
swc_hub_CM4.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   00000298  08100000  08100000  00010000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         0001c410  081002a0  081002a0  000102a0  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       00003454  0811c6b0  0811c6b0  0002c6b0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .ARM          00000008  0811fb04  0811fb04  0002fb04  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .init_array   00000004  0811fb0c  0811fb0c  0002fb0c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .fini_array   00000004  0811fb10  0811fb10  0002fb10  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  6 .data         000001c0  10000000  0811fb14  00030000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  7 .RxDecripSection 00000060  100001c0  0811fcd4  000301c0  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  8 .TxDecripSection 00000060  10000220  0811fd34  00030220  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  9 .bss          00008d48  10000280  0811fd94  00030280  2**2
                  ALLOC
 10 ._user_heap_stack 00000600  10008fc8  0811fd94  00038fc8  2**0
                  ALLOC
 11 .ARM.attributes 00000030  00000000  00000000  00030280  2**0
                  CONTENTS, READONLY
 12 .comment      00000043  00000000  00000000  000302b0  2**0
                  CONTENTS, READONLY
 13 .debug_info   000392d0  00000000  00000000  000302f3  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 14 .debug_abbrev 000084a1  00000000  00000000  000695c3  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 15 .debug_aranges 00002960  00000000  00000000  00071a68  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 16 .debug_rnglists 00002095  00000000  00000000  000743c8  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 17 .debug_macro  0004ef07  00000000  00000000  0007645d  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 18 .debug_line   00044645  00000000  00000000  000c5364  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 19 .debug_str    001b8302  00000000  00000000  001099a9  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 20 .debug_frame  0000b7a8  00000000  00000000  002c1cac  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 21 .debug_line_str 00000068  00000000  00000000  002cd454  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS

Disassembly of section .text:

081002a0 <__do_global_dtors_aux>:
 81002a0:	b510      	push	{r4, lr}
 81002a2:	4c05      	ldr	r4, [pc, #20]	; (81002b8 <__do_global_dtors_aux+0x18>)
 81002a4:	7823      	ldrb	r3, [r4, #0]
 81002a6:	b933      	cbnz	r3, 81002b6 <__do_global_dtors_aux+0x16>
 81002a8:	4b04      	ldr	r3, [pc, #16]	; (81002bc <__do_global_dtors_aux+0x1c>)
 81002aa:	b113      	cbz	r3, 81002b2 <__do_global_dtors_aux+0x12>
 81002ac:	4804      	ldr	r0, [pc, #16]	; (81002c0 <__do_global_dtors_aux+0x20>)
 81002ae:	f3af 8000 	nop.w
 81002b2:	2301      	movs	r3, #1
 81002b4:	7023      	strb	r3, [r4, #0]
 81002b6:	bd10      	pop	{r4, pc}
 81002b8:	10000280 	.word	0x10000280
 81002bc:	00000000 	.word	0x00000000
 81002c0:	0811c698 	.word	0x0811c698

081002c4 <frame_dummy>:
 81002c4:	b508      	push	{r3, lr}
 81002c6:	4b03      	ldr	r3, [pc, #12]	; (81002d4 <frame_dummy+0x10>)
 81002c8:	b11b      	cbz	r3, 81002d2 <frame_dummy+0xe>
 81002ca:	4903      	ldr	r1, [pc, #12]	; (81002d8 <frame_dummy+0x14>)
 81002cc:	4803      	ldr	r0, [pc, #12]	; (81002dc <frame_dummy+0x18>)
 81002ce:	f3af 8000 	nop.w
 81002d2:	bd08      	pop	{r3, pc}
 81002d4:	00000000 	.word	0x00000000
 81002d8:	10000284 	.word	0x10000284
 81002dc:	0811c698 	.word	0x0811c698

081002e0 <strlen>:
 81002e0:	4603      	mov	r3, r0
 81002e2:	f813 2b01 	ldrb.w	r2, [r3], #1
 81002e6:	2a00      	cmp	r2, #0
 81002e8:	d1fb      	bne.n	81002e2 <strlen+0x2>
 81002ea:	1a18      	subs	r0, r3, r0
 81002ec:	3801      	subs	r0, #1
 81002ee:	4770      	bx	lr

081002f0 <memchr>:
 81002f0:	f001 01ff 	and.w	r1, r1, #255	; 0xff
 81002f4:	2a10      	cmp	r2, #16
 81002f6:	db2b      	blt.n	8100350 <memchr+0x60>
 81002f8:	f010 0f07 	tst.w	r0, #7
 81002fc:	d008      	beq.n	8100310 <memchr+0x20>
 81002fe:	f810 3b01 	ldrb.w	r3, [r0], #1
 8100302:	3a01      	subs	r2, #1
 8100304:	428b      	cmp	r3, r1
 8100306:	d02d      	beq.n	8100364 <memchr+0x74>
 8100308:	f010 0f07 	tst.w	r0, #7
 810030c:	b342      	cbz	r2, 8100360 <memchr+0x70>
 810030e:	d1f6      	bne.n	81002fe <memchr+0xe>
 8100310:	b4f0      	push	{r4, r5, r6, r7}
 8100312:	ea41 2101 	orr.w	r1, r1, r1, lsl #8
 8100316:	ea41 4101 	orr.w	r1, r1, r1, lsl #16
 810031a:	f022 0407 	bic.w	r4, r2, #7
 810031e:	f07f 0700 	mvns.w	r7, #0
 8100322:	2300      	movs	r3, #0
 8100324:	e8f0 5602 	ldrd	r5, r6, [r0], #8
 8100328:	3c08      	subs	r4, #8
 810032a:	ea85 0501 	eor.w	r5, r5, r1
 810032e:	ea86 0601 	eor.w	r6, r6, r1
 8100332:	fa85 f547 	uadd8	r5, r5, r7
 8100336:	faa3 f587 	sel	r5, r3, r7
 810033a:	fa86 f647 	uadd8	r6, r6, r7
 810033e:	faa5 f687 	sel	r6, r5, r7
 8100342:	b98e      	cbnz	r6, 8100368 <memchr+0x78>
 8100344:	d1ee      	bne.n	8100324 <memchr+0x34>
 8100346:	bcf0      	pop	{r4, r5, r6, r7}
 8100348:	f001 01ff 	and.w	r1, r1, #255	; 0xff
 810034c:	f002 0207 	and.w	r2, r2, #7
 8100350:	b132      	cbz	r2, 8100360 <memchr+0x70>
 8100352:	f810 3b01 	ldrb.w	r3, [r0], #1
 8100356:	3a01      	subs	r2, #1
 8100358:	ea83 0301 	eor.w	r3, r3, r1
 810035c:	b113      	cbz	r3, 8100364 <memchr+0x74>
 810035e:	d1f8      	bne.n	8100352 <memchr+0x62>
 8100360:	2000      	movs	r0, #0
 8100362:	4770      	bx	lr
 8100364:	3801      	subs	r0, #1
 8100366:	4770      	bx	lr
 8100368:	2d00      	cmp	r5, #0
 810036a:	bf06      	itte	eq
 810036c:	4635      	moveq	r5, r6
 810036e:	3803      	subeq	r0, #3
 8100370:	3807      	subne	r0, #7
 8100372:	f015 0f01 	tst.w	r5, #1
 8100376:	d107      	bne.n	8100388 <memchr+0x98>
 8100378:	3001      	adds	r0, #1
 810037a:	f415 7f80 	tst.w	r5, #256	; 0x100
 810037e:	bf02      	ittt	eq
 8100380:	3001      	addeq	r0, #1
 8100382:	f415 3fc0 	tsteq.w	r5, #98304	; 0x18000
 8100386:	3001      	addeq	r0, #1
 8100388:	bcf0      	pop	{r4, r5, r6, r7}
 810038a:	3801      	subs	r0, #1
 810038c:	4770      	bx	lr
 810038e:	bf00      	nop

08100390 <__aeabi_uldivmod>:
 8100390:	b953      	cbnz	r3, 81003a8 <__aeabi_uldivmod+0x18>
 8100392:	b94a      	cbnz	r2, 81003a8 <__aeabi_uldivmod+0x18>
 8100394:	2900      	cmp	r1, #0
 8100396:	bf08      	it	eq
 8100398:	2800      	cmpeq	r0, #0
 810039a:	bf1c      	itt	ne
 810039c:	f04f 31ff 	movne.w	r1, #4294967295	; 0xffffffff
 81003a0:	f04f 30ff 	movne.w	r0, #4294967295	; 0xffffffff
 81003a4:	f000 b970 	b.w	8100688 <__aeabi_idiv0>
 81003a8:	f1ad 0c08 	sub.w	ip, sp, #8
 81003ac:	e96d ce04 	strd	ip, lr, [sp, #-16]!
 81003b0:	f000 f806 	bl	81003c0 <__udivmoddi4>
 81003b4:	f8dd e004 	ldr.w	lr, [sp, #4]
 81003b8:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 81003bc:	b004      	add	sp, #16
 81003be:	4770      	bx	lr

081003c0 <__udivmoddi4>:
 81003c0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 81003c4:	9e08      	ldr	r6, [sp, #32]
 81003c6:	460d      	mov	r5, r1
 81003c8:	4604      	mov	r4, r0
 81003ca:	460f      	mov	r7, r1
 81003cc:	2b00      	cmp	r3, #0
 81003ce:	d14a      	bne.n	8100466 <__udivmoddi4+0xa6>
 81003d0:	428a      	cmp	r2, r1
 81003d2:	4694      	mov	ip, r2
 81003d4:	d965      	bls.n	81004a2 <__udivmoddi4+0xe2>
 81003d6:	fab2 f382 	clz	r3, r2
 81003da:	b143      	cbz	r3, 81003ee <__udivmoddi4+0x2e>
 81003dc:	fa02 fc03 	lsl.w	ip, r2, r3
 81003e0:	f1c3 0220 	rsb	r2, r3, #32
 81003e4:	409f      	lsls	r7, r3
 81003e6:	fa20 f202 	lsr.w	r2, r0, r2
 81003ea:	4317      	orrs	r7, r2
 81003ec:	409c      	lsls	r4, r3
 81003ee:	ea4f 4e1c 	mov.w	lr, ip, lsr #16
 81003f2:	fa1f f58c 	uxth.w	r5, ip
 81003f6:	fbb7 f1fe 	udiv	r1, r7, lr
 81003fa:	0c22      	lsrs	r2, r4, #16
 81003fc:	fb0e 7711 	mls	r7, lr, r1, r7
 8100400:	ea42 4207 	orr.w	r2, r2, r7, lsl #16
 8100404:	fb01 f005 	mul.w	r0, r1, r5
 8100408:	4290      	cmp	r0, r2
 810040a:	d90a      	bls.n	8100422 <__udivmoddi4+0x62>
 810040c:	eb1c 0202 	adds.w	r2, ip, r2
 8100410:	f101 37ff 	add.w	r7, r1, #4294967295	; 0xffffffff
 8100414:	f080 811c 	bcs.w	8100650 <__udivmoddi4+0x290>
 8100418:	4290      	cmp	r0, r2
 810041a:	f240 8119 	bls.w	8100650 <__udivmoddi4+0x290>
 810041e:	3902      	subs	r1, #2
 8100420:	4462      	add	r2, ip
 8100422:	1a12      	subs	r2, r2, r0
 8100424:	b2a4      	uxth	r4, r4
 8100426:	fbb2 f0fe 	udiv	r0, r2, lr
 810042a:	fb0e 2210 	mls	r2, lr, r0, r2
 810042e:	ea44 4402 	orr.w	r4, r4, r2, lsl #16
 8100432:	fb00 f505 	mul.w	r5, r0, r5
 8100436:	42a5      	cmp	r5, r4
 8100438:	d90a      	bls.n	8100450 <__udivmoddi4+0x90>
 810043a:	eb1c 0404 	adds.w	r4, ip, r4
 810043e:	f100 32ff 	add.w	r2, r0, #4294967295	; 0xffffffff
 8100442:	f080 8107 	bcs.w	8100654 <__udivmoddi4+0x294>
 8100446:	42a5      	cmp	r5, r4
 8100448:	f240 8104 	bls.w	8100654 <__udivmoddi4+0x294>
 810044c:	4464      	add	r4, ip
 810044e:	3802      	subs	r0, #2
 8100450:	ea40 4001 	orr.w	r0, r0, r1, lsl #16
 8100454:	1b64      	subs	r4, r4, r5
 8100456:	2100      	movs	r1, #0
 8100458:	b11e      	cbz	r6, 8100462 <__udivmoddi4+0xa2>
 810045a:	40dc      	lsrs	r4, r3
 810045c:	2300      	movs	r3, #0
 810045e:	e9c6 4300 	strd	r4, r3, [r6]
 8100462:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8100466:	428b      	cmp	r3, r1
 8100468:	d908      	bls.n	810047c <__udivmoddi4+0xbc>
 810046a:	2e00      	cmp	r6, #0
 810046c:	f000 80ed 	beq.w	810064a <__udivmoddi4+0x28a>
 8100470:	2100      	movs	r1, #0
 8100472:	e9c6 0500 	strd	r0, r5, [r6]
 8100476:	4608      	mov	r0, r1
 8100478:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 810047c:	fab3 f183 	clz	r1, r3
 8100480:	2900      	cmp	r1, #0
 8100482:	d149      	bne.n	8100518 <__udivmoddi4+0x158>
 8100484:	42ab      	cmp	r3, r5
 8100486:	d302      	bcc.n	810048e <__udivmoddi4+0xce>
 8100488:	4282      	cmp	r2, r0
 810048a:	f200 80f8 	bhi.w	810067e <__udivmoddi4+0x2be>
 810048e:	1a84      	subs	r4, r0, r2
 8100490:	eb65 0203 	sbc.w	r2, r5, r3
 8100494:	2001      	movs	r0, #1
 8100496:	4617      	mov	r7, r2
 8100498:	2e00      	cmp	r6, #0
 810049a:	d0e2      	beq.n	8100462 <__udivmoddi4+0xa2>
 810049c:	e9c6 4700 	strd	r4, r7, [r6]
 81004a0:	e7df      	b.n	8100462 <__udivmoddi4+0xa2>
 81004a2:	b902      	cbnz	r2, 81004a6 <__udivmoddi4+0xe6>
 81004a4:	deff      	udf	#255	; 0xff
 81004a6:	fab2 f382 	clz	r3, r2
 81004aa:	2b00      	cmp	r3, #0
 81004ac:	f040 8090 	bne.w	81005d0 <__udivmoddi4+0x210>
 81004b0:	1a8a      	subs	r2, r1, r2
 81004b2:	ea4f 471c 	mov.w	r7, ip, lsr #16
 81004b6:	fa1f fe8c 	uxth.w	lr, ip
 81004ba:	2101      	movs	r1, #1
 81004bc:	fbb2 f5f7 	udiv	r5, r2, r7
 81004c0:	fb07 2015 	mls	r0, r7, r5, r2
 81004c4:	0c22      	lsrs	r2, r4, #16
 81004c6:	ea42 4200 	orr.w	r2, r2, r0, lsl #16
 81004ca:	fb0e f005 	mul.w	r0, lr, r5
 81004ce:	4290      	cmp	r0, r2
 81004d0:	d908      	bls.n	81004e4 <__udivmoddi4+0x124>
 81004d2:	eb1c 0202 	adds.w	r2, ip, r2
 81004d6:	f105 38ff 	add.w	r8, r5, #4294967295	; 0xffffffff
 81004da:	d202      	bcs.n	81004e2 <__udivmoddi4+0x122>
 81004dc:	4290      	cmp	r0, r2
 81004de:	f200 80cb 	bhi.w	8100678 <__udivmoddi4+0x2b8>
 81004e2:	4645      	mov	r5, r8
 81004e4:	1a12      	subs	r2, r2, r0
 81004e6:	b2a4      	uxth	r4, r4
 81004e8:	fbb2 f0f7 	udiv	r0, r2, r7
 81004ec:	fb07 2210 	mls	r2, r7, r0, r2
 81004f0:	ea44 4402 	orr.w	r4, r4, r2, lsl #16
 81004f4:	fb0e fe00 	mul.w	lr, lr, r0
 81004f8:	45a6      	cmp	lr, r4
 81004fa:	d908      	bls.n	810050e <__udivmoddi4+0x14e>
 81004fc:	eb1c 0404 	adds.w	r4, ip, r4
 8100500:	f100 32ff 	add.w	r2, r0, #4294967295	; 0xffffffff
 8100504:	d202      	bcs.n	810050c <__udivmoddi4+0x14c>
 8100506:	45a6      	cmp	lr, r4
 8100508:	f200 80bb 	bhi.w	8100682 <__udivmoddi4+0x2c2>
 810050c:	4610      	mov	r0, r2
 810050e:	eba4 040e 	sub.w	r4, r4, lr
 8100512:	ea40 4005 	orr.w	r0, r0, r5, lsl #16
 8100516:	e79f      	b.n	8100458 <__udivmoddi4+0x98>
 8100518:	f1c1 0720 	rsb	r7, r1, #32
 810051c:	408b      	lsls	r3, r1
 810051e:	fa22 fc07 	lsr.w	ip, r2, r7
 8100522:	ea4c 0c03 	orr.w	ip, ip, r3
 8100526:	fa05 f401 	lsl.w	r4, r5, r1
 810052a:	fa20 f307 	lsr.w	r3, r0, r7
 810052e:	40fd      	lsrs	r5, r7
 8100530:	ea4f 491c 	mov.w	r9, ip, lsr #16
 8100534:	4323      	orrs	r3, r4
 8100536:	fbb5 f8f9 	udiv	r8, r5, r9
 810053a:	fa1f fe8c 	uxth.w	lr, ip
 810053e:	fb09 5518 	mls	r5, r9, r8, r5
 8100542:	0c1c      	lsrs	r4, r3, #16
 8100544:	ea44 4405 	orr.w	r4, r4, r5, lsl #16
 8100548:	fb08 f50e 	mul.w	r5, r8, lr
 810054c:	42a5      	cmp	r5, r4
 810054e:	fa02 f201 	lsl.w	r2, r2, r1
 8100552:	fa00 f001 	lsl.w	r0, r0, r1
 8100556:	d90b      	bls.n	8100570 <__udivmoddi4+0x1b0>
 8100558:	eb1c 0404 	adds.w	r4, ip, r4
 810055c:	f108 3aff 	add.w	sl, r8, #4294967295	; 0xffffffff
 8100560:	f080 8088 	bcs.w	8100674 <__udivmoddi4+0x2b4>
 8100564:	42a5      	cmp	r5, r4
 8100566:	f240 8085 	bls.w	8100674 <__udivmoddi4+0x2b4>
 810056a:	f1a8 0802 	sub.w	r8, r8, #2
 810056e:	4464      	add	r4, ip
 8100570:	1b64      	subs	r4, r4, r5
 8100572:	b29d      	uxth	r5, r3
 8100574:	fbb4 f3f9 	udiv	r3, r4, r9
 8100578:	fb09 4413 	mls	r4, r9, r3, r4
 810057c:	ea45 4404 	orr.w	r4, r5, r4, lsl #16
 8100580:	fb03 fe0e 	mul.w	lr, r3, lr
 8100584:	45a6      	cmp	lr, r4
 8100586:	d908      	bls.n	810059a <__udivmoddi4+0x1da>
 8100588:	eb1c 0404 	adds.w	r4, ip, r4
 810058c:	f103 35ff 	add.w	r5, r3, #4294967295	; 0xffffffff
 8100590:	d26c      	bcs.n	810066c <__udivmoddi4+0x2ac>
 8100592:	45a6      	cmp	lr, r4
 8100594:	d96a      	bls.n	810066c <__udivmoddi4+0x2ac>
 8100596:	3b02      	subs	r3, #2
 8100598:	4464      	add	r4, ip
 810059a:	ea43 4308 	orr.w	r3, r3, r8, lsl #16
 810059e:	fba3 9502 	umull	r9, r5, r3, r2
 81005a2:	eba4 040e 	sub.w	r4, r4, lr
 81005a6:	42ac      	cmp	r4, r5
 81005a8:	46c8      	mov	r8, r9
 81005aa:	46ae      	mov	lr, r5
 81005ac:	d356      	bcc.n	810065c <__udivmoddi4+0x29c>
 81005ae:	d053      	beq.n	8100658 <__udivmoddi4+0x298>
 81005b0:	b156      	cbz	r6, 81005c8 <__udivmoddi4+0x208>
 81005b2:	ebb0 0208 	subs.w	r2, r0, r8
 81005b6:	eb64 040e 	sbc.w	r4, r4, lr
 81005ba:	fa04 f707 	lsl.w	r7, r4, r7
 81005be:	40ca      	lsrs	r2, r1
 81005c0:	40cc      	lsrs	r4, r1
 81005c2:	4317      	orrs	r7, r2
 81005c4:	e9c6 7400 	strd	r7, r4, [r6]
 81005c8:	4618      	mov	r0, r3
 81005ca:	2100      	movs	r1, #0
 81005cc:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 81005d0:	f1c3 0120 	rsb	r1, r3, #32
 81005d4:	fa02 fc03 	lsl.w	ip, r2, r3
 81005d8:	fa20 f201 	lsr.w	r2, r0, r1
 81005dc:	fa25 f101 	lsr.w	r1, r5, r1
 81005e0:	409d      	lsls	r5, r3
 81005e2:	432a      	orrs	r2, r5
 81005e4:	ea4f 471c 	mov.w	r7, ip, lsr #16
 81005e8:	fa1f fe8c 	uxth.w	lr, ip
 81005ec:	fbb1 f0f7 	udiv	r0, r1, r7
 81005f0:	fb07 1510 	mls	r5, r7, r0, r1
 81005f4:	0c11      	lsrs	r1, r2, #16
 81005f6:	ea41 4105 	orr.w	r1, r1, r5, lsl #16
 81005fa:	fb00 f50e 	mul.w	r5, r0, lr
 81005fe:	428d      	cmp	r5, r1
 8100600:	fa04 f403 	lsl.w	r4, r4, r3
 8100604:	d908      	bls.n	8100618 <__udivmoddi4+0x258>
 8100606:	eb1c 0101 	adds.w	r1, ip, r1
 810060a:	f100 38ff 	add.w	r8, r0, #4294967295	; 0xffffffff
 810060e:	d22f      	bcs.n	8100670 <__udivmoddi4+0x2b0>
 8100610:	428d      	cmp	r5, r1
 8100612:	d92d      	bls.n	8100670 <__udivmoddi4+0x2b0>
 8100614:	3802      	subs	r0, #2
 8100616:	4461      	add	r1, ip
 8100618:	1b49      	subs	r1, r1, r5
 810061a:	b292      	uxth	r2, r2
 810061c:	fbb1 f5f7 	udiv	r5, r1, r7
 8100620:	fb07 1115 	mls	r1, r7, r5, r1
 8100624:	ea42 4201 	orr.w	r2, r2, r1, lsl #16
 8100628:	fb05 f10e 	mul.w	r1, r5, lr
 810062c:	4291      	cmp	r1, r2
 810062e:	d908      	bls.n	8100642 <__udivmoddi4+0x282>
 8100630:	eb1c 0202 	adds.w	r2, ip, r2
 8100634:	f105 38ff 	add.w	r8, r5, #4294967295	; 0xffffffff
 8100638:	d216      	bcs.n	8100668 <__udivmoddi4+0x2a8>
 810063a:	4291      	cmp	r1, r2
 810063c:	d914      	bls.n	8100668 <__udivmoddi4+0x2a8>
 810063e:	3d02      	subs	r5, #2
 8100640:	4462      	add	r2, ip
 8100642:	1a52      	subs	r2, r2, r1
 8100644:	ea45 4100 	orr.w	r1, r5, r0, lsl #16
 8100648:	e738      	b.n	81004bc <__udivmoddi4+0xfc>
 810064a:	4631      	mov	r1, r6
 810064c:	4630      	mov	r0, r6
 810064e:	e708      	b.n	8100462 <__udivmoddi4+0xa2>
 8100650:	4639      	mov	r1, r7
 8100652:	e6e6      	b.n	8100422 <__udivmoddi4+0x62>
 8100654:	4610      	mov	r0, r2
 8100656:	e6fb      	b.n	8100450 <__udivmoddi4+0x90>
 8100658:	4548      	cmp	r0, r9
 810065a:	d2a9      	bcs.n	81005b0 <__udivmoddi4+0x1f0>
 810065c:	ebb9 0802 	subs.w	r8, r9, r2
 8100660:	eb65 0e0c 	sbc.w	lr, r5, ip
 8100664:	3b01      	subs	r3, #1
 8100666:	e7a3      	b.n	81005b0 <__udivmoddi4+0x1f0>
 8100668:	4645      	mov	r5, r8
 810066a:	e7ea      	b.n	8100642 <__udivmoddi4+0x282>
 810066c:	462b      	mov	r3, r5
 810066e:	e794      	b.n	810059a <__udivmoddi4+0x1da>
 8100670:	4640      	mov	r0, r8
 8100672:	e7d1      	b.n	8100618 <__udivmoddi4+0x258>
 8100674:	46d0      	mov	r8, sl
 8100676:	e77b      	b.n	8100570 <__udivmoddi4+0x1b0>
 8100678:	3d02      	subs	r5, #2
 810067a:	4462      	add	r2, ip
 810067c:	e732      	b.n	81004e4 <__udivmoddi4+0x124>
 810067e:	4608      	mov	r0, r1
 8100680:	e70a      	b.n	8100498 <__udivmoddi4+0xd8>
 8100682:	4464      	add	r4, ip
 8100684:	3802      	subs	r0, #2
 8100686:	e742      	b.n	810050e <__udivmoddi4+0x14e>

08100688 <__aeabi_idiv0>:
 8100688:	4770      	bx	lr
 810068a:	bf00      	nop

0810068c <SystemInit>:
  *         configuration.
  * @param  None
  * @retval None
  */
void SystemInit (void)
{
 810068c:	b480      	push	{r7}
 810068e:	af00      	add	r7, sp, #0
  /* FPU settings ------------------------------------------------------------*/
  #if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
    SCB->CPACR |= ((3UL << (10*2))|(3UL << (11*2)));  /* set CP10 and CP11 Full Access */
 8100690:	4b09      	ldr	r3, [pc, #36]	; (81006b8 <SystemInit+0x2c>)
 8100692:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 8100696:	4a08      	ldr	r2, [pc, #32]	; (81006b8 <SystemInit+0x2c>)
 8100698:	f443 0370 	orr.w	r3, r3, #15728640	; 0xf00000
 810069c:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88
  #endif

    /*SEVONPEND enabled so that an interrupt coming from the CPU(n) interrupt signal is
     detectable by the CPU after a WFI/WFE instruction.*/
 SCB->SCR |= SCB_SCR_SEVONPEND_Msk;
 81006a0:	4b05      	ldr	r3, [pc, #20]	; (81006b8 <SystemInit+0x2c>)
 81006a2:	691b      	ldr	r3, [r3, #16]
 81006a4:	4a04      	ldr	r2, [pc, #16]	; (81006b8 <SystemInit+0x2c>)
 81006a6:	f043 0310 	orr.w	r3, r3, #16
 81006aa:	6113      	str	r3, [r2, #16]
#endif /* USER_VECT_TAB_ADDRESS */

#else
#error Please #define CORE_CM4 or CORE_CM7
#endif /* CORE_CM4 */
}
 81006ac:	bf00      	nop
 81006ae:	46bd      	mov	sp, r7
 81006b0:	f85d 7b04 	ldr.w	r7, [sp], #4
 81006b4:	4770      	bx	lr
 81006b6:	bf00      	nop
 81006b8:	e000ed00 	.word	0xe000ed00

081006bc <main>:
/**
  * @brief  The application entry point.
  * @retval int
  */
int main(void)
{
 81006bc:	b580      	push	{r7, lr}
 81006be:	b082      	sub	sp, #8
 81006c0:	af00      	add	r7, sp, #0

  /* USER CODE END 1 */

/* USER CODE BEGIN Boot_Mode_Sequence_1 */
  /*HW semaphore Clock enable*/
  __HAL_RCC_HSEM_CLK_ENABLE();
 81006c2:	4b32      	ldr	r3, [pc, #200]	; (810078c <main+0xd0>)
 81006c4:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
 81006c8:	4a30      	ldr	r2, [pc, #192]	; (810078c <main+0xd0>)
 81006ca:	f043 7300 	orr.w	r3, r3, #33554432	; 0x2000000
 81006ce:	f8c2 30e0 	str.w	r3, [r2, #224]	; 0xe0
 81006d2:	4b2e      	ldr	r3, [pc, #184]	; (810078c <main+0xd0>)
 81006d4:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
 81006d8:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 81006dc:	607b      	str	r3, [r7, #4]
 81006de:	687b      	ldr	r3, [r7, #4]
  /* Activate HSEM notification for Cortex-M4*/
  HAL_HSEM_ActivateNotification(__HAL_HSEM_SEMID_TO_MASK(HSEM_ID_0));
 81006e0:	2001      	movs	r0, #1
 81006e2:	f005 f83f 	bl	8105764 <HAL_HSEM_ActivateNotification>
  /*
  Domain D2 goes to STOP mode (Cortex-M4 in deep-sleep) waiting for Cortex-M7 to
  perform system initialization (system clock config, external memory configuration.. )
  */
  HAL_PWREx_ClearPendingEvent();
 81006e6:	f006 fb4f 	bl	8106d88 <HAL_PWREx_ClearPendingEvent>
  HAL_PWREx_EnterSTOPMode(PWR_MAINREGULATOR_ON, PWR_STOPENTRY_WFE, PWR_D2_DOMAIN);
 81006ea:	2201      	movs	r2, #1
 81006ec:	2102      	movs	r1, #2
 81006ee:	2000      	movs	r0, #0
 81006f0:	f006 fad0 	bl	8106c94 <HAL_PWREx_EnterSTOPMode>
  /* Clear HSEM flag */
  __HAL_HSEM_CLEAR_FLAG(__HAL_HSEM_SEMID_TO_MASK(HSEM_ID_0));
 81006f4:	4b26      	ldr	r3, [pc, #152]	; (8100790 <main+0xd4>)
 81006f6:	681b      	ldr	r3, [r3, #0]
 81006f8:	091b      	lsrs	r3, r3, #4
 81006fa:	f003 030f 	and.w	r3, r3, #15
 81006fe:	2b07      	cmp	r3, #7
 8100700:	d108      	bne.n	8100714 <main+0x58>
 8100702:	4b24      	ldr	r3, [pc, #144]	; (8100794 <main+0xd8>)
 8100704:	f8d3 3104 	ldr.w	r3, [r3, #260]	; 0x104
 8100708:	4a22      	ldr	r2, [pc, #136]	; (8100794 <main+0xd8>)
 810070a:	f043 0301 	orr.w	r3, r3, #1
 810070e:	f8c2 3104 	str.w	r3, [r2, #260]	; 0x104
 8100712:	e007      	b.n	8100724 <main+0x68>
 8100714:	4b1f      	ldr	r3, [pc, #124]	; (8100794 <main+0xd8>)
 8100716:	f8d3 3114 	ldr.w	r3, [r3, #276]	; 0x114
 810071a:	4a1e      	ldr	r2, [pc, #120]	; (8100794 <main+0xd8>)
 810071c:	f043 0301 	orr.w	r3, r3, #1
 8100720:	f8c2 3114 	str.w	r3, [r2, #276]	; 0x114

/* USER CODE END Boot_Mode_Sequence_1 */
  /* MCU Configuration--------------------------------------------------------*/

  /* Reset of all peripherals, Initializes the Flash interface and the Systick. */
  HAL_Init();
 8100724:	f000 fee2 	bl	81014ec <HAL_Init>
  /* USER CODE BEGIN SysInit */

  /* USER CODE END SysInit */

  /* Initialize all configured peripherals */
  MX_GPIO_Init();
 8100728:	f000 f948 	bl	81009bc <MX_GPIO_Init>
  MX_ADC2_Init();
 810072c:	f000 f836 	bl	810079c <MX_ADC2_Init>
  MX_LWIP_Init();
 8100730:	f00b fdd6 	bl	810c2e0 <MX_LWIP_Init>
  MX_USB_DEVICE_Init();
 8100734:	f01a fb04 	bl	811ad40 <MX_USB_DEVICE_Init>
  MX_FDCAN1_Init();
 8100738:	f000 f8da 	bl	81008f0 <MX_FDCAN1_Init>
  /* USER CODE BEGIN 2 */

  /* USER CODE END 2 */

  /* Initialize leds */
  BSP_LED_Init(LED_GREEN);
 810073c:	2000      	movs	r0, #0
 810073e:	f000 fcf1 	bl	8101124 <BSP_LED_Init>
  BSP_LED_Init(LED_YELLOW);
 8100742:	2001      	movs	r0, #1
 8100744:	f000 fcee 	bl	8101124 <BSP_LED_Init>
  BSP_LED_Init(LED_RED);
 8100748:	2002      	movs	r0, #2
 810074a:	f000 fceb 	bl	8101124 <BSP_LED_Init>

  /* Initialize USER push-button, will be used to trigger an interrupt each time it's pressed.*/
  BSP_PB_Init(BUTTON_USER, BUTTON_MODE_EXTI);
 810074e:	2101      	movs	r1, #1
 8100750:	2000      	movs	r0, #0
 8100752:	f000 fd5d 	bl	8101210 <BSP_PB_Init>

  /* Initialize COM1 port (115200, 8 bits (7-bit data + 1 stop bit), no parity */
  BspCOMInit.BaudRate   = 115200;
 8100756:	4b10      	ldr	r3, [pc, #64]	; (8100798 <main+0xdc>)
 8100758:	f44f 32e1 	mov.w	r2, #115200	; 0x1c200
 810075c:	601a      	str	r2, [r3, #0]
  BspCOMInit.WordLength = COM_WORDLENGTH_8B;
 810075e:	4b0e      	ldr	r3, [pc, #56]	; (8100798 <main+0xdc>)
 8100760:	2200      	movs	r2, #0
 8100762:	605a      	str	r2, [r3, #4]
  BspCOMInit.StopBits   = COM_STOPBITS_1;
 8100764:	4b0c      	ldr	r3, [pc, #48]	; (8100798 <main+0xdc>)
 8100766:	2200      	movs	r2, #0
 8100768:	811a      	strh	r2, [r3, #8]
  BspCOMInit.Parity     = COM_PARITY_NONE;
 810076a:	4b0b      	ldr	r3, [pc, #44]	; (8100798 <main+0xdc>)
 810076c:	2200      	movs	r2, #0
 810076e:	815a      	strh	r2, [r3, #10]
  BspCOMInit.HwFlowCtl  = COM_HWCONTROL_NONE;
 8100770:	4b09      	ldr	r3, [pc, #36]	; (8100798 <main+0xdc>)
 8100772:	2200      	movs	r2, #0
 8100774:	819a      	strh	r2, [r3, #12]
  if (BSP_COM_Init(COM1, &BspCOMInit) != BSP_ERROR_NONE)
 8100776:	4908      	ldr	r1, [pc, #32]	; (8100798 <main+0xdc>)
 8100778:	2000      	movs	r0, #0
 810077a:	f000 fdd9 	bl	8101330 <BSP_COM_Init>
 810077e:	4603      	mov	r3, r0
 8100780:	2b00      	cmp	r3, #0
 8100782:	d001      	beq.n	8100788 <main+0xcc>
  {
    Error_Handler();
 8100784:	f000 f970 	bl	8100a68 <Error_Handler>
  }

  /* Infinite loop */
  /* USER CODE BEGIN WHILE */
  while (1)
 8100788:	e7fe      	b.n	8100788 <main+0xcc>
 810078a:	bf00      	nop
 810078c:	58024400 	.word	0x58024400
 8100790:	e000ed00 	.word	0xe000ed00
 8100794:	58026400 	.word	0x58026400
 8100798:	1000029c 	.word	0x1000029c

0810079c <MX_ADC2_Init>:
  * @brief ADC2 Initialization Function
  * @param None
  * @retval None
  */
static void MX_ADC2_Init(void)
{
 810079c:	b580      	push	{r7, lr}
 810079e:	b096      	sub	sp, #88	; 0x58
 81007a0:	af00      	add	r7, sp, #0

  /* USER CODE BEGIN ADC2_Init 0 */

  /* USER CODE END ADC2_Init 0 */

  ADC_ChannelConfTypeDef sConfig = {0};
 81007a2:	f107 033c 	add.w	r3, r7, #60	; 0x3c
 81007a6:	2200      	movs	r2, #0
 81007a8:	601a      	str	r2, [r3, #0]
 81007aa:	605a      	str	r2, [r3, #4]
 81007ac:	609a      	str	r2, [r3, #8]
 81007ae:	60da      	str	r2, [r3, #12]
 81007b0:	611a      	str	r2, [r3, #16]
 81007b2:	615a      	str	r2, [r3, #20]
 81007b4:	619a      	str	r2, [r3, #24]
  ADC_InjectionConfTypeDef sConfigInjected = {0};
 81007b6:	463b      	mov	r3, r7
 81007b8:	223c      	movs	r2, #60	; 0x3c
 81007ba:	2100      	movs	r1, #0
 81007bc:	4618      	mov	r0, r3
 81007be:	f01b f849 	bl	811b854 <memset>

  /* USER CODE END ADC2_Init 1 */

  /** Common config
  */
  hadc2.Instance = ADC2;
 81007c2:	4b48      	ldr	r3, [pc, #288]	; (81008e4 <MX_ADC2_Init+0x148>)
 81007c4:	4a48      	ldr	r2, [pc, #288]	; (81008e8 <MX_ADC2_Init+0x14c>)
 81007c6:	601a      	str	r2, [r3, #0]
  hadc2.Init.ClockPrescaler = ADC_CLOCK_ASYNC_DIV2;
 81007c8:	4b46      	ldr	r3, [pc, #280]	; (81008e4 <MX_ADC2_Init+0x148>)
 81007ca:	f44f 2280 	mov.w	r2, #262144	; 0x40000
 81007ce:	605a      	str	r2, [r3, #4]
  hadc2.Init.Resolution = ADC_RESOLUTION_16B;
 81007d0:	4b44      	ldr	r3, [pc, #272]	; (81008e4 <MX_ADC2_Init+0x148>)
 81007d2:	2200      	movs	r2, #0
 81007d4:	609a      	str	r2, [r3, #8]
  hadc2.Init.ScanConvMode = ADC_SCAN_ENABLE;
 81007d6:	4b43      	ldr	r3, [pc, #268]	; (81008e4 <MX_ADC2_Init+0x148>)
 81007d8:	2201      	movs	r2, #1
 81007da:	60da      	str	r2, [r3, #12]
  hadc2.Init.EOCSelection = ADC_EOC_SINGLE_CONV;
 81007dc:	4b41      	ldr	r3, [pc, #260]	; (81008e4 <MX_ADC2_Init+0x148>)
 81007de:	2204      	movs	r2, #4
 81007e0:	611a      	str	r2, [r3, #16]
  hadc2.Init.LowPowerAutoWait = DISABLE;
 81007e2:	4b40      	ldr	r3, [pc, #256]	; (81008e4 <MX_ADC2_Init+0x148>)
 81007e4:	2200      	movs	r2, #0
 81007e6:	751a      	strb	r2, [r3, #20]
  hadc2.Init.ContinuousConvMode = DISABLE;
 81007e8:	4b3e      	ldr	r3, [pc, #248]	; (81008e4 <MX_ADC2_Init+0x148>)
 81007ea:	2200      	movs	r2, #0
 81007ec:	755a      	strb	r2, [r3, #21]
  hadc2.Init.NbrOfConversion = 1;
 81007ee:	4b3d      	ldr	r3, [pc, #244]	; (81008e4 <MX_ADC2_Init+0x148>)
 81007f0:	2201      	movs	r2, #1
 81007f2:	619a      	str	r2, [r3, #24]
  hadc2.Init.DiscontinuousConvMode = DISABLE;
 81007f4:	4b3b      	ldr	r3, [pc, #236]	; (81008e4 <MX_ADC2_Init+0x148>)
 81007f6:	2200      	movs	r2, #0
 81007f8:	771a      	strb	r2, [r3, #28]
  hadc2.Init.ExternalTrigConv = ADC_SOFTWARE_START;
 81007fa:	4b3a      	ldr	r3, [pc, #232]	; (81008e4 <MX_ADC2_Init+0x148>)
 81007fc:	2200      	movs	r2, #0
 81007fe:	625a      	str	r2, [r3, #36]	; 0x24
  hadc2.Init.ExternalTrigConvEdge = ADC_EXTERNALTRIGCONVEDGE_NONE;
 8100800:	4b38      	ldr	r3, [pc, #224]	; (81008e4 <MX_ADC2_Init+0x148>)
 8100802:	2200      	movs	r2, #0
 8100804:	629a      	str	r2, [r3, #40]	; 0x28
  hadc2.Init.ConversionDataManagement = ADC_CONVERSIONDATA_DR;
 8100806:	4b37      	ldr	r3, [pc, #220]	; (81008e4 <MX_ADC2_Init+0x148>)
 8100808:	2200      	movs	r2, #0
 810080a:	62da      	str	r2, [r3, #44]	; 0x2c
  hadc2.Init.Overrun = ADC_OVR_DATA_PRESERVED;
 810080c:	4b35      	ldr	r3, [pc, #212]	; (81008e4 <MX_ADC2_Init+0x148>)
 810080e:	2200      	movs	r2, #0
 8100810:	631a      	str	r2, [r3, #48]	; 0x30
  hadc2.Init.LeftBitShift = ADC_LEFTBITSHIFT_NONE;
 8100812:	4b34      	ldr	r3, [pc, #208]	; (81008e4 <MX_ADC2_Init+0x148>)
 8100814:	2200      	movs	r2, #0
 8100816:	635a      	str	r2, [r3, #52]	; 0x34
  hadc2.Init.OversamplingMode = DISABLE;
 8100818:	4b32      	ldr	r3, [pc, #200]	; (81008e4 <MX_ADC2_Init+0x148>)
 810081a:	2200      	movs	r2, #0
 810081c:	f883 2038 	strb.w	r2, [r3, #56]	; 0x38
  if (HAL_ADC_Init(&hadc2) != HAL_OK)
 8100820:	4830      	ldr	r0, [pc, #192]	; (81008e4 <MX_ADC2_Init+0x148>)
 8100822:	f001 f8e7 	bl	81019f4 <HAL_ADC_Init>
 8100826:	4603      	mov	r3, r0
 8100828:	2b00      	cmp	r3, #0
 810082a:	d001      	beq.n	8100830 <MX_ADC2_Init+0x94>
  {
    Error_Handler();
 810082c:	f000 f91c 	bl	8100a68 <Error_Handler>
  }

  /** Disable Injected Queue
  */
  HAL_ADCEx_DisableInjectedQueue(&hadc2);
 8100830:	482c      	ldr	r0, [pc, #176]	; (81008e4 <MX_ADC2_Init+0x148>)
 8100832:	f002 fd81 	bl	8103338 <HAL_ADCEx_DisableInjectedQueue>

  /** Configure Regular Channel
  */
  sConfig.Channel = ADC_CHANNEL_3;
 8100836:	4b2d      	ldr	r3, [pc, #180]	; (81008ec <MX_ADC2_Init+0x150>)
 8100838:	63fb      	str	r3, [r7, #60]	; 0x3c
  sConfig.Rank = ADC_REGULAR_RANK_1;
 810083a:	2306      	movs	r3, #6
 810083c:	643b      	str	r3, [r7, #64]	; 0x40
  sConfig.SamplingTime = ADC_SAMPLETIME_1CYCLE_5;
 810083e:	2300      	movs	r3, #0
 8100840:	647b      	str	r3, [r7, #68]	; 0x44
  sConfig.SingleDiff = ADC_SINGLE_ENDED;
 8100842:	f240 73ff 	movw	r3, #2047	; 0x7ff
 8100846:	64bb      	str	r3, [r7, #72]	; 0x48
  sConfig.OffsetNumber = ADC_OFFSET_NONE;
 8100848:	2304      	movs	r3, #4
 810084a:	64fb      	str	r3, [r7, #76]	; 0x4c
  sConfig.Offset = 0;
 810084c:	2300      	movs	r3, #0
 810084e:	653b      	str	r3, [r7, #80]	; 0x50
  sConfig.OffsetSignedSaturation = DISABLE;
 8100850:	2300      	movs	r3, #0
 8100852:	f887 3055 	strb.w	r3, [r7, #85]	; 0x55
  if (HAL_ADC_ConfigChannel(&hadc2, &sConfig) != HAL_OK)
 8100856:	f107 033c 	add.w	r3, r7, #60	; 0x3c
 810085a:	4619      	mov	r1, r3
 810085c:	4821      	ldr	r0, [pc, #132]	; (81008e4 <MX_ADC2_Init+0x148>)
 810085e:	f001 fa6b 	bl	8101d38 <HAL_ADC_ConfigChannel>
 8100862:	4603      	mov	r3, r0
 8100864:	2b00      	cmp	r3, #0
 8100866:	d001      	beq.n	810086c <MX_ADC2_Init+0xd0>
  {
    Error_Handler();
 8100868:	f000 f8fe 	bl	8100a68 <Error_Handler>
  }

  /** Configure Injected Channel
  */
  sConfigInjected.InjectedChannel = ADC_CHANNEL_3;
 810086c:	4b1f      	ldr	r3, [pc, #124]	; (81008ec <MX_ADC2_Init+0x150>)
 810086e:	603b      	str	r3, [r7, #0]
  sConfigInjected.InjectedRank = ADC_INJECTED_RANK_1;
 8100870:	2309      	movs	r3, #9
 8100872:	607b      	str	r3, [r7, #4]
  sConfigInjected.InjectedSamplingTime = ADC_SAMPLETIME_387CYCLES_5;
 8100874:	2306      	movs	r3, #6
 8100876:	60bb      	str	r3, [r7, #8]
  sConfigInjected.InjectedSingleDiff = ADC_SINGLE_ENDED;
 8100878:	f240 73ff 	movw	r3, #2047	; 0x7ff
 810087c:	60fb      	str	r3, [r7, #12]
  sConfigInjected.InjectedOffsetNumber = ADC_OFFSET_NONE;
 810087e:	2304      	movs	r3, #4
 8100880:	613b      	str	r3, [r7, #16]
  sConfigInjected.InjectedOffset = 0;
 8100882:	2300      	movs	r3, #0
 8100884:	617b      	str	r3, [r7, #20]
  sConfigInjected.InjectedOffsetSignedSaturation = DISABLE;
 8100886:	2300      	movs	r3, #0
 8100888:	773b      	strb	r3, [r7, #28]
  sConfigInjected.InjectedNbrOfConversion = 2;
 810088a:	2302      	movs	r3, #2
 810088c:	623b      	str	r3, [r7, #32]
  sConfigInjected.InjectedDiscontinuousConvMode = DISABLE;
 810088e:	2300      	movs	r3, #0
 8100890:	f887 3024 	strb.w	r3, [r7, #36]	; 0x24
  sConfigInjected.AutoInjectedConv = DISABLE;
 8100894:	2300      	movs	r3, #0
 8100896:	f887 3025 	strb.w	r3, [r7, #37]	; 0x25
  sConfigInjected.QueueInjectedContext = DISABLE;
 810089a:	2300      	movs	r3, #0
 810089c:	f887 3026 	strb.w	r3, [r7, #38]	; 0x26
  sConfigInjected.ExternalTrigInjecConv = ADC_INJECTED_SOFTWARE_START;
 81008a0:	2300      	movs	r3, #0
 81008a2:	62bb      	str	r3, [r7, #40]	; 0x28
  sConfigInjected.ExternalTrigInjecConvEdge = ADC_EXTERNALTRIGINJECCONV_EDGE_NONE;
 81008a4:	2300      	movs	r3, #0
 81008a6:	62fb      	str	r3, [r7, #44]	; 0x2c
  sConfigInjected.InjecOversamplingMode = DISABLE;
 81008a8:	2300      	movs	r3, #0
 81008aa:	f887 3030 	strb.w	r3, [r7, #48]	; 0x30
  if (HAL_ADCEx_InjectedConfigChannel(&hadc2, &sConfigInjected) != HAL_OK)
 81008ae:	463b      	mov	r3, r7
 81008b0:	4619      	mov	r1, r3
 81008b2:	480c      	ldr	r0, [pc, #48]	; (81008e4 <MX_ADC2_Init+0x148>)
 81008b4:	f001 ffb8 	bl	8102828 <HAL_ADCEx_InjectedConfigChannel>
 81008b8:	4603      	mov	r3, r0
 81008ba:	2b00      	cmp	r3, #0
 81008bc:	d001      	beq.n	81008c2 <MX_ADC2_Init+0x126>
  {
    Error_Handler();
 81008be:	f000 f8d3 	bl	8100a68 <Error_Handler>
  }

  /** Configure Injected Channel
  */
  sConfigInjected.InjectedRank = ADC_INJECTED_RANK_2;
 81008c2:	f240 130f 	movw	r3, #271	; 0x10f
 81008c6:	607b      	str	r3, [r7, #4]
  if (HAL_ADCEx_InjectedConfigChannel(&hadc2, &sConfigInjected) != HAL_OK)
 81008c8:	463b      	mov	r3, r7
 81008ca:	4619      	mov	r1, r3
 81008cc:	4805      	ldr	r0, [pc, #20]	; (81008e4 <MX_ADC2_Init+0x148>)
 81008ce:	f001 ffab 	bl	8102828 <HAL_ADCEx_InjectedConfigChannel>
 81008d2:	4603      	mov	r3, r0
 81008d4:	2b00      	cmp	r3, #0
 81008d6:	d001      	beq.n	81008dc <MX_ADC2_Init+0x140>
  {
    Error_Handler();
 81008d8:	f000 f8c6 	bl	8100a68 <Error_Handler>
  }
  /* USER CODE BEGIN ADC2_Init 2 */

  /* USER CODE END ADC2_Init 2 */

}
 81008dc:	bf00      	nop
 81008de:	3758      	adds	r7, #88	; 0x58
 81008e0:	46bd      	mov	sp, r7
 81008e2:	bd80      	pop	{r7, pc}
 81008e4:	100002ac 	.word	0x100002ac
 81008e8:	40022100 	.word	0x40022100
 81008ec:	0c900008 	.word	0x0c900008

081008f0 <MX_FDCAN1_Init>:
  * @brief FDCAN1 Initialization Function
  * @param None
  * @retval None
  */
static void MX_FDCAN1_Init(void)
{
 81008f0:	b580      	push	{r7, lr}
 81008f2:	af00      	add	r7, sp, #0
  /* USER CODE END FDCAN1_Init 0 */

  /* USER CODE BEGIN FDCAN1_Init 1 */

  /* USER CODE END FDCAN1_Init 1 */
  hfdcan1.Instance = FDCAN1;
 81008f4:	4b2f      	ldr	r3, [pc, #188]	; (81009b4 <MX_FDCAN1_Init+0xc4>)
 81008f6:	4a30      	ldr	r2, [pc, #192]	; (81009b8 <MX_FDCAN1_Init+0xc8>)
 81008f8:	601a      	str	r2, [r3, #0]
  hfdcan1.Init.FrameFormat = FDCAN_FRAME_FD_BRS;
 81008fa:	4b2e      	ldr	r3, [pc, #184]	; (81009b4 <MX_FDCAN1_Init+0xc4>)
 81008fc:	f44f 7240 	mov.w	r2, #768	; 0x300
 8100900:	609a      	str	r2, [r3, #8]
  hfdcan1.Init.Mode = FDCAN_MODE_BUS_MONITORING;
 8100902:	4b2c      	ldr	r3, [pc, #176]	; (81009b4 <MX_FDCAN1_Init+0xc4>)
 8100904:	2202      	movs	r2, #2
 8100906:	60da      	str	r2, [r3, #12]
  hfdcan1.Init.AutoRetransmission = DISABLE;
 8100908:	4b2a      	ldr	r3, [pc, #168]	; (81009b4 <MX_FDCAN1_Init+0xc4>)
 810090a:	2200      	movs	r2, #0
 810090c:	741a      	strb	r2, [r3, #16]
  hfdcan1.Init.TransmitPause = DISABLE;
 810090e:	4b29      	ldr	r3, [pc, #164]	; (81009b4 <MX_FDCAN1_Init+0xc4>)
 8100910:	2200      	movs	r2, #0
 8100912:	745a      	strb	r2, [r3, #17]
  hfdcan1.Init.ProtocolException = DISABLE;
 8100914:	4b27      	ldr	r3, [pc, #156]	; (81009b4 <MX_FDCAN1_Init+0xc4>)
 8100916:	2200      	movs	r2, #0
 8100918:	749a      	strb	r2, [r3, #18]
  hfdcan1.Init.NominalPrescaler = 16;
 810091a:	4b26      	ldr	r3, [pc, #152]	; (81009b4 <MX_FDCAN1_Init+0xc4>)
 810091c:	2210      	movs	r2, #16
 810091e:	615a      	str	r2, [r3, #20]
  hfdcan1.Init.NominalSyncJumpWidth = 1;
 8100920:	4b24      	ldr	r3, [pc, #144]	; (81009b4 <MX_FDCAN1_Init+0xc4>)
 8100922:	2201      	movs	r2, #1
 8100924:	619a      	str	r2, [r3, #24]
  hfdcan1.Init.NominalTimeSeg1 = 2;
 8100926:	4b23      	ldr	r3, [pc, #140]	; (81009b4 <MX_FDCAN1_Init+0xc4>)
 8100928:	2202      	movs	r2, #2
 810092a:	61da      	str	r2, [r3, #28]
  hfdcan1.Init.NominalTimeSeg2 = 2;
 810092c:	4b21      	ldr	r3, [pc, #132]	; (81009b4 <MX_FDCAN1_Init+0xc4>)
 810092e:	2202      	movs	r2, #2
 8100930:	621a      	str	r2, [r3, #32]
  hfdcan1.Init.DataPrescaler = 1;
 8100932:	4b20      	ldr	r3, [pc, #128]	; (81009b4 <MX_FDCAN1_Init+0xc4>)
 8100934:	2201      	movs	r2, #1
 8100936:	625a      	str	r2, [r3, #36]	; 0x24
  hfdcan1.Init.DataSyncJumpWidth = 1;
 8100938:	4b1e      	ldr	r3, [pc, #120]	; (81009b4 <MX_FDCAN1_Init+0xc4>)
 810093a:	2201      	movs	r2, #1
 810093c:	629a      	str	r2, [r3, #40]	; 0x28
  hfdcan1.Init.DataTimeSeg1 = 1;
 810093e:	4b1d      	ldr	r3, [pc, #116]	; (81009b4 <MX_FDCAN1_Init+0xc4>)
 8100940:	2201      	movs	r2, #1
 8100942:	62da      	str	r2, [r3, #44]	; 0x2c
  hfdcan1.Init.DataTimeSeg2 = 1;
 8100944:	4b1b      	ldr	r3, [pc, #108]	; (81009b4 <MX_FDCAN1_Init+0xc4>)
 8100946:	2201      	movs	r2, #1
 8100948:	631a      	str	r2, [r3, #48]	; 0x30
  hfdcan1.Init.MessageRAMOffset = 0;
 810094a:	4b1a      	ldr	r3, [pc, #104]	; (81009b4 <MX_FDCAN1_Init+0xc4>)
 810094c:	2200      	movs	r2, #0
 810094e:	635a      	str	r2, [r3, #52]	; 0x34
  hfdcan1.Init.StdFiltersNbr = 0;
 8100950:	4b18      	ldr	r3, [pc, #96]	; (81009b4 <MX_FDCAN1_Init+0xc4>)
 8100952:	2200      	movs	r2, #0
 8100954:	639a      	str	r2, [r3, #56]	; 0x38
  hfdcan1.Init.ExtFiltersNbr = 0;
 8100956:	4b17      	ldr	r3, [pc, #92]	; (81009b4 <MX_FDCAN1_Init+0xc4>)
 8100958:	2200      	movs	r2, #0
 810095a:	63da      	str	r2, [r3, #60]	; 0x3c
  hfdcan1.Init.RxFifo0ElmtsNbr = 0;
 810095c:	4b15      	ldr	r3, [pc, #84]	; (81009b4 <MX_FDCAN1_Init+0xc4>)
 810095e:	2200      	movs	r2, #0
 8100960:	641a      	str	r2, [r3, #64]	; 0x40
  hfdcan1.Init.RxFifo0ElmtSize = FDCAN_DATA_BYTES_8;
 8100962:	4b14      	ldr	r3, [pc, #80]	; (81009b4 <MX_FDCAN1_Init+0xc4>)
 8100964:	2204      	movs	r2, #4
 8100966:	645a      	str	r2, [r3, #68]	; 0x44
  hfdcan1.Init.RxFifo1ElmtsNbr = 0;
 8100968:	4b12      	ldr	r3, [pc, #72]	; (81009b4 <MX_FDCAN1_Init+0xc4>)
 810096a:	2200      	movs	r2, #0
 810096c:	649a      	str	r2, [r3, #72]	; 0x48
  hfdcan1.Init.RxFifo1ElmtSize = FDCAN_DATA_BYTES_8;
 810096e:	4b11      	ldr	r3, [pc, #68]	; (81009b4 <MX_FDCAN1_Init+0xc4>)
 8100970:	2204      	movs	r2, #4
 8100972:	64da      	str	r2, [r3, #76]	; 0x4c
  hfdcan1.Init.RxBuffersNbr = 0;
 8100974:	4b0f      	ldr	r3, [pc, #60]	; (81009b4 <MX_FDCAN1_Init+0xc4>)
 8100976:	2200      	movs	r2, #0
 8100978:	651a      	str	r2, [r3, #80]	; 0x50
  hfdcan1.Init.RxBufferSize = FDCAN_DATA_BYTES_8;
 810097a:	4b0e      	ldr	r3, [pc, #56]	; (81009b4 <MX_FDCAN1_Init+0xc4>)
 810097c:	2204      	movs	r2, #4
 810097e:	655a      	str	r2, [r3, #84]	; 0x54
  hfdcan1.Init.TxEventsNbr = 0;
 8100980:	4b0c      	ldr	r3, [pc, #48]	; (81009b4 <MX_FDCAN1_Init+0xc4>)
 8100982:	2200      	movs	r2, #0
 8100984:	659a      	str	r2, [r3, #88]	; 0x58
  hfdcan1.Init.TxBuffersNbr = 0;
 8100986:	4b0b      	ldr	r3, [pc, #44]	; (81009b4 <MX_FDCAN1_Init+0xc4>)
 8100988:	2200      	movs	r2, #0
 810098a:	65da      	str	r2, [r3, #92]	; 0x5c
  hfdcan1.Init.TxFifoQueueElmtsNbr = 0;
 810098c:	4b09      	ldr	r3, [pc, #36]	; (81009b4 <MX_FDCAN1_Init+0xc4>)
 810098e:	2200      	movs	r2, #0
 8100990:	661a      	str	r2, [r3, #96]	; 0x60
  hfdcan1.Init.TxFifoQueueMode = FDCAN_TX_FIFO_OPERATION;
 8100992:	4b08      	ldr	r3, [pc, #32]	; (81009b4 <MX_FDCAN1_Init+0xc4>)
 8100994:	2200      	movs	r2, #0
 8100996:	665a      	str	r2, [r3, #100]	; 0x64
  hfdcan1.Init.TxElmtSize = FDCAN_DATA_BYTES_8;
 8100998:	4b06      	ldr	r3, [pc, #24]	; (81009b4 <MX_FDCAN1_Init+0xc4>)
 810099a:	2204      	movs	r2, #4
 810099c:	669a      	str	r2, [r3, #104]	; 0x68
  if (HAL_FDCAN_Init(&hfdcan1) != HAL_OK)
 810099e:	4805      	ldr	r0, [pc, #20]	; (81009b4 <MX_FDCAN1_Init+0xc4>)
 81009a0:	f004 f9a8 	bl	8104cf4 <HAL_FDCAN_Init>
 81009a4:	4603      	mov	r3, r0
 81009a6:	2b00      	cmp	r3, #0
 81009a8:	d001      	beq.n	81009ae <MX_FDCAN1_Init+0xbe>
  {
    Error_Handler();
 81009aa:	f000 f85d 	bl	8100a68 <Error_Handler>
  }
  /* USER CODE BEGIN FDCAN1_Init 2 */

  /* USER CODE END FDCAN1_Init 2 */

}
 81009ae:	bf00      	nop
 81009b0:	bd80      	pop	{r7, pc}
 81009b2:	bf00      	nop
 81009b4:	10000310 	.word	0x10000310
 81009b8:	4000a000 	.word	0x4000a000

081009bc <MX_GPIO_Init>:
  * @brief GPIO Initialization Function
  * @param None
  * @retval None
  */
static void MX_GPIO_Init(void)
{
 81009bc:	b480      	push	{r7}
 81009be:	b087      	sub	sp, #28
 81009c0:	af00      	add	r7, sp, #0
/* USER CODE BEGIN MX_GPIO_Init_1 */
/* USER CODE END MX_GPIO_Init_1 */

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOC_CLK_ENABLE();
 81009c2:	4b28      	ldr	r3, [pc, #160]	; (8100a64 <MX_GPIO_Init+0xa8>)
 81009c4:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
 81009c8:	4a26      	ldr	r2, [pc, #152]	; (8100a64 <MX_GPIO_Init+0xa8>)
 81009ca:	f043 0304 	orr.w	r3, r3, #4
 81009ce:	f8c2 30e0 	str.w	r3, [r2, #224]	; 0xe0
 81009d2:	4b24      	ldr	r3, [pc, #144]	; (8100a64 <MX_GPIO_Init+0xa8>)
 81009d4:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
 81009d8:	f003 0304 	and.w	r3, r3, #4
 81009dc:	617b      	str	r3, [r7, #20]
 81009de:	697b      	ldr	r3, [r7, #20]
  __HAL_RCC_GPIOA_CLK_ENABLE();
 81009e0:	4b20      	ldr	r3, [pc, #128]	; (8100a64 <MX_GPIO_Init+0xa8>)
 81009e2:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
 81009e6:	4a1f      	ldr	r2, [pc, #124]	; (8100a64 <MX_GPIO_Init+0xa8>)
 81009e8:	f043 0301 	orr.w	r3, r3, #1
 81009ec:	f8c2 30e0 	str.w	r3, [r2, #224]	; 0xe0
 81009f0:	4b1c      	ldr	r3, [pc, #112]	; (8100a64 <MX_GPIO_Init+0xa8>)
 81009f2:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
 81009f6:	f003 0301 	and.w	r3, r3, #1
 81009fa:	613b      	str	r3, [r7, #16]
 81009fc:	693b      	ldr	r3, [r7, #16]
  __HAL_RCC_GPIOB_CLK_ENABLE();
 81009fe:	4b19      	ldr	r3, [pc, #100]	; (8100a64 <MX_GPIO_Init+0xa8>)
 8100a00:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
 8100a04:	4a17      	ldr	r2, [pc, #92]	; (8100a64 <MX_GPIO_Init+0xa8>)
 8100a06:	f043 0302 	orr.w	r3, r3, #2
 8100a0a:	f8c2 30e0 	str.w	r3, [r2, #224]	; 0xe0
 8100a0e:	4b15      	ldr	r3, [pc, #84]	; (8100a64 <MX_GPIO_Init+0xa8>)
 8100a10:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
 8100a14:	f003 0302 	and.w	r3, r3, #2
 8100a18:	60fb      	str	r3, [r7, #12]
 8100a1a:	68fb      	ldr	r3, [r7, #12]
  __HAL_RCC_GPIOD_CLK_ENABLE();
 8100a1c:	4b11      	ldr	r3, [pc, #68]	; (8100a64 <MX_GPIO_Init+0xa8>)
 8100a1e:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
 8100a22:	4a10      	ldr	r2, [pc, #64]	; (8100a64 <MX_GPIO_Init+0xa8>)
 8100a24:	f043 0308 	orr.w	r3, r3, #8
 8100a28:	f8c2 30e0 	str.w	r3, [r2, #224]	; 0xe0
 8100a2c:	4b0d      	ldr	r3, [pc, #52]	; (8100a64 <MX_GPIO_Init+0xa8>)
 8100a2e:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
 8100a32:	f003 0308 	and.w	r3, r3, #8
 8100a36:	60bb      	str	r3, [r7, #8]
 8100a38:	68bb      	ldr	r3, [r7, #8]
  __HAL_RCC_GPIOG_CLK_ENABLE();
 8100a3a:	4b0a      	ldr	r3, [pc, #40]	; (8100a64 <MX_GPIO_Init+0xa8>)
 8100a3c:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
 8100a40:	4a08      	ldr	r2, [pc, #32]	; (8100a64 <MX_GPIO_Init+0xa8>)
 8100a42:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8100a46:	f8c2 30e0 	str.w	r3, [r2, #224]	; 0xe0
 8100a4a:	4b06      	ldr	r3, [pc, #24]	; (8100a64 <MX_GPIO_Init+0xa8>)
 8100a4c:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
 8100a50:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8100a54:	607b      	str	r3, [r7, #4]
 8100a56:	687b      	ldr	r3, [r7, #4]

/* USER CODE BEGIN MX_GPIO_Init_2 */
/* USER CODE END MX_GPIO_Init_2 */
}
 8100a58:	bf00      	nop
 8100a5a:	371c      	adds	r7, #28
 8100a5c:	46bd      	mov	sp, r7
 8100a5e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8100a62:	4770      	bx	lr
 8100a64:	58024400 	.word	0x58024400

08100a68 <Error_Handler>:
/**
  * @brief  This function is executed in case of error occurrence.
  * @retval None
  */
void Error_Handler(void)
{
 8100a68:	b480      	push	{r7}
 8100a6a:	af00      	add	r7, sp, #0
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8100a6c:	b672      	cpsid	i
}
 8100a6e:	bf00      	nop
  /* USER CODE BEGIN Error_Handler_Debug */
  /* User can add his own implementation to report the HAL error return state */
  __disable_irq();
  while (1)
 8100a70:	e7fe      	b.n	8100a70 <Error_Handler+0x8>
	...

08100a74 <HAL_MspInit>:
/* USER CODE END 0 */
/**
  * Initializes the Global MSP.
  */
void HAL_MspInit(void)
{
 8100a74:	b480      	push	{r7}
 8100a76:	b083      	sub	sp, #12
 8100a78:	af00      	add	r7, sp, #0

  /* USER CODE BEGIN MspInit 0 */

  /* USER CODE END MspInit 0 */

  __HAL_RCC_SYSCFG_CLK_ENABLE();
 8100a7a:	4b0a      	ldr	r3, [pc, #40]	; (8100aa4 <HAL_MspInit+0x30>)
 8100a7c:	f8d3 30f4 	ldr.w	r3, [r3, #244]	; 0xf4
 8100a80:	4a08      	ldr	r2, [pc, #32]	; (8100aa4 <HAL_MspInit+0x30>)
 8100a82:	f043 0302 	orr.w	r3, r3, #2
 8100a86:	f8c2 30f4 	str.w	r3, [r2, #244]	; 0xf4
 8100a8a:	4b06      	ldr	r3, [pc, #24]	; (8100aa4 <HAL_MspInit+0x30>)
 8100a8c:	f8d3 30f4 	ldr.w	r3, [r3, #244]	; 0xf4
 8100a90:	f003 0302 	and.w	r3, r3, #2
 8100a94:	607b      	str	r3, [r7, #4]
 8100a96:	687b      	ldr	r3, [r7, #4]
  /* System interrupt init*/

  /* USER CODE BEGIN MspInit 1 */

  /* USER CODE END MspInit 1 */
}
 8100a98:	bf00      	nop
 8100a9a:	370c      	adds	r7, #12
 8100a9c:	46bd      	mov	sp, r7
 8100a9e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8100aa2:	4770      	bx	lr
 8100aa4:	58024400 	.word	0x58024400

08100aa8 <HAL_ADC_MspInit>:
* This function configures the hardware resources used in this example
* @param hadc: ADC handle pointer
* @retval None
*/
void HAL_ADC_MspInit(ADC_HandleTypeDef* hadc)
{
 8100aa8:	b580      	push	{r7, lr}
 8100aaa:	b0bc      	sub	sp, #240	; 0xf0
 8100aac:	af00      	add	r7, sp, #0
 8100aae:	6078      	str	r0, [r7, #4]
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8100ab0:	f107 03dc 	add.w	r3, r7, #220	; 0xdc
 8100ab4:	2200      	movs	r2, #0
 8100ab6:	601a      	str	r2, [r3, #0]
 8100ab8:	605a      	str	r2, [r3, #4]
 8100aba:	609a      	str	r2, [r3, #8]
 8100abc:	60da      	str	r2, [r3, #12]
 8100abe:	611a      	str	r2, [r3, #16]
  RCC_PeriphCLKInitTypeDef PeriphClkInitStruct = {0};
 8100ac0:	f107 0318 	add.w	r3, r7, #24
 8100ac4:	22c0      	movs	r2, #192	; 0xc0
 8100ac6:	2100      	movs	r1, #0
 8100ac8:	4618      	mov	r0, r3
 8100aca:	f01a fec3 	bl	811b854 <memset>
  if(hadc->Instance==ADC2)
 8100ace:	687b      	ldr	r3, [r7, #4]
 8100ad0:	681b      	ldr	r3, [r3, #0]
 8100ad2:	4a3b      	ldr	r2, [pc, #236]	; (8100bc0 <HAL_ADC_MspInit+0x118>)
 8100ad4:	4293      	cmp	r3, r2
 8100ad6:	d16e      	bne.n	8100bb6 <HAL_ADC_MspInit+0x10e>

  /* USER CODE END ADC2_MspInit 0 */

  /** Initializes the peripherals clock
  */
    PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_ADC;
 8100ad8:	f44f 2200 	mov.w	r2, #524288	; 0x80000
 8100adc:	f04f 0300 	mov.w	r3, #0
 8100ae0:	e9c7 2306 	strd	r2, r3, [r7, #24]
    PeriphClkInitStruct.PLL2.PLL2M = 4;
 8100ae4:	2304      	movs	r3, #4
 8100ae6:	623b      	str	r3, [r7, #32]
    PeriphClkInitStruct.PLL2.PLL2N = 9;
 8100ae8:	2309      	movs	r3, #9
 8100aea:	627b      	str	r3, [r7, #36]	; 0x24
    PeriphClkInitStruct.PLL2.PLL2P = 2;
 8100aec:	2302      	movs	r3, #2
 8100aee:	62bb      	str	r3, [r7, #40]	; 0x28
    PeriphClkInitStruct.PLL2.PLL2Q = 2;
 8100af0:	2302      	movs	r3, #2
 8100af2:	62fb      	str	r3, [r7, #44]	; 0x2c
    PeriphClkInitStruct.PLL2.PLL2R = 2;
 8100af4:	2302      	movs	r3, #2
 8100af6:	633b      	str	r3, [r7, #48]	; 0x30
    PeriphClkInitStruct.PLL2.PLL2RGE = RCC_PLL2VCIRANGE_3;
 8100af8:	23c0      	movs	r3, #192	; 0xc0
 8100afa:	637b      	str	r3, [r7, #52]	; 0x34
    PeriphClkInitStruct.PLL2.PLL2VCOSEL = RCC_PLL2VCOMEDIUM;
 8100afc:	2320      	movs	r3, #32
 8100afe:	63bb      	str	r3, [r7, #56]	; 0x38
    PeriphClkInitStruct.PLL2.PLL2FRACN = 3072.0;
 8100b00:	f44f 6340 	mov.w	r3, #3072	; 0xc00
 8100b04:	63fb      	str	r3, [r7, #60]	; 0x3c
    PeriphClkInitStruct.AdcClockSelection = RCC_ADCCLKSOURCE_PLL2;
 8100b06:	2300      	movs	r3, #0
 8100b08:	f8c7 30bc 	str.w	r3, [r7, #188]	; 0xbc
    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
 8100b0c:	f107 0318 	add.w	r3, r7, #24
 8100b10:	4618      	mov	r0, r3
 8100b12:	f006 fb2f 	bl	8107174 <HAL_RCCEx_PeriphCLKConfig>
 8100b16:	4603      	mov	r3, r0
 8100b18:	2b00      	cmp	r3, #0
 8100b1a:	d001      	beq.n	8100b20 <HAL_ADC_MspInit+0x78>
    {
      Error_Handler();
 8100b1c:	f7ff ffa4 	bl	8100a68 <Error_Handler>
    }

    /* Peripheral clock enable */
    __HAL_RCC_ADC12_CLK_ENABLE();
 8100b20:	4b28      	ldr	r3, [pc, #160]	; (8100bc4 <HAL_ADC_MspInit+0x11c>)
 8100b22:	f8d3 30d8 	ldr.w	r3, [r3, #216]	; 0xd8
 8100b26:	4a27      	ldr	r2, [pc, #156]	; (8100bc4 <HAL_ADC_MspInit+0x11c>)
 8100b28:	f043 0320 	orr.w	r3, r3, #32
 8100b2c:	f8c2 30d8 	str.w	r3, [r2, #216]	; 0xd8
 8100b30:	4b24      	ldr	r3, [pc, #144]	; (8100bc4 <HAL_ADC_MspInit+0x11c>)
 8100b32:	f8d3 30d8 	ldr.w	r3, [r3, #216]	; 0xd8
 8100b36:	f003 0320 	and.w	r3, r3, #32
 8100b3a:	617b      	str	r3, [r7, #20]
 8100b3c:	697b      	ldr	r3, [r7, #20]

    __HAL_RCC_GPIOA_CLK_ENABLE();
 8100b3e:	4b21      	ldr	r3, [pc, #132]	; (8100bc4 <HAL_ADC_MspInit+0x11c>)
 8100b40:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
 8100b44:	4a1f      	ldr	r2, [pc, #124]	; (8100bc4 <HAL_ADC_MspInit+0x11c>)
 8100b46:	f043 0301 	orr.w	r3, r3, #1
 8100b4a:	f8c2 30e0 	str.w	r3, [r2, #224]	; 0xe0
 8100b4e:	4b1d      	ldr	r3, [pc, #116]	; (8100bc4 <HAL_ADC_MspInit+0x11c>)
 8100b50:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
 8100b54:	f003 0301 	and.w	r3, r3, #1
 8100b58:	613b      	str	r3, [r7, #16]
 8100b5a:	693b      	ldr	r3, [r7, #16]
    __HAL_RCC_GPIOB_CLK_ENABLE();
 8100b5c:	4b19      	ldr	r3, [pc, #100]	; (8100bc4 <HAL_ADC_MspInit+0x11c>)
 8100b5e:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
 8100b62:	4a18      	ldr	r2, [pc, #96]	; (8100bc4 <HAL_ADC_MspInit+0x11c>)
 8100b64:	f043 0302 	orr.w	r3, r3, #2
 8100b68:	f8c2 30e0 	str.w	r3, [r2, #224]	; 0xe0
 8100b6c:	4b15      	ldr	r3, [pc, #84]	; (8100bc4 <HAL_ADC_MspInit+0x11c>)
 8100b6e:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
 8100b72:	f003 0302 	and.w	r3, r3, #2
 8100b76:	60fb      	str	r3, [r7, #12]
 8100b78:	68fb      	ldr	r3, [r7, #12]
    /**ADC2 GPIO Configuration
    PA6     ------> ADC2_INP3
    PB1     ------> ADC2_INP5
    */
    GPIO_InitStruct.Pin = GPIO_PIN_6;
 8100b7a:	2340      	movs	r3, #64	; 0x40
 8100b7c:	f8c7 30dc 	str.w	r3, [r7, #220]	; 0xdc
    GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
 8100b80:	2303      	movs	r3, #3
 8100b82:	f8c7 30e0 	str.w	r3, [r7, #224]	; 0xe0
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8100b86:	2300      	movs	r3, #0
 8100b88:	f8c7 30e4 	str.w	r3, [r7, #228]	; 0xe4
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8100b8c:	f107 03dc 	add.w	r3, r7, #220	; 0xdc
 8100b90:	4619      	mov	r1, r3
 8100b92:	480d      	ldr	r0, [pc, #52]	; (8100bc8 <HAL_ADC_MspInit+0x120>)
 8100b94:	f004 fc1c 	bl	81053d0 <HAL_GPIO_Init>

    GPIO_InitStruct.Pin = GPIO_PIN_1;
 8100b98:	2302      	movs	r3, #2
 8100b9a:	f8c7 30dc 	str.w	r3, [r7, #220]	; 0xdc
    GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
 8100b9e:	2303      	movs	r3, #3
 8100ba0:	f8c7 30e0 	str.w	r3, [r7, #224]	; 0xe0
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8100ba4:	2300      	movs	r3, #0
 8100ba6:	f8c7 30e4 	str.w	r3, [r7, #228]	; 0xe4
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8100baa:	f107 03dc 	add.w	r3, r7, #220	; 0xdc
 8100bae:	4619      	mov	r1, r3
 8100bb0:	4806      	ldr	r0, [pc, #24]	; (8100bcc <HAL_ADC_MspInit+0x124>)
 8100bb2:	f004 fc0d 	bl	81053d0 <HAL_GPIO_Init>
  /* USER CODE BEGIN ADC2_MspInit 1 */

  /* USER CODE END ADC2_MspInit 1 */
  }

}
 8100bb6:	bf00      	nop
 8100bb8:	37f0      	adds	r7, #240	; 0xf0
 8100bba:	46bd      	mov	sp, r7
 8100bbc:	bd80      	pop	{r7, pc}
 8100bbe:	bf00      	nop
 8100bc0:	40022100 	.word	0x40022100
 8100bc4:	58024400 	.word	0x58024400
 8100bc8:	58020000 	.word	0x58020000
 8100bcc:	58020400 	.word	0x58020400

08100bd0 <HAL_FDCAN_MspInit>:
* This function configures the hardware resources used in this example
* @param hfdcan: FDCAN handle pointer
* @retval None
*/
void HAL_FDCAN_MspInit(FDCAN_HandleTypeDef* hfdcan)
{
 8100bd0:	b580      	push	{r7, lr}
 8100bd2:	b0ba      	sub	sp, #232	; 0xe8
 8100bd4:	af00      	add	r7, sp, #0
 8100bd6:	6078      	str	r0, [r7, #4]
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8100bd8:	f107 03d4 	add.w	r3, r7, #212	; 0xd4
 8100bdc:	2200      	movs	r2, #0
 8100bde:	601a      	str	r2, [r3, #0]
 8100be0:	605a      	str	r2, [r3, #4]
 8100be2:	609a      	str	r2, [r3, #8]
 8100be4:	60da      	str	r2, [r3, #12]
 8100be6:	611a      	str	r2, [r3, #16]
  RCC_PeriphCLKInitTypeDef PeriphClkInitStruct = {0};
 8100be8:	f107 0310 	add.w	r3, r7, #16
 8100bec:	22c0      	movs	r2, #192	; 0xc0
 8100bee:	2100      	movs	r1, #0
 8100bf0:	4618      	mov	r0, r3
 8100bf2:	f01a fe2f 	bl	811b854 <memset>
  if(hfdcan->Instance==FDCAN1)
 8100bf6:	687b      	ldr	r3, [r7, #4]
 8100bf8:	681b      	ldr	r3, [r3, #0]
 8100bfa:	4a27      	ldr	r2, [pc, #156]	; (8100c98 <HAL_FDCAN_MspInit+0xc8>)
 8100bfc:	4293      	cmp	r3, r2
 8100bfe:	d146      	bne.n	8100c8e <HAL_FDCAN_MspInit+0xbe>

  /* USER CODE END FDCAN1_MspInit 0 */

  /** Initializes the peripherals clock
  */
    PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_FDCAN;
 8100c00:	f44f 4200 	mov.w	r2, #32768	; 0x8000
 8100c04:	f04f 0300 	mov.w	r3, #0
 8100c08:	e9c7 2304 	strd	r2, r3, [r7, #16]
    PeriphClkInitStruct.FdcanClockSelection = RCC_FDCANCLKSOURCE_PLL;
 8100c0c:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
 8100c10:	f8c7 3080 	str.w	r3, [r7, #128]	; 0x80
    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
 8100c14:	f107 0310 	add.w	r3, r7, #16
 8100c18:	4618      	mov	r0, r3
 8100c1a:	f006 faab 	bl	8107174 <HAL_RCCEx_PeriphCLKConfig>
 8100c1e:	4603      	mov	r3, r0
 8100c20:	2b00      	cmp	r3, #0
 8100c22:	d001      	beq.n	8100c28 <HAL_FDCAN_MspInit+0x58>
    {
      Error_Handler();
 8100c24:	f7ff ff20 	bl	8100a68 <Error_Handler>
    }

    /* Peripheral clock enable */
    __HAL_RCC_FDCAN_CLK_ENABLE();
 8100c28:	4b1c      	ldr	r3, [pc, #112]	; (8100c9c <HAL_FDCAN_MspInit+0xcc>)
 8100c2a:	f8d3 30ec 	ldr.w	r3, [r3, #236]	; 0xec
 8100c2e:	4a1b      	ldr	r2, [pc, #108]	; (8100c9c <HAL_FDCAN_MspInit+0xcc>)
 8100c30:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8100c34:	f8c2 30ec 	str.w	r3, [r2, #236]	; 0xec
 8100c38:	4b18      	ldr	r3, [pc, #96]	; (8100c9c <HAL_FDCAN_MspInit+0xcc>)
 8100c3a:	f8d3 30ec 	ldr.w	r3, [r3, #236]	; 0xec
 8100c3e:	f403 7380 	and.w	r3, r3, #256	; 0x100
 8100c42:	60fb      	str	r3, [r7, #12]
 8100c44:	68fb      	ldr	r3, [r7, #12]

    __HAL_RCC_GPIOD_CLK_ENABLE();
 8100c46:	4b15      	ldr	r3, [pc, #84]	; (8100c9c <HAL_FDCAN_MspInit+0xcc>)
 8100c48:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
 8100c4c:	4a13      	ldr	r2, [pc, #76]	; (8100c9c <HAL_FDCAN_MspInit+0xcc>)
 8100c4e:	f043 0308 	orr.w	r3, r3, #8
 8100c52:	f8c2 30e0 	str.w	r3, [r2, #224]	; 0xe0
 8100c56:	4b11      	ldr	r3, [pc, #68]	; (8100c9c <HAL_FDCAN_MspInit+0xcc>)
 8100c58:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
 8100c5c:	f003 0308 	and.w	r3, r3, #8
 8100c60:	60bb      	str	r3, [r7, #8]
 8100c62:	68bb      	ldr	r3, [r7, #8]
    /**FDCAN1 GPIO Configuration
    PD0     ------> FDCAN1_RX
    PD1     ------> FDCAN1_TX
    */
    GPIO_InitStruct.Pin = GPIO_PIN_0|GPIO_PIN_1;
 8100c64:	2303      	movs	r3, #3
 8100c66:	f8c7 30d4 	str.w	r3, [r7, #212]	; 0xd4
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8100c6a:	2302      	movs	r3, #2
 8100c6c:	f8c7 30d8 	str.w	r3, [r7, #216]	; 0xd8
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8100c70:	2300      	movs	r3, #0
 8100c72:	f8c7 30dc 	str.w	r3, [r7, #220]	; 0xdc
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 8100c76:	2300      	movs	r3, #0
 8100c78:	f8c7 30e0 	str.w	r3, [r7, #224]	; 0xe0
    GPIO_InitStruct.Alternate = GPIO_AF9_FDCAN1;
 8100c7c:	2309      	movs	r3, #9
 8100c7e:	f8c7 30e4 	str.w	r3, [r7, #228]	; 0xe4
    HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
 8100c82:	f107 03d4 	add.w	r3, r7, #212	; 0xd4
 8100c86:	4619      	mov	r1, r3
 8100c88:	4805      	ldr	r0, [pc, #20]	; (8100ca0 <HAL_FDCAN_MspInit+0xd0>)
 8100c8a:	f004 fba1 	bl	81053d0 <HAL_GPIO_Init>
  /* USER CODE BEGIN FDCAN1_MspInit 1 */

  /* USER CODE END FDCAN1_MspInit 1 */
  }

}
 8100c8e:	bf00      	nop
 8100c90:	37e8      	adds	r7, #232	; 0xe8
 8100c92:	46bd      	mov	sp, r7
 8100c94:	bd80      	pop	{r7, pc}
 8100c96:	bf00      	nop
 8100c98:	4000a000 	.word	0x4000a000
 8100c9c:	58024400 	.word	0x58024400
 8100ca0:	58020c00 	.word	0x58020c00

08100ca4 <NMI_Handler>:
/******************************************************************************/
/**
  * @brief This function handles Non maskable interrupt.
  */
void NMI_Handler(void)
{
 8100ca4:	b480      	push	{r7}
 8100ca6:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN NonMaskableInt_IRQn 0 */

  /* USER CODE END NonMaskableInt_IRQn 0 */
  /* USER CODE BEGIN NonMaskableInt_IRQn 1 */
   while (1)
 8100ca8:	e7fe      	b.n	8100ca8 <NMI_Handler+0x4>

08100caa <HardFault_Handler>:

/**
  * @brief This function handles Hard fault interrupt.
  */
void HardFault_Handler(void)
{
 8100caa:	b480      	push	{r7}
 8100cac:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN HardFault_IRQn 0 */

  /* USER CODE END HardFault_IRQn 0 */
  while (1)
 8100cae:	e7fe      	b.n	8100cae <HardFault_Handler+0x4>

08100cb0 <MemManage_Handler>:

/**
  * @brief This function handles Memory management fault.
  */
void MemManage_Handler(void)
{
 8100cb0:	b480      	push	{r7}
 8100cb2:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN MemoryManagement_IRQn 0 */

  /* USER CODE END MemoryManagement_IRQn 0 */
  while (1)
 8100cb4:	e7fe      	b.n	8100cb4 <MemManage_Handler+0x4>

08100cb6 <BusFault_Handler>:

/**
  * @brief This function handles Pre-fetch fault, memory access fault.
  */
void BusFault_Handler(void)
{
 8100cb6:	b480      	push	{r7}
 8100cb8:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN BusFault_IRQn 0 */

  /* USER CODE END BusFault_IRQn 0 */
  while (1)
 8100cba:	e7fe      	b.n	8100cba <BusFault_Handler+0x4>

08100cbc <UsageFault_Handler>:

/**
  * @brief This function handles Undefined instruction or illegal state.
  */
void UsageFault_Handler(void)
{
 8100cbc:	b480      	push	{r7}
 8100cbe:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN UsageFault_IRQn 0 */

  /* USER CODE END UsageFault_IRQn 0 */
  while (1)
 8100cc0:	e7fe      	b.n	8100cc0 <UsageFault_Handler+0x4>

08100cc2 <SVC_Handler>:

/**
  * @brief This function handles System service call via SWI instruction.
  */
void SVC_Handler(void)
{
 8100cc2:	b480      	push	{r7}
 8100cc4:	af00      	add	r7, sp, #0

  /* USER CODE END SVCall_IRQn 0 */
  /* USER CODE BEGIN SVCall_IRQn 1 */

  /* USER CODE END SVCall_IRQn 1 */
}
 8100cc6:	bf00      	nop
 8100cc8:	46bd      	mov	sp, r7
 8100cca:	f85d 7b04 	ldr.w	r7, [sp], #4
 8100cce:	4770      	bx	lr

08100cd0 <DebugMon_Handler>:

/**
  * @brief This function handles Debug monitor.
  */
void DebugMon_Handler(void)
{
 8100cd0:	b480      	push	{r7}
 8100cd2:	af00      	add	r7, sp, #0

  /* USER CODE END DebugMonitor_IRQn 0 */
  /* USER CODE BEGIN DebugMonitor_IRQn 1 */

  /* USER CODE END DebugMonitor_IRQn 1 */
}
 8100cd4:	bf00      	nop
 8100cd6:	46bd      	mov	sp, r7
 8100cd8:	f85d 7b04 	ldr.w	r7, [sp], #4
 8100cdc:	4770      	bx	lr

08100cde <PendSV_Handler>:

/**
  * @brief This function handles Pendable request for system service.
  */
void PendSV_Handler(void)
{
 8100cde:	b480      	push	{r7}
 8100ce0:	af00      	add	r7, sp, #0

  /* USER CODE END PendSV_IRQn 0 */
  /* USER CODE BEGIN PendSV_IRQn 1 */

  /* USER CODE END PendSV_IRQn 1 */
}
 8100ce2:	bf00      	nop
 8100ce4:	46bd      	mov	sp, r7
 8100ce6:	f85d 7b04 	ldr.w	r7, [sp], #4
 8100cea:	4770      	bx	lr

08100cec <SysTick_Handler>:

/**
  * @brief This function handles System tick timer.
  */
void SysTick_Handler(void)
{
 8100cec:	b580      	push	{r7, lr}
 8100cee:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN SysTick_IRQn 0 */

  /* USER CODE END SysTick_IRQn 0 */
  HAL_IncTick();
 8100cf0:	f000 fc90 	bl	8101614 <HAL_IncTick>
  /* USER CODE BEGIN SysTick_IRQn 1 */

  /* USER CODE END SysTick_IRQn 1 */
}
 8100cf4:	bf00      	nop
 8100cf6:	bd80      	pop	{r7, pc}

08100cf8 <EXTI15_10_IRQHandler>:

/**
  * @brief This function handles EXTI line[15:10] interrupts.
  */
void EXTI15_10_IRQHandler(void)
{
 8100cf8:	b580      	push	{r7, lr}
 8100cfa:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN EXTI15_10_IRQn 0 */

  /* USER CODE END EXTI15_10_IRQn 0 */
  BSP_PB_IRQHandler(BUTTON_USER);
 8100cfc:	2000      	movs	r0, #0
 8100cfe:	f000 faf9 	bl	81012f4 <BSP_PB_IRQHandler>
  /* USER CODE BEGIN EXTI15_10_IRQn 1 */

  /* USER CODE END EXTI15_10_IRQn 1 */
}
 8100d02:	bf00      	nop
 8100d04:	bd80      	pop	{r7, pc}
	...

08100d08 <OTG_FS_WKUP_IRQHandler>:

/**
  * @brief This function handles USB On The Go FS wake-up interrupt through EXTI line 44.
  */
void OTG_FS_WKUP_IRQHandler(void)
{
 8100d08:	b580      	push	{r7, lr}
 8100d0a:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN OTG_FS_WKUP_IRQn 0 */

  /* USER CODE END OTG_FS_WKUP_IRQn 0 */
  HAL_PCD_IRQHandler(&hpcd_USB_OTG_FS);
 8100d0c:	4802      	ldr	r0, [pc, #8]	; (8100d18 <OTG_FS_WKUP_IRQHandler+0x10>)
 8100d0e:	f004 fe7c 	bl	8105a0a <HAL_PCD_IRQHandler>
  /* USER CODE BEGIN OTG_FS_WKUP_IRQn 1 */

  /* USER CODE END OTG_FS_WKUP_IRQn 1 */
}
 8100d12:	bf00      	nop
 8100d14:	bd80      	pop	{r7, pc}
 8100d16:	bf00      	nop
 8100d18:	10008984 	.word	0x10008984

08100d1c <OTG_FS_IRQHandler>:

/**
  * @brief This function handles USB On The Go FS global interrupt.
  */
void OTG_FS_IRQHandler(void)
{
 8100d1c:	b580      	push	{r7, lr}
 8100d1e:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN OTG_FS_IRQn 0 */

  /* USER CODE END OTG_FS_IRQn 0 */
  HAL_PCD_IRQHandler(&hpcd_USB_OTG_FS);
 8100d20:	4802      	ldr	r0, [pc, #8]	; (8100d2c <OTG_FS_IRQHandler+0x10>)
 8100d22:	f004 fe72 	bl	8105a0a <HAL_PCD_IRQHandler>
  /* USER CODE BEGIN OTG_FS_IRQn 1 */

  /* USER CODE END OTG_FS_IRQn 1 */
}
 8100d26:	bf00      	nop
 8100d28:	bd80      	pop	{r7, pc}
 8100d2a:	bf00      	nop
 8100d2c:	10008984 	.word	0x10008984

08100d30 <_getpid>:
void initialise_monitor_handles()
{
}

int _getpid(void)
{
 8100d30:	b480      	push	{r7}
 8100d32:	af00      	add	r7, sp, #0
  return 1;
 8100d34:	2301      	movs	r3, #1
}
 8100d36:	4618      	mov	r0, r3
 8100d38:	46bd      	mov	sp, r7
 8100d3a:	f85d 7b04 	ldr.w	r7, [sp], #4
 8100d3e:	4770      	bx	lr

08100d40 <_kill>:

int _kill(int pid, int sig)
{
 8100d40:	b480      	push	{r7}
 8100d42:	b083      	sub	sp, #12
 8100d44:	af00      	add	r7, sp, #0
 8100d46:	6078      	str	r0, [r7, #4]
 8100d48:	6039      	str	r1, [r7, #0]
  (void)pid;
  (void)sig;
  errno = EINVAL;
 8100d4a:	4b05      	ldr	r3, [pc, #20]	; (8100d60 <_kill+0x20>)
 8100d4c:	2216      	movs	r2, #22
 8100d4e:	601a      	str	r2, [r3, #0]
  return -1;
 8100d50:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
}
 8100d54:	4618      	mov	r0, r3
 8100d56:	370c      	adds	r7, #12
 8100d58:	46bd      	mov	sp, r7
 8100d5a:	f85d 7b04 	ldr.w	r7, [sp], #4
 8100d5e:	4770      	bx	lr
 8100d60:	10008fb8 	.word	0x10008fb8

08100d64 <_exit>:

void _exit (int status)
{
 8100d64:	b580      	push	{r7, lr}
 8100d66:	b082      	sub	sp, #8
 8100d68:	af00      	add	r7, sp, #0
 8100d6a:	6078      	str	r0, [r7, #4]
  _kill(status, -1);
 8100d6c:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
 8100d70:	6878      	ldr	r0, [r7, #4]
 8100d72:	f7ff ffe5 	bl	8100d40 <_kill>
  while (1) {}    /* Make sure we hang here */
 8100d76:	e7fe      	b.n	8100d76 <_exit+0x12>

08100d78 <_read>:
}

__attribute__((weak)) int _read(int file, char *ptr, int len)
{
 8100d78:	b580      	push	{r7, lr}
 8100d7a:	b086      	sub	sp, #24
 8100d7c:	af00      	add	r7, sp, #0
 8100d7e:	60f8      	str	r0, [r7, #12]
 8100d80:	60b9      	str	r1, [r7, #8]
 8100d82:	607a      	str	r2, [r7, #4]
  (void)file;
  int DataIdx;

  for (DataIdx = 0; DataIdx < len; DataIdx++)
 8100d84:	2300      	movs	r3, #0
 8100d86:	617b      	str	r3, [r7, #20]
 8100d88:	e00a      	b.n	8100da0 <_read+0x28>
  {
    *ptr++ = __io_getchar();
 8100d8a:	f3af 8000 	nop.w
 8100d8e:	4601      	mov	r1, r0
 8100d90:	68bb      	ldr	r3, [r7, #8]
 8100d92:	1c5a      	adds	r2, r3, #1
 8100d94:	60ba      	str	r2, [r7, #8]
 8100d96:	b2ca      	uxtb	r2, r1
 8100d98:	701a      	strb	r2, [r3, #0]
  for (DataIdx = 0; DataIdx < len; DataIdx++)
 8100d9a:	697b      	ldr	r3, [r7, #20]
 8100d9c:	3301      	adds	r3, #1
 8100d9e:	617b      	str	r3, [r7, #20]
 8100da0:	697a      	ldr	r2, [r7, #20]
 8100da2:	687b      	ldr	r3, [r7, #4]
 8100da4:	429a      	cmp	r2, r3
 8100da6:	dbf0      	blt.n	8100d8a <_read+0x12>
  }

  return len;
 8100da8:	687b      	ldr	r3, [r7, #4]
}
 8100daa:	4618      	mov	r0, r3
 8100dac:	3718      	adds	r7, #24
 8100dae:	46bd      	mov	sp, r7
 8100db0:	bd80      	pop	{r7, pc}

08100db2 <_write>:

__attribute__((weak)) int _write(int file, char *ptr, int len)
{
 8100db2:	b580      	push	{r7, lr}
 8100db4:	b086      	sub	sp, #24
 8100db6:	af00      	add	r7, sp, #0
 8100db8:	60f8      	str	r0, [r7, #12]
 8100dba:	60b9      	str	r1, [r7, #8]
 8100dbc:	607a      	str	r2, [r7, #4]
  (void)file;
  int DataIdx;

  for (DataIdx = 0; DataIdx < len; DataIdx++)
 8100dbe:	2300      	movs	r3, #0
 8100dc0:	617b      	str	r3, [r7, #20]
 8100dc2:	e009      	b.n	8100dd8 <_write+0x26>
  {
    __io_putchar(*ptr++);
 8100dc4:	68bb      	ldr	r3, [r7, #8]
 8100dc6:	1c5a      	adds	r2, r3, #1
 8100dc8:	60ba      	str	r2, [r7, #8]
 8100dca:	781b      	ldrb	r3, [r3, #0]
 8100dcc:	4618      	mov	r0, r3
 8100dce:	f000 fb11 	bl	81013f4 <__io_putchar>
  for (DataIdx = 0; DataIdx < len; DataIdx++)
 8100dd2:	697b      	ldr	r3, [r7, #20]
 8100dd4:	3301      	adds	r3, #1
 8100dd6:	617b      	str	r3, [r7, #20]
 8100dd8:	697a      	ldr	r2, [r7, #20]
 8100dda:	687b      	ldr	r3, [r7, #4]
 8100ddc:	429a      	cmp	r2, r3
 8100dde:	dbf1      	blt.n	8100dc4 <_write+0x12>
  }
  return len;
 8100de0:	687b      	ldr	r3, [r7, #4]
}
 8100de2:	4618      	mov	r0, r3
 8100de4:	3718      	adds	r7, #24
 8100de6:	46bd      	mov	sp, r7
 8100de8:	bd80      	pop	{r7, pc}

08100dea <_close>:

int _close(int file)
{
 8100dea:	b480      	push	{r7}
 8100dec:	b083      	sub	sp, #12
 8100dee:	af00      	add	r7, sp, #0
 8100df0:	6078      	str	r0, [r7, #4]
  (void)file;
  return -1;
 8100df2:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
}
 8100df6:	4618      	mov	r0, r3
 8100df8:	370c      	adds	r7, #12
 8100dfa:	46bd      	mov	sp, r7
 8100dfc:	f85d 7b04 	ldr.w	r7, [sp], #4
 8100e00:	4770      	bx	lr

08100e02 <_fstat>:


int _fstat(int file, struct stat *st)
{
 8100e02:	b480      	push	{r7}
 8100e04:	b083      	sub	sp, #12
 8100e06:	af00      	add	r7, sp, #0
 8100e08:	6078      	str	r0, [r7, #4]
 8100e0a:	6039      	str	r1, [r7, #0]
  (void)file;
  st->st_mode = S_IFCHR;
 8100e0c:	683b      	ldr	r3, [r7, #0]
 8100e0e:	f44f 5200 	mov.w	r2, #8192	; 0x2000
 8100e12:	605a      	str	r2, [r3, #4]
  return 0;
 8100e14:	2300      	movs	r3, #0
}
 8100e16:	4618      	mov	r0, r3
 8100e18:	370c      	adds	r7, #12
 8100e1a:	46bd      	mov	sp, r7
 8100e1c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8100e20:	4770      	bx	lr

08100e22 <_isatty>:

int _isatty(int file)
{
 8100e22:	b480      	push	{r7}
 8100e24:	b083      	sub	sp, #12
 8100e26:	af00      	add	r7, sp, #0
 8100e28:	6078      	str	r0, [r7, #4]
  (void)file;
  return 1;
 8100e2a:	2301      	movs	r3, #1
}
 8100e2c:	4618      	mov	r0, r3
 8100e2e:	370c      	adds	r7, #12
 8100e30:	46bd      	mov	sp, r7
 8100e32:	f85d 7b04 	ldr.w	r7, [sp], #4
 8100e36:	4770      	bx	lr

08100e38 <_lseek>:

int _lseek(int file, int ptr, int dir)
{
 8100e38:	b480      	push	{r7}
 8100e3a:	b085      	sub	sp, #20
 8100e3c:	af00      	add	r7, sp, #0
 8100e3e:	60f8      	str	r0, [r7, #12]
 8100e40:	60b9      	str	r1, [r7, #8]
 8100e42:	607a      	str	r2, [r7, #4]
  (void)file;
  (void)ptr;
  (void)dir;
  return 0;
 8100e44:	2300      	movs	r3, #0
}
 8100e46:	4618      	mov	r0, r3
 8100e48:	3714      	adds	r7, #20
 8100e4a:	46bd      	mov	sp, r7
 8100e4c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8100e50:	4770      	bx	lr
	...

08100e54 <_sbrk>:
 *
 * @param incr Memory size
 * @return Pointer to allocated memory
 */
void *_sbrk(ptrdiff_t incr)
{
 8100e54:	b480      	push	{r7}
 8100e56:	b087      	sub	sp, #28
 8100e58:	af00      	add	r7, sp, #0
 8100e5a:	6078      	str	r0, [r7, #4]
  extern uint8_t _end; /* Symbol defined in the linker script */
  extern uint8_t _estack; /* Symbol defined in the linker script */
  extern uint32_t _Min_Stack_Size; /* Symbol defined in the linker script */
  const uint32_t stack_limit = (uint32_t)&_estack - (uint32_t)&_Min_Stack_Size;
 8100e5c:	4a14      	ldr	r2, [pc, #80]	; (8100eb0 <_sbrk+0x5c>)
 8100e5e:	4b15      	ldr	r3, [pc, #84]	; (8100eb4 <_sbrk+0x60>)
 8100e60:	1ad3      	subs	r3, r2, r3
 8100e62:	617b      	str	r3, [r7, #20]
  const uint8_t *max_heap = (uint8_t *)stack_limit;
 8100e64:	697b      	ldr	r3, [r7, #20]
 8100e66:	613b      	str	r3, [r7, #16]
  uint8_t *prev_heap_end;

  /* Initialize heap end at first call */
  if (NULL == __sbrk_heap_end)
 8100e68:	4b13      	ldr	r3, [pc, #76]	; (8100eb8 <_sbrk+0x64>)
 8100e6a:	681b      	ldr	r3, [r3, #0]
 8100e6c:	2b00      	cmp	r3, #0
 8100e6e:	d102      	bne.n	8100e76 <_sbrk+0x22>
  {
    __sbrk_heap_end = &_end;
 8100e70:	4b11      	ldr	r3, [pc, #68]	; (8100eb8 <_sbrk+0x64>)
 8100e72:	4a12      	ldr	r2, [pc, #72]	; (8100ebc <_sbrk+0x68>)
 8100e74:	601a      	str	r2, [r3, #0]
  }

  /* Protect heap from growing into the reserved MSP stack */
  if (__sbrk_heap_end + incr > max_heap)
 8100e76:	4b10      	ldr	r3, [pc, #64]	; (8100eb8 <_sbrk+0x64>)
 8100e78:	681a      	ldr	r2, [r3, #0]
 8100e7a:	687b      	ldr	r3, [r7, #4]
 8100e7c:	4413      	add	r3, r2
 8100e7e:	693a      	ldr	r2, [r7, #16]
 8100e80:	429a      	cmp	r2, r3
 8100e82:	d205      	bcs.n	8100e90 <_sbrk+0x3c>
  {
    errno = ENOMEM;
 8100e84:	4b0e      	ldr	r3, [pc, #56]	; (8100ec0 <_sbrk+0x6c>)
 8100e86:	220c      	movs	r2, #12
 8100e88:	601a      	str	r2, [r3, #0]
    return (void *)-1;
 8100e8a:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 8100e8e:	e009      	b.n	8100ea4 <_sbrk+0x50>
  }

  prev_heap_end = __sbrk_heap_end;
 8100e90:	4b09      	ldr	r3, [pc, #36]	; (8100eb8 <_sbrk+0x64>)
 8100e92:	681b      	ldr	r3, [r3, #0]
 8100e94:	60fb      	str	r3, [r7, #12]
  __sbrk_heap_end += incr;
 8100e96:	4b08      	ldr	r3, [pc, #32]	; (8100eb8 <_sbrk+0x64>)
 8100e98:	681a      	ldr	r2, [r3, #0]
 8100e9a:	687b      	ldr	r3, [r7, #4]
 8100e9c:	4413      	add	r3, r2
 8100e9e:	4a06      	ldr	r2, [pc, #24]	; (8100eb8 <_sbrk+0x64>)
 8100ea0:	6013      	str	r3, [r2, #0]

  return (void *)prev_heap_end;
 8100ea2:	68fb      	ldr	r3, [r7, #12]
}
 8100ea4:	4618      	mov	r0, r3
 8100ea6:	371c      	adds	r7, #28
 8100ea8:	46bd      	mov	sp, r7
 8100eaa:	f85d 7b04 	ldr.w	r7, [sp], #4
 8100eae:	4770      	bx	lr
 8100eb0:	10048000 	.word	0x10048000
 8100eb4:	00000400 	.word	0x00000400
 8100eb8:	100003b0 	.word	0x100003b0
 8100ebc:	10008fc8 	.word	0x10008fc8
 8100ec0:	10008fb8 	.word	0x10008fb8

08100ec4 <Reset_Handler>:

    .section  .text.Reset_Handler
  .weak  Reset_Handler
  .type  Reset_Handler, %function
Reset_Handler:
  ldr   sp, =_estack      /* set stack pointer */
 8100ec4:	f8df d034 	ldr.w	sp, [pc, #52]	; 8100efc <LoopFillZerobss+0xe>

/* Call the clock system initialization function.*/
  bl  SystemInit
 8100ec8:	f7ff fbe0 	bl	810068c <SystemInit>

/* Copy the data segment initializers from flash to SRAM */
  ldr r0, =_sdata
 8100ecc:	480c      	ldr	r0, [pc, #48]	; (8100f00 <LoopFillZerobss+0x12>)
  ldr r1, =_edata
 8100ece:	490d      	ldr	r1, [pc, #52]	; (8100f04 <LoopFillZerobss+0x16>)
  ldr r2, =_sidata
 8100ed0:	4a0d      	ldr	r2, [pc, #52]	; (8100f08 <LoopFillZerobss+0x1a>)
  movs r3, #0
 8100ed2:	2300      	movs	r3, #0
  b LoopCopyDataInit
 8100ed4:	e002      	b.n	8100edc <LoopCopyDataInit>

08100ed6 <CopyDataInit>:

CopyDataInit:
  ldr r4, [r2, r3]
 8100ed6:	58d4      	ldr	r4, [r2, r3]
  str r4, [r0, r3]
 8100ed8:	50c4      	str	r4, [r0, r3]
  adds r3, r3, #4
 8100eda:	3304      	adds	r3, #4

08100edc <LoopCopyDataInit>:

LoopCopyDataInit:
  adds r4, r0, r3
 8100edc:	18c4      	adds	r4, r0, r3
  cmp r4, r1
 8100ede:	428c      	cmp	r4, r1
  bcc CopyDataInit
 8100ee0:	d3f9      	bcc.n	8100ed6 <CopyDataInit>
/* Zero fill the bss segment. */
  ldr r2, =_sbss
 8100ee2:	4a0a      	ldr	r2, [pc, #40]	; (8100f0c <LoopFillZerobss+0x1e>)
  ldr r4, =_ebss
 8100ee4:	4c0a      	ldr	r4, [pc, #40]	; (8100f10 <LoopFillZerobss+0x22>)
  movs r3, #0
 8100ee6:	2300      	movs	r3, #0
  b LoopFillZerobss
 8100ee8:	e001      	b.n	8100eee <LoopFillZerobss>

08100eea <FillZerobss>:

FillZerobss:
  str  r3, [r2]
 8100eea:	6013      	str	r3, [r2, #0]
  adds r2, r2, #4
 8100eec:	3204      	adds	r2, #4

08100eee <LoopFillZerobss>:

LoopFillZerobss:
  cmp r2, r4
 8100eee:	42a2      	cmp	r2, r4
  bcc FillZerobss
 8100ef0:	d3fb      	bcc.n	8100eea <FillZerobss>

/* Call static constructors */
    bl __libc_init_array
 8100ef2:	f01a fcb7 	bl	811b864 <__libc_init_array>
/* Call the application's entry point.*/
  bl  main
 8100ef6:	f7ff fbe1 	bl	81006bc <main>
  bx  lr
 8100efa:	4770      	bx	lr
  ldr   sp, =_estack      /* set stack pointer */
 8100efc:	10048000 	.word	0x10048000
  ldr r0, =_sdata
 8100f00:	10000000 	.word	0x10000000
  ldr r1, =_edata
 8100f04:	100001c0 	.word	0x100001c0
  ldr r2, =_sidata
 8100f08:	0811fb14 	.word	0x0811fb14
  ldr r2, =_sbss
 8100f0c:	10000280 	.word	0x10000280
  ldr r4, =_ebss
 8100f10:	10008fc8 	.word	0x10008fc8

08100f14 <ADC3_IRQHandler>:
 * @retval None
*/
    .section  .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b  Infinite_Loop
 8100f14:	e7fe      	b.n	8100f14 <ADC3_IRQHandler>

08100f16 <LAN8742_RegisterBusIO>:
  * @param  ioctx: holds device IO functions.
  * @retval LAN8742_STATUS_OK  if OK
  *         LAN8742_STATUS_ERROR if missing mandatory function
  */
int32_t  LAN8742_RegisterBusIO(lan8742_Object_t *pObj, lan8742_IOCtx_t *ioctx)
{
 8100f16:	b480      	push	{r7}
 8100f18:	b083      	sub	sp, #12
 8100f1a:	af00      	add	r7, sp, #0
 8100f1c:	6078      	str	r0, [r7, #4]
 8100f1e:	6039      	str	r1, [r7, #0]
  if(!pObj || !ioctx->ReadReg || !ioctx->WriteReg || !ioctx->GetTick)
 8100f20:	687b      	ldr	r3, [r7, #4]
 8100f22:	2b00      	cmp	r3, #0
 8100f24:	d00b      	beq.n	8100f3e <LAN8742_RegisterBusIO+0x28>
 8100f26:	683b      	ldr	r3, [r7, #0]
 8100f28:	68db      	ldr	r3, [r3, #12]
 8100f2a:	2b00      	cmp	r3, #0
 8100f2c:	d007      	beq.n	8100f3e <LAN8742_RegisterBusIO+0x28>
 8100f2e:	683b      	ldr	r3, [r7, #0]
 8100f30:	689b      	ldr	r3, [r3, #8]
 8100f32:	2b00      	cmp	r3, #0
 8100f34:	d003      	beq.n	8100f3e <LAN8742_RegisterBusIO+0x28>
 8100f36:	683b      	ldr	r3, [r7, #0]
 8100f38:	691b      	ldr	r3, [r3, #16]
 8100f3a:	2b00      	cmp	r3, #0
 8100f3c:	d102      	bne.n	8100f44 <LAN8742_RegisterBusIO+0x2e>
  {
    return LAN8742_STATUS_ERROR;
 8100f3e:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 8100f42:	e014      	b.n	8100f6e <LAN8742_RegisterBusIO+0x58>
  }

  pObj->IO.Init = ioctx->Init;
 8100f44:	683b      	ldr	r3, [r7, #0]
 8100f46:	681a      	ldr	r2, [r3, #0]
 8100f48:	687b      	ldr	r3, [r7, #4]
 8100f4a:	609a      	str	r2, [r3, #8]
  pObj->IO.DeInit = ioctx->DeInit;
 8100f4c:	683b      	ldr	r3, [r7, #0]
 8100f4e:	685a      	ldr	r2, [r3, #4]
 8100f50:	687b      	ldr	r3, [r7, #4]
 8100f52:	60da      	str	r2, [r3, #12]
  pObj->IO.ReadReg = ioctx->ReadReg;
 8100f54:	683b      	ldr	r3, [r7, #0]
 8100f56:	68da      	ldr	r2, [r3, #12]
 8100f58:	687b      	ldr	r3, [r7, #4]
 8100f5a:	615a      	str	r2, [r3, #20]
  pObj->IO.WriteReg = ioctx->WriteReg;
 8100f5c:	683b      	ldr	r3, [r7, #0]
 8100f5e:	689a      	ldr	r2, [r3, #8]
 8100f60:	687b      	ldr	r3, [r7, #4]
 8100f62:	611a      	str	r2, [r3, #16]
  pObj->IO.GetTick = ioctx->GetTick;
 8100f64:	683b      	ldr	r3, [r7, #0]
 8100f66:	691a      	ldr	r2, [r3, #16]
 8100f68:	687b      	ldr	r3, [r7, #4]
 8100f6a:	619a      	str	r2, [r3, #24]

  return LAN8742_STATUS_OK;
 8100f6c:	2300      	movs	r3, #0
}
 8100f6e:	4618      	mov	r0, r3
 8100f70:	370c      	adds	r7, #12
 8100f72:	46bd      	mov	sp, r7
 8100f74:	f85d 7b04 	ldr.w	r7, [sp], #4
 8100f78:	4770      	bx	lr

08100f7a <LAN8742_Init>:
  * @retval LAN8742_STATUS_OK  if OK
  *         LAN8742_STATUS_ADDRESS_ERROR if cannot find device address
  *         LAN8742_STATUS_READ_ERROR if cannot read register
  */
 int32_t LAN8742_Init(lan8742_Object_t *pObj)
 {
 8100f7a:	b580      	push	{r7, lr}
 8100f7c:	b086      	sub	sp, #24
 8100f7e:	af00      	add	r7, sp, #0
 8100f80:	6078      	str	r0, [r7, #4]
   uint32_t regvalue = 0, addr = 0;
 8100f82:	2300      	movs	r3, #0
 8100f84:	60fb      	str	r3, [r7, #12]
 8100f86:	2300      	movs	r3, #0
 8100f88:	617b      	str	r3, [r7, #20]
   int32_t status = LAN8742_STATUS_OK;
 8100f8a:	2300      	movs	r3, #0
 8100f8c:	613b      	str	r3, [r7, #16]

   if(pObj->Is_Initialized == 0)
 8100f8e:	687b      	ldr	r3, [r7, #4]
 8100f90:	685b      	ldr	r3, [r3, #4]
 8100f92:	2b00      	cmp	r3, #0
 8100f94:	d139      	bne.n	810100a <LAN8742_Init+0x90>
   {
     if(pObj->IO.Init != 0)
 8100f96:	687b      	ldr	r3, [r7, #4]
 8100f98:	689b      	ldr	r3, [r3, #8]
 8100f9a:	2b00      	cmp	r3, #0
 8100f9c:	d002      	beq.n	8100fa4 <LAN8742_Init+0x2a>
     {
       /* GPIO and Clocks initialization */
       pObj->IO.Init();
 8100f9e:	687b      	ldr	r3, [r7, #4]
 8100fa0:	689b      	ldr	r3, [r3, #8]
 8100fa2:	4798      	blx	r3
     }

     /* for later check */
     pObj->DevAddr = LAN8742_MAX_DEV_ADDR + 1;
 8100fa4:	687b      	ldr	r3, [r7, #4]
 8100fa6:	2220      	movs	r2, #32
 8100fa8:	601a      	str	r2, [r3, #0]

     /* Get the device address from special mode register */
     for(addr = 0; addr <= LAN8742_MAX_DEV_ADDR; addr ++)
 8100faa:	2300      	movs	r3, #0
 8100fac:	617b      	str	r3, [r7, #20]
 8100fae:	e01c      	b.n	8100fea <LAN8742_Init+0x70>
     {
       if(pObj->IO.ReadReg(addr, LAN8742_SMR, &regvalue) < 0)
 8100fb0:	687b      	ldr	r3, [r7, #4]
 8100fb2:	695b      	ldr	r3, [r3, #20]
 8100fb4:	f107 020c 	add.w	r2, r7, #12
 8100fb8:	2112      	movs	r1, #18
 8100fba:	6978      	ldr	r0, [r7, #20]
 8100fbc:	4798      	blx	r3
 8100fbe:	4603      	mov	r3, r0
 8100fc0:	2b00      	cmp	r3, #0
 8100fc2:	da03      	bge.n	8100fcc <LAN8742_Init+0x52>
       {
         status = LAN8742_STATUS_READ_ERROR;
 8100fc4:	f06f 0304 	mvn.w	r3, #4
 8100fc8:	613b      	str	r3, [r7, #16]
         /* Can't read from this device address
            continue with next address */
         continue;
 8100fca:	e00b      	b.n	8100fe4 <LAN8742_Init+0x6a>
       }

       if((regvalue & LAN8742_SMR_PHY_ADDR) == addr)
 8100fcc:	68fb      	ldr	r3, [r7, #12]
 8100fce:	f003 031f 	and.w	r3, r3, #31
 8100fd2:	697a      	ldr	r2, [r7, #20]
 8100fd4:	429a      	cmp	r2, r3
 8100fd6:	d105      	bne.n	8100fe4 <LAN8742_Init+0x6a>
       {
         pObj->DevAddr = addr;
 8100fd8:	687b      	ldr	r3, [r7, #4]
 8100fda:	697a      	ldr	r2, [r7, #20]
 8100fdc:	601a      	str	r2, [r3, #0]
         status = LAN8742_STATUS_OK;
 8100fde:	2300      	movs	r3, #0
 8100fe0:	613b      	str	r3, [r7, #16]
         break;
 8100fe2:	e005      	b.n	8100ff0 <LAN8742_Init+0x76>
     for(addr = 0; addr <= LAN8742_MAX_DEV_ADDR; addr ++)
 8100fe4:	697b      	ldr	r3, [r7, #20]
 8100fe6:	3301      	adds	r3, #1
 8100fe8:	617b      	str	r3, [r7, #20]
 8100fea:	697b      	ldr	r3, [r7, #20]
 8100fec:	2b1f      	cmp	r3, #31
 8100fee:	d9df      	bls.n	8100fb0 <LAN8742_Init+0x36>
       }
     }

     if(pObj->DevAddr > LAN8742_MAX_DEV_ADDR)
 8100ff0:	687b      	ldr	r3, [r7, #4]
 8100ff2:	681b      	ldr	r3, [r3, #0]
 8100ff4:	2b1f      	cmp	r3, #31
 8100ff6:	d902      	bls.n	8100ffe <LAN8742_Init+0x84>
     {
       status = LAN8742_STATUS_ADDRESS_ERROR;
 8100ff8:	f06f 0302 	mvn.w	r3, #2
 8100ffc:	613b      	str	r3, [r7, #16]
     }

     /* if device address is matched */
     if(status == LAN8742_STATUS_OK)
 8100ffe:	693b      	ldr	r3, [r7, #16]
 8101000:	2b00      	cmp	r3, #0
 8101002:	d102      	bne.n	810100a <LAN8742_Init+0x90>
     {
       pObj->Is_Initialized = 1;
 8101004:	687b      	ldr	r3, [r7, #4]
 8101006:	2201      	movs	r2, #1
 8101008:	605a      	str	r2, [r3, #4]
     }
   }

   return status;
 810100a:	693b      	ldr	r3, [r7, #16]
 }
 810100c:	4618      	mov	r0, r3
 810100e:	3718      	adds	r7, #24
 8101010:	46bd      	mov	sp, r7
 8101012:	bd80      	pop	{r7, pc}

08101014 <LAN8742_GetLinkState>:
  *         LAN8742_STATUS_10MBITS_HALFDUPLEX  if 10Mb/s HD
  *         LAN8742_STATUS_READ_ERROR if cannot read register
  *         LAN8742_STATUS_WRITE_ERROR if cannot write to register
  */
int32_t LAN8742_GetLinkState(lan8742_Object_t *pObj)
{
 8101014:	b580      	push	{r7, lr}
 8101016:	b084      	sub	sp, #16
 8101018:	af00      	add	r7, sp, #0
 810101a:	6078      	str	r0, [r7, #4]
  uint32_t readval = 0;
 810101c:	2300      	movs	r3, #0
 810101e:	60fb      	str	r3, [r7, #12]

  /* Read Status register  */
  if(pObj->IO.ReadReg(pObj->DevAddr, LAN8742_BSR, &readval) < 0)
 8101020:	687b      	ldr	r3, [r7, #4]
 8101022:	695b      	ldr	r3, [r3, #20]
 8101024:	687a      	ldr	r2, [r7, #4]
 8101026:	6810      	ldr	r0, [r2, #0]
 8101028:	f107 020c 	add.w	r2, r7, #12
 810102c:	2101      	movs	r1, #1
 810102e:	4798      	blx	r3
 8101030:	4603      	mov	r3, r0
 8101032:	2b00      	cmp	r3, #0
 8101034:	da02      	bge.n	810103c <LAN8742_GetLinkState+0x28>
  {
    return LAN8742_STATUS_READ_ERROR;
 8101036:	f06f 0304 	mvn.w	r3, #4
 810103a:	e06e      	b.n	810111a <LAN8742_GetLinkState+0x106>
  }

  /* Read Status register again */
  if(pObj->IO.ReadReg(pObj->DevAddr, LAN8742_BSR, &readval) < 0)
 810103c:	687b      	ldr	r3, [r7, #4]
 810103e:	695b      	ldr	r3, [r3, #20]
 8101040:	687a      	ldr	r2, [r7, #4]
 8101042:	6810      	ldr	r0, [r2, #0]
 8101044:	f107 020c 	add.w	r2, r7, #12
 8101048:	2101      	movs	r1, #1
 810104a:	4798      	blx	r3
 810104c:	4603      	mov	r3, r0
 810104e:	2b00      	cmp	r3, #0
 8101050:	da02      	bge.n	8101058 <LAN8742_GetLinkState+0x44>
  {
    return LAN8742_STATUS_READ_ERROR;
 8101052:	f06f 0304 	mvn.w	r3, #4
 8101056:	e060      	b.n	810111a <LAN8742_GetLinkState+0x106>
  }

  if((readval & LAN8742_BSR_LINK_STATUS) == 0)
 8101058:	68fb      	ldr	r3, [r7, #12]
 810105a:	f003 0304 	and.w	r3, r3, #4
 810105e:	2b00      	cmp	r3, #0
 8101060:	d101      	bne.n	8101066 <LAN8742_GetLinkState+0x52>
  {
    /* Return Link Down status */
    return LAN8742_STATUS_LINK_DOWN;
 8101062:	2301      	movs	r3, #1
 8101064:	e059      	b.n	810111a <LAN8742_GetLinkState+0x106>
  }

  /* Check Auto negotiation */
  if(pObj->IO.ReadReg(pObj->DevAddr, LAN8742_BCR, &readval) < 0)
 8101066:	687b      	ldr	r3, [r7, #4]
 8101068:	695b      	ldr	r3, [r3, #20]
 810106a:	687a      	ldr	r2, [r7, #4]
 810106c:	6810      	ldr	r0, [r2, #0]
 810106e:	f107 020c 	add.w	r2, r7, #12
 8101072:	2100      	movs	r1, #0
 8101074:	4798      	blx	r3
 8101076:	4603      	mov	r3, r0
 8101078:	2b00      	cmp	r3, #0
 810107a:	da02      	bge.n	8101082 <LAN8742_GetLinkState+0x6e>
  {
    return LAN8742_STATUS_READ_ERROR;
 810107c:	f06f 0304 	mvn.w	r3, #4
 8101080:	e04b      	b.n	810111a <LAN8742_GetLinkState+0x106>
  }

  if((readval & LAN8742_BCR_AUTONEGO_EN) != LAN8742_BCR_AUTONEGO_EN)
 8101082:	68fb      	ldr	r3, [r7, #12]
 8101084:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
 8101088:	2b00      	cmp	r3, #0
 810108a:	d11b      	bne.n	81010c4 <LAN8742_GetLinkState+0xb0>
  {
    if(((readval & LAN8742_BCR_SPEED_SELECT) == LAN8742_BCR_SPEED_SELECT) && ((readval & LAN8742_BCR_DUPLEX_MODE) == LAN8742_BCR_DUPLEX_MODE))
 810108c:	68fb      	ldr	r3, [r7, #12]
 810108e:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
 8101092:	2b00      	cmp	r3, #0
 8101094:	d006      	beq.n	81010a4 <LAN8742_GetLinkState+0x90>
 8101096:	68fb      	ldr	r3, [r7, #12]
 8101098:	f403 7380 	and.w	r3, r3, #256	; 0x100
 810109c:	2b00      	cmp	r3, #0
 810109e:	d001      	beq.n	81010a4 <LAN8742_GetLinkState+0x90>
    {
      return LAN8742_STATUS_100MBITS_FULLDUPLEX;
 81010a0:	2302      	movs	r3, #2
 81010a2:	e03a      	b.n	810111a <LAN8742_GetLinkState+0x106>
    }
    else if ((readval & LAN8742_BCR_SPEED_SELECT) == LAN8742_BCR_SPEED_SELECT)
 81010a4:	68fb      	ldr	r3, [r7, #12]
 81010a6:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
 81010aa:	2b00      	cmp	r3, #0
 81010ac:	d001      	beq.n	81010b2 <LAN8742_GetLinkState+0x9e>
    {
      return LAN8742_STATUS_100MBITS_HALFDUPLEX;
 81010ae:	2303      	movs	r3, #3
 81010b0:	e033      	b.n	810111a <LAN8742_GetLinkState+0x106>
    }
    else if ((readval & LAN8742_BCR_DUPLEX_MODE) == LAN8742_BCR_DUPLEX_MODE)
 81010b2:	68fb      	ldr	r3, [r7, #12]
 81010b4:	f403 7380 	and.w	r3, r3, #256	; 0x100
 81010b8:	2b00      	cmp	r3, #0
 81010ba:	d001      	beq.n	81010c0 <LAN8742_GetLinkState+0xac>
    {
      return LAN8742_STATUS_10MBITS_FULLDUPLEX;
 81010bc:	2304      	movs	r3, #4
 81010be:	e02c      	b.n	810111a <LAN8742_GetLinkState+0x106>
    }
    else
    {
      return LAN8742_STATUS_10MBITS_HALFDUPLEX;
 81010c0:	2305      	movs	r3, #5
 81010c2:	e02a      	b.n	810111a <LAN8742_GetLinkState+0x106>
    }
  }
  else /* Auto Nego enabled */
  {
    if(pObj->IO.ReadReg(pObj->DevAddr, LAN8742_PHYSCSR, &readval) < 0)
 81010c4:	687b      	ldr	r3, [r7, #4]
 81010c6:	695b      	ldr	r3, [r3, #20]
 81010c8:	687a      	ldr	r2, [r7, #4]
 81010ca:	6810      	ldr	r0, [r2, #0]
 81010cc:	f107 020c 	add.w	r2, r7, #12
 81010d0:	211f      	movs	r1, #31
 81010d2:	4798      	blx	r3
 81010d4:	4603      	mov	r3, r0
 81010d6:	2b00      	cmp	r3, #0
 81010d8:	da02      	bge.n	81010e0 <LAN8742_GetLinkState+0xcc>
    {
      return LAN8742_STATUS_READ_ERROR;
 81010da:	f06f 0304 	mvn.w	r3, #4
 81010de:	e01c      	b.n	810111a <LAN8742_GetLinkState+0x106>
    }

    /* Check if auto nego not done */
    if((readval & LAN8742_PHYSCSR_AUTONEGO_DONE) == 0)
 81010e0:	68fb      	ldr	r3, [r7, #12]
 81010e2:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
 81010e6:	2b00      	cmp	r3, #0
 81010e8:	d101      	bne.n	81010ee <LAN8742_GetLinkState+0xda>
    {
      return LAN8742_STATUS_AUTONEGO_NOTDONE;
 81010ea:	2306      	movs	r3, #6
 81010ec:	e015      	b.n	810111a <LAN8742_GetLinkState+0x106>
    }

    if((readval & LAN8742_PHYSCSR_HCDSPEEDMASK) == LAN8742_PHYSCSR_100BTX_FD)
 81010ee:	68fb      	ldr	r3, [r7, #12]
 81010f0:	f003 031c 	and.w	r3, r3, #28
 81010f4:	2b18      	cmp	r3, #24
 81010f6:	d101      	bne.n	81010fc <LAN8742_GetLinkState+0xe8>
    {
      return LAN8742_STATUS_100MBITS_FULLDUPLEX;
 81010f8:	2302      	movs	r3, #2
 81010fa:	e00e      	b.n	810111a <LAN8742_GetLinkState+0x106>
    }
    else if ((readval & LAN8742_PHYSCSR_HCDSPEEDMASK) == LAN8742_PHYSCSR_100BTX_HD)
 81010fc:	68fb      	ldr	r3, [r7, #12]
 81010fe:	f003 031c 	and.w	r3, r3, #28
 8101102:	2b08      	cmp	r3, #8
 8101104:	d101      	bne.n	810110a <LAN8742_GetLinkState+0xf6>
    {
      return LAN8742_STATUS_100MBITS_HALFDUPLEX;
 8101106:	2303      	movs	r3, #3
 8101108:	e007      	b.n	810111a <LAN8742_GetLinkState+0x106>
    }
    else if ((readval & LAN8742_PHYSCSR_HCDSPEEDMASK) == LAN8742_PHYSCSR_10BT_FD)
 810110a:	68fb      	ldr	r3, [r7, #12]
 810110c:	f003 031c 	and.w	r3, r3, #28
 8101110:	2b14      	cmp	r3, #20
 8101112:	d101      	bne.n	8101118 <LAN8742_GetLinkState+0x104>
    {
      return LAN8742_STATUS_10MBITS_FULLDUPLEX;
 8101114:	2304      	movs	r3, #4
 8101116:	e000      	b.n	810111a <LAN8742_GetLinkState+0x106>
    }
    else
    {
      return LAN8742_STATUS_10MBITS_HALFDUPLEX;
 8101118:	2305      	movs	r3, #5
    }
  }
}
 810111a:	4618      	mov	r0, r3
 810111c:	3710      	adds	r7, #16
 810111e:	46bd      	mov	sp, r7
 8101120:	bd80      	pop	{r7, pc}
	...

08101124 <BSP_LED_Init>:
  *     @arg  LED2
  *     @arg  LED3
  * @retval BSP status
  */
int32_t BSP_LED_Init(Led_TypeDef Led)
{
 8101124:	b580      	push	{r7, lr}
 8101126:	b08c      	sub	sp, #48	; 0x30
 8101128:	af00      	add	r7, sp, #0
 810112a:	4603      	mov	r3, r0
 810112c:	71fb      	strb	r3, [r7, #7]
  int32_t ret = BSP_ERROR_NONE;
 810112e:	2300      	movs	r3, #0
 8101130:	62fb      	str	r3, [r7, #44]	; 0x2c
  GPIO_InitTypeDef  gpio_init_structure;

  if((Led != LED1) && (Led != LED2) && (Led != LED3))
 8101132:	79fb      	ldrb	r3, [r7, #7]
 8101134:	2b00      	cmp	r3, #0
 8101136:	d009      	beq.n	810114c <BSP_LED_Init+0x28>
 8101138:	79fb      	ldrb	r3, [r7, #7]
 810113a:	2b01      	cmp	r3, #1
 810113c:	d006      	beq.n	810114c <BSP_LED_Init+0x28>
 810113e:	79fb      	ldrb	r3, [r7, #7]
 8101140:	2b02      	cmp	r3, #2
 8101142:	d003      	beq.n	810114c <BSP_LED_Init+0x28>
  {
    ret = BSP_ERROR_WRONG_PARAM;
 8101144:	f06f 0301 	mvn.w	r3, #1
 8101148:	62fb      	str	r3, [r7, #44]	; 0x2c
 810114a:	e055      	b.n	81011f8 <BSP_LED_Init+0xd4>
  }
  else
  {
    /* Enable the GPIO LED Clock */
    if(Led == LED1)
 810114c:	79fb      	ldrb	r3, [r7, #7]
 810114e:	2b00      	cmp	r3, #0
 8101150:	d10f      	bne.n	8101172 <BSP_LED_Init+0x4e>
    {
      LED1_GPIO_CLK_ENABLE();
 8101152:	4b2c      	ldr	r3, [pc, #176]	; (8101204 <BSP_LED_Init+0xe0>)
 8101154:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
 8101158:	4a2a      	ldr	r2, [pc, #168]	; (8101204 <BSP_LED_Init+0xe0>)
 810115a:	f043 0302 	orr.w	r3, r3, #2
 810115e:	f8c2 30e0 	str.w	r3, [r2, #224]	; 0xe0
 8101162:	4b28      	ldr	r3, [pc, #160]	; (8101204 <BSP_LED_Init+0xe0>)
 8101164:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
 8101168:	f003 0302 	and.w	r3, r3, #2
 810116c:	617b      	str	r3, [r7, #20]
 810116e:	697b      	ldr	r3, [r7, #20]
 8101170:	e021      	b.n	81011b6 <BSP_LED_Init+0x92>
    }
    else if(Led == LED2)
 8101172:	79fb      	ldrb	r3, [r7, #7]
 8101174:	2b01      	cmp	r3, #1
 8101176:	d10f      	bne.n	8101198 <BSP_LED_Init+0x74>
    {
      LED2_GPIO_CLK_ENABLE();
 8101178:	4b22      	ldr	r3, [pc, #136]	; (8101204 <BSP_LED_Init+0xe0>)
 810117a:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
 810117e:	4a21      	ldr	r2, [pc, #132]	; (8101204 <BSP_LED_Init+0xe0>)
 8101180:	f043 0310 	orr.w	r3, r3, #16
 8101184:	f8c2 30e0 	str.w	r3, [r2, #224]	; 0xe0
 8101188:	4b1e      	ldr	r3, [pc, #120]	; (8101204 <BSP_LED_Init+0xe0>)
 810118a:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
 810118e:	f003 0310 	and.w	r3, r3, #16
 8101192:	613b      	str	r3, [r7, #16]
 8101194:	693b      	ldr	r3, [r7, #16]
 8101196:	e00e      	b.n	81011b6 <BSP_LED_Init+0x92>
    }
    else
    {
      LED3_GPIO_CLK_ENABLE();
 8101198:	4b1a      	ldr	r3, [pc, #104]	; (8101204 <BSP_LED_Init+0xe0>)
 810119a:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
 810119e:	4a19      	ldr	r2, [pc, #100]	; (8101204 <BSP_LED_Init+0xe0>)
 81011a0:	f043 0302 	orr.w	r3, r3, #2
 81011a4:	f8c2 30e0 	str.w	r3, [r2, #224]	; 0xe0
 81011a8:	4b16      	ldr	r3, [pc, #88]	; (8101204 <BSP_LED_Init+0xe0>)
 81011aa:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
 81011ae:	f003 0302 	and.w	r3, r3, #2
 81011b2:	60fb      	str	r3, [r7, #12]
 81011b4:	68fb      	ldr	r3, [r7, #12]
    }
    /* Configure the GPIO_LED pin */
    gpio_init_structure.Pin   = LED_PIN[Led];
 81011b6:	79fb      	ldrb	r3, [r7, #7]
 81011b8:	4a13      	ldr	r2, [pc, #76]	; (8101208 <BSP_LED_Init+0xe4>)
 81011ba:	f832 3013 	ldrh.w	r3, [r2, r3, lsl #1]
 81011be:	61bb      	str	r3, [r7, #24]
    gpio_init_structure.Mode  = GPIO_MODE_OUTPUT_PP;
 81011c0:	2301      	movs	r3, #1
 81011c2:	61fb      	str	r3, [r7, #28]
    gpio_init_structure.Pull  = GPIO_NOPULL;
 81011c4:	2300      	movs	r3, #0
 81011c6:	623b      	str	r3, [r7, #32]
    gpio_init_structure.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 81011c8:	2303      	movs	r3, #3
 81011ca:	627b      	str	r3, [r7, #36]	; 0x24

    HAL_GPIO_Init(LED_PORT[Led], &gpio_init_structure);
 81011cc:	79fb      	ldrb	r3, [r7, #7]
 81011ce:	4a0f      	ldr	r2, [pc, #60]	; (810120c <BSP_LED_Init+0xe8>)
 81011d0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 81011d4:	f107 0218 	add.w	r2, r7, #24
 81011d8:	4611      	mov	r1, r2
 81011da:	4618      	mov	r0, r3
 81011dc:	f004 f8f8 	bl	81053d0 <HAL_GPIO_Init>
    HAL_GPIO_WritePin(LED_PORT[Led], LED_PIN[Led], GPIO_PIN_RESET);
 81011e0:	79fb      	ldrb	r3, [r7, #7]
 81011e2:	4a0a      	ldr	r2, [pc, #40]	; (810120c <BSP_LED_Init+0xe8>)
 81011e4:	f852 0023 	ldr.w	r0, [r2, r3, lsl #2]
 81011e8:	79fb      	ldrb	r3, [r7, #7]
 81011ea:	4a07      	ldr	r2, [pc, #28]	; (8101208 <BSP_LED_Init+0xe4>)
 81011ec:	f832 3013 	ldrh.w	r3, [r2, r3, lsl #1]
 81011f0:	2200      	movs	r2, #0
 81011f2:	4619      	mov	r1, r3
 81011f4:	f004 fa9c 	bl	8105730 <HAL_GPIO_WritePin>
  }

  return ret;
 81011f8:	6afb      	ldr	r3, [r7, #44]	; 0x2c
}
 81011fa:	4618      	mov	r0, r3
 81011fc:	3730      	adds	r7, #48	; 0x30
 81011fe:	46bd      	mov	sp, r7
 8101200:	bd80      	pop	{r7, pc}
 8101202:	bf00      	nop
 8101204:	58024400 	.word	0x58024400
 8101208:	0811f8f4 	.word	0x0811f8f4
 810120c:	1000000c 	.word	0x1000000c

08101210 <BSP_PB_Init>:
  *            @arg  BUTTON_MODE_GPIO: Button will be used as simple IO
  *            @arg  BUTTON_MODE_EXTI: Button will be connected to EXTI line
  *                                    with interrupt generation capability
  */
int32_t BSP_PB_Init(Button_TypeDef Button, ButtonMode_TypeDef ButtonMode)
{
 8101210:	b580      	push	{r7, lr}
 8101212:	b088      	sub	sp, #32
 8101214:	af00      	add	r7, sp, #0
 8101216:	4603      	mov	r3, r0
 8101218:	460a      	mov	r2, r1
 810121a:	71fb      	strb	r3, [r7, #7]
 810121c:	4613      	mov	r3, r2
 810121e:	71bb      	strb	r3, [r7, #6]
  static BSP_EXTI_LineCallback ButtonCallback[BUTTONn] = {BUTTON_USER_EXTI_Callback};
  static uint32_t  BSP_BUTTON_PRIO [BUTTONn] = {BSP_BUTTON_USER_IT_PRIORITY};
  static const uint32_t BUTTON_EXTI_LINE[BUTTONn] = {BUTTON_USER_EXTI_LINE};

  /* Enable the BUTTON clock */
  BUTTON_USER_GPIO_CLK_ENABLE();
 8101220:	4b2e      	ldr	r3, [pc, #184]	; (81012dc <BSP_PB_Init+0xcc>)
 8101222:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
 8101226:	4a2d      	ldr	r2, [pc, #180]	; (81012dc <BSP_PB_Init+0xcc>)
 8101228:	f043 0304 	orr.w	r3, r3, #4
 810122c:	f8c2 30e0 	str.w	r3, [r2, #224]	; 0xe0
 8101230:	4b2a      	ldr	r3, [pc, #168]	; (81012dc <BSP_PB_Init+0xcc>)
 8101232:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
 8101236:	f003 0304 	and.w	r3, r3, #4
 810123a:	60bb      	str	r3, [r7, #8]
 810123c:	68bb      	ldr	r3, [r7, #8]

  gpio_init_structure.Pin = BUTTON_PIN [Button];
 810123e:	f44f 5300 	mov.w	r3, #8192	; 0x2000
 8101242:	60fb      	str	r3, [r7, #12]
  gpio_init_structure.Pull = GPIO_PULLDOWN;
 8101244:	2302      	movs	r3, #2
 8101246:	617b      	str	r3, [r7, #20]
  gpio_init_structure.Speed = GPIO_SPEED_FREQ_HIGH;
 8101248:	2302      	movs	r3, #2
 810124a:	61bb      	str	r3, [r7, #24]

  if(ButtonMode == BUTTON_MODE_GPIO)
 810124c:	79bb      	ldrb	r3, [r7, #6]
 810124e:	2b00      	cmp	r3, #0
 8101250:	d10c      	bne.n	810126c <BSP_PB_Init+0x5c>
  {
    /* Configure Button pin as input */
    gpio_init_structure.Mode = GPIO_MODE_INPUT;
 8101252:	2300      	movs	r3, #0
 8101254:	613b      	str	r3, [r7, #16]
    HAL_GPIO_Init(BUTTON_PORT [Button], &gpio_init_structure);
 8101256:	79fb      	ldrb	r3, [r7, #7]
 8101258:	4a21      	ldr	r2, [pc, #132]	; (81012e0 <BSP_PB_Init+0xd0>)
 810125a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 810125e:	f107 020c 	add.w	r2, r7, #12
 8101262:	4611      	mov	r1, r2
 8101264:	4618      	mov	r0, r3
 8101266:	f004 f8b3 	bl	81053d0 <HAL_GPIO_Init>
 810126a:	e031      	b.n	81012d0 <BSP_PB_Init+0xc0>
  }
  else /* (ButtonMode == BUTTON_MODE_EXTI) */
  {
    /* Configure Button pin as input with External interrupt */
    gpio_init_structure.Mode = GPIO_MODE_IT_RISING;
 810126c:	f44f 1388 	mov.w	r3, #1114112	; 0x110000
 8101270:	613b      	str	r3, [r7, #16]

    HAL_GPIO_Init(BUTTON_PORT[Button], &gpio_init_structure);
 8101272:	79fb      	ldrb	r3, [r7, #7]
 8101274:	4a1a      	ldr	r2, [pc, #104]	; (81012e0 <BSP_PB_Init+0xd0>)
 8101276:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 810127a:	f107 020c 	add.w	r2, r7, #12
 810127e:	4611      	mov	r1, r2
 8101280:	4618      	mov	r0, r3
 8101282:	f004 f8a5 	bl	81053d0 <HAL_GPIO_Init>

    (void)HAL_EXTI_GetHandle(&hpb_exti[Button], BUTTON_EXTI_LINE[Button]);
 8101286:	79fb      	ldrb	r3, [r7, #7]
 8101288:	00db      	lsls	r3, r3, #3
 810128a:	4a16      	ldr	r2, [pc, #88]	; (81012e4 <BSP_PB_Init+0xd4>)
 810128c:	441a      	add	r2, r3
 810128e:	79fb      	ldrb	r3, [r7, #7]
 8101290:	4915      	ldr	r1, [pc, #84]	; (81012e8 <BSP_PB_Init+0xd8>)
 8101292:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8101296:	4619      	mov	r1, r3
 8101298:	4610      	mov	r0, r2
 810129a:	f003 fcdd 	bl	8104c58 <HAL_EXTI_GetHandle>
    (void)HAL_EXTI_RegisterCallback(&hpb_exti[Button],  HAL_EXTI_COMMON_CB_ID, ButtonCallback[Button]);
 810129e:	79fb      	ldrb	r3, [r7, #7]
 81012a0:	00db      	lsls	r3, r3, #3
 81012a2:	4a10      	ldr	r2, [pc, #64]	; (81012e4 <BSP_PB_Init+0xd4>)
 81012a4:	1898      	adds	r0, r3, r2
 81012a6:	79fb      	ldrb	r3, [r7, #7]
 81012a8:	4a10      	ldr	r2, [pc, #64]	; (81012ec <BSP_PB_Init+0xdc>)
 81012aa:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 81012ae:	461a      	mov	r2, r3
 81012b0:	2100      	movs	r1, #0
 81012b2:	f003 fcb2 	bl	8104c1a <HAL_EXTI_RegisterCallback>

    /* Enable and set Button EXTI Interrupt to the lowest priority */
    HAL_NVIC_SetPriority((BUTTON_IRQn[Button]), BSP_BUTTON_PRIO[Button], 0x00);
 81012b6:	2028      	movs	r0, #40	; 0x28
 81012b8:	79fb      	ldrb	r3, [r7, #7]
 81012ba:	4a0d      	ldr	r2, [pc, #52]	; (81012f0 <BSP_PB_Init+0xe0>)
 81012bc:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 81012c0:	2200      	movs	r2, #0
 81012c2:	4619      	mov	r1, r3
 81012c4:	f002 f93b 	bl	810353e <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ((BUTTON_IRQn[Button]));
 81012c8:	2328      	movs	r3, #40	; 0x28
 81012ca:	4618      	mov	r0, r3
 81012cc:	f002 f951 	bl	8103572 <HAL_NVIC_EnableIRQ>
  }

  return BSP_ERROR_NONE;
 81012d0:	2300      	movs	r3, #0
}
 81012d2:	4618      	mov	r0, r3
 81012d4:	3720      	adds	r7, #32
 81012d6:	46bd      	mov	sp, r7
 81012d8:	bd80      	pop	{r7, pc}
 81012da:	bf00      	nop
 81012dc:	58024400 	.word	0x58024400
 81012e0:	10000018 	.word	0x10000018
 81012e4:	100003b4 	.word	0x100003b4
 81012e8:	0811f8fc 	.word	0x0811f8fc
 81012ec:	1000001c 	.word	0x1000001c
 81012f0:	10000020 	.word	0x10000020

081012f4 <BSP_PB_IRQHandler>:
  * @brief  BSP Button IRQ handler
  * @param  Button Can only be BUTTON_USER
  * @retval None
  */
void BSP_PB_IRQHandler(Button_TypeDef Button)
{
 81012f4:	b580      	push	{r7, lr}
 81012f6:	b082      	sub	sp, #8
 81012f8:	af00      	add	r7, sp, #0
 81012fa:	4603      	mov	r3, r0
 81012fc:	71fb      	strb	r3, [r7, #7]
  HAL_EXTI_IRQHandler(&hpb_exti[Button]);
 81012fe:	79fb      	ldrb	r3, [r7, #7]
 8101300:	00db      	lsls	r3, r3, #3
 8101302:	4a04      	ldr	r2, [pc, #16]	; (8101314 <BSP_PB_IRQHandler+0x20>)
 8101304:	4413      	add	r3, r2
 8101306:	4618      	mov	r0, r3
 8101308:	f003 fcba 	bl	8104c80 <HAL_EXTI_IRQHandler>
}
 810130c:	bf00      	nop
 810130e:	3708      	adds	r7, #8
 8101310:	46bd      	mov	sp, r7
 8101312:	bd80      	pop	{r7, pc}
 8101314:	100003b4 	.word	0x100003b4

08101318 <BSP_PB_Callback>:
  * @brief  BSP Push Button callback
  * @param  Button Specifies the pin connected EXTI line
  * @retval None
  */
__weak void BSP_PB_Callback(Button_TypeDef Button)
{
 8101318:	b480      	push	{r7}
 810131a:	b083      	sub	sp, #12
 810131c:	af00      	add	r7, sp, #0
 810131e:	4603      	mov	r3, r0
 8101320:	71fb      	strb	r3, [r7, #7]
  /* Prevent unused argument(s) compilation warning */
  UNUSED(Button);

  /* This function should be implemented by the user application.
     It is called into this driver when an event on Button is triggered. */
}
 8101322:	bf00      	nop
 8101324:	370c      	adds	r7, #12
 8101326:	46bd      	mov	sp, r7
 8101328:	f85d 7b04 	ldr.w	r7, [sp], #4
 810132c:	4770      	bx	lr
	...

08101330 <BSP_COM_Init>:
  * @param  COM_Init Pointer to a UART_HandleTypeDef structure that contains the
  *                  configuration information for the specified USART peripheral.
  * @retval BSP error code
  */
int32_t BSP_COM_Init(COM_TypeDef COM, COM_InitTypeDef *COM_Init)
{
 8101330:	b580      	push	{r7, lr}
 8101332:	b084      	sub	sp, #16
 8101334:	af00      	add	r7, sp, #0
 8101336:	4603      	mov	r3, r0
 8101338:	6039      	str	r1, [r7, #0]
 810133a:	71fb      	strb	r3, [r7, #7]
  int32_t ret = BSP_ERROR_NONE;
 810133c:	2300      	movs	r3, #0
 810133e:	60fb      	str	r3, [r7, #12]

  if(COM >= COMn)
 8101340:	79fb      	ldrb	r3, [r7, #7]
 8101342:	2b00      	cmp	r3, #0
 8101344:	d003      	beq.n	810134e <BSP_COM_Init+0x1e>
  {
    ret = BSP_ERROR_WRONG_PARAM;
 8101346:	f06f 0301 	mvn.w	r3, #1
 810134a:	60fb      	str	r3, [r7, #12]
 810134c:	e018      	b.n	8101380 <BSP_COM_Init+0x50>
  }
  else
  {
#if (USE_HAL_UART_REGISTER_CALLBACKS == 0)
    /* Init the UART Msp */
    COM1_MspInit(&hcom_uart[COM]);
 810134e:	79fb      	ldrb	r3, [r7, #7]
 8101350:	2294      	movs	r2, #148	; 0x94
 8101352:	fb02 f303 	mul.w	r3, r2, r3
 8101356:	4a0d      	ldr	r2, [pc, #52]	; (810138c <BSP_COM_Init+0x5c>)
 8101358:	4413      	add	r3, r2
 810135a:	4618      	mov	r0, r3
 810135c:	f000 f86e 	bl	810143c <COM1_MspInit>
        return BSP_ERROR_MSP_FAILURE;
      }
    }
#endif

    if(MX_USART3_Init(&hcom_uart[COM], COM_Init) != HAL_OK)
 8101360:	79fb      	ldrb	r3, [r7, #7]
 8101362:	2294      	movs	r2, #148	; 0x94
 8101364:	fb02 f303 	mul.w	r3, r2, r3
 8101368:	4a08      	ldr	r2, [pc, #32]	; (810138c <BSP_COM_Init+0x5c>)
 810136a:	4413      	add	r3, r2
 810136c:	6839      	ldr	r1, [r7, #0]
 810136e:	4618      	mov	r0, r3
 8101370:	f000 f80e 	bl	8101390 <MX_USART3_Init>
 8101374:	4603      	mov	r3, r0
 8101376:	2b00      	cmp	r3, #0
 8101378:	d002      	beq.n	8101380 <BSP_COM_Init+0x50>
    {
      ret = BSP_ERROR_PERIPH_FAILURE;
 810137a:	f06f 0303 	mvn.w	r3, #3
 810137e:	60fb      	str	r3, [r7, #12]
    }
  }

  return ret;
 8101380:	68fb      	ldr	r3, [r7, #12]
}
 8101382:	4618      	mov	r0, r3
 8101384:	3710      	adds	r7, #16
 8101386:	46bd      	mov	sp, r7
 8101388:	bd80      	pop	{r7, pc}
 810138a:	bf00      	nop
 810138c:	100003bc 	.word	0x100003bc

08101390 <MX_USART3_Init>:
  * @param  COM_Init Pointer to a UART_HandleTypeDef structure that contains the
  *                  configuration information for the specified USART peripheral.
  * @retval HAL error code
  */
__weak HAL_StatusTypeDef MX_USART3_Init(UART_HandleTypeDef *huart, MX_UART_InitTypeDef *COM_Init)
{
 8101390:	b580      	push	{r7, lr}
 8101392:	b082      	sub	sp, #8
 8101394:	af00      	add	r7, sp, #0
 8101396:	6078      	str	r0, [r7, #4]
 8101398:	6039      	str	r1, [r7, #0]
  /* USART configuration */
 huart->Instance          = COM_USART[COM1];
 810139a:	4b15      	ldr	r3, [pc, #84]	; (81013f0 <MX_USART3_Init+0x60>)
 810139c:	681a      	ldr	r2, [r3, #0]
 810139e:	687b      	ldr	r3, [r7, #4]
 81013a0:	601a      	str	r2, [r3, #0]
 huart->Init.BaudRate     = COM_Init->BaudRate;
 81013a2:	683b      	ldr	r3, [r7, #0]
 81013a4:	681a      	ldr	r2, [r3, #0]
 81013a6:	687b      	ldr	r3, [r7, #4]
 81013a8:	605a      	str	r2, [r3, #4]
 huart->Init.Mode         = UART_MODE_TX_RX;
 81013aa:	687b      	ldr	r3, [r7, #4]
 81013ac:	220c      	movs	r2, #12
 81013ae:	615a      	str	r2, [r3, #20]
 huart->Init.Parity       = (uint32_t)COM_Init->Parity;
 81013b0:	683b      	ldr	r3, [r7, #0]
 81013b2:	895b      	ldrh	r3, [r3, #10]
 81013b4:	461a      	mov	r2, r3
 81013b6:	687b      	ldr	r3, [r7, #4]
 81013b8:	611a      	str	r2, [r3, #16]
 huart->Init.WordLength   = (uint32_t)COM_Init->WordLength;
 81013ba:	683b      	ldr	r3, [r7, #0]
 81013bc:	685a      	ldr	r2, [r3, #4]
 81013be:	687b      	ldr	r3, [r7, #4]
 81013c0:	609a      	str	r2, [r3, #8]
 huart->Init.StopBits     = (uint32_t)COM_Init->StopBits;
 81013c2:	683b      	ldr	r3, [r7, #0]
 81013c4:	891b      	ldrh	r3, [r3, #8]
 81013c6:	461a      	mov	r2, r3
 81013c8:	687b      	ldr	r3, [r7, #4]
 81013ca:	60da      	str	r2, [r3, #12]
 huart->Init.HwFlowCtl    = (uint32_t)COM_Init->HwFlowCtl;
 81013cc:	683b      	ldr	r3, [r7, #0]
 81013ce:	899b      	ldrh	r3, [r3, #12]
 81013d0:	461a      	mov	r2, r3
 81013d2:	687b      	ldr	r3, [r7, #4]
 81013d4:	619a      	str	r2, [r3, #24]
 huart->Init.OverSampling = UART_OVERSAMPLING_8;
 81013d6:	687b      	ldr	r3, [r7, #4]
 81013d8:	f44f 4200 	mov.w	r2, #32768	; 0x8000
 81013dc:	61da      	str	r2, [r3, #28]

 return HAL_UART_Init(huart);
 81013de:	6878      	ldr	r0, [r7, #4]
 81013e0:	f008 fbc6 	bl	8109b70 <HAL_UART_Init>
 81013e4:	4603      	mov	r3, r0
}
 81013e6:	4618      	mov	r0, r3
 81013e8:	3708      	adds	r7, #8
 81013ea:	46bd      	mov	sp, r7
 81013ec:	bd80      	pop	{r7, pc}
 81013ee:	bf00      	nop
 81013f0:	10000008 	.word	0x10000008

081013f4 <__io_putchar>:
 #ifdef __GNUC__
 int __io_putchar (int ch)
 #else
 int fputc (int ch, FILE *f)
 #endif /* __GNUC__ */
{
 81013f4:	b580      	push	{r7, lr}
 81013f6:	b082      	sub	sp, #8
 81013f8:	af00      	add	r7, sp, #0
 81013fa:	6078      	str	r0, [r7, #4]
  HAL_UART_Transmit (&hcom_uart [COM_ActiveLogPort], (uint8_t *) &ch, 1, COM_POLL_TIMEOUT);
 81013fc:	4b09      	ldr	r3, [pc, #36]	; (8101424 <__io_putchar+0x30>)
 81013fe:	781b      	ldrb	r3, [r3, #0]
 8101400:	461a      	mov	r2, r3
 8101402:	2394      	movs	r3, #148	; 0x94
 8101404:	fb02 f303 	mul.w	r3, r2, r3
 8101408:	4a07      	ldr	r2, [pc, #28]	; (8101428 <__io_putchar+0x34>)
 810140a:	1898      	adds	r0, r3, r2
 810140c:	1d39      	adds	r1, r7, #4
 810140e:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 8101412:	2201      	movs	r2, #1
 8101414:	f008 fc06 	bl	8109c24 <HAL_UART_Transmit>
  return ch;
 8101418:	687b      	ldr	r3, [r7, #4]
}
 810141a:	4618      	mov	r0, r3
 810141c:	3708      	adds	r7, #8
 810141e:	46bd      	mov	sp, r7
 8101420:	bd80      	pop	{r7, pc}
 8101422:	bf00      	nop
 8101424:	10000450 	.word	0x10000450
 8101428:	100003bc 	.word	0x100003bc

0810142c <BUTTON_USER_EXTI_Callback>:
/**
  * @brief  Key EXTI line detection callbacks.
  * @retval BSP status
  */
static void BUTTON_USER_EXTI_Callback(void)
{
 810142c:	b580      	push	{r7, lr}
 810142e:	af00      	add	r7, sp, #0
  BSP_PB_Callback(BUTTON_USER);
 8101430:	2000      	movs	r0, #0
 8101432:	f7ff ff71 	bl	8101318 <BSP_PB_Callback>
}
 8101436:	bf00      	nop
 8101438:	bd80      	pop	{r7, pc}
	...

0810143c <COM1_MspInit>:
  * @brief  Initializes UART MSP.
  * @param  huart UART handle
  * @retval BSP status
  */
static void COM1_MspInit(UART_HandleTypeDef *huart)
{
 810143c:	b580      	push	{r7, lr}
 810143e:	b08a      	sub	sp, #40	; 0x28
 8101440:	af00      	add	r7, sp, #0
 8101442:	6078      	str	r0, [r7, #4]

  /* Prevent unused argument(s) compilation warning */
  UNUSED(huart);

  /* Enable GPIO clock */
  COM1_TX_GPIO_CLK_ENABLE();
 8101444:	4b27      	ldr	r3, [pc, #156]	; (81014e4 <COM1_MspInit+0xa8>)
 8101446:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
 810144a:	4a26      	ldr	r2, [pc, #152]	; (81014e4 <COM1_MspInit+0xa8>)
 810144c:	f043 0308 	orr.w	r3, r3, #8
 8101450:	f8c2 30e0 	str.w	r3, [r2, #224]	; 0xe0
 8101454:	4b23      	ldr	r3, [pc, #140]	; (81014e4 <COM1_MspInit+0xa8>)
 8101456:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
 810145a:	f003 0308 	and.w	r3, r3, #8
 810145e:	613b      	str	r3, [r7, #16]
 8101460:	693b      	ldr	r3, [r7, #16]
  COM1_RX_GPIO_CLK_ENABLE();
 8101462:	4b20      	ldr	r3, [pc, #128]	; (81014e4 <COM1_MspInit+0xa8>)
 8101464:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
 8101468:	4a1e      	ldr	r2, [pc, #120]	; (81014e4 <COM1_MspInit+0xa8>)
 810146a:	f043 0308 	orr.w	r3, r3, #8
 810146e:	f8c2 30e0 	str.w	r3, [r2, #224]	; 0xe0
 8101472:	4b1c      	ldr	r3, [pc, #112]	; (81014e4 <COM1_MspInit+0xa8>)
 8101474:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
 8101478:	f003 0308 	and.w	r3, r3, #8
 810147c:	60fb      	str	r3, [r7, #12]
 810147e:	68fb      	ldr	r3, [r7, #12]

  /* Enable USART clock */
  COM1_CLK_ENABLE();
 8101480:	4b18      	ldr	r3, [pc, #96]	; (81014e4 <COM1_MspInit+0xa8>)
 8101482:	f8d3 30e8 	ldr.w	r3, [r3, #232]	; 0xe8
 8101486:	4a17      	ldr	r2, [pc, #92]	; (81014e4 <COM1_MspInit+0xa8>)
 8101488:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
 810148c:	f8c2 30e8 	str.w	r3, [r2, #232]	; 0xe8
 8101490:	4b14      	ldr	r3, [pc, #80]	; (81014e4 <COM1_MspInit+0xa8>)
 8101492:	f8d3 30e8 	ldr.w	r3, [r3, #232]	; 0xe8
 8101496:	f403 2380 	and.w	r3, r3, #262144	; 0x40000
 810149a:	60bb      	str	r3, [r7, #8]
 810149c:	68bb      	ldr	r3, [r7, #8]

  /* Configure USART Tx as alternate function */
  gpio_init_structure.Pin = COM1_TX_PIN;
 810149e:	f44f 7380 	mov.w	r3, #256	; 0x100
 81014a2:	617b      	str	r3, [r7, #20]
  gpio_init_structure.Mode = GPIO_MODE_AF_PP;
 81014a4:	2302      	movs	r3, #2
 81014a6:	61bb      	str	r3, [r7, #24]
  gpio_init_structure.Speed = GPIO_SPEED_FREQ_HIGH;
 81014a8:	2302      	movs	r3, #2
 81014aa:	623b      	str	r3, [r7, #32]
  gpio_init_structure.Pull = GPIO_PULLUP;
 81014ac:	2301      	movs	r3, #1
 81014ae:	61fb      	str	r3, [r7, #28]
  gpio_init_structure.Alternate = COM1_TX_AF;
 81014b0:	2307      	movs	r3, #7
 81014b2:	627b      	str	r3, [r7, #36]	; 0x24
  HAL_GPIO_Init(COM1_TX_GPIO_PORT, &gpio_init_structure);
 81014b4:	f107 0314 	add.w	r3, r7, #20
 81014b8:	4619      	mov	r1, r3
 81014ba:	480b      	ldr	r0, [pc, #44]	; (81014e8 <COM1_MspInit+0xac>)
 81014bc:	f003 ff88 	bl	81053d0 <HAL_GPIO_Init>

  /* Configure USART Rx as alternate function */
  gpio_init_structure.Pin = COM1_RX_PIN;
 81014c0:	f44f 7300 	mov.w	r3, #512	; 0x200
 81014c4:	617b      	str	r3, [r7, #20]
  gpio_init_structure.Mode = GPIO_MODE_AF_PP;
 81014c6:	2302      	movs	r3, #2
 81014c8:	61bb      	str	r3, [r7, #24]
  gpio_init_structure.Alternate = COM1_RX_AF;
 81014ca:	2307      	movs	r3, #7
 81014cc:	627b      	str	r3, [r7, #36]	; 0x24
  HAL_GPIO_Init(COM1_RX_GPIO_PORT, &gpio_init_structure);
 81014ce:	f107 0314 	add.w	r3, r7, #20
 81014d2:	4619      	mov	r1, r3
 81014d4:	4804      	ldr	r0, [pc, #16]	; (81014e8 <COM1_MspInit+0xac>)
 81014d6:	f003 ff7b 	bl	81053d0 <HAL_GPIO_Init>
}
 81014da:	bf00      	nop
 81014dc:	3728      	adds	r7, #40	; 0x28
 81014de:	46bd      	mov	sp, r7
 81014e0:	bd80      	pop	{r7, pc}
 81014e2:	bf00      	nop
 81014e4:	58024400 	.word	0x58024400
 81014e8:	58020c00 	.word	0x58020c00

081014ec <HAL_Init>:
  *         need to ensure that the SysTick time base is always set to 1 millisecond
  *         to have correct HAL operation.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_Init(void)
{
 81014ec:	b580      	push	{r7, lr}
 81014ee:	b082      	sub	sp, #8
 81014f0:	af00      	add	r7, sp, #0

uint32_t common_system_clock;

#if defined(DUAL_CORE) && defined(CORE_CM4)
   /* Configure Cortex-M4 Instruction cache through ART accelerator */
   __HAL_RCC_ART_CLK_ENABLE();                   /* Enable the Cortex-M4 ART Clock */
 81014f2:	4b28      	ldr	r3, [pc, #160]	; (8101594 <HAL_Init+0xa8>)
 81014f4:	f8d3 30d8 	ldr.w	r3, [r3, #216]	; 0xd8
 81014f8:	4a26      	ldr	r2, [pc, #152]	; (8101594 <HAL_Init+0xa8>)
 81014fa:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 81014fe:	f8c2 30d8 	str.w	r3, [r2, #216]	; 0xd8
 8101502:	4b24      	ldr	r3, [pc, #144]	; (8101594 <HAL_Init+0xa8>)
 8101504:	f8d3 30d8 	ldr.w	r3, [r3, #216]	; 0xd8
 8101508:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
 810150c:	603b      	str	r3, [r7, #0]
 810150e:	683b      	ldr	r3, [r7, #0]
   __HAL_ART_CONFIG_BASE_ADDRESS(0x08100000UL);  /* Configure the Cortex-M4 ART Base address to the Flash Bank 2 : */
 8101510:	4b21      	ldr	r3, [pc, #132]	; (8101598 <HAL_Init+0xac>)
 8101512:	681b      	ldr	r3, [r3, #0]
 8101514:	f423 237f 	bic.w	r3, r3, #1044480	; 0xff000
 8101518:	f423 6370 	bic.w	r3, r3, #3840	; 0xf00
 810151c:	4a1e      	ldr	r2, [pc, #120]	; (8101598 <HAL_Init+0xac>)
 810151e:	f443 4301 	orr.w	r3, r3, #33024	; 0x8100
 8101522:	6013      	str	r3, [r2, #0]
   __HAL_ART_ENABLE();                           /* Enable the Cortex-M4 ART */
 8101524:	4b1c      	ldr	r3, [pc, #112]	; (8101598 <HAL_Init+0xac>)
 8101526:	681b      	ldr	r3, [r3, #0]
 8101528:	4a1b      	ldr	r2, [pc, #108]	; (8101598 <HAL_Init+0xac>)
 810152a:	f043 0301 	orr.w	r3, r3, #1
 810152e:	6013      	str	r3, [r2, #0]
#endif /* DUAL_CORE &&  CORE_CM4 */

  /* Set Interrupt Group Priority */
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 8101530:	2003      	movs	r0, #3
 8101532:	f001 fff9 	bl	8103528 <HAL_NVIC_SetPriorityGrouping>

  /* Update the SystemCoreClock global variable */
#if defined(RCC_D1CFGR_D1CPRE)
  common_system_clock = HAL_RCC_GetSysClockFreq() >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_D1CPRE)>> RCC_D1CFGR_D1CPRE_Pos]) & 0x1FU);
 8101536:	f005 fc45 	bl	8106dc4 <HAL_RCC_GetSysClockFreq>
 810153a:	4602      	mov	r2, r0
 810153c:	4b15      	ldr	r3, [pc, #84]	; (8101594 <HAL_Init+0xa8>)
 810153e:	699b      	ldr	r3, [r3, #24]
 8101540:	0a1b      	lsrs	r3, r3, #8
 8101542:	f003 030f 	and.w	r3, r3, #15
 8101546:	4915      	ldr	r1, [pc, #84]	; (810159c <HAL_Init+0xb0>)
 8101548:	5ccb      	ldrb	r3, [r1, r3]
 810154a:	f003 031f 	and.w	r3, r3, #31
 810154e:	fa22 f303 	lsr.w	r3, r2, r3
 8101552:	607b      	str	r3, [r7, #4]
  common_system_clock = HAL_RCC_GetSysClockFreq() >> ((D1CorePrescTable[(RCC->CDCFGR1 & RCC_CDCFGR1_CDCPRE)>> RCC_CDCFGR1_CDCPRE_Pos]) & 0x1FU);
#endif

  /* Update the SystemD2Clock global variable */
#if defined(RCC_D1CFGR_HPRE)
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE)>> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));
 8101554:	4b0f      	ldr	r3, [pc, #60]	; (8101594 <HAL_Init+0xa8>)
 8101556:	699b      	ldr	r3, [r3, #24]
 8101558:	f003 030f 	and.w	r3, r3, #15
 810155c:	4a0f      	ldr	r2, [pc, #60]	; (810159c <HAL_Init+0xb0>)
 810155e:	5cd3      	ldrb	r3, [r2, r3]
 8101560:	f003 031f 	and.w	r3, r3, #31
 8101564:	687a      	ldr	r2, [r7, #4]
 8101566:	fa22 f303 	lsr.w	r3, r2, r3
 810156a:	4a0d      	ldr	r2, [pc, #52]	; (81015a0 <HAL_Init+0xb4>)
 810156c:	6013      	str	r3, [r2, #0]
#else
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->CDCFGR1 & RCC_CDCFGR1_HPRE)>> RCC_CDCFGR1_HPRE_Pos]) & 0x1FU));
#endif

#if defined(DUAL_CORE) && defined(CORE_CM4)
  SystemCoreClock = SystemD2Clock;
 810156e:	4b0c      	ldr	r3, [pc, #48]	; (81015a0 <HAL_Init+0xb4>)
 8101570:	681b      	ldr	r3, [r3, #0]
 8101572:	4a0c      	ldr	r2, [pc, #48]	; (81015a4 <HAL_Init+0xb8>)
 8101574:	6013      	str	r3, [r2, #0]
#else
  SystemCoreClock = common_system_clock;
#endif /* DUAL_CORE && CORE_CM4 */

  /* Use systick as time base source and configure 1ms tick (default clock after Reset is HSI) */
  if(HAL_InitTick(TICK_INT_PRIORITY) != HAL_OK)
 8101576:	2000      	movs	r0, #0
 8101578:	f000 f816 	bl	81015a8 <HAL_InitTick>
 810157c:	4603      	mov	r3, r0
 810157e:	2b00      	cmp	r3, #0
 8101580:	d001      	beq.n	8101586 <HAL_Init+0x9a>
  {
    return HAL_ERROR;
 8101582:	2301      	movs	r3, #1
 8101584:	e002      	b.n	810158c <HAL_Init+0xa0>
  }

  /* Init the low level hardware */
  HAL_MspInit();
 8101586:	f7ff fa75 	bl	8100a74 <HAL_MspInit>

  /* Return function status */
  return HAL_OK;
 810158a:	2300      	movs	r3, #0
}
 810158c:	4618      	mov	r0, r3
 810158e:	3708      	adds	r7, #8
 8101590:	46bd      	mov	sp, r7
 8101592:	bd80      	pop	{r7, pc}
 8101594:	58024400 	.word	0x58024400
 8101598:	40024400 	.word	0x40024400
 810159c:	0811f8e4 	.word	0x0811f8e4
 81015a0:	10000004 	.word	0x10000004
 81015a4:	10000000 	.word	0x10000000

081015a8 <HAL_InitTick>:
  *       implementation  in user file.
  * @param TickPriority: Tick interrupt priority.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
 81015a8:	b580      	push	{r7, lr}
 81015aa:	b082      	sub	sp, #8
 81015ac:	af00      	add	r7, sp, #0
 81015ae:	6078      	str	r0, [r7, #4]
  /* Check uwTickFreq for MisraC 2012 (even if uwTickFreq is a enum type that don't take the value zero)*/
  if((uint32_t)uwTickFreq == 0UL)
 81015b0:	4b15      	ldr	r3, [pc, #84]	; (8101608 <HAL_InitTick+0x60>)
 81015b2:	781b      	ldrb	r3, [r3, #0]
 81015b4:	2b00      	cmp	r3, #0
 81015b6:	d101      	bne.n	81015bc <HAL_InitTick+0x14>
  {
    return HAL_ERROR;
 81015b8:	2301      	movs	r3, #1
 81015ba:	e021      	b.n	8101600 <HAL_InitTick+0x58>
  }

    /* Configure the SysTick to have interrupt in 1ms time basis*/
    if (HAL_SYSTICK_Config(SystemCoreClock / (1000UL / (uint32_t)uwTickFreq)) > 0U)
 81015bc:	4b13      	ldr	r3, [pc, #76]	; (810160c <HAL_InitTick+0x64>)
 81015be:	681a      	ldr	r2, [r3, #0]
 81015c0:	4b11      	ldr	r3, [pc, #68]	; (8101608 <HAL_InitTick+0x60>)
 81015c2:	781b      	ldrb	r3, [r3, #0]
 81015c4:	4619      	mov	r1, r3
 81015c6:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 81015ca:	fbb3 f3f1 	udiv	r3, r3, r1
 81015ce:	fbb2 f3f3 	udiv	r3, r2, r3
 81015d2:	4618      	mov	r0, r3
 81015d4:	f001 ffdb 	bl	810358e <HAL_SYSTICK_Config>
 81015d8:	4603      	mov	r3, r0
 81015da:	2b00      	cmp	r3, #0
 81015dc:	d001      	beq.n	81015e2 <HAL_InitTick+0x3a>
    {
      return HAL_ERROR;
 81015de:	2301      	movs	r3, #1
 81015e0:	e00e      	b.n	8101600 <HAL_InitTick+0x58>
    }

  /* Configure the SysTick IRQ priority */
  if (TickPriority < (1UL << __NVIC_PRIO_BITS))
 81015e2:	687b      	ldr	r3, [r7, #4]
 81015e4:	2b0f      	cmp	r3, #15
 81015e6:	d80a      	bhi.n	81015fe <HAL_InitTick+0x56>
  {
    HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority, 0U);
 81015e8:	2200      	movs	r2, #0
 81015ea:	6879      	ldr	r1, [r7, #4]
 81015ec:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 81015f0:	f001 ffa5 	bl	810353e <HAL_NVIC_SetPriority>
    uwTickPrio = TickPriority;
 81015f4:	4a06      	ldr	r2, [pc, #24]	; (8101610 <HAL_InitTick+0x68>)
 81015f6:	687b      	ldr	r3, [r7, #4]
 81015f8:	6013      	str	r3, [r2, #0]
  {
    return HAL_ERROR;
  }

  /* Return function status */
  return HAL_OK;
 81015fa:	2300      	movs	r3, #0
 81015fc:	e000      	b.n	8101600 <HAL_InitTick+0x58>
    return HAL_ERROR;
 81015fe:	2301      	movs	r3, #1
}
 8101600:	4618      	mov	r0, r3
 8101602:	3708      	adds	r7, #8
 8101604:	46bd      	mov	sp, r7
 8101606:	bd80      	pop	{r7, pc}
 8101608:	10000028 	.word	0x10000028
 810160c:	10000000 	.word	0x10000000
 8101610:	10000024 	.word	0x10000024

08101614 <HAL_IncTick>:
 * @note This function is declared as __weak to be overwritten in case of other
  *      implementations in user file.
  * @retval None
  */
__weak void HAL_IncTick(void)
{
 8101614:	b480      	push	{r7}
 8101616:	af00      	add	r7, sp, #0
  uwTick += (uint32_t)uwTickFreq;
 8101618:	4b06      	ldr	r3, [pc, #24]	; (8101634 <HAL_IncTick+0x20>)
 810161a:	781b      	ldrb	r3, [r3, #0]
 810161c:	461a      	mov	r2, r3
 810161e:	4b06      	ldr	r3, [pc, #24]	; (8101638 <HAL_IncTick+0x24>)
 8101620:	681b      	ldr	r3, [r3, #0]
 8101622:	4413      	add	r3, r2
 8101624:	4a04      	ldr	r2, [pc, #16]	; (8101638 <HAL_IncTick+0x24>)
 8101626:	6013      	str	r3, [r2, #0]
}
 8101628:	bf00      	nop
 810162a:	46bd      	mov	sp, r7
 810162c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8101630:	4770      	bx	lr
 8101632:	bf00      	nop
 8101634:	10000028 	.word	0x10000028
 8101638:	10000454 	.word	0x10000454

0810163c <HAL_GetTick>:
  * @note This function is declared as __weak to be overwritten in case of other
  *       implementations in user file.
  * @retval tick value
  */
__weak uint32_t HAL_GetTick(void)
{
 810163c:	b480      	push	{r7}
 810163e:	af00      	add	r7, sp, #0
  return uwTick;
 8101640:	4b03      	ldr	r3, [pc, #12]	; (8101650 <HAL_GetTick+0x14>)
 8101642:	681b      	ldr	r3, [r3, #0]
}
 8101644:	4618      	mov	r0, r3
 8101646:	46bd      	mov	sp, r7
 8101648:	f85d 7b04 	ldr.w	r7, [sp], #4
 810164c:	4770      	bx	lr
 810164e:	bf00      	nop
 8101650:	10000454 	.word	0x10000454

08101654 <HAL_Delay>:
  *       implementations in user file.
  * @param Delay  specifies the delay time length, in milliseconds.
  * @retval None
  */
__weak void HAL_Delay(uint32_t Delay)
{
 8101654:	b580      	push	{r7, lr}
 8101656:	b084      	sub	sp, #16
 8101658:	af00      	add	r7, sp, #0
 810165a:	6078      	str	r0, [r7, #4]
  uint32_t tickstart = HAL_GetTick();
 810165c:	f7ff ffee 	bl	810163c <HAL_GetTick>
 8101660:	60b8      	str	r0, [r7, #8]
  uint32_t wait = Delay;
 8101662:	687b      	ldr	r3, [r7, #4]
 8101664:	60fb      	str	r3, [r7, #12]

  /* Add a freq to guarantee minimum wait */
  if (wait < HAL_MAX_DELAY)
 8101666:	68fb      	ldr	r3, [r7, #12]
 8101668:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 810166c:	d005      	beq.n	810167a <HAL_Delay+0x26>
  {
    wait += (uint32_t)(uwTickFreq);
 810166e:	4b0a      	ldr	r3, [pc, #40]	; (8101698 <HAL_Delay+0x44>)
 8101670:	781b      	ldrb	r3, [r3, #0]
 8101672:	461a      	mov	r2, r3
 8101674:	68fb      	ldr	r3, [r7, #12]
 8101676:	4413      	add	r3, r2
 8101678:	60fb      	str	r3, [r7, #12]
  }

  while ((HAL_GetTick() - tickstart) < wait)
 810167a:	bf00      	nop
 810167c:	f7ff ffde 	bl	810163c <HAL_GetTick>
 8101680:	4602      	mov	r2, r0
 8101682:	68bb      	ldr	r3, [r7, #8]
 8101684:	1ad3      	subs	r3, r2, r3
 8101686:	68fa      	ldr	r2, [r7, #12]
 8101688:	429a      	cmp	r2, r3
 810168a:	d8f7      	bhi.n	810167c <HAL_Delay+0x28>
  {
  }
}
 810168c:	bf00      	nop
 810168e:	bf00      	nop
 8101690:	3710      	adds	r7, #16
 8101692:	46bd      	mov	sp, r7
 8101694:	bd80      	pop	{r7, pc}
 8101696:	bf00      	nop
 8101698:	10000028 	.word	0x10000028

0810169c <HAL_GetREVID>:
/**
  * @brief  Returns the device revision identifier.
  * @retval Device revision identifier
  */
uint32_t HAL_GetREVID(void)
{
 810169c:	b480      	push	{r7}
 810169e:	af00      	add	r7, sp, #0
   return((DBGMCU->IDCODE) >> 16);
 81016a0:	4b03      	ldr	r3, [pc, #12]	; (81016b0 <HAL_GetREVID+0x14>)
 81016a2:	681b      	ldr	r3, [r3, #0]
 81016a4:	0c1b      	lsrs	r3, r3, #16
}
 81016a6:	4618      	mov	r0, r3
 81016a8:	46bd      	mov	sp, r7
 81016aa:	f85d 7b04 	ldr.w	r7, [sp], #4
 81016ae:	4770      	bx	lr
 81016b0:	5c001000 	.word	0x5c001000

081016b4 <HAL_SYSCFG_ETHInterfaceSelect>:
  *   @arg SYSCFG_ETH_MII : Select the Media Independent Interface
  *   @arg SYSCFG_ETH_RMII: Select the Reduced Media Independent Interface
  * @retval None
  */
void HAL_SYSCFG_ETHInterfaceSelect(uint32_t SYSCFG_ETHInterface)
{
 81016b4:	b480      	push	{r7}
 81016b6:	b083      	sub	sp, #12
 81016b8:	af00      	add	r7, sp, #0
 81016ba:	6078      	str	r0, [r7, #4]
  /* Check the parameter */
  assert_param(IS_SYSCFG_ETHERNET_CONFIG(SYSCFG_ETHInterface));

  MODIFY_REG(SYSCFG->PMCR, SYSCFG_PMCR_EPIS_SEL, (uint32_t)(SYSCFG_ETHInterface));
 81016bc:	4b06      	ldr	r3, [pc, #24]	; (81016d8 <HAL_SYSCFG_ETHInterfaceSelect+0x24>)
 81016be:	685b      	ldr	r3, [r3, #4]
 81016c0:	f423 0260 	bic.w	r2, r3, #14680064	; 0xe00000
 81016c4:	4904      	ldr	r1, [pc, #16]	; (81016d8 <HAL_SYSCFG_ETHInterfaceSelect+0x24>)
 81016c6:	687b      	ldr	r3, [r7, #4]
 81016c8:	4313      	orrs	r3, r2
 81016ca:	604b      	str	r3, [r1, #4]
}
 81016cc:	bf00      	nop
 81016ce:	370c      	adds	r7, #12
 81016d0:	46bd      	mov	sp, r7
 81016d2:	f85d 7b04 	ldr.w	r7, [sp], #4
 81016d6:	4770      	bx	lr
 81016d8:	58000400 	.word	0x58000400

081016dc <LL_ADC_SetCommonClock>:
  *         @arg @ref LL_ADC_CLOCK_ASYNC_DIV128
  *         @arg @ref LL_ADC_CLOCK_ASYNC_DIV256
  * @retval None
  */
__STATIC_INLINE void LL_ADC_SetCommonClock(ADC_Common_TypeDef *ADCxy_COMMON, uint32_t CommonClock)
{
 81016dc:	b480      	push	{r7}
 81016de:	b083      	sub	sp, #12
 81016e0:	af00      	add	r7, sp, #0
 81016e2:	6078      	str	r0, [r7, #4]
 81016e4:	6039      	str	r1, [r7, #0]
  MODIFY_REG(ADCxy_COMMON->CCR, ADC_CCR_CKMODE | ADC_CCR_PRESC, CommonClock);
 81016e6:	687b      	ldr	r3, [r7, #4]
 81016e8:	689b      	ldr	r3, [r3, #8]
 81016ea:	f423 127c 	bic.w	r2, r3, #4128768	; 0x3f0000
 81016ee:	683b      	ldr	r3, [r7, #0]
 81016f0:	431a      	orrs	r2, r3
 81016f2:	687b      	ldr	r3, [r7, #4]
 81016f4:	609a      	str	r2, [r3, #8]
}
 81016f6:	bf00      	nop
 81016f8:	370c      	adds	r7, #12
 81016fa:	46bd      	mov	sp, r7
 81016fc:	f85d 7b04 	ldr.w	r7, [sp], #4
 8101700:	4770      	bx	lr

08101702 <LL_ADC_SetCommonPathInternalCh>:
  *         @arg @ref LL_ADC_PATH_INTERNAL_TEMPSENSOR
  *         @arg @ref LL_ADC_PATH_INTERNAL_VBAT
  * @retval None
  */
__STATIC_INLINE void LL_ADC_SetCommonPathInternalCh(ADC_Common_TypeDef *ADCxy_COMMON, uint32_t PathInternal)
{
 8101702:	b480      	push	{r7}
 8101704:	b083      	sub	sp, #12
 8101706:	af00      	add	r7, sp, #0
 8101708:	6078      	str	r0, [r7, #4]
 810170a:	6039      	str	r1, [r7, #0]
  MODIFY_REG(ADCxy_COMMON->CCR, ADC_CCR_VREFEN | ADC_CCR_TSEN | ADC_CCR_VBATEN, PathInternal);
 810170c:	687b      	ldr	r3, [r7, #4]
 810170e:	689b      	ldr	r3, [r3, #8]
 8101710:	f023 72e0 	bic.w	r2, r3, #29360128	; 0x1c00000
 8101714:	683b      	ldr	r3, [r7, #0]
 8101716:	431a      	orrs	r2, r3
 8101718:	687b      	ldr	r3, [r7, #4]
 810171a:	609a      	str	r2, [r3, #8]
}
 810171c:	bf00      	nop
 810171e:	370c      	adds	r7, #12
 8101720:	46bd      	mov	sp, r7
 8101722:	f85d 7b04 	ldr.w	r7, [sp], #4
 8101726:	4770      	bx	lr

08101728 <LL_ADC_GetCommonPathInternalCh>:
  *         @arg @ref LL_ADC_PATH_INTERNAL_VREFINT
  *         @arg @ref LL_ADC_PATH_INTERNAL_TEMPSENSOR
  *         @arg @ref LL_ADC_PATH_INTERNAL_VBAT
  */
__STATIC_INLINE uint32_t LL_ADC_GetCommonPathInternalCh(ADC_Common_TypeDef *ADCxy_COMMON)
{
 8101728:	b480      	push	{r7}
 810172a:	b083      	sub	sp, #12
 810172c:	af00      	add	r7, sp, #0
 810172e:	6078      	str	r0, [r7, #4]
  return (uint32_t)(READ_BIT(ADCxy_COMMON->CCR, ADC_CCR_VREFEN | ADC_CCR_TSEN | ADC_CCR_VBATEN));
 8101730:	687b      	ldr	r3, [r7, #4]
 8101732:	689b      	ldr	r3, [r3, #8]
 8101734:	f003 73e0 	and.w	r3, r3, #29360128	; 0x1c00000
}
 8101738:	4618      	mov	r0, r3
 810173a:	370c      	adds	r7, #12
 810173c:	46bd      	mov	sp, r7
 810173e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8101742:	4770      	bx	lr

08101744 <LL_ADC_SetOffset>:
  *             Other channels are slow channels (conversion rate: refer to reference manual).
  * @param  OffsetLevel Value between Min_Data=0x000 and Max_Data=0x3FFFFFF
  * @retval None
  */
__STATIC_INLINE void LL_ADC_SetOffset(ADC_TypeDef *ADCx, uint32_t Offsety, uint32_t Channel, uint32_t OffsetLevel)
{
 8101744:	b480      	push	{r7}
 8101746:	b087      	sub	sp, #28
 8101748:	af00      	add	r7, sp, #0
 810174a:	60f8      	str	r0, [r7, #12]
 810174c:	60b9      	str	r1, [r7, #8]
 810174e:	607a      	str	r2, [r7, #4]
 8101750:	603b      	str	r3, [r7, #0]
  __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->OFR1, Offsety);
 8101752:	68fb      	ldr	r3, [r7, #12]
 8101754:	3360      	adds	r3, #96	; 0x60
 8101756:	461a      	mov	r2, r3
 8101758:	68bb      	ldr	r3, [r7, #8]
 810175a:	009b      	lsls	r3, r3, #2
 810175c:	4413      	add	r3, r2
 810175e:	617b      	str	r3, [r7, #20]
               ADC3_OFR1_OFFSET1_EN | (Channel & ADC_CHANNEL_ID_NUMBER_MASK) | OffsetLevel);
  }
  else
#endif /* ADC_VER_V5_V90 */
  {
    MODIFY_REG(*preg,
 8101760:	697b      	ldr	r3, [r7, #20]
 8101762:	681b      	ldr	r3, [r3, #0]
 8101764:	f003 4200 	and.w	r2, r3, #2147483648	; 0x80000000
 8101768:	687b      	ldr	r3, [r7, #4]
 810176a:	f003 41f8 	and.w	r1, r3, #2080374784	; 0x7c000000
 810176e:	683b      	ldr	r3, [r7, #0]
 8101770:	430b      	orrs	r3, r1
 8101772:	431a      	orrs	r2, r3
 8101774:	697b      	ldr	r3, [r7, #20]
 8101776:	601a      	str	r2, [r3, #0]
               ADC_OFR1_OFFSET1_CH | ADC_OFR1_OFFSET1,
               (Channel & ADC_CHANNEL_ID_NUMBER_MASK) | OffsetLevel);
  }
}
 8101778:	bf00      	nop
 810177a:	371c      	adds	r7, #28
 810177c:	46bd      	mov	sp, r7
 810177e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8101782:	4770      	bx	lr

08101784 <LL_ADC_SetDataRightShift>:
  *         @arg @ref LL_ADC_OFFSET_RSHIFT_ENABLE
  *         @arg @ref LL_ADC_OFFSET_RSHIFT_DISABLE
  * @retval Returned None
  */
__STATIC_INLINE void LL_ADC_SetDataRightShift(ADC_TypeDef *ADCx, uint32_t Offsety, uint32_t RigthShift)
{
 8101784:	b480      	push	{r7}
 8101786:	b085      	sub	sp, #20
 8101788:	af00      	add	r7, sp, #0
 810178a:	60f8      	str	r0, [r7, #12]
 810178c:	60b9      	str	r1, [r7, #8]
 810178e:	607a      	str	r2, [r7, #4]
  MODIFY_REG(ADCx->CFGR2, (ADC_CFGR2_RSHIFT1 | ADC_CFGR2_RSHIFT2 | ADC_CFGR2_RSHIFT3 | ADC_CFGR2_RSHIFT4), RigthShift << (Offsety & 0x1FUL));
 8101790:	68fb      	ldr	r3, [r7, #12]
 8101792:	691b      	ldr	r3, [r3, #16]
 8101794:	f423 42f0 	bic.w	r2, r3, #30720	; 0x7800
 8101798:	68bb      	ldr	r3, [r7, #8]
 810179a:	f003 031f 	and.w	r3, r3, #31
 810179e:	6879      	ldr	r1, [r7, #4]
 81017a0:	fa01 f303 	lsl.w	r3, r1, r3
 81017a4:	431a      	orrs	r2, r3
 81017a6:	68fb      	ldr	r3, [r7, #12]
 81017a8:	611a      	str	r2, [r3, #16]
}
 81017aa:	bf00      	nop
 81017ac:	3714      	adds	r7, #20
 81017ae:	46bd      	mov	sp, r7
 81017b0:	f85d 7b04 	ldr.w	r7, [sp], #4
 81017b4:	4770      	bx	lr

081017b6 <LL_ADC_SetOffsetSignedSaturation>:
  *         @arg @ref LL_ADC_OFFSET_SIGNED_SATURATION_ENABLE
  *         @arg @ref LL_ADC_OFFSET_SIGNED_SATURATION_DISABLE
  * @retval Returned None
  */
__STATIC_INLINE void LL_ADC_SetOffsetSignedSaturation(ADC_TypeDef *ADCx, uint32_t Offsety, uint32_t OffsetSignedSaturation)
{
 81017b6:	b480      	push	{r7}
 81017b8:	b087      	sub	sp, #28
 81017ba:	af00      	add	r7, sp, #0
 81017bc:	60f8      	str	r0, [r7, #12]
 81017be:	60b9      	str	r1, [r7, #8]
 81017c0:	607a      	str	r2, [r7, #4]
    /* Function not available on this instance */
  }
  else
#endif  /* ADC_VER_V5_V90 */
  {
    __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->OFR1, Offsety);
 81017c2:	68fb      	ldr	r3, [r7, #12]
 81017c4:	3360      	adds	r3, #96	; 0x60
 81017c6:	461a      	mov	r2, r3
 81017c8:	68bb      	ldr	r3, [r7, #8]
 81017ca:	009b      	lsls	r3, r3, #2
 81017cc:	4413      	add	r3, r2
 81017ce:	617b      	str	r3, [r7, #20]
    MODIFY_REG(*preg, ADC_OFR1_SSATE, OffsetSignedSaturation);
 81017d0:	697b      	ldr	r3, [r7, #20]
 81017d2:	681b      	ldr	r3, [r3, #0]
 81017d4:	f023 4200 	bic.w	r2, r3, #2147483648	; 0x80000000
 81017d8:	687b      	ldr	r3, [r7, #4]
 81017da:	431a      	orrs	r2, r3
 81017dc:	697b      	ldr	r3, [r7, #20]
 81017de:	601a      	str	r2, [r3, #0]
  }
}
 81017e0:	bf00      	nop
 81017e2:	371c      	adds	r7, #28
 81017e4:	46bd      	mov	sp, r7
 81017e6:	f85d 7b04 	ldr.w	r7, [sp], #4
 81017ea:	4770      	bx	lr

081017ec <LL_ADC_REG_SetSequencerRanks>:
  *         (3) On STM32H7, fast channel (0.125 us for 14-bit resolution (ADC conversion rate up to 8 Ms/s)).
  *             Other channels are slow channels (conversion rate: refer to reference manual).
  * @retval None
  */
__STATIC_INLINE void LL_ADC_REG_SetSequencerRanks(ADC_TypeDef *ADCx, uint32_t Rank, uint32_t Channel)
{
 81017ec:	b480      	push	{r7}
 81017ee:	b087      	sub	sp, #28
 81017f0:	af00      	add	r7, sp, #0
 81017f2:	60f8      	str	r0, [r7, #12]
 81017f4:	60b9      	str	r1, [r7, #8]
 81017f6:	607a      	str	r2, [r7, #4]
  /* Set bits with content of parameter "Channel" with bits position          */
  /* in register and register position depending on parameter "Rank".         */
  /* Parameters "Rank" and "Channel" are used with masks because containing   */
  /* other bits reserved for other purpose.                                   */
  __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->SQR1, ((Rank & ADC_REG_SQRX_REGOFFSET_MASK) >> ADC_SQRX_REGOFFSET_POS));
 81017f8:	68fb      	ldr	r3, [r7, #12]
 81017fa:	3330      	adds	r3, #48	; 0x30
 81017fc:	461a      	mov	r2, r3
 81017fe:	68bb      	ldr	r3, [r7, #8]
 8101800:	0a1b      	lsrs	r3, r3, #8
 8101802:	009b      	lsls	r3, r3, #2
 8101804:	f003 030c 	and.w	r3, r3, #12
 8101808:	4413      	add	r3, r2
 810180a:	617b      	str	r3, [r7, #20]

  MODIFY_REG(*preg,
 810180c:	697b      	ldr	r3, [r7, #20]
 810180e:	681a      	ldr	r2, [r3, #0]
 8101810:	68bb      	ldr	r3, [r7, #8]
 8101812:	f003 031f 	and.w	r3, r3, #31
 8101816:	211f      	movs	r1, #31
 8101818:	fa01 f303 	lsl.w	r3, r1, r3
 810181c:	43db      	mvns	r3, r3
 810181e:	401a      	ands	r2, r3
 8101820:	687b      	ldr	r3, [r7, #4]
 8101822:	0e9b      	lsrs	r3, r3, #26
 8101824:	f003 011f 	and.w	r1, r3, #31
 8101828:	68bb      	ldr	r3, [r7, #8]
 810182a:	f003 031f 	and.w	r3, r3, #31
 810182e:	fa01 f303 	lsl.w	r3, r1, r3
 8101832:	431a      	orrs	r2, r3
 8101834:	697b      	ldr	r3, [r7, #20]
 8101836:	601a      	str	r2, [r3, #0]
             ADC_CHANNEL_ID_NUMBER_MASK_POSBIT0 << (Rank & ADC_REG_RANK_ID_SQRX_MASK),
             ((Channel & ADC_CHANNEL_ID_NUMBER_MASK) >> ADC_CHANNEL_ID_NUMBER_BITOFFSET_POS) << (Rank & ADC_REG_RANK_ID_SQRX_MASK));
}
 8101838:	bf00      	nop
 810183a:	371c      	adds	r7, #28
 810183c:	46bd      	mov	sp, r7
 810183e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8101842:	4770      	bx	lr

08101844 <LL_ADC_SetChannelSamplingTime>:
  *         @arg @ref LL_ADC_SAMPLINGTIME_387CYCLES_5
  *         @arg @ref LL_ADC_SAMPLINGTIME_810CYCLES_5
  * @retval None
  */
__STATIC_INLINE void LL_ADC_SetChannelSamplingTime(ADC_TypeDef *ADCx, uint32_t Channel, uint32_t SamplingTime)
{
 8101844:	b480      	push	{r7}
 8101846:	b087      	sub	sp, #28
 8101848:	af00      	add	r7, sp, #0
 810184a:	60f8      	str	r0, [r7, #12]
 810184c:	60b9      	str	r1, [r7, #8]
 810184e:	607a      	str	r2, [r7, #4]
  /* Set bits with content of parameter "SamplingTime" with bits position     */
  /* in register and register position depending on parameter "Channel".      */
  /* Parameter "Channel" is used with masks because containing                */
  /* other bits reserved for other purpose.                                   */
  __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->SMPR1, ((Channel & ADC_CHANNEL_SMPRX_REGOFFSET_MASK) >> ADC_SMPRX_REGOFFSET_POS));
 8101850:	68fb      	ldr	r3, [r7, #12]
 8101852:	3314      	adds	r3, #20
 8101854:	461a      	mov	r2, r3
 8101856:	68bb      	ldr	r3, [r7, #8]
 8101858:	0e5b      	lsrs	r3, r3, #25
 810185a:	009b      	lsls	r3, r3, #2
 810185c:	f003 0304 	and.w	r3, r3, #4
 8101860:	4413      	add	r3, r2
 8101862:	617b      	str	r3, [r7, #20]

  MODIFY_REG(*preg,
 8101864:	697b      	ldr	r3, [r7, #20]
 8101866:	681a      	ldr	r2, [r3, #0]
 8101868:	68bb      	ldr	r3, [r7, #8]
 810186a:	0d1b      	lsrs	r3, r3, #20
 810186c:	f003 031f 	and.w	r3, r3, #31
 8101870:	2107      	movs	r1, #7
 8101872:	fa01 f303 	lsl.w	r3, r1, r3
 8101876:	43db      	mvns	r3, r3
 8101878:	401a      	ands	r2, r3
 810187a:	68bb      	ldr	r3, [r7, #8]
 810187c:	0d1b      	lsrs	r3, r3, #20
 810187e:	f003 031f 	and.w	r3, r3, #31
 8101882:	6879      	ldr	r1, [r7, #4]
 8101884:	fa01 f303 	lsl.w	r3, r1, r3
 8101888:	431a      	orrs	r2, r3
 810188a:	697b      	ldr	r3, [r7, #20]
 810188c:	601a      	str	r2, [r3, #0]
             ADC_SMPR1_SMP0 << ((Channel & ADC_CHANNEL_SMPx_BITOFFSET_MASK) >> ADC_CHANNEL_SMPx_BITOFFSET_POS),
             SamplingTime   << ((Channel & ADC_CHANNEL_SMPx_BITOFFSET_MASK) >> ADC_CHANNEL_SMPx_BITOFFSET_POS));
}
 810188e:	bf00      	nop
 8101890:	371c      	adds	r7, #28
 8101892:	46bd      	mov	sp, r7
 8101894:	f85d 7b04 	ldr.w	r7, [sp], #4
 8101898:	4770      	bx	lr
	...

0810189c <LL_ADC_SetChannelSingleDiff>:
  *         @arg @ref LL_ADC_SINGLE_ENDED
  *         @arg @ref LL_ADC_DIFFERENTIAL_ENDED
  * @retval None
  */
__STATIC_INLINE void LL_ADC_SetChannelSingleDiff(ADC_TypeDef *ADCx, uint32_t Channel, uint32_t SingleDiff)
{
 810189c:	b480      	push	{r7}
 810189e:	b085      	sub	sp, #20
 81018a0:	af00      	add	r7, sp, #0
 81018a2:	60f8      	str	r0, [r7, #12]
 81018a4:	60b9      	str	r1, [r7, #8]
 81018a6:	607a      	str	r2, [r7, #4]
  }
#else  /* ADC_VER_V5_V90 */
  /* Bits of channels in single or differential mode are set only for         */
  /* differential mode (for single mode, mask of bits allowed to be set is    */
  /* shifted out of range of bits of channels in single or differential mode. */
  MODIFY_REG(ADCx->DIFSEL,
 81018a8:	68fb      	ldr	r3, [r7, #12]
 81018aa:	f8d3 20c0 	ldr.w	r2, [r3, #192]	; 0xc0
 81018ae:	68bb      	ldr	r3, [r7, #8]
 81018b0:	f3c3 0313 	ubfx	r3, r3, #0, #20
 81018b4:	43db      	mvns	r3, r3
 81018b6:	401a      	ands	r2, r3
 81018b8:	687b      	ldr	r3, [r7, #4]
 81018ba:	f003 0318 	and.w	r3, r3, #24
 81018be:	4908      	ldr	r1, [pc, #32]	; (81018e0 <LL_ADC_SetChannelSingleDiff+0x44>)
 81018c0:	40d9      	lsrs	r1, r3
 81018c2:	68bb      	ldr	r3, [r7, #8]
 81018c4:	400b      	ands	r3, r1
 81018c6:	f3c3 0313 	ubfx	r3, r3, #0, #20
 81018ca:	431a      	orrs	r2, r3
 81018cc:	68fb      	ldr	r3, [r7, #12]
 81018ce:	f8c3 20c0 	str.w	r2, [r3, #192]	; 0xc0
             Channel & ADC_SINGLEDIFF_CHANNEL_MASK,
             (Channel & ADC_SINGLEDIFF_CHANNEL_MASK) & (ADC_DIFSEL_DIFSEL >> (SingleDiff & ADC_SINGLEDIFF_CHANNEL_SHIFT_MASK)));
#endif /* ADC_VER_V5_V90 */
}
 81018d2:	bf00      	nop
 81018d4:	3714      	adds	r7, #20
 81018d6:	46bd      	mov	sp, r7
 81018d8:	f85d 7b04 	ldr.w	r7, [sp], #4
 81018dc:	4770      	bx	lr
 81018de:	bf00      	nop
 81018e0:	000fffff 	.word	0x000fffff

081018e4 <LL_ADC_DisableDeepPowerDown>:
  * @rmtoll CR       DEEPPWD        LL_ADC_DisableDeepPowerDown
  * @param  ADCx ADC instance
  * @retval None
  */
__STATIC_INLINE void LL_ADC_DisableDeepPowerDown(ADC_TypeDef *ADCx)
{
 81018e4:	b480      	push	{r7}
 81018e6:	b083      	sub	sp, #12
 81018e8:	af00      	add	r7, sp, #0
 81018ea:	6078      	str	r0, [r7, #4]
  /* Note: Write register with some additional bits forced to state reset     */
  /*       instead of modifying only the selected bit for this function,      */
  /*       to not interfere with bits with HW property "rs".                  */
  CLEAR_BIT(ADCx->CR, (ADC_CR_DEEPPWD | ADC_CR_BITS_PROPERTY_RS));
 81018ec:	687b      	ldr	r3, [r7, #4]
 81018ee:	689b      	ldr	r3, [r3, #8]
 81018f0:	f023 4320 	bic.w	r3, r3, #2684354560	; 0xa0000000
 81018f4:	f023 033f 	bic.w	r3, r3, #63	; 0x3f
 81018f8:	687a      	ldr	r2, [r7, #4]
 81018fa:	6093      	str	r3, [r2, #8]
}
 81018fc:	bf00      	nop
 81018fe:	370c      	adds	r7, #12
 8101900:	46bd      	mov	sp, r7
 8101902:	f85d 7b04 	ldr.w	r7, [sp], #4
 8101906:	4770      	bx	lr

08101908 <LL_ADC_IsDeepPowerDownEnabled>:
  * @rmtoll CR       DEEPPWD        LL_ADC_IsDeepPowerDownEnabled
  * @param  ADCx ADC instance
  * @retval 0: deep power down is disabled, 1: deep power down is enabled.
  */
__STATIC_INLINE uint32_t LL_ADC_IsDeepPowerDownEnabled(ADC_TypeDef *ADCx)
{
 8101908:	b480      	push	{r7}
 810190a:	b083      	sub	sp, #12
 810190c:	af00      	add	r7, sp, #0
 810190e:	6078      	str	r0, [r7, #4]
  return ((READ_BIT(ADCx->CR, ADC_CR_DEEPPWD) == (ADC_CR_DEEPPWD)) ? 1UL : 0UL);
 8101910:	687b      	ldr	r3, [r7, #4]
 8101912:	689b      	ldr	r3, [r3, #8]
 8101914:	f003 5300 	and.w	r3, r3, #536870912	; 0x20000000
 8101918:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
 810191c:	d101      	bne.n	8101922 <LL_ADC_IsDeepPowerDownEnabled+0x1a>
 810191e:	2301      	movs	r3, #1
 8101920:	e000      	b.n	8101924 <LL_ADC_IsDeepPowerDownEnabled+0x1c>
 8101922:	2300      	movs	r3, #0
}
 8101924:	4618      	mov	r0, r3
 8101926:	370c      	adds	r7, #12
 8101928:	46bd      	mov	sp, r7
 810192a:	f85d 7b04 	ldr.w	r7, [sp], #4
 810192e:	4770      	bx	lr

08101930 <LL_ADC_EnableInternalRegulator>:
  * @rmtoll CR       ADVREGEN       LL_ADC_EnableInternalRegulator
  * @param  ADCx ADC instance
  * @retval None
  */
__STATIC_INLINE void LL_ADC_EnableInternalRegulator(ADC_TypeDef *ADCx)
{
 8101930:	b480      	push	{r7}
 8101932:	b083      	sub	sp, #12
 8101934:	af00      	add	r7, sp, #0
 8101936:	6078      	str	r0, [r7, #4]
  /* Note: Write register with some additional bits forced to state reset     */
  /*       instead of modifying only the selected bit for this function,      */
  /*       to not interfere with bits with HW property "rs".                  */
  MODIFY_REG(ADCx->CR,
 8101938:	687b      	ldr	r3, [r7, #4]
 810193a:	689b      	ldr	r3, [r3, #8]
 810193c:	f023 4310 	bic.w	r3, r3, #2415919104	; 0x90000000
 8101940:	f023 033f 	bic.w	r3, r3, #63	; 0x3f
 8101944:	f043 5280 	orr.w	r2, r3, #268435456	; 0x10000000
 8101948:	687b      	ldr	r3, [r7, #4]
 810194a:	609a      	str	r2, [r3, #8]
             ADC_CR_BITS_PROPERTY_RS,
             ADC_CR_ADVREGEN);
}
 810194c:	bf00      	nop
 810194e:	370c      	adds	r7, #12
 8101950:	46bd      	mov	sp, r7
 8101952:	f85d 7b04 	ldr.w	r7, [sp], #4
 8101956:	4770      	bx	lr

08101958 <LL_ADC_IsInternalRegulatorEnabled>:
  * @rmtoll CR       ADVREGEN       LL_ADC_IsInternalRegulatorEnabled
  * @param  ADCx ADC instance
  * @retval 0: internal regulator is disabled, 1: internal regulator is enabled.
  */
__STATIC_INLINE uint32_t LL_ADC_IsInternalRegulatorEnabled(ADC_TypeDef *ADCx)
{
 8101958:	b480      	push	{r7}
 810195a:	b083      	sub	sp, #12
 810195c:	af00      	add	r7, sp, #0
 810195e:	6078      	str	r0, [r7, #4]
  return ((READ_BIT(ADCx->CR, ADC_CR_ADVREGEN) == (ADC_CR_ADVREGEN)) ? 1UL : 0UL);
 8101960:	687b      	ldr	r3, [r7, #4]
 8101962:	689b      	ldr	r3, [r3, #8]
 8101964:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 8101968:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
 810196c:	d101      	bne.n	8101972 <LL_ADC_IsInternalRegulatorEnabled+0x1a>
 810196e:	2301      	movs	r3, #1
 8101970:	e000      	b.n	8101974 <LL_ADC_IsInternalRegulatorEnabled+0x1c>
 8101972:	2300      	movs	r3, #0
}
 8101974:	4618      	mov	r0, r3
 8101976:	370c      	adds	r7, #12
 8101978:	46bd      	mov	sp, r7
 810197a:	f85d 7b04 	ldr.w	r7, [sp], #4
 810197e:	4770      	bx	lr

08101980 <LL_ADC_IsEnabled>:
  * @rmtoll CR       ADEN           LL_ADC_IsEnabled
  * @param  ADCx ADC instance
  * @retval 0: ADC is disabled, 1: ADC is enabled.
  */
__STATIC_INLINE uint32_t LL_ADC_IsEnabled(ADC_TypeDef *ADCx)
{
 8101980:	b480      	push	{r7}
 8101982:	b083      	sub	sp, #12
 8101984:	af00      	add	r7, sp, #0
 8101986:	6078      	str	r0, [r7, #4]
  return ((READ_BIT(ADCx->CR, ADC_CR_ADEN) == (ADC_CR_ADEN)) ? 1UL : 0UL);
 8101988:	687b      	ldr	r3, [r7, #4]
 810198a:	689b      	ldr	r3, [r3, #8]
 810198c:	f003 0301 	and.w	r3, r3, #1
 8101990:	2b01      	cmp	r3, #1
 8101992:	d101      	bne.n	8101998 <LL_ADC_IsEnabled+0x18>
 8101994:	2301      	movs	r3, #1
 8101996:	e000      	b.n	810199a <LL_ADC_IsEnabled+0x1a>
 8101998:	2300      	movs	r3, #0
}
 810199a:	4618      	mov	r0, r3
 810199c:	370c      	adds	r7, #12
 810199e:	46bd      	mov	sp, r7
 81019a0:	f85d 7b04 	ldr.w	r7, [sp], #4
 81019a4:	4770      	bx	lr

081019a6 <LL_ADC_REG_IsConversionOngoing>:
  * @rmtoll CR       ADSTART        LL_ADC_REG_IsConversionOngoing
  * @param  ADCx ADC instance
  * @retval 0: no conversion is on going on ADC group regular.
  */
__STATIC_INLINE uint32_t LL_ADC_REG_IsConversionOngoing(ADC_TypeDef *ADCx)
{
 81019a6:	b480      	push	{r7}
 81019a8:	b083      	sub	sp, #12
 81019aa:	af00      	add	r7, sp, #0
 81019ac:	6078      	str	r0, [r7, #4]
  return ((READ_BIT(ADCx->CR, ADC_CR_ADSTART) == (ADC_CR_ADSTART)) ? 1UL : 0UL);
 81019ae:	687b      	ldr	r3, [r7, #4]
 81019b0:	689b      	ldr	r3, [r3, #8]
 81019b2:	f003 0304 	and.w	r3, r3, #4
 81019b6:	2b04      	cmp	r3, #4
 81019b8:	d101      	bne.n	81019be <LL_ADC_REG_IsConversionOngoing+0x18>
 81019ba:	2301      	movs	r3, #1
 81019bc:	e000      	b.n	81019c0 <LL_ADC_REG_IsConversionOngoing+0x1a>
 81019be:	2300      	movs	r3, #0
}
 81019c0:	4618      	mov	r0, r3
 81019c2:	370c      	adds	r7, #12
 81019c4:	46bd      	mov	sp, r7
 81019c6:	f85d 7b04 	ldr.w	r7, [sp], #4
 81019ca:	4770      	bx	lr

081019cc <LL_ADC_INJ_IsConversionOngoing>:
  * @rmtoll CR       JADSTART       LL_ADC_INJ_IsConversionOngoing
  * @param  ADCx ADC instance
  * @retval 0: no conversion is on going on ADC group injected.
  */
__STATIC_INLINE uint32_t LL_ADC_INJ_IsConversionOngoing(ADC_TypeDef *ADCx)
{
 81019cc:	b480      	push	{r7}
 81019ce:	b083      	sub	sp, #12
 81019d0:	af00      	add	r7, sp, #0
 81019d2:	6078      	str	r0, [r7, #4]
  return ((READ_BIT(ADCx->CR, ADC_CR_JADSTART) == (ADC_CR_JADSTART)) ? 1UL : 0UL);
 81019d4:	687b      	ldr	r3, [r7, #4]
 81019d6:	689b      	ldr	r3, [r3, #8]
 81019d8:	f003 0308 	and.w	r3, r3, #8
 81019dc:	2b08      	cmp	r3, #8
 81019de:	d101      	bne.n	81019e4 <LL_ADC_INJ_IsConversionOngoing+0x18>
 81019e0:	2301      	movs	r3, #1
 81019e2:	e000      	b.n	81019e6 <LL_ADC_INJ_IsConversionOngoing+0x1a>
 81019e4:	2300      	movs	r3, #0
}
 81019e6:	4618      	mov	r0, r3
 81019e8:	370c      	adds	r7, #12
 81019ea:	46bd      	mov	sp, r7
 81019ec:	f85d 7b04 	ldr.w	r7, [sp], #4
 81019f0:	4770      	bx	lr
	...

081019f4 <HAL_ADC_Init>:
  *         without  disabling the other ADCs.
  * @param hadc ADC handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_ADC_Init(ADC_HandleTypeDef *hadc)
{
 81019f4:	b590      	push	{r4, r7, lr}
 81019f6:	b089      	sub	sp, #36	; 0x24
 81019f8:	af00      	add	r7, sp, #0
 81019fa:	6078      	str	r0, [r7, #4]
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
 81019fc:	2300      	movs	r3, #0
 81019fe:	77fb      	strb	r3, [r7, #31]
  uint32_t tmpCFGR;
  uint32_t tmp_adc_reg_is_conversion_on_going;
  __IO uint32_t wait_loop_index = 0UL;
 8101a00:	2300      	movs	r3, #0
 8101a02:	60bb      	str	r3, [r7, #8]
  uint32_t tmp_adc_is_conversion_on_going_regular;
  uint32_t tmp_adc_is_conversion_on_going_injected;

  /* Check ADC handle */
  if (hadc == NULL)
 8101a04:	687b      	ldr	r3, [r7, #4]
 8101a06:	2b00      	cmp	r3, #0
 8101a08:	d101      	bne.n	8101a0e <HAL_ADC_Init+0x1a>
  {
    return HAL_ERROR;
 8101a0a:	2301      	movs	r3, #1
 8101a0c:	e18f      	b.n	8101d2e <HAL_ADC_Init+0x33a>
  assert_param(IS_ADC_EOC_SELECTION(hadc->Init.EOCSelection));
  assert_param(IS_ADC_OVERRUN(hadc->Init.Overrun));
  assert_param(IS_FUNCTIONAL_STATE(hadc->Init.LowPowerAutoWait));
  assert_param(IS_FUNCTIONAL_STATE(hadc->Init.OversamplingMode));

  if (hadc->Init.ScanConvMode != ADC_SCAN_DISABLE)
 8101a0e:	687b      	ldr	r3, [r7, #4]
 8101a10:	68db      	ldr	r3, [r3, #12]
 8101a12:	2b00      	cmp	r3, #0
  /* DISCEN and CONT bits cannot be set at the same time */
  assert_param(!((hadc->Init.DiscontinuousConvMode == ENABLE) && (hadc->Init.ContinuousConvMode == ENABLE)));

  /* Actions performed only if ADC is coming from state reset:                */
  /* - Initialization of ADC MSP                                              */
  if (hadc->State == HAL_ADC_STATE_RESET)
 8101a14:	687b      	ldr	r3, [r7, #4]
 8101a16:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8101a18:	2b00      	cmp	r3, #0
 8101a1a:	d109      	bne.n	8101a30 <HAL_ADC_Init+0x3c>

    /* Init the low level hardware */
    hadc->MspInitCallback(hadc);
#else
    /* Init the low level hardware */
    HAL_ADC_MspInit(hadc);
 8101a1c:	6878      	ldr	r0, [r7, #4]
 8101a1e:	f7ff f843 	bl	8100aa8 <HAL_ADC_MspInit>
#endif /* USE_HAL_ADC_REGISTER_CALLBACKS */

    /* Set ADC error code to none */
    ADC_CLEAR_ERRORCODE(hadc);
 8101a22:	687b      	ldr	r3, [r7, #4]
 8101a24:	2200      	movs	r2, #0
 8101a26:	659a      	str	r2, [r3, #88]	; 0x58

    /* Initialize Lock */
    hadc->Lock = HAL_UNLOCKED;
 8101a28:	687b      	ldr	r3, [r7, #4]
 8101a2a:	2200      	movs	r2, #0
 8101a2c:	f883 2050 	strb.w	r2, [r3, #80]	; 0x50
  }

  /* - Exit from deep-power-down mode and ADC voltage regulator enable        */
  if (LL_ADC_IsDeepPowerDownEnabled(hadc->Instance) != 0UL)
 8101a30:	687b      	ldr	r3, [r7, #4]
 8101a32:	681b      	ldr	r3, [r3, #0]
 8101a34:	4618      	mov	r0, r3
 8101a36:	f7ff ff67 	bl	8101908 <LL_ADC_IsDeepPowerDownEnabled>
 8101a3a:	4603      	mov	r3, r0
 8101a3c:	2b00      	cmp	r3, #0
 8101a3e:	d004      	beq.n	8101a4a <HAL_ADC_Init+0x56>
  {
    /* Disable ADC deep power down mode */
    LL_ADC_DisableDeepPowerDown(hadc->Instance);
 8101a40:	687b      	ldr	r3, [r7, #4]
 8101a42:	681b      	ldr	r3, [r3, #0]
 8101a44:	4618      	mov	r0, r3
 8101a46:	f7ff ff4d 	bl	81018e4 <LL_ADC_DisableDeepPowerDown>
    /* System was in deep power down mode, calibration must
     be relaunched or a previously saved calibration factor
     re-applied once the ADC voltage regulator is enabled */
  }

  if (LL_ADC_IsInternalRegulatorEnabled(hadc->Instance) == 0UL)
 8101a4a:	687b      	ldr	r3, [r7, #4]
 8101a4c:	681b      	ldr	r3, [r3, #0]
 8101a4e:	4618      	mov	r0, r3
 8101a50:	f7ff ff82 	bl	8101958 <LL_ADC_IsInternalRegulatorEnabled>
 8101a54:	4603      	mov	r3, r0
 8101a56:	2b00      	cmp	r3, #0
 8101a58:	d114      	bne.n	8101a84 <HAL_ADC_Init+0x90>
  {
    /* Enable ADC internal voltage regulator */
    LL_ADC_EnableInternalRegulator(hadc->Instance);
 8101a5a:	687b      	ldr	r3, [r7, #4]
 8101a5c:	681b      	ldr	r3, [r3, #0]
 8101a5e:	4618      	mov	r0, r3
 8101a60:	f7ff ff66 	bl	8101930 <LL_ADC_EnableInternalRegulator>

    /* Note: Variable divided by 2 to compensate partially              */
    /*       CPU processing cycles, scaling in us split to not          */
    /*       exceed 32 bits register capacity and handle low frequency. */
    wait_loop_index = ((LL_ADC_DELAY_INTERNAL_REGUL_STAB_US / 10UL) * ((SystemCoreClock / (100000UL * 2UL)) + 1UL));
 8101a64:	4b88      	ldr	r3, [pc, #544]	; (8101c88 <HAL_ADC_Init+0x294>)
 8101a66:	681b      	ldr	r3, [r3, #0]
 8101a68:	099b      	lsrs	r3, r3, #6
 8101a6a:	4a88      	ldr	r2, [pc, #544]	; (8101c8c <HAL_ADC_Init+0x298>)
 8101a6c:	fba2 2303 	umull	r2, r3, r2, r3
 8101a70:	099b      	lsrs	r3, r3, #6
 8101a72:	3301      	adds	r3, #1
 8101a74:	60bb      	str	r3, [r7, #8]
    while (wait_loop_index != 0UL)
 8101a76:	e002      	b.n	8101a7e <HAL_ADC_Init+0x8a>
    {
      wait_loop_index--;
 8101a78:	68bb      	ldr	r3, [r7, #8]
 8101a7a:	3b01      	subs	r3, #1
 8101a7c:	60bb      	str	r3, [r7, #8]
    while (wait_loop_index != 0UL)
 8101a7e:	68bb      	ldr	r3, [r7, #8]
 8101a80:	2b00      	cmp	r3, #0
 8101a82:	d1f9      	bne.n	8101a78 <HAL_ADC_Init+0x84>
  }

  /* Verification that ADC voltage regulator is correctly enabled, whether    */
  /* or not ADC is coming from state reset (if any potential problem of       */
  /* clocking, voltage regulator would not be enabled).                       */
  if (LL_ADC_IsInternalRegulatorEnabled(hadc->Instance) == 0UL)
 8101a84:	687b      	ldr	r3, [r7, #4]
 8101a86:	681b      	ldr	r3, [r3, #0]
 8101a88:	4618      	mov	r0, r3
 8101a8a:	f7ff ff65 	bl	8101958 <LL_ADC_IsInternalRegulatorEnabled>
 8101a8e:	4603      	mov	r3, r0
 8101a90:	2b00      	cmp	r3, #0
 8101a92:	d10d      	bne.n	8101ab0 <HAL_ADC_Init+0xbc>
  {
    /* Update ADC state machine to error */
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
 8101a94:	687b      	ldr	r3, [r7, #4]
 8101a96:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8101a98:	f043 0210 	orr.w	r2, r3, #16
 8101a9c:	687b      	ldr	r3, [r7, #4]
 8101a9e:	655a      	str	r2, [r3, #84]	; 0x54

    /* Set ADC error code to ADC peripheral internal error */
    SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
 8101aa0:	687b      	ldr	r3, [r7, #4]
 8101aa2:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8101aa4:	f043 0201 	orr.w	r2, r3, #1
 8101aa8:	687b      	ldr	r3, [r7, #4]
 8101aaa:	659a      	str	r2, [r3, #88]	; 0x58

    tmp_hal_status = HAL_ERROR;
 8101aac:	2301      	movs	r3, #1
 8101aae:	77fb      	strb	r3, [r7, #31]

  /* Configuration of ADC parameters if previous preliminary actions are      */
  /* correctly completed and if there is no conversion on going on regular    */
  /* group (ADC may already be enabled at this point if HAL_ADC_Init() is     */
  /* called to update a parameter on the fly).                                */
  tmp_adc_reg_is_conversion_on_going = LL_ADC_REG_IsConversionOngoing(hadc->Instance);
 8101ab0:	687b      	ldr	r3, [r7, #4]
 8101ab2:	681b      	ldr	r3, [r3, #0]
 8101ab4:	4618      	mov	r0, r3
 8101ab6:	f7ff ff76 	bl	81019a6 <LL_ADC_REG_IsConversionOngoing>
 8101aba:	6178      	str	r0, [r7, #20]

  if (((hadc->State & HAL_ADC_STATE_ERROR_INTERNAL) == 0UL)
 8101abc:	687b      	ldr	r3, [r7, #4]
 8101abe:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8101ac0:	f003 0310 	and.w	r3, r3, #16
 8101ac4:	2b00      	cmp	r3, #0
 8101ac6:	f040 8129 	bne.w	8101d1c <HAL_ADC_Init+0x328>
      && (tmp_adc_reg_is_conversion_on_going == 0UL)
 8101aca:	697b      	ldr	r3, [r7, #20]
 8101acc:	2b00      	cmp	r3, #0
 8101ace:	f040 8125 	bne.w	8101d1c <HAL_ADC_Init+0x328>
     )
  {
    /* Set ADC state */
    ADC_STATE_CLR_SET(hadc->State,
 8101ad2:	687b      	ldr	r3, [r7, #4]
 8101ad4:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8101ad6:	f423 7381 	bic.w	r3, r3, #258	; 0x102
 8101ada:	f043 0202 	orr.w	r2, r3, #2
 8101ade:	687b      	ldr	r3, [r7, #4]
 8101ae0:	655a      	str	r2, [r3, #84]	; 0x54
    /* Configuration of common ADC parameters                                 */

    /* Parameters update conditioned to ADC state:                            */
    /* Parameters that can be updated only when ADC is disabled:              */
    /*  - clock configuration                                                 */
    if (LL_ADC_IsEnabled(hadc->Instance) == 0UL)
 8101ae2:	687b      	ldr	r3, [r7, #4]
 8101ae4:	681b      	ldr	r3, [r3, #0]
 8101ae6:	4618      	mov	r0, r3
 8101ae8:	f7ff ff4a 	bl	8101980 <LL_ADC_IsEnabled>
 8101aec:	4603      	mov	r3, r0
 8101aee:	2b00      	cmp	r3, #0
 8101af0:	d136      	bne.n	8101b60 <HAL_ADC_Init+0x16c>
    {
      if (__LL_ADC_IS_ENABLED_ALL_COMMON_INSTANCE(__LL_ADC_COMMON_INSTANCE(hadc->Instance)) == 0UL)
 8101af2:	687b      	ldr	r3, [r7, #4]
 8101af4:	681b      	ldr	r3, [r3, #0]
 8101af6:	4a66      	ldr	r2, [pc, #408]	; (8101c90 <HAL_ADC_Init+0x29c>)
 8101af8:	4293      	cmp	r3, r2
 8101afa:	d004      	beq.n	8101b06 <HAL_ADC_Init+0x112>
 8101afc:	687b      	ldr	r3, [r7, #4]
 8101afe:	681b      	ldr	r3, [r3, #0]
 8101b00:	4a64      	ldr	r2, [pc, #400]	; (8101c94 <HAL_ADC_Init+0x2a0>)
 8101b02:	4293      	cmp	r3, r2
 8101b04:	d10e      	bne.n	8101b24 <HAL_ADC_Init+0x130>
 8101b06:	4862      	ldr	r0, [pc, #392]	; (8101c90 <HAL_ADC_Init+0x29c>)
 8101b08:	f7ff ff3a 	bl	8101980 <LL_ADC_IsEnabled>
 8101b0c:	4604      	mov	r4, r0
 8101b0e:	4861      	ldr	r0, [pc, #388]	; (8101c94 <HAL_ADC_Init+0x2a0>)
 8101b10:	f7ff ff36 	bl	8101980 <LL_ADC_IsEnabled>
 8101b14:	4603      	mov	r3, r0
 8101b16:	4323      	orrs	r3, r4
 8101b18:	2b00      	cmp	r3, #0
 8101b1a:	bf0c      	ite	eq
 8101b1c:	2301      	moveq	r3, #1
 8101b1e:	2300      	movne	r3, #0
 8101b20:	b2db      	uxtb	r3, r3
 8101b22:	e008      	b.n	8101b36 <HAL_ADC_Init+0x142>
 8101b24:	485c      	ldr	r0, [pc, #368]	; (8101c98 <HAL_ADC_Init+0x2a4>)
 8101b26:	f7ff ff2b 	bl	8101980 <LL_ADC_IsEnabled>
 8101b2a:	4603      	mov	r3, r0
 8101b2c:	2b00      	cmp	r3, #0
 8101b2e:	bf0c      	ite	eq
 8101b30:	2301      	moveq	r3, #1
 8101b32:	2300      	movne	r3, #0
 8101b34:	b2db      	uxtb	r3, r3
 8101b36:	2b00      	cmp	r3, #0
 8101b38:	d012      	beq.n	8101b60 <HAL_ADC_Init+0x16c>
        /*     parameters: MDMA, DMACFG, DELAY, DUAL (set by API                */
        /*     HAL_ADCEx_MultiModeConfigChannel() )                             */
        /*   - internal measurement paths: Vbat, temperature sensor, Vref       */
        /*     (set into HAL_ADC_ConfigChannel() or                             */
        /*     HAL_ADCEx_InjectedConfigChannel() )                              */
        LL_ADC_SetCommonClock(__LL_ADC_COMMON_INSTANCE(hadc->Instance), hadc->Init.ClockPrescaler);
 8101b3a:	687b      	ldr	r3, [r7, #4]
 8101b3c:	681b      	ldr	r3, [r3, #0]
 8101b3e:	4a54      	ldr	r2, [pc, #336]	; (8101c90 <HAL_ADC_Init+0x29c>)
 8101b40:	4293      	cmp	r3, r2
 8101b42:	d004      	beq.n	8101b4e <HAL_ADC_Init+0x15a>
 8101b44:	687b      	ldr	r3, [r7, #4]
 8101b46:	681b      	ldr	r3, [r3, #0]
 8101b48:	4a52      	ldr	r2, [pc, #328]	; (8101c94 <HAL_ADC_Init+0x2a0>)
 8101b4a:	4293      	cmp	r3, r2
 8101b4c:	d101      	bne.n	8101b52 <HAL_ADC_Init+0x15e>
 8101b4e:	4a53      	ldr	r2, [pc, #332]	; (8101c9c <HAL_ADC_Init+0x2a8>)
 8101b50:	e000      	b.n	8101b54 <HAL_ADC_Init+0x160>
 8101b52:	4a53      	ldr	r2, [pc, #332]	; (8101ca0 <HAL_ADC_Init+0x2ac>)
 8101b54:	687b      	ldr	r3, [r7, #4]
 8101b56:	685b      	ldr	r3, [r3, #4]
 8101b58:	4619      	mov	r1, r3
 8101b5a:	4610      	mov	r0, r2
 8101b5c:	f7ff fdbe 	bl	81016dc <LL_ADC_SetCommonClock>
                  ADC_CFGR_REG_DISCONTINUOUS((uint32_t)hadc->Init.DiscontinuousConvMode));
    }

#else

    if ((HAL_GetREVID() > REV_ID_Y) && (ADC_RESOLUTION_8B == hadc->Init.Resolution))
 8101b60:	f7ff fd9c 	bl	810169c <HAL_GetREVID>
 8101b64:	4603      	mov	r3, r0
 8101b66:	f241 0203 	movw	r2, #4099	; 0x1003
 8101b6a:	4293      	cmp	r3, r2
 8101b6c:	d914      	bls.n	8101b98 <HAL_ADC_Init+0x1a4>
 8101b6e:	687b      	ldr	r3, [r7, #4]
 8101b70:	689b      	ldr	r3, [r3, #8]
 8101b72:	2b10      	cmp	r3, #16
 8101b74:	d110      	bne.n	8101b98 <HAL_ADC_Init+0x1a4>
    {
      /* for STM32H7 silicon rev.B and above , ADC_CFGR_RES value for 8bits resolution is : b111 */
      tmpCFGR  = (ADC_CFGR_CONTINUOUS((uint32_t)hadc->Init.ContinuousConvMode)          |
 8101b76:	687b      	ldr	r3, [r7, #4]
 8101b78:	7d5b      	ldrb	r3, [r3, #21]
 8101b7a:	035a      	lsls	r2, r3, #13
                  hadc->Init.Overrun                                                    |
 8101b7c:	687b      	ldr	r3, [r7, #4]
 8101b7e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
      tmpCFGR  = (ADC_CFGR_CONTINUOUS((uint32_t)hadc->Init.ContinuousConvMode)          |
 8101b80:	431a      	orrs	r2, r3
                  hadc->Init.Resolution | (ADC_CFGR_RES_1 | ADC_CFGR_RES_0)                |
 8101b82:	687b      	ldr	r3, [r7, #4]
 8101b84:	689b      	ldr	r3, [r3, #8]
                  hadc->Init.Overrun                                                    |
 8101b86:	431a      	orrs	r2, r3
                  ADC_CFGR_REG_DISCONTINUOUS((uint32_t)hadc->Init.DiscontinuousConvMode));
 8101b88:	687b      	ldr	r3, [r7, #4]
 8101b8a:	7f1b      	ldrb	r3, [r3, #28]
 8101b8c:	041b      	lsls	r3, r3, #16
                  hadc->Init.Resolution | (ADC_CFGR_RES_1 | ADC_CFGR_RES_0)                |
 8101b8e:	4313      	orrs	r3, r2
      tmpCFGR  = (ADC_CFGR_CONTINUOUS((uint32_t)hadc->Init.ContinuousConvMode)          |
 8101b90:	f043 030c 	orr.w	r3, r3, #12
 8101b94:	61bb      	str	r3, [r7, #24]
 8101b96:	e00d      	b.n	8101bb4 <HAL_ADC_Init+0x1c0>
    }
    else
    {

      tmpCFGR  = (ADC_CFGR_CONTINUOUS((uint32_t)hadc->Init.ContinuousConvMode)          |
 8101b98:	687b      	ldr	r3, [r7, #4]
 8101b9a:	7d5b      	ldrb	r3, [r3, #21]
 8101b9c:	035a      	lsls	r2, r3, #13
                  hadc->Init.Overrun                                                    |
 8101b9e:	687b      	ldr	r3, [r7, #4]
 8101ba0:	6b1b      	ldr	r3, [r3, #48]	; 0x30
      tmpCFGR  = (ADC_CFGR_CONTINUOUS((uint32_t)hadc->Init.ContinuousConvMode)          |
 8101ba2:	431a      	orrs	r2, r3
                  hadc->Init.Resolution                                                 |
 8101ba4:	687b      	ldr	r3, [r7, #4]
 8101ba6:	689b      	ldr	r3, [r3, #8]
                  hadc->Init.Overrun                                                    |
 8101ba8:	431a      	orrs	r2, r3
                  ADC_CFGR_REG_DISCONTINUOUS((uint32_t)hadc->Init.DiscontinuousConvMode));
 8101baa:	687b      	ldr	r3, [r7, #4]
 8101bac:	7f1b      	ldrb	r3, [r3, #28]
 8101bae:	041b      	lsls	r3, r3, #16
      tmpCFGR  = (ADC_CFGR_CONTINUOUS((uint32_t)hadc->Init.ContinuousConvMode)          |
 8101bb0:	4313      	orrs	r3, r2
 8101bb2:	61bb      	str	r3, [r7, #24]
    }

#endif /* ADC_VER_V5_3 */

    if (hadc->Init.DiscontinuousConvMode == ENABLE)
 8101bb4:	687b      	ldr	r3, [r7, #4]
 8101bb6:	7f1b      	ldrb	r3, [r3, #28]
 8101bb8:	2b01      	cmp	r3, #1
 8101bba:	d106      	bne.n	8101bca <HAL_ADC_Init+0x1d6>
    {
      tmpCFGR |= ADC_CFGR_DISCONTINUOUS_NUM(hadc->Init.NbrOfDiscConversion);
 8101bbc:	687b      	ldr	r3, [r7, #4]
 8101bbe:	6a1b      	ldr	r3, [r3, #32]
 8101bc0:	3b01      	subs	r3, #1
 8101bc2:	045b      	lsls	r3, r3, #17
 8101bc4:	69ba      	ldr	r2, [r7, #24]
 8101bc6:	4313      	orrs	r3, r2
 8101bc8:	61bb      	str	r3, [r7, #24]
    /* Enable external trigger if trigger selection is different of software  */
    /* start.                                                                 */
    /* Note: This configuration keeps the hardware feature of parameter       */
    /*       ExternalTrigConvEdge "trigger edge none" equivalent to           */
    /*       software start.                                                  */
    if (hadc->Init.ExternalTrigConv != ADC_SOFTWARE_START)
 8101bca:	687b      	ldr	r3, [r7, #4]
 8101bcc:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8101bce:	2b00      	cmp	r3, #0
 8101bd0:	d009      	beq.n	8101be6 <HAL_ADC_Init+0x1f2>
    {
      tmpCFGR |= ((hadc->Init.ExternalTrigConv & ADC_CFGR_EXTSEL)
 8101bd2:	687b      	ldr	r3, [r7, #4]
 8101bd4:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8101bd6:	f403 7278 	and.w	r2, r3, #992	; 0x3e0
                  | hadc->Init.ExternalTrigConvEdge
 8101bda:	687b      	ldr	r3, [r7, #4]
 8101bdc:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8101bde:	4313      	orrs	r3, r2
      tmpCFGR |= ((hadc->Init.ExternalTrigConv & ADC_CFGR_EXTSEL)
 8101be0:	69ba      	ldr	r2, [r7, #24]
 8101be2:	4313      	orrs	r3, r2
 8101be4:	61bb      	str	r3, [r7, #24]
      /* Update Configuration Register CFGR */
      MODIFY_REG(hadc->Instance->CFGR, ADC_CFGR_FIELDS_1, tmpCFGR);
    }
#else
    /* Update Configuration Register CFGR */
    MODIFY_REG(hadc->Instance->CFGR, ADC_CFGR_FIELDS_1, tmpCFGR);
 8101be6:	687b      	ldr	r3, [r7, #4]
 8101be8:	681b      	ldr	r3, [r3, #0]
 8101bea:	68da      	ldr	r2, [r3, #12]
 8101bec:	4b2d      	ldr	r3, [pc, #180]	; (8101ca4 <HAL_ADC_Init+0x2b0>)
 8101bee:	4013      	ands	r3, r2
 8101bf0:	687a      	ldr	r2, [r7, #4]
 8101bf2:	6812      	ldr	r2, [r2, #0]
 8101bf4:	69b9      	ldr	r1, [r7, #24]
 8101bf6:	430b      	orrs	r3, r1
 8101bf8:	60d3      	str	r3, [r2, #12]
    /* Parameters that can be updated when ADC is disabled or enabled without */
    /* conversion on going on regular and injected groups:                    */
    /*  - Conversion data management      Init.ConversionDataManagement       */
    /*  - LowPowerAutoWait feature        Init.LowPowerAutoWait               */
    /*  - Oversampling parameters         Init.Oversampling                   */
    tmp_adc_is_conversion_on_going_regular = LL_ADC_REG_IsConversionOngoing(hadc->Instance);
 8101bfa:	687b      	ldr	r3, [r7, #4]
 8101bfc:	681b      	ldr	r3, [r3, #0]
 8101bfe:	4618      	mov	r0, r3
 8101c00:	f7ff fed1 	bl	81019a6 <LL_ADC_REG_IsConversionOngoing>
 8101c04:	6138      	str	r0, [r7, #16]
    tmp_adc_is_conversion_on_going_injected = LL_ADC_INJ_IsConversionOngoing(hadc->Instance);
 8101c06:	687b      	ldr	r3, [r7, #4]
 8101c08:	681b      	ldr	r3, [r3, #0]
 8101c0a:	4618      	mov	r0, r3
 8101c0c:	f7ff fede 	bl	81019cc <LL_ADC_INJ_IsConversionOngoing>
 8101c10:	60f8      	str	r0, [r7, #12]
    if ((tmp_adc_is_conversion_on_going_regular == 0UL)
 8101c12:	693b      	ldr	r3, [r7, #16]
 8101c14:	2b00      	cmp	r3, #0
 8101c16:	d15f      	bne.n	8101cd8 <HAL_ADC_Init+0x2e4>
        && (tmp_adc_is_conversion_on_going_injected == 0UL)
 8101c18:	68fb      	ldr	r3, [r7, #12]
 8101c1a:	2b00      	cmp	r3, #0
 8101c1c:	d15c      	bne.n	8101cd8 <HAL_ADC_Init+0x2e4>
                    ADC_CFGR_AUTOWAIT((uint32_t)hadc->Init.LowPowerAutoWait)        |
                    ADC_CFGR_DMACONTREQ((uint32_t)hadc->Init.ConversionDataManagement));
      }
#else
      tmpCFGR = (
                  ADC_CFGR_AUTOWAIT((uint32_t)hadc->Init.LowPowerAutoWait)        |
 8101c1e:	687b      	ldr	r3, [r7, #4]
 8101c20:	7d1b      	ldrb	r3, [r3, #20]
 8101c22:	039a      	lsls	r2, r3, #14
                  ADC_CFGR_DMACONTREQ((uint32_t)hadc->Init.ConversionDataManagement));
 8101c24:	687b      	ldr	r3, [r7, #4]
 8101c26:	6adb      	ldr	r3, [r3, #44]	; 0x2c
      tmpCFGR = (
 8101c28:	4313      	orrs	r3, r2
 8101c2a:	61bb      	str	r3, [r7, #24]
#endif

      MODIFY_REG(hadc->Instance->CFGR, ADC_CFGR_FIELDS_2, tmpCFGR);
 8101c2c:	687b      	ldr	r3, [r7, #4]
 8101c2e:	681b      	ldr	r3, [r3, #0]
 8101c30:	68db      	ldr	r3, [r3, #12]
 8101c32:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
 8101c36:	f023 0303 	bic.w	r3, r3, #3
 8101c3a:	687a      	ldr	r2, [r7, #4]
 8101c3c:	6812      	ldr	r2, [r2, #0]
 8101c3e:	69b9      	ldr	r1, [r7, #24]
 8101c40:	430b      	orrs	r3, r1
 8101c42:	60d3      	str	r3, [r2, #12]

      if (hadc->Init.OversamplingMode == ENABLE)
 8101c44:	687b      	ldr	r3, [r7, #4]
 8101c46:	f893 3038 	ldrb.w	r3, [r3, #56]	; 0x38
 8101c4a:	2b01      	cmp	r3, #1
 8101c4c:	d12e      	bne.n	8101cac <HAL_ADC_Init+0x2b8>
#endif
        assert_param(IS_ADC_RIGHT_BIT_SHIFT(hadc->Init.Oversampling.RightBitShift));
        assert_param(IS_ADC_TRIGGERED_OVERSAMPLING_MODE(hadc->Init.Oversampling.TriggeredMode));
        assert_param(IS_ADC_REGOVERSAMPLING_MODE(hadc->Init.Oversampling.OversamplingStopReset));

        if ((hadc->Init.ExternalTrigConv == ADC_SOFTWARE_START)
 8101c4e:	687b      	ldr	r3, [r7, #4]
 8101c50:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8101c52:	2b00      	cmp	r3, #0
        /*  - Oversampling Ratio                                               */
        /*  - Right bit shift                                                  */
        /*  - Left bit shift                                                   */
        /*  - Triggered mode                                                   */
        /*  - Oversampling mode (continued/resumed)                            */
        MODIFY_REG(hadc->Instance->CFGR2, ADC_CFGR2_FIELDS,
 8101c54:	687b      	ldr	r3, [r7, #4]
 8101c56:	681b      	ldr	r3, [r3, #0]
 8101c58:	691a      	ldr	r2, [r3, #16]
 8101c5a:	4b13      	ldr	r3, [pc, #76]	; (8101ca8 <HAL_ADC_Init+0x2b4>)
 8101c5c:	4013      	ands	r3, r2
 8101c5e:	687a      	ldr	r2, [r7, #4]
 8101c60:	6bd2      	ldr	r2, [r2, #60]	; 0x3c
 8101c62:	3a01      	subs	r2, #1
 8101c64:	0411      	lsls	r1, r2, #16
 8101c66:	687a      	ldr	r2, [r7, #4]
 8101c68:	6c12      	ldr	r2, [r2, #64]	; 0x40
 8101c6a:	4311      	orrs	r1, r2
 8101c6c:	687a      	ldr	r2, [r7, #4]
 8101c6e:	6c52      	ldr	r2, [r2, #68]	; 0x44
 8101c70:	4311      	orrs	r1, r2
 8101c72:	687a      	ldr	r2, [r7, #4]
 8101c74:	6c92      	ldr	r2, [r2, #72]	; 0x48
 8101c76:	430a      	orrs	r2, r1
 8101c78:	431a      	orrs	r2, r3
 8101c7a:	687b      	ldr	r3, [r7, #4]
 8101c7c:	681b      	ldr	r3, [r3, #0]
 8101c7e:	f042 0201 	orr.w	r2, r2, #1
 8101c82:	611a      	str	r2, [r3, #16]
 8101c84:	e01a      	b.n	8101cbc <HAL_ADC_Init+0x2c8>
 8101c86:	bf00      	nop
 8101c88:	10000000 	.word	0x10000000
 8101c8c:	053e2d63 	.word	0x053e2d63
 8101c90:	40022000 	.word	0x40022000
 8101c94:	40022100 	.word	0x40022100
 8101c98:	58026000 	.word	0x58026000
 8101c9c:	40022300 	.word	0x40022300
 8101ca0:	58026300 	.word	0x58026300
 8101ca4:	fff0c003 	.word	0xfff0c003
 8101ca8:	fc00f81e 	.word	0xfc00f81e

      }
      else
      {
        /* Disable ADC oversampling scope on ADC group regular */
        CLEAR_BIT(hadc->Instance->CFGR2, ADC_CFGR2_ROVSE);
 8101cac:	687b      	ldr	r3, [r7, #4]
 8101cae:	681b      	ldr	r3, [r3, #0]
 8101cb0:	691a      	ldr	r2, [r3, #16]
 8101cb2:	687b      	ldr	r3, [r7, #4]
 8101cb4:	681b      	ldr	r3, [r3, #0]
 8101cb6:	f022 0201 	bic.w	r2, r2, #1
 8101cba:	611a      	str	r2, [r3, #16]
      }

      /* Set the LeftShift parameter: it is applied to the final result with or without oversampling */
      MODIFY_REG(hadc->Instance->CFGR2, ADC_CFGR2_LSHIFT, hadc->Init.LeftBitShift);
 8101cbc:	687b      	ldr	r3, [r7, #4]
 8101cbe:	681b      	ldr	r3, [r3, #0]
 8101cc0:	691b      	ldr	r3, [r3, #16]
 8101cc2:	f023 4170 	bic.w	r1, r3, #4026531840	; 0xf0000000
 8101cc6:	687b      	ldr	r3, [r7, #4]
 8101cc8:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8101cca:	687b      	ldr	r3, [r7, #4]
 8101ccc:	681b      	ldr	r3, [r3, #0]
 8101cce:	430a      	orrs	r2, r1
 8101cd0:	611a      	str	r2, [r3, #16]
        /* Configure the BOOST Mode */
        ADC_ConfigureBoostMode(hadc);
      }
#else
      /* Configure the BOOST Mode */
      ADC_ConfigureBoostMode(hadc);
 8101cd2:	6878      	ldr	r0, [r7, #4]
 8101cd4:	f000 fb8c 	bl	81023f0 <ADC_ConfigureBoostMode>
    /*   Note: Scan mode is not present by hardware on this device, but       */
    /*   emulated by software for alignment over all STM32 devices.           */
    /* - if scan mode is enabled, regular channels sequence length is set to  */
    /*   parameter "NbrOfConversion".                                         */

    if (hadc->Init.ScanConvMode == ADC_SCAN_ENABLE)
 8101cd8:	687b      	ldr	r3, [r7, #4]
 8101cda:	68db      	ldr	r3, [r3, #12]
 8101cdc:	2b01      	cmp	r3, #1
 8101cde:	d10c      	bne.n	8101cfa <HAL_ADC_Init+0x306>
    {
      /* Set number of ranks in regular group sequencer */
      MODIFY_REG(hadc->Instance->SQR1, ADC_SQR1_L, (hadc->Init.NbrOfConversion - (uint8_t)1));
 8101ce0:	687b      	ldr	r3, [r7, #4]
 8101ce2:	681b      	ldr	r3, [r3, #0]
 8101ce4:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8101ce6:	f023 010f 	bic.w	r1, r3, #15
 8101cea:	687b      	ldr	r3, [r7, #4]
 8101cec:	699b      	ldr	r3, [r3, #24]
 8101cee:	1e5a      	subs	r2, r3, #1
 8101cf0:	687b      	ldr	r3, [r7, #4]
 8101cf2:	681b      	ldr	r3, [r3, #0]
 8101cf4:	430a      	orrs	r2, r1
 8101cf6:	631a      	str	r2, [r3, #48]	; 0x30
 8101cf8:	e007      	b.n	8101d0a <HAL_ADC_Init+0x316>
    }
    else
    {
      CLEAR_BIT(hadc->Instance->SQR1, ADC_SQR1_L);
 8101cfa:	687b      	ldr	r3, [r7, #4]
 8101cfc:	681b      	ldr	r3, [r3, #0]
 8101cfe:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8101d00:	687b      	ldr	r3, [r7, #4]
 8101d02:	681b      	ldr	r3, [r3, #0]
 8101d04:	f022 020f 	bic.w	r2, r2, #15
 8101d08:	631a      	str	r2, [r3, #48]	; 0x30
    }

    /* Initialize the ADC state */
    /* Clear HAL_ADC_STATE_BUSY_INTERNAL bit, set HAL_ADC_STATE_READY bit */
    ADC_STATE_CLR_SET(hadc->State, HAL_ADC_STATE_BUSY_INTERNAL, HAL_ADC_STATE_READY);
 8101d0a:	687b      	ldr	r3, [r7, #4]
 8101d0c:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8101d0e:	f023 0303 	bic.w	r3, r3, #3
 8101d12:	f043 0201 	orr.w	r2, r3, #1
 8101d16:	687b      	ldr	r3, [r7, #4]
 8101d18:	655a      	str	r2, [r3, #84]	; 0x54
 8101d1a:	e007      	b.n	8101d2c <HAL_ADC_Init+0x338>
  }
  else
  {
    /* Update ADC state machine to error */
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
 8101d1c:	687b      	ldr	r3, [r7, #4]
 8101d1e:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8101d20:	f043 0210 	orr.w	r2, r3, #16
 8101d24:	687b      	ldr	r3, [r7, #4]
 8101d26:	655a      	str	r2, [r3, #84]	; 0x54

    tmp_hal_status = HAL_ERROR;
 8101d28:	2301      	movs	r3, #1
 8101d2a:	77fb      	strb	r3, [r7, #31]
  }

  /* Return function status */
  return tmp_hal_status;
 8101d2c:	7ffb      	ldrb	r3, [r7, #31]
}
 8101d2e:	4618      	mov	r0, r3
 8101d30:	3724      	adds	r7, #36	; 0x24
 8101d32:	46bd      	mov	sp, r7
 8101d34:	bd90      	pop	{r4, r7, pc}
 8101d36:	bf00      	nop

08101d38 <HAL_ADC_ConfigChannel>:
  * @param hadc ADC handle
  * @param sConfig Structure of ADC channel assigned to ADC group regular.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_ADC_ConfigChannel(ADC_HandleTypeDef *hadc, ADC_ChannelConfTypeDef *sConfig)
{
 8101d38:	b590      	push	{r4, r7, lr}
 8101d3a:	b0a1      	sub	sp, #132	; 0x84
 8101d3c:	af00      	add	r7, sp, #0
 8101d3e:	6078      	str	r0, [r7, #4]
 8101d40:	6039      	str	r1, [r7, #0]
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
 8101d42:	2300      	movs	r3, #0
 8101d44:	f887 307f 	strb.w	r3, [r7, #127]	; 0x7f
  uint32_t tmpOffsetShifted;
  uint32_t tmp_config_internal_channel;
  __IO uint32_t wait_loop_index = 0;
 8101d48:	2300      	movs	r3, #0
 8101d4a:	60bb      	str	r3, [r7, #8]
  /* if ROVSE is set, the value of the OFFSETy_EN bit in ADCx_OFRy register is
     ignored (considered as reset) */
  assert_param(!((sConfig->OffsetNumber != ADC_OFFSET_NONE) && (hadc->Init.OversamplingMode == ENABLE)));

  /* Verification of channel number */
  if (sConfig->SingleDiff != ADC_DIFFERENTIAL_ENDED)
 8101d4c:	683b      	ldr	r3, [r7, #0]
 8101d4e:	68db      	ldr	r3, [r3, #12]
 8101d50:	4a65      	ldr	r2, [pc, #404]	; (8101ee8 <HAL_ADC_ConfigChannel+0x1b0>)
 8101d52:	4293      	cmp	r3, r2
    }
#endif
  }

  /* Process locked */
  __HAL_LOCK(hadc);
 8101d54:	687b      	ldr	r3, [r7, #4]
 8101d56:	f893 3050 	ldrb.w	r3, [r3, #80]	; 0x50
 8101d5a:	2b01      	cmp	r3, #1
 8101d5c:	d101      	bne.n	8101d62 <HAL_ADC_ConfigChannel+0x2a>
 8101d5e:	2302      	movs	r3, #2
 8101d60:	e32e      	b.n	81023c0 <HAL_ADC_ConfigChannel+0x688>
 8101d62:	687b      	ldr	r3, [r7, #4]
 8101d64:	2201      	movs	r2, #1
 8101d66:	f883 2050 	strb.w	r2, [r3, #80]	; 0x50
  /* Parameters update conditioned to ADC state:                              */
  /* Parameters that can be updated when ADC is disabled or enabled without   */
  /* conversion on going on regular group:                                    */
  /*  - Channel number                                                        */
  /*  - Channel rank                                                          */
  if (LL_ADC_REG_IsConversionOngoing(hadc->Instance) == 0UL)
 8101d6a:	687b      	ldr	r3, [r7, #4]
 8101d6c:	681b      	ldr	r3, [r3, #0]
 8101d6e:	4618      	mov	r0, r3
 8101d70:	f7ff fe19 	bl	81019a6 <LL_ADC_REG_IsConversionOngoing>
 8101d74:	4603      	mov	r3, r0
 8101d76:	2b00      	cmp	r3, #0
 8101d78:	f040 8313 	bne.w	81023a2 <HAL_ADC_ConfigChannel+0x66a>
  {
    if (!(__LL_ADC_IS_CHANNEL_INTERNAL(sConfig->Channel)))
 8101d7c:	683b      	ldr	r3, [r7, #0]
 8101d7e:	681b      	ldr	r3, [r3, #0]
 8101d80:	2b00      	cmp	r3, #0
 8101d82:	db2c      	blt.n	8101dde <HAL_ADC_ConfigChannel+0xa6>
        /* ADC channels preselection */
        hadc->Instance->PCSEL_RES0 |= (1UL << (__LL_ADC_CHANNEL_TO_DECIMAL_NB((uint32_t)sConfig->Channel) & 0x1FUL));
      }
#else
      /* ADC channels preselection */
      hadc->Instance->PCSEL |= (1UL << (__LL_ADC_CHANNEL_TO_DECIMAL_NB((uint32_t)sConfig->Channel) & 0x1FUL));
 8101d84:	683b      	ldr	r3, [r7, #0]
 8101d86:	681b      	ldr	r3, [r3, #0]
 8101d88:	f3c3 0313 	ubfx	r3, r3, #0, #20
 8101d8c:	2b00      	cmp	r3, #0
 8101d8e:	d108      	bne.n	8101da2 <HAL_ADC_ConfigChannel+0x6a>
 8101d90:	683b      	ldr	r3, [r7, #0]
 8101d92:	681b      	ldr	r3, [r3, #0]
 8101d94:	0e9b      	lsrs	r3, r3, #26
 8101d96:	f003 031f 	and.w	r3, r3, #31
 8101d9a:	2201      	movs	r2, #1
 8101d9c:	fa02 f303 	lsl.w	r3, r2, r3
 8101da0:	e016      	b.n	8101dd0 <HAL_ADC_ConfigChannel+0x98>
 8101da2:	683b      	ldr	r3, [r7, #0]
 8101da4:	681b      	ldr	r3, [r3, #0]
 8101da6:	667b      	str	r3, [r7, #100]	; 0x64
  uint32_t result;

#if ((defined (__ARM_ARCH_7M__      ) && (__ARM_ARCH_7M__      == 1)) || \
     (defined (__ARM_ARCH_7EM__     ) && (__ARM_ARCH_7EM__     == 1)) || \
     (defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1))    )
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8101da8:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8101daa:	fa93 f3a3 	rbit	r3, r3
 8101dae:	663b      	str	r3, [r7, #96]	; 0x60
    result |= value & 1U;
    s--;
  }
  result <<= s;                        /* shift when v's highest bits are zero */
#endif
  return result;
 8101db0:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8101db2:	66bb      	str	r3, [r7, #104]	; 0x68
     optimisations using the logic "value was passed to __builtin_clz, so it
     is non-zero".
     ARM GCC 7.3 and possibly earlier will optimise this test away, leaving a
     single CLZ instruction.
   */
  if (value == 0U)
 8101db4:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 8101db6:	2b00      	cmp	r3, #0
 8101db8:	d101      	bne.n	8101dbe <HAL_ADC_ConfigChannel+0x86>
  {
    return 32U;
 8101dba:	2320      	movs	r3, #32
 8101dbc:	e003      	b.n	8101dc6 <HAL_ADC_ConfigChannel+0x8e>
  }
  return __builtin_clz(value);
 8101dbe:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 8101dc0:	fab3 f383 	clz	r3, r3
 8101dc4:	b2db      	uxtb	r3, r3
 8101dc6:	f003 031f 	and.w	r3, r3, #31
 8101dca:	2201      	movs	r2, #1
 8101dcc:	fa02 f303 	lsl.w	r3, r2, r3
 8101dd0:	687a      	ldr	r2, [r7, #4]
 8101dd2:	6812      	ldr	r2, [r2, #0]
 8101dd4:	69d1      	ldr	r1, [r2, #28]
 8101dd6:	687a      	ldr	r2, [r7, #4]
 8101dd8:	6812      	ldr	r2, [r2, #0]
 8101dda:	430b      	orrs	r3, r1
 8101ddc:	61d3      	str	r3, [r2, #28]
#endif /* ADC_VER_V5_V90 */
    }

    /* Set ADC group regular sequence: channel on the selected scan sequence rank */
    LL_ADC_REG_SetSequencerRanks(hadc->Instance, sConfig->Rank, sConfig->Channel);
 8101dde:	687b      	ldr	r3, [r7, #4]
 8101de0:	6818      	ldr	r0, [r3, #0]
 8101de2:	683b      	ldr	r3, [r7, #0]
 8101de4:	6859      	ldr	r1, [r3, #4]
 8101de6:	683b      	ldr	r3, [r7, #0]
 8101de8:	681b      	ldr	r3, [r3, #0]
 8101dea:	461a      	mov	r2, r3
 8101dec:	f7ff fcfe 	bl	81017ec <LL_ADC_REG_SetSequencerRanks>
    /* Parameters update conditioned to ADC state:                              */
    /* Parameters that can be updated when ADC is disabled or enabled without   */
    /* conversion on going on regular group:                                    */
    /*  - Channel sampling time                                                 */
    /*  - Channel offset                                                        */
    tmp_adc_is_conversion_on_going_regular = LL_ADC_REG_IsConversionOngoing(hadc->Instance);
 8101df0:	687b      	ldr	r3, [r7, #4]
 8101df2:	681b      	ldr	r3, [r3, #0]
 8101df4:	4618      	mov	r0, r3
 8101df6:	f7ff fdd6 	bl	81019a6 <LL_ADC_REG_IsConversionOngoing>
 8101dfa:	67b8      	str	r0, [r7, #120]	; 0x78
    tmp_adc_is_conversion_on_going_injected = LL_ADC_INJ_IsConversionOngoing(hadc->Instance);
 8101dfc:	687b      	ldr	r3, [r7, #4]
 8101dfe:	681b      	ldr	r3, [r3, #0]
 8101e00:	4618      	mov	r0, r3
 8101e02:	f7ff fde3 	bl	81019cc <LL_ADC_INJ_IsConversionOngoing>
 8101e06:	6778      	str	r0, [r7, #116]	; 0x74
    if ((tmp_adc_is_conversion_on_going_regular == 0UL)
 8101e08:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 8101e0a:	2b00      	cmp	r3, #0
 8101e0c:	f040 80b8 	bne.w	8101f80 <HAL_ADC_ConfigChannel+0x248>
        && (tmp_adc_is_conversion_on_going_injected == 0UL)
 8101e10:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 8101e12:	2b00      	cmp	r3, #0
 8101e14:	f040 80b4 	bne.w	8101f80 <HAL_ADC_ConfigChannel+0x248>
       )
    {
      /* Set sampling time of the selected ADC channel */
      LL_ADC_SetChannelSamplingTime(hadc->Instance, sConfig->Channel, sConfig->SamplingTime);
 8101e18:	687b      	ldr	r3, [r7, #4]
 8101e1a:	6818      	ldr	r0, [r3, #0]
 8101e1c:	683b      	ldr	r3, [r7, #0]
 8101e1e:	6819      	ldr	r1, [r3, #0]
 8101e20:	683b      	ldr	r3, [r7, #0]
 8101e22:	689b      	ldr	r3, [r3, #8]
 8101e24:	461a      	mov	r2, r3
 8101e26:	f7ff fd0d 	bl	8101844 <LL_ADC_SetChannelSamplingTime>
        tmpOffsetShifted = ADC3_OFFSET_SHIFT_RESOLUTION(hadc, (uint32_t)sConfig->Offset);
      }
      else
#endif /* ADC_VER_V5_V90 */
      {
        tmpOffsetShifted = ADC_OFFSET_SHIFT_RESOLUTION(hadc, (uint32_t)sConfig->Offset);
 8101e2a:	4b30      	ldr	r3, [pc, #192]	; (8101eec <HAL_ADC_ConfigChannel+0x1b4>)
 8101e2c:	681b      	ldr	r3, [r3, #0]
 8101e2e:	f003 4370 	and.w	r3, r3, #4026531840	; 0xf0000000
 8101e32:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
 8101e36:	d10b      	bne.n	8101e50 <HAL_ADC_ConfigChannel+0x118>
 8101e38:	683b      	ldr	r3, [r7, #0]
 8101e3a:	695a      	ldr	r2, [r3, #20]
 8101e3c:	687b      	ldr	r3, [r7, #4]
 8101e3e:	681b      	ldr	r3, [r3, #0]
 8101e40:	68db      	ldr	r3, [r3, #12]
 8101e42:	089b      	lsrs	r3, r3, #2
 8101e44:	f003 0307 	and.w	r3, r3, #7
 8101e48:	005b      	lsls	r3, r3, #1
 8101e4a:	fa02 f303 	lsl.w	r3, r2, r3
 8101e4e:	e01d      	b.n	8101e8c <HAL_ADC_ConfigChannel+0x154>
 8101e50:	687b      	ldr	r3, [r7, #4]
 8101e52:	681b      	ldr	r3, [r3, #0]
 8101e54:	68db      	ldr	r3, [r3, #12]
 8101e56:	f003 0310 	and.w	r3, r3, #16
 8101e5a:	2b00      	cmp	r3, #0
 8101e5c:	d10b      	bne.n	8101e76 <HAL_ADC_ConfigChannel+0x13e>
 8101e5e:	683b      	ldr	r3, [r7, #0]
 8101e60:	695a      	ldr	r2, [r3, #20]
 8101e62:	687b      	ldr	r3, [r7, #4]
 8101e64:	681b      	ldr	r3, [r3, #0]
 8101e66:	68db      	ldr	r3, [r3, #12]
 8101e68:	089b      	lsrs	r3, r3, #2
 8101e6a:	f003 0307 	and.w	r3, r3, #7
 8101e6e:	005b      	lsls	r3, r3, #1
 8101e70:	fa02 f303 	lsl.w	r3, r2, r3
 8101e74:	e00a      	b.n	8101e8c <HAL_ADC_ConfigChannel+0x154>
 8101e76:	683b      	ldr	r3, [r7, #0]
 8101e78:	695a      	ldr	r2, [r3, #20]
 8101e7a:	687b      	ldr	r3, [r7, #4]
 8101e7c:	681b      	ldr	r3, [r3, #0]
 8101e7e:	68db      	ldr	r3, [r3, #12]
 8101e80:	089b      	lsrs	r3, r3, #2
 8101e82:	f003 0304 	and.w	r3, r3, #4
 8101e86:	005b      	lsls	r3, r3, #1
 8101e88:	fa02 f303 	lsl.w	r3, r2, r3
 8101e8c:	673b      	str	r3, [r7, #112]	; 0x70
      }
      
      if (sConfig->OffsetNumber != ADC_OFFSET_NONE)
 8101e8e:	683b      	ldr	r3, [r7, #0]
 8101e90:	691b      	ldr	r3, [r3, #16]
 8101e92:	2b04      	cmp	r3, #4
 8101e94:	d02c      	beq.n	8101ef0 <HAL_ADC_ConfigChannel+0x1b8>
      {
        /* Set ADC selected offset number */
        LL_ADC_SetOffset(hadc->Instance, sConfig->OffsetNumber, sConfig->Channel, tmpOffsetShifted);
 8101e96:	687b      	ldr	r3, [r7, #4]
 8101e98:	6818      	ldr	r0, [r3, #0]
 8101e9a:	683b      	ldr	r3, [r7, #0]
 8101e9c:	6919      	ldr	r1, [r3, #16]
 8101e9e:	683b      	ldr	r3, [r7, #0]
 8101ea0:	681a      	ldr	r2, [r3, #0]
 8101ea2:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 8101ea4:	f7ff fc4e 	bl	8101744 <LL_ADC_SetOffset>
        else
#endif /* ADC_VER_V5_V90 */
        {
          assert_param(IS_FUNCTIONAL_STATE(sConfig->OffsetSignedSaturation));
          /* Set ADC selected offset signed saturation */
          LL_ADC_SetOffsetSignedSaturation(hadc->Instance, sConfig->OffsetNumber, (sConfig->OffsetSignedSaturation == ENABLE) ? LL_ADC_OFFSET_SIGNED_SATURATION_ENABLE : LL_ADC_OFFSET_SIGNED_SATURATION_DISABLE);
 8101ea8:	687b      	ldr	r3, [r7, #4]
 8101eaa:	6818      	ldr	r0, [r3, #0]
 8101eac:	683b      	ldr	r3, [r7, #0]
 8101eae:	6919      	ldr	r1, [r3, #16]
 8101eb0:	683b      	ldr	r3, [r7, #0]
 8101eb2:	7e5b      	ldrb	r3, [r3, #25]
 8101eb4:	2b01      	cmp	r3, #1
 8101eb6:	d102      	bne.n	8101ebe <HAL_ADC_ConfigChannel+0x186>
 8101eb8:	f04f 4300 	mov.w	r3, #2147483648	; 0x80000000
 8101ebc:	e000      	b.n	8101ec0 <HAL_ADC_ConfigChannel+0x188>
 8101ebe:	2300      	movs	r3, #0
 8101ec0:	461a      	mov	r2, r3
 8101ec2:	f7ff fc78 	bl	81017b6 <LL_ADC_SetOffsetSignedSaturation>

          assert_param(IS_FUNCTIONAL_STATE(sConfig->OffsetRightShift));
          /* Set ADC selected offset right shift */
          LL_ADC_SetDataRightShift(hadc->Instance, sConfig->OffsetNumber, (sConfig->OffsetRightShift == ENABLE) ? LL_ADC_OFFSET_RSHIFT_ENABLE : LL_ADC_OFFSET_RSHIFT_DISABLE);
 8101ec6:	687b      	ldr	r3, [r7, #4]
 8101ec8:	6818      	ldr	r0, [r3, #0]
 8101eca:	683b      	ldr	r3, [r7, #0]
 8101ecc:	6919      	ldr	r1, [r3, #16]
 8101ece:	683b      	ldr	r3, [r7, #0]
 8101ed0:	7e1b      	ldrb	r3, [r3, #24]
 8101ed2:	2b01      	cmp	r3, #1
 8101ed4:	d102      	bne.n	8101edc <HAL_ADC_ConfigChannel+0x1a4>
 8101ed6:	f44f 6300 	mov.w	r3, #2048	; 0x800
 8101eda:	e000      	b.n	8101ede <HAL_ADC_ConfigChannel+0x1a6>
 8101edc:	2300      	movs	r3, #0
 8101ede:	461a      	mov	r2, r3
 8101ee0:	f7ff fc50 	bl	8101784 <LL_ADC_SetDataRightShift>
 8101ee4:	e04c      	b.n	8101f80 <HAL_ADC_ConfigChannel+0x248>
 8101ee6:	bf00      	nop
 8101ee8:	47ff0000 	.word	0x47ff0000
 8101eec:	5c001000 	.word	0x5c001000
          }
        }
        else
#endif /* ADC_VER_V5_V90 */
        {
          if (((hadc->Instance->OFR1) & ADC_OFR1_OFFSET1_CH) == ADC_OFR_CHANNEL(sConfig->Channel))
 8101ef0:	687b      	ldr	r3, [r7, #4]
 8101ef2:	681b      	ldr	r3, [r3, #0]
 8101ef4:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 8101ef6:	f003 42f8 	and.w	r2, r3, #2080374784	; 0x7c000000
 8101efa:	683b      	ldr	r3, [r7, #0]
 8101efc:	681b      	ldr	r3, [r3, #0]
 8101efe:	069b      	lsls	r3, r3, #26
 8101f00:	429a      	cmp	r2, r3
 8101f02:	d107      	bne.n	8101f14 <HAL_ADC_ConfigChannel+0x1dc>
          {
            CLEAR_BIT(hadc->Instance->OFR1, ADC_OFR1_SSATE);
 8101f04:	687b      	ldr	r3, [r7, #4]
 8101f06:	681b      	ldr	r3, [r3, #0]
 8101f08:	6e1a      	ldr	r2, [r3, #96]	; 0x60
 8101f0a:	687b      	ldr	r3, [r7, #4]
 8101f0c:	681b      	ldr	r3, [r3, #0]
 8101f0e:	f022 4200 	bic.w	r2, r2, #2147483648	; 0x80000000
 8101f12:	661a      	str	r2, [r3, #96]	; 0x60
          }
          if (((hadc->Instance->OFR2) & ADC_OFR2_OFFSET2_CH) == ADC_OFR_CHANNEL(sConfig->Channel))
 8101f14:	687b      	ldr	r3, [r7, #4]
 8101f16:	681b      	ldr	r3, [r3, #0]
 8101f18:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 8101f1a:	f003 42f8 	and.w	r2, r3, #2080374784	; 0x7c000000
 8101f1e:	683b      	ldr	r3, [r7, #0]
 8101f20:	681b      	ldr	r3, [r3, #0]
 8101f22:	069b      	lsls	r3, r3, #26
 8101f24:	429a      	cmp	r2, r3
 8101f26:	d107      	bne.n	8101f38 <HAL_ADC_ConfigChannel+0x200>
          {
            CLEAR_BIT(hadc->Instance->OFR2, ADC_OFR2_SSATE);
 8101f28:	687b      	ldr	r3, [r7, #4]
 8101f2a:	681b      	ldr	r3, [r3, #0]
 8101f2c:	6e5a      	ldr	r2, [r3, #100]	; 0x64
 8101f2e:	687b      	ldr	r3, [r7, #4]
 8101f30:	681b      	ldr	r3, [r3, #0]
 8101f32:	f022 4200 	bic.w	r2, r2, #2147483648	; 0x80000000
 8101f36:	665a      	str	r2, [r3, #100]	; 0x64
          }
          if (((hadc->Instance->OFR3) & ADC_OFR3_OFFSET3_CH) == ADC_OFR_CHANNEL(sConfig->Channel))
 8101f38:	687b      	ldr	r3, [r7, #4]
 8101f3a:	681b      	ldr	r3, [r3, #0]
 8101f3c:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 8101f3e:	f003 42f8 	and.w	r2, r3, #2080374784	; 0x7c000000
 8101f42:	683b      	ldr	r3, [r7, #0]
 8101f44:	681b      	ldr	r3, [r3, #0]
 8101f46:	069b      	lsls	r3, r3, #26
 8101f48:	429a      	cmp	r2, r3
 8101f4a:	d107      	bne.n	8101f5c <HAL_ADC_ConfigChannel+0x224>
          {
            CLEAR_BIT(hadc->Instance->OFR3, ADC_OFR3_SSATE);
 8101f4c:	687b      	ldr	r3, [r7, #4]
 8101f4e:	681b      	ldr	r3, [r3, #0]
 8101f50:	6e9a      	ldr	r2, [r3, #104]	; 0x68
 8101f52:	687b      	ldr	r3, [r7, #4]
 8101f54:	681b      	ldr	r3, [r3, #0]
 8101f56:	f022 4200 	bic.w	r2, r2, #2147483648	; 0x80000000
 8101f5a:	669a      	str	r2, [r3, #104]	; 0x68
          }
          if (((hadc->Instance->OFR4) & ADC_OFR4_OFFSET4_CH) == ADC_OFR_CHANNEL(sConfig->Channel))
 8101f5c:	687b      	ldr	r3, [r7, #4]
 8101f5e:	681b      	ldr	r3, [r3, #0]
 8101f60:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 8101f62:	f003 42f8 	and.w	r2, r3, #2080374784	; 0x7c000000
 8101f66:	683b      	ldr	r3, [r7, #0]
 8101f68:	681b      	ldr	r3, [r3, #0]
 8101f6a:	069b      	lsls	r3, r3, #26
 8101f6c:	429a      	cmp	r2, r3
 8101f6e:	d107      	bne.n	8101f80 <HAL_ADC_ConfigChannel+0x248>
          {
            CLEAR_BIT(hadc->Instance->OFR4, ADC_OFR4_SSATE);
 8101f70:	687b      	ldr	r3, [r7, #4]
 8101f72:	681b      	ldr	r3, [r3, #0]
 8101f74:	6eda      	ldr	r2, [r3, #108]	; 0x6c
 8101f76:	687b      	ldr	r3, [r7, #4]
 8101f78:	681b      	ldr	r3, [r3, #0]
 8101f7a:	f022 4200 	bic.w	r2, r2, #2147483648	; 0x80000000
 8101f7e:	66da      	str	r2, [r3, #108]	; 0x6c

    /* Parameters update conditioned to ADC state:                              */
    /* Parameters that can be updated only when ADC is disabled:                */
    /*  - Single or differential mode                                           */
    /*  - Internal measurement channels: Vbat/VrefInt/TempSensor                */
    if (LL_ADC_IsEnabled(hadc->Instance) == 0UL)
 8101f80:	687b      	ldr	r3, [r7, #4]
 8101f82:	681b      	ldr	r3, [r3, #0]
 8101f84:	4618      	mov	r0, r3
 8101f86:	f7ff fcfb 	bl	8101980 <LL_ADC_IsEnabled>
 8101f8a:	4603      	mov	r3, r0
 8101f8c:	2b00      	cmp	r3, #0
 8101f8e:	f040 8211 	bne.w	81023b4 <HAL_ADC_ConfigChannel+0x67c>
    {
      /* Set mode single-ended or differential input of the selected ADC channel */
      LL_ADC_SetChannelSingleDiff(hadc->Instance, sConfig->Channel, sConfig->SingleDiff);
 8101f92:	687b      	ldr	r3, [r7, #4]
 8101f94:	6818      	ldr	r0, [r3, #0]
 8101f96:	683b      	ldr	r3, [r7, #0]
 8101f98:	6819      	ldr	r1, [r3, #0]
 8101f9a:	683b      	ldr	r3, [r7, #0]
 8101f9c:	68db      	ldr	r3, [r3, #12]
 8101f9e:	461a      	mov	r2, r3
 8101fa0:	f7ff fc7c 	bl	810189c <LL_ADC_SetChannelSingleDiff>

      /* Configuration of differential mode */
      if (sConfig->SingleDiff == ADC_DIFFERENTIAL_ENDED)
 8101fa4:	683b      	ldr	r3, [r7, #0]
 8101fa6:	68db      	ldr	r3, [r3, #12]
 8101fa8:	4aa1      	ldr	r2, [pc, #644]	; (8102230 <HAL_ADC_ConfigChannel+0x4f8>)
 8101faa:	4293      	cmp	r3, r2
 8101fac:	f040 812e 	bne.w	810220c <HAL_ADC_ConfigChannel+0x4d4>
      {
        /* Set sampling time of the selected ADC channel */
        /* Note: ADC channel number masked with value "0x1F" to ensure shift value within 32 bits range */
        LL_ADC_SetChannelSamplingTime(hadc->Instance,
 8101fb0:	687b      	ldr	r3, [r7, #4]
 8101fb2:	6818      	ldr	r0, [r3, #0]
                                      (uint32_t)(__LL_ADC_DECIMAL_NB_TO_CHANNEL((__LL_ADC_CHANNEL_TO_DECIMAL_NB((uint32_t)sConfig->Channel) + 1UL) & 0x1FUL)),
 8101fb4:	683b      	ldr	r3, [r7, #0]
 8101fb6:	681b      	ldr	r3, [r3, #0]
 8101fb8:	f3c3 0313 	ubfx	r3, r3, #0, #20
 8101fbc:	2b00      	cmp	r3, #0
 8101fbe:	d10b      	bne.n	8101fd8 <HAL_ADC_ConfigChannel+0x2a0>
 8101fc0:	683b      	ldr	r3, [r7, #0]
 8101fc2:	681b      	ldr	r3, [r3, #0]
 8101fc4:	0e9b      	lsrs	r3, r3, #26
 8101fc6:	3301      	adds	r3, #1
 8101fc8:	f003 031f 	and.w	r3, r3, #31
 8101fcc:	2b09      	cmp	r3, #9
 8101fce:	bf94      	ite	ls
 8101fd0:	2301      	movls	r3, #1
 8101fd2:	2300      	movhi	r3, #0
 8101fd4:	b2db      	uxtb	r3, r3
 8101fd6:	e019      	b.n	810200c <HAL_ADC_ConfigChannel+0x2d4>
 8101fd8:	683b      	ldr	r3, [r7, #0]
 8101fda:	681b      	ldr	r3, [r3, #0]
 8101fdc:	65bb      	str	r3, [r7, #88]	; 0x58
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8101fde:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8101fe0:	fa93 f3a3 	rbit	r3, r3
 8101fe4:	657b      	str	r3, [r7, #84]	; 0x54
  return result;
 8101fe6:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8101fe8:	65fb      	str	r3, [r7, #92]	; 0x5c
  if (value == 0U)
 8101fea:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8101fec:	2b00      	cmp	r3, #0
 8101fee:	d101      	bne.n	8101ff4 <HAL_ADC_ConfigChannel+0x2bc>
    return 32U;
 8101ff0:	2320      	movs	r3, #32
 8101ff2:	e003      	b.n	8101ffc <HAL_ADC_ConfigChannel+0x2c4>
  return __builtin_clz(value);
 8101ff4:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8101ff6:	fab3 f383 	clz	r3, r3
 8101ffa:	b2db      	uxtb	r3, r3
 8101ffc:	3301      	adds	r3, #1
 8101ffe:	f003 031f 	and.w	r3, r3, #31
 8102002:	2b09      	cmp	r3, #9
 8102004:	bf94      	ite	ls
 8102006:	2301      	movls	r3, #1
 8102008:	2300      	movhi	r3, #0
 810200a:	b2db      	uxtb	r3, r3
        LL_ADC_SetChannelSamplingTime(hadc->Instance,
 810200c:	2b00      	cmp	r3, #0
 810200e:	d079      	beq.n	8102104 <HAL_ADC_ConfigChannel+0x3cc>
                                      (uint32_t)(__LL_ADC_DECIMAL_NB_TO_CHANNEL((__LL_ADC_CHANNEL_TO_DECIMAL_NB((uint32_t)sConfig->Channel) + 1UL) & 0x1FUL)),
 8102010:	683b      	ldr	r3, [r7, #0]
 8102012:	681b      	ldr	r3, [r3, #0]
 8102014:	f3c3 0313 	ubfx	r3, r3, #0, #20
 8102018:	2b00      	cmp	r3, #0
 810201a:	d107      	bne.n	810202c <HAL_ADC_ConfigChannel+0x2f4>
 810201c:	683b      	ldr	r3, [r7, #0]
 810201e:	681b      	ldr	r3, [r3, #0]
 8102020:	0e9b      	lsrs	r3, r3, #26
 8102022:	3301      	adds	r3, #1
 8102024:	069b      	lsls	r3, r3, #26
 8102026:	f003 42f8 	and.w	r2, r3, #2080374784	; 0x7c000000
 810202a:	e015      	b.n	8102058 <HAL_ADC_ConfigChannel+0x320>
 810202c:	683b      	ldr	r3, [r7, #0]
 810202e:	681b      	ldr	r3, [r3, #0]
 8102030:	64fb      	str	r3, [r7, #76]	; 0x4c
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8102032:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8102034:	fa93 f3a3 	rbit	r3, r3
 8102038:	64bb      	str	r3, [r7, #72]	; 0x48
  return result;
 810203a:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 810203c:	653b      	str	r3, [r7, #80]	; 0x50
  if (value == 0U)
 810203e:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8102040:	2b00      	cmp	r3, #0
 8102042:	d101      	bne.n	8102048 <HAL_ADC_ConfigChannel+0x310>
    return 32U;
 8102044:	2320      	movs	r3, #32
 8102046:	e003      	b.n	8102050 <HAL_ADC_ConfigChannel+0x318>
  return __builtin_clz(value);
 8102048:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 810204a:	fab3 f383 	clz	r3, r3
 810204e:	b2db      	uxtb	r3, r3
 8102050:	3301      	adds	r3, #1
 8102052:	069b      	lsls	r3, r3, #26
 8102054:	f003 42f8 	and.w	r2, r3, #2080374784	; 0x7c000000
 8102058:	683b      	ldr	r3, [r7, #0]
 810205a:	681b      	ldr	r3, [r3, #0]
 810205c:	f3c3 0313 	ubfx	r3, r3, #0, #20
 8102060:	2b00      	cmp	r3, #0
 8102062:	d109      	bne.n	8102078 <HAL_ADC_ConfigChannel+0x340>
 8102064:	683b      	ldr	r3, [r7, #0]
 8102066:	681b      	ldr	r3, [r3, #0]
 8102068:	0e9b      	lsrs	r3, r3, #26
 810206a:	3301      	adds	r3, #1
 810206c:	f003 031f 	and.w	r3, r3, #31
 8102070:	2101      	movs	r1, #1
 8102072:	fa01 f303 	lsl.w	r3, r1, r3
 8102076:	e017      	b.n	81020a8 <HAL_ADC_ConfigChannel+0x370>
 8102078:	683b      	ldr	r3, [r7, #0]
 810207a:	681b      	ldr	r3, [r3, #0]
 810207c:	643b      	str	r3, [r7, #64]	; 0x40
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 810207e:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8102080:	fa93 f3a3 	rbit	r3, r3
 8102084:	63fb      	str	r3, [r7, #60]	; 0x3c
  return result;
 8102086:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8102088:	647b      	str	r3, [r7, #68]	; 0x44
  if (value == 0U)
 810208a:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 810208c:	2b00      	cmp	r3, #0
 810208e:	d101      	bne.n	8102094 <HAL_ADC_ConfigChannel+0x35c>
    return 32U;
 8102090:	2320      	movs	r3, #32
 8102092:	e003      	b.n	810209c <HAL_ADC_ConfigChannel+0x364>
  return __builtin_clz(value);
 8102094:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8102096:	fab3 f383 	clz	r3, r3
 810209a:	b2db      	uxtb	r3, r3
 810209c:	3301      	adds	r3, #1
 810209e:	f003 031f 	and.w	r3, r3, #31
 81020a2:	2101      	movs	r1, #1
 81020a4:	fa01 f303 	lsl.w	r3, r1, r3
 81020a8:	ea42 0103 	orr.w	r1, r2, r3
 81020ac:	683b      	ldr	r3, [r7, #0]
 81020ae:	681b      	ldr	r3, [r3, #0]
 81020b0:	f3c3 0313 	ubfx	r3, r3, #0, #20
 81020b4:	2b00      	cmp	r3, #0
 81020b6:	d10a      	bne.n	81020ce <HAL_ADC_ConfigChannel+0x396>
 81020b8:	683b      	ldr	r3, [r7, #0]
 81020ba:	681b      	ldr	r3, [r3, #0]
 81020bc:	0e9b      	lsrs	r3, r3, #26
 81020be:	3301      	adds	r3, #1
 81020c0:	f003 021f 	and.w	r2, r3, #31
 81020c4:	4613      	mov	r3, r2
 81020c6:	005b      	lsls	r3, r3, #1
 81020c8:	4413      	add	r3, r2
 81020ca:	051b      	lsls	r3, r3, #20
 81020cc:	e018      	b.n	8102100 <HAL_ADC_ConfigChannel+0x3c8>
 81020ce:	683b      	ldr	r3, [r7, #0]
 81020d0:	681b      	ldr	r3, [r3, #0]
 81020d2:	637b      	str	r3, [r7, #52]	; 0x34
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 81020d4:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 81020d6:	fa93 f3a3 	rbit	r3, r3
 81020da:	633b      	str	r3, [r7, #48]	; 0x30
  return result;
 81020dc:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 81020de:	63bb      	str	r3, [r7, #56]	; 0x38
  if (value == 0U)
 81020e0:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 81020e2:	2b00      	cmp	r3, #0
 81020e4:	d101      	bne.n	81020ea <HAL_ADC_ConfigChannel+0x3b2>
    return 32U;
 81020e6:	2320      	movs	r3, #32
 81020e8:	e003      	b.n	81020f2 <HAL_ADC_ConfigChannel+0x3ba>
  return __builtin_clz(value);
 81020ea:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 81020ec:	fab3 f383 	clz	r3, r3
 81020f0:	b2db      	uxtb	r3, r3
 81020f2:	3301      	adds	r3, #1
 81020f4:	f003 021f 	and.w	r2, r3, #31
 81020f8:	4613      	mov	r3, r2
 81020fa:	005b      	lsls	r3, r3, #1
 81020fc:	4413      	add	r3, r2
 81020fe:	051b      	lsls	r3, r3, #20
        LL_ADC_SetChannelSamplingTime(hadc->Instance,
 8102100:	430b      	orrs	r3, r1
 8102102:	e07e      	b.n	8102202 <HAL_ADC_ConfigChannel+0x4ca>
                                      (uint32_t)(__LL_ADC_DECIMAL_NB_TO_CHANNEL((__LL_ADC_CHANNEL_TO_DECIMAL_NB((uint32_t)sConfig->Channel) + 1UL) & 0x1FUL)),
 8102104:	683b      	ldr	r3, [r7, #0]
 8102106:	681b      	ldr	r3, [r3, #0]
 8102108:	f3c3 0313 	ubfx	r3, r3, #0, #20
 810210c:	2b00      	cmp	r3, #0
 810210e:	d107      	bne.n	8102120 <HAL_ADC_ConfigChannel+0x3e8>
 8102110:	683b      	ldr	r3, [r7, #0]
 8102112:	681b      	ldr	r3, [r3, #0]
 8102114:	0e9b      	lsrs	r3, r3, #26
 8102116:	3301      	adds	r3, #1
 8102118:	069b      	lsls	r3, r3, #26
 810211a:	f003 42f8 	and.w	r2, r3, #2080374784	; 0x7c000000
 810211e:	e015      	b.n	810214c <HAL_ADC_ConfigChannel+0x414>
 8102120:	683b      	ldr	r3, [r7, #0]
 8102122:	681b      	ldr	r3, [r3, #0]
 8102124:	62bb      	str	r3, [r7, #40]	; 0x28
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8102126:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8102128:	fa93 f3a3 	rbit	r3, r3
 810212c:	627b      	str	r3, [r7, #36]	; 0x24
  return result;
 810212e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8102130:	62fb      	str	r3, [r7, #44]	; 0x2c
  if (value == 0U)
 8102132:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8102134:	2b00      	cmp	r3, #0
 8102136:	d101      	bne.n	810213c <HAL_ADC_ConfigChannel+0x404>
    return 32U;
 8102138:	2320      	movs	r3, #32
 810213a:	e003      	b.n	8102144 <HAL_ADC_ConfigChannel+0x40c>
  return __builtin_clz(value);
 810213c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 810213e:	fab3 f383 	clz	r3, r3
 8102142:	b2db      	uxtb	r3, r3
 8102144:	3301      	adds	r3, #1
 8102146:	069b      	lsls	r3, r3, #26
 8102148:	f003 42f8 	and.w	r2, r3, #2080374784	; 0x7c000000
 810214c:	683b      	ldr	r3, [r7, #0]
 810214e:	681b      	ldr	r3, [r3, #0]
 8102150:	f3c3 0313 	ubfx	r3, r3, #0, #20
 8102154:	2b00      	cmp	r3, #0
 8102156:	d109      	bne.n	810216c <HAL_ADC_ConfigChannel+0x434>
 8102158:	683b      	ldr	r3, [r7, #0]
 810215a:	681b      	ldr	r3, [r3, #0]
 810215c:	0e9b      	lsrs	r3, r3, #26
 810215e:	3301      	adds	r3, #1
 8102160:	f003 031f 	and.w	r3, r3, #31
 8102164:	2101      	movs	r1, #1
 8102166:	fa01 f303 	lsl.w	r3, r1, r3
 810216a:	e017      	b.n	810219c <HAL_ADC_ConfigChannel+0x464>
 810216c:	683b      	ldr	r3, [r7, #0]
 810216e:	681b      	ldr	r3, [r3, #0]
 8102170:	61fb      	str	r3, [r7, #28]
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8102172:	69fb      	ldr	r3, [r7, #28]
 8102174:	fa93 f3a3 	rbit	r3, r3
 8102178:	61bb      	str	r3, [r7, #24]
  return result;
 810217a:	69bb      	ldr	r3, [r7, #24]
 810217c:	623b      	str	r3, [r7, #32]
  if (value == 0U)
 810217e:	6a3b      	ldr	r3, [r7, #32]
 8102180:	2b00      	cmp	r3, #0
 8102182:	d101      	bne.n	8102188 <HAL_ADC_ConfigChannel+0x450>
    return 32U;
 8102184:	2320      	movs	r3, #32
 8102186:	e003      	b.n	8102190 <HAL_ADC_ConfigChannel+0x458>
  return __builtin_clz(value);
 8102188:	6a3b      	ldr	r3, [r7, #32]
 810218a:	fab3 f383 	clz	r3, r3
 810218e:	b2db      	uxtb	r3, r3
 8102190:	3301      	adds	r3, #1
 8102192:	f003 031f 	and.w	r3, r3, #31
 8102196:	2101      	movs	r1, #1
 8102198:	fa01 f303 	lsl.w	r3, r1, r3
 810219c:	ea42 0103 	orr.w	r1, r2, r3
 81021a0:	683b      	ldr	r3, [r7, #0]
 81021a2:	681b      	ldr	r3, [r3, #0]
 81021a4:	f3c3 0313 	ubfx	r3, r3, #0, #20
 81021a8:	2b00      	cmp	r3, #0
 81021aa:	d10d      	bne.n	81021c8 <HAL_ADC_ConfigChannel+0x490>
 81021ac:	683b      	ldr	r3, [r7, #0]
 81021ae:	681b      	ldr	r3, [r3, #0]
 81021b0:	0e9b      	lsrs	r3, r3, #26
 81021b2:	3301      	adds	r3, #1
 81021b4:	f003 021f 	and.w	r2, r3, #31
 81021b8:	4613      	mov	r3, r2
 81021ba:	005b      	lsls	r3, r3, #1
 81021bc:	4413      	add	r3, r2
 81021be:	3b1e      	subs	r3, #30
 81021c0:	051b      	lsls	r3, r3, #20
 81021c2:	f043 7300 	orr.w	r3, r3, #33554432	; 0x2000000
 81021c6:	e01b      	b.n	8102200 <HAL_ADC_ConfigChannel+0x4c8>
 81021c8:	683b      	ldr	r3, [r7, #0]
 81021ca:	681b      	ldr	r3, [r3, #0]
 81021cc:	613b      	str	r3, [r7, #16]
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 81021ce:	693b      	ldr	r3, [r7, #16]
 81021d0:	fa93 f3a3 	rbit	r3, r3
 81021d4:	60fb      	str	r3, [r7, #12]
  return result;
 81021d6:	68fb      	ldr	r3, [r7, #12]
 81021d8:	617b      	str	r3, [r7, #20]
  if (value == 0U)
 81021da:	697b      	ldr	r3, [r7, #20]
 81021dc:	2b00      	cmp	r3, #0
 81021de:	d101      	bne.n	81021e4 <HAL_ADC_ConfigChannel+0x4ac>
    return 32U;
 81021e0:	2320      	movs	r3, #32
 81021e2:	e003      	b.n	81021ec <HAL_ADC_ConfigChannel+0x4b4>
  return __builtin_clz(value);
 81021e4:	697b      	ldr	r3, [r7, #20]
 81021e6:	fab3 f383 	clz	r3, r3
 81021ea:	b2db      	uxtb	r3, r3
 81021ec:	3301      	adds	r3, #1
 81021ee:	f003 021f 	and.w	r2, r3, #31
 81021f2:	4613      	mov	r3, r2
 81021f4:	005b      	lsls	r3, r3, #1
 81021f6:	4413      	add	r3, r2
 81021f8:	3b1e      	subs	r3, #30
 81021fa:	051b      	lsls	r3, r3, #20
 81021fc:	f043 7300 	orr.w	r3, r3, #33554432	; 0x2000000
        LL_ADC_SetChannelSamplingTime(hadc->Instance,
 8102200:	430b      	orrs	r3, r1
 8102202:	683a      	ldr	r2, [r7, #0]
 8102204:	6892      	ldr	r2, [r2, #8]
 8102206:	4619      	mov	r1, r3
 8102208:	f7ff fb1c 	bl	8101844 <LL_ADC_SetChannelSamplingTime>
      /* If internal channel selected, enable dedicated internal buffers and    */
      /* paths.                                                                 */
      /* Note: these internal measurement paths can be disabled using           */
      /* HAL_ADC_DeInit().                                                      */

      if (__LL_ADC_IS_CHANNEL_INTERNAL(sConfig->Channel))
 810220c:	683b      	ldr	r3, [r7, #0]
 810220e:	681b      	ldr	r3, [r3, #0]
 8102210:	2b00      	cmp	r3, #0
 8102212:	f280 80cf 	bge.w	81023b4 <HAL_ADC_ConfigChannel+0x67c>
      {
        /* Configuration of common ADC parameters                                 */

        tmp_config_internal_channel = LL_ADC_GetCommonPathInternalCh(__LL_ADC_COMMON_INSTANCE(hadc->Instance));
 8102216:	687b      	ldr	r3, [r7, #4]
 8102218:	681b      	ldr	r3, [r3, #0]
 810221a:	4a06      	ldr	r2, [pc, #24]	; (8102234 <HAL_ADC_ConfigChannel+0x4fc>)
 810221c:	4293      	cmp	r3, r2
 810221e:	d004      	beq.n	810222a <HAL_ADC_ConfigChannel+0x4f2>
 8102220:	687b      	ldr	r3, [r7, #4]
 8102222:	681b      	ldr	r3, [r3, #0]
 8102224:	4a04      	ldr	r2, [pc, #16]	; (8102238 <HAL_ADC_ConfigChannel+0x500>)
 8102226:	4293      	cmp	r3, r2
 8102228:	d10a      	bne.n	8102240 <HAL_ADC_ConfigChannel+0x508>
 810222a:	4b04      	ldr	r3, [pc, #16]	; (810223c <HAL_ADC_ConfigChannel+0x504>)
 810222c:	e009      	b.n	8102242 <HAL_ADC_ConfigChannel+0x50a>
 810222e:	bf00      	nop
 8102230:	47ff0000 	.word	0x47ff0000
 8102234:	40022000 	.word	0x40022000
 8102238:	40022100 	.word	0x40022100
 810223c:	40022300 	.word	0x40022300
 8102240:	4b61      	ldr	r3, [pc, #388]	; (81023c8 <HAL_ADC_ConfigChannel+0x690>)
 8102242:	4618      	mov	r0, r3
 8102244:	f7ff fa70 	bl	8101728 <LL_ADC_GetCommonPathInternalCh>
 8102248:	66f8      	str	r0, [r7, #108]	; 0x6c

        /* Software is allowed to change common parameters only when all ADCs   */
        /* of the common group are disabled.                                    */
        if (__LL_ADC_IS_ENABLED_ALL_COMMON_INSTANCE(__LL_ADC_COMMON_INSTANCE(hadc->Instance)) == 0UL)
 810224a:	687b      	ldr	r3, [r7, #4]
 810224c:	681b      	ldr	r3, [r3, #0]
 810224e:	4a5f      	ldr	r2, [pc, #380]	; (81023cc <HAL_ADC_ConfigChannel+0x694>)
 8102250:	4293      	cmp	r3, r2
 8102252:	d004      	beq.n	810225e <HAL_ADC_ConfigChannel+0x526>
 8102254:	687b      	ldr	r3, [r7, #4]
 8102256:	681b      	ldr	r3, [r3, #0]
 8102258:	4a5d      	ldr	r2, [pc, #372]	; (81023d0 <HAL_ADC_ConfigChannel+0x698>)
 810225a:	4293      	cmp	r3, r2
 810225c:	d10e      	bne.n	810227c <HAL_ADC_ConfigChannel+0x544>
 810225e:	485b      	ldr	r0, [pc, #364]	; (81023cc <HAL_ADC_ConfigChannel+0x694>)
 8102260:	f7ff fb8e 	bl	8101980 <LL_ADC_IsEnabled>
 8102264:	4604      	mov	r4, r0
 8102266:	485a      	ldr	r0, [pc, #360]	; (81023d0 <HAL_ADC_ConfigChannel+0x698>)
 8102268:	f7ff fb8a 	bl	8101980 <LL_ADC_IsEnabled>
 810226c:	4603      	mov	r3, r0
 810226e:	4323      	orrs	r3, r4
 8102270:	2b00      	cmp	r3, #0
 8102272:	bf0c      	ite	eq
 8102274:	2301      	moveq	r3, #1
 8102276:	2300      	movne	r3, #0
 8102278:	b2db      	uxtb	r3, r3
 810227a:	e008      	b.n	810228e <HAL_ADC_ConfigChannel+0x556>
 810227c:	4855      	ldr	r0, [pc, #340]	; (81023d4 <HAL_ADC_ConfigChannel+0x69c>)
 810227e:	f7ff fb7f 	bl	8101980 <LL_ADC_IsEnabled>
 8102282:	4603      	mov	r3, r0
 8102284:	2b00      	cmp	r3, #0
 8102286:	bf0c      	ite	eq
 8102288:	2301      	moveq	r3, #1
 810228a:	2300      	movne	r3, #0
 810228c:	b2db      	uxtb	r3, r3
 810228e:	2b00      	cmp	r3, #0
 8102290:	d07d      	beq.n	810238e <HAL_ADC_ConfigChannel+0x656>
        {
          /* If the requested internal measurement path has already been enabled, */
          /* bypass the configuration processing.                                 */
          if ((sConfig->Channel == ADC_CHANNEL_TEMPSENSOR) && ((tmp_config_internal_channel & LL_ADC_PATH_INTERNAL_TEMPSENSOR) == 0UL))
 8102292:	683b      	ldr	r3, [r7, #0]
 8102294:	681b      	ldr	r3, [r3, #0]
 8102296:	4a50      	ldr	r2, [pc, #320]	; (81023d8 <HAL_ADC_ConfigChannel+0x6a0>)
 8102298:	4293      	cmp	r3, r2
 810229a:	d130      	bne.n	81022fe <HAL_ADC_ConfigChannel+0x5c6>
 810229c:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 810229e:	f403 0300 	and.w	r3, r3, #8388608	; 0x800000
 81022a2:	2b00      	cmp	r3, #0
 81022a4:	d12b      	bne.n	81022fe <HAL_ADC_ConfigChannel+0x5c6>
          {
            if (ADC_TEMPERATURE_SENSOR_INSTANCE(hadc))
 81022a6:	687b      	ldr	r3, [r7, #4]
 81022a8:	681b      	ldr	r3, [r3, #0]
 81022aa:	4a4a      	ldr	r2, [pc, #296]	; (81023d4 <HAL_ADC_ConfigChannel+0x69c>)
 81022ac:	4293      	cmp	r3, r2
 81022ae:	f040 8081 	bne.w	81023b4 <HAL_ADC_ConfigChannel+0x67c>
            {
              LL_ADC_SetCommonPathInternalCh(__LL_ADC_COMMON_INSTANCE(hadc->Instance), LL_ADC_PATH_INTERNAL_TEMPSENSOR | tmp_config_internal_channel);
 81022b2:	687b      	ldr	r3, [r7, #4]
 81022b4:	681b      	ldr	r3, [r3, #0]
 81022b6:	4a45      	ldr	r2, [pc, #276]	; (81023cc <HAL_ADC_ConfigChannel+0x694>)
 81022b8:	4293      	cmp	r3, r2
 81022ba:	d004      	beq.n	81022c6 <HAL_ADC_ConfigChannel+0x58e>
 81022bc:	687b      	ldr	r3, [r7, #4]
 81022be:	681b      	ldr	r3, [r3, #0]
 81022c0:	4a43      	ldr	r2, [pc, #268]	; (81023d0 <HAL_ADC_ConfigChannel+0x698>)
 81022c2:	4293      	cmp	r3, r2
 81022c4:	d101      	bne.n	81022ca <HAL_ADC_ConfigChannel+0x592>
 81022c6:	4a45      	ldr	r2, [pc, #276]	; (81023dc <HAL_ADC_ConfigChannel+0x6a4>)
 81022c8:	e000      	b.n	81022cc <HAL_ADC_ConfigChannel+0x594>
 81022ca:	4a3f      	ldr	r2, [pc, #252]	; (81023c8 <HAL_ADC_ConfigChannel+0x690>)
 81022cc:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 81022ce:	f443 0300 	orr.w	r3, r3, #8388608	; 0x800000
 81022d2:	4619      	mov	r1, r3
 81022d4:	4610      	mov	r0, r2
 81022d6:	f7ff fa14 	bl	8101702 <LL_ADC_SetCommonPathInternalCh>
              /* Delay for temperature sensor stabilization time */
              /* Wait loop initialization and execution */
              /* Note: Variable divided by 2 to compensate partially              */
              /*       CPU processing cycles, scaling in us split to not          */
              /*       exceed 32 bits register capacity and handle low frequency. */
              wait_loop_index = ((LL_ADC_DELAY_TEMPSENSOR_STAB_US / 10UL) * ((SystemCoreClock / (100000UL * 2UL)) + 1UL));
 81022da:	4b41      	ldr	r3, [pc, #260]	; (81023e0 <HAL_ADC_ConfigChannel+0x6a8>)
 81022dc:	681b      	ldr	r3, [r3, #0]
 81022de:	099b      	lsrs	r3, r3, #6
 81022e0:	4a40      	ldr	r2, [pc, #256]	; (81023e4 <HAL_ADC_ConfigChannel+0x6ac>)
 81022e2:	fba2 2303 	umull	r2, r3, r2, r3
 81022e6:	099b      	lsrs	r3, r3, #6
 81022e8:	3301      	adds	r3, #1
 81022ea:	005b      	lsls	r3, r3, #1
 81022ec:	60bb      	str	r3, [r7, #8]
              while (wait_loop_index != 0UL)
 81022ee:	e002      	b.n	81022f6 <HAL_ADC_ConfigChannel+0x5be>
              {
                wait_loop_index--;
 81022f0:	68bb      	ldr	r3, [r7, #8]
 81022f2:	3b01      	subs	r3, #1
 81022f4:	60bb      	str	r3, [r7, #8]
              while (wait_loop_index != 0UL)
 81022f6:	68bb      	ldr	r3, [r7, #8]
 81022f8:	2b00      	cmp	r3, #0
 81022fa:	d1f9      	bne.n	81022f0 <HAL_ADC_ConfigChannel+0x5b8>
            if (ADC_TEMPERATURE_SENSOR_INSTANCE(hadc))
 81022fc:	e05a      	b.n	81023b4 <HAL_ADC_ConfigChannel+0x67c>
              }
            }
          }
          else if ((sConfig->Channel == ADC_CHANNEL_VBAT) && ((tmp_config_internal_channel & LL_ADC_PATH_INTERNAL_VBAT) == 0UL))
 81022fe:	683b      	ldr	r3, [r7, #0]
 8102300:	681b      	ldr	r3, [r3, #0]
 8102302:	4a39      	ldr	r2, [pc, #228]	; (81023e8 <HAL_ADC_ConfigChannel+0x6b0>)
 8102304:	4293      	cmp	r3, r2
 8102306:	d11e      	bne.n	8102346 <HAL_ADC_ConfigChannel+0x60e>
 8102308:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 810230a:	f003 7380 	and.w	r3, r3, #16777216	; 0x1000000
 810230e:	2b00      	cmp	r3, #0
 8102310:	d119      	bne.n	8102346 <HAL_ADC_ConfigChannel+0x60e>
          {
            if (ADC_BATTERY_VOLTAGE_INSTANCE(hadc))
 8102312:	687b      	ldr	r3, [r7, #4]
 8102314:	681b      	ldr	r3, [r3, #0]
 8102316:	4a2f      	ldr	r2, [pc, #188]	; (81023d4 <HAL_ADC_ConfigChannel+0x69c>)
 8102318:	4293      	cmp	r3, r2
 810231a:	d14b      	bne.n	81023b4 <HAL_ADC_ConfigChannel+0x67c>
            {
              LL_ADC_SetCommonPathInternalCh(__LL_ADC_COMMON_INSTANCE(hadc->Instance), LL_ADC_PATH_INTERNAL_VBAT | tmp_config_internal_channel);
 810231c:	687b      	ldr	r3, [r7, #4]
 810231e:	681b      	ldr	r3, [r3, #0]
 8102320:	4a2a      	ldr	r2, [pc, #168]	; (81023cc <HAL_ADC_ConfigChannel+0x694>)
 8102322:	4293      	cmp	r3, r2
 8102324:	d004      	beq.n	8102330 <HAL_ADC_ConfigChannel+0x5f8>
 8102326:	687b      	ldr	r3, [r7, #4]
 8102328:	681b      	ldr	r3, [r3, #0]
 810232a:	4a29      	ldr	r2, [pc, #164]	; (81023d0 <HAL_ADC_ConfigChannel+0x698>)
 810232c:	4293      	cmp	r3, r2
 810232e:	d101      	bne.n	8102334 <HAL_ADC_ConfigChannel+0x5fc>
 8102330:	4a2a      	ldr	r2, [pc, #168]	; (81023dc <HAL_ADC_ConfigChannel+0x6a4>)
 8102332:	e000      	b.n	8102336 <HAL_ADC_ConfigChannel+0x5fe>
 8102334:	4a24      	ldr	r2, [pc, #144]	; (81023c8 <HAL_ADC_ConfigChannel+0x690>)
 8102336:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 8102338:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 810233c:	4619      	mov	r1, r3
 810233e:	4610      	mov	r0, r2
 8102340:	f7ff f9df 	bl	8101702 <LL_ADC_SetCommonPathInternalCh>
            if (ADC_BATTERY_VOLTAGE_INSTANCE(hadc))
 8102344:	e036      	b.n	81023b4 <HAL_ADC_ConfigChannel+0x67c>
            }
          }
          else if ((sConfig->Channel == ADC_CHANNEL_VREFINT) && ((tmp_config_internal_channel & LL_ADC_PATH_INTERNAL_VREFINT) == 0UL))
 8102346:	683b      	ldr	r3, [r7, #0]
 8102348:	681b      	ldr	r3, [r3, #0]
 810234a:	4a28      	ldr	r2, [pc, #160]	; (81023ec <HAL_ADC_ConfigChannel+0x6b4>)
 810234c:	4293      	cmp	r3, r2
 810234e:	d131      	bne.n	81023b4 <HAL_ADC_ConfigChannel+0x67c>
 8102350:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 8102352:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
 8102356:	2b00      	cmp	r3, #0
 8102358:	d12c      	bne.n	81023b4 <HAL_ADC_ConfigChannel+0x67c>
          {
            if (ADC_VREFINT_INSTANCE(hadc))
 810235a:	687b      	ldr	r3, [r7, #4]
 810235c:	681b      	ldr	r3, [r3, #0]
 810235e:	4a1d      	ldr	r2, [pc, #116]	; (81023d4 <HAL_ADC_ConfigChannel+0x69c>)
 8102360:	4293      	cmp	r3, r2
 8102362:	d127      	bne.n	81023b4 <HAL_ADC_ConfigChannel+0x67c>
            {
              LL_ADC_SetCommonPathInternalCh(__LL_ADC_COMMON_INSTANCE(hadc->Instance), LL_ADC_PATH_INTERNAL_VREFINT | tmp_config_internal_channel);
 8102364:	687b      	ldr	r3, [r7, #4]
 8102366:	681b      	ldr	r3, [r3, #0]
 8102368:	4a18      	ldr	r2, [pc, #96]	; (81023cc <HAL_ADC_ConfigChannel+0x694>)
 810236a:	4293      	cmp	r3, r2
 810236c:	d004      	beq.n	8102378 <HAL_ADC_ConfigChannel+0x640>
 810236e:	687b      	ldr	r3, [r7, #4]
 8102370:	681b      	ldr	r3, [r3, #0]
 8102372:	4a17      	ldr	r2, [pc, #92]	; (81023d0 <HAL_ADC_ConfigChannel+0x698>)
 8102374:	4293      	cmp	r3, r2
 8102376:	d101      	bne.n	810237c <HAL_ADC_ConfigChannel+0x644>
 8102378:	4a18      	ldr	r2, [pc, #96]	; (81023dc <HAL_ADC_ConfigChannel+0x6a4>)
 810237a:	e000      	b.n	810237e <HAL_ADC_ConfigChannel+0x646>
 810237c:	4a12      	ldr	r2, [pc, #72]	; (81023c8 <HAL_ADC_ConfigChannel+0x690>)
 810237e:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 8102380:	f443 0380 	orr.w	r3, r3, #4194304	; 0x400000
 8102384:	4619      	mov	r1, r3
 8102386:	4610      	mov	r0, r2
 8102388:	f7ff f9bb 	bl	8101702 <LL_ADC_SetCommonPathInternalCh>
 810238c:	e012      	b.n	81023b4 <HAL_ADC_ConfigChannel+0x67c>
        /* enabled and other ADC of the common group are enabled, internal      */
        /* measurement paths cannot be enabled.                                 */
        else
        {
          /* Update ADC state machine to error */
          SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
 810238e:	687b      	ldr	r3, [r7, #4]
 8102390:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8102392:	f043 0220 	orr.w	r2, r3, #32
 8102396:	687b      	ldr	r3, [r7, #4]
 8102398:	655a      	str	r2, [r3, #84]	; 0x54

          tmp_hal_status = HAL_ERROR;
 810239a:	2301      	movs	r3, #1
 810239c:	f887 307f 	strb.w	r3, [r7, #127]	; 0x7f
 81023a0:	e008      	b.n	81023b4 <HAL_ADC_ConfigChannel+0x67c>
  /* channel could be done on neither of the channel configuration structure  */
  /* parameters.                                                              */
  else
  {
    /* Update ADC state machine to error */
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
 81023a2:	687b      	ldr	r3, [r7, #4]
 81023a4:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 81023a6:	f043 0220 	orr.w	r2, r3, #32
 81023aa:	687b      	ldr	r3, [r7, #4]
 81023ac:	655a      	str	r2, [r3, #84]	; 0x54

    tmp_hal_status = HAL_ERROR;
 81023ae:	2301      	movs	r3, #1
 81023b0:	f887 307f 	strb.w	r3, [r7, #127]	; 0x7f
  }

  /* Process unlocked */
  __HAL_UNLOCK(hadc);
 81023b4:	687b      	ldr	r3, [r7, #4]
 81023b6:	2200      	movs	r2, #0
 81023b8:	f883 2050 	strb.w	r2, [r3, #80]	; 0x50

  /* Return function status */
  return tmp_hal_status;
 81023bc:	f897 307f 	ldrb.w	r3, [r7, #127]	; 0x7f
}
 81023c0:	4618      	mov	r0, r3
 81023c2:	3784      	adds	r7, #132	; 0x84
 81023c4:	46bd      	mov	sp, r7
 81023c6:	bd90      	pop	{r4, r7, pc}
 81023c8:	58026300 	.word	0x58026300
 81023cc:	40022000 	.word	0x40022000
 81023d0:	40022100 	.word	0x40022100
 81023d4:	58026000 	.word	0x58026000
 81023d8:	cb840000 	.word	0xcb840000
 81023dc:	40022300 	.word	0x40022300
 81023e0:	10000000 	.word	0x10000000
 81023e4:	053e2d63 	.word	0x053e2d63
 81023e8:	c7520000 	.word	0xc7520000
 81023ec:	cfb80000 	.word	0xcfb80000

081023f0 <ADC_ConfigureBoostMode>:
  *         stopped.
  * @param  hadc ADC handle
  * @retval None.
  */
void ADC_ConfigureBoostMode(ADC_HandleTypeDef *hadc)
{
 81023f0:	b580      	push	{r7, lr}
 81023f2:	b084      	sub	sp, #16
 81023f4:	af00      	add	r7, sp, #0
 81023f6:	6078      	str	r0, [r7, #4]
  uint32_t freq;
  if (ADC_IS_SYNCHRONOUS_CLOCK_MODE(hadc))
 81023f8:	687b      	ldr	r3, [r7, #4]
 81023fa:	681b      	ldr	r3, [r3, #0]
 81023fc:	4a7a      	ldr	r2, [pc, #488]	; (81025e8 <ADC_ConfigureBoostMode+0x1f8>)
 81023fe:	4293      	cmp	r3, r2
 8102400:	d004      	beq.n	810240c <ADC_ConfigureBoostMode+0x1c>
 8102402:	687b      	ldr	r3, [r7, #4]
 8102404:	681b      	ldr	r3, [r3, #0]
 8102406:	4a79      	ldr	r2, [pc, #484]	; (81025ec <ADC_ConfigureBoostMode+0x1fc>)
 8102408:	4293      	cmp	r3, r2
 810240a:	d109      	bne.n	8102420 <ADC_ConfigureBoostMode+0x30>
 810240c:	4b78      	ldr	r3, [pc, #480]	; (81025f0 <ADC_ConfigureBoostMode+0x200>)
 810240e:	689b      	ldr	r3, [r3, #8]
 8102410:	f403 3340 	and.w	r3, r3, #196608	; 0x30000
 8102414:	2b00      	cmp	r3, #0
 8102416:	bf14      	ite	ne
 8102418:	2301      	movne	r3, #1
 810241a:	2300      	moveq	r3, #0
 810241c:	b2db      	uxtb	r3, r3
 810241e:	e008      	b.n	8102432 <ADC_ConfigureBoostMode+0x42>
 8102420:	4b74      	ldr	r3, [pc, #464]	; (81025f4 <ADC_ConfigureBoostMode+0x204>)
 8102422:	689b      	ldr	r3, [r3, #8]
 8102424:	f403 3340 	and.w	r3, r3, #196608	; 0x30000
 8102428:	2b00      	cmp	r3, #0
 810242a:	bf14      	ite	ne
 810242c:	2301      	movne	r3, #1
 810242e:	2300      	moveq	r3, #0
 8102430:	b2db      	uxtb	r3, r3
 8102432:	2b00      	cmp	r3, #0
 8102434:	d01c      	beq.n	8102470 <ADC_ConfigureBoostMode+0x80>
  {
    freq = HAL_RCC_GetHCLKFreq();
 8102436:	f004 fe3f 	bl	81070b8 <HAL_RCC_GetHCLKFreq>
 810243a:	60f8      	str	r0, [r7, #12]
    switch (hadc->Init.ClockPrescaler)
 810243c:	687b      	ldr	r3, [r7, #4]
 810243e:	685b      	ldr	r3, [r3, #4]
 8102440:	f5b3 3f40 	cmp.w	r3, #196608	; 0x30000
 8102444:	d010      	beq.n	8102468 <ADC_ConfigureBoostMode+0x78>
 8102446:	f5b3 3f40 	cmp.w	r3, #196608	; 0x30000
 810244a:	d873      	bhi.n	8102534 <ADC_ConfigureBoostMode+0x144>
 810244c:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 8102450:	d002      	beq.n	8102458 <ADC_ConfigureBoostMode+0x68>
 8102452:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
 8102456:	d16d      	bne.n	8102534 <ADC_ConfigureBoostMode+0x144>
    {
      case ADC_CLOCK_SYNC_PCLK_DIV1:
      case ADC_CLOCK_SYNC_PCLK_DIV2:
        freq /= (hadc->Init.ClockPrescaler >> ADC_CCR_CKMODE_Pos);
 8102458:	687b      	ldr	r3, [r7, #4]
 810245a:	685b      	ldr	r3, [r3, #4]
 810245c:	0c1b      	lsrs	r3, r3, #16
 810245e:	68fa      	ldr	r2, [r7, #12]
 8102460:	fbb2 f3f3 	udiv	r3, r2, r3
 8102464:	60fb      	str	r3, [r7, #12]
        break;
 8102466:	e068      	b.n	810253a <ADC_ConfigureBoostMode+0x14a>
      case ADC_CLOCK_SYNC_PCLK_DIV4:
        freq /= 4UL;
 8102468:	68fb      	ldr	r3, [r7, #12]
 810246a:	089b      	lsrs	r3, r3, #2
 810246c:	60fb      	str	r3, [r7, #12]
        break;
 810246e:	e064      	b.n	810253a <ADC_ConfigureBoostMode+0x14a>
        break;
    }
  }
  else
  {
    freq = HAL_RCCEx_GetPeriphCLKFreq(RCC_PERIPHCLK_ADC);
 8102470:	f44f 2000 	mov.w	r0, #524288	; 0x80000
 8102474:	f04f 0100 	mov.w	r1, #0
 8102478:	f006 f886 	bl	8108588 <HAL_RCCEx_GetPeriphCLKFreq>
 810247c:	60f8      	str	r0, [r7, #12]
    switch (hadc->Init.ClockPrescaler)
 810247e:	687b      	ldr	r3, [r7, #4]
 8102480:	685b      	ldr	r3, [r3, #4]
 8102482:	f5b3 1f30 	cmp.w	r3, #2883584	; 0x2c0000
 8102486:	d051      	beq.n	810252c <ADC_ConfigureBoostMode+0x13c>
 8102488:	f5b3 1f30 	cmp.w	r3, #2883584	; 0x2c0000
 810248c:	d854      	bhi.n	8102538 <ADC_ConfigureBoostMode+0x148>
 810248e:	f5b3 1f20 	cmp.w	r3, #2621440	; 0x280000
 8102492:	d047      	beq.n	8102524 <ADC_ConfigureBoostMode+0x134>
 8102494:	f5b3 1f20 	cmp.w	r3, #2621440	; 0x280000
 8102498:	d84e      	bhi.n	8102538 <ADC_ConfigureBoostMode+0x148>
 810249a:	f5b3 1f10 	cmp.w	r3, #2359296	; 0x240000
 810249e:	d03d      	beq.n	810251c <ADC_ConfigureBoostMode+0x12c>
 81024a0:	f5b3 1f10 	cmp.w	r3, #2359296	; 0x240000
 81024a4:	d848      	bhi.n	8102538 <ADC_ConfigureBoostMode+0x148>
 81024a6:	f5b3 1f00 	cmp.w	r3, #2097152	; 0x200000
 81024aa:	d033      	beq.n	8102514 <ADC_ConfigureBoostMode+0x124>
 81024ac:	f5b3 1f00 	cmp.w	r3, #2097152	; 0x200000
 81024b0:	d842      	bhi.n	8102538 <ADC_ConfigureBoostMode+0x148>
 81024b2:	f5b3 1fe0 	cmp.w	r3, #1835008	; 0x1c0000
 81024b6:	d029      	beq.n	810250c <ADC_ConfigureBoostMode+0x11c>
 81024b8:	f5b3 1fe0 	cmp.w	r3, #1835008	; 0x1c0000
 81024bc:	d83c      	bhi.n	8102538 <ADC_ConfigureBoostMode+0x148>
 81024be:	f5b3 1fc0 	cmp.w	r3, #1572864	; 0x180000
 81024c2:	d01a      	beq.n	81024fa <ADC_ConfigureBoostMode+0x10a>
 81024c4:	f5b3 1fc0 	cmp.w	r3, #1572864	; 0x180000
 81024c8:	d836      	bhi.n	8102538 <ADC_ConfigureBoostMode+0x148>
 81024ca:	f5b3 1fa0 	cmp.w	r3, #1310720	; 0x140000
 81024ce:	d014      	beq.n	81024fa <ADC_ConfigureBoostMode+0x10a>
 81024d0:	f5b3 1fa0 	cmp.w	r3, #1310720	; 0x140000
 81024d4:	d830      	bhi.n	8102538 <ADC_ConfigureBoostMode+0x148>
 81024d6:	f5b3 1f80 	cmp.w	r3, #1048576	; 0x100000
 81024da:	d00e      	beq.n	81024fa <ADC_ConfigureBoostMode+0x10a>
 81024dc:	f5b3 1f80 	cmp.w	r3, #1048576	; 0x100000
 81024e0:	d82a      	bhi.n	8102538 <ADC_ConfigureBoostMode+0x148>
 81024e2:	f5b3 2f40 	cmp.w	r3, #786432	; 0xc0000
 81024e6:	d008      	beq.n	81024fa <ADC_ConfigureBoostMode+0x10a>
 81024e8:	f5b3 2f40 	cmp.w	r3, #786432	; 0xc0000
 81024ec:	d824      	bhi.n	8102538 <ADC_ConfigureBoostMode+0x148>
 81024ee:	f5b3 2f80 	cmp.w	r3, #262144	; 0x40000
 81024f2:	d002      	beq.n	81024fa <ADC_ConfigureBoostMode+0x10a>
 81024f4:	f5b3 2f00 	cmp.w	r3, #524288	; 0x80000
 81024f8:	d11e      	bne.n	8102538 <ADC_ConfigureBoostMode+0x148>
      case ADC_CLOCK_ASYNC_DIV4:
      case ADC_CLOCK_ASYNC_DIV6:
      case ADC_CLOCK_ASYNC_DIV8:
      case ADC_CLOCK_ASYNC_DIV10:
      case ADC_CLOCK_ASYNC_DIV12:
        freq /= ((hadc->Init.ClockPrescaler >> ADC_CCR_PRESC_Pos) << 1UL);
 81024fa:	687b      	ldr	r3, [r7, #4]
 81024fc:	685b      	ldr	r3, [r3, #4]
 81024fe:	0c9b      	lsrs	r3, r3, #18
 8102500:	005b      	lsls	r3, r3, #1
 8102502:	68fa      	ldr	r2, [r7, #12]
 8102504:	fbb2 f3f3 	udiv	r3, r2, r3
 8102508:	60fb      	str	r3, [r7, #12]
        break;
 810250a:	e016      	b.n	810253a <ADC_ConfigureBoostMode+0x14a>
      case ADC_CLOCK_ASYNC_DIV16:
        freq /= 16UL;
 810250c:	68fb      	ldr	r3, [r7, #12]
 810250e:	091b      	lsrs	r3, r3, #4
 8102510:	60fb      	str	r3, [r7, #12]
        break;
 8102512:	e012      	b.n	810253a <ADC_ConfigureBoostMode+0x14a>
      case ADC_CLOCK_ASYNC_DIV32:
        freq /= 32UL;
 8102514:	68fb      	ldr	r3, [r7, #12]
 8102516:	095b      	lsrs	r3, r3, #5
 8102518:	60fb      	str	r3, [r7, #12]
        break;
 810251a:	e00e      	b.n	810253a <ADC_ConfigureBoostMode+0x14a>
      case ADC_CLOCK_ASYNC_DIV64:
        freq /= 64UL;
 810251c:	68fb      	ldr	r3, [r7, #12]
 810251e:	099b      	lsrs	r3, r3, #6
 8102520:	60fb      	str	r3, [r7, #12]
        break;
 8102522:	e00a      	b.n	810253a <ADC_ConfigureBoostMode+0x14a>
      case ADC_CLOCK_ASYNC_DIV128:
        freq /= 128UL;
 8102524:	68fb      	ldr	r3, [r7, #12]
 8102526:	09db      	lsrs	r3, r3, #7
 8102528:	60fb      	str	r3, [r7, #12]
        break;
 810252a:	e006      	b.n	810253a <ADC_ConfigureBoostMode+0x14a>
      case ADC_CLOCK_ASYNC_DIV256:
        freq /= 256UL;
 810252c:	68fb      	ldr	r3, [r7, #12]
 810252e:	0a1b      	lsrs	r3, r3, #8
 8102530:	60fb      	str	r3, [r7, #12]
        break;
 8102532:	e002      	b.n	810253a <ADC_ConfigureBoostMode+0x14a>
        break;
 8102534:	bf00      	nop
 8102536:	e000      	b.n	810253a <ADC_ConfigureBoostMode+0x14a>
      default:
        break;
 8102538:	bf00      	nop
  else /* if(freq > 25000000UL) */
  {
    MODIFY_REG(hadc->Instance->CR, ADC_CR_BOOST, ADC_CR_BOOST_1 | ADC_CR_BOOST_0);
  }
#else
  if (HAL_GetREVID() <= REV_ID_Y) /* STM32H7 silicon Rev.Y */
 810253a:	f7ff f8af 	bl	810169c <HAL_GetREVID>
 810253e:	4603      	mov	r3, r0
 8102540:	f241 0203 	movw	r2, #4099	; 0x1003
 8102544:	4293      	cmp	r3, r2
 8102546:	d815      	bhi.n	8102574 <ADC_ConfigureBoostMode+0x184>
  {
    if (freq > 20000000UL)
 8102548:	68fb      	ldr	r3, [r7, #12]
 810254a:	4a2b      	ldr	r2, [pc, #172]	; (81025f8 <ADC_ConfigureBoostMode+0x208>)
 810254c:	4293      	cmp	r3, r2
 810254e:	d908      	bls.n	8102562 <ADC_ConfigureBoostMode+0x172>
    {
      SET_BIT(hadc->Instance->CR, ADC_CR_BOOST_0);
 8102550:	687b      	ldr	r3, [r7, #4]
 8102552:	681b      	ldr	r3, [r3, #0]
 8102554:	689a      	ldr	r2, [r3, #8]
 8102556:	687b      	ldr	r3, [r7, #4]
 8102558:	681b      	ldr	r3, [r3, #0]
 810255a:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 810255e:	609a      	str	r2, [r3, #8]
    {
      MODIFY_REG(hadc->Instance->CR, ADC_CR_BOOST, ADC_CR_BOOST_1 | ADC_CR_BOOST_0);
    }
  }
#endif /* ADC_VER_V5_3 */
}
 8102560:	e03e      	b.n	81025e0 <ADC_ConfigureBoostMode+0x1f0>
      CLEAR_BIT(hadc->Instance->CR, ADC_CR_BOOST_0);
 8102562:	687b      	ldr	r3, [r7, #4]
 8102564:	681b      	ldr	r3, [r3, #0]
 8102566:	689a      	ldr	r2, [r3, #8]
 8102568:	687b      	ldr	r3, [r7, #4]
 810256a:	681b      	ldr	r3, [r3, #0]
 810256c:	f422 7280 	bic.w	r2, r2, #256	; 0x100
 8102570:	609a      	str	r2, [r3, #8]
}
 8102572:	e035      	b.n	81025e0 <ADC_ConfigureBoostMode+0x1f0>
    freq /= 2U; /* divider by 2 for Rev.V */
 8102574:	68fb      	ldr	r3, [r7, #12]
 8102576:	085b      	lsrs	r3, r3, #1
 8102578:	60fb      	str	r3, [r7, #12]
    if (freq <= 6250000UL)
 810257a:	68fb      	ldr	r3, [r7, #12]
 810257c:	4a1f      	ldr	r2, [pc, #124]	; (81025fc <ADC_ConfigureBoostMode+0x20c>)
 810257e:	4293      	cmp	r3, r2
 8102580:	d808      	bhi.n	8102594 <ADC_ConfigureBoostMode+0x1a4>
      MODIFY_REG(hadc->Instance->CR, ADC_CR_BOOST, 0UL);
 8102582:	687b      	ldr	r3, [r7, #4]
 8102584:	681b      	ldr	r3, [r3, #0]
 8102586:	689a      	ldr	r2, [r3, #8]
 8102588:	687b      	ldr	r3, [r7, #4]
 810258a:	681b      	ldr	r3, [r3, #0]
 810258c:	f422 7240 	bic.w	r2, r2, #768	; 0x300
 8102590:	609a      	str	r2, [r3, #8]
}
 8102592:	e025      	b.n	81025e0 <ADC_ConfigureBoostMode+0x1f0>
    else if (freq <= 12500000UL)
 8102594:	68fb      	ldr	r3, [r7, #12]
 8102596:	4a1a      	ldr	r2, [pc, #104]	; (8102600 <ADC_ConfigureBoostMode+0x210>)
 8102598:	4293      	cmp	r3, r2
 810259a:	d80a      	bhi.n	81025b2 <ADC_ConfigureBoostMode+0x1c2>
      MODIFY_REG(hadc->Instance->CR, ADC_CR_BOOST, ADC_CR_BOOST_0);
 810259c:	687b      	ldr	r3, [r7, #4]
 810259e:	681b      	ldr	r3, [r3, #0]
 81025a0:	689b      	ldr	r3, [r3, #8]
 81025a2:	f423 7240 	bic.w	r2, r3, #768	; 0x300
 81025a6:	687b      	ldr	r3, [r7, #4]
 81025a8:	681b      	ldr	r3, [r3, #0]
 81025aa:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 81025ae:	609a      	str	r2, [r3, #8]
}
 81025b0:	e016      	b.n	81025e0 <ADC_ConfigureBoostMode+0x1f0>
    else if (freq <= 25000000UL)
 81025b2:	68fb      	ldr	r3, [r7, #12]
 81025b4:	4a13      	ldr	r2, [pc, #76]	; (8102604 <ADC_ConfigureBoostMode+0x214>)
 81025b6:	4293      	cmp	r3, r2
 81025b8:	d80a      	bhi.n	81025d0 <ADC_ConfigureBoostMode+0x1e0>
      MODIFY_REG(hadc->Instance->CR, ADC_CR_BOOST, ADC_CR_BOOST_1);
 81025ba:	687b      	ldr	r3, [r7, #4]
 81025bc:	681b      	ldr	r3, [r3, #0]
 81025be:	689b      	ldr	r3, [r3, #8]
 81025c0:	f423 7240 	bic.w	r2, r3, #768	; 0x300
 81025c4:	687b      	ldr	r3, [r7, #4]
 81025c6:	681b      	ldr	r3, [r3, #0]
 81025c8:	f442 7200 	orr.w	r2, r2, #512	; 0x200
 81025cc:	609a      	str	r2, [r3, #8]
}
 81025ce:	e007      	b.n	81025e0 <ADC_ConfigureBoostMode+0x1f0>
      MODIFY_REG(hadc->Instance->CR, ADC_CR_BOOST, ADC_CR_BOOST_1 | ADC_CR_BOOST_0);
 81025d0:	687b      	ldr	r3, [r7, #4]
 81025d2:	681b      	ldr	r3, [r3, #0]
 81025d4:	689a      	ldr	r2, [r3, #8]
 81025d6:	687b      	ldr	r3, [r7, #4]
 81025d8:	681b      	ldr	r3, [r3, #0]
 81025da:	f442 7240 	orr.w	r2, r2, #768	; 0x300
 81025de:	609a      	str	r2, [r3, #8]
}
 81025e0:	bf00      	nop
 81025e2:	3710      	adds	r7, #16
 81025e4:	46bd      	mov	sp, r7
 81025e6:	bd80      	pop	{r7, pc}
 81025e8:	40022000 	.word	0x40022000
 81025ec:	40022100 	.word	0x40022100
 81025f0:	40022300 	.word	0x40022300
 81025f4:	58026300 	.word	0x58026300
 81025f8:	01312d00 	.word	0x01312d00
 81025fc:	005f5e10 	.word	0x005f5e10
 8102600:	00bebc20 	.word	0x00bebc20
 8102604:	017d7840 	.word	0x017d7840

08102608 <LL_ADC_SetCommonPathInternalCh>:
{
 8102608:	b480      	push	{r7}
 810260a:	b083      	sub	sp, #12
 810260c:	af00      	add	r7, sp, #0
 810260e:	6078      	str	r0, [r7, #4]
 8102610:	6039      	str	r1, [r7, #0]
  MODIFY_REG(ADCxy_COMMON->CCR, ADC_CCR_VREFEN | ADC_CCR_TSEN | ADC_CCR_VBATEN, PathInternal);
 8102612:	687b      	ldr	r3, [r7, #4]
 8102614:	689b      	ldr	r3, [r3, #8]
 8102616:	f023 72e0 	bic.w	r2, r3, #29360128	; 0x1c00000
 810261a:	683b      	ldr	r3, [r7, #0]
 810261c:	431a      	orrs	r2, r3
 810261e:	687b      	ldr	r3, [r7, #4]
 8102620:	609a      	str	r2, [r3, #8]
}
 8102622:	bf00      	nop
 8102624:	370c      	adds	r7, #12
 8102626:	46bd      	mov	sp, r7
 8102628:	f85d 7b04 	ldr.w	r7, [sp], #4
 810262c:	4770      	bx	lr

0810262e <LL_ADC_GetCommonPathInternalCh>:
{
 810262e:	b480      	push	{r7}
 8102630:	b083      	sub	sp, #12
 8102632:	af00      	add	r7, sp, #0
 8102634:	6078      	str	r0, [r7, #4]
  return (uint32_t)(READ_BIT(ADCxy_COMMON->CCR, ADC_CCR_VREFEN | ADC_CCR_TSEN | ADC_CCR_VBATEN));
 8102636:	687b      	ldr	r3, [r7, #4]
 8102638:	689b      	ldr	r3, [r3, #8]
 810263a:	f003 73e0 	and.w	r3, r3, #29360128	; 0x1c00000
}
 810263e:	4618      	mov	r0, r3
 8102640:	370c      	adds	r7, #12
 8102642:	46bd      	mov	sp, r7
 8102644:	f85d 7b04 	ldr.w	r7, [sp], #4
 8102648:	4770      	bx	lr

0810264a <LL_ADC_SetOffset>:
{
 810264a:	b480      	push	{r7}
 810264c:	b087      	sub	sp, #28
 810264e:	af00      	add	r7, sp, #0
 8102650:	60f8      	str	r0, [r7, #12]
 8102652:	60b9      	str	r1, [r7, #8]
 8102654:	607a      	str	r2, [r7, #4]
 8102656:	603b      	str	r3, [r7, #0]
  __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->OFR1, Offsety);
 8102658:	68fb      	ldr	r3, [r7, #12]
 810265a:	3360      	adds	r3, #96	; 0x60
 810265c:	461a      	mov	r2, r3
 810265e:	68bb      	ldr	r3, [r7, #8]
 8102660:	009b      	lsls	r3, r3, #2
 8102662:	4413      	add	r3, r2
 8102664:	617b      	str	r3, [r7, #20]
    MODIFY_REG(*preg,
 8102666:	697b      	ldr	r3, [r7, #20]
 8102668:	681b      	ldr	r3, [r3, #0]
 810266a:	f003 4200 	and.w	r2, r3, #2147483648	; 0x80000000
 810266e:	687b      	ldr	r3, [r7, #4]
 8102670:	f003 41f8 	and.w	r1, r3, #2080374784	; 0x7c000000
 8102674:	683b      	ldr	r3, [r7, #0]
 8102676:	430b      	orrs	r3, r1
 8102678:	431a      	orrs	r2, r3
 810267a:	697b      	ldr	r3, [r7, #20]
 810267c:	601a      	str	r2, [r3, #0]
}
 810267e:	bf00      	nop
 8102680:	371c      	adds	r7, #28
 8102682:	46bd      	mov	sp, r7
 8102684:	f85d 7b04 	ldr.w	r7, [sp], #4
 8102688:	4770      	bx	lr

0810268a <LL_ADC_GetOffsetChannel>:
{
 810268a:	b480      	push	{r7}
 810268c:	b085      	sub	sp, #20
 810268e:	af00      	add	r7, sp, #0
 8102690:	6078      	str	r0, [r7, #4]
 8102692:	6039      	str	r1, [r7, #0]
  const __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->OFR1, Offsety);
 8102694:	687b      	ldr	r3, [r7, #4]
 8102696:	3360      	adds	r3, #96	; 0x60
 8102698:	461a      	mov	r2, r3
 810269a:	683b      	ldr	r3, [r7, #0]
 810269c:	009b      	lsls	r3, r3, #2
 810269e:	4413      	add	r3, r2
 81026a0:	60fb      	str	r3, [r7, #12]
  return (uint32_t) READ_BIT(*preg, ADC_OFR1_OFFSET1_CH);
 81026a2:	68fb      	ldr	r3, [r7, #12]
 81026a4:	681b      	ldr	r3, [r3, #0]
 81026a6:	f003 43f8 	and.w	r3, r3, #2080374784	; 0x7c000000
}
 81026aa:	4618      	mov	r0, r3
 81026ac:	3714      	adds	r7, #20
 81026ae:	46bd      	mov	sp, r7
 81026b0:	f85d 7b04 	ldr.w	r7, [sp], #4
 81026b4:	4770      	bx	lr

081026b6 <LL_ADC_SetOffsetSignedSaturation>:
{
 81026b6:	b480      	push	{r7}
 81026b8:	b087      	sub	sp, #28
 81026ba:	af00      	add	r7, sp, #0
 81026bc:	60f8      	str	r0, [r7, #12]
 81026be:	60b9      	str	r1, [r7, #8]
 81026c0:	607a      	str	r2, [r7, #4]
    __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->OFR1, Offsety);
 81026c2:	68fb      	ldr	r3, [r7, #12]
 81026c4:	3360      	adds	r3, #96	; 0x60
 81026c6:	461a      	mov	r2, r3
 81026c8:	68bb      	ldr	r3, [r7, #8]
 81026ca:	009b      	lsls	r3, r3, #2
 81026cc:	4413      	add	r3, r2
 81026ce:	617b      	str	r3, [r7, #20]
    MODIFY_REG(*preg, ADC_OFR1_SSATE, OffsetSignedSaturation);
 81026d0:	697b      	ldr	r3, [r7, #20]
 81026d2:	681b      	ldr	r3, [r3, #0]
 81026d4:	f023 4200 	bic.w	r2, r3, #2147483648	; 0x80000000
 81026d8:	687b      	ldr	r3, [r7, #4]
 81026da:	431a      	orrs	r2, r3
 81026dc:	697b      	ldr	r3, [r7, #20]
 81026de:	601a      	str	r2, [r3, #0]
}
 81026e0:	bf00      	nop
 81026e2:	371c      	adds	r7, #28
 81026e4:	46bd      	mov	sp, r7
 81026e6:	f85d 7b04 	ldr.w	r7, [sp], #4
 81026ea:	4770      	bx	lr

081026ec <LL_ADC_INJ_SetQueueMode>:
{
 81026ec:	b480      	push	{r7}
 81026ee:	b083      	sub	sp, #12
 81026f0:	af00      	add	r7, sp, #0
 81026f2:	6078      	str	r0, [r7, #4]
 81026f4:	6039      	str	r1, [r7, #0]
  MODIFY_REG(ADCx->CFGR, ADC_CFGR_JQM | ADC_CFGR_JQDIS, QueueMode);
 81026f6:	687b      	ldr	r3, [r7, #4]
 81026f8:	68db      	ldr	r3, [r3, #12]
 81026fa:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 81026fe:	f423 1300 	bic.w	r3, r3, #2097152	; 0x200000
 8102702:	683a      	ldr	r2, [r7, #0]
 8102704:	431a      	orrs	r2, r3
 8102706:	687b      	ldr	r3, [r7, #4]
 8102708:	60da      	str	r2, [r3, #12]
}
 810270a:	bf00      	nop
 810270c:	370c      	adds	r7, #12
 810270e:	46bd      	mov	sp, r7
 8102710:	f85d 7b04 	ldr.w	r7, [sp], #4
 8102714:	4770      	bx	lr

08102716 <LL_ADC_SetChannelSamplingTime>:
{
 8102716:	b480      	push	{r7}
 8102718:	b087      	sub	sp, #28
 810271a:	af00      	add	r7, sp, #0
 810271c:	60f8      	str	r0, [r7, #12]
 810271e:	60b9      	str	r1, [r7, #8]
 8102720:	607a      	str	r2, [r7, #4]
  __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->SMPR1, ((Channel & ADC_CHANNEL_SMPRX_REGOFFSET_MASK) >> ADC_SMPRX_REGOFFSET_POS));
 8102722:	68fb      	ldr	r3, [r7, #12]
 8102724:	3314      	adds	r3, #20
 8102726:	461a      	mov	r2, r3
 8102728:	68bb      	ldr	r3, [r7, #8]
 810272a:	0e5b      	lsrs	r3, r3, #25
 810272c:	009b      	lsls	r3, r3, #2
 810272e:	f003 0304 	and.w	r3, r3, #4
 8102732:	4413      	add	r3, r2
 8102734:	617b      	str	r3, [r7, #20]
  MODIFY_REG(*preg,
 8102736:	697b      	ldr	r3, [r7, #20]
 8102738:	681a      	ldr	r2, [r3, #0]
 810273a:	68bb      	ldr	r3, [r7, #8]
 810273c:	0d1b      	lsrs	r3, r3, #20
 810273e:	f003 031f 	and.w	r3, r3, #31
 8102742:	2107      	movs	r1, #7
 8102744:	fa01 f303 	lsl.w	r3, r1, r3
 8102748:	43db      	mvns	r3, r3
 810274a:	401a      	ands	r2, r3
 810274c:	68bb      	ldr	r3, [r7, #8]
 810274e:	0d1b      	lsrs	r3, r3, #20
 8102750:	f003 031f 	and.w	r3, r3, #31
 8102754:	6879      	ldr	r1, [r7, #4]
 8102756:	fa01 f303 	lsl.w	r3, r1, r3
 810275a:	431a      	orrs	r2, r3
 810275c:	697b      	ldr	r3, [r7, #20]
 810275e:	601a      	str	r2, [r3, #0]
}
 8102760:	bf00      	nop
 8102762:	371c      	adds	r7, #28
 8102764:	46bd      	mov	sp, r7
 8102766:	f85d 7b04 	ldr.w	r7, [sp], #4
 810276a:	4770      	bx	lr

0810276c <LL_ADC_SetChannelSingleDiff>:
{
 810276c:	b480      	push	{r7}
 810276e:	b085      	sub	sp, #20
 8102770:	af00      	add	r7, sp, #0
 8102772:	60f8      	str	r0, [r7, #12]
 8102774:	60b9      	str	r1, [r7, #8]
 8102776:	607a      	str	r2, [r7, #4]
  MODIFY_REG(ADCx->DIFSEL,
 8102778:	68fb      	ldr	r3, [r7, #12]
 810277a:	f8d3 20c0 	ldr.w	r2, [r3, #192]	; 0xc0
 810277e:	68bb      	ldr	r3, [r7, #8]
 8102780:	f3c3 0313 	ubfx	r3, r3, #0, #20
 8102784:	43db      	mvns	r3, r3
 8102786:	401a      	ands	r2, r3
 8102788:	687b      	ldr	r3, [r7, #4]
 810278a:	f003 0318 	and.w	r3, r3, #24
 810278e:	4908      	ldr	r1, [pc, #32]	; (81027b0 <LL_ADC_SetChannelSingleDiff+0x44>)
 8102790:	40d9      	lsrs	r1, r3
 8102792:	68bb      	ldr	r3, [r7, #8]
 8102794:	400b      	ands	r3, r1
 8102796:	f3c3 0313 	ubfx	r3, r3, #0, #20
 810279a:	431a      	orrs	r2, r3
 810279c:	68fb      	ldr	r3, [r7, #12]
 810279e:	f8c3 20c0 	str.w	r2, [r3, #192]	; 0xc0
}
 81027a2:	bf00      	nop
 81027a4:	3714      	adds	r7, #20
 81027a6:	46bd      	mov	sp, r7
 81027a8:	f85d 7b04 	ldr.w	r7, [sp], #4
 81027ac:	4770      	bx	lr
 81027ae:	bf00      	nop
 81027b0:	000fffff 	.word	0x000fffff

081027b4 <LL_ADC_IsEnabled>:
{
 81027b4:	b480      	push	{r7}
 81027b6:	b083      	sub	sp, #12
 81027b8:	af00      	add	r7, sp, #0
 81027ba:	6078      	str	r0, [r7, #4]
  return ((READ_BIT(ADCx->CR, ADC_CR_ADEN) == (ADC_CR_ADEN)) ? 1UL : 0UL);
 81027bc:	687b      	ldr	r3, [r7, #4]
 81027be:	689b      	ldr	r3, [r3, #8]
 81027c0:	f003 0301 	and.w	r3, r3, #1
 81027c4:	2b01      	cmp	r3, #1
 81027c6:	d101      	bne.n	81027cc <LL_ADC_IsEnabled+0x18>
 81027c8:	2301      	movs	r3, #1
 81027ca:	e000      	b.n	81027ce <LL_ADC_IsEnabled+0x1a>
 81027cc:	2300      	movs	r3, #0
}
 81027ce:	4618      	mov	r0, r3
 81027d0:	370c      	adds	r7, #12
 81027d2:	46bd      	mov	sp, r7
 81027d4:	f85d 7b04 	ldr.w	r7, [sp], #4
 81027d8:	4770      	bx	lr

081027da <LL_ADC_REG_IsConversionOngoing>:
{
 81027da:	b480      	push	{r7}
 81027dc:	b083      	sub	sp, #12
 81027de:	af00      	add	r7, sp, #0
 81027e0:	6078      	str	r0, [r7, #4]
  return ((READ_BIT(ADCx->CR, ADC_CR_ADSTART) == (ADC_CR_ADSTART)) ? 1UL : 0UL);
 81027e2:	687b      	ldr	r3, [r7, #4]
 81027e4:	689b      	ldr	r3, [r3, #8]
 81027e6:	f003 0304 	and.w	r3, r3, #4
 81027ea:	2b04      	cmp	r3, #4
 81027ec:	d101      	bne.n	81027f2 <LL_ADC_REG_IsConversionOngoing+0x18>
 81027ee:	2301      	movs	r3, #1
 81027f0:	e000      	b.n	81027f4 <LL_ADC_REG_IsConversionOngoing+0x1a>
 81027f2:	2300      	movs	r3, #0
}
 81027f4:	4618      	mov	r0, r3
 81027f6:	370c      	adds	r7, #12
 81027f8:	46bd      	mov	sp, r7
 81027fa:	f85d 7b04 	ldr.w	r7, [sp], #4
 81027fe:	4770      	bx	lr

08102800 <LL_ADC_INJ_IsConversionOngoing>:
{
 8102800:	b480      	push	{r7}
 8102802:	b083      	sub	sp, #12
 8102804:	af00      	add	r7, sp, #0
 8102806:	6078      	str	r0, [r7, #4]
  return ((READ_BIT(ADCx->CR, ADC_CR_JADSTART) == (ADC_CR_JADSTART)) ? 1UL : 0UL);
 8102808:	687b      	ldr	r3, [r7, #4]
 810280a:	689b      	ldr	r3, [r3, #8]
 810280c:	f003 0308 	and.w	r3, r3, #8
 8102810:	2b08      	cmp	r3, #8
 8102812:	d101      	bne.n	8102818 <LL_ADC_INJ_IsConversionOngoing+0x18>
 8102814:	2301      	movs	r3, #1
 8102816:	e000      	b.n	810281a <LL_ADC_INJ_IsConversionOngoing+0x1a>
 8102818:	2300      	movs	r3, #0
}
 810281a:	4618      	mov	r0, r3
 810281c:	370c      	adds	r7, #12
 810281e:	46bd      	mov	sp, r7
 8102820:	f85d 7b04 	ldr.w	r7, [sp], #4
 8102824:	4770      	bx	lr
	...

08102828 <HAL_ADCEx_InjectedConfigChannel>:
  * @param sConfigInjected Structure of ADC injected group and ADC channel for
  *         injected group.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_ADCEx_InjectedConfigChannel(ADC_HandleTypeDef *hadc, ADC_InjectionConfTypeDef *sConfigInjected)
{
 8102828:	b590      	push	{r4, r7, lr}
 810282a:	b0bb      	sub	sp, #236	; 0xec
 810282c:	af00      	add	r7, sp, #0
 810282e:	6078      	str	r0, [r7, #4]
 8102830:	6039      	str	r1, [r7, #0]
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
 8102832:	2300      	movs	r3, #0
 8102834:	f887 30e7 	strb.w	r3, [r7, #231]	; 0xe7
  uint32_t tmpOffsetShifted;
  uint32_t tmp_config_internal_channel;
  uint32_t tmp_adc_is_conversion_on_going_regular;
  uint32_t tmp_adc_is_conversion_on_going_injected;
  __IO uint32_t wait_loop_index = 0;
 8102838:	2300      	movs	r3, #0
 810283a:	60fb      	str	r3, [r7, #12]

  uint32_t tmp_JSQR_ContextQueueBeingBuilt = 0U;
 810283c:	2300      	movs	r3, #0
 810283e:	f8c7 30e0 	str.w	r3, [r7, #224]	; 0xe0

  /*  DISCEN and JAUTO bits can't be set at the same time */
  assert_param(!((hadc->Init.DiscontinuousConvMode == ENABLE) && (sConfigInjected->AutoInjectedConv == ENABLE)));

  /* Verification of channel number */
  if (sConfigInjected->InjectedSingleDiff != ADC_DIFFERENTIAL_ENDED)
 8102842:	683b      	ldr	r3, [r7, #0]
 8102844:	68db      	ldr	r3, [r3, #12]
 8102846:	4a9f      	ldr	r2, [pc, #636]	; (8102ac4 <HAL_ADCEx_InjectedConfigChannel+0x29c>)
 8102848:	4293      	cmp	r3, r2
    }
#endif
  }

  /* Process locked */
  __HAL_LOCK(hadc);
 810284a:	687b      	ldr	r3, [r7, #4]
 810284c:	f893 3050 	ldrb.w	r3, [r3, #80]	; 0x50
 8102850:	2b01      	cmp	r3, #1
 8102852:	d102      	bne.n	810285a <HAL_ADCEx_InjectedConfigChannel+0x32>
 8102854:	2302      	movs	r3, #2
 8102856:	f000 bd57 	b.w	8103308 <HAL_ADCEx_InjectedConfigChannel+0xae0>
 810285a:	687b      	ldr	r3, [r7, #4]
 810285c:	2201      	movs	r2, #1
 810285e:	f883 2050 	strb.w	r2, [r3, #80]	; 0x50
  /*      injected channel rank. It is entered into queue only when all       */
  /*      injected ranks have been set.                                       */
  /*   Note: Scan mode is not present by hardware on this device, but used    */
  /*   by software for alignment over all STM32 devices.                      */

  if ((hadc->Init.ScanConvMode == ADC_SCAN_DISABLE)  ||
 8102862:	687b      	ldr	r3, [r7, #4]
 8102864:	68db      	ldr	r3, [r3, #12]
 8102866:	2b00      	cmp	r3, #0
 8102868:	d003      	beq.n	8102872 <HAL_ADCEx_InjectedConfigChannel+0x4a>
      (sConfigInjected->InjectedNbrOfConversion == 1U))
 810286a:	683b      	ldr	r3, [r7, #0]
 810286c:	6a1b      	ldr	r3, [r3, #32]
  if ((hadc->Init.ScanConvMode == ADC_SCAN_DISABLE)  ||
 810286e:	2b01      	cmp	r3, #1
 8102870:	d130      	bne.n	81028d4 <HAL_ADCEx_InjectedConfigChannel+0xac>
    /*    (scan mode disabled, only rank 1 used)                              */
    /*  - external trigger to start conversion                                */
    /*  - external trigger polarity                                           */
    /*  - channel set to rank 1 (scan mode disabled, only rank 1 can be used) */

    if (sConfigInjected->InjectedRank == ADC_INJECTED_RANK_1)
 8102872:	683b      	ldr	r3, [r7, #0]
 8102874:	685b      	ldr	r3, [r3, #4]
 8102876:	2b09      	cmp	r3, #9
 8102878:	d179      	bne.n	810296e <HAL_ADCEx_InjectedConfigChannel+0x146>
      /* Enable external trigger if trigger selection is different of         */
      /* software start.                                                      */
      /* Note: This configuration keeps the hardware feature of parameter     */
      /*       ExternalTrigInjecConvEdge "trigger edge none" equivalent to    */
      /*       software start.                                                */
      if (sConfigInjected->ExternalTrigInjecConv != ADC_INJECTED_SOFTWARE_START)
 810287a:	683b      	ldr	r3, [r7, #0]
 810287c:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 810287e:	2b00      	cmp	r3, #0
 8102880:	d010      	beq.n	81028a4 <HAL_ADCEx_InjectedConfigChannel+0x7c>
      {
        tmp_JSQR_ContextQueueBeingBuilt = (ADC_JSQR_RK(sConfigInjected->InjectedChannel, ADC_INJECTED_RANK_1)
 8102882:	683b      	ldr	r3, [r7, #0]
 8102884:	681b      	ldr	r3, [r3, #0]
 8102886:	0e9b      	lsrs	r3, r3, #26
 8102888:	025b      	lsls	r3, r3, #9
 810288a:	f403 5278 	and.w	r2, r3, #15872	; 0x3e00
                                           | (sConfigInjected->ExternalTrigInjecConv & ADC_JSQR_JEXTSEL)
 810288e:	683b      	ldr	r3, [r7, #0]
 8102890:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8102892:	f003 037c 	and.w	r3, r3, #124	; 0x7c
 8102896:	431a      	orrs	r2, r3
                                           | sConfigInjected->ExternalTrigInjecConvEdge
 8102898:	683b      	ldr	r3, [r7, #0]
 810289a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
        tmp_JSQR_ContextQueueBeingBuilt = (ADC_JSQR_RK(sConfigInjected->InjectedChannel, ADC_INJECTED_RANK_1)
 810289c:	4313      	orrs	r3, r2
 810289e:	f8c7 30e0 	str.w	r3, [r7, #224]	; 0xe0
 81028a2:	e007      	b.n	81028b4 <HAL_ADCEx_InjectedConfigChannel+0x8c>
                                          );
      }
      else
      {
        tmp_JSQR_ContextQueueBeingBuilt = (ADC_JSQR_RK(sConfigInjected->InjectedChannel, ADC_INJECTED_RANK_1));
 81028a4:	683b      	ldr	r3, [r7, #0]
 81028a6:	681b      	ldr	r3, [r3, #0]
 81028a8:	0e9b      	lsrs	r3, r3, #26
 81028aa:	025b      	lsls	r3, r3, #9
 81028ac:	f403 5378 	and.w	r3, r3, #15872	; 0x3e00
 81028b0:	f8c7 30e0 	str.w	r3, [r7, #224]	; 0xe0
      }

      MODIFY_REG(hadc->Instance->JSQR, ADC_JSQR_FIELDS, tmp_JSQR_ContextQueueBeingBuilt);
 81028b4:	687b      	ldr	r3, [r7, #4]
 81028b6:	681b      	ldr	r3, [r3, #0]
 81028b8:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 81028ba:	4b83      	ldr	r3, [pc, #524]	; (8102ac8 <HAL_ADCEx_InjectedConfigChannel+0x2a0>)
 81028bc:	4013      	ands	r3, r2
 81028be:	687a      	ldr	r2, [r7, #4]
 81028c0:	6812      	ldr	r2, [r2, #0]
 81028c2:	f8d7 10e0 	ldr.w	r1, [r7, #224]	; 0xe0
 81028c6:	430b      	orrs	r3, r1
 81028c8:	64d3      	str	r3, [r2, #76]	; 0x4c
      /* For debug and informative reasons, hadc handle saves JSQR setting */
      hadc->InjectionConfig.ContextQueue = tmp_JSQR_ContextQueueBeingBuilt;
 81028ca:	687b      	ldr	r3, [r7, #4]
 81028cc:	f8d7 20e0 	ldr.w	r2, [r7, #224]	; 0xe0
 81028d0:	65da      	str	r2, [r3, #92]	; 0x5c
    if (sConfigInjected->InjectedRank == ADC_INJECTED_RANK_1)
 81028d2:	e04c      	b.n	810296e <HAL_ADCEx_InjectedConfigChannel+0x146>
    /* 1. Start new context and set parameters related to all injected        */
    /*    channels: injected sequence length and trigger.                     */

    /* if hadc->InjectionConfig.ChannelCount is equal to 0, this is the first */
    /*   call of the context under setting                                    */
    if (hadc->InjectionConfig.ChannelCount == 0U)
 81028d4:	687b      	ldr	r3, [r7, #4]
 81028d6:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 81028d8:	2b00      	cmp	r3, #0
 81028da:	d11d      	bne.n	8102918 <HAL_ADCEx_InjectedConfigChannel+0xf0>
    {
      /* Initialize number of channels that will be configured on the context */
      /*  being built                                                         */
      hadc->InjectionConfig.ChannelCount = sConfigInjected->InjectedNbrOfConversion;
 81028dc:	683b      	ldr	r3, [r7, #0]
 81028de:	6a1a      	ldr	r2, [r3, #32]
 81028e0:	687b      	ldr	r3, [r7, #4]
 81028e2:	661a      	str	r2, [r3, #96]	; 0x60
      /* Handle hadc saves the context under build up over each HAL_ADCEx_InjectedConfigChannel()
         call, this context will be written in JSQR register at the last call.
         At this point, the context is merely reset  */
      hadc->InjectionConfig.ContextQueue = 0x00000000U;
 81028e4:	687b      	ldr	r3, [r7, #4]
 81028e6:	2200      	movs	r2, #0
 81028e8:	65da      	str	r2, [r3, #92]	; 0x5c
      /* Enable external trigger if trigger selection is different of         */
      /* software start.                                                      */
      /* Note: This configuration keeps the hardware feature of parameter     */
      /*       ExternalTrigInjecConvEdge "trigger edge none" equivalent to    */
      /*       software start.                                                */
      if (sConfigInjected->ExternalTrigInjecConv != ADC_INJECTED_SOFTWARE_START)
 81028ea:	683b      	ldr	r3, [r7, #0]
 81028ec:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 81028ee:	2b00      	cmp	r3, #0
 81028f0:	d00d      	beq.n	810290e <HAL_ADCEx_InjectedConfigChannel+0xe6>
      {
        tmp_JSQR_ContextQueueBeingBuilt = ((sConfigInjected->InjectedNbrOfConversion - 1U)
 81028f2:	683b      	ldr	r3, [r7, #0]
 81028f4:	6a1b      	ldr	r3, [r3, #32]
 81028f6:	1e5a      	subs	r2, r3, #1
                                           | (sConfigInjected->ExternalTrigInjecConv & ADC_JSQR_JEXTSEL)
 81028f8:	683b      	ldr	r3, [r7, #0]
 81028fa:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 81028fc:	f003 037c 	and.w	r3, r3, #124	; 0x7c
 8102900:	431a      	orrs	r2, r3
                                           | sConfigInjected->ExternalTrigInjecConvEdge
 8102902:	683b      	ldr	r3, [r7, #0]
 8102904:	6adb      	ldr	r3, [r3, #44]	; 0x2c
        tmp_JSQR_ContextQueueBeingBuilt = ((sConfigInjected->InjectedNbrOfConversion - 1U)
 8102906:	4313      	orrs	r3, r2
 8102908:	f8c7 30e0 	str.w	r3, [r7, #224]	; 0xe0
 810290c:	e004      	b.n	8102918 <HAL_ADCEx_InjectedConfigChannel+0xf0>
                                          );
      }
      else
      {
        tmp_JSQR_ContextQueueBeingBuilt = ((sConfigInjected->InjectedNbrOfConversion - 1U));
 810290e:	683b      	ldr	r3, [r7, #0]
 8102910:	6a1b      	ldr	r3, [r3, #32]
 8102912:	3b01      	subs	r3, #1
 8102914:	f8c7 30e0 	str.w	r3, [r7, #224]	; 0xe0
    /*    related to each channel: channel rank sequence                    */
    /* Clear the old JSQx bits for the selected rank */
    tmp_JSQR_ContextQueueBeingBuilt &= ~ADC_JSQR_RK(ADC_SQR3_SQ10, sConfigInjected->InjectedRank);

    /* Set the JSQx bits for the selected rank */
    tmp_JSQR_ContextQueueBeingBuilt |= ADC_JSQR_RK(sConfigInjected->InjectedChannel, sConfigInjected->InjectedRank);
 8102918:	683b      	ldr	r3, [r7, #0]
 810291a:	681b      	ldr	r3, [r3, #0]
 810291c:	0e9b      	lsrs	r3, r3, #26
 810291e:	f003 021f 	and.w	r2, r3, #31
 8102922:	683b      	ldr	r3, [r7, #0]
 8102924:	685b      	ldr	r3, [r3, #4]
 8102926:	f003 031f 	and.w	r3, r3, #31
 810292a:	fa02 f303 	lsl.w	r3, r2, r3
 810292e:	f8d7 20e0 	ldr.w	r2, [r7, #224]	; 0xe0
 8102932:	4313      	orrs	r3, r2
 8102934:	f8c7 30e0 	str.w	r3, [r7, #224]	; 0xe0

    /* Decrease channel count  */
    hadc->InjectionConfig.ChannelCount--;
 8102938:	687b      	ldr	r3, [r7, #4]
 810293a:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 810293c:	1e5a      	subs	r2, r3, #1
 810293e:	687b      	ldr	r3, [r7, #4]
 8102940:	661a      	str	r2, [r3, #96]	; 0x60

    /* 3. tmp_JSQR_ContextQueueBeingBuilt is fully built for this HAL_ADCEx_InjectedConfigChannel()
          call, aggregate the setting to those already built during the previous
          HAL_ADCEx_InjectedConfigChannel() calls (for the same context of course)  */
    hadc->InjectionConfig.ContextQueue |= tmp_JSQR_ContextQueueBeingBuilt;
 8102942:	687b      	ldr	r3, [r7, #4]
 8102944:	6dda      	ldr	r2, [r3, #92]	; 0x5c
 8102946:	f8d7 30e0 	ldr.w	r3, [r7, #224]	; 0xe0
 810294a:	431a      	orrs	r2, r3
 810294c:	687b      	ldr	r3, [r7, #4]
 810294e:	65da      	str	r2, [r3, #92]	; 0x5c

    /* 4. End of context setting: if this is the last channel set, then write context
        into register JSQR and make it enter into queue                   */
    if (hadc->InjectionConfig.ChannelCount == 0U)
 8102950:	687b      	ldr	r3, [r7, #4]
 8102952:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 8102954:	2b00      	cmp	r3, #0
 8102956:	d10a      	bne.n	810296e <HAL_ADCEx_InjectedConfigChannel+0x146>
    {
      MODIFY_REG(hadc->Instance->JSQR, ADC_JSQR_FIELDS, hadc->InjectionConfig.ContextQueue);
 8102958:	687b      	ldr	r3, [r7, #4]
 810295a:	681b      	ldr	r3, [r3, #0]
 810295c:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 810295e:	4b5a      	ldr	r3, [pc, #360]	; (8102ac8 <HAL_ADCEx_InjectedConfigChannel+0x2a0>)
 8102960:	4013      	ands	r3, r2
 8102962:	687a      	ldr	r2, [r7, #4]
 8102964:	6dd1      	ldr	r1, [r2, #92]	; 0x5c
 8102966:	687a      	ldr	r2, [r7, #4]
 8102968:	6812      	ldr	r2, [r2, #0]
 810296a:	430b      	orrs	r3, r1
 810296c:	64d3      	str	r3, [r2, #76]	; 0x4c
  /* conversion on going on injected group:                                   */
  /*  - Injected context queue: Queue disable (active context is kept) or     */
  /*    enable (context decremented, up to 2 contexts queued)                 */
  /*  - Injected discontinuous mode: can be enabled only if auto-injected     */
  /*    mode is disabled.                                                     */
  if (LL_ADC_INJ_IsConversionOngoing(hadc->Instance) == 0UL)
 810296e:	687b      	ldr	r3, [r7, #4]
 8102970:	681b      	ldr	r3, [r3, #0]
 8102972:	4618      	mov	r0, r3
 8102974:	f7ff ff44 	bl	8102800 <LL_ADC_INJ_IsConversionOngoing>
 8102978:	4603      	mov	r3, r0
 810297a:	2b00      	cmp	r3, #0
 810297c:	d15c      	bne.n	8102a38 <HAL_ADCEx_InjectedConfigChannel+0x210>
  {
    if (!(__LL_ADC_IS_CHANNEL_INTERNAL(sConfigInjected->InjectedChannel)))
 810297e:	683b      	ldr	r3, [r7, #0]
 8102980:	681b      	ldr	r3, [r3, #0]
 8102982:	2b00      	cmp	r3, #0
 8102984:	db33      	blt.n	81029ee <HAL_ADCEx_InjectedConfigChannel+0x1c6>
        /* ADC channels preselection */
        hadc->Instance->PCSEL_RES0 |= (1UL << (__LL_ADC_CHANNEL_TO_DECIMAL_NB(sConfigInjected->InjectedChannel) & 0x1FUL));
      }
#else
      /* ADC channels preselection */
      hadc->Instance->PCSEL |= (1UL << (__LL_ADC_CHANNEL_TO_DECIMAL_NB(sConfigInjected->InjectedChannel) & 0x1FUL));
 8102986:	683b      	ldr	r3, [r7, #0]
 8102988:	681b      	ldr	r3, [r3, #0]
 810298a:	f3c3 0313 	ubfx	r3, r3, #0, #20
 810298e:	2b00      	cmp	r3, #0
 8102990:	d108      	bne.n	81029a4 <HAL_ADCEx_InjectedConfigChannel+0x17c>
 8102992:	683b      	ldr	r3, [r7, #0]
 8102994:	681b      	ldr	r3, [r3, #0]
 8102996:	0e9b      	lsrs	r3, r3, #26
 8102998:	f003 031f 	and.w	r3, r3, #31
 810299c:	2201      	movs	r2, #1
 810299e:	fa02 f303 	lsl.w	r3, r2, r3
 81029a2:	e01d      	b.n	81029e0 <HAL_ADCEx_InjectedConfigChannel+0x1b8>
 81029a4:	683b      	ldr	r3, [r7, #0]
 81029a6:	681b      	ldr	r3, [r3, #0]
 81029a8:	f8c7 30c8 	str.w	r3, [r7, #200]	; 0xc8
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 81029ac:	f8d7 30c8 	ldr.w	r3, [r7, #200]	; 0xc8
 81029b0:	fa93 f3a3 	rbit	r3, r3
 81029b4:	f8c7 30c4 	str.w	r3, [r7, #196]	; 0xc4
  return result;
 81029b8:	f8d7 30c4 	ldr.w	r3, [r7, #196]	; 0xc4
 81029bc:	f8c7 30cc 	str.w	r3, [r7, #204]	; 0xcc
  if (value == 0U)
 81029c0:	f8d7 30cc 	ldr.w	r3, [r7, #204]	; 0xcc
 81029c4:	2b00      	cmp	r3, #0
 81029c6:	d101      	bne.n	81029cc <HAL_ADCEx_InjectedConfigChannel+0x1a4>
    return 32U;
 81029c8:	2320      	movs	r3, #32
 81029ca:	e004      	b.n	81029d6 <HAL_ADCEx_InjectedConfigChannel+0x1ae>
  return __builtin_clz(value);
 81029cc:	f8d7 30cc 	ldr.w	r3, [r7, #204]	; 0xcc
 81029d0:	fab3 f383 	clz	r3, r3
 81029d4:	b2db      	uxtb	r3, r3
 81029d6:	f003 031f 	and.w	r3, r3, #31
 81029da:	2201      	movs	r2, #1
 81029dc:	fa02 f303 	lsl.w	r3, r2, r3
 81029e0:	687a      	ldr	r2, [r7, #4]
 81029e2:	6812      	ldr	r2, [r2, #0]
 81029e4:	69d1      	ldr	r1, [r2, #28]
 81029e6:	687a      	ldr	r2, [r7, #4]
 81029e8:	6812      	ldr	r2, [r2, #0]
 81029ea:	430b      	orrs	r3, r1
 81029ec:	61d3      	str	r3, [r2, #28]
#endif /* ADC_VER_V5_V90 */
    }

    /* If auto-injected mode is disabled: no constraint                       */
    if (sConfigInjected->AutoInjectedConv == DISABLE)
 81029ee:	683b      	ldr	r3, [r7, #0]
 81029f0:	f893 3025 	ldrb.w	r3, [r3, #37]	; 0x25
 81029f4:	2b00      	cmp	r3, #0
 81029f6:	d112      	bne.n	8102a1e <HAL_ADCEx_InjectedConfigChannel+0x1f6>
    {
      MODIFY_REG(hadc->Instance->CFGR,
 81029f8:	687b      	ldr	r3, [r7, #4]
 81029fa:	681b      	ldr	r3, [r3, #0]
 81029fc:	68db      	ldr	r3, [r3, #12]
 81029fe:	f423 1140 	bic.w	r1, r3, #3145728	; 0x300000
 8102a02:	683b      	ldr	r3, [r7, #0]
 8102a04:	f893 3026 	ldrb.w	r3, [r3, #38]	; 0x26
 8102a08:	055a      	lsls	r2, r3, #21
 8102a0a:	683b      	ldr	r3, [r7, #0]
 8102a0c:	f893 3024 	ldrb.w	r3, [r3, #36]	; 0x24
 8102a10:	051b      	lsls	r3, r3, #20
 8102a12:	431a      	orrs	r2, r3
 8102a14:	687b      	ldr	r3, [r7, #4]
 8102a16:	681b      	ldr	r3, [r3, #0]
 8102a18:	430a      	orrs	r2, r1
 8102a1a:	60da      	str	r2, [r3, #12]
 8102a1c:	e00c      	b.n	8102a38 <HAL_ADCEx_InjectedConfigChannel+0x210>
    }
    /* If auto-injected mode is enabled: Injected discontinuous setting is    */
    /* discarded.                                                             */
    else
    {
      MODIFY_REG(hadc->Instance->CFGR,
 8102a1e:	687b      	ldr	r3, [r7, #4]
 8102a20:	681b      	ldr	r3, [r3, #0]
 8102a22:	68db      	ldr	r3, [r3, #12]
 8102a24:	f423 1140 	bic.w	r1, r3, #3145728	; 0x300000
 8102a28:	683b      	ldr	r3, [r7, #0]
 8102a2a:	f893 3026 	ldrb.w	r3, [r3, #38]	; 0x26
 8102a2e:	055a      	lsls	r2, r3, #21
 8102a30:	687b      	ldr	r3, [r7, #4]
 8102a32:	681b      	ldr	r3, [r3, #0]
 8102a34:	430a      	orrs	r2, r1
 8102a36:	60da      	str	r2, [r3, #12]
  /* conversion on going on regular and injected groups:                      */
  /*  - Automatic injected conversion: can be enabled if injected group       */
  /*    external triggers are disabled.                                       */
  /*  - Channel sampling time                                                 */
  /*  - Channel offset                                                        */
  tmp_adc_is_conversion_on_going_regular = LL_ADC_REG_IsConversionOngoing(hadc->Instance);
 8102a38:	687b      	ldr	r3, [r7, #4]
 8102a3a:	681b      	ldr	r3, [r3, #0]
 8102a3c:	4618      	mov	r0, r3
 8102a3e:	f7ff fecc 	bl	81027da <LL_ADC_REG_IsConversionOngoing>
 8102a42:	f8c7 00dc 	str.w	r0, [r7, #220]	; 0xdc
  tmp_adc_is_conversion_on_going_injected = LL_ADC_INJ_IsConversionOngoing(hadc->Instance);
 8102a46:	687b      	ldr	r3, [r7, #4]
 8102a48:	681b      	ldr	r3, [r3, #0]
 8102a4a:	4618      	mov	r0, r3
 8102a4c:	f7ff fed8 	bl	8102800 <LL_ADC_INJ_IsConversionOngoing>
 8102a50:	f8c7 00d8 	str.w	r0, [r7, #216]	; 0xd8

  if ((tmp_adc_is_conversion_on_going_regular == 0UL)
 8102a54:	f8d7 30dc 	ldr.w	r3, [r7, #220]	; 0xdc
 8102a58:	2b00      	cmp	r3, #0
 8102a5a:	f040 823e 	bne.w	8102eda <HAL_ADCEx_InjectedConfigChannel+0x6b2>
      && (tmp_adc_is_conversion_on_going_injected == 0UL)
 8102a5e:	f8d7 30d8 	ldr.w	r3, [r7, #216]	; 0xd8
 8102a62:	2b00      	cmp	r3, #0
 8102a64:	f040 8239 	bne.w	8102eda <HAL_ADCEx_InjectedConfigChannel+0x6b2>
     )
  {
    /* If injected group external triggers are disabled (set to injected      */
    /* software start): no constraint                                         */
    if ((sConfigInjected->ExternalTrigInjecConv == ADC_INJECTED_SOFTWARE_START)
 8102a68:	683b      	ldr	r3, [r7, #0]
 8102a6a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8102a6c:	2b00      	cmp	r3, #0
 8102a6e:	d003      	beq.n	8102a78 <HAL_ADCEx_InjectedConfigChannel+0x250>
        || (sConfigInjected->ExternalTrigInjecConvEdge == ADC_EXTERNALTRIGINJECCONV_EDGE_NONE))
 8102a70:	683b      	ldr	r3, [r7, #0]
 8102a72:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8102a74:	2b00      	cmp	r3, #0
 8102a76:	d116      	bne.n	8102aa6 <HAL_ADCEx_InjectedConfigChannel+0x27e>
    {
      if (sConfigInjected->AutoInjectedConv == ENABLE)
 8102a78:	683b      	ldr	r3, [r7, #0]
 8102a7a:	f893 3025 	ldrb.w	r3, [r3, #37]	; 0x25
 8102a7e:	2b01      	cmp	r3, #1
 8102a80:	d108      	bne.n	8102a94 <HAL_ADCEx_InjectedConfigChannel+0x26c>
      {
        SET_BIT(hadc->Instance->CFGR, ADC_CFGR_JAUTO);
 8102a82:	687b      	ldr	r3, [r7, #4]
 8102a84:	681b      	ldr	r3, [r3, #0]
 8102a86:	68da      	ldr	r2, [r3, #12]
 8102a88:	687b      	ldr	r3, [r7, #4]
 8102a8a:	681b      	ldr	r3, [r3, #0]
 8102a8c:	f042 7200 	orr.w	r2, r2, #33554432	; 0x2000000
 8102a90:	60da      	str	r2, [r3, #12]
      if (sConfigInjected->AutoInjectedConv == ENABLE)
 8102a92:	e023      	b.n	8102adc <HAL_ADCEx_InjectedConfigChannel+0x2b4>
      }
      else
      {
        CLEAR_BIT(hadc->Instance->CFGR, ADC_CFGR_JAUTO);
 8102a94:	687b      	ldr	r3, [r7, #4]
 8102a96:	681b      	ldr	r3, [r3, #0]
 8102a98:	68da      	ldr	r2, [r3, #12]
 8102a9a:	687b      	ldr	r3, [r7, #4]
 8102a9c:	681b      	ldr	r3, [r3, #0]
 8102a9e:	f022 7200 	bic.w	r2, r2, #33554432	; 0x2000000
 8102aa2:	60da      	str	r2, [r3, #12]
      if (sConfigInjected->AutoInjectedConv == ENABLE)
 8102aa4:	e01a      	b.n	8102adc <HAL_ADCEx_InjectedConfigChannel+0x2b4>
    }
    /* If Automatic injected conversion was intended to be set and could not  */
    /* due to injected group external triggers enabled, error is reported.    */
    else
    {
      if (sConfigInjected->AutoInjectedConv == ENABLE)
 8102aa6:	683b      	ldr	r3, [r7, #0]
 8102aa8:	f893 3025 	ldrb.w	r3, [r3, #37]	; 0x25
 8102aac:	2b01      	cmp	r3, #1
 8102aae:	d10d      	bne.n	8102acc <HAL_ADCEx_InjectedConfigChannel+0x2a4>
      {
        /* Update ADC state machine to error */
        SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
 8102ab0:	687b      	ldr	r3, [r7, #4]
 8102ab2:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8102ab4:	f043 0220 	orr.w	r2, r3, #32
 8102ab8:	687b      	ldr	r3, [r7, #4]
 8102aba:	655a      	str	r2, [r3, #84]	; 0x54

        tmp_hal_status = HAL_ERROR;
 8102abc:	2301      	movs	r3, #1
 8102abe:	f887 30e7 	strb.w	r3, [r7, #231]	; 0xe7
 8102ac2:	e00b      	b.n	8102adc <HAL_ADCEx_InjectedConfigChannel+0x2b4>
 8102ac4:	47ff0000 	.word	0x47ff0000
 8102ac8:	04104000 	.word	0x04104000
      }
      else
      {
        CLEAR_BIT(hadc->Instance->CFGR, ADC_CFGR_JAUTO);
 8102acc:	687b      	ldr	r3, [r7, #4]
 8102ace:	681b      	ldr	r3, [r3, #0]
 8102ad0:	68da      	ldr	r2, [r3, #12]
 8102ad2:	687b      	ldr	r3, [r7, #4]
 8102ad4:	681b      	ldr	r3, [r3, #0]
 8102ad6:	f022 7200 	bic.w	r2, r2, #33554432	; 0x2000000
 8102ada:	60da      	str	r2, [r3, #12]
      }
    }

    if (sConfigInjected->InjecOversamplingMode == ENABLE)
 8102adc:	683b      	ldr	r3, [r7, #0]
 8102ade:	f893 3030 	ldrb.w	r3, [r3, #48]	; 0x30
 8102ae2:	2b01      	cmp	r3, #1
 8102ae4:	d112      	bne.n	8102b0c <HAL_ADCEx_InjectedConfigChannel+0x2e4>
                  (sConfigInjected->InjecOversampling.Ratio)        |
                   sConfigInjected->InjecOversampling.RightBitShift
                  );
      }
#else
      MODIFY_REG(hadc->Instance->CFGR2,
 8102ae6:	687b      	ldr	r3, [r7, #4]
 8102ae8:	681b      	ldr	r3, [r3, #0]
 8102aea:	691a      	ldr	r2, [r3, #16]
 8102aec:	4bb4      	ldr	r3, [pc, #720]	; (8102dc0 <HAL_ADCEx_InjectedConfigChannel+0x598>)
 8102aee:	4013      	ands	r3, r2
 8102af0:	683a      	ldr	r2, [r7, #0]
 8102af2:	6b52      	ldr	r2, [r2, #52]	; 0x34
 8102af4:	3a01      	subs	r2, #1
 8102af6:	0411      	lsls	r1, r2, #16
 8102af8:	683a      	ldr	r2, [r7, #0]
 8102afa:	6b92      	ldr	r2, [r2, #56]	; 0x38
 8102afc:	430a      	orrs	r2, r1
 8102afe:	431a      	orrs	r2, r3
 8102b00:	687b      	ldr	r3, [r7, #4]
 8102b02:	681b      	ldr	r3, [r3, #0]
 8102b04:	f042 0202 	orr.w	r2, r2, #2
 8102b08:	611a      	str	r2, [r3, #16]
 8102b0a:	e007      	b.n	8102b1c <HAL_ADCEx_InjectedConfigChannel+0x2f4>
#endif
    }
    else
    {
      /* Disable Regular OverSampling */
      CLEAR_BIT(hadc->Instance->CFGR2, ADC_CFGR2_JOVSE);
 8102b0c:	687b      	ldr	r3, [r7, #4]
 8102b0e:	681b      	ldr	r3, [r3, #0]
 8102b10:	691a      	ldr	r2, [r3, #16]
 8102b12:	687b      	ldr	r3, [r7, #4]
 8102b14:	681b      	ldr	r3, [r3, #0]
 8102b16:	f022 0202 	bic.w	r2, r2, #2
 8102b1a:	611a      	str	r2, [r3, #16]
    }

    /* Set sampling time of the selected ADC channel */
    LL_ADC_SetChannelSamplingTime(hadc->Instance, sConfigInjected->InjectedChannel, sConfigInjected->InjectedSamplingTime);
 8102b1c:	687b      	ldr	r3, [r7, #4]
 8102b1e:	6818      	ldr	r0, [r3, #0]
 8102b20:	683b      	ldr	r3, [r7, #0]
 8102b22:	6819      	ldr	r1, [r3, #0]
 8102b24:	683b      	ldr	r3, [r7, #0]
 8102b26:	689b      	ldr	r3, [r3, #8]
 8102b28:	461a      	mov	r2, r3
 8102b2a:	f7ff fdf4 	bl	8102716 <LL_ADC_SetChannelSamplingTime>
      tmpOffsetShifted = ADC3_OFFSET_SHIFT_RESOLUTION(hadc, sConfigInjected->InjectedOffset);
    }
    else
#endif /* ADC_VER_V5_V90 */
    {
      tmpOffsetShifted = ADC_OFFSET_SHIFT_RESOLUTION(hadc, sConfigInjected->InjectedOffset);
 8102b2e:	4ba5      	ldr	r3, [pc, #660]	; (8102dc4 <HAL_ADCEx_InjectedConfigChannel+0x59c>)
 8102b30:	681b      	ldr	r3, [r3, #0]
 8102b32:	f003 4370 	and.w	r3, r3, #4026531840	; 0xf0000000
 8102b36:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
 8102b3a:	d10b      	bne.n	8102b54 <HAL_ADCEx_InjectedConfigChannel+0x32c>
 8102b3c:	683b      	ldr	r3, [r7, #0]
 8102b3e:	695a      	ldr	r2, [r3, #20]
 8102b40:	687b      	ldr	r3, [r7, #4]
 8102b42:	681b      	ldr	r3, [r3, #0]
 8102b44:	68db      	ldr	r3, [r3, #12]
 8102b46:	089b      	lsrs	r3, r3, #2
 8102b48:	f003 0307 	and.w	r3, r3, #7
 8102b4c:	005b      	lsls	r3, r3, #1
 8102b4e:	fa02 f303 	lsl.w	r3, r2, r3
 8102b52:	e01d      	b.n	8102b90 <HAL_ADCEx_InjectedConfigChannel+0x368>
 8102b54:	687b      	ldr	r3, [r7, #4]
 8102b56:	681b      	ldr	r3, [r3, #0]
 8102b58:	68db      	ldr	r3, [r3, #12]
 8102b5a:	f003 0310 	and.w	r3, r3, #16
 8102b5e:	2b00      	cmp	r3, #0
 8102b60:	d10b      	bne.n	8102b7a <HAL_ADCEx_InjectedConfigChannel+0x352>
 8102b62:	683b      	ldr	r3, [r7, #0]
 8102b64:	695a      	ldr	r2, [r3, #20]
 8102b66:	687b      	ldr	r3, [r7, #4]
 8102b68:	681b      	ldr	r3, [r3, #0]
 8102b6a:	68db      	ldr	r3, [r3, #12]
 8102b6c:	089b      	lsrs	r3, r3, #2
 8102b6e:	f003 0307 	and.w	r3, r3, #7
 8102b72:	005b      	lsls	r3, r3, #1
 8102b74:	fa02 f303 	lsl.w	r3, r2, r3
 8102b78:	e00a      	b.n	8102b90 <HAL_ADCEx_InjectedConfigChannel+0x368>
 8102b7a:	683b      	ldr	r3, [r7, #0]
 8102b7c:	695a      	ldr	r2, [r3, #20]
 8102b7e:	687b      	ldr	r3, [r7, #4]
 8102b80:	681b      	ldr	r3, [r3, #0]
 8102b82:	68db      	ldr	r3, [r3, #12]
 8102b84:	089b      	lsrs	r3, r3, #2
 8102b86:	f003 0304 	and.w	r3, r3, #4
 8102b8a:	005b      	lsls	r3, r3, #1
 8102b8c:	fa02 f303 	lsl.w	r3, r2, r3
 8102b90:	f8c7 30d4 	str.w	r3, [r7, #212]	; 0xd4
    }

    if (sConfigInjected->InjectedOffsetNumber != ADC_OFFSET_NONE)
 8102b94:	683b      	ldr	r3, [r7, #0]
 8102b96:	691b      	ldr	r3, [r3, #16]
 8102b98:	2b04      	cmp	r3, #4
 8102b9a:	d019      	beq.n	8102bd0 <HAL_ADCEx_InjectedConfigChannel+0x3a8>
    {
      /* Set ADC selected offset number */
      LL_ADC_SetOffset(hadc->Instance, sConfigInjected->InjectedOffsetNumber, sConfigInjected->InjectedChannel, tmpOffsetShifted);
 8102b9c:	687b      	ldr	r3, [r7, #4]
 8102b9e:	6818      	ldr	r0, [r3, #0]
 8102ba0:	683b      	ldr	r3, [r7, #0]
 8102ba2:	6919      	ldr	r1, [r3, #16]
 8102ba4:	683b      	ldr	r3, [r7, #0]
 8102ba6:	681a      	ldr	r2, [r3, #0]
 8102ba8:	f8d7 30d4 	ldr.w	r3, [r7, #212]	; 0xd4
 8102bac:	f7ff fd4d 	bl	810264a <LL_ADC_SetOffset>
      }
      else
#endif /* ADC_VER_V5_V90 */
      {
        /* Set ADC selected offset signed saturation */
        LL_ADC_SetOffsetSignedSaturation(hadc->Instance, sConfigInjected->InjectedOffsetNumber, (sConfigInjected->InjectedOffsetSignedSaturation == ENABLE) ? LL_ADC_OFFSET_SIGNED_SATURATION_ENABLE : LL_ADC_OFFSET_SIGNED_SATURATION_DISABLE);
 8102bb0:	687b      	ldr	r3, [r7, #4]
 8102bb2:	6818      	ldr	r0, [r3, #0]
 8102bb4:	683b      	ldr	r3, [r7, #0]
 8102bb6:	6919      	ldr	r1, [r3, #16]
 8102bb8:	683b      	ldr	r3, [r7, #0]
 8102bba:	7f1b      	ldrb	r3, [r3, #28]
 8102bbc:	2b01      	cmp	r3, #1
 8102bbe:	d102      	bne.n	8102bc6 <HAL_ADCEx_InjectedConfigChannel+0x39e>
 8102bc0:	f04f 4300 	mov.w	r3, #2147483648	; 0x80000000
 8102bc4:	e000      	b.n	8102bc8 <HAL_ADCEx_InjectedConfigChannel+0x3a0>
 8102bc6:	2300      	movs	r3, #0
 8102bc8:	461a      	mov	r2, r3
 8102bca:	f7ff fd74 	bl	81026b6 <LL_ADC_SetOffsetSignedSaturation>
 8102bce:	e184      	b.n	8102eda <HAL_ADCEx_InjectedConfigChannel+0x6b2>
      else
#endif /* ADC_VER_V5_V90 */
      {
        /* Scan each offset register to check if the selected channel is targeted. */
        /* If this is the case, the corresponding offset number is disabled.       */
        if (__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_1)) == __LL_ADC_CHANNEL_TO_DECIMAL_NB(sConfigInjected->InjectedChannel))
 8102bd0:	687b      	ldr	r3, [r7, #4]
 8102bd2:	681b      	ldr	r3, [r3, #0]
 8102bd4:	2100      	movs	r1, #0
 8102bd6:	4618      	mov	r0, r3
 8102bd8:	f7ff fd57 	bl	810268a <LL_ADC_GetOffsetChannel>
 8102bdc:	4603      	mov	r3, r0
 8102bde:	f3c3 0313 	ubfx	r3, r3, #0, #20
 8102be2:	2b00      	cmp	r3, #0
 8102be4:	d10a      	bne.n	8102bfc <HAL_ADCEx_InjectedConfigChannel+0x3d4>
 8102be6:	687b      	ldr	r3, [r7, #4]
 8102be8:	681b      	ldr	r3, [r3, #0]
 8102bea:	2100      	movs	r1, #0
 8102bec:	4618      	mov	r0, r3
 8102bee:	f7ff fd4c 	bl	810268a <LL_ADC_GetOffsetChannel>
 8102bf2:	4603      	mov	r3, r0
 8102bf4:	0e9b      	lsrs	r3, r3, #26
 8102bf6:	f003 021f 	and.w	r2, r3, #31
 8102bfa:	e01e      	b.n	8102c3a <HAL_ADCEx_InjectedConfigChannel+0x412>
 8102bfc:	687b      	ldr	r3, [r7, #4]
 8102bfe:	681b      	ldr	r3, [r3, #0]
 8102c00:	2100      	movs	r1, #0
 8102c02:	4618      	mov	r0, r3
 8102c04:	f7ff fd41 	bl	810268a <LL_ADC_GetOffsetChannel>
 8102c08:	4603      	mov	r3, r0
 8102c0a:	f8c7 30bc 	str.w	r3, [r7, #188]	; 0xbc
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8102c0e:	f8d7 30bc 	ldr.w	r3, [r7, #188]	; 0xbc
 8102c12:	fa93 f3a3 	rbit	r3, r3
 8102c16:	f8c7 30b8 	str.w	r3, [r7, #184]	; 0xb8
  return result;
 8102c1a:	f8d7 30b8 	ldr.w	r3, [r7, #184]	; 0xb8
 8102c1e:	f8c7 30c0 	str.w	r3, [r7, #192]	; 0xc0
  if (value == 0U)
 8102c22:	f8d7 30c0 	ldr.w	r3, [r7, #192]	; 0xc0
 8102c26:	2b00      	cmp	r3, #0
 8102c28:	d101      	bne.n	8102c2e <HAL_ADCEx_InjectedConfigChannel+0x406>
    return 32U;
 8102c2a:	2320      	movs	r3, #32
 8102c2c:	e004      	b.n	8102c38 <HAL_ADCEx_InjectedConfigChannel+0x410>
  return __builtin_clz(value);
 8102c2e:	f8d7 30c0 	ldr.w	r3, [r7, #192]	; 0xc0
 8102c32:	fab3 f383 	clz	r3, r3
 8102c36:	b2db      	uxtb	r3, r3
 8102c38:	461a      	mov	r2, r3
 8102c3a:	683b      	ldr	r3, [r7, #0]
 8102c3c:	681b      	ldr	r3, [r3, #0]
 8102c3e:	f3c3 0313 	ubfx	r3, r3, #0, #20
 8102c42:	2b00      	cmp	r3, #0
 8102c44:	d105      	bne.n	8102c52 <HAL_ADCEx_InjectedConfigChannel+0x42a>
 8102c46:	683b      	ldr	r3, [r7, #0]
 8102c48:	681b      	ldr	r3, [r3, #0]
 8102c4a:	0e9b      	lsrs	r3, r3, #26
 8102c4c:	f003 031f 	and.w	r3, r3, #31
 8102c50:	e018      	b.n	8102c84 <HAL_ADCEx_InjectedConfigChannel+0x45c>
 8102c52:	683b      	ldr	r3, [r7, #0]
 8102c54:	681b      	ldr	r3, [r3, #0]
 8102c56:	f8c7 30b0 	str.w	r3, [r7, #176]	; 0xb0
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8102c5a:	f8d7 30b0 	ldr.w	r3, [r7, #176]	; 0xb0
 8102c5e:	fa93 f3a3 	rbit	r3, r3
 8102c62:	f8c7 30ac 	str.w	r3, [r7, #172]	; 0xac
  return result;
 8102c66:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 8102c6a:	f8c7 30b4 	str.w	r3, [r7, #180]	; 0xb4
  if (value == 0U)
 8102c6e:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 8102c72:	2b00      	cmp	r3, #0
 8102c74:	d101      	bne.n	8102c7a <HAL_ADCEx_InjectedConfigChannel+0x452>
    return 32U;
 8102c76:	2320      	movs	r3, #32
 8102c78:	e004      	b.n	8102c84 <HAL_ADCEx_InjectedConfigChannel+0x45c>
  return __builtin_clz(value);
 8102c7a:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 8102c7e:	fab3 f383 	clz	r3, r3
 8102c82:	b2db      	uxtb	r3, r3
 8102c84:	429a      	cmp	r2, r3
 8102c86:	d107      	bne.n	8102c98 <HAL_ADCEx_InjectedConfigChannel+0x470>
        {
          LL_ADC_SetOffset(hadc->Instance, LL_ADC_OFFSET_1, sConfigInjected->InjectedChannel, LL_ADC_OFFSET_SIGNED_SATURATION_DISABLE);
 8102c88:	687b      	ldr	r3, [r7, #4]
 8102c8a:	6818      	ldr	r0, [r3, #0]
 8102c8c:	683b      	ldr	r3, [r7, #0]
 8102c8e:	681a      	ldr	r2, [r3, #0]
 8102c90:	2300      	movs	r3, #0
 8102c92:	2100      	movs	r1, #0
 8102c94:	f7ff fcd9 	bl	810264a <LL_ADC_SetOffset>
        }
        if (__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_2)) == __LL_ADC_CHANNEL_TO_DECIMAL_NB(sConfigInjected->InjectedChannel))
 8102c98:	687b      	ldr	r3, [r7, #4]
 8102c9a:	681b      	ldr	r3, [r3, #0]
 8102c9c:	2101      	movs	r1, #1
 8102c9e:	4618      	mov	r0, r3
 8102ca0:	f7ff fcf3 	bl	810268a <LL_ADC_GetOffsetChannel>
 8102ca4:	4603      	mov	r3, r0
 8102ca6:	f3c3 0313 	ubfx	r3, r3, #0, #20
 8102caa:	2b00      	cmp	r3, #0
 8102cac:	d10a      	bne.n	8102cc4 <HAL_ADCEx_InjectedConfigChannel+0x49c>
 8102cae:	687b      	ldr	r3, [r7, #4]
 8102cb0:	681b      	ldr	r3, [r3, #0]
 8102cb2:	2101      	movs	r1, #1
 8102cb4:	4618      	mov	r0, r3
 8102cb6:	f7ff fce8 	bl	810268a <LL_ADC_GetOffsetChannel>
 8102cba:	4603      	mov	r3, r0
 8102cbc:	0e9b      	lsrs	r3, r3, #26
 8102cbe:	f003 021f 	and.w	r2, r3, #31
 8102cc2:	e01e      	b.n	8102d02 <HAL_ADCEx_InjectedConfigChannel+0x4da>
 8102cc4:	687b      	ldr	r3, [r7, #4]
 8102cc6:	681b      	ldr	r3, [r3, #0]
 8102cc8:	2101      	movs	r1, #1
 8102cca:	4618      	mov	r0, r3
 8102ccc:	f7ff fcdd 	bl	810268a <LL_ADC_GetOffsetChannel>
 8102cd0:	4603      	mov	r3, r0
 8102cd2:	f8c7 30a4 	str.w	r3, [r7, #164]	; 0xa4
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8102cd6:	f8d7 30a4 	ldr.w	r3, [r7, #164]	; 0xa4
 8102cda:	fa93 f3a3 	rbit	r3, r3
 8102cde:	f8c7 30a0 	str.w	r3, [r7, #160]	; 0xa0
  return result;
 8102ce2:	f8d7 30a0 	ldr.w	r3, [r7, #160]	; 0xa0
 8102ce6:	f8c7 30a8 	str.w	r3, [r7, #168]	; 0xa8
  if (value == 0U)
 8102cea:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
 8102cee:	2b00      	cmp	r3, #0
 8102cf0:	d101      	bne.n	8102cf6 <HAL_ADCEx_InjectedConfigChannel+0x4ce>
    return 32U;
 8102cf2:	2320      	movs	r3, #32
 8102cf4:	e004      	b.n	8102d00 <HAL_ADCEx_InjectedConfigChannel+0x4d8>
  return __builtin_clz(value);
 8102cf6:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
 8102cfa:	fab3 f383 	clz	r3, r3
 8102cfe:	b2db      	uxtb	r3, r3
 8102d00:	461a      	mov	r2, r3
 8102d02:	683b      	ldr	r3, [r7, #0]
 8102d04:	681b      	ldr	r3, [r3, #0]
 8102d06:	f3c3 0313 	ubfx	r3, r3, #0, #20
 8102d0a:	2b00      	cmp	r3, #0
 8102d0c:	d105      	bne.n	8102d1a <HAL_ADCEx_InjectedConfigChannel+0x4f2>
 8102d0e:	683b      	ldr	r3, [r7, #0]
 8102d10:	681b      	ldr	r3, [r3, #0]
 8102d12:	0e9b      	lsrs	r3, r3, #26
 8102d14:	f003 031f 	and.w	r3, r3, #31
 8102d18:	e018      	b.n	8102d4c <HAL_ADCEx_InjectedConfigChannel+0x524>
 8102d1a:	683b      	ldr	r3, [r7, #0]
 8102d1c:	681b      	ldr	r3, [r3, #0]
 8102d1e:	f8c7 3098 	str.w	r3, [r7, #152]	; 0x98
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8102d22:	f8d7 3098 	ldr.w	r3, [r7, #152]	; 0x98
 8102d26:	fa93 f3a3 	rbit	r3, r3
 8102d2a:	f8c7 3094 	str.w	r3, [r7, #148]	; 0x94
  return result;
 8102d2e:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
 8102d32:	f8c7 309c 	str.w	r3, [r7, #156]	; 0x9c
  if (value == 0U)
 8102d36:	f8d7 309c 	ldr.w	r3, [r7, #156]	; 0x9c
 8102d3a:	2b00      	cmp	r3, #0
 8102d3c:	d101      	bne.n	8102d42 <HAL_ADCEx_InjectedConfigChannel+0x51a>
    return 32U;
 8102d3e:	2320      	movs	r3, #32
 8102d40:	e004      	b.n	8102d4c <HAL_ADCEx_InjectedConfigChannel+0x524>
  return __builtin_clz(value);
 8102d42:	f8d7 309c 	ldr.w	r3, [r7, #156]	; 0x9c
 8102d46:	fab3 f383 	clz	r3, r3
 8102d4a:	b2db      	uxtb	r3, r3
 8102d4c:	429a      	cmp	r2, r3
 8102d4e:	d107      	bne.n	8102d60 <HAL_ADCEx_InjectedConfigChannel+0x538>
        {
          LL_ADC_SetOffset(hadc->Instance, LL_ADC_OFFSET_2, sConfigInjected->InjectedChannel, LL_ADC_OFFSET_SIGNED_SATURATION_DISABLE);
 8102d50:	687b      	ldr	r3, [r7, #4]
 8102d52:	6818      	ldr	r0, [r3, #0]
 8102d54:	683b      	ldr	r3, [r7, #0]
 8102d56:	681a      	ldr	r2, [r3, #0]
 8102d58:	2300      	movs	r3, #0
 8102d5a:	2101      	movs	r1, #1
 8102d5c:	f7ff fc75 	bl	810264a <LL_ADC_SetOffset>
        }
        if (__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_3)) == __LL_ADC_CHANNEL_TO_DECIMAL_NB(sConfigInjected->InjectedChannel))
 8102d60:	687b      	ldr	r3, [r7, #4]
 8102d62:	681b      	ldr	r3, [r3, #0]
 8102d64:	2102      	movs	r1, #2
 8102d66:	4618      	mov	r0, r3
 8102d68:	f7ff fc8f 	bl	810268a <LL_ADC_GetOffsetChannel>
 8102d6c:	4603      	mov	r3, r0
 8102d6e:	f3c3 0313 	ubfx	r3, r3, #0, #20
 8102d72:	2b00      	cmp	r3, #0
 8102d74:	d10a      	bne.n	8102d8c <HAL_ADCEx_InjectedConfigChannel+0x564>
 8102d76:	687b      	ldr	r3, [r7, #4]
 8102d78:	681b      	ldr	r3, [r3, #0]
 8102d7a:	2102      	movs	r1, #2
 8102d7c:	4618      	mov	r0, r3
 8102d7e:	f7ff fc84 	bl	810268a <LL_ADC_GetOffsetChannel>
 8102d82:	4603      	mov	r3, r0
 8102d84:	0e9b      	lsrs	r3, r3, #26
 8102d86:	f003 021f 	and.w	r2, r3, #31
 8102d8a:	e023      	b.n	8102dd4 <HAL_ADCEx_InjectedConfigChannel+0x5ac>
 8102d8c:	687b      	ldr	r3, [r7, #4]
 8102d8e:	681b      	ldr	r3, [r3, #0]
 8102d90:	2102      	movs	r1, #2
 8102d92:	4618      	mov	r0, r3
 8102d94:	f7ff fc79 	bl	810268a <LL_ADC_GetOffsetChannel>
 8102d98:	4603      	mov	r3, r0
 8102d9a:	f8c7 308c 	str.w	r3, [r7, #140]	; 0x8c
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8102d9e:	f8d7 308c 	ldr.w	r3, [r7, #140]	; 0x8c
 8102da2:	fa93 f3a3 	rbit	r3, r3
 8102da6:	f8c7 3088 	str.w	r3, [r7, #136]	; 0x88
  return result;
 8102daa:	f8d7 3088 	ldr.w	r3, [r7, #136]	; 0x88
 8102dae:	f8c7 3090 	str.w	r3, [r7, #144]	; 0x90
  if (value == 0U)
 8102db2:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 8102db6:	2b00      	cmp	r3, #0
 8102db8:	d106      	bne.n	8102dc8 <HAL_ADCEx_InjectedConfigChannel+0x5a0>
    return 32U;
 8102dba:	2320      	movs	r3, #32
 8102dbc:	e009      	b.n	8102dd2 <HAL_ADCEx_InjectedConfigChannel+0x5aa>
 8102dbe:	bf00      	nop
 8102dc0:	fc00fe1d 	.word	0xfc00fe1d
 8102dc4:	5c001000 	.word	0x5c001000
  return __builtin_clz(value);
 8102dc8:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 8102dcc:	fab3 f383 	clz	r3, r3
 8102dd0:	b2db      	uxtb	r3, r3
 8102dd2:	461a      	mov	r2, r3
 8102dd4:	683b      	ldr	r3, [r7, #0]
 8102dd6:	681b      	ldr	r3, [r3, #0]
 8102dd8:	f3c3 0313 	ubfx	r3, r3, #0, #20
 8102ddc:	2b00      	cmp	r3, #0
 8102dde:	d105      	bne.n	8102dec <HAL_ADCEx_InjectedConfigChannel+0x5c4>
 8102de0:	683b      	ldr	r3, [r7, #0]
 8102de2:	681b      	ldr	r3, [r3, #0]
 8102de4:	0e9b      	lsrs	r3, r3, #26
 8102de6:	f003 031f 	and.w	r3, r3, #31
 8102dea:	e016      	b.n	8102e1a <HAL_ADCEx_InjectedConfigChannel+0x5f2>
 8102dec:	683b      	ldr	r3, [r7, #0]
 8102dee:	681b      	ldr	r3, [r3, #0]
 8102df0:	f8c7 3080 	str.w	r3, [r7, #128]	; 0x80
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8102df4:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
 8102df8:	fa93 f3a3 	rbit	r3, r3
 8102dfc:	67fb      	str	r3, [r7, #124]	; 0x7c
  return result;
 8102dfe:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 8102e00:	f8c7 3084 	str.w	r3, [r7, #132]	; 0x84
  if (value == 0U)
 8102e04:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 8102e08:	2b00      	cmp	r3, #0
 8102e0a:	d101      	bne.n	8102e10 <HAL_ADCEx_InjectedConfigChannel+0x5e8>
    return 32U;
 8102e0c:	2320      	movs	r3, #32
 8102e0e:	e004      	b.n	8102e1a <HAL_ADCEx_InjectedConfigChannel+0x5f2>
  return __builtin_clz(value);
 8102e10:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 8102e14:	fab3 f383 	clz	r3, r3
 8102e18:	b2db      	uxtb	r3, r3
 8102e1a:	429a      	cmp	r2, r3
 8102e1c:	d107      	bne.n	8102e2e <HAL_ADCEx_InjectedConfigChannel+0x606>
        {
          LL_ADC_SetOffset(hadc->Instance, LL_ADC_OFFSET_4, sConfigInjected->InjectedChannel, LL_ADC_OFFSET_SIGNED_SATURATION_DISABLE);
 8102e1e:	687b      	ldr	r3, [r7, #4]
 8102e20:	6818      	ldr	r0, [r3, #0]
 8102e22:	683b      	ldr	r3, [r7, #0]
 8102e24:	681a      	ldr	r2, [r3, #0]
 8102e26:	2300      	movs	r3, #0
 8102e28:	2103      	movs	r1, #3
 8102e2a:	f7ff fc0e 	bl	810264a <LL_ADC_SetOffset>
        }
        if (__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_4)) == __LL_ADC_CHANNEL_TO_DECIMAL_NB(sConfigInjected->InjectedChannel))
 8102e2e:	687b      	ldr	r3, [r7, #4]
 8102e30:	681b      	ldr	r3, [r3, #0]
 8102e32:	2103      	movs	r1, #3
 8102e34:	4618      	mov	r0, r3
 8102e36:	f7ff fc28 	bl	810268a <LL_ADC_GetOffsetChannel>
 8102e3a:	4603      	mov	r3, r0
 8102e3c:	f3c3 0313 	ubfx	r3, r3, #0, #20
 8102e40:	2b00      	cmp	r3, #0
 8102e42:	d10a      	bne.n	8102e5a <HAL_ADCEx_InjectedConfigChannel+0x632>
 8102e44:	687b      	ldr	r3, [r7, #4]
 8102e46:	681b      	ldr	r3, [r3, #0]
 8102e48:	2103      	movs	r1, #3
 8102e4a:	4618      	mov	r0, r3
 8102e4c:	f7ff fc1d 	bl	810268a <LL_ADC_GetOffsetChannel>
 8102e50:	4603      	mov	r3, r0
 8102e52:	0e9b      	lsrs	r3, r3, #26
 8102e54:	f003 021f 	and.w	r2, r3, #31
 8102e58:	e017      	b.n	8102e8a <HAL_ADCEx_InjectedConfigChannel+0x662>
 8102e5a:	687b      	ldr	r3, [r7, #4]
 8102e5c:	681b      	ldr	r3, [r3, #0]
 8102e5e:	2103      	movs	r1, #3
 8102e60:	4618      	mov	r0, r3
 8102e62:	f7ff fc12 	bl	810268a <LL_ADC_GetOffsetChannel>
 8102e66:	4603      	mov	r3, r0
 8102e68:	677b      	str	r3, [r7, #116]	; 0x74
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8102e6a:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 8102e6c:	fa93 f3a3 	rbit	r3, r3
 8102e70:	673b      	str	r3, [r7, #112]	; 0x70
  return result;
 8102e72:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 8102e74:	67bb      	str	r3, [r7, #120]	; 0x78
  if (value == 0U)
 8102e76:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 8102e78:	2b00      	cmp	r3, #0
 8102e7a:	d101      	bne.n	8102e80 <HAL_ADCEx_InjectedConfigChannel+0x658>
    return 32U;
 8102e7c:	2320      	movs	r3, #32
 8102e7e:	e003      	b.n	8102e88 <HAL_ADCEx_InjectedConfigChannel+0x660>
  return __builtin_clz(value);
 8102e80:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 8102e82:	fab3 f383 	clz	r3, r3
 8102e86:	b2db      	uxtb	r3, r3
 8102e88:	461a      	mov	r2, r3
 8102e8a:	683b      	ldr	r3, [r7, #0]
 8102e8c:	681b      	ldr	r3, [r3, #0]
 8102e8e:	f3c3 0313 	ubfx	r3, r3, #0, #20
 8102e92:	2b00      	cmp	r3, #0
 8102e94:	d105      	bne.n	8102ea2 <HAL_ADCEx_InjectedConfigChannel+0x67a>
 8102e96:	683b      	ldr	r3, [r7, #0]
 8102e98:	681b      	ldr	r3, [r3, #0]
 8102e9a:	0e9b      	lsrs	r3, r3, #26
 8102e9c:	f003 031f 	and.w	r3, r3, #31
 8102ea0:	e011      	b.n	8102ec6 <HAL_ADCEx_InjectedConfigChannel+0x69e>
 8102ea2:	683b      	ldr	r3, [r7, #0]
 8102ea4:	681b      	ldr	r3, [r3, #0]
 8102ea6:	66bb      	str	r3, [r7, #104]	; 0x68
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8102ea8:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 8102eaa:	fa93 f3a3 	rbit	r3, r3
 8102eae:	667b      	str	r3, [r7, #100]	; 0x64
  return result;
 8102eb0:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8102eb2:	66fb      	str	r3, [r7, #108]	; 0x6c
  if (value == 0U)
 8102eb4:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 8102eb6:	2b00      	cmp	r3, #0
 8102eb8:	d101      	bne.n	8102ebe <HAL_ADCEx_InjectedConfigChannel+0x696>
    return 32U;
 8102eba:	2320      	movs	r3, #32
 8102ebc:	e003      	b.n	8102ec6 <HAL_ADCEx_InjectedConfigChannel+0x69e>
  return __builtin_clz(value);
 8102ebe:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 8102ec0:	fab3 f383 	clz	r3, r3
 8102ec4:	b2db      	uxtb	r3, r3
 8102ec6:	429a      	cmp	r2, r3
 8102ec8:	d107      	bne.n	8102eda <HAL_ADCEx_InjectedConfigChannel+0x6b2>
        {
          LL_ADC_SetOffset(hadc->Instance, LL_ADC_OFFSET_4, sConfigInjected->InjectedChannel, LL_ADC_OFFSET_SIGNED_SATURATION_DISABLE);
 8102eca:	687b      	ldr	r3, [r7, #4]
 8102ecc:	6818      	ldr	r0, [r3, #0]
 8102ece:	683b      	ldr	r3, [r7, #0]
 8102ed0:	681a      	ldr	r2, [r3, #0]
 8102ed2:	2300      	movs	r3, #0
 8102ed4:	2103      	movs	r1, #3
 8102ed6:	f7ff fbb8 	bl	810264a <LL_ADC_SetOffset>

  /* Parameters update conditioned to ADC state:                              */
  /* Parameters that can be updated only when ADC is disabled:                */
  /*  - Single or differential mode                                           */
  /*  - Internal measurement channels: Vbat/VrefInt/TempSensor                */
  if (LL_ADC_IsEnabled(hadc->Instance) == 0UL)
 8102eda:	687b      	ldr	r3, [r7, #4]
 8102edc:	681b      	ldr	r3, [r3, #0]
 8102ede:	4618      	mov	r0, r3
 8102ee0:	f7ff fc68 	bl	81027b4 <LL_ADC_IsEnabled>
 8102ee4:	4603      	mov	r3, r0
 8102ee6:	2b00      	cmp	r3, #0
 8102ee8:	f040 8208 	bne.w	81032fc <HAL_ADCEx_InjectedConfigChannel+0xad4>
  {
    /* Set mode single-ended or differential input of the selected ADC channel */
    LL_ADC_SetChannelSingleDiff(hadc->Instance, sConfigInjected->InjectedChannel, sConfigInjected->InjectedSingleDiff);
 8102eec:	687b      	ldr	r3, [r7, #4]
 8102eee:	6818      	ldr	r0, [r3, #0]
 8102ef0:	683b      	ldr	r3, [r7, #0]
 8102ef2:	6819      	ldr	r1, [r3, #0]
 8102ef4:	683b      	ldr	r3, [r7, #0]
 8102ef6:	68db      	ldr	r3, [r3, #12]
 8102ef8:	461a      	mov	r2, r3
 8102efa:	f7ff fc37 	bl	810276c <LL_ADC_SetChannelSingleDiff>

    /* Configuration of differential mode */
    /* Note: ADC channel number masked with value "0x1F" to ensure shift value within 32 bits range */
    if (sConfigInjected->InjectedSingleDiff == ADC_DIFFERENTIAL_ENDED)
 8102efe:	683b      	ldr	r3, [r7, #0]
 8102f00:	68db      	ldr	r3, [r3, #12]
 8102f02:	4a8f      	ldr	r2, [pc, #572]	; (8103140 <HAL_ADCEx_InjectedConfigChannel+0x918>)
 8102f04:	4293      	cmp	r3, r2
 8102f06:	f040 8131 	bne.w	810316c <HAL_ADCEx_InjectedConfigChannel+0x944>
    {
      /* Set sampling time of the selected ADC channel */
      LL_ADC_SetChannelSamplingTime(hadc->Instance, (uint32_t)(__LL_ADC_DECIMAL_NB_TO_CHANNEL((__LL_ADC_CHANNEL_TO_DECIMAL_NB((uint32_t)sConfigInjected->InjectedChannel) + 1UL) & 0x1FUL)), sConfigInjected->InjectedSamplingTime);
 8102f0a:	687b      	ldr	r3, [r7, #4]
 8102f0c:	6818      	ldr	r0, [r3, #0]
 8102f0e:	683b      	ldr	r3, [r7, #0]
 8102f10:	681b      	ldr	r3, [r3, #0]
 8102f12:	f3c3 0313 	ubfx	r3, r3, #0, #20
 8102f16:	2b00      	cmp	r3, #0
 8102f18:	d10b      	bne.n	8102f32 <HAL_ADCEx_InjectedConfigChannel+0x70a>
 8102f1a:	683b      	ldr	r3, [r7, #0]
 8102f1c:	681b      	ldr	r3, [r3, #0]
 8102f1e:	0e9b      	lsrs	r3, r3, #26
 8102f20:	3301      	adds	r3, #1
 8102f22:	f003 031f 	and.w	r3, r3, #31
 8102f26:	2b09      	cmp	r3, #9
 8102f28:	bf94      	ite	ls
 8102f2a:	2301      	movls	r3, #1
 8102f2c:	2300      	movhi	r3, #0
 8102f2e:	b2db      	uxtb	r3, r3
 8102f30:	e019      	b.n	8102f66 <HAL_ADCEx_InjectedConfigChannel+0x73e>
 8102f32:	683b      	ldr	r3, [r7, #0]
 8102f34:	681b      	ldr	r3, [r3, #0]
 8102f36:	65fb      	str	r3, [r7, #92]	; 0x5c
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8102f38:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8102f3a:	fa93 f3a3 	rbit	r3, r3
 8102f3e:	65bb      	str	r3, [r7, #88]	; 0x58
  return result;
 8102f40:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8102f42:	663b      	str	r3, [r7, #96]	; 0x60
  if (value == 0U)
 8102f44:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8102f46:	2b00      	cmp	r3, #0
 8102f48:	d101      	bne.n	8102f4e <HAL_ADCEx_InjectedConfigChannel+0x726>
    return 32U;
 8102f4a:	2320      	movs	r3, #32
 8102f4c:	e003      	b.n	8102f56 <HAL_ADCEx_InjectedConfigChannel+0x72e>
  return __builtin_clz(value);
 8102f4e:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8102f50:	fab3 f383 	clz	r3, r3
 8102f54:	b2db      	uxtb	r3, r3
 8102f56:	3301      	adds	r3, #1
 8102f58:	f003 031f 	and.w	r3, r3, #31
 8102f5c:	2b09      	cmp	r3, #9
 8102f5e:	bf94      	ite	ls
 8102f60:	2301      	movls	r3, #1
 8102f62:	2300      	movhi	r3, #0
 8102f64:	b2db      	uxtb	r3, r3
 8102f66:	2b00      	cmp	r3, #0
 8102f68:	d079      	beq.n	810305e <HAL_ADCEx_InjectedConfigChannel+0x836>
 8102f6a:	683b      	ldr	r3, [r7, #0]
 8102f6c:	681b      	ldr	r3, [r3, #0]
 8102f6e:	f3c3 0313 	ubfx	r3, r3, #0, #20
 8102f72:	2b00      	cmp	r3, #0
 8102f74:	d107      	bne.n	8102f86 <HAL_ADCEx_InjectedConfigChannel+0x75e>
 8102f76:	683b      	ldr	r3, [r7, #0]
 8102f78:	681b      	ldr	r3, [r3, #0]
 8102f7a:	0e9b      	lsrs	r3, r3, #26
 8102f7c:	3301      	adds	r3, #1
 8102f7e:	069b      	lsls	r3, r3, #26
 8102f80:	f003 42f8 	and.w	r2, r3, #2080374784	; 0x7c000000
 8102f84:	e015      	b.n	8102fb2 <HAL_ADCEx_InjectedConfigChannel+0x78a>
 8102f86:	683b      	ldr	r3, [r7, #0]
 8102f88:	681b      	ldr	r3, [r3, #0]
 8102f8a:	653b      	str	r3, [r7, #80]	; 0x50
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8102f8c:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8102f8e:	fa93 f3a3 	rbit	r3, r3
 8102f92:	64fb      	str	r3, [r7, #76]	; 0x4c
  return result;
 8102f94:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8102f96:	657b      	str	r3, [r7, #84]	; 0x54
  if (value == 0U)
 8102f98:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8102f9a:	2b00      	cmp	r3, #0
 8102f9c:	d101      	bne.n	8102fa2 <HAL_ADCEx_InjectedConfigChannel+0x77a>
    return 32U;
 8102f9e:	2320      	movs	r3, #32
 8102fa0:	e003      	b.n	8102faa <HAL_ADCEx_InjectedConfigChannel+0x782>
  return __builtin_clz(value);
 8102fa2:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8102fa4:	fab3 f383 	clz	r3, r3
 8102fa8:	b2db      	uxtb	r3, r3
 8102faa:	3301      	adds	r3, #1
 8102fac:	069b      	lsls	r3, r3, #26
 8102fae:	f003 42f8 	and.w	r2, r3, #2080374784	; 0x7c000000
 8102fb2:	683b      	ldr	r3, [r7, #0]
 8102fb4:	681b      	ldr	r3, [r3, #0]
 8102fb6:	f3c3 0313 	ubfx	r3, r3, #0, #20
 8102fba:	2b00      	cmp	r3, #0
 8102fbc:	d109      	bne.n	8102fd2 <HAL_ADCEx_InjectedConfigChannel+0x7aa>
 8102fbe:	683b      	ldr	r3, [r7, #0]
 8102fc0:	681b      	ldr	r3, [r3, #0]
 8102fc2:	0e9b      	lsrs	r3, r3, #26
 8102fc4:	3301      	adds	r3, #1
 8102fc6:	f003 031f 	and.w	r3, r3, #31
 8102fca:	2101      	movs	r1, #1
 8102fcc:	fa01 f303 	lsl.w	r3, r1, r3
 8102fd0:	e017      	b.n	8103002 <HAL_ADCEx_InjectedConfigChannel+0x7da>
 8102fd2:	683b      	ldr	r3, [r7, #0]
 8102fd4:	681b      	ldr	r3, [r3, #0]
 8102fd6:	647b      	str	r3, [r7, #68]	; 0x44
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8102fd8:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8102fda:	fa93 f3a3 	rbit	r3, r3
 8102fde:	643b      	str	r3, [r7, #64]	; 0x40
  return result;
 8102fe0:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8102fe2:	64bb      	str	r3, [r7, #72]	; 0x48
  if (value == 0U)
 8102fe4:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8102fe6:	2b00      	cmp	r3, #0
 8102fe8:	d101      	bne.n	8102fee <HAL_ADCEx_InjectedConfigChannel+0x7c6>
    return 32U;
 8102fea:	2320      	movs	r3, #32
 8102fec:	e003      	b.n	8102ff6 <HAL_ADCEx_InjectedConfigChannel+0x7ce>
  return __builtin_clz(value);
 8102fee:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8102ff0:	fab3 f383 	clz	r3, r3
 8102ff4:	b2db      	uxtb	r3, r3
 8102ff6:	3301      	adds	r3, #1
 8102ff8:	f003 031f 	and.w	r3, r3, #31
 8102ffc:	2101      	movs	r1, #1
 8102ffe:	fa01 f303 	lsl.w	r3, r1, r3
 8103002:	ea42 0103 	orr.w	r1, r2, r3
 8103006:	683b      	ldr	r3, [r7, #0]
 8103008:	681b      	ldr	r3, [r3, #0]
 810300a:	f3c3 0313 	ubfx	r3, r3, #0, #20
 810300e:	2b00      	cmp	r3, #0
 8103010:	d10a      	bne.n	8103028 <HAL_ADCEx_InjectedConfigChannel+0x800>
 8103012:	683b      	ldr	r3, [r7, #0]
 8103014:	681b      	ldr	r3, [r3, #0]
 8103016:	0e9b      	lsrs	r3, r3, #26
 8103018:	3301      	adds	r3, #1
 810301a:	f003 021f 	and.w	r2, r3, #31
 810301e:	4613      	mov	r3, r2
 8103020:	005b      	lsls	r3, r3, #1
 8103022:	4413      	add	r3, r2
 8103024:	051b      	lsls	r3, r3, #20
 8103026:	e018      	b.n	810305a <HAL_ADCEx_InjectedConfigChannel+0x832>
 8103028:	683b      	ldr	r3, [r7, #0]
 810302a:	681b      	ldr	r3, [r3, #0]
 810302c:	63bb      	str	r3, [r7, #56]	; 0x38
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 810302e:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8103030:	fa93 f3a3 	rbit	r3, r3
 8103034:	637b      	str	r3, [r7, #52]	; 0x34
  return result;
 8103036:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8103038:	63fb      	str	r3, [r7, #60]	; 0x3c
  if (value == 0U)
 810303a:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 810303c:	2b00      	cmp	r3, #0
 810303e:	d101      	bne.n	8103044 <HAL_ADCEx_InjectedConfigChannel+0x81c>
    return 32U;
 8103040:	2320      	movs	r3, #32
 8103042:	e003      	b.n	810304c <HAL_ADCEx_InjectedConfigChannel+0x824>
  return __builtin_clz(value);
 8103044:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8103046:	fab3 f383 	clz	r3, r3
 810304a:	b2db      	uxtb	r3, r3
 810304c:	3301      	adds	r3, #1
 810304e:	f003 021f 	and.w	r2, r3, #31
 8103052:	4613      	mov	r3, r2
 8103054:	005b      	lsls	r3, r3, #1
 8103056:	4413      	add	r3, r2
 8103058:	051b      	lsls	r3, r3, #20
 810305a:	430b      	orrs	r3, r1
 810305c:	e081      	b.n	8103162 <HAL_ADCEx_InjectedConfigChannel+0x93a>
 810305e:	683b      	ldr	r3, [r7, #0]
 8103060:	681b      	ldr	r3, [r3, #0]
 8103062:	f3c3 0313 	ubfx	r3, r3, #0, #20
 8103066:	2b00      	cmp	r3, #0
 8103068:	d107      	bne.n	810307a <HAL_ADCEx_InjectedConfigChannel+0x852>
 810306a:	683b      	ldr	r3, [r7, #0]
 810306c:	681b      	ldr	r3, [r3, #0]
 810306e:	0e9b      	lsrs	r3, r3, #26
 8103070:	3301      	adds	r3, #1
 8103072:	069b      	lsls	r3, r3, #26
 8103074:	f003 42f8 	and.w	r2, r3, #2080374784	; 0x7c000000
 8103078:	e015      	b.n	81030a6 <HAL_ADCEx_InjectedConfigChannel+0x87e>
 810307a:	683b      	ldr	r3, [r7, #0]
 810307c:	681b      	ldr	r3, [r3, #0]
 810307e:	62fb      	str	r3, [r7, #44]	; 0x2c
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8103080:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8103082:	fa93 f3a3 	rbit	r3, r3
 8103086:	62bb      	str	r3, [r7, #40]	; 0x28
  return result;
 8103088:	6abb      	ldr	r3, [r7, #40]	; 0x28
 810308a:	633b      	str	r3, [r7, #48]	; 0x30
  if (value == 0U)
 810308c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 810308e:	2b00      	cmp	r3, #0
 8103090:	d101      	bne.n	8103096 <HAL_ADCEx_InjectedConfigChannel+0x86e>
    return 32U;
 8103092:	2320      	movs	r3, #32
 8103094:	e003      	b.n	810309e <HAL_ADCEx_InjectedConfigChannel+0x876>
  return __builtin_clz(value);
 8103096:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8103098:	fab3 f383 	clz	r3, r3
 810309c:	b2db      	uxtb	r3, r3
 810309e:	3301      	adds	r3, #1
 81030a0:	069b      	lsls	r3, r3, #26
 81030a2:	f003 42f8 	and.w	r2, r3, #2080374784	; 0x7c000000
 81030a6:	683b      	ldr	r3, [r7, #0]
 81030a8:	681b      	ldr	r3, [r3, #0]
 81030aa:	f3c3 0313 	ubfx	r3, r3, #0, #20
 81030ae:	2b00      	cmp	r3, #0
 81030b0:	d109      	bne.n	81030c6 <HAL_ADCEx_InjectedConfigChannel+0x89e>
 81030b2:	683b      	ldr	r3, [r7, #0]
 81030b4:	681b      	ldr	r3, [r3, #0]
 81030b6:	0e9b      	lsrs	r3, r3, #26
 81030b8:	3301      	adds	r3, #1
 81030ba:	f003 031f 	and.w	r3, r3, #31
 81030be:	2101      	movs	r1, #1
 81030c0:	fa01 f303 	lsl.w	r3, r1, r3
 81030c4:	e017      	b.n	81030f6 <HAL_ADCEx_InjectedConfigChannel+0x8ce>
 81030c6:	683b      	ldr	r3, [r7, #0]
 81030c8:	681b      	ldr	r3, [r3, #0]
 81030ca:	623b      	str	r3, [r7, #32]
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 81030cc:	6a3b      	ldr	r3, [r7, #32]
 81030ce:	fa93 f3a3 	rbit	r3, r3
 81030d2:	61fb      	str	r3, [r7, #28]
  return result;
 81030d4:	69fb      	ldr	r3, [r7, #28]
 81030d6:	627b      	str	r3, [r7, #36]	; 0x24
  if (value == 0U)
 81030d8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 81030da:	2b00      	cmp	r3, #0
 81030dc:	d101      	bne.n	81030e2 <HAL_ADCEx_InjectedConfigChannel+0x8ba>
    return 32U;
 81030de:	2320      	movs	r3, #32
 81030e0:	e003      	b.n	81030ea <HAL_ADCEx_InjectedConfigChannel+0x8c2>
  return __builtin_clz(value);
 81030e2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 81030e4:	fab3 f383 	clz	r3, r3
 81030e8:	b2db      	uxtb	r3, r3
 81030ea:	3301      	adds	r3, #1
 81030ec:	f003 031f 	and.w	r3, r3, #31
 81030f0:	2101      	movs	r1, #1
 81030f2:	fa01 f303 	lsl.w	r3, r1, r3
 81030f6:	ea42 0103 	orr.w	r1, r2, r3
 81030fa:	683b      	ldr	r3, [r7, #0]
 81030fc:	681b      	ldr	r3, [r3, #0]
 81030fe:	f3c3 0313 	ubfx	r3, r3, #0, #20
 8103102:	2b00      	cmp	r3, #0
 8103104:	d10d      	bne.n	8103122 <HAL_ADCEx_InjectedConfigChannel+0x8fa>
 8103106:	683b      	ldr	r3, [r7, #0]
 8103108:	681b      	ldr	r3, [r3, #0]
 810310a:	0e9b      	lsrs	r3, r3, #26
 810310c:	3301      	adds	r3, #1
 810310e:	f003 021f 	and.w	r2, r3, #31
 8103112:	4613      	mov	r3, r2
 8103114:	005b      	lsls	r3, r3, #1
 8103116:	4413      	add	r3, r2
 8103118:	3b1e      	subs	r3, #30
 810311a:	051b      	lsls	r3, r3, #20
 810311c:	f043 7300 	orr.w	r3, r3, #33554432	; 0x2000000
 8103120:	e01e      	b.n	8103160 <HAL_ADCEx_InjectedConfigChannel+0x938>
 8103122:	683b      	ldr	r3, [r7, #0]
 8103124:	681b      	ldr	r3, [r3, #0]
 8103126:	617b      	str	r3, [r7, #20]
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8103128:	697b      	ldr	r3, [r7, #20]
 810312a:	fa93 f3a3 	rbit	r3, r3
 810312e:	613b      	str	r3, [r7, #16]
  return result;
 8103130:	693b      	ldr	r3, [r7, #16]
 8103132:	61bb      	str	r3, [r7, #24]
  if (value == 0U)
 8103134:	69bb      	ldr	r3, [r7, #24]
 8103136:	2b00      	cmp	r3, #0
 8103138:	d104      	bne.n	8103144 <HAL_ADCEx_InjectedConfigChannel+0x91c>
    return 32U;
 810313a:	2320      	movs	r3, #32
 810313c:	e006      	b.n	810314c <HAL_ADCEx_InjectedConfigChannel+0x924>
 810313e:	bf00      	nop
 8103140:	47ff0000 	.word	0x47ff0000
  return __builtin_clz(value);
 8103144:	69bb      	ldr	r3, [r7, #24]
 8103146:	fab3 f383 	clz	r3, r3
 810314a:	b2db      	uxtb	r3, r3
 810314c:	3301      	adds	r3, #1
 810314e:	f003 021f 	and.w	r2, r3, #31
 8103152:	4613      	mov	r3, r2
 8103154:	005b      	lsls	r3, r3, #1
 8103156:	4413      	add	r3, r2
 8103158:	3b1e      	subs	r3, #30
 810315a:	051b      	lsls	r3, r3, #20
 810315c:	f043 7300 	orr.w	r3, r3, #33554432	; 0x2000000
 8103160:	430b      	orrs	r3, r1
 8103162:	683a      	ldr	r2, [r7, #0]
 8103164:	6892      	ldr	r2, [r2, #8]
 8103166:	4619      	mov	r1, r3
 8103168:	f7ff fad5 	bl	8102716 <LL_ADC_SetChannelSamplingTime>
    /* internal measurement paths enable: If internal channel selected,       */
    /* enable dedicated internal buffers and path.                            */
    /* Note: these internal measurement paths can be disabled using           */
    /* HAL_ADC_DeInit().                                                      */

    if (__LL_ADC_IS_CHANNEL_INTERNAL(sConfigInjected->InjectedChannel))
 810316c:	683b      	ldr	r3, [r7, #0]
 810316e:	681b      	ldr	r3, [r3, #0]
 8103170:	2b00      	cmp	r3, #0
 8103172:	f280 80c3 	bge.w	81032fc <HAL_ADCEx_InjectedConfigChannel+0xad4>
    {
      /* Configuration of common ADC parameters (continuation)                */
      /* Software is allowed to change common parameters only when all ADCs   */
      /* of the common group are disabled.                                    */
      if (__LL_ADC_IS_ENABLED_ALL_COMMON_INSTANCE(__LL_ADC_COMMON_INSTANCE(hadc->Instance)) == 0UL)
 8103176:	687b      	ldr	r3, [r7, #4]
 8103178:	681b      	ldr	r3, [r3, #0]
 810317a:	4a65      	ldr	r2, [pc, #404]	; (8103310 <HAL_ADCEx_InjectedConfigChannel+0xae8>)
 810317c:	4293      	cmp	r3, r2
 810317e:	d004      	beq.n	810318a <HAL_ADCEx_InjectedConfigChannel+0x962>
 8103180:	687b      	ldr	r3, [r7, #4]
 8103182:	681b      	ldr	r3, [r3, #0]
 8103184:	4a63      	ldr	r2, [pc, #396]	; (8103314 <HAL_ADCEx_InjectedConfigChannel+0xaec>)
 8103186:	4293      	cmp	r3, r2
 8103188:	d10e      	bne.n	81031a8 <HAL_ADCEx_InjectedConfigChannel+0x980>
 810318a:	4861      	ldr	r0, [pc, #388]	; (8103310 <HAL_ADCEx_InjectedConfigChannel+0xae8>)
 810318c:	f7ff fb12 	bl	81027b4 <LL_ADC_IsEnabled>
 8103190:	4604      	mov	r4, r0
 8103192:	4860      	ldr	r0, [pc, #384]	; (8103314 <HAL_ADCEx_InjectedConfigChannel+0xaec>)
 8103194:	f7ff fb0e 	bl	81027b4 <LL_ADC_IsEnabled>
 8103198:	4603      	mov	r3, r0
 810319a:	4323      	orrs	r3, r4
 810319c:	2b00      	cmp	r3, #0
 810319e:	bf0c      	ite	eq
 81031a0:	2301      	moveq	r3, #1
 81031a2:	2300      	movne	r3, #0
 81031a4:	b2db      	uxtb	r3, r3
 81031a6:	e008      	b.n	81031ba <HAL_ADCEx_InjectedConfigChannel+0x992>
 81031a8:	485b      	ldr	r0, [pc, #364]	; (8103318 <HAL_ADCEx_InjectedConfigChannel+0xaf0>)
 81031aa:	f7ff fb03 	bl	81027b4 <LL_ADC_IsEnabled>
 81031ae:	4603      	mov	r3, r0
 81031b0:	2b00      	cmp	r3, #0
 81031b2:	bf0c      	ite	eq
 81031b4:	2301      	moveq	r3, #1
 81031b6:	2300      	movne	r3, #0
 81031b8:	b2db      	uxtb	r3, r3
 81031ba:	2b00      	cmp	r3, #0
 81031bc:	f000 8095 	beq.w	81032ea <HAL_ADCEx_InjectedConfigChannel+0xac2>
      {
        tmp_config_internal_channel = LL_ADC_GetCommonPathInternalCh(__LL_ADC_COMMON_INSTANCE(hadc->Instance));
 81031c0:	687b      	ldr	r3, [r7, #4]
 81031c2:	681b      	ldr	r3, [r3, #0]
 81031c4:	4a52      	ldr	r2, [pc, #328]	; (8103310 <HAL_ADCEx_InjectedConfigChannel+0xae8>)
 81031c6:	4293      	cmp	r3, r2
 81031c8:	d004      	beq.n	81031d4 <HAL_ADCEx_InjectedConfigChannel+0x9ac>
 81031ca:	687b      	ldr	r3, [r7, #4]
 81031cc:	681b      	ldr	r3, [r3, #0]
 81031ce:	4a51      	ldr	r2, [pc, #324]	; (8103314 <HAL_ADCEx_InjectedConfigChannel+0xaec>)
 81031d0:	4293      	cmp	r3, r2
 81031d2:	d101      	bne.n	81031d8 <HAL_ADCEx_InjectedConfigChannel+0x9b0>
 81031d4:	4b51      	ldr	r3, [pc, #324]	; (810331c <HAL_ADCEx_InjectedConfigChannel+0xaf4>)
 81031d6:	e000      	b.n	81031da <HAL_ADCEx_InjectedConfigChannel+0x9b2>
 81031d8:	4b51      	ldr	r3, [pc, #324]	; (8103320 <HAL_ADCEx_InjectedConfigChannel+0xaf8>)
 81031da:	4618      	mov	r0, r3
 81031dc:	f7ff fa27 	bl	810262e <LL_ADC_GetCommonPathInternalCh>
 81031e0:	f8c7 00d0 	str.w	r0, [r7, #208]	; 0xd0

        /* If the requested internal measurement path has already been enabled, */
        /* bypass the configuration processing.                                 */
        if ((sConfigInjected->InjectedChannel == ADC_CHANNEL_TEMPSENSOR) && ((tmp_config_internal_channel & LL_ADC_PATH_INTERNAL_TEMPSENSOR) == 0UL))
 81031e4:	683b      	ldr	r3, [r7, #0]
 81031e6:	681b      	ldr	r3, [r3, #0]
 81031e8:	4a4e      	ldr	r2, [pc, #312]	; (8103324 <HAL_ADCEx_InjectedConfigChannel+0xafc>)
 81031ea:	4293      	cmp	r3, r2
 81031ec:	d131      	bne.n	8103252 <HAL_ADCEx_InjectedConfigChannel+0xa2a>
 81031ee:	f8d7 30d0 	ldr.w	r3, [r7, #208]	; 0xd0
 81031f2:	f403 0300 	and.w	r3, r3, #8388608	; 0x800000
 81031f6:	2b00      	cmp	r3, #0
 81031f8:	d12b      	bne.n	8103252 <HAL_ADCEx_InjectedConfigChannel+0xa2a>
        {
          if (ADC_TEMPERATURE_SENSOR_INSTANCE(hadc))
 81031fa:	687b      	ldr	r3, [r7, #4]
 81031fc:	681b      	ldr	r3, [r3, #0]
 81031fe:	4a46      	ldr	r2, [pc, #280]	; (8103318 <HAL_ADCEx_InjectedConfigChannel+0xaf0>)
 8103200:	4293      	cmp	r3, r2
 8103202:	d17b      	bne.n	81032fc <HAL_ADCEx_InjectedConfigChannel+0xad4>
          {
            LL_ADC_SetCommonPathInternalCh(__LL_ADC_COMMON_INSTANCE(hadc->Instance), LL_ADC_PATH_INTERNAL_TEMPSENSOR | tmp_config_internal_channel);
 8103204:	687b      	ldr	r3, [r7, #4]
 8103206:	681b      	ldr	r3, [r3, #0]
 8103208:	4a41      	ldr	r2, [pc, #260]	; (8103310 <HAL_ADCEx_InjectedConfigChannel+0xae8>)
 810320a:	4293      	cmp	r3, r2
 810320c:	d004      	beq.n	8103218 <HAL_ADCEx_InjectedConfigChannel+0x9f0>
 810320e:	687b      	ldr	r3, [r7, #4]
 8103210:	681b      	ldr	r3, [r3, #0]
 8103212:	4a40      	ldr	r2, [pc, #256]	; (8103314 <HAL_ADCEx_InjectedConfigChannel+0xaec>)
 8103214:	4293      	cmp	r3, r2
 8103216:	d101      	bne.n	810321c <HAL_ADCEx_InjectedConfigChannel+0x9f4>
 8103218:	4a40      	ldr	r2, [pc, #256]	; (810331c <HAL_ADCEx_InjectedConfigChannel+0xaf4>)
 810321a:	e000      	b.n	810321e <HAL_ADCEx_InjectedConfigChannel+0x9f6>
 810321c:	4a40      	ldr	r2, [pc, #256]	; (8103320 <HAL_ADCEx_InjectedConfigChannel+0xaf8>)
 810321e:	f8d7 30d0 	ldr.w	r3, [r7, #208]	; 0xd0
 8103222:	f443 0300 	orr.w	r3, r3, #8388608	; 0x800000
 8103226:	4619      	mov	r1, r3
 8103228:	4610      	mov	r0, r2
 810322a:	f7ff f9ed 	bl	8102608 <LL_ADC_SetCommonPathInternalCh>
            /* Delay for temperature sensor stabilization time */
            /* Wait loop initialization and execution */
            /* Note: Variable divided by 2 to compensate partially              */
            /*       CPU processing cycles, scaling in us split to not          */
            /*       exceed 32 bits register capacity and handle low frequency. */
            wait_loop_index = ((LL_ADC_DELAY_TEMPSENSOR_STAB_US / 10UL) * ((SystemCoreClock / (100000UL * 2UL)) + 1UL));
 810322e:	4b3e      	ldr	r3, [pc, #248]	; (8103328 <HAL_ADCEx_InjectedConfigChannel+0xb00>)
 8103230:	681b      	ldr	r3, [r3, #0]
 8103232:	099b      	lsrs	r3, r3, #6
 8103234:	4a3d      	ldr	r2, [pc, #244]	; (810332c <HAL_ADCEx_InjectedConfigChannel+0xb04>)
 8103236:	fba2 2303 	umull	r2, r3, r2, r3
 810323a:	099b      	lsrs	r3, r3, #6
 810323c:	3301      	adds	r3, #1
 810323e:	005b      	lsls	r3, r3, #1
 8103240:	60fb      	str	r3, [r7, #12]
            while (wait_loop_index != 0UL)
 8103242:	e002      	b.n	810324a <HAL_ADCEx_InjectedConfigChannel+0xa22>
            {
              wait_loop_index--;
 8103244:	68fb      	ldr	r3, [r7, #12]
 8103246:	3b01      	subs	r3, #1
 8103248:	60fb      	str	r3, [r7, #12]
            while (wait_loop_index != 0UL)
 810324a:	68fb      	ldr	r3, [r7, #12]
 810324c:	2b00      	cmp	r3, #0
 810324e:	d1f9      	bne.n	8103244 <HAL_ADCEx_InjectedConfigChannel+0xa1c>
          if (ADC_TEMPERATURE_SENSOR_INSTANCE(hadc))
 8103250:	e054      	b.n	81032fc <HAL_ADCEx_InjectedConfigChannel+0xad4>
            }
          }
        }
        else if ((sConfigInjected->InjectedChannel == ADC_CHANNEL_VBAT) && ((tmp_config_internal_channel & LL_ADC_PATH_INTERNAL_VBAT) == 0UL))
 8103252:	683b      	ldr	r3, [r7, #0]
 8103254:	681b      	ldr	r3, [r3, #0]
 8103256:	4a36      	ldr	r2, [pc, #216]	; (8103330 <HAL_ADCEx_InjectedConfigChannel+0xb08>)
 8103258:	4293      	cmp	r3, r2
 810325a:	d120      	bne.n	810329e <HAL_ADCEx_InjectedConfigChannel+0xa76>
 810325c:	f8d7 30d0 	ldr.w	r3, [r7, #208]	; 0xd0
 8103260:	f003 7380 	and.w	r3, r3, #16777216	; 0x1000000
 8103264:	2b00      	cmp	r3, #0
 8103266:	d11a      	bne.n	810329e <HAL_ADCEx_InjectedConfigChannel+0xa76>
        {
          if (ADC_BATTERY_VOLTAGE_INSTANCE(hadc))
 8103268:	687b      	ldr	r3, [r7, #4]
 810326a:	681b      	ldr	r3, [r3, #0]
 810326c:	4a2a      	ldr	r2, [pc, #168]	; (8103318 <HAL_ADCEx_InjectedConfigChannel+0xaf0>)
 810326e:	4293      	cmp	r3, r2
 8103270:	d144      	bne.n	81032fc <HAL_ADCEx_InjectedConfigChannel+0xad4>
          {
            LL_ADC_SetCommonPathInternalCh(__LL_ADC_COMMON_INSTANCE(hadc->Instance), LL_ADC_PATH_INTERNAL_VBAT | tmp_config_internal_channel);
 8103272:	687b      	ldr	r3, [r7, #4]
 8103274:	681b      	ldr	r3, [r3, #0]
 8103276:	4a26      	ldr	r2, [pc, #152]	; (8103310 <HAL_ADCEx_InjectedConfigChannel+0xae8>)
 8103278:	4293      	cmp	r3, r2
 810327a:	d004      	beq.n	8103286 <HAL_ADCEx_InjectedConfigChannel+0xa5e>
 810327c:	687b      	ldr	r3, [r7, #4]
 810327e:	681b      	ldr	r3, [r3, #0]
 8103280:	4a24      	ldr	r2, [pc, #144]	; (8103314 <HAL_ADCEx_InjectedConfigChannel+0xaec>)
 8103282:	4293      	cmp	r3, r2
 8103284:	d101      	bne.n	810328a <HAL_ADCEx_InjectedConfigChannel+0xa62>
 8103286:	4a25      	ldr	r2, [pc, #148]	; (810331c <HAL_ADCEx_InjectedConfigChannel+0xaf4>)
 8103288:	e000      	b.n	810328c <HAL_ADCEx_InjectedConfigChannel+0xa64>
 810328a:	4a25      	ldr	r2, [pc, #148]	; (8103320 <HAL_ADCEx_InjectedConfigChannel+0xaf8>)
 810328c:	f8d7 30d0 	ldr.w	r3, [r7, #208]	; 0xd0
 8103290:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 8103294:	4619      	mov	r1, r3
 8103296:	4610      	mov	r0, r2
 8103298:	f7ff f9b6 	bl	8102608 <LL_ADC_SetCommonPathInternalCh>
          if (ADC_BATTERY_VOLTAGE_INSTANCE(hadc))
 810329c:	e02e      	b.n	81032fc <HAL_ADCEx_InjectedConfigChannel+0xad4>
          }
        }
        else if ((sConfigInjected->InjectedChannel == ADC_CHANNEL_VREFINT) && ((tmp_config_internal_channel & LL_ADC_PATH_INTERNAL_VREFINT) == 0UL))
 810329e:	683b      	ldr	r3, [r7, #0]
 81032a0:	681b      	ldr	r3, [r3, #0]
 81032a2:	4a24      	ldr	r2, [pc, #144]	; (8103334 <HAL_ADCEx_InjectedConfigChannel+0xb0c>)
 81032a4:	4293      	cmp	r3, r2
 81032a6:	d129      	bne.n	81032fc <HAL_ADCEx_InjectedConfigChannel+0xad4>
 81032a8:	f8d7 30d0 	ldr.w	r3, [r7, #208]	; 0xd0
 81032ac:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
 81032b0:	2b00      	cmp	r3, #0
 81032b2:	d123      	bne.n	81032fc <HAL_ADCEx_InjectedConfigChannel+0xad4>
        {
          if (ADC_VREFINT_INSTANCE(hadc))
 81032b4:	687b      	ldr	r3, [r7, #4]
 81032b6:	681b      	ldr	r3, [r3, #0]
 81032b8:	4a17      	ldr	r2, [pc, #92]	; (8103318 <HAL_ADCEx_InjectedConfigChannel+0xaf0>)
 81032ba:	4293      	cmp	r3, r2
 81032bc:	d11e      	bne.n	81032fc <HAL_ADCEx_InjectedConfigChannel+0xad4>
          {
            LL_ADC_SetCommonPathInternalCh(__LL_ADC_COMMON_INSTANCE(hadc->Instance), LL_ADC_PATH_INTERNAL_VREFINT | tmp_config_internal_channel);
 81032be:	687b      	ldr	r3, [r7, #4]
 81032c0:	681b      	ldr	r3, [r3, #0]
 81032c2:	4a13      	ldr	r2, [pc, #76]	; (8103310 <HAL_ADCEx_InjectedConfigChannel+0xae8>)
 81032c4:	4293      	cmp	r3, r2
 81032c6:	d004      	beq.n	81032d2 <HAL_ADCEx_InjectedConfigChannel+0xaaa>
 81032c8:	687b      	ldr	r3, [r7, #4]
 81032ca:	681b      	ldr	r3, [r3, #0]
 81032cc:	4a11      	ldr	r2, [pc, #68]	; (8103314 <HAL_ADCEx_InjectedConfigChannel+0xaec>)
 81032ce:	4293      	cmp	r3, r2
 81032d0:	d101      	bne.n	81032d6 <HAL_ADCEx_InjectedConfigChannel+0xaae>
 81032d2:	4a12      	ldr	r2, [pc, #72]	; (810331c <HAL_ADCEx_InjectedConfigChannel+0xaf4>)
 81032d4:	e000      	b.n	81032d8 <HAL_ADCEx_InjectedConfigChannel+0xab0>
 81032d6:	4a12      	ldr	r2, [pc, #72]	; (8103320 <HAL_ADCEx_InjectedConfigChannel+0xaf8>)
 81032d8:	f8d7 30d0 	ldr.w	r3, [r7, #208]	; 0xd0
 81032dc:	f443 0380 	orr.w	r3, r3, #4194304	; 0x400000
 81032e0:	4619      	mov	r1, r3
 81032e2:	4610      	mov	r0, r2
 81032e4:	f7ff f990 	bl	8102608 <LL_ADC_SetCommonPathInternalCh>
 81032e8:	e008      	b.n	81032fc <HAL_ADCEx_InjectedConfigChannel+0xad4>
      /* and other ADC of the common group are enabled, internal              */
      /* measurement paths cannot be enabled.                                 */
      else
      {
        /* Update ADC state machine to error */
        SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
 81032ea:	687b      	ldr	r3, [r7, #4]
 81032ec:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 81032ee:	f043 0220 	orr.w	r2, r3, #32
 81032f2:	687b      	ldr	r3, [r7, #4]
 81032f4:	655a      	str	r2, [r3, #84]	; 0x54

        tmp_hal_status = HAL_ERROR;
 81032f6:	2301      	movs	r3, #1
 81032f8:	f887 30e7 	strb.w	r3, [r7, #231]	; 0xe7
    }

  }

  /* Process unlocked */
  __HAL_UNLOCK(hadc);
 81032fc:	687b      	ldr	r3, [r7, #4]
 81032fe:	2200      	movs	r2, #0
 8103300:	f883 2050 	strb.w	r2, [r3, #80]	; 0x50

  /* Return function status */
  return tmp_hal_status;
 8103304:	f897 30e7 	ldrb.w	r3, [r7, #231]	; 0xe7
}
 8103308:	4618      	mov	r0, r3
 810330a:	37ec      	adds	r7, #236	; 0xec
 810330c:	46bd      	mov	sp, r7
 810330e:	bd90      	pop	{r4, r7, pc}
 8103310:	40022000 	.word	0x40022000
 8103314:	40022100 	.word	0x40022100
 8103318:	58026000 	.word	0x58026000
 810331c:	40022300 	.word	0x40022300
 8103320:	58026300 	.word	0x58026300
 8103324:	cb840000 	.word	0xcb840000
 8103328:	10000000 	.word	0x10000000
 810332c:	053e2d63 	.word	0x053e2d63
 8103330:	c7520000 	.word	0xc7520000
 8103334:	cfb80000 	.word	0xcfb80000

08103338 <HAL_ADCEx_DisableInjectedQueue>:
  *         conversion is ongoing.
  * @param hadc ADC handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_ADCEx_DisableInjectedQueue(ADC_HandleTypeDef *hadc)
{
 8103338:	b580      	push	{r7, lr}
 810333a:	b086      	sub	sp, #24
 810333c:	af00      	add	r7, sp, #0
 810333e:	6078      	str	r0, [r7, #4]
  uint32_t tmp_adc_is_conversion_on_going_injected;

  /* Check the parameters */
  assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));

  tmp_adc_is_conversion_on_going_regular = LL_ADC_REG_IsConversionOngoing(hadc->Instance);
 8103340:	687b      	ldr	r3, [r7, #4]
 8103342:	681b      	ldr	r3, [r3, #0]
 8103344:	4618      	mov	r0, r3
 8103346:	f7ff fa48 	bl	81027da <LL_ADC_REG_IsConversionOngoing>
 810334a:	6138      	str	r0, [r7, #16]
  tmp_adc_is_conversion_on_going_injected = LL_ADC_INJ_IsConversionOngoing(hadc->Instance);
 810334c:	687b      	ldr	r3, [r7, #4]
 810334e:	681b      	ldr	r3, [r3, #0]
 8103350:	4618      	mov	r0, r3
 8103352:	f7ff fa55 	bl	8102800 <LL_ADC_INJ_IsConversionOngoing>
 8103356:	60f8      	str	r0, [r7, #12]

  /* Parameter can be set only if no conversion is on-going */
  if ((tmp_adc_is_conversion_on_going_regular == 0UL)
 8103358:	693b      	ldr	r3, [r7, #16]
 810335a:	2b00      	cmp	r3, #0
 810335c:	d10c      	bne.n	8103378 <HAL_ADCEx_DisableInjectedQueue+0x40>
      && (tmp_adc_is_conversion_on_going_injected == 0UL)
 810335e:	68fb      	ldr	r3, [r7, #12]
 8103360:	2b00      	cmp	r3, #0
 8103362:	d109      	bne.n	8103378 <HAL_ADCEx_DisableInjectedQueue+0x40>
     )
  {
    LL_ADC_INJ_SetQueueMode(hadc->Instance, LL_ADC_INJ_QUEUE_DISABLE);
 8103364:	687b      	ldr	r3, [r7, #4]
 8103366:	681b      	ldr	r3, [r3, #0]
 8103368:	f04f 4100 	mov.w	r1, #2147483648	; 0x80000000
 810336c:	4618      	mov	r0, r3
 810336e:	f7ff f9bd 	bl	81026ec <LL_ADC_INJ_SetQueueMode>
    tmp_hal_status = HAL_OK;
 8103372:	2300      	movs	r3, #0
 8103374:	75fb      	strb	r3, [r7, #23]
 8103376:	e001      	b.n	810337c <HAL_ADCEx_DisableInjectedQueue+0x44>
  }
  else
  {
    tmp_hal_status = HAL_ERROR;
 8103378:	2301      	movs	r3, #1
 810337a:	75fb      	strb	r3, [r7, #23]
  }

  return tmp_hal_status;
 810337c:	7dfb      	ldrb	r3, [r7, #23]
}
 810337e:	4618      	mov	r0, r3
 8103380:	3718      	adds	r7, #24
 8103382:	46bd      	mov	sp, r7
 8103384:	bd80      	pop	{r7, pc}
	...

08103388 <__NVIC_SetPriorityGrouping>:
           In case of a conflict between priority grouping and available
           priority bits (__NVIC_PRIO_BITS), the smallest possible priority group is set.
  \param [in]      PriorityGroup  Priority grouping field.
 */
__STATIC_INLINE void __NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
 8103388:	b480      	push	{r7}
 810338a:	b085      	sub	sp, #20
 810338c:	af00      	add	r7, sp, #0
 810338e:	6078      	str	r0, [r7, #4]
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */
 8103390:	687b      	ldr	r3, [r7, #4]
 8103392:	f003 0307 	and.w	r3, r3, #7
 8103396:	60fb      	str	r3, [r7, #12]

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 8103398:	4b0c      	ldr	r3, [pc, #48]	; (81033cc <__NVIC_SetPriorityGrouping+0x44>)
 810339a:	68db      	ldr	r3, [r3, #12]
 810339c:	60bb      	str	r3, [r7, #8]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 810339e:	68ba      	ldr	r2, [r7, #8]
 81033a0:	f64f 03ff 	movw	r3, #63743	; 0xf8ff
 81033a4:	4013      	ands	r3, r2
 81033a6:	60bb      	str	r3, [r7, #8]
  reg_value  =  (reg_value                                   |
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
 81033a8:	68fb      	ldr	r3, [r7, #12]
 81033aa:	021a      	lsls	r2, r3, #8
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
 81033ac:	68bb      	ldr	r3, [r7, #8]
 81033ae:	4313      	orrs	r3, r2
  reg_value  =  (reg_value                                   |
 81033b0:	f043 63bf 	orr.w	r3, r3, #100139008	; 0x5f80000
 81033b4:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 81033b8:	60bb      	str	r3, [r7, #8]
  SCB->AIRCR =  reg_value;
 81033ba:	4a04      	ldr	r2, [pc, #16]	; (81033cc <__NVIC_SetPriorityGrouping+0x44>)
 81033bc:	68bb      	ldr	r3, [r7, #8]
 81033be:	60d3      	str	r3, [r2, #12]
}
 81033c0:	bf00      	nop
 81033c2:	3714      	adds	r7, #20
 81033c4:	46bd      	mov	sp, r7
 81033c6:	f85d 7b04 	ldr.w	r7, [sp], #4
 81033ca:	4770      	bx	lr
 81033cc:	e000ed00 	.word	0xe000ed00

081033d0 <__NVIC_GetPriorityGrouping>:
  \brief   Get Priority Grouping
  \details Reads the priority grouping field from the NVIC Interrupt Controller.
  \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
 */
__STATIC_INLINE uint32_t __NVIC_GetPriorityGrouping(void)
{
 81033d0:	b480      	push	{r7}
 81033d2:	af00      	add	r7, sp, #0
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 81033d4:	4b04      	ldr	r3, [pc, #16]	; (81033e8 <__NVIC_GetPriorityGrouping+0x18>)
 81033d6:	68db      	ldr	r3, [r3, #12]
 81033d8:	0a1b      	lsrs	r3, r3, #8
 81033da:	f003 0307 	and.w	r3, r3, #7
}
 81033de:	4618      	mov	r0, r3
 81033e0:	46bd      	mov	sp, r7
 81033e2:	f85d 7b04 	ldr.w	r7, [sp], #4
 81033e6:	4770      	bx	lr
 81033e8:	e000ed00 	.word	0xe000ed00

081033ec <__NVIC_EnableIRQ>:
  \details Enables a device specific interrupt in the NVIC interrupt controller.
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
{
 81033ec:	b480      	push	{r7}
 81033ee:	b083      	sub	sp, #12
 81033f0:	af00      	add	r7, sp, #0
 81033f2:	4603      	mov	r3, r0
 81033f4:	80fb      	strh	r3, [r7, #6]
  if ((int32_t)(IRQn) >= 0)
 81033f6:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 81033fa:	2b00      	cmp	r3, #0
 81033fc:	db0b      	blt.n	8103416 <__NVIC_EnableIRQ+0x2a>
  {
    __COMPILER_BARRIER();
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 81033fe:	88fb      	ldrh	r3, [r7, #6]
 8103400:	f003 021f 	and.w	r2, r3, #31
 8103404:	4907      	ldr	r1, [pc, #28]	; (8103424 <__NVIC_EnableIRQ+0x38>)
 8103406:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 810340a:	095b      	lsrs	r3, r3, #5
 810340c:	2001      	movs	r0, #1
 810340e:	fa00 f202 	lsl.w	r2, r0, r2
 8103412:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    __COMPILER_BARRIER();
  }
}
 8103416:	bf00      	nop
 8103418:	370c      	adds	r7, #12
 810341a:	46bd      	mov	sp, r7
 810341c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8103420:	4770      	bx	lr
 8103422:	bf00      	nop
 8103424:	e000e100 	.word	0xe000e100

08103428 <__NVIC_SetPriority>:
  \param [in]      IRQn  Interrupt number.
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
 8103428:	b480      	push	{r7}
 810342a:	b083      	sub	sp, #12
 810342c:	af00      	add	r7, sp, #0
 810342e:	4603      	mov	r3, r0
 8103430:	6039      	str	r1, [r7, #0]
 8103432:	80fb      	strh	r3, [r7, #6]
  if ((int32_t)(IRQn) >= 0)
 8103434:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 8103438:	2b00      	cmp	r3, #0
 810343a:	db0a      	blt.n	8103452 <__NVIC_SetPriority+0x2a>
  {
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 810343c:	683b      	ldr	r3, [r7, #0]
 810343e:	b2da      	uxtb	r2, r3
 8103440:	490c      	ldr	r1, [pc, #48]	; (8103474 <__NVIC_SetPriority+0x4c>)
 8103442:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 8103446:	0112      	lsls	r2, r2, #4
 8103448:	b2d2      	uxtb	r2, r2
 810344a:	440b      	add	r3, r1
 810344c:	f883 2300 	strb.w	r2, [r3, #768]	; 0x300
  }
  else
  {
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
  }
}
 8103450:	e00a      	b.n	8103468 <__NVIC_SetPriority+0x40>
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8103452:	683b      	ldr	r3, [r7, #0]
 8103454:	b2da      	uxtb	r2, r3
 8103456:	4908      	ldr	r1, [pc, #32]	; (8103478 <__NVIC_SetPriority+0x50>)
 8103458:	88fb      	ldrh	r3, [r7, #6]
 810345a:	f003 030f 	and.w	r3, r3, #15
 810345e:	3b04      	subs	r3, #4
 8103460:	0112      	lsls	r2, r2, #4
 8103462:	b2d2      	uxtb	r2, r2
 8103464:	440b      	add	r3, r1
 8103466:	761a      	strb	r2, [r3, #24]
}
 8103468:	bf00      	nop
 810346a:	370c      	adds	r7, #12
 810346c:	46bd      	mov	sp, r7
 810346e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8103472:	4770      	bx	lr
 8103474:	e000e100 	.word	0xe000e100
 8103478:	e000ed00 	.word	0xe000ed00

0810347c <NVIC_EncodePriority>:
  \param [in]   PreemptPriority  Preemptive priority value (starting from 0).
  \param [in]       SubPriority  Subpriority value (starting from 0).
  \return                        Encoded priority. Value can be used in the function \ref NVIC_SetPriority().
 */
__STATIC_INLINE uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
{
 810347c:	b480      	push	{r7}
 810347e:	b089      	sub	sp, #36	; 0x24
 8103480:	af00      	add	r7, sp, #0
 8103482:	60f8      	str	r0, [r7, #12]
 8103484:	60b9      	str	r1, [r7, #8]
 8103486:	607a      	str	r2, [r7, #4]
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
 8103488:	68fb      	ldr	r3, [r7, #12]
 810348a:	f003 0307 	and.w	r3, r3, #7
 810348e:	61fb      	str	r3, [r7, #28]
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 8103490:	69fb      	ldr	r3, [r7, #28]
 8103492:	f1c3 0307 	rsb	r3, r3, #7
 8103496:	2b04      	cmp	r3, #4
 8103498:	bf28      	it	cs
 810349a:	2304      	movcs	r3, #4
 810349c:	61bb      	str	r3, [r7, #24]
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 810349e:	69fb      	ldr	r3, [r7, #28]
 81034a0:	3304      	adds	r3, #4
 81034a2:	2b06      	cmp	r3, #6
 81034a4:	d902      	bls.n	81034ac <NVIC_EncodePriority+0x30>
 81034a6:	69fb      	ldr	r3, [r7, #28]
 81034a8:	3b03      	subs	r3, #3
 81034aa:	e000      	b.n	81034ae <NVIC_EncodePriority+0x32>
 81034ac:	2300      	movs	r3, #0
 81034ae:	617b      	str	r3, [r7, #20]

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 81034b0:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 81034b4:	69bb      	ldr	r3, [r7, #24]
 81034b6:	fa02 f303 	lsl.w	r3, r2, r3
 81034ba:	43da      	mvns	r2, r3
 81034bc:	68bb      	ldr	r3, [r7, #8]
 81034be:	401a      	ands	r2, r3
 81034c0:	697b      	ldr	r3, [r7, #20]
 81034c2:	409a      	lsls	r2, r3
           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
 81034c4:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
 81034c8:	697b      	ldr	r3, [r7, #20]
 81034ca:	fa01 f303 	lsl.w	r3, r1, r3
 81034ce:	43d9      	mvns	r1, r3
 81034d0:	687b      	ldr	r3, [r7, #4]
 81034d2:	400b      	ands	r3, r1
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 81034d4:	4313      	orrs	r3, r2
         );
}
 81034d6:	4618      	mov	r0, r3
 81034d8:	3724      	adds	r7, #36	; 0x24
 81034da:	46bd      	mov	sp, r7
 81034dc:	f85d 7b04 	ldr.w	r7, [sp], #4
 81034e0:	4770      	bx	lr
	...

081034e4 <SysTick_Config>:
  \note    When the variable <b>__Vendor_SysTickConfig</b> is set to 1, then the
           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
           must contain a vendor-specific implementation of this function.
 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
 81034e4:	b580      	push	{r7, lr}
 81034e6:	b082      	sub	sp, #8
 81034e8:	af00      	add	r7, sp, #0
 81034ea:	6078      	str	r0, [r7, #4]
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
 81034ec:	687b      	ldr	r3, [r7, #4]
 81034ee:	3b01      	subs	r3, #1
 81034f0:	f1b3 7f80 	cmp.w	r3, #16777216	; 0x1000000
 81034f4:	d301      	bcc.n	81034fa <SysTick_Config+0x16>
  {
    return (1UL);                                                   /* Reload value impossible */
 81034f6:	2301      	movs	r3, #1
 81034f8:	e00f      	b.n	810351a <SysTick_Config+0x36>
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 81034fa:	4a0a      	ldr	r2, [pc, #40]	; (8103524 <SysTick_Config+0x40>)
 81034fc:	687b      	ldr	r3, [r7, #4]
 81034fe:	3b01      	subs	r3, #1
 8103500:	6053      	str	r3, [r2, #4]
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
 8103502:	210f      	movs	r1, #15
 8103504:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8103508:	f7ff ff8e 	bl	8103428 <__NVIC_SetPriority>
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 810350c:	4b05      	ldr	r3, [pc, #20]	; (8103524 <SysTick_Config+0x40>)
 810350e:	2200      	movs	r2, #0
 8103510:	609a      	str	r2, [r3, #8]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 8103512:	4b04      	ldr	r3, [pc, #16]	; (8103524 <SysTick_Config+0x40>)
 8103514:	2207      	movs	r2, #7
 8103516:	601a      	str	r2, [r3, #0]
                   SysTick_CTRL_TICKINT_Msk   |
                   SysTick_CTRL_ENABLE_Msk;                         /* Enable SysTick IRQ and SysTick Timer */
  return (0UL);                                                     /* Function successful */
 8103518:	2300      	movs	r3, #0
}
 810351a:	4618      	mov	r0, r3
 810351c:	3708      	adds	r7, #8
 810351e:	46bd      	mov	sp, r7
 8103520:	bd80      	pop	{r7, pc}
 8103522:	bf00      	nop
 8103524:	e000e010 	.word	0xe000e010

08103528 <HAL_NVIC_SetPriorityGrouping>:
  * @note   When the NVIC_PriorityGroup_0 is selected, IRQ preemption is no more possible.
  *         The pending IRQ priority will be managed only by the subpriority.
  * @retval None
  */
void HAL_NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
 8103528:	b580      	push	{r7, lr}
 810352a:	b082      	sub	sp, #8
 810352c:	af00      	add	r7, sp, #0
 810352e:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup));

  /* Set the PRIGROUP[10:8] bits according to the PriorityGroup parameter value */
  NVIC_SetPriorityGrouping(PriorityGroup);
 8103530:	6878      	ldr	r0, [r7, #4]
 8103532:	f7ff ff29 	bl	8103388 <__NVIC_SetPriorityGrouping>
}
 8103536:	bf00      	nop
 8103538:	3708      	adds	r7, #8
 810353a:	46bd      	mov	sp, r7
 810353c:	bd80      	pop	{r7, pc}

0810353e <HAL_NVIC_SetPriority>:
  *         This parameter can be a value between 0 and 15
  *         A lower priority value indicates a higher priority.
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{
 810353e:	b580      	push	{r7, lr}
 8103540:	b086      	sub	sp, #24
 8103542:	af00      	add	r7, sp, #0
 8103544:	4603      	mov	r3, r0
 8103546:	60b9      	str	r1, [r7, #8]
 8103548:	607a      	str	r2, [r7, #4]
 810354a:	81fb      	strh	r3, [r7, #14]

  /* Check the parameters */
  assert_param(IS_NVIC_SUB_PRIORITY(SubPriority));
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority));

  prioritygroup = NVIC_GetPriorityGrouping();
 810354c:	f7ff ff40 	bl	81033d0 <__NVIC_GetPriorityGrouping>
 8103550:	6178      	str	r0, [r7, #20]

  NVIC_SetPriority(IRQn, NVIC_EncodePriority(prioritygroup, PreemptPriority, SubPriority));
 8103552:	687a      	ldr	r2, [r7, #4]
 8103554:	68b9      	ldr	r1, [r7, #8]
 8103556:	6978      	ldr	r0, [r7, #20]
 8103558:	f7ff ff90 	bl	810347c <NVIC_EncodePriority>
 810355c:	4602      	mov	r2, r0
 810355e:	f9b7 300e 	ldrsh.w	r3, [r7, #14]
 8103562:	4611      	mov	r1, r2
 8103564:	4618      	mov	r0, r3
 8103566:	f7ff ff5f 	bl	8103428 <__NVIC_SetPriority>
}
 810356a:	bf00      	nop
 810356c:	3718      	adds	r7, #24
 810356e:	46bd      	mov	sp, r7
 8103570:	bd80      	pop	{r7, pc}

08103572 <HAL_NVIC_EnableIRQ>:
  *         This parameter can be an enumerator of IRQn_Type enumeration
  *         (For the complete STM32 Devices IRQ Channels list, please refer to the appropriate CMSIS device file (stm32h7xxxx.h))
  * @retval None
  */
void HAL_NVIC_EnableIRQ(IRQn_Type IRQn)
{
 8103572:	b580      	push	{r7, lr}
 8103574:	b082      	sub	sp, #8
 8103576:	af00      	add	r7, sp, #0
 8103578:	4603      	mov	r3, r0
 810357a:	80fb      	strh	r3, [r7, #6]
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));

  /* Enable interrupt */
  NVIC_EnableIRQ(IRQn);
 810357c:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 8103580:	4618      	mov	r0, r3
 8103582:	f7ff ff33 	bl	81033ec <__NVIC_EnableIRQ>
}
 8103586:	bf00      	nop
 8103588:	3708      	adds	r7, #8
 810358a:	46bd      	mov	sp, r7
 810358c:	bd80      	pop	{r7, pc}

0810358e <HAL_SYSTICK_Config>:
  * @param  TicksNumb Specifies the ticks Number of ticks between two interrupts.
  * @retval status   - 0  Function succeeded.
  *                  - 1  Function failed.
  */
uint32_t HAL_SYSTICK_Config(uint32_t TicksNumb)
{
 810358e:	b580      	push	{r7, lr}
 8103590:	b082      	sub	sp, #8
 8103592:	af00      	add	r7, sp, #0
 8103594:	6078      	str	r0, [r7, #4]
   return SysTick_Config(TicksNumb);
 8103596:	6878      	ldr	r0, [r7, #4]
 8103598:	f7ff ffa4 	bl	81034e4 <SysTick_Config>
 810359c:	4603      	mov	r3, r0
}
 810359e:	4618      	mov	r0, r3
 81035a0:	3708      	adds	r7, #8
 81035a2:	46bd      	mov	sp, r7
 81035a4:	bd80      	pop	{r7, pc}
	...

081035a8 <HAL_GetCurrentCPUID>:
/**
  * @brief  Returns the current CPU ID.
  * @retval CPU identifier
  */
uint32_t HAL_GetCurrentCPUID(void)
{
 81035a8:	b480      	push	{r7}
 81035aa:	af00      	add	r7, sp, #0
  if (((SCB->CPUID & 0x000000F0U) >> 4 )== 0x7U)
 81035ac:	4b07      	ldr	r3, [pc, #28]	; (81035cc <HAL_GetCurrentCPUID+0x24>)
 81035ae:	681b      	ldr	r3, [r3, #0]
 81035b0:	091b      	lsrs	r3, r3, #4
 81035b2:	f003 030f 	and.w	r3, r3, #15
 81035b6:	2b07      	cmp	r3, #7
 81035b8:	d101      	bne.n	81035be <HAL_GetCurrentCPUID+0x16>
  {
    return  CM7_CPUID;
 81035ba:	2303      	movs	r3, #3
 81035bc:	e000      	b.n	81035c0 <HAL_GetCurrentCPUID+0x18>
  }
  else
  {
    return CM4_CPUID;
 81035be:	2301      	movs	r3, #1
  }
}
 81035c0:	4618      	mov	r0, r3
 81035c2:	46bd      	mov	sp, r7
 81035c4:	f85d 7b04 	ldr.w	r7, [sp], #4
 81035c8:	4770      	bx	lr
 81035ca:	bf00      	nop
 81035cc:	e000ed00 	.word	0xe000ed00

081035d0 <HAL_ETH_Init>:
  * @param  heth: pointer to a ETH_HandleTypeDef structure that contains
  *         the configuration information for ETHERNET module
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_ETH_Init(ETH_HandleTypeDef *heth)
{
 81035d0:	b580      	push	{r7, lr}
 81035d2:	b084      	sub	sp, #16
 81035d4:	af00      	add	r7, sp, #0
 81035d6:	6078      	str	r0, [r7, #4]
  uint32_t tickstart;

  if (heth == NULL)
 81035d8:	687b      	ldr	r3, [r7, #4]
 81035da:	2b00      	cmp	r3, #0
 81035dc:	d101      	bne.n	81035e2 <HAL_ETH_Init+0x12>
  {
    return HAL_ERROR;
 81035de:	2301      	movs	r3, #1
 81035e0:	e0e7      	b.n	81037b2 <HAL_ETH_Init+0x1e2>
  }
  if (heth->gState == HAL_ETH_STATE_RESET)
 81035e2:	687b      	ldr	r3, [r7, #4]
 81035e4:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 81035e8:	2b00      	cmp	r3, #0
 81035ea:	d106      	bne.n	81035fa <HAL_ETH_Init+0x2a>
  {
    heth->gState = HAL_ETH_STATE_BUSY;
 81035ec:	687b      	ldr	r3, [r7, #4]
 81035ee:	2223      	movs	r2, #35	; 0x23
 81035f0:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84

    /* Init the low level hardware */
    heth->MspInitCallback(heth);
#else
    /* Init the low level hardware : GPIO, CLOCK, NVIC. */
    HAL_ETH_MspInit(heth);
 81035f4:	6878      	ldr	r0, [r7, #4]
 81035f6:	f009 f81d 	bl	810c634 <HAL_ETH_MspInit>

#endif /* (USE_HAL_ETH_REGISTER_CALLBACKS) */
  }

  __HAL_RCC_SYSCFG_CLK_ENABLE();
 81035fa:	4b70      	ldr	r3, [pc, #448]	; (81037bc <HAL_ETH_Init+0x1ec>)
 81035fc:	f8d3 30f4 	ldr.w	r3, [r3, #244]	; 0xf4
 8103600:	4a6e      	ldr	r2, [pc, #440]	; (81037bc <HAL_ETH_Init+0x1ec>)
 8103602:	f043 0302 	orr.w	r3, r3, #2
 8103606:	f8c2 30f4 	str.w	r3, [r2, #244]	; 0xf4
 810360a:	4b6c      	ldr	r3, [pc, #432]	; (81037bc <HAL_ETH_Init+0x1ec>)
 810360c:	f8d3 30f4 	ldr.w	r3, [r3, #244]	; 0xf4
 8103610:	f003 0302 	and.w	r3, r3, #2
 8103614:	60bb      	str	r3, [r7, #8]
 8103616:	68bb      	ldr	r3, [r7, #8]

  if (heth->Init.MediaInterface == HAL_ETH_MII_MODE)
 8103618:	687b      	ldr	r3, [r7, #4]
 810361a:	7a1b      	ldrb	r3, [r3, #8]
 810361c:	2b00      	cmp	r3, #0
 810361e:	d103      	bne.n	8103628 <HAL_ETH_Init+0x58>
  {
    HAL_SYSCFG_ETHInterfaceSelect(SYSCFG_ETH_MII);
 8103620:	2000      	movs	r0, #0
 8103622:	f7fe f847 	bl	81016b4 <HAL_SYSCFG_ETHInterfaceSelect>
 8103626:	e003      	b.n	8103630 <HAL_ETH_Init+0x60>
  }
  else
  {
    HAL_SYSCFG_ETHInterfaceSelect(SYSCFG_ETH_RMII);
 8103628:	f44f 0000 	mov.w	r0, #8388608	; 0x800000
 810362c:	f7fe f842 	bl	81016b4 <HAL_SYSCFG_ETHInterfaceSelect>
  }

  /* Dummy read to sync with ETH */
  (void)SYSCFG->PMCR;
 8103630:	4b63      	ldr	r3, [pc, #396]	; (81037c0 <HAL_ETH_Init+0x1f0>)
 8103632:	685b      	ldr	r3, [r3, #4]

  /* Ethernet Software reset */
  /* Set the SWR bit: resets all MAC subsystem internal registers and logic */
  /* After reset all the registers holds their respective reset values */
  SET_BIT(heth->Instance->DMAMR, ETH_DMAMR_SWR);
 8103634:	687b      	ldr	r3, [r7, #4]
 8103636:	681b      	ldr	r3, [r3, #0]
 8103638:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 810363c:	681b      	ldr	r3, [r3, #0]
 810363e:	687a      	ldr	r2, [r7, #4]
 8103640:	6812      	ldr	r2, [r2, #0]
 8103642:	f043 0301 	orr.w	r3, r3, #1
 8103646:	f502 5280 	add.w	r2, r2, #4096	; 0x1000
 810364a:	6013      	str	r3, [r2, #0]

  /* Get tick */
  tickstart = HAL_GetTick();
 810364c:	f7fd fff6 	bl	810163c <HAL_GetTick>
 8103650:	60f8      	str	r0, [r7, #12]

  /* Wait for software reset */
  while (READ_BIT(heth->Instance->DMAMR, ETH_DMAMR_SWR) > 0U)
 8103652:	e011      	b.n	8103678 <HAL_ETH_Init+0xa8>
  {
    if (((HAL_GetTick() - tickstart) > ETH_SWRESET_TIMEOUT))
 8103654:	f7fd fff2 	bl	810163c <HAL_GetTick>
 8103658:	4602      	mov	r2, r0
 810365a:	68fb      	ldr	r3, [r7, #12]
 810365c:	1ad3      	subs	r3, r2, r3
 810365e:	f5b3 7ffa 	cmp.w	r3, #500	; 0x1f4
 8103662:	d909      	bls.n	8103678 <HAL_ETH_Init+0xa8>
    {
      /* Set Error Code */
      heth->ErrorCode = HAL_ETH_ERROR_TIMEOUT;
 8103664:	687b      	ldr	r3, [r7, #4]
 8103666:	2204      	movs	r2, #4
 8103668:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
      /* Set State as Error */
      heth->gState = HAL_ETH_STATE_ERROR;
 810366c:	687b      	ldr	r3, [r7, #4]
 810366e:	22e0      	movs	r2, #224	; 0xe0
 8103670:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
      /* Return Error */
      return HAL_ERROR;
 8103674:	2301      	movs	r3, #1
 8103676:	e09c      	b.n	81037b2 <HAL_ETH_Init+0x1e2>
  while (READ_BIT(heth->Instance->DMAMR, ETH_DMAMR_SWR) > 0U)
 8103678:	687b      	ldr	r3, [r7, #4]
 810367a:	681b      	ldr	r3, [r3, #0]
 810367c:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 8103680:	681b      	ldr	r3, [r3, #0]
 8103682:	f003 0301 	and.w	r3, r3, #1
 8103686:	2b00      	cmp	r3, #0
 8103688:	d1e4      	bne.n	8103654 <HAL_ETH_Init+0x84>
    }
  }

  /*------------------ MDIO CSR Clock Range Configuration --------------------*/
  HAL_ETH_SetMDIOClockRange(heth);
 810368a:	6878      	ldr	r0, [r7, #4]
 810368c:	f000 fcf6 	bl	810407c <HAL_ETH_SetMDIOClockRange>

  /*------------------ MAC LPI 1US Tic Counter Configuration --------------------*/
  WRITE_REG(heth->Instance->MAC1USTCR, (((uint32_t)HAL_RCC_GetHCLKFreq() / ETH_MAC_US_TICK) - 1U));
 8103690:	f003 fd12 	bl	81070b8 <HAL_RCC_GetHCLKFreq>
 8103694:	4603      	mov	r3, r0
 8103696:	4a4b      	ldr	r2, [pc, #300]	; (81037c4 <HAL_ETH_Init+0x1f4>)
 8103698:	fba2 2303 	umull	r2, r3, r2, r3
 810369c:	0c9a      	lsrs	r2, r3, #18
 810369e:	687b      	ldr	r3, [r7, #4]
 81036a0:	681b      	ldr	r3, [r3, #0]
 81036a2:	3a01      	subs	r2, #1
 81036a4:	f8c3 20dc 	str.w	r2, [r3, #220]	; 0xdc

  /*------------------ MAC, MTL and DMA default Configuration ----------------*/
  ETH_MACDMAConfig(heth);
 81036a8:	6878      	ldr	r0, [r7, #4]
 81036aa:	f000 fed9 	bl	8104460 <ETH_MACDMAConfig>

  /* SET DSL to 64 bit */
  MODIFY_REG(heth->Instance->DMACCR, ETH_DMACCR_DSL, ETH_DMACCR_DSL_64BIT);
 81036ae:	687b      	ldr	r3, [r7, #4]
 81036b0:	681b      	ldr	r3, [r3, #0]
 81036b2:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 81036b6:	f8d3 3100 	ldr.w	r3, [r3, #256]	; 0x100
 81036ba:	f423 13e0 	bic.w	r3, r3, #1835008	; 0x1c0000
 81036be:	687a      	ldr	r2, [r7, #4]
 81036c0:	6812      	ldr	r2, [r2, #0]
 81036c2:	f443 2300 	orr.w	r3, r3, #524288	; 0x80000
 81036c6:	f502 5280 	add.w	r2, r2, #4096	; 0x1000
 81036ca:	f8c2 3100 	str.w	r3, [r2, #256]	; 0x100

  /* Set Receive Buffers Length (must be a multiple of 4) */
  if ((heth->Init.RxBuffLen % 0x4U) != 0x0U)
 81036ce:	687b      	ldr	r3, [r7, #4]
 81036d0:	695b      	ldr	r3, [r3, #20]
 81036d2:	f003 0303 	and.w	r3, r3, #3
 81036d6:	2b00      	cmp	r3, #0
 81036d8:	d009      	beq.n	81036ee <HAL_ETH_Init+0x11e>
  {
    /* Set Error Code */
    heth->ErrorCode = HAL_ETH_ERROR_PARAM;
 81036da:	687b      	ldr	r3, [r7, #4]
 81036dc:	2201      	movs	r2, #1
 81036de:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
    /* Set State as Error */
    heth->gState = HAL_ETH_STATE_ERROR;
 81036e2:	687b      	ldr	r3, [r7, #4]
 81036e4:	22e0      	movs	r2, #224	; 0xe0
 81036e6:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
    /* Return Error */
    return HAL_ERROR;
 81036ea:	2301      	movs	r3, #1
 81036ec:	e061      	b.n	81037b2 <HAL_ETH_Init+0x1e2>
  }
  else
  {
    MODIFY_REG(heth->Instance->DMACRCR, ETH_DMACRCR_RBSZ, ((heth->Init.RxBuffLen) << 1));
 81036ee:	687b      	ldr	r3, [r7, #4]
 81036f0:	681b      	ldr	r3, [r3, #0]
 81036f2:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 81036f6:	f8d3 3108 	ldr.w	r3, [r3, #264]	; 0x108
 81036fa:	f423 43ff 	bic.w	r3, r3, #32640	; 0x7f80
 81036fe:	f023 037e 	bic.w	r3, r3, #126	; 0x7e
 8103702:	687a      	ldr	r2, [r7, #4]
 8103704:	6952      	ldr	r2, [r2, #20]
 8103706:	0051      	lsls	r1, r2, #1
 8103708:	687a      	ldr	r2, [r7, #4]
 810370a:	6812      	ldr	r2, [r2, #0]
 810370c:	430b      	orrs	r3, r1
 810370e:	f502 5280 	add.w	r2, r2, #4096	; 0x1000
 8103712:	f8c2 3108 	str.w	r3, [r2, #264]	; 0x108
  }

  /*------------------ DMA Tx Descriptors Configuration ----------------------*/
  ETH_DMATxDescListInit(heth);
 8103716:	6878      	ldr	r0, [r7, #4]
 8103718:	f000 ff3f 	bl	810459a <ETH_DMATxDescListInit>

  /*------------------ DMA Rx Descriptors Configuration ----------------------*/
  ETH_DMARxDescListInit(heth);
 810371c:	6878      	ldr	r0, [r7, #4]
 810371e:	f000 ff85 	bl	810462c <ETH_DMARxDescListInit>

  /*--------------------- ETHERNET MAC Address Configuration ------------------*/
  /* Set MAC addr bits 32 to 47 */
  heth->Instance->MACA0HR = (((uint32_t)(heth->Init.MACAddr[5]) << 8) | (uint32_t)heth->Init.MACAddr[4]);
 8103722:	687b      	ldr	r3, [r7, #4]
 8103724:	685b      	ldr	r3, [r3, #4]
 8103726:	3305      	adds	r3, #5
 8103728:	781b      	ldrb	r3, [r3, #0]
 810372a:	021a      	lsls	r2, r3, #8
 810372c:	687b      	ldr	r3, [r7, #4]
 810372e:	685b      	ldr	r3, [r3, #4]
 8103730:	3304      	adds	r3, #4
 8103732:	781b      	ldrb	r3, [r3, #0]
 8103734:	4619      	mov	r1, r3
 8103736:	687b      	ldr	r3, [r7, #4]
 8103738:	681b      	ldr	r3, [r3, #0]
 810373a:	430a      	orrs	r2, r1
 810373c:	f8c3 2300 	str.w	r2, [r3, #768]	; 0x300
  /* Set MAC addr bits 0 to 31 */
  heth->Instance->MACA0LR = (((uint32_t)(heth->Init.MACAddr[3]) << 24) | ((uint32_t)(heth->Init.MACAddr[2]) << 16) |
 8103740:	687b      	ldr	r3, [r7, #4]
 8103742:	685b      	ldr	r3, [r3, #4]
 8103744:	3303      	adds	r3, #3
 8103746:	781b      	ldrb	r3, [r3, #0]
 8103748:	061a      	lsls	r2, r3, #24
 810374a:	687b      	ldr	r3, [r7, #4]
 810374c:	685b      	ldr	r3, [r3, #4]
 810374e:	3302      	adds	r3, #2
 8103750:	781b      	ldrb	r3, [r3, #0]
 8103752:	041b      	lsls	r3, r3, #16
 8103754:	431a      	orrs	r2, r3
                             ((uint32_t)(heth->Init.MACAddr[1]) << 8) | (uint32_t)heth->Init.MACAddr[0]);
 8103756:	687b      	ldr	r3, [r7, #4]
 8103758:	685b      	ldr	r3, [r3, #4]
 810375a:	3301      	adds	r3, #1
 810375c:	781b      	ldrb	r3, [r3, #0]
 810375e:	021b      	lsls	r3, r3, #8
  heth->Instance->MACA0LR = (((uint32_t)(heth->Init.MACAddr[3]) << 24) | ((uint32_t)(heth->Init.MACAddr[2]) << 16) |
 8103760:	431a      	orrs	r2, r3
                             ((uint32_t)(heth->Init.MACAddr[1]) << 8) | (uint32_t)heth->Init.MACAddr[0]);
 8103762:	687b      	ldr	r3, [r7, #4]
 8103764:	685b      	ldr	r3, [r3, #4]
 8103766:	781b      	ldrb	r3, [r3, #0]
 8103768:	4619      	mov	r1, r3
  heth->Instance->MACA0LR = (((uint32_t)(heth->Init.MACAddr[3]) << 24) | ((uint32_t)(heth->Init.MACAddr[2]) << 16) |
 810376a:	687b      	ldr	r3, [r7, #4]
 810376c:	681b      	ldr	r3, [r3, #0]
                             ((uint32_t)(heth->Init.MACAddr[1]) << 8) | (uint32_t)heth->Init.MACAddr[0]);
 810376e:	430a      	orrs	r2, r1
  heth->Instance->MACA0LR = (((uint32_t)(heth->Init.MACAddr[3]) << 24) | ((uint32_t)(heth->Init.MACAddr[2]) << 16) |
 8103770:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304

  /* Disable Rx MMC Interrupts */
  SET_BIT(heth->Instance->MMCRIMR, ETH_MMCRIMR_RXLPITRCIM | ETH_MMCRIMR_RXLPIUSCIM | \
 8103774:	687b      	ldr	r3, [r7, #4]
 8103776:	681b      	ldr	r3, [r3, #0]
 8103778:	f8d3 170c 	ldr.w	r1, [r3, #1804]	; 0x70c
 810377c:	687b      	ldr	r3, [r7, #4]
 810377e:	681a      	ldr	r2, [r3, #0]
 8103780:	4b11      	ldr	r3, [pc, #68]	; (81037c8 <HAL_ETH_Init+0x1f8>)
 8103782:	430b      	orrs	r3, r1
 8103784:	f8c2 370c 	str.w	r3, [r2, #1804]	; 0x70c
          ETH_MMCRIMR_RXUCGPIM | ETH_MMCRIMR_RXALGNERPIM | ETH_MMCRIMR_RXCRCERPIM);

  /* Disable Tx MMC Interrupts */
  SET_BIT(heth->Instance->MMCTIMR, ETH_MMCTIMR_TXLPITRCIM | ETH_MMCTIMR_TXLPIUSCIM | \
 8103788:	687b      	ldr	r3, [r7, #4]
 810378a:	681b      	ldr	r3, [r3, #0]
 810378c:	f8d3 3710 	ldr.w	r3, [r3, #1808]	; 0x710
 8103790:	687a      	ldr	r2, [r7, #4]
 8103792:	6812      	ldr	r2, [r2, #0]
 8103794:	f043 6342 	orr.w	r3, r3, #203423744	; 0xc200000
 8103798:	f443 4340 	orr.w	r3, r3, #49152	; 0xc000
 810379c:	f8c2 3710 	str.w	r3, [r2, #1808]	; 0x710
          ETH_MMCTIMR_TXGPKTIM | ETH_MMCTIMR_TXMCOLGPIM | ETH_MMCTIMR_TXSCOLGPIM);

  heth->ErrorCode = HAL_ETH_ERROR_NONE;
 81037a0:	687b      	ldr	r3, [r7, #4]
 81037a2:	2200      	movs	r2, #0
 81037a4:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
  heth->gState = HAL_ETH_STATE_READY;
 81037a8:	687b      	ldr	r3, [r7, #4]
 81037aa:	2210      	movs	r2, #16
 81037ac:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84

  return HAL_OK;
 81037b0:	2300      	movs	r3, #0
}
 81037b2:	4618      	mov	r0, r3
 81037b4:	3710      	adds	r7, #16
 81037b6:	46bd      	mov	sp, r7
 81037b8:	bd80      	pop	{r7, pc}
 81037ba:	bf00      	nop
 81037bc:	58024400 	.word	0x58024400
 81037c0:	58000400 	.word	0x58000400
 81037c4:	431bde83 	.word	0x431bde83
 81037c8:	0c020060 	.word	0x0c020060

081037cc <HAL_ETH_Start>:
  * @param  heth: pointer to a ETH_HandleTypeDef structure that contains
  *         the configuration information for ETHERNET module
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_ETH_Start(ETH_HandleTypeDef *heth)
{
 81037cc:	b580      	push	{r7, lr}
 81037ce:	b082      	sub	sp, #8
 81037d0:	af00      	add	r7, sp, #0
 81037d2:	6078      	str	r0, [r7, #4]
  if (heth->gState == HAL_ETH_STATE_READY)
 81037d4:	687b      	ldr	r3, [r7, #4]
 81037d6:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 81037da:	2b10      	cmp	r3, #16
 81037dc:	d153      	bne.n	8103886 <HAL_ETH_Start+0xba>
  {
    heth->gState = HAL_ETH_STATE_BUSY;
 81037de:	687b      	ldr	r3, [r7, #4]
 81037e0:	2223      	movs	r2, #35	; 0x23
 81037e2:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84

    /* Set number of descriptors to build */
    heth->RxDescList.RxBuildDescCnt = ETH_RX_DESC_CNT;
 81037e6:	687b      	ldr	r3, [r7, #4]
 81037e8:	2204      	movs	r2, #4
 81037ea:	66da      	str	r2, [r3, #108]	; 0x6c

    /* Build all descriptors */
    ETH_UpdateDescriptor(heth);
 81037ec:	6878      	ldr	r0, [r7, #4]
 81037ee:	f000 f936 	bl	8103a5e <ETH_UpdateDescriptor>

    /* Enable the MAC transmission */
    SET_BIT(heth->Instance->MACCR, ETH_MACCR_TE);
 81037f2:	687b      	ldr	r3, [r7, #4]
 81037f4:	681b      	ldr	r3, [r3, #0]
 81037f6:	681a      	ldr	r2, [r3, #0]
 81037f8:	687b      	ldr	r3, [r7, #4]
 81037fa:	681b      	ldr	r3, [r3, #0]
 81037fc:	f042 0202 	orr.w	r2, r2, #2
 8103800:	601a      	str	r2, [r3, #0]

    /* Enable the MAC reception */
    SET_BIT(heth->Instance->MACCR, ETH_MACCR_RE);
 8103802:	687b      	ldr	r3, [r7, #4]
 8103804:	681b      	ldr	r3, [r3, #0]
 8103806:	681a      	ldr	r2, [r3, #0]
 8103808:	687b      	ldr	r3, [r7, #4]
 810380a:	681b      	ldr	r3, [r3, #0]
 810380c:	f042 0201 	orr.w	r2, r2, #1
 8103810:	601a      	str	r2, [r3, #0]

    /* Set the Flush Transmit FIFO bit */
    SET_BIT(heth->Instance->MTLTQOMR, ETH_MTLTQOMR_FTQ);
 8103812:	687b      	ldr	r3, [r7, #4]
 8103814:	681b      	ldr	r3, [r3, #0]
 8103816:	f8d3 2d00 	ldr.w	r2, [r3, #3328]	; 0xd00
 810381a:	687b      	ldr	r3, [r7, #4]
 810381c:	681b      	ldr	r3, [r3, #0]
 810381e:	f042 0201 	orr.w	r2, r2, #1
 8103822:	f8c3 2d00 	str.w	r2, [r3, #3328]	; 0xd00

    /* Enable the DMA transmission */
    SET_BIT(heth->Instance->DMACTCR, ETH_DMACTCR_ST);
 8103826:	687b      	ldr	r3, [r7, #4]
 8103828:	681b      	ldr	r3, [r3, #0]
 810382a:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 810382e:	f8d3 3104 	ldr.w	r3, [r3, #260]	; 0x104
 8103832:	687a      	ldr	r2, [r7, #4]
 8103834:	6812      	ldr	r2, [r2, #0]
 8103836:	f043 0301 	orr.w	r3, r3, #1
 810383a:	f502 5280 	add.w	r2, r2, #4096	; 0x1000
 810383e:	f8c2 3104 	str.w	r3, [r2, #260]	; 0x104

    /* Enable the DMA reception */
    SET_BIT(heth->Instance->DMACRCR, ETH_DMACRCR_SR);
 8103842:	687b      	ldr	r3, [r7, #4]
 8103844:	681b      	ldr	r3, [r3, #0]
 8103846:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 810384a:	f8d3 3108 	ldr.w	r3, [r3, #264]	; 0x108
 810384e:	687a      	ldr	r2, [r7, #4]
 8103850:	6812      	ldr	r2, [r2, #0]
 8103852:	f043 0301 	orr.w	r3, r3, #1
 8103856:	f502 5280 	add.w	r2, r2, #4096	; 0x1000
 810385a:	f8c2 3108 	str.w	r3, [r2, #264]	; 0x108

    /* Clear Tx and Rx process stopped flags */
    heth->Instance->DMACSR |= (ETH_DMACSR_TPS | ETH_DMACSR_RPS);
 810385e:	687b      	ldr	r3, [r7, #4]
 8103860:	681b      	ldr	r3, [r3, #0]
 8103862:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 8103866:	f8d3 3160 	ldr.w	r3, [r3, #352]	; 0x160
 810386a:	687a      	ldr	r2, [r7, #4]
 810386c:	6812      	ldr	r2, [r2, #0]
 810386e:	f443 7381 	orr.w	r3, r3, #258	; 0x102
 8103872:	f502 5280 	add.w	r2, r2, #4096	; 0x1000
 8103876:	f8c2 3160 	str.w	r3, [r2, #352]	; 0x160

    heth->gState = HAL_ETH_STATE_STARTED;
 810387a:	687b      	ldr	r3, [r7, #4]
 810387c:	2223      	movs	r2, #35	; 0x23
 810387e:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84

    return HAL_OK;
 8103882:	2300      	movs	r3, #0
 8103884:	e000      	b.n	8103888 <HAL_ETH_Start+0xbc>
  }
  else
  {
    return HAL_ERROR;
 8103886:	2301      	movs	r3, #1
  }
}
 8103888:	4618      	mov	r0, r3
 810388a:	3708      	adds	r7, #8
 810388c:	46bd      	mov	sp, r7
 810388e:	bd80      	pop	{r7, pc}

08103890 <HAL_ETH_Stop>:
  * @param  heth: pointer to a ETH_HandleTypeDef structure that contains
  *         the configuration information for ETHERNET module
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_ETH_Stop(ETH_HandleTypeDef *heth)
{
 8103890:	b480      	push	{r7}
 8103892:	b083      	sub	sp, #12
 8103894:	af00      	add	r7, sp, #0
 8103896:	6078      	str	r0, [r7, #4]
  if (heth->gState == HAL_ETH_STATE_STARTED)
 8103898:	687b      	ldr	r3, [r7, #4]
 810389a:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 810389e:	2b23      	cmp	r3, #35	; 0x23
 81038a0:	d13f      	bne.n	8103922 <HAL_ETH_Stop+0x92>
  {
    /* Set the ETH peripheral state to BUSY */
    heth->gState = HAL_ETH_STATE_BUSY;
 81038a2:	687b      	ldr	r3, [r7, #4]
 81038a4:	2223      	movs	r2, #35	; 0x23
 81038a6:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84

    /* Disable the DMA transmission */
    CLEAR_BIT(heth->Instance->DMACTCR, ETH_DMACTCR_ST);
 81038aa:	687b      	ldr	r3, [r7, #4]
 81038ac:	681b      	ldr	r3, [r3, #0]
 81038ae:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 81038b2:	f8d3 3104 	ldr.w	r3, [r3, #260]	; 0x104
 81038b6:	687a      	ldr	r2, [r7, #4]
 81038b8:	6812      	ldr	r2, [r2, #0]
 81038ba:	f023 0301 	bic.w	r3, r3, #1
 81038be:	f502 5280 	add.w	r2, r2, #4096	; 0x1000
 81038c2:	f8c2 3104 	str.w	r3, [r2, #260]	; 0x104

    /* Disable the DMA reception */
    CLEAR_BIT(heth->Instance->DMACRCR, ETH_DMACRCR_SR);
 81038c6:	687b      	ldr	r3, [r7, #4]
 81038c8:	681b      	ldr	r3, [r3, #0]
 81038ca:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 81038ce:	f8d3 3108 	ldr.w	r3, [r3, #264]	; 0x108
 81038d2:	687a      	ldr	r2, [r7, #4]
 81038d4:	6812      	ldr	r2, [r2, #0]
 81038d6:	f023 0301 	bic.w	r3, r3, #1
 81038da:	f502 5280 	add.w	r2, r2, #4096	; 0x1000
 81038de:	f8c2 3108 	str.w	r3, [r2, #264]	; 0x108

    /* Disable the MAC reception */
    CLEAR_BIT(heth->Instance->MACCR, ETH_MACCR_RE);
 81038e2:	687b      	ldr	r3, [r7, #4]
 81038e4:	681b      	ldr	r3, [r3, #0]
 81038e6:	681a      	ldr	r2, [r3, #0]
 81038e8:	687b      	ldr	r3, [r7, #4]
 81038ea:	681b      	ldr	r3, [r3, #0]
 81038ec:	f022 0201 	bic.w	r2, r2, #1
 81038f0:	601a      	str	r2, [r3, #0]

    /* Set the Flush Transmit FIFO bit */
    SET_BIT(heth->Instance->MTLTQOMR, ETH_MTLTQOMR_FTQ);
 81038f2:	687b      	ldr	r3, [r7, #4]
 81038f4:	681b      	ldr	r3, [r3, #0]
 81038f6:	f8d3 2d00 	ldr.w	r2, [r3, #3328]	; 0xd00
 81038fa:	687b      	ldr	r3, [r7, #4]
 81038fc:	681b      	ldr	r3, [r3, #0]
 81038fe:	f042 0201 	orr.w	r2, r2, #1
 8103902:	f8c3 2d00 	str.w	r2, [r3, #3328]	; 0xd00

    /* Disable the MAC transmission */
    CLEAR_BIT(heth->Instance->MACCR, ETH_MACCR_TE);
 8103906:	687b      	ldr	r3, [r7, #4]
 8103908:	681b      	ldr	r3, [r3, #0]
 810390a:	681a      	ldr	r2, [r3, #0]
 810390c:	687b      	ldr	r3, [r7, #4]
 810390e:	681b      	ldr	r3, [r3, #0]
 8103910:	f022 0202 	bic.w	r2, r2, #2
 8103914:	601a      	str	r2, [r3, #0]

    heth->gState = HAL_ETH_STATE_READY;
 8103916:	687b      	ldr	r3, [r7, #4]
 8103918:	2210      	movs	r2, #16
 810391a:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84

    /* Return function status */
    return HAL_OK;
 810391e:	2300      	movs	r3, #0
 8103920:	e000      	b.n	8103924 <HAL_ETH_Stop+0x94>
  }
  else
  {
    return HAL_ERROR;
 8103922:	2301      	movs	r3, #1
  }
}
 8103924:	4618      	mov	r0, r3
 8103926:	370c      	adds	r7, #12
 8103928:	46bd      	mov	sp, r7
 810392a:	f85d 7b04 	ldr.w	r7, [sp], #4
 810392e:	4770      	bx	lr

08103930 <HAL_ETH_Transmit>:
  * @param  pTxConfig: Hold the configuration of packet to be transmitted
  * @param  Timeout: timeout value
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_ETH_Transmit(ETH_HandleTypeDef *heth, ETH_TxPacketConfigTypeDef *pTxConfig, uint32_t Timeout)
{
 8103930:	b580      	push	{r7, lr}
 8103932:	b086      	sub	sp, #24
 8103934:	af00      	add	r7, sp, #0
 8103936:	60f8      	str	r0, [r7, #12]
 8103938:	60b9      	str	r1, [r7, #8]
 810393a:	607a      	str	r2, [r7, #4]
  uint32_t tickstart;
  ETH_DMADescTypeDef *dmatxdesc;

  if (pTxConfig == NULL)
 810393c:	68bb      	ldr	r3, [r7, #8]
 810393e:	2b00      	cmp	r3, #0
 8103940:	d109      	bne.n	8103956 <HAL_ETH_Transmit+0x26>
  {
    heth->ErrorCode |= HAL_ETH_ERROR_PARAM;
 8103942:	68fb      	ldr	r3, [r7, #12]
 8103944:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 8103948:	f043 0201 	orr.w	r2, r3, #1
 810394c:	68fb      	ldr	r3, [r7, #12]
 810394e:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
    return HAL_ERROR;
 8103952:	2301      	movs	r3, #1
 8103954:	e07f      	b.n	8103a56 <HAL_ETH_Transmit+0x126>
  }

  if (heth->gState == HAL_ETH_STATE_STARTED)
 8103956:	68fb      	ldr	r3, [r7, #12]
 8103958:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 810395c:	2b23      	cmp	r3, #35	; 0x23
 810395e:	d179      	bne.n	8103a54 <HAL_ETH_Transmit+0x124>
  {
    /* Config DMA Tx descriptor by Tx Packet info */
    if (ETH_Prepare_Tx_Descriptors(heth, pTxConfig, 0) != HAL_ETH_ERROR_NONE)
 8103960:	2200      	movs	r2, #0
 8103962:	68b9      	ldr	r1, [r7, #8]
 8103964:	68f8      	ldr	r0, [r7, #12]
 8103966:	f000 febe 	bl	81046e6 <ETH_Prepare_Tx_Descriptors>
 810396a:	4603      	mov	r3, r0
 810396c:	2b00      	cmp	r3, #0
 810396e:	d009      	beq.n	8103984 <HAL_ETH_Transmit+0x54>
    {
      /* Set the ETH error code */
      heth->ErrorCode |= HAL_ETH_ERROR_BUSY;
 8103970:	68fb      	ldr	r3, [r7, #12]
 8103972:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 8103976:	f043 0202 	orr.w	r2, r3, #2
 810397a:	68fb      	ldr	r3, [r7, #12]
 810397c:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
      return HAL_ERROR;
 8103980:	2301      	movs	r3, #1
 8103982:	e068      	b.n	8103a56 <HAL_ETH_Transmit+0x126>
  __ASM volatile ("dsb 0xF":::"memory");
 8103984:	f3bf 8f4f 	dsb	sy
}
 8103988:	bf00      	nop
    }

    /* Ensure completion of descriptor preparation before transmission start */
    __DSB();

    dmatxdesc = (ETH_DMADescTypeDef *)(&heth->TxDescList)->TxDesc[heth->TxDescList.CurTxDesc];
 810398a:	68fb      	ldr	r3, [r7, #12]
 810398c:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 810398e:	68fb      	ldr	r3, [r7, #12]
 8103990:	3206      	adds	r2, #6
 8103992:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8103996:	617b      	str	r3, [r7, #20]

    /* Incr current tx desc index */
    INCR_TX_DESC_INDEX(heth->TxDescList.CurTxDesc, 1U);
 8103998:	68fb      	ldr	r3, [r7, #12]
 810399a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 810399c:	1c5a      	adds	r2, r3, #1
 810399e:	68fb      	ldr	r3, [r7, #12]
 81039a0:	629a      	str	r2, [r3, #40]	; 0x28
 81039a2:	68fb      	ldr	r3, [r7, #12]
 81039a4:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 81039a6:	2b03      	cmp	r3, #3
 81039a8:	d904      	bls.n	81039b4 <HAL_ETH_Transmit+0x84>
 81039aa:	68fb      	ldr	r3, [r7, #12]
 81039ac:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 81039ae:	1f1a      	subs	r2, r3, #4
 81039b0:	68fb      	ldr	r3, [r7, #12]
 81039b2:	629a      	str	r2, [r3, #40]	; 0x28

    /* Start transmission */
    /* issue a poll command to Tx DMA by writing address of next immediate free descriptor */
    WRITE_REG(heth->Instance->DMACTDTPR, (uint32_t)(heth->TxDescList.TxDesc[heth->TxDescList.CurTxDesc]));
 81039b4:	68fb      	ldr	r3, [r7, #12]
 81039b6:	6a99      	ldr	r1, [r3, #40]	; 0x28
 81039b8:	68fb      	ldr	r3, [r7, #12]
 81039ba:	681a      	ldr	r2, [r3, #0]
 81039bc:	68fb      	ldr	r3, [r7, #12]
 81039be:	3106      	adds	r1, #6
 81039c0:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
 81039c4:	f502 5280 	add.w	r2, r2, #4096	; 0x1000
 81039c8:	f8c2 3120 	str.w	r3, [r2, #288]	; 0x120

    tickstart = HAL_GetTick();
 81039cc:	f7fd fe36 	bl	810163c <HAL_GetTick>
 81039d0:	6138      	str	r0, [r7, #16]

    /* Wait for data to be transmitted or timeout occurred */
    while ((dmatxdesc->DESC3 & ETH_DMATXNDESCWBF_OWN) != (uint32_t)RESET)
 81039d2:	e039      	b.n	8103a48 <HAL_ETH_Transmit+0x118>
    {
      if ((heth->Instance->DMACSR & ETH_DMACSR_FBE) != (uint32_t)RESET)
 81039d4:	68fb      	ldr	r3, [r7, #12]
 81039d6:	681b      	ldr	r3, [r3, #0]
 81039d8:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 81039dc:	f8d3 3160 	ldr.w	r3, [r3, #352]	; 0x160
 81039e0:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
 81039e4:	2b00      	cmp	r3, #0
 81039e6:	d012      	beq.n	8103a0e <HAL_ETH_Transmit+0xde>
      {
        heth->ErrorCode |= HAL_ETH_ERROR_DMA;
 81039e8:	68fb      	ldr	r3, [r7, #12]
 81039ea:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 81039ee:	f043 0208 	orr.w	r2, r3, #8
 81039f2:	68fb      	ldr	r3, [r7, #12]
 81039f4:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
        heth->DMAErrorCode = heth->Instance->DMACSR;
 81039f8:	68fb      	ldr	r3, [r7, #12]
 81039fa:	681b      	ldr	r3, [r3, #0]
 81039fc:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 8103a00:	f8d3 2160 	ldr.w	r2, [r3, #352]	; 0x160
 8103a04:	68fb      	ldr	r3, [r7, #12]
 8103a06:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
        /* Return function status */
        return HAL_ERROR;
 8103a0a:	2301      	movs	r3, #1
 8103a0c:	e023      	b.n	8103a56 <HAL_ETH_Transmit+0x126>
      }

      /* Check for the Timeout */
      if (Timeout != HAL_MAX_DELAY)
 8103a0e:	687b      	ldr	r3, [r7, #4]
 8103a10:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 8103a14:	d018      	beq.n	8103a48 <HAL_ETH_Transmit+0x118>
      {
        if (((HAL_GetTick() - tickstart) > Timeout) || (Timeout == 0U))
 8103a16:	f7fd fe11 	bl	810163c <HAL_GetTick>
 8103a1a:	4602      	mov	r2, r0
 8103a1c:	693b      	ldr	r3, [r7, #16]
 8103a1e:	1ad3      	subs	r3, r2, r3
 8103a20:	687a      	ldr	r2, [r7, #4]
 8103a22:	429a      	cmp	r2, r3
 8103a24:	d302      	bcc.n	8103a2c <HAL_ETH_Transmit+0xfc>
 8103a26:	687b      	ldr	r3, [r7, #4]
 8103a28:	2b00      	cmp	r3, #0
 8103a2a:	d10d      	bne.n	8103a48 <HAL_ETH_Transmit+0x118>
        {
          heth->ErrorCode |= HAL_ETH_ERROR_TIMEOUT;
 8103a2c:	68fb      	ldr	r3, [r7, #12]
 8103a2e:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 8103a32:	f043 0204 	orr.w	r2, r3, #4
 8103a36:	68fb      	ldr	r3, [r7, #12]
 8103a38:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
          /* Clear TX descriptor so that we can proceed */
          dmatxdesc->DESC3 = (ETH_DMATXNDESCWBF_FD | ETH_DMATXNDESCWBF_LD);
 8103a3c:	697b      	ldr	r3, [r7, #20]
 8103a3e:	f04f 5240 	mov.w	r2, #805306368	; 0x30000000
 8103a42:	60da      	str	r2, [r3, #12]
          return HAL_ERROR;
 8103a44:	2301      	movs	r3, #1
 8103a46:	e006      	b.n	8103a56 <HAL_ETH_Transmit+0x126>
    while ((dmatxdesc->DESC3 & ETH_DMATXNDESCWBF_OWN) != (uint32_t)RESET)
 8103a48:	697b      	ldr	r3, [r7, #20]
 8103a4a:	68db      	ldr	r3, [r3, #12]
 8103a4c:	2b00      	cmp	r3, #0
 8103a4e:	dbc1      	blt.n	81039d4 <HAL_ETH_Transmit+0xa4>
        }
      }
    }

    /* Return function status */
    return HAL_OK;
 8103a50:	2300      	movs	r3, #0
 8103a52:	e000      	b.n	8103a56 <HAL_ETH_Transmit+0x126>
  }
  else
  {
    return HAL_ERROR;
 8103a54:	2301      	movs	r3, #1
  }
}
 8103a56:	4618      	mov	r0, r3
 8103a58:	3718      	adds	r7, #24
 8103a5a:	46bd      	mov	sp, r7
 8103a5c:	bd80      	pop	{r7, pc}

08103a5e <ETH_UpdateDescriptor>:
  * @param  heth: pointer to a ETH_HandleTypeDef structure that contains
  *         the configuration information for ETHERNET module
  * @retval HAL status
  */
static void ETH_UpdateDescriptor(ETH_HandleTypeDef *heth)
{
 8103a5e:	b580      	push	{r7, lr}
 8103a60:	b088      	sub	sp, #32
 8103a62:	af00      	add	r7, sp, #0
 8103a64:	6078      	str	r0, [r7, #4]
  uint32_t descidx;
  uint32_t tailidx;
  uint32_t desccount;
  ETH_DMADescTypeDef *dmarxdesc;
  uint8_t *buff = NULL;
 8103a66:	2300      	movs	r3, #0
 8103a68:	60bb      	str	r3, [r7, #8]
  uint8_t allocStatus = 1U;
 8103a6a:	2301      	movs	r3, #1
 8103a6c:	74fb      	strb	r3, [r7, #19]

  descidx = heth->RxDescList.RxBuildDescIdx;
 8103a6e:	687b      	ldr	r3, [r7, #4]
 8103a70:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 8103a72:	61fb      	str	r3, [r7, #28]
  dmarxdesc = (ETH_DMADescTypeDef *)heth->RxDescList.RxDesc[descidx];
 8103a74:	687b      	ldr	r3, [r7, #4]
 8103a76:	69fa      	ldr	r2, [r7, #28]
 8103a78:	3212      	adds	r2, #18
 8103a7a:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8103a7e:	617b      	str	r3, [r7, #20]
  desccount = heth->RxDescList.RxBuildDescCnt;
 8103a80:	687b      	ldr	r3, [r7, #4]
 8103a82:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 8103a84:	61bb      	str	r3, [r7, #24]

  while ((desccount > 0U) && (allocStatus != 0U))
 8103a86:	e038      	b.n	8103afa <ETH_UpdateDescriptor+0x9c>
  {
    /* Check if a buffer's attached the descriptor */
    if (READ_REG(dmarxdesc->BackupAddr0) == 0U)
 8103a88:	697b      	ldr	r3, [r7, #20]
 8103a8a:	691b      	ldr	r3, [r3, #16]
 8103a8c:	2b00      	cmp	r3, #0
 8103a8e:	d112      	bne.n	8103ab6 <ETH_UpdateDescriptor+0x58>
#if (USE_HAL_ETH_REGISTER_CALLBACKS == 1)
      /*Call registered Allocate callback*/
      heth->rxAllocateCallback(&buff);
#else
      /* Allocate callback */
      HAL_ETH_RxAllocateCallback(&buff);
 8103a90:	f107 0308 	add.w	r3, r7, #8
 8103a94:	4618      	mov	r0, r3
 8103a96:	f008 ff75 	bl	810c984 <HAL_ETH_RxAllocateCallback>
#endif  /* USE_HAL_ETH_REGISTER_CALLBACKS */
      if (buff == NULL)
 8103a9a:	68bb      	ldr	r3, [r7, #8]
 8103a9c:	2b00      	cmp	r3, #0
 8103a9e:	d102      	bne.n	8103aa6 <ETH_UpdateDescriptor+0x48>
      {
        allocStatus = 0U;
 8103aa0:	2300      	movs	r3, #0
 8103aa2:	74fb      	strb	r3, [r7, #19]
 8103aa4:	e007      	b.n	8103ab6 <ETH_UpdateDescriptor+0x58>
      }
      else
      {
        WRITE_REG(dmarxdesc->BackupAddr0, (uint32_t)buff);
 8103aa6:	68bb      	ldr	r3, [r7, #8]
 8103aa8:	461a      	mov	r2, r3
 8103aaa:	697b      	ldr	r3, [r7, #20]
 8103aac:	611a      	str	r2, [r3, #16]
        WRITE_REG(dmarxdesc->DESC0, (uint32_t)buff);
 8103aae:	68bb      	ldr	r3, [r7, #8]
 8103ab0:	461a      	mov	r2, r3
 8103ab2:	697b      	ldr	r3, [r7, #20]
 8103ab4:	601a      	str	r2, [r3, #0]
      }
    }

    if (allocStatus != 0U)
 8103ab6:	7cfb      	ldrb	r3, [r7, #19]
 8103ab8:	2b00      	cmp	r3, #0
 8103aba:	d01e      	beq.n	8103afa <ETH_UpdateDescriptor+0x9c>
    {

      if (heth->RxDescList.ItMode != 0U)
 8103abc:	687b      	ldr	r3, [r7, #4]
 8103abe:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8103ac0:	2b00      	cmp	r3, #0
 8103ac2:	d004      	beq.n	8103ace <ETH_UpdateDescriptor+0x70>
      {
        WRITE_REG(dmarxdesc->DESC3, ETH_DMARXNDESCRF_OWN | ETH_DMARXNDESCRF_BUF1V | ETH_DMARXNDESCRF_IOC);
 8103ac4:	697b      	ldr	r3, [r7, #20]
 8103ac6:	f04f 4241 	mov.w	r2, #3238002688	; 0xc1000000
 8103aca:	60da      	str	r2, [r3, #12]
 8103acc:	e003      	b.n	8103ad6 <ETH_UpdateDescriptor+0x78>
      }
      else
      {
        WRITE_REG(dmarxdesc->DESC3, ETH_DMARXNDESCRF_OWN | ETH_DMARXNDESCRF_BUF1V);
 8103ace:	697b      	ldr	r3, [r7, #20]
 8103ad0:	f04f 4201 	mov.w	r2, #2164260864	; 0x81000000
 8103ad4:	60da      	str	r2, [r3, #12]
      }

      /* Increment current rx descriptor index */
      INCR_RX_DESC_INDEX(descidx, 1U);
 8103ad6:	69fb      	ldr	r3, [r7, #28]
 8103ad8:	3301      	adds	r3, #1
 8103ada:	61fb      	str	r3, [r7, #28]
 8103adc:	69fb      	ldr	r3, [r7, #28]
 8103ade:	2b03      	cmp	r3, #3
 8103ae0:	d902      	bls.n	8103ae8 <ETH_UpdateDescriptor+0x8a>
 8103ae2:	69fb      	ldr	r3, [r7, #28]
 8103ae4:	3b04      	subs	r3, #4
 8103ae6:	61fb      	str	r3, [r7, #28]
      /* Get current descriptor address */
      dmarxdesc = (ETH_DMADescTypeDef *)heth->RxDescList.RxDesc[descidx];
 8103ae8:	687b      	ldr	r3, [r7, #4]
 8103aea:	69fa      	ldr	r2, [r7, #28]
 8103aec:	3212      	adds	r2, #18
 8103aee:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8103af2:	617b      	str	r3, [r7, #20]
      desccount--;
 8103af4:	69bb      	ldr	r3, [r7, #24]
 8103af6:	3b01      	subs	r3, #1
 8103af8:	61bb      	str	r3, [r7, #24]
  while ((desccount > 0U) && (allocStatus != 0U))
 8103afa:	69bb      	ldr	r3, [r7, #24]
 8103afc:	2b00      	cmp	r3, #0
 8103afe:	d002      	beq.n	8103b06 <ETH_UpdateDescriptor+0xa8>
 8103b00:	7cfb      	ldrb	r3, [r7, #19]
 8103b02:	2b00      	cmp	r3, #0
 8103b04:	d1c0      	bne.n	8103a88 <ETH_UpdateDescriptor+0x2a>
    }
  }

  if (heth->RxDescList.RxBuildDescCnt != desccount)
 8103b06:	687b      	ldr	r3, [r7, #4]
 8103b08:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 8103b0a:	69ba      	ldr	r2, [r7, #24]
 8103b0c:	429a      	cmp	r2, r3
 8103b0e:	d01b      	beq.n	8103b48 <ETH_UpdateDescriptor+0xea>
  {
    /* Set the tail pointer index */
    tailidx = (descidx + 1U) % ETH_RX_DESC_CNT;
 8103b10:	69fb      	ldr	r3, [r7, #28]
 8103b12:	3301      	adds	r3, #1
 8103b14:	f003 0303 	and.w	r3, r3, #3
 8103b18:	60fb      	str	r3, [r7, #12]
  __ASM volatile ("dmb 0xF":::"memory");
 8103b1a:	f3bf 8f5f 	dmb	sy
}
 8103b1e:	bf00      	nop

    /* DMB instruction to avoid race condition */
    __DMB();

    /* Set the Tail pointer address */
    WRITE_REG(heth->Instance->DMACRDTPR, ((uint32_t)(heth->Init.RxDesc + (tailidx))));
 8103b20:	687b      	ldr	r3, [r7, #4]
 8103b22:	6919      	ldr	r1, [r3, #16]
 8103b24:	68fa      	ldr	r2, [r7, #12]
 8103b26:	4613      	mov	r3, r2
 8103b28:	005b      	lsls	r3, r3, #1
 8103b2a:	4413      	add	r3, r2
 8103b2c:	00db      	lsls	r3, r3, #3
 8103b2e:	18ca      	adds	r2, r1, r3
 8103b30:	687b      	ldr	r3, [r7, #4]
 8103b32:	681b      	ldr	r3, [r3, #0]
 8103b34:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 8103b38:	f8c3 2128 	str.w	r2, [r3, #296]	; 0x128

    heth->RxDescList.RxBuildDescIdx = descidx;
 8103b3c:	687b      	ldr	r3, [r7, #4]
 8103b3e:	69fa      	ldr	r2, [r7, #28]
 8103b40:	669a      	str	r2, [r3, #104]	; 0x68
    heth->RxDescList.RxBuildDescCnt = desccount;
 8103b42:	687b      	ldr	r3, [r7, #4]
 8103b44:	69ba      	ldr	r2, [r7, #24]
 8103b46:	66da      	str	r2, [r3, #108]	; 0x6c
  }
}
 8103b48:	bf00      	nop
 8103b4a:	3720      	adds	r7, #32
 8103b4c:	46bd      	mov	sp, r7
 8103b4e:	bd80      	pop	{r7, pc}

08103b50 <HAL_ETH_ReadPHYRegister>:
  * @param pRegValue: parameter to hold read value
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_ETH_ReadPHYRegister(ETH_HandleTypeDef *heth, uint32_t PHYAddr, uint32_t PHYReg,
                                          uint32_t *pRegValue)
{
 8103b50:	b580      	push	{r7, lr}
 8103b52:	b086      	sub	sp, #24
 8103b54:	af00      	add	r7, sp, #0
 8103b56:	60f8      	str	r0, [r7, #12]
 8103b58:	60b9      	str	r1, [r7, #8]
 8103b5a:	607a      	str	r2, [r7, #4]
 8103b5c:	603b      	str	r3, [r7, #0]
  uint32_t tickstart;
  uint32_t tmpreg;

  /* Check for the Busy flag */
  if (READ_BIT(heth->Instance->MACMDIOAR, ETH_MACMDIOAR_MB) != (uint32_t)RESET)
 8103b5e:	68fb      	ldr	r3, [r7, #12]
 8103b60:	681b      	ldr	r3, [r3, #0]
 8103b62:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
 8103b66:	f003 0301 	and.w	r3, r3, #1
 8103b6a:	2b00      	cmp	r3, #0
 8103b6c:	d001      	beq.n	8103b72 <HAL_ETH_ReadPHYRegister+0x22>
  {
    return HAL_ERROR;
 8103b6e:	2301      	movs	r3, #1
 8103b70:	e03e      	b.n	8103bf0 <HAL_ETH_ReadPHYRegister+0xa0>
  }

  /* Get the  MACMDIOAR value */
  WRITE_REG(tmpreg, heth->Instance->MACMDIOAR);
 8103b72:	68fb      	ldr	r3, [r7, #12]
 8103b74:	681b      	ldr	r3, [r3, #0]
 8103b76:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
 8103b7a:	617b      	str	r3, [r7, #20]
     - Set the PHY device address
     - Set the PHY register address
     - Set the read mode
     - Set the MII Busy bit */

  MODIFY_REG(tmpreg, ETH_MACMDIOAR_PA, (PHYAddr << 21));
 8103b7c:	697b      	ldr	r3, [r7, #20]
 8103b7e:	f023 7278 	bic.w	r2, r3, #65011712	; 0x3e00000
 8103b82:	68bb      	ldr	r3, [r7, #8]
 8103b84:	055b      	lsls	r3, r3, #21
 8103b86:	4313      	orrs	r3, r2
 8103b88:	617b      	str	r3, [r7, #20]
  MODIFY_REG(tmpreg, ETH_MACMDIOAR_RDA, (PHYReg << 16));
 8103b8a:	697b      	ldr	r3, [r7, #20]
 8103b8c:	f423 12f8 	bic.w	r2, r3, #2031616	; 0x1f0000
 8103b90:	687b      	ldr	r3, [r7, #4]
 8103b92:	041b      	lsls	r3, r3, #16
 8103b94:	4313      	orrs	r3, r2
 8103b96:	617b      	str	r3, [r7, #20]
  MODIFY_REG(tmpreg, ETH_MACMDIOAR_MOC, ETH_MACMDIOAR_MOC_RD);
 8103b98:	697b      	ldr	r3, [r7, #20]
 8103b9a:	f043 030c 	orr.w	r3, r3, #12
 8103b9e:	617b      	str	r3, [r7, #20]
  SET_BIT(tmpreg, ETH_MACMDIOAR_MB);
 8103ba0:	697b      	ldr	r3, [r7, #20]
 8103ba2:	f043 0301 	orr.w	r3, r3, #1
 8103ba6:	617b      	str	r3, [r7, #20]

  /* Write the result value into the MDII Address register */
  WRITE_REG(heth->Instance->MACMDIOAR, tmpreg);
 8103ba8:	68fb      	ldr	r3, [r7, #12]
 8103baa:	681b      	ldr	r3, [r3, #0]
 8103bac:	697a      	ldr	r2, [r7, #20]
 8103bae:	f8c3 2200 	str.w	r2, [r3, #512]	; 0x200

  tickstart = HAL_GetTick();
 8103bb2:	f7fd fd43 	bl	810163c <HAL_GetTick>
 8103bb6:	6138      	str	r0, [r7, #16]

  /* Wait for the Busy flag */
  while (READ_BIT(heth->Instance->MACMDIOAR, ETH_MACMDIOAR_MB) > 0U)
 8103bb8:	e009      	b.n	8103bce <HAL_ETH_ReadPHYRegister+0x7e>
  {
    if (((HAL_GetTick() - tickstart) > ETH_MDIO_BUS_TIMEOUT))
 8103bba:	f7fd fd3f 	bl	810163c <HAL_GetTick>
 8103bbe:	4602      	mov	r2, r0
 8103bc0:	693b      	ldr	r3, [r7, #16]
 8103bc2:	1ad3      	subs	r3, r2, r3
 8103bc4:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
 8103bc8:	d901      	bls.n	8103bce <HAL_ETH_ReadPHYRegister+0x7e>
    {
      return HAL_ERROR;
 8103bca:	2301      	movs	r3, #1
 8103bcc:	e010      	b.n	8103bf0 <HAL_ETH_ReadPHYRegister+0xa0>
  while (READ_BIT(heth->Instance->MACMDIOAR, ETH_MACMDIOAR_MB) > 0U)
 8103bce:	68fb      	ldr	r3, [r7, #12]
 8103bd0:	681b      	ldr	r3, [r3, #0]
 8103bd2:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
 8103bd6:	f003 0301 	and.w	r3, r3, #1
 8103bda:	2b00      	cmp	r3, #0
 8103bdc:	d1ed      	bne.n	8103bba <HAL_ETH_ReadPHYRegister+0x6a>
    }
  }

  /* Get MACMIIDR value */
  WRITE_REG(*pRegValue, (uint16_t)heth->Instance->MACMDIODR);
 8103bde:	68fb      	ldr	r3, [r7, #12]
 8103be0:	681b      	ldr	r3, [r3, #0]
 8103be2:	f8d3 3204 	ldr.w	r3, [r3, #516]	; 0x204
 8103be6:	b29b      	uxth	r3, r3
 8103be8:	461a      	mov	r2, r3
 8103bea:	683b      	ldr	r3, [r7, #0]
 8103bec:	601a      	str	r2, [r3, #0]

  return HAL_OK;
 8103bee:	2300      	movs	r3, #0
}
 8103bf0:	4618      	mov	r0, r3
 8103bf2:	3718      	adds	r7, #24
 8103bf4:	46bd      	mov	sp, r7
 8103bf6:	bd80      	pop	{r7, pc}

08103bf8 <HAL_ETH_WritePHYRegister>:
  * @param  RegValue: the value to write
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_ETH_WritePHYRegister(const ETH_HandleTypeDef *heth, uint32_t PHYAddr, uint32_t PHYReg,
                                           uint32_t RegValue)
{
 8103bf8:	b580      	push	{r7, lr}
 8103bfa:	b086      	sub	sp, #24
 8103bfc:	af00      	add	r7, sp, #0
 8103bfe:	60f8      	str	r0, [r7, #12]
 8103c00:	60b9      	str	r1, [r7, #8]
 8103c02:	607a      	str	r2, [r7, #4]
 8103c04:	603b      	str	r3, [r7, #0]
  uint32_t tickstart;
  uint32_t tmpreg;

  /* Check for the Busy flag */
  if (READ_BIT(heth->Instance->MACMDIOAR, ETH_MACMDIOAR_MB) != (uint32_t)RESET)
 8103c06:	68fb      	ldr	r3, [r7, #12]
 8103c08:	681b      	ldr	r3, [r3, #0]
 8103c0a:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
 8103c0e:	f003 0301 	and.w	r3, r3, #1
 8103c12:	2b00      	cmp	r3, #0
 8103c14:	d001      	beq.n	8103c1a <HAL_ETH_WritePHYRegister+0x22>
  {
    return HAL_ERROR;
 8103c16:	2301      	movs	r3, #1
 8103c18:	e03c      	b.n	8103c94 <HAL_ETH_WritePHYRegister+0x9c>
  }

  /* Get the  MACMDIOAR value */
  WRITE_REG(tmpreg, heth->Instance->MACMDIOAR);
 8103c1a:	68fb      	ldr	r3, [r7, #12]
 8103c1c:	681b      	ldr	r3, [r3, #0]
 8103c1e:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
 8103c22:	617b      	str	r3, [r7, #20]
     - Set the PHY device address
     - Set the PHY register address
     - Set the write mode
     - Set the MII Busy bit */

  MODIFY_REG(tmpreg, ETH_MACMDIOAR_PA, (PHYAddr << 21));
 8103c24:	697b      	ldr	r3, [r7, #20]
 8103c26:	f023 7278 	bic.w	r2, r3, #65011712	; 0x3e00000
 8103c2a:	68bb      	ldr	r3, [r7, #8]
 8103c2c:	055b      	lsls	r3, r3, #21
 8103c2e:	4313      	orrs	r3, r2
 8103c30:	617b      	str	r3, [r7, #20]
  MODIFY_REG(tmpreg, ETH_MACMDIOAR_RDA, (PHYReg << 16));
 8103c32:	697b      	ldr	r3, [r7, #20]
 8103c34:	f423 12f8 	bic.w	r2, r3, #2031616	; 0x1f0000
 8103c38:	687b      	ldr	r3, [r7, #4]
 8103c3a:	041b      	lsls	r3, r3, #16
 8103c3c:	4313      	orrs	r3, r2
 8103c3e:	617b      	str	r3, [r7, #20]
  MODIFY_REG(tmpreg, ETH_MACMDIOAR_MOC, ETH_MACMDIOAR_MOC_WR);
 8103c40:	697b      	ldr	r3, [r7, #20]
 8103c42:	f023 030c 	bic.w	r3, r3, #12
 8103c46:	f043 0304 	orr.w	r3, r3, #4
 8103c4a:	617b      	str	r3, [r7, #20]
  SET_BIT(tmpreg, ETH_MACMDIOAR_MB);
 8103c4c:	697b      	ldr	r3, [r7, #20]
 8103c4e:	f043 0301 	orr.w	r3, r3, #1
 8103c52:	617b      	str	r3, [r7, #20]

  /* Give the value to the MII data register */
  WRITE_REG(ETH->MACMDIODR, (uint16_t)RegValue);
 8103c54:	683b      	ldr	r3, [r7, #0]
 8103c56:	b29a      	uxth	r2, r3
 8103c58:	4b10      	ldr	r3, [pc, #64]	; (8103c9c <HAL_ETH_WritePHYRegister+0xa4>)
 8103c5a:	f8c3 2204 	str.w	r2, [r3, #516]	; 0x204

  /* Write the result value into the MII Address register */
  WRITE_REG(ETH->MACMDIOAR, tmpreg);
 8103c5e:	4a0f      	ldr	r2, [pc, #60]	; (8103c9c <HAL_ETH_WritePHYRegister+0xa4>)
 8103c60:	697b      	ldr	r3, [r7, #20]
 8103c62:	f8c2 3200 	str.w	r3, [r2, #512]	; 0x200

  tickstart = HAL_GetTick();
 8103c66:	f7fd fce9 	bl	810163c <HAL_GetTick>
 8103c6a:	6138      	str	r0, [r7, #16]

  /* Wait for the Busy flag */
  while (READ_BIT(heth->Instance->MACMDIOAR, ETH_MACMDIOAR_MB) > 0U)
 8103c6c:	e009      	b.n	8103c82 <HAL_ETH_WritePHYRegister+0x8a>
  {
    if (((HAL_GetTick() - tickstart) > ETH_MDIO_BUS_TIMEOUT))
 8103c6e:	f7fd fce5 	bl	810163c <HAL_GetTick>
 8103c72:	4602      	mov	r2, r0
 8103c74:	693b      	ldr	r3, [r7, #16]
 8103c76:	1ad3      	subs	r3, r2, r3
 8103c78:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
 8103c7c:	d901      	bls.n	8103c82 <HAL_ETH_WritePHYRegister+0x8a>
    {
      return HAL_ERROR;
 8103c7e:	2301      	movs	r3, #1
 8103c80:	e008      	b.n	8103c94 <HAL_ETH_WritePHYRegister+0x9c>
  while (READ_BIT(heth->Instance->MACMDIOAR, ETH_MACMDIOAR_MB) > 0U)
 8103c82:	68fb      	ldr	r3, [r7, #12]
 8103c84:	681b      	ldr	r3, [r3, #0]
 8103c86:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
 8103c8a:	f003 0301 	and.w	r3, r3, #1
 8103c8e:	2b00      	cmp	r3, #0
 8103c90:	d1ed      	bne.n	8103c6e <HAL_ETH_WritePHYRegister+0x76>
    }
  }

  return HAL_OK;
 8103c92:	2300      	movs	r3, #0
}
 8103c94:	4618      	mov	r0, r3
 8103c96:	3718      	adds	r7, #24
 8103c98:	46bd      	mov	sp, r7
 8103c9a:	bd80      	pop	{r7, pc}
 8103c9c:	40028000 	.word	0x40028000

08103ca0 <HAL_ETH_GetMACConfig>:
  * @param  macconf: pointer to a ETH_MACConfigTypeDef structure that will hold
  *         the configuration of the MAC.
  * @retval HAL Status
  */
HAL_StatusTypeDef HAL_ETH_GetMACConfig(const ETH_HandleTypeDef *heth, ETH_MACConfigTypeDef *macconf)
{
 8103ca0:	b480      	push	{r7}
 8103ca2:	b083      	sub	sp, #12
 8103ca4:	af00      	add	r7, sp, #0
 8103ca6:	6078      	str	r0, [r7, #4]
 8103ca8:	6039      	str	r1, [r7, #0]
  if (macconf == NULL)
 8103caa:	683b      	ldr	r3, [r7, #0]
 8103cac:	2b00      	cmp	r3, #0
 8103cae:	d101      	bne.n	8103cb4 <HAL_ETH_GetMACConfig+0x14>
  {
    return HAL_ERROR;
 8103cb0:	2301      	movs	r3, #1
 8103cb2:	e1c3      	b.n	810403c <HAL_ETH_GetMACConfig+0x39c>
  }

  /* Get MAC parameters */
  macconf->PreambleLength = READ_BIT(heth->Instance->MACCR, ETH_MACCR_PRELEN);
 8103cb4:	687b      	ldr	r3, [r7, #4]
 8103cb6:	681b      	ldr	r3, [r3, #0]
 8103cb8:	681b      	ldr	r3, [r3, #0]
 8103cba:	f003 020c 	and.w	r2, r3, #12
 8103cbe:	683b      	ldr	r3, [r7, #0]
 8103cc0:	62da      	str	r2, [r3, #44]	; 0x2c
  macconf->DeferralCheck = ((READ_BIT(heth->Instance->MACCR, ETH_MACCR_DC) >> 4) > 0U) ? ENABLE : DISABLE;
 8103cc2:	687b      	ldr	r3, [r7, #4]
 8103cc4:	681b      	ldr	r3, [r3, #0]
 8103cc6:	681b      	ldr	r3, [r3, #0]
 8103cc8:	f003 0310 	and.w	r3, r3, #16
 8103ccc:	2b00      	cmp	r3, #0
 8103cce:	bf14      	ite	ne
 8103cd0:	2301      	movne	r3, #1
 8103cd2:	2300      	moveq	r3, #0
 8103cd4:	b2db      	uxtb	r3, r3
 8103cd6:	461a      	mov	r2, r3
 8103cd8:	683b      	ldr	r3, [r7, #0]
 8103cda:	f883 2028 	strb.w	r2, [r3, #40]	; 0x28
  macconf->BackOffLimit = READ_BIT(heth->Instance->MACCR, ETH_MACCR_BL);
 8103cde:	687b      	ldr	r3, [r7, #4]
 8103ce0:	681b      	ldr	r3, [r3, #0]
 8103ce2:	681b      	ldr	r3, [r3, #0]
 8103ce4:	f003 0260 	and.w	r2, r3, #96	; 0x60
 8103ce8:	683b      	ldr	r3, [r7, #0]
 8103cea:	625a      	str	r2, [r3, #36]	; 0x24
  macconf->RetryTransmission = ((READ_BIT(heth->Instance->MACCR, ETH_MACCR_DR) >> 8) == 0U) ? ENABLE : DISABLE;
 8103cec:	687b      	ldr	r3, [r7, #4]
 8103cee:	681b      	ldr	r3, [r3, #0]
 8103cf0:	681b      	ldr	r3, [r3, #0]
 8103cf2:	f403 7380 	and.w	r3, r3, #256	; 0x100
 8103cf6:	2b00      	cmp	r3, #0
 8103cf8:	bf0c      	ite	eq
 8103cfa:	2301      	moveq	r3, #1
 8103cfc:	2300      	movne	r3, #0
 8103cfe:	b2db      	uxtb	r3, r3
 8103d00:	461a      	mov	r2, r3
 8103d02:	683b      	ldr	r3, [r7, #0]
 8103d04:	f883 2020 	strb.w	r2, [r3, #32]
  macconf->CarrierSenseDuringTransmit = ((READ_BIT(heth->Instance->MACCR, ETH_MACCR_DCRS) >> 9) > 0U)
 8103d08:	687b      	ldr	r3, [r7, #4]
 8103d0a:	681b      	ldr	r3, [r3, #0]
 8103d0c:	681b      	ldr	r3, [r3, #0]
 8103d0e:	f403 7300 	and.w	r3, r3, #512	; 0x200
                                        ? ENABLE : DISABLE;
 8103d12:	2b00      	cmp	r3, #0
 8103d14:	bf14      	ite	ne
 8103d16:	2301      	movne	r3, #1
 8103d18:	2300      	moveq	r3, #0
 8103d1a:	b2db      	uxtb	r3, r3
 8103d1c:	461a      	mov	r2, r3
  macconf->CarrierSenseDuringTransmit = ((READ_BIT(heth->Instance->MACCR, ETH_MACCR_DCRS) >> 9) > 0U)
 8103d1e:	683b      	ldr	r3, [r7, #0]
 8103d20:	77da      	strb	r2, [r3, #31]
  macconf->ReceiveOwn = ((READ_BIT(heth->Instance->MACCR, ETH_MACCR_DO) >> 10) == 0U) ? ENABLE : DISABLE;
 8103d22:	687b      	ldr	r3, [r7, #4]
 8103d24:	681b      	ldr	r3, [r3, #0]
 8103d26:	681b      	ldr	r3, [r3, #0]
 8103d28:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 8103d2c:	2b00      	cmp	r3, #0
 8103d2e:	bf0c      	ite	eq
 8103d30:	2301      	moveq	r3, #1
 8103d32:	2300      	movne	r3, #0
 8103d34:	b2db      	uxtb	r3, r3
 8103d36:	461a      	mov	r2, r3
 8103d38:	683b      	ldr	r3, [r7, #0]
 8103d3a:	779a      	strb	r2, [r3, #30]
  macconf->CarrierSenseBeforeTransmit = ((READ_BIT(heth->Instance->MACCR,
 8103d3c:	687b      	ldr	r3, [r7, #4]
 8103d3e:	681b      	ldr	r3, [r3, #0]
 8103d40:	681b      	ldr	r3, [r3, #0]
                                                   ETH_MACCR_ECRSFD) >> 11) > 0U) ? ENABLE : DISABLE;
 8103d42:	f403 6300 	and.w	r3, r3, #2048	; 0x800
 8103d46:	2b00      	cmp	r3, #0
 8103d48:	bf14      	ite	ne
 8103d4a:	2301      	movne	r3, #1
 8103d4c:	2300      	moveq	r3, #0
 8103d4e:	b2db      	uxtb	r3, r3
 8103d50:	461a      	mov	r2, r3
  macconf->CarrierSenseBeforeTransmit = ((READ_BIT(heth->Instance->MACCR,
 8103d52:	683b      	ldr	r3, [r7, #0]
 8103d54:	775a      	strb	r2, [r3, #29]
  macconf->LoopbackMode = ((READ_BIT(heth->Instance->MACCR, ETH_MACCR_LM) >> 12) > 0U) ? ENABLE : DISABLE;
 8103d56:	687b      	ldr	r3, [r7, #4]
 8103d58:	681b      	ldr	r3, [r3, #0]
 8103d5a:	681b      	ldr	r3, [r3, #0]
 8103d5c:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
 8103d60:	2b00      	cmp	r3, #0
 8103d62:	bf14      	ite	ne
 8103d64:	2301      	movne	r3, #1
 8103d66:	2300      	moveq	r3, #0
 8103d68:	b2db      	uxtb	r3, r3
 8103d6a:	461a      	mov	r2, r3
 8103d6c:	683b      	ldr	r3, [r7, #0]
 8103d6e:	771a      	strb	r2, [r3, #28]
  macconf->DuplexMode = READ_BIT(heth->Instance->MACCR, ETH_MACCR_DM);
 8103d70:	687b      	ldr	r3, [r7, #4]
 8103d72:	681b      	ldr	r3, [r3, #0]
 8103d74:	681b      	ldr	r3, [r3, #0]
 8103d76:	f403 5200 	and.w	r2, r3, #8192	; 0x2000
 8103d7a:	683b      	ldr	r3, [r7, #0]
 8103d7c:	619a      	str	r2, [r3, #24]
  macconf->Speed = READ_BIT(heth->Instance->MACCR, ETH_MACCR_FES);
 8103d7e:	687b      	ldr	r3, [r7, #4]
 8103d80:	681b      	ldr	r3, [r3, #0]
 8103d82:	681b      	ldr	r3, [r3, #0]
 8103d84:	f403 4280 	and.w	r2, r3, #16384	; 0x4000
 8103d88:	683b      	ldr	r3, [r7, #0]
 8103d8a:	615a      	str	r2, [r3, #20]
  macconf->JumboPacket = ((READ_BIT(heth->Instance->MACCR, ETH_MACCR_JE) >> 16) > 0U) ? ENABLE : DISABLE;
 8103d8c:	687b      	ldr	r3, [r7, #4]
 8103d8e:	681b      	ldr	r3, [r3, #0]
 8103d90:	681b      	ldr	r3, [r3, #0]
 8103d92:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
 8103d96:	2b00      	cmp	r3, #0
 8103d98:	bf14      	ite	ne
 8103d9a:	2301      	movne	r3, #1
 8103d9c:	2300      	moveq	r3, #0
 8103d9e:	b2db      	uxtb	r3, r3
 8103da0:	461a      	mov	r2, r3
 8103da2:	683b      	ldr	r3, [r7, #0]
 8103da4:	749a      	strb	r2, [r3, #18]
  macconf->Jabber = ((READ_BIT(heth->Instance->MACCR, ETH_MACCR_JD) >> 17) == 0U) ? ENABLE : DISABLE;
 8103da6:	687b      	ldr	r3, [r7, #4]
 8103da8:	681b      	ldr	r3, [r3, #0]
 8103daa:	681b      	ldr	r3, [r3, #0]
 8103dac:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 8103db0:	2b00      	cmp	r3, #0
 8103db2:	bf0c      	ite	eq
 8103db4:	2301      	moveq	r3, #1
 8103db6:	2300      	movne	r3, #0
 8103db8:	b2db      	uxtb	r3, r3
 8103dba:	461a      	mov	r2, r3
 8103dbc:	683b      	ldr	r3, [r7, #0]
 8103dbe:	745a      	strb	r2, [r3, #17]
  macconf->Watchdog = ((READ_BIT(heth->Instance->MACCR, ETH_MACCR_WD) >> 19) == 0U) ? ENABLE : DISABLE;
 8103dc0:	687b      	ldr	r3, [r7, #4]
 8103dc2:	681b      	ldr	r3, [r3, #0]
 8103dc4:	681b      	ldr	r3, [r3, #0]
 8103dc6:	f403 2300 	and.w	r3, r3, #524288	; 0x80000
 8103dca:	2b00      	cmp	r3, #0
 8103dcc:	bf0c      	ite	eq
 8103dce:	2301      	moveq	r3, #1
 8103dd0:	2300      	movne	r3, #0
 8103dd2:	b2db      	uxtb	r3, r3
 8103dd4:	461a      	mov	r2, r3
 8103dd6:	683b      	ldr	r3, [r7, #0]
 8103dd8:	741a      	strb	r2, [r3, #16]
  macconf->AutomaticPadCRCStrip = ((READ_BIT(heth->Instance->MACCR, ETH_MACCR_ACS) >> 20) > 0U) ? ENABLE : DISABLE;
 8103dda:	687b      	ldr	r3, [r7, #4]
 8103ddc:	681b      	ldr	r3, [r3, #0]
 8103dde:	681b      	ldr	r3, [r3, #0]
 8103de0:	f403 1380 	and.w	r3, r3, #1048576	; 0x100000
 8103de4:	2b00      	cmp	r3, #0
 8103de6:	bf14      	ite	ne
 8103de8:	2301      	movne	r3, #1
 8103dea:	2300      	moveq	r3, #0
 8103dec:	b2db      	uxtb	r3, r3
 8103dee:	461a      	mov	r2, r3
 8103df0:	683b      	ldr	r3, [r7, #0]
 8103df2:	73da      	strb	r2, [r3, #15]
  macconf->CRCStripTypePacket = ((READ_BIT(heth->Instance->MACCR, ETH_MACCR_CST) >> 21) > 0U) ? ENABLE : DISABLE;
 8103df4:	687b      	ldr	r3, [r7, #4]
 8103df6:	681b      	ldr	r3, [r3, #0]
 8103df8:	681b      	ldr	r3, [r3, #0]
 8103dfa:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
 8103dfe:	2b00      	cmp	r3, #0
 8103e00:	bf14      	ite	ne
 8103e02:	2301      	movne	r3, #1
 8103e04:	2300      	moveq	r3, #0
 8103e06:	b2db      	uxtb	r3, r3
 8103e08:	461a      	mov	r2, r3
 8103e0a:	683b      	ldr	r3, [r7, #0]
 8103e0c:	739a      	strb	r2, [r3, #14]
  macconf->Support2KPacket = ((READ_BIT(heth->Instance->MACCR, ETH_MACCR_S2KP) >> 22) > 0U) ? ENABLE : DISABLE;
 8103e0e:	687b      	ldr	r3, [r7, #4]
 8103e10:	681b      	ldr	r3, [r3, #0]
 8103e12:	681b      	ldr	r3, [r3, #0]
 8103e14:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
 8103e18:	2b00      	cmp	r3, #0
 8103e1a:	bf14      	ite	ne
 8103e1c:	2301      	movne	r3, #1
 8103e1e:	2300      	moveq	r3, #0
 8103e20:	b2db      	uxtb	r3, r3
 8103e22:	461a      	mov	r2, r3
 8103e24:	683b      	ldr	r3, [r7, #0]
 8103e26:	735a      	strb	r2, [r3, #13]
  macconf->GiantPacketSizeLimitControl = ((READ_BIT(heth->Instance->MACCR,
 8103e28:	687b      	ldr	r3, [r7, #4]
 8103e2a:	681b      	ldr	r3, [r3, #0]
 8103e2c:	681b      	ldr	r3, [r3, #0]
                                                    ETH_MACCR_GPSLCE) >> 23) > 0U) ? ENABLE : DISABLE;
 8103e2e:	f403 0300 	and.w	r3, r3, #8388608	; 0x800000
 8103e32:	2b00      	cmp	r3, #0
 8103e34:	bf14      	ite	ne
 8103e36:	2301      	movne	r3, #1
 8103e38:	2300      	moveq	r3, #0
 8103e3a:	b2db      	uxtb	r3, r3
 8103e3c:	461a      	mov	r2, r3
  macconf->GiantPacketSizeLimitControl = ((READ_BIT(heth->Instance->MACCR,
 8103e3e:	683b      	ldr	r3, [r7, #0]
 8103e40:	731a      	strb	r2, [r3, #12]
  macconf->InterPacketGapVal = READ_BIT(heth->Instance->MACCR, ETH_MACCR_IPG);
 8103e42:	687b      	ldr	r3, [r7, #4]
 8103e44:	681b      	ldr	r3, [r3, #0]
 8103e46:	681b      	ldr	r3, [r3, #0]
 8103e48:	f003 62e0 	and.w	r2, r3, #117440512	; 0x7000000
 8103e4c:	683b      	ldr	r3, [r7, #0]
 8103e4e:	609a      	str	r2, [r3, #8]
  macconf->ChecksumOffload = ((READ_BIT(heth->Instance->MACCR, ETH_MACCR_IPC) >> 27) > 0U) ? ENABLE : DISABLE;
 8103e50:	687b      	ldr	r3, [r7, #4]
 8103e52:	681b      	ldr	r3, [r3, #0]
 8103e54:	681b      	ldr	r3, [r3, #0]
 8103e56:	f003 6300 	and.w	r3, r3, #134217728	; 0x8000000
 8103e5a:	2b00      	cmp	r3, #0
 8103e5c:	bf14      	ite	ne
 8103e5e:	2301      	movne	r3, #1
 8103e60:	2300      	moveq	r3, #0
 8103e62:	b2db      	uxtb	r3, r3
 8103e64:	461a      	mov	r2, r3
 8103e66:	683b      	ldr	r3, [r7, #0]
 8103e68:	711a      	strb	r2, [r3, #4]
  macconf->SourceAddrControl = READ_BIT(heth->Instance->MACCR, ETH_MACCR_SARC);
 8103e6a:	687b      	ldr	r3, [r7, #4]
 8103e6c:	681b      	ldr	r3, [r3, #0]
 8103e6e:	681b      	ldr	r3, [r3, #0]
 8103e70:	f003 42e0 	and.w	r2, r3, #1879048192	; 0x70000000
 8103e74:	683b      	ldr	r3, [r7, #0]
 8103e76:	601a      	str	r2, [r3, #0]

  macconf->GiantPacketSizeLimit = READ_BIT(heth->Instance->MACECR, ETH_MACECR_GPSL);
 8103e78:	687b      	ldr	r3, [r7, #4]
 8103e7a:	681b      	ldr	r3, [r3, #0]
 8103e7c:	685b      	ldr	r3, [r3, #4]
 8103e7e:	f3c3 020d 	ubfx	r2, r3, #0, #14
 8103e82:	683b      	ldr	r3, [r7, #0]
 8103e84:	635a      	str	r2, [r3, #52]	; 0x34
  macconf->CRCCheckingRxPackets = ((READ_BIT(heth->Instance->MACECR, ETH_MACECR_DCRCC) >> 16) == 0U) ? ENABLE : DISABLE;
 8103e86:	687b      	ldr	r3, [r7, #4]
 8103e88:	681b      	ldr	r3, [r3, #0]
 8103e8a:	685b      	ldr	r3, [r3, #4]
 8103e8c:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
 8103e90:	2b00      	cmp	r3, #0
 8103e92:	bf0c      	ite	eq
 8103e94:	2301      	moveq	r3, #1
 8103e96:	2300      	movne	r3, #0
 8103e98:	b2db      	uxtb	r3, r3
 8103e9a:	461a      	mov	r2, r3
 8103e9c:	683b      	ldr	r3, [r7, #0]
 8103e9e:	f883 2032 	strb.w	r2, [r3, #50]	; 0x32
  macconf->SlowProtocolDetect = ((READ_BIT(heth->Instance->MACECR, ETH_MACECR_SPEN) >> 17) > 0U) ? ENABLE : DISABLE;
 8103ea2:	687b      	ldr	r3, [r7, #4]
 8103ea4:	681b      	ldr	r3, [r3, #0]
 8103ea6:	685b      	ldr	r3, [r3, #4]
 8103ea8:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 8103eac:	2b00      	cmp	r3, #0
 8103eae:	bf14      	ite	ne
 8103eb0:	2301      	movne	r3, #1
 8103eb2:	2300      	moveq	r3, #0
 8103eb4:	b2db      	uxtb	r3, r3
 8103eb6:	461a      	mov	r2, r3
 8103eb8:	683b      	ldr	r3, [r7, #0]
 8103eba:	f883 2031 	strb.w	r2, [r3, #49]	; 0x31
  macconf->UnicastSlowProtocolPacketDetect = ((READ_BIT(heth->Instance->MACECR,
 8103ebe:	687b      	ldr	r3, [r7, #4]
 8103ec0:	681b      	ldr	r3, [r3, #0]
 8103ec2:	685b      	ldr	r3, [r3, #4]
                                                        ETH_MACECR_USP) >> 18) > 0U) ? ENABLE : DISABLE;
 8103ec4:	f403 2380 	and.w	r3, r3, #262144	; 0x40000
 8103ec8:	2b00      	cmp	r3, #0
 8103eca:	bf14      	ite	ne
 8103ecc:	2301      	movne	r3, #1
 8103ece:	2300      	moveq	r3, #0
 8103ed0:	b2db      	uxtb	r3, r3
 8103ed2:	461a      	mov	r2, r3
  macconf->UnicastSlowProtocolPacketDetect = ((READ_BIT(heth->Instance->MACECR,
 8103ed4:	683b      	ldr	r3, [r7, #0]
 8103ed6:	f883 2030 	strb.w	r2, [r3, #48]	; 0x30
  macconf->ExtendedInterPacketGap = ((READ_BIT(heth->Instance->MACECR, ETH_MACECR_EIPGEN) >> 24) > 0U)
 8103eda:	687b      	ldr	r3, [r7, #4]
 8103edc:	681b      	ldr	r3, [r3, #0]
 8103ede:	685b      	ldr	r3, [r3, #4]
 8103ee0:	f003 7380 	and.w	r3, r3, #16777216	; 0x1000000
                                    ? ENABLE : DISABLE;
 8103ee4:	2b00      	cmp	r3, #0
 8103ee6:	bf14      	ite	ne
 8103ee8:	2301      	movne	r3, #1
 8103eea:	2300      	moveq	r3, #0
 8103eec:	b2db      	uxtb	r3, r3
 8103eee:	461a      	mov	r2, r3
  macconf->ExtendedInterPacketGap = ((READ_BIT(heth->Instance->MACECR, ETH_MACECR_EIPGEN) >> 24) > 0U)
 8103ef0:	683b      	ldr	r3, [r7, #0]
 8103ef2:	f883 2038 	strb.w	r2, [r3, #56]	; 0x38
  macconf->ExtendedInterPacketGapVal = READ_BIT(heth->Instance->MACECR, ETH_MACECR_EIPG) >> 25;
 8103ef6:	687b      	ldr	r3, [r7, #4]
 8103ef8:	681b      	ldr	r3, [r3, #0]
 8103efa:	685b      	ldr	r3, [r3, #4]
 8103efc:	0e5b      	lsrs	r3, r3, #25
 8103efe:	f003 021f 	and.w	r2, r3, #31
 8103f02:	683b      	ldr	r3, [r7, #0]
 8103f04:	63da      	str	r2, [r3, #60]	; 0x3c

  macconf->ProgrammableWatchdog = ((READ_BIT(heth->Instance->MACWTR, ETH_MACWTR_PWE) >> 8) > 0U) ? ENABLE : DISABLE;
 8103f06:	687b      	ldr	r3, [r7, #4]
 8103f08:	681b      	ldr	r3, [r3, #0]
 8103f0a:	68db      	ldr	r3, [r3, #12]
 8103f0c:	f403 7380 	and.w	r3, r3, #256	; 0x100
 8103f10:	2b00      	cmp	r3, #0
 8103f12:	bf14      	ite	ne
 8103f14:	2301      	movne	r3, #1
 8103f16:	2300      	moveq	r3, #0
 8103f18:	b2db      	uxtb	r3, r3
 8103f1a:	461a      	mov	r2, r3
 8103f1c:	683b      	ldr	r3, [r7, #0]
 8103f1e:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
  macconf->WatchdogTimeout = READ_BIT(heth->Instance->MACWTR, ETH_MACWTR_WTO);
 8103f22:	687b      	ldr	r3, [r7, #4]
 8103f24:	681b      	ldr	r3, [r3, #0]
 8103f26:	68db      	ldr	r3, [r3, #12]
 8103f28:	f003 020f 	and.w	r2, r3, #15
 8103f2c:	683b      	ldr	r3, [r7, #0]
 8103f2e:	645a      	str	r2, [r3, #68]	; 0x44

  macconf->TransmitFlowControl = ((READ_BIT(heth->Instance->MACTFCR, ETH_MACTFCR_TFE) >> 1) > 0U) ? ENABLE : DISABLE;
 8103f30:	687b      	ldr	r3, [r7, #4]
 8103f32:	681b      	ldr	r3, [r3, #0]
 8103f34:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8103f36:	f003 0302 	and.w	r3, r3, #2
 8103f3a:	2b00      	cmp	r3, #0
 8103f3c:	bf14      	ite	ne
 8103f3e:	2301      	movne	r3, #1
 8103f40:	2300      	moveq	r3, #0
 8103f42:	b2db      	uxtb	r3, r3
 8103f44:	461a      	mov	r2, r3
 8103f46:	683b      	ldr	r3, [r7, #0]
 8103f48:	f883 2054 	strb.w	r2, [r3, #84]	; 0x54
  macconf->ZeroQuantaPause = ((READ_BIT(heth->Instance->MACTFCR, ETH_MACTFCR_DZPQ) >> 7) == 0U) ? ENABLE : DISABLE;
 8103f4c:	687b      	ldr	r3, [r7, #4]
 8103f4e:	681b      	ldr	r3, [r3, #0]
 8103f50:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8103f52:	f003 0380 	and.w	r3, r3, #128	; 0x80
 8103f56:	2b00      	cmp	r3, #0
 8103f58:	bf0c      	ite	eq
 8103f5a:	2301      	moveq	r3, #1
 8103f5c:	2300      	movne	r3, #0
 8103f5e:	b2db      	uxtb	r3, r3
 8103f60:	461a      	mov	r2, r3
 8103f62:	683b      	ldr	r3, [r7, #0]
 8103f64:	f883 204c 	strb.w	r2, [r3, #76]	; 0x4c
  macconf->PauseLowThreshold = READ_BIT(heth->Instance->MACTFCR, ETH_MACTFCR_PLT);
 8103f68:	687b      	ldr	r3, [r7, #4]
 8103f6a:	681b      	ldr	r3, [r3, #0]
 8103f6c:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8103f6e:	f003 0270 	and.w	r2, r3, #112	; 0x70
 8103f72:	683b      	ldr	r3, [r7, #0]
 8103f74:	651a      	str	r2, [r3, #80]	; 0x50
  macconf->PauseTime = (READ_BIT(heth->Instance->MACTFCR, ETH_MACTFCR_PT) >> 16);
 8103f76:	687b      	ldr	r3, [r7, #4]
 8103f78:	681b      	ldr	r3, [r3, #0]
 8103f7a:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8103f7c:	0c1b      	lsrs	r3, r3, #16
 8103f7e:	b29a      	uxth	r2, r3
 8103f80:	683b      	ldr	r3, [r7, #0]
 8103f82:	649a      	str	r2, [r3, #72]	; 0x48
  macconf->ReceiveFlowControl = (READ_BIT(heth->Instance->MACRFCR, ETH_MACRFCR_RFE) > 0U) ? ENABLE : DISABLE;
 8103f84:	687b      	ldr	r3, [r7, #4]
 8103f86:	681b      	ldr	r3, [r3, #0]
 8103f88:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 8103f8c:	f003 0301 	and.w	r3, r3, #1
 8103f90:	2b00      	cmp	r3, #0
 8103f92:	bf14      	ite	ne
 8103f94:	2301      	movne	r3, #1
 8103f96:	2300      	moveq	r3, #0
 8103f98:	b2db      	uxtb	r3, r3
 8103f9a:	461a      	mov	r2, r3
 8103f9c:	683b      	ldr	r3, [r7, #0]
 8103f9e:	f883 2056 	strb.w	r2, [r3, #86]	; 0x56
  macconf->UnicastPausePacketDetect = ((READ_BIT(heth->Instance->MACRFCR, ETH_MACRFCR_UP) >> 1) > 0U)
 8103fa2:	687b      	ldr	r3, [r7, #4]
 8103fa4:	681b      	ldr	r3, [r3, #0]
 8103fa6:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 8103faa:	f003 0302 	and.w	r3, r3, #2
                                      ? ENABLE : DISABLE;
 8103fae:	2b00      	cmp	r3, #0
 8103fb0:	bf14      	ite	ne
 8103fb2:	2301      	movne	r3, #1
 8103fb4:	2300      	moveq	r3, #0
 8103fb6:	b2db      	uxtb	r3, r3
 8103fb8:	461a      	mov	r2, r3
  macconf->UnicastPausePacketDetect = ((READ_BIT(heth->Instance->MACRFCR, ETH_MACRFCR_UP) >> 1) > 0U)
 8103fba:	683b      	ldr	r3, [r7, #0]
 8103fbc:	f883 2055 	strb.w	r2, [r3, #85]	; 0x55

  macconf->TransmitQueueMode = READ_BIT(heth->Instance->MTLTQOMR, (ETH_MTLTQOMR_TTC | ETH_MTLTQOMR_TSF));
 8103fc0:	687b      	ldr	r3, [r7, #4]
 8103fc2:	681b      	ldr	r3, [r3, #0]
 8103fc4:	f8d3 3d00 	ldr.w	r3, [r3, #3328]	; 0xd00
 8103fc8:	f003 0272 	and.w	r2, r3, #114	; 0x72
 8103fcc:	683b      	ldr	r3, [r7, #0]
 8103fce:	659a      	str	r2, [r3, #88]	; 0x58

  macconf->ReceiveQueueMode = READ_BIT(heth->Instance->MTLRQOMR, (ETH_MTLRQOMR_RTC | ETH_MTLRQOMR_RSF));
 8103fd0:	687b      	ldr	r3, [r7, #4]
 8103fd2:	681b      	ldr	r3, [r3, #0]
 8103fd4:	f8d3 3d30 	ldr.w	r3, [r3, #3376]	; 0xd30
 8103fd8:	f003 0223 	and.w	r2, r3, #35	; 0x23
 8103fdc:	683b      	ldr	r3, [r7, #0]
 8103fde:	65da      	str	r2, [r3, #92]	; 0x5c
  macconf->ForwardRxUndersizedGoodPacket = ((READ_BIT(heth->Instance->MTLRQOMR,
 8103fe0:	687b      	ldr	r3, [r7, #4]
 8103fe2:	681b      	ldr	r3, [r3, #0]
 8103fe4:	f8d3 3d30 	ldr.w	r3, [r3, #3376]	; 0xd30
                                                      ETH_MTLRQOMR_FUP) >> 3) > 0U) ? ENABLE : DISABLE;
 8103fe8:	f003 0308 	and.w	r3, r3, #8
 8103fec:	2b00      	cmp	r3, #0
 8103fee:	bf14      	ite	ne
 8103ff0:	2301      	movne	r3, #1
 8103ff2:	2300      	moveq	r3, #0
 8103ff4:	b2db      	uxtb	r3, r3
 8103ff6:	461a      	mov	r2, r3
  macconf->ForwardRxUndersizedGoodPacket = ((READ_BIT(heth->Instance->MTLRQOMR,
 8103ff8:	683b      	ldr	r3, [r7, #0]
 8103ffa:	f883 2062 	strb.w	r2, [r3, #98]	; 0x62
  macconf->ForwardRxErrorPacket = ((READ_BIT(heth->Instance->MTLRQOMR, ETH_MTLRQOMR_FEP) >> 4) > 0U) ? ENABLE : DISABLE;
 8103ffe:	687b      	ldr	r3, [r7, #4]
 8104000:	681b      	ldr	r3, [r3, #0]
 8104002:	f8d3 3d30 	ldr.w	r3, [r3, #3376]	; 0xd30
 8104006:	f003 0310 	and.w	r3, r3, #16
 810400a:	2b00      	cmp	r3, #0
 810400c:	bf14      	ite	ne
 810400e:	2301      	movne	r3, #1
 8104010:	2300      	moveq	r3, #0
 8104012:	b2db      	uxtb	r3, r3
 8104014:	461a      	mov	r2, r3
 8104016:	683b      	ldr	r3, [r7, #0]
 8104018:	f883 2061 	strb.w	r2, [r3, #97]	; 0x61
  macconf->DropTCPIPChecksumErrorPacket = ((READ_BIT(heth->Instance->MTLRQOMR,
 810401c:	687b      	ldr	r3, [r7, #4]
 810401e:	681b      	ldr	r3, [r3, #0]
 8104020:	f8d3 3d30 	ldr.w	r3, [r3, #3376]	; 0xd30
                                                     ETH_MTLRQOMR_DISTCPEF) >> 6) == 0U) ? ENABLE : DISABLE;
 8104024:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8104028:	2b00      	cmp	r3, #0
 810402a:	bf0c      	ite	eq
 810402c:	2301      	moveq	r3, #1
 810402e:	2300      	movne	r3, #0
 8104030:	b2db      	uxtb	r3, r3
 8104032:	461a      	mov	r2, r3
  macconf->DropTCPIPChecksumErrorPacket = ((READ_BIT(heth->Instance->MTLRQOMR,
 8104034:	683b      	ldr	r3, [r7, #0]
 8104036:	f883 2060 	strb.w	r2, [r3, #96]	; 0x60

  return HAL_OK;
 810403a:	2300      	movs	r3, #0
}
 810403c:	4618      	mov	r0, r3
 810403e:	370c      	adds	r7, #12
 8104040:	46bd      	mov	sp, r7
 8104042:	f85d 7b04 	ldr.w	r7, [sp], #4
 8104046:	4770      	bx	lr

08104048 <HAL_ETH_SetMACConfig>:
  * @param  macconf: pointer to a ETH_MACConfigTypeDef structure that contains
  *         the configuration of the MAC.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_ETH_SetMACConfig(ETH_HandleTypeDef *heth,  ETH_MACConfigTypeDef *macconf)
{
 8104048:	b580      	push	{r7, lr}
 810404a:	b082      	sub	sp, #8
 810404c:	af00      	add	r7, sp, #0
 810404e:	6078      	str	r0, [r7, #4]
 8104050:	6039      	str	r1, [r7, #0]
  if (macconf == NULL)
 8104052:	683b      	ldr	r3, [r7, #0]
 8104054:	2b00      	cmp	r3, #0
 8104056:	d101      	bne.n	810405c <HAL_ETH_SetMACConfig+0x14>
  {
    return HAL_ERROR;
 8104058:	2301      	movs	r3, #1
 810405a:	e00b      	b.n	8104074 <HAL_ETH_SetMACConfig+0x2c>
  }

  if (heth->gState == HAL_ETH_STATE_READY)
 810405c:	687b      	ldr	r3, [r7, #4]
 810405e:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 8104062:	2b10      	cmp	r3, #16
 8104064:	d105      	bne.n	8104072 <HAL_ETH_SetMACConfig+0x2a>
  {
    ETH_SetMACConfig(heth, macconf);
 8104066:	6839      	ldr	r1, [r7, #0]
 8104068:	6878      	ldr	r0, [r7, #4]
 810406a:	f000 f857 	bl	810411c <ETH_SetMACConfig>

    return HAL_OK;
 810406e:	2300      	movs	r3, #0
 8104070:	e000      	b.n	8104074 <HAL_ETH_SetMACConfig+0x2c>
  }
  else
  {
    return HAL_ERROR;
 8104072:	2301      	movs	r3, #1
  }
}
 8104074:	4618      	mov	r0, r3
 8104076:	3708      	adds	r7, #8
 8104078:	46bd      	mov	sp, r7
 810407a:	bd80      	pop	{r7, pc}

0810407c <HAL_ETH_SetMDIOClockRange>:
  * @param  heth: pointer to a ETH_HandleTypeDef structure that contains
  *         the configuration information for ETHERNET module
  * @retval None
  */
void HAL_ETH_SetMDIOClockRange(ETH_HandleTypeDef *heth)
{
 810407c:	b580      	push	{r7, lr}
 810407e:	b084      	sub	sp, #16
 8104080:	af00      	add	r7, sp, #0
 8104082:	6078      	str	r0, [r7, #4]
  uint32_t hclk;
  uint32_t tmpreg;

  /* Get the ETHERNET MACMDIOAR value */
  tmpreg = (heth->Instance)->MACMDIOAR;
 8104084:	687b      	ldr	r3, [r7, #4]
 8104086:	681b      	ldr	r3, [r3, #0]
 8104088:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
 810408c:	60fb      	str	r3, [r7, #12]

  /* Clear CSR Clock Range bits */
  tmpreg &= ~ETH_MACMDIOAR_CR;
 810408e:	68fb      	ldr	r3, [r7, #12]
 8104090:	f423 6370 	bic.w	r3, r3, #3840	; 0xf00
 8104094:	60fb      	str	r3, [r7, #12]

  /* Get hclk frequency value */
  hclk = HAL_RCC_GetHCLKFreq();
 8104096:	f003 f80f 	bl	81070b8 <HAL_RCC_GetHCLKFreq>
 810409a:	60b8      	str	r0, [r7, #8]

  /* Set CR bits depending on hclk value */
  if (hclk < 35000000U)
 810409c:	68bb      	ldr	r3, [r7, #8]
 810409e:	4a1a      	ldr	r2, [pc, #104]	; (8104108 <HAL_ETH_SetMDIOClockRange+0x8c>)
 81040a0:	4293      	cmp	r3, r2
 81040a2:	d804      	bhi.n	81040ae <HAL_ETH_SetMDIOClockRange+0x32>
  {
    /* CSR Clock Range between 0-35 MHz */
    tmpreg |= (uint32_t)ETH_MACMDIOAR_CR_DIV16;
 81040a4:	68fb      	ldr	r3, [r7, #12]
 81040a6:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 81040aa:	60fb      	str	r3, [r7, #12]
 81040ac:	e022      	b.n	81040f4 <HAL_ETH_SetMDIOClockRange+0x78>
  }
  else if (hclk < 60000000U)
 81040ae:	68bb      	ldr	r3, [r7, #8]
 81040b0:	4a16      	ldr	r2, [pc, #88]	; (810410c <HAL_ETH_SetMDIOClockRange+0x90>)
 81040b2:	4293      	cmp	r3, r2
 81040b4:	d204      	bcs.n	81040c0 <HAL_ETH_SetMDIOClockRange+0x44>
  {
    /* CSR Clock Range between 35-60 MHz */
    tmpreg |= (uint32_t)ETH_MACMDIOAR_CR_DIV26;
 81040b6:	68fb      	ldr	r3, [r7, #12]
 81040b8:	f443 7340 	orr.w	r3, r3, #768	; 0x300
 81040bc:	60fb      	str	r3, [r7, #12]
 81040be:	e019      	b.n	81040f4 <HAL_ETH_SetMDIOClockRange+0x78>
  }
  else if (hclk < 100000000U)
 81040c0:	68bb      	ldr	r3, [r7, #8]
 81040c2:	4a13      	ldr	r2, [pc, #76]	; (8104110 <HAL_ETH_SetMDIOClockRange+0x94>)
 81040c4:	4293      	cmp	r3, r2
 81040c6:	d915      	bls.n	81040f4 <HAL_ETH_SetMDIOClockRange+0x78>
  {
    /* CSR Clock Range between 60-100 MHz */
    tmpreg |= (uint32_t)ETH_MACMDIOAR_CR_DIV42;
  }
  else if (hclk < 150000000U)
 81040c8:	68bb      	ldr	r3, [r7, #8]
 81040ca:	4a12      	ldr	r2, [pc, #72]	; (8104114 <HAL_ETH_SetMDIOClockRange+0x98>)
 81040cc:	4293      	cmp	r3, r2
 81040ce:	d804      	bhi.n	81040da <HAL_ETH_SetMDIOClockRange+0x5e>
  {
    /* CSR Clock Range between 100-150 MHz */
    tmpreg |= (uint32_t)ETH_MACMDIOAR_CR_DIV62;
 81040d0:	68fb      	ldr	r3, [r7, #12]
 81040d2:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 81040d6:	60fb      	str	r3, [r7, #12]
 81040d8:	e00c      	b.n	81040f4 <HAL_ETH_SetMDIOClockRange+0x78>
  }
  else if (hclk < 250000000U)
 81040da:	68bb      	ldr	r3, [r7, #8]
 81040dc:	4a0e      	ldr	r2, [pc, #56]	; (8104118 <HAL_ETH_SetMDIOClockRange+0x9c>)
 81040de:	4293      	cmp	r3, r2
 81040e0:	d804      	bhi.n	81040ec <HAL_ETH_SetMDIOClockRange+0x70>
  {
    /* CSR Clock Range between 150-250 MHz */
    tmpreg |= (uint32_t)ETH_MACMDIOAR_CR_DIV102;
 81040e2:	68fb      	ldr	r3, [r7, #12]
 81040e4:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
 81040e8:	60fb      	str	r3, [r7, #12]
 81040ea:	e003      	b.n	81040f4 <HAL_ETH_SetMDIOClockRange+0x78>
  }
  else /* (hclk >= 250000000U) */
  {
    /* CSR Clock >= 250 MHz */
    tmpreg |= (uint32_t)(ETH_MACMDIOAR_CR_DIV124);
 81040ec:	68fb      	ldr	r3, [r7, #12]
 81040ee:	f443 63a0 	orr.w	r3, r3, #1280	; 0x500
 81040f2:	60fb      	str	r3, [r7, #12]
  }

  /* Configure the CSR Clock Range */
  (heth->Instance)->MACMDIOAR = (uint32_t)tmpreg;
 81040f4:	687b      	ldr	r3, [r7, #4]
 81040f6:	681b      	ldr	r3, [r3, #0]
 81040f8:	68fa      	ldr	r2, [r7, #12]
 81040fa:	f8c3 2200 	str.w	r2, [r3, #512]	; 0x200
}
 81040fe:	bf00      	nop
 8104100:	3710      	adds	r7, #16
 8104102:	46bd      	mov	sp, r7
 8104104:	bd80      	pop	{r7, pc}
 8104106:	bf00      	nop
 8104108:	02160ebf 	.word	0x02160ebf
 810410c:	03938700 	.word	0x03938700
 8104110:	05f5e0ff 	.word	0x05f5e0ff
 8104114:	08f0d17f 	.word	0x08f0d17f
 8104118:	0ee6b27f 	.word	0x0ee6b27f

0810411c <ETH_SetMACConfig>:
/** @addtogroup ETH_Private_Functions   ETH Private Functions
  * @{
  */

static void ETH_SetMACConfig(ETH_HandleTypeDef *heth, const ETH_MACConfigTypeDef *macconf)
{
 810411c:	b480      	push	{r7}
 810411e:	b085      	sub	sp, #20
 8104120:	af00      	add	r7, sp, #0
 8104122:	6078      	str	r0, [r7, #4]
 8104124:	6039      	str	r1, [r7, #0]
  uint32_t macregval;

  /*------------------------ MACCR Configuration --------------------*/
  macregval = (macconf->InterPacketGapVal |
 8104126:	683b      	ldr	r3, [r7, #0]
 8104128:	689a      	ldr	r2, [r3, #8]
               macconf->SourceAddrControl |
 810412a:	683b      	ldr	r3, [r7, #0]
 810412c:	681b      	ldr	r3, [r3, #0]
  macregval = (macconf->InterPacketGapVal |
 810412e:	431a      	orrs	r2, r3
               ((uint32_t)macconf->ChecksumOffload << 27) |
 8104130:	683b      	ldr	r3, [r7, #0]
 8104132:	791b      	ldrb	r3, [r3, #4]
 8104134:	06db      	lsls	r3, r3, #27
               macconf->SourceAddrControl |
 8104136:	431a      	orrs	r2, r3
               ((uint32_t)macconf->GiantPacketSizeLimitControl << 23) |
 8104138:	683b      	ldr	r3, [r7, #0]
 810413a:	7b1b      	ldrb	r3, [r3, #12]
 810413c:	05db      	lsls	r3, r3, #23
               ((uint32_t)macconf->ChecksumOffload << 27) |
 810413e:	431a      	orrs	r2, r3
               ((uint32_t)macconf->Support2KPacket  << 22) |
 8104140:	683b      	ldr	r3, [r7, #0]
 8104142:	7b5b      	ldrb	r3, [r3, #13]
 8104144:	059b      	lsls	r3, r3, #22
               ((uint32_t)macconf->GiantPacketSizeLimitControl << 23) |
 8104146:	431a      	orrs	r2, r3
               ((uint32_t)macconf->CRCStripTypePacket << 21) |
 8104148:	683b      	ldr	r3, [r7, #0]
 810414a:	7b9b      	ldrb	r3, [r3, #14]
 810414c:	055b      	lsls	r3, r3, #21
               ((uint32_t)macconf->Support2KPacket  << 22) |
 810414e:	431a      	orrs	r2, r3
               ((uint32_t)macconf->AutomaticPadCRCStrip << 20) |
 8104150:	683b      	ldr	r3, [r7, #0]
 8104152:	7bdb      	ldrb	r3, [r3, #15]
 8104154:	051b      	lsls	r3, r3, #20
               ((uint32_t)macconf->CRCStripTypePacket << 21) |
 8104156:	4313      	orrs	r3, r2
               ((uint32_t)((macconf->Watchdog == DISABLE) ? 1U : 0U) << 19) |
 8104158:	683a      	ldr	r2, [r7, #0]
 810415a:	7c12      	ldrb	r2, [r2, #16]
 810415c:	2a00      	cmp	r2, #0
 810415e:	d102      	bne.n	8104166 <ETH_SetMACConfig+0x4a>
 8104160:	f44f 2200 	mov.w	r2, #524288	; 0x80000
 8104164:	e000      	b.n	8104168 <ETH_SetMACConfig+0x4c>
 8104166:	2200      	movs	r2, #0
               ((uint32_t)macconf->AutomaticPadCRCStrip << 20) |
 8104168:	4313      	orrs	r3, r2
               ((uint32_t)((macconf->Jabber == DISABLE) ? 1U : 0U) << 17) |
 810416a:	683a      	ldr	r2, [r7, #0]
 810416c:	7c52      	ldrb	r2, [r2, #17]
 810416e:	2a00      	cmp	r2, #0
 8104170:	d102      	bne.n	8104178 <ETH_SetMACConfig+0x5c>
 8104172:	f44f 3200 	mov.w	r2, #131072	; 0x20000
 8104176:	e000      	b.n	810417a <ETH_SetMACConfig+0x5e>
 8104178:	2200      	movs	r2, #0
               ((uint32_t)((macconf->Watchdog == DISABLE) ? 1U : 0U) << 19) |
 810417a:	431a      	orrs	r2, r3
               ((uint32_t)macconf->JumboPacket << 16) |
 810417c:	683b      	ldr	r3, [r7, #0]
 810417e:	7c9b      	ldrb	r3, [r3, #18]
 8104180:	041b      	lsls	r3, r3, #16
               ((uint32_t)((macconf->Jabber == DISABLE) ? 1U : 0U) << 17) |
 8104182:	431a      	orrs	r2, r3
               macconf->Speed |
 8104184:	683b      	ldr	r3, [r7, #0]
 8104186:	695b      	ldr	r3, [r3, #20]
               ((uint32_t)macconf->JumboPacket << 16) |
 8104188:	431a      	orrs	r2, r3
               macconf->DuplexMode |
 810418a:	683b      	ldr	r3, [r7, #0]
 810418c:	699b      	ldr	r3, [r3, #24]
               macconf->Speed |
 810418e:	431a      	orrs	r2, r3
               ((uint32_t)macconf->LoopbackMode << 12) |
 8104190:	683b      	ldr	r3, [r7, #0]
 8104192:	7f1b      	ldrb	r3, [r3, #28]
 8104194:	031b      	lsls	r3, r3, #12
               macconf->DuplexMode |
 8104196:	431a      	orrs	r2, r3
               ((uint32_t)macconf->CarrierSenseBeforeTransmit << 11) |
 8104198:	683b      	ldr	r3, [r7, #0]
 810419a:	7f5b      	ldrb	r3, [r3, #29]
 810419c:	02db      	lsls	r3, r3, #11
               ((uint32_t)macconf->LoopbackMode << 12) |
 810419e:	4313      	orrs	r3, r2
               ((uint32_t)((macconf->ReceiveOwn == DISABLE) ? 1U : 0U) << 10) |
 81041a0:	683a      	ldr	r2, [r7, #0]
 81041a2:	7f92      	ldrb	r2, [r2, #30]
 81041a4:	2a00      	cmp	r2, #0
 81041a6:	d102      	bne.n	81041ae <ETH_SetMACConfig+0x92>
 81041a8:	f44f 6280 	mov.w	r2, #1024	; 0x400
 81041ac:	e000      	b.n	81041b0 <ETH_SetMACConfig+0x94>
 81041ae:	2200      	movs	r2, #0
               ((uint32_t)macconf->CarrierSenseBeforeTransmit << 11) |
 81041b0:	431a      	orrs	r2, r3
               ((uint32_t)macconf->CarrierSenseDuringTransmit << 9) |
 81041b2:	683b      	ldr	r3, [r7, #0]
 81041b4:	7fdb      	ldrb	r3, [r3, #31]
 81041b6:	025b      	lsls	r3, r3, #9
               ((uint32_t)((macconf->ReceiveOwn == DISABLE) ? 1U : 0U) << 10) |
 81041b8:	4313      	orrs	r3, r2
               ((uint32_t)((macconf->RetryTransmission == DISABLE) ? 1U : 0U) << 8) |
 81041ba:	683a      	ldr	r2, [r7, #0]
 81041bc:	f892 2020 	ldrb.w	r2, [r2, #32]
 81041c0:	2a00      	cmp	r2, #0
 81041c2:	d102      	bne.n	81041ca <ETH_SetMACConfig+0xae>
 81041c4:	f44f 7280 	mov.w	r2, #256	; 0x100
 81041c8:	e000      	b.n	81041cc <ETH_SetMACConfig+0xb0>
 81041ca:	2200      	movs	r2, #0
               ((uint32_t)macconf->CarrierSenseDuringTransmit << 9) |
 81041cc:	431a      	orrs	r2, r3
               macconf->BackOffLimit |
 81041ce:	683b      	ldr	r3, [r7, #0]
 81041d0:	6a5b      	ldr	r3, [r3, #36]	; 0x24
               ((uint32_t)((macconf->RetryTransmission == DISABLE) ? 1U : 0U) << 8) |
 81041d2:	431a      	orrs	r2, r3
               ((uint32_t)macconf->DeferralCheck << 4) |
 81041d4:	683b      	ldr	r3, [r7, #0]
 81041d6:	f893 3028 	ldrb.w	r3, [r3, #40]	; 0x28
 81041da:	011b      	lsls	r3, r3, #4
               macconf->BackOffLimit |
 81041dc:	431a      	orrs	r2, r3
               macconf->PreambleLength);
 81041de:	683b      	ldr	r3, [r7, #0]
 81041e0:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  macregval = (macconf->InterPacketGapVal |
 81041e2:	4313      	orrs	r3, r2
 81041e4:	60fb      	str	r3, [r7, #12]

  /* Write to MACCR */
  MODIFY_REG(heth->Instance->MACCR, ETH_MACCR_MASK, macregval);
 81041e6:	687b      	ldr	r3, [r7, #4]
 81041e8:	681b      	ldr	r3, [r3, #0]
 81041ea:	681a      	ldr	r2, [r3, #0]
 81041ec:	4b57      	ldr	r3, [pc, #348]	; (810434c <ETH_SetMACConfig+0x230>)
 81041ee:	4013      	ands	r3, r2
 81041f0:	687a      	ldr	r2, [r7, #4]
 81041f2:	6812      	ldr	r2, [r2, #0]
 81041f4:	68f9      	ldr	r1, [r7, #12]
 81041f6:	430b      	orrs	r3, r1
 81041f8:	6013      	str	r3, [r2, #0]

  /*------------------------ MACECR Configuration --------------------*/
  macregval = ((macconf->ExtendedInterPacketGapVal << 25) |
 81041fa:	683b      	ldr	r3, [r7, #0]
 81041fc:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 81041fe:	065a      	lsls	r2, r3, #25
               ((uint32_t)macconf->ExtendedInterPacketGap << 24) |
 8104200:	683b      	ldr	r3, [r7, #0]
 8104202:	f893 3038 	ldrb.w	r3, [r3, #56]	; 0x38
 8104206:	061b      	lsls	r3, r3, #24
  macregval = ((macconf->ExtendedInterPacketGapVal << 25) |
 8104208:	431a      	orrs	r2, r3
               ((uint32_t)macconf->UnicastSlowProtocolPacketDetect << 18) |
 810420a:	683b      	ldr	r3, [r7, #0]
 810420c:	f893 3030 	ldrb.w	r3, [r3, #48]	; 0x30
 8104210:	049b      	lsls	r3, r3, #18
               ((uint32_t)macconf->ExtendedInterPacketGap << 24) |
 8104212:	431a      	orrs	r2, r3
               ((uint32_t)macconf->SlowProtocolDetect << 17) |
 8104214:	683b      	ldr	r3, [r7, #0]
 8104216:	f893 3031 	ldrb.w	r3, [r3, #49]	; 0x31
 810421a:	045b      	lsls	r3, r3, #17
               ((uint32_t)macconf->UnicastSlowProtocolPacketDetect << 18) |
 810421c:	4313      	orrs	r3, r2
               ((uint32_t)((macconf->CRCCheckingRxPackets == DISABLE) ? 1U : 0U) << 16) |
 810421e:	683a      	ldr	r2, [r7, #0]
 8104220:	f892 2032 	ldrb.w	r2, [r2, #50]	; 0x32
 8104224:	2a00      	cmp	r2, #0
 8104226:	d102      	bne.n	810422e <ETH_SetMACConfig+0x112>
 8104228:	f44f 3280 	mov.w	r2, #65536	; 0x10000
 810422c:	e000      	b.n	8104230 <ETH_SetMACConfig+0x114>
 810422e:	2200      	movs	r2, #0
               ((uint32_t)macconf->SlowProtocolDetect << 17) |
 8104230:	431a      	orrs	r2, r3
               macconf->GiantPacketSizeLimit);
 8104232:	683b      	ldr	r3, [r7, #0]
 8104234:	6b5b      	ldr	r3, [r3, #52]	; 0x34
  macregval = ((macconf->ExtendedInterPacketGapVal << 25) |
 8104236:	4313      	orrs	r3, r2
 8104238:	60fb      	str	r3, [r7, #12]

  /* Write to MACECR */
  MODIFY_REG(heth->Instance->MACECR, ETH_MACECR_MASK, macregval);
 810423a:	687b      	ldr	r3, [r7, #4]
 810423c:	681b      	ldr	r3, [r3, #0]
 810423e:	685a      	ldr	r2, [r3, #4]
 8104240:	4b43      	ldr	r3, [pc, #268]	; (8104350 <ETH_SetMACConfig+0x234>)
 8104242:	4013      	ands	r3, r2
 8104244:	687a      	ldr	r2, [r7, #4]
 8104246:	6812      	ldr	r2, [r2, #0]
 8104248:	68f9      	ldr	r1, [r7, #12]
 810424a:	430b      	orrs	r3, r1
 810424c:	6053      	str	r3, [r2, #4]

  /*------------------------ MACWTR Configuration --------------------*/
  macregval = (((uint32_t)macconf->ProgrammableWatchdog << 8) |
 810424e:	683b      	ldr	r3, [r7, #0]
 8104250:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
 8104254:	021a      	lsls	r2, r3, #8
               macconf->WatchdogTimeout);
 8104256:	683b      	ldr	r3, [r7, #0]
 8104258:	6c5b      	ldr	r3, [r3, #68]	; 0x44
  macregval = (((uint32_t)macconf->ProgrammableWatchdog << 8) |
 810425a:	4313      	orrs	r3, r2
 810425c:	60fb      	str	r3, [r7, #12]

  /* Write to MACWTR */
  MODIFY_REG(heth->Instance->MACWTR, ETH_MACWTR_MASK, macregval);
 810425e:	687b      	ldr	r3, [r7, #4]
 8104260:	681b      	ldr	r3, [r3, #0]
 8104262:	68db      	ldr	r3, [r3, #12]
 8104264:	f423 7387 	bic.w	r3, r3, #270	; 0x10e
 8104268:	f023 0301 	bic.w	r3, r3, #1
 810426c:	687a      	ldr	r2, [r7, #4]
 810426e:	6812      	ldr	r2, [r2, #0]
 8104270:	68f9      	ldr	r1, [r7, #12]
 8104272:	430b      	orrs	r3, r1
 8104274:	60d3      	str	r3, [r2, #12]

  /*------------------------ MACTFCR Configuration --------------------*/
  macregval = (((uint32_t)macconf->TransmitFlowControl << 1) |
 8104276:	683b      	ldr	r3, [r7, #0]
 8104278:	f893 3054 	ldrb.w	r3, [r3, #84]	; 0x54
 810427c:	005a      	lsls	r2, r3, #1
               macconf->PauseLowThreshold |
 810427e:	683b      	ldr	r3, [r7, #0]
 8104280:	6d1b      	ldr	r3, [r3, #80]	; 0x50
  macregval = (((uint32_t)macconf->TransmitFlowControl << 1) |
 8104282:	4313      	orrs	r3, r2
               ((uint32_t)((macconf->ZeroQuantaPause == DISABLE) ? 1U : 0U) << 7) |
 8104284:	683a      	ldr	r2, [r7, #0]
 8104286:	f892 204c 	ldrb.w	r2, [r2, #76]	; 0x4c
 810428a:	2a00      	cmp	r2, #0
 810428c:	d101      	bne.n	8104292 <ETH_SetMACConfig+0x176>
 810428e:	2280      	movs	r2, #128	; 0x80
 8104290:	e000      	b.n	8104294 <ETH_SetMACConfig+0x178>
 8104292:	2200      	movs	r2, #0
               macconf->PauseLowThreshold |
 8104294:	431a      	orrs	r2, r3
               (macconf->PauseTime << 16));
 8104296:	683b      	ldr	r3, [r7, #0]
 8104298:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 810429a:	041b      	lsls	r3, r3, #16
  macregval = (((uint32_t)macconf->TransmitFlowControl << 1) |
 810429c:	4313      	orrs	r3, r2
 810429e:	60fb      	str	r3, [r7, #12]

  /* Write to MACTFCR */
  MODIFY_REG(heth->Instance->MACTFCR, ETH_MACTFCR_MASK, macregval);
 81042a0:	687b      	ldr	r3, [r7, #4]
 81042a2:	681b      	ldr	r3, [r3, #0]
 81042a4:	6f1a      	ldr	r2, [r3, #112]	; 0x70
 81042a6:	f64f 730d 	movw	r3, #65293	; 0xff0d
 81042aa:	4013      	ands	r3, r2
 81042ac:	687a      	ldr	r2, [r7, #4]
 81042ae:	6812      	ldr	r2, [r2, #0]
 81042b0:	68f9      	ldr	r1, [r7, #12]
 81042b2:	430b      	orrs	r3, r1
 81042b4:	6713      	str	r3, [r2, #112]	; 0x70

  /*------------------------ MACRFCR Configuration --------------------*/
  macregval = ((uint32_t)macconf->ReceiveFlowControl |
 81042b6:	683b      	ldr	r3, [r7, #0]
 81042b8:	f893 3056 	ldrb.w	r3, [r3, #86]	; 0x56
 81042bc:	461a      	mov	r2, r3
               ((uint32_t)macconf->UnicastPausePacketDetect << 1));
 81042be:	683b      	ldr	r3, [r7, #0]
 81042c0:	f893 3055 	ldrb.w	r3, [r3, #85]	; 0x55
 81042c4:	005b      	lsls	r3, r3, #1
  macregval = ((uint32_t)macconf->ReceiveFlowControl |
 81042c6:	4313      	orrs	r3, r2
 81042c8:	60fb      	str	r3, [r7, #12]

  /* Write to MACRFCR */
  MODIFY_REG(heth->Instance->MACRFCR, ETH_MACRFCR_MASK, macregval);
 81042ca:	687b      	ldr	r3, [r7, #4]
 81042cc:	681b      	ldr	r3, [r3, #0]
 81042ce:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 81042d2:	f023 0103 	bic.w	r1, r3, #3
 81042d6:	687b      	ldr	r3, [r7, #4]
 81042d8:	681b      	ldr	r3, [r3, #0]
 81042da:	68fa      	ldr	r2, [r7, #12]
 81042dc:	430a      	orrs	r2, r1
 81042de:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90

  /*------------------------ MTLTQOMR Configuration --------------------*/
  /* Write to MTLTQOMR */
  MODIFY_REG(heth->Instance->MTLTQOMR, ETH_MTLTQOMR_MASK, macconf->TransmitQueueMode);
 81042e2:	687b      	ldr	r3, [r7, #4]
 81042e4:	681b      	ldr	r3, [r3, #0]
 81042e6:	f8d3 3d00 	ldr.w	r3, [r3, #3328]	; 0xd00
 81042ea:	f023 0172 	bic.w	r1, r3, #114	; 0x72
 81042ee:	683b      	ldr	r3, [r7, #0]
 81042f0:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 81042f2:	687b      	ldr	r3, [r7, #4]
 81042f4:	681b      	ldr	r3, [r3, #0]
 81042f6:	430a      	orrs	r2, r1
 81042f8:	f8c3 2d00 	str.w	r2, [r3, #3328]	; 0xd00

  /*------------------------ MTLRQOMR Configuration --------------------*/
  macregval = (macconf->ReceiveQueueMode |
 81042fc:	683b      	ldr	r3, [r7, #0]
 81042fe:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
               ((uint32_t)((macconf->DropTCPIPChecksumErrorPacket == DISABLE) ? 1U : 0U) << 6) |
 8104300:	683a      	ldr	r2, [r7, #0]
 8104302:	f892 2060 	ldrb.w	r2, [r2, #96]	; 0x60
 8104306:	2a00      	cmp	r2, #0
 8104308:	d101      	bne.n	810430e <ETH_SetMACConfig+0x1f2>
 810430a:	2240      	movs	r2, #64	; 0x40
 810430c:	e000      	b.n	8104310 <ETH_SetMACConfig+0x1f4>
 810430e:	2200      	movs	r2, #0
  macregval = (macconf->ReceiveQueueMode |
 8104310:	431a      	orrs	r2, r3
               ((uint32_t)macconf->ForwardRxErrorPacket << 4) |
 8104312:	683b      	ldr	r3, [r7, #0]
 8104314:	f893 3061 	ldrb.w	r3, [r3, #97]	; 0x61
 8104318:	011b      	lsls	r3, r3, #4
               ((uint32_t)((macconf->DropTCPIPChecksumErrorPacket == DISABLE) ? 1U : 0U) << 6) |
 810431a:	431a      	orrs	r2, r3
               ((uint32_t)macconf->ForwardRxUndersizedGoodPacket << 3));
 810431c:	683b      	ldr	r3, [r7, #0]
 810431e:	f893 3062 	ldrb.w	r3, [r3, #98]	; 0x62
 8104322:	00db      	lsls	r3, r3, #3
  macregval = (macconf->ReceiveQueueMode |
 8104324:	4313      	orrs	r3, r2
 8104326:	60fb      	str	r3, [r7, #12]

  /* Write to MTLRQOMR */
  MODIFY_REG(heth->Instance->MTLRQOMR, ETH_MTLRQOMR_MASK, macregval);
 8104328:	687b      	ldr	r3, [r7, #4]
 810432a:	681b      	ldr	r3, [r3, #0]
 810432c:	f8d3 3d30 	ldr.w	r3, [r3, #3376]	; 0xd30
 8104330:	f023 017b 	bic.w	r1, r3, #123	; 0x7b
 8104334:	687b      	ldr	r3, [r7, #4]
 8104336:	681b      	ldr	r3, [r3, #0]
 8104338:	68fa      	ldr	r2, [r7, #12]
 810433a:	430a      	orrs	r2, r1
 810433c:	f8c3 2d30 	str.w	r2, [r3, #3376]	; 0xd30
}
 8104340:	bf00      	nop
 8104342:	3714      	adds	r7, #20
 8104344:	46bd      	mov	sp, r7
 8104346:	f85d 7b04 	ldr.w	r7, [sp], #4
 810434a:	4770      	bx	lr
 810434c:	00048083 	.word	0x00048083
 8104350:	c0f88000 	.word	0xc0f88000

08104354 <ETH_SetDMAConfig>:

static void ETH_SetDMAConfig(ETH_HandleTypeDef *heth, const ETH_DMAConfigTypeDef *dmaconf)
{
 8104354:	b480      	push	{r7}
 8104356:	b085      	sub	sp, #20
 8104358:	af00      	add	r7, sp, #0
 810435a:	6078      	str	r0, [r7, #4]
 810435c:	6039      	str	r1, [r7, #0]
  uint32_t dmaregval;

  /*------------------------ DMAMR Configuration --------------------*/
  MODIFY_REG(heth->Instance->DMAMR, ETH_DMAMR_MASK, dmaconf->DMAArbitration);
 810435e:	687b      	ldr	r3, [r7, #4]
 8104360:	681b      	ldr	r3, [r3, #0]
 8104362:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 8104366:	681b      	ldr	r3, [r3, #0]
 8104368:	f423 43f0 	bic.w	r3, r3, #30720	; 0x7800
 810436c:	f023 0302 	bic.w	r3, r3, #2
 8104370:	683a      	ldr	r2, [r7, #0]
 8104372:	6811      	ldr	r1, [r2, #0]
 8104374:	687a      	ldr	r2, [r7, #4]
 8104376:	6812      	ldr	r2, [r2, #0]
 8104378:	430b      	orrs	r3, r1
 810437a:	f502 5280 	add.w	r2, r2, #4096	; 0x1000
 810437e:	6013      	str	r3, [r2, #0]

  /*------------------------ DMASBMR Configuration --------------------*/
  dmaregval = (((uint32_t)dmaconf->AddressAlignedBeats << 12) |
 8104380:	683b      	ldr	r3, [r7, #0]
 8104382:	791b      	ldrb	r3, [r3, #4]
 8104384:	031a      	lsls	r2, r3, #12
               dmaconf->BurstMode |
 8104386:	683b      	ldr	r3, [r7, #0]
 8104388:	689b      	ldr	r3, [r3, #8]
  dmaregval = (((uint32_t)dmaconf->AddressAlignedBeats << 12) |
 810438a:	431a      	orrs	r2, r3
               ((uint32_t)dmaconf->RebuildINCRxBurst << 15));
 810438c:	683b      	ldr	r3, [r7, #0]
 810438e:	7b1b      	ldrb	r3, [r3, #12]
 8104390:	03db      	lsls	r3, r3, #15
  dmaregval = (((uint32_t)dmaconf->AddressAlignedBeats << 12) |
 8104392:	4313      	orrs	r3, r2
 8104394:	60fb      	str	r3, [r7, #12]

  MODIFY_REG(heth->Instance->DMASBMR, ETH_DMASBMR_MASK, dmaregval);
 8104396:	687b      	ldr	r3, [r7, #4]
 8104398:	681b      	ldr	r3, [r3, #0]
 810439a:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 810439e:	685b      	ldr	r3, [r3, #4]
 81043a0:	f423 4350 	bic.w	r3, r3, #53248	; 0xd000
 81043a4:	f023 0301 	bic.w	r3, r3, #1
 81043a8:	687a      	ldr	r2, [r7, #4]
 81043aa:	6812      	ldr	r2, [r2, #0]
 81043ac:	68f9      	ldr	r1, [r7, #12]
 81043ae:	430b      	orrs	r3, r1
 81043b0:	f502 5280 	add.w	r2, r2, #4096	; 0x1000
 81043b4:	6053      	str	r3, [r2, #4]

  /*------------------------ DMACCR Configuration --------------------*/
  dmaregval = (((uint32_t)dmaconf->PBLx8Mode << 16) |
 81043b6:	683b      	ldr	r3, [r7, #0]
 81043b8:	7b5b      	ldrb	r3, [r3, #13]
 81043ba:	041a      	lsls	r2, r3, #16
               dmaconf->MaximumSegmentSize);
 81043bc:	683b      	ldr	r3, [r7, #0]
 81043be:	6a1b      	ldr	r3, [r3, #32]
  dmaregval = (((uint32_t)dmaconf->PBLx8Mode << 16) |
 81043c0:	4313      	orrs	r3, r2
 81043c2:	60fb      	str	r3, [r7, #12]
  MODIFY_REG(heth->Instance->DMACCR, ETH_DMACCR_MASK, dmaregval);
 81043c4:	687b      	ldr	r3, [r7, #4]
 81043c6:	681b      	ldr	r3, [r3, #0]
 81043c8:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 81043cc:	f8d3 2100 	ldr.w	r2, [r3, #256]	; 0x100
 81043d0:	4b21      	ldr	r3, [pc, #132]	; (8104458 <ETH_SetDMAConfig+0x104>)
 81043d2:	4013      	ands	r3, r2
 81043d4:	687a      	ldr	r2, [r7, #4]
 81043d6:	6812      	ldr	r2, [r2, #0]
 81043d8:	68f9      	ldr	r1, [r7, #12]
 81043da:	430b      	orrs	r3, r1
 81043dc:	f502 5280 	add.w	r2, r2, #4096	; 0x1000
 81043e0:	f8c2 3100 	str.w	r3, [r2, #256]	; 0x100

  /*------------------------ DMACTCR Configuration --------------------*/
  dmaregval = (dmaconf->TxDMABurstLength |
 81043e4:	683b      	ldr	r3, [r7, #0]
 81043e6:	691a      	ldr	r2, [r3, #16]
               ((uint32_t)dmaconf->SecondPacketOperate << 4) |
 81043e8:	683b      	ldr	r3, [r7, #0]
 81043ea:	7d1b      	ldrb	r3, [r3, #20]
 81043ec:	011b      	lsls	r3, r3, #4
  dmaregval = (dmaconf->TxDMABurstLength |
 81043ee:	431a      	orrs	r2, r3
               ((uint32_t)dmaconf->TCPSegmentation << 12));
 81043f0:	683b      	ldr	r3, [r7, #0]
 81043f2:	7f5b      	ldrb	r3, [r3, #29]
 81043f4:	031b      	lsls	r3, r3, #12
  dmaregval = (dmaconf->TxDMABurstLength |
 81043f6:	4313      	orrs	r3, r2
 81043f8:	60fb      	str	r3, [r7, #12]

  MODIFY_REG(heth->Instance->DMACTCR, ETH_DMACTCR_MASK, dmaregval);
 81043fa:	687b      	ldr	r3, [r7, #4]
 81043fc:	681b      	ldr	r3, [r3, #0]
 81043fe:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 8104402:	f8d3 2104 	ldr.w	r2, [r3, #260]	; 0x104
 8104406:	4b15      	ldr	r3, [pc, #84]	; (810445c <ETH_SetDMAConfig+0x108>)
 8104408:	4013      	ands	r3, r2
 810440a:	687a      	ldr	r2, [r7, #4]
 810440c:	6812      	ldr	r2, [r2, #0]
 810440e:	68f9      	ldr	r1, [r7, #12]
 8104410:	430b      	orrs	r3, r1
 8104412:	f502 5280 	add.w	r2, r2, #4096	; 0x1000
 8104416:	f8c2 3104 	str.w	r3, [r2, #260]	; 0x104

  /*------------------------ DMACRCR Configuration --------------------*/
  dmaregval = (((uint32_t)dmaconf->FlushRxPacket  << 31) |
 810441a:	683b      	ldr	r3, [r7, #0]
 810441c:	7f1b      	ldrb	r3, [r3, #28]
 810441e:	07da      	lsls	r2, r3, #31
               dmaconf->RxDMABurstLength);
 8104420:	683b      	ldr	r3, [r7, #0]
 8104422:	699b      	ldr	r3, [r3, #24]
  dmaregval = (((uint32_t)dmaconf->FlushRxPacket  << 31) |
 8104424:	4313      	orrs	r3, r2
 8104426:	60fb      	str	r3, [r7, #12]

  /* Write to DMACRCR */
  MODIFY_REG(heth->Instance->DMACRCR, ETH_DMACRCR_MASK, dmaregval);
 8104428:	687b      	ldr	r3, [r7, #4]
 810442a:	681b      	ldr	r3, [r3, #0]
 810442c:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 8104430:	f8d3 3108 	ldr.w	r3, [r3, #264]	; 0x108
 8104434:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 8104438:	f423 137c 	bic.w	r3, r3, #4128768	; 0x3f0000
 810443c:	687a      	ldr	r2, [r7, #4]
 810443e:	6812      	ldr	r2, [r2, #0]
 8104440:	68f9      	ldr	r1, [r7, #12]
 8104442:	430b      	orrs	r3, r1
 8104444:	f502 5280 	add.w	r2, r2, #4096	; 0x1000
 8104448:	f8c2 3108 	str.w	r3, [r2, #264]	; 0x108
}
 810444c:	bf00      	nop
 810444e:	3714      	adds	r7, #20
 8104450:	46bd      	mov	sp, r7
 8104452:	f85d 7b04 	ldr.w	r7, [sp], #4
 8104456:	4770      	bx	lr
 8104458:	fffec000 	.word	0xfffec000
 810445c:	ffc0efef 	.word	0xffc0efef

08104460 <ETH_MACDMAConfig>:
  * @param  heth: pointer to a ETH_HandleTypeDef structure that contains
  *         the configuration information for ETHERNET module
  * @retval HAL status
  */
static void ETH_MACDMAConfig(ETH_HandleTypeDef *heth)
{
 8104460:	b580      	push	{r7, lr}
 8104462:	b0a4      	sub	sp, #144	; 0x90
 8104464:	af00      	add	r7, sp, #0
 8104466:	6078      	str	r0, [r7, #4]
  ETH_MACConfigTypeDef macDefaultConf;
  ETH_DMAConfigTypeDef dmaDefaultConf;

  /*--------------- ETHERNET MAC registers default Configuration --------------*/
  macDefaultConf.AutomaticPadCRCStrip = ENABLE;
 8104468:	2301      	movs	r3, #1
 810446a:	f887 303b 	strb.w	r3, [r7, #59]	; 0x3b
  macDefaultConf.BackOffLimit = ETH_BACKOFFLIMIT_10;
 810446e:	2300      	movs	r3, #0
 8104470:	653b      	str	r3, [r7, #80]	; 0x50
  macDefaultConf.CarrierSenseBeforeTransmit = DISABLE;
 8104472:	2300      	movs	r3, #0
 8104474:	f887 3049 	strb.w	r3, [r7, #73]	; 0x49
  macDefaultConf.CarrierSenseDuringTransmit = DISABLE;
 8104478:	2300      	movs	r3, #0
 810447a:	f887 304b 	strb.w	r3, [r7, #75]	; 0x4b
  macDefaultConf.ChecksumOffload = ENABLE;
 810447e:	2301      	movs	r3, #1
 8104480:	f887 3030 	strb.w	r3, [r7, #48]	; 0x30
  macDefaultConf.CRCCheckingRxPackets = ENABLE;
 8104484:	2301      	movs	r3, #1
 8104486:	f887 305e 	strb.w	r3, [r7, #94]	; 0x5e
  macDefaultConf.CRCStripTypePacket = ENABLE;
 810448a:	2301      	movs	r3, #1
 810448c:	f887 303a 	strb.w	r3, [r7, #58]	; 0x3a
  macDefaultConf.DeferralCheck = DISABLE;
 8104490:	2300      	movs	r3, #0
 8104492:	f887 3054 	strb.w	r3, [r7, #84]	; 0x54
  macDefaultConf.DropTCPIPChecksumErrorPacket = ENABLE;
 8104496:	2301      	movs	r3, #1
 8104498:	f887 308c 	strb.w	r3, [r7, #140]	; 0x8c
  macDefaultConf.DuplexMode = ETH_FULLDUPLEX_MODE;
 810449c:	f44f 5300 	mov.w	r3, #8192	; 0x2000
 81044a0:	647b      	str	r3, [r7, #68]	; 0x44
  macDefaultConf.ExtendedInterPacketGap = DISABLE;
 81044a2:	2300      	movs	r3, #0
 81044a4:	f887 3064 	strb.w	r3, [r7, #100]	; 0x64
  macDefaultConf.ExtendedInterPacketGapVal = 0x0U;
 81044a8:	2300      	movs	r3, #0
 81044aa:	66bb      	str	r3, [r7, #104]	; 0x68
  macDefaultConf.ForwardRxErrorPacket = DISABLE;
 81044ac:	2300      	movs	r3, #0
 81044ae:	f887 308d 	strb.w	r3, [r7, #141]	; 0x8d
  macDefaultConf.ForwardRxUndersizedGoodPacket = DISABLE;
 81044b2:	2300      	movs	r3, #0
 81044b4:	f887 308e 	strb.w	r3, [r7, #142]	; 0x8e
  macDefaultConf.GiantPacketSizeLimit = 0x618U;
 81044b8:	f44f 63c3 	mov.w	r3, #1560	; 0x618
 81044bc:	663b      	str	r3, [r7, #96]	; 0x60
  macDefaultConf.GiantPacketSizeLimitControl = DISABLE;
 81044be:	2300      	movs	r3, #0
 81044c0:	f887 3038 	strb.w	r3, [r7, #56]	; 0x38
  macDefaultConf.InterPacketGapVal = ETH_INTERPACKETGAP_96BIT;
 81044c4:	2300      	movs	r3, #0
 81044c6:	637b      	str	r3, [r7, #52]	; 0x34
  macDefaultConf.Jabber = ENABLE;
 81044c8:	2301      	movs	r3, #1
 81044ca:	f887 303d 	strb.w	r3, [r7, #61]	; 0x3d
  macDefaultConf.JumboPacket = DISABLE;
 81044ce:	2300      	movs	r3, #0
 81044d0:	f887 303e 	strb.w	r3, [r7, #62]	; 0x3e
  macDefaultConf.LoopbackMode = DISABLE;
 81044d4:	2300      	movs	r3, #0
 81044d6:	f887 3048 	strb.w	r3, [r7, #72]	; 0x48
  macDefaultConf.PauseLowThreshold = ETH_PAUSELOWTHRESHOLD_MINUS_4;
 81044da:	2300      	movs	r3, #0
 81044dc:	67fb      	str	r3, [r7, #124]	; 0x7c
  macDefaultConf.PauseTime = 0x0U;
 81044de:	2300      	movs	r3, #0
 81044e0:	677b      	str	r3, [r7, #116]	; 0x74
  macDefaultConf.PreambleLength = ETH_PREAMBLELENGTH_7;
 81044e2:	2300      	movs	r3, #0
 81044e4:	65bb      	str	r3, [r7, #88]	; 0x58
  macDefaultConf.ProgrammableWatchdog = DISABLE;
 81044e6:	2300      	movs	r3, #0
 81044e8:	f887 306c 	strb.w	r3, [r7, #108]	; 0x6c
  macDefaultConf.ReceiveFlowControl = DISABLE;
 81044ec:	2300      	movs	r3, #0
 81044ee:	f887 3082 	strb.w	r3, [r7, #130]	; 0x82
  macDefaultConf.ReceiveOwn = ENABLE;
 81044f2:	2301      	movs	r3, #1
 81044f4:	f887 304a 	strb.w	r3, [r7, #74]	; 0x4a
  macDefaultConf.ReceiveQueueMode = ETH_RECEIVESTOREFORWARD;
 81044f8:	2320      	movs	r3, #32
 81044fa:	f8c7 3088 	str.w	r3, [r7, #136]	; 0x88
  macDefaultConf.RetryTransmission = ENABLE;
 81044fe:	2301      	movs	r3, #1
 8104500:	f887 304c 	strb.w	r3, [r7, #76]	; 0x4c
  macDefaultConf.SlowProtocolDetect = DISABLE;
 8104504:	2300      	movs	r3, #0
 8104506:	f887 305d 	strb.w	r3, [r7, #93]	; 0x5d
  macDefaultConf.SourceAddrControl = ETH_SOURCEADDRESS_REPLACE_ADDR0;
 810450a:	f04f 5340 	mov.w	r3, #805306368	; 0x30000000
 810450e:	62fb      	str	r3, [r7, #44]	; 0x2c
  macDefaultConf.Speed = ETH_SPEED_100M;
 8104510:	f44f 4380 	mov.w	r3, #16384	; 0x4000
 8104514:	643b      	str	r3, [r7, #64]	; 0x40
  macDefaultConf.Support2KPacket = DISABLE;
 8104516:	2300      	movs	r3, #0
 8104518:	f887 3039 	strb.w	r3, [r7, #57]	; 0x39
  macDefaultConf.TransmitQueueMode = ETH_TRANSMITSTOREFORWARD;
 810451c:	2302      	movs	r3, #2
 810451e:	f8c7 3084 	str.w	r3, [r7, #132]	; 0x84
  macDefaultConf.TransmitFlowControl = DISABLE;
 8104522:	2300      	movs	r3, #0
 8104524:	f887 3080 	strb.w	r3, [r7, #128]	; 0x80
  macDefaultConf.UnicastPausePacketDetect = DISABLE;
 8104528:	2300      	movs	r3, #0
 810452a:	f887 3081 	strb.w	r3, [r7, #129]	; 0x81
  macDefaultConf.UnicastSlowProtocolPacketDetect = DISABLE;
 810452e:	2300      	movs	r3, #0
 8104530:	f887 305c 	strb.w	r3, [r7, #92]	; 0x5c
  macDefaultConf.Watchdog = ENABLE;
 8104534:	2301      	movs	r3, #1
 8104536:	f887 303c 	strb.w	r3, [r7, #60]	; 0x3c
  macDefaultConf.WatchdogTimeout =  ETH_MACWTR_WTO_2KB;
 810453a:	2300      	movs	r3, #0
 810453c:	673b      	str	r3, [r7, #112]	; 0x70
  macDefaultConf.ZeroQuantaPause = ENABLE;
 810453e:	2301      	movs	r3, #1
 8104540:	f887 3078 	strb.w	r3, [r7, #120]	; 0x78

  /* MAC default configuration */
  ETH_SetMACConfig(heth, &macDefaultConf);
 8104544:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 8104548:	4619      	mov	r1, r3
 810454a:	6878      	ldr	r0, [r7, #4]
 810454c:	f7ff fde6 	bl	810411c <ETH_SetMACConfig>

  /*--------------- ETHERNET DMA registers default Configuration --------------*/
  dmaDefaultConf.AddressAlignedBeats = ENABLE;
 8104550:	2301      	movs	r3, #1
 8104552:	733b      	strb	r3, [r7, #12]
  dmaDefaultConf.BurstMode = ETH_BURSTLENGTH_FIXED;
 8104554:	2301      	movs	r3, #1
 8104556:	613b      	str	r3, [r7, #16]
  dmaDefaultConf.DMAArbitration = ETH_DMAARBITRATION_RX1_TX1;
 8104558:	2300      	movs	r3, #0
 810455a:	60bb      	str	r3, [r7, #8]
  dmaDefaultConf.FlushRxPacket = DISABLE;
 810455c:	2300      	movs	r3, #0
 810455e:	f887 3024 	strb.w	r3, [r7, #36]	; 0x24
  dmaDefaultConf.PBLx8Mode = DISABLE;
 8104562:	2300      	movs	r3, #0
 8104564:	757b      	strb	r3, [r7, #21]
  dmaDefaultConf.RebuildINCRxBurst = DISABLE;
 8104566:	2300      	movs	r3, #0
 8104568:	753b      	strb	r3, [r7, #20]
  dmaDefaultConf.RxDMABurstLength = ETH_RXDMABURSTLENGTH_32BEAT;
 810456a:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 810456e:	623b      	str	r3, [r7, #32]
  dmaDefaultConf.SecondPacketOperate = DISABLE;
 8104570:	2300      	movs	r3, #0
 8104572:	773b      	strb	r3, [r7, #28]
  dmaDefaultConf.TxDMABurstLength = ETH_TXDMABURSTLENGTH_32BEAT;
 8104574:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 8104578:	61bb      	str	r3, [r7, #24]
  dmaDefaultConf.TCPSegmentation = DISABLE;
 810457a:	2300      	movs	r3, #0
 810457c:	f887 3025 	strb.w	r3, [r7, #37]	; 0x25
  dmaDefaultConf.MaximumSegmentSize = ETH_SEGMENT_SIZE_DEFAULT;
 8104580:	f44f 7306 	mov.w	r3, #536	; 0x218
 8104584:	62bb      	str	r3, [r7, #40]	; 0x28

  /* DMA default configuration */
  ETH_SetDMAConfig(heth, &dmaDefaultConf);
 8104586:	f107 0308 	add.w	r3, r7, #8
 810458a:	4619      	mov	r1, r3
 810458c:	6878      	ldr	r0, [r7, #4]
 810458e:	f7ff fee1 	bl	8104354 <ETH_SetDMAConfig>
}
 8104592:	bf00      	nop
 8104594:	3790      	adds	r7, #144	; 0x90
 8104596:	46bd      	mov	sp, r7
 8104598:	bd80      	pop	{r7, pc}

0810459a <ETH_DMATxDescListInit>:
  * @param  heth: pointer to a ETH_HandleTypeDef structure that contains
  *         the configuration information for ETHERNET module
  * @retval None
  */
static void ETH_DMATxDescListInit(ETH_HandleTypeDef *heth)
{
 810459a:	b480      	push	{r7}
 810459c:	b085      	sub	sp, #20
 810459e:	af00      	add	r7, sp, #0
 81045a0:	6078      	str	r0, [r7, #4]
  ETH_DMADescTypeDef *dmatxdesc;
  uint32_t i;

  /* Fill each DMATxDesc descriptor with the right values */
  for (i = 0; i < (uint32_t)ETH_TX_DESC_CNT; i++)
 81045a2:	2300      	movs	r3, #0
 81045a4:	60fb      	str	r3, [r7, #12]
 81045a6:	e01d      	b.n	81045e4 <ETH_DMATxDescListInit+0x4a>
  {
    dmatxdesc = heth->Init.TxDesc + i;
 81045a8:	687b      	ldr	r3, [r7, #4]
 81045aa:	68d9      	ldr	r1, [r3, #12]
 81045ac:	68fa      	ldr	r2, [r7, #12]
 81045ae:	4613      	mov	r3, r2
 81045b0:	005b      	lsls	r3, r3, #1
 81045b2:	4413      	add	r3, r2
 81045b4:	00db      	lsls	r3, r3, #3
 81045b6:	440b      	add	r3, r1
 81045b8:	60bb      	str	r3, [r7, #8]

    WRITE_REG(dmatxdesc->DESC0, 0x0U);
 81045ba:	68bb      	ldr	r3, [r7, #8]
 81045bc:	2200      	movs	r2, #0
 81045be:	601a      	str	r2, [r3, #0]
    WRITE_REG(dmatxdesc->DESC1, 0x0U);
 81045c0:	68bb      	ldr	r3, [r7, #8]
 81045c2:	2200      	movs	r2, #0
 81045c4:	605a      	str	r2, [r3, #4]
    WRITE_REG(dmatxdesc->DESC2, 0x0U);
 81045c6:	68bb      	ldr	r3, [r7, #8]
 81045c8:	2200      	movs	r2, #0
 81045ca:	609a      	str	r2, [r3, #8]
    WRITE_REG(dmatxdesc->DESC3, 0x0U);
 81045cc:	68bb      	ldr	r3, [r7, #8]
 81045ce:	2200      	movs	r2, #0
 81045d0:	60da      	str	r2, [r3, #12]

    WRITE_REG(heth->TxDescList.TxDesc[i], (uint32_t)dmatxdesc);
 81045d2:	68b9      	ldr	r1, [r7, #8]
 81045d4:	687b      	ldr	r3, [r7, #4]
 81045d6:	68fa      	ldr	r2, [r7, #12]
 81045d8:	3206      	adds	r2, #6
 81045da:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
  for (i = 0; i < (uint32_t)ETH_TX_DESC_CNT; i++)
 81045de:	68fb      	ldr	r3, [r7, #12]
 81045e0:	3301      	adds	r3, #1
 81045e2:	60fb      	str	r3, [r7, #12]
 81045e4:	68fb      	ldr	r3, [r7, #12]
 81045e6:	2b03      	cmp	r3, #3
 81045e8:	d9de      	bls.n	81045a8 <ETH_DMATxDescListInit+0xe>

  }

  heth->TxDescList.CurTxDesc = 0;
 81045ea:	687b      	ldr	r3, [r7, #4]
 81045ec:	2200      	movs	r2, #0
 81045ee:	629a      	str	r2, [r3, #40]	; 0x28

  /* Set Transmit Descriptor Ring Length */
  WRITE_REG(heth->Instance->DMACTDRLR, (ETH_TX_DESC_CNT - 1U));
 81045f0:	687b      	ldr	r3, [r7, #4]
 81045f2:	681b      	ldr	r3, [r3, #0]
 81045f4:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 81045f8:	461a      	mov	r2, r3
 81045fa:	2303      	movs	r3, #3
 81045fc:	f8c2 312c 	str.w	r3, [r2, #300]	; 0x12c

  /* Set Transmit Descriptor List Address */
  WRITE_REG(heth->Instance->DMACTDLAR, (uint32_t) heth->Init.TxDesc);
 8104600:	687b      	ldr	r3, [r7, #4]
 8104602:	68da      	ldr	r2, [r3, #12]
 8104604:	687b      	ldr	r3, [r7, #4]
 8104606:	681b      	ldr	r3, [r3, #0]
 8104608:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 810460c:	f8c3 2114 	str.w	r2, [r3, #276]	; 0x114

  /* Set Transmit Descriptor Tail pointer */
  WRITE_REG(heth->Instance->DMACTDTPR, (uint32_t) heth->Init.TxDesc);
 8104610:	687b      	ldr	r3, [r7, #4]
 8104612:	68da      	ldr	r2, [r3, #12]
 8104614:	687b      	ldr	r3, [r7, #4]
 8104616:	681b      	ldr	r3, [r3, #0]
 8104618:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 810461c:	f8c3 2120 	str.w	r2, [r3, #288]	; 0x120
}
 8104620:	bf00      	nop
 8104622:	3714      	adds	r7, #20
 8104624:	46bd      	mov	sp, r7
 8104626:	f85d 7b04 	ldr.w	r7, [sp], #4
 810462a:	4770      	bx	lr

0810462c <ETH_DMARxDescListInit>:
  * @param  heth: pointer to a ETH_HandleTypeDef structure that contains
  *         the configuration information for ETHERNET module
  * @retval None
  */
static void ETH_DMARxDescListInit(ETH_HandleTypeDef *heth)
{
 810462c:	b480      	push	{r7}
 810462e:	b085      	sub	sp, #20
 8104630:	af00      	add	r7, sp, #0
 8104632:	6078      	str	r0, [r7, #4]
  ETH_DMADescTypeDef *dmarxdesc;
  uint32_t i;

  for (i = 0; i < (uint32_t)ETH_RX_DESC_CNT; i++)
 8104634:	2300      	movs	r3, #0
 8104636:	60fb      	str	r3, [r7, #12]
 8104638:	e023      	b.n	8104682 <ETH_DMARxDescListInit+0x56>
  {
    dmarxdesc =  heth->Init.RxDesc + i;
 810463a:	687b      	ldr	r3, [r7, #4]
 810463c:	6919      	ldr	r1, [r3, #16]
 810463e:	68fa      	ldr	r2, [r7, #12]
 8104640:	4613      	mov	r3, r2
 8104642:	005b      	lsls	r3, r3, #1
 8104644:	4413      	add	r3, r2
 8104646:	00db      	lsls	r3, r3, #3
 8104648:	440b      	add	r3, r1
 810464a:	60bb      	str	r3, [r7, #8]

    WRITE_REG(dmarxdesc->DESC0, 0x0U);
 810464c:	68bb      	ldr	r3, [r7, #8]
 810464e:	2200      	movs	r2, #0
 8104650:	601a      	str	r2, [r3, #0]
    WRITE_REG(dmarxdesc->DESC1, 0x0U);
 8104652:	68bb      	ldr	r3, [r7, #8]
 8104654:	2200      	movs	r2, #0
 8104656:	605a      	str	r2, [r3, #4]
    WRITE_REG(dmarxdesc->DESC2, 0x0U);
 8104658:	68bb      	ldr	r3, [r7, #8]
 810465a:	2200      	movs	r2, #0
 810465c:	609a      	str	r2, [r3, #8]
    WRITE_REG(dmarxdesc->DESC3, 0x0U);
 810465e:	68bb      	ldr	r3, [r7, #8]
 8104660:	2200      	movs	r2, #0
 8104662:	60da      	str	r2, [r3, #12]
    WRITE_REG(dmarxdesc->BackupAddr0, 0x0U);
 8104664:	68bb      	ldr	r3, [r7, #8]
 8104666:	2200      	movs	r2, #0
 8104668:	611a      	str	r2, [r3, #16]
    WRITE_REG(dmarxdesc->BackupAddr1, 0x0U);
 810466a:	68bb      	ldr	r3, [r7, #8]
 810466c:	2200      	movs	r2, #0
 810466e:	615a      	str	r2, [r3, #20]

    /* Set Rx descritors addresses */
    WRITE_REG(heth->RxDescList.RxDesc[i], (uint32_t)dmarxdesc);
 8104670:	68b9      	ldr	r1, [r7, #8]
 8104672:	687b      	ldr	r3, [r7, #4]
 8104674:	68fa      	ldr	r2, [r7, #12]
 8104676:	3212      	adds	r2, #18
 8104678:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
  for (i = 0; i < (uint32_t)ETH_RX_DESC_CNT; i++)
 810467c:	68fb      	ldr	r3, [r7, #12]
 810467e:	3301      	adds	r3, #1
 8104680:	60fb      	str	r3, [r7, #12]
 8104682:	68fb      	ldr	r3, [r7, #12]
 8104684:	2b03      	cmp	r3, #3
 8104686:	d9d8      	bls.n	810463a <ETH_DMARxDescListInit+0xe>

  }

  WRITE_REG(heth->RxDescList.RxDescIdx, 0U);
 8104688:	687b      	ldr	r3, [r7, #4]
 810468a:	2200      	movs	r2, #0
 810468c:	65da      	str	r2, [r3, #92]	; 0x5c
  WRITE_REG(heth->RxDescList.RxDescCnt, 0U);
 810468e:	687b      	ldr	r3, [r7, #4]
 8104690:	2200      	movs	r2, #0
 8104692:	661a      	str	r2, [r3, #96]	; 0x60
  WRITE_REG(heth->RxDescList.RxBuildDescIdx, 0U);
 8104694:	687b      	ldr	r3, [r7, #4]
 8104696:	2200      	movs	r2, #0
 8104698:	669a      	str	r2, [r3, #104]	; 0x68
  WRITE_REG(heth->RxDescList.RxBuildDescCnt, 0U);
 810469a:	687b      	ldr	r3, [r7, #4]
 810469c:	2200      	movs	r2, #0
 810469e:	66da      	str	r2, [r3, #108]	; 0x6c
  WRITE_REG(heth->RxDescList.ItMode, 0U);
 81046a0:	687b      	ldr	r3, [r7, #4]
 81046a2:	2200      	movs	r2, #0
 81046a4:	659a      	str	r2, [r3, #88]	; 0x58

  /* Set Receive Descriptor Ring Length */
  WRITE_REG(heth->Instance->DMACRDRLR, ((uint32_t)(ETH_RX_DESC_CNT - 1U)));
 81046a6:	687b      	ldr	r3, [r7, #4]
 81046a8:	681b      	ldr	r3, [r3, #0]
 81046aa:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 81046ae:	461a      	mov	r2, r3
 81046b0:	2303      	movs	r3, #3
 81046b2:	f8c2 3130 	str.w	r3, [r2, #304]	; 0x130

  /* Set Receive Descriptor List Address */
  WRITE_REG(heth->Instance->DMACRDLAR, (uint32_t) heth->Init.RxDesc);
 81046b6:	687b      	ldr	r3, [r7, #4]
 81046b8:	691a      	ldr	r2, [r3, #16]
 81046ba:	687b      	ldr	r3, [r7, #4]
 81046bc:	681b      	ldr	r3, [r3, #0]
 81046be:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 81046c2:	f8c3 211c 	str.w	r2, [r3, #284]	; 0x11c

  /* Set Receive Descriptor Tail pointer Address */
  WRITE_REG(heth->Instance->DMACRDTPR, ((uint32_t)(heth->Init.RxDesc + (uint32_t)(ETH_RX_DESC_CNT - 1U))));
 81046c6:	687b      	ldr	r3, [r7, #4]
 81046c8:	691b      	ldr	r3, [r3, #16]
 81046ca:	f103 0248 	add.w	r2, r3, #72	; 0x48
 81046ce:	687b      	ldr	r3, [r7, #4]
 81046d0:	681b      	ldr	r3, [r3, #0]
 81046d2:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 81046d6:	f8c3 2128 	str.w	r2, [r3, #296]	; 0x128
}
 81046da:	bf00      	nop
 81046dc:	3714      	adds	r7, #20
 81046de:	46bd      	mov	sp, r7
 81046e0:	f85d 7b04 	ldr.w	r7, [sp], #4
 81046e4:	4770      	bx	lr

081046e6 <ETH_Prepare_Tx_Descriptors>:
  * @param  ItMode: Enable or disable Tx EOT interrept
  * @retval Status
  */
static uint32_t ETH_Prepare_Tx_Descriptors(ETH_HandleTypeDef *heth, const ETH_TxPacketConfigTypeDef *pTxConfig,
                                           uint32_t ItMode)
{
 81046e6:	b480      	push	{r7}
 81046e8:	b091      	sub	sp, #68	; 0x44
 81046ea:	af00      	add	r7, sp, #0
 81046ec:	60f8      	str	r0, [r7, #12]
 81046ee:	60b9      	str	r1, [r7, #8]
 81046f0:	607a      	str	r2, [r7, #4]
  ETH_TxDescListTypeDef *dmatxdesclist = &heth->TxDescList;
 81046f2:	68fb      	ldr	r3, [r7, #12]
 81046f4:	3318      	adds	r3, #24
 81046f6:	627b      	str	r3, [r7, #36]	; 0x24
  uint32_t descidx = dmatxdesclist->CurTxDesc;
 81046f8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 81046fa:	691b      	ldr	r3, [r3, #16]
 81046fc:	63fb      	str	r3, [r7, #60]	; 0x3c
  uint32_t firstdescidx = dmatxdesclist->CurTxDesc;
 81046fe:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8104700:	691b      	ldr	r3, [r3, #16]
 8104702:	623b      	str	r3, [r7, #32]
  uint32_t idx;
  uint32_t descnbr = 0;
 8104704:	2300      	movs	r3, #0
 8104706:	637b      	str	r3, [r7, #52]	; 0x34
  ETH_DMADescTypeDef *dmatxdesc = (ETH_DMADescTypeDef *)dmatxdesclist->TxDesc[descidx];
 8104708:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 810470a:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 810470c:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8104710:	633b      	str	r3, [r7, #48]	; 0x30

  ETH_BufferTypeDef  *txbuffer = pTxConfig->TxBuffer;
 8104712:	68bb      	ldr	r3, [r7, #8]
 8104714:	689b      	ldr	r3, [r3, #8]
 8104716:	62fb      	str	r3, [r7, #44]	; 0x2c
  uint32_t           bd_count = 0;
 8104718:	2300      	movs	r3, #0
 810471a:	62bb      	str	r3, [r7, #40]	; 0x28
  uint32_t primask_bit;

  /* Current Tx Descriptor Owned by DMA: cannot be used by the application  */
  if ((READ_BIT(dmatxdesc->DESC3, ETH_DMATXNDESCWBF_OWN) == ETH_DMATXNDESCWBF_OWN)
 810471c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 810471e:	68db      	ldr	r3, [r3, #12]
 8104720:	f003 4300 	and.w	r3, r3, #2147483648	; 0x80000000
 8104724:	f1b3 4f00 	cmp.w	r3, #2147483648	; 0x80000000
 8104728:	d007      	beq.n	810473a <ETH_Prepare_Tx_Descriptors+0x54>
      || (dmatxdesclist->PacketAddress[descidx] != NULL))
 810472a:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 810472c:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 810472e:	3304      	adds	r3, #4
 8104730:	009b      	lsls	r3, r3, #2
 8104732:	4413      	add	r3, r2
 8104734:	685b      	ldr	r3, [r3, #4]
 8104736:	2b00      	cmp	r3, #0
 8104738:	d001      	beq.n	810473e <ETH_Prepare_Tx_Descriptors+0x58>
  {
    return HAL_ETH_ERROR_BUSY;
 810473a:	2302      	movs	r3, #2
 810473c:	e267      	b.n	8104c0e <ETH_Prepare_Tx_Descriptors+0x528>

  /***************************************************************************/
  /*****************    Context descriptor configuration (Optional) **********/
  /***************************************************************************/
  /* If VLAN tag is enabled for this packet */
  if (READ_BIT(pTxConfig->Attributes, ETH_TX_PACKETS_FEATURES_VLANTAG) != (uint32_t)RESET)
 810473e:	68bb      	ldr	r3, [r7, #8]
 8104740:	681b      	ldr	r3, [r3, #0]
 8104742:	f003 0304 	and.w	r3, r3, #4
 8104746:	2b00      	cmp	r3, #0
 8104748:	d044      	beq.n	81047d4 <ETH_Prepare_Tx_Descriptors+0xee>
  {
    /* Set vlan tag value */
    MODIFY_REG(dmatxdesc->DESC3, ETH_DMATXCDESC_VT, pTxConfig->VlanTag);
 810474a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 810474c:	68db      	ldr	r3, [r3, #12]
 810474e:	0c1b      	lsrs	r3, r3, #16
 8104750:	041b      	lsls	r3, r3, #16
 8104752:	68ba      	ldr	r2, [r7, #8]
 8104754:	6a52      	ldr	r2, [r2, #36]	; 0x24
 8104756:	431a      	orrs	r2, r3
 8104758:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 810475a:	60da      	str	r2, [r3, #12]
    /* Set vlan tag valid bit */
    SET_BIT(dmatxdesc->DESC3, ETH_DMATXCDESC_VLTV);
 810475c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 810475e:	68db      	ldr	r3, [r3, #12]
 8104760:	f443 3280 	orr.w	r2, r3, #65536	; 0x10000
 8104764:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8104766:	60da      	str	r2, [r3, #12]
    /* Set the descriptor as the vlan input source */
    SET_BIT(heth->Instance->MACVIR, ETH_MACVIR_VLTI);
 8104768:	68fb      	ldr	r3, [r7, #12]
 810476a:	681b      	ldr	r3, [r3, #0]
 810476c:	6e1a      	ldr	r2, [r3, #96]	; 0x60
 810476e:	68fb      	ldr	r3, [r7, #12]
 8104770:	681b      	ldr	r3, [r3, #0]
 8104772:	f442 1280 	orr.w	r2, r2, #1048576	; 0x100000
 8104776:	661a      	str	r2, [r3, #96]	; 0x60

    /* if inner VLAN is enabled */
    if (READ_BIT(pTxConfig->Attributes, ETH_TX_PACKETS_FEATURES_INNERVLANTAG) != (uint32_t)RESET)
 8104778:	68bb      	ldr	r3, [r7, #8]
 810477a:	681b      	ldr	r3, [r3, #0]
 810477c:	f003 0308 	and.w	r3, r3, #8
 8104780:	2b00      	cmp	r3, #0
 8104782:	d027      	beq.n	81047d4 <ETH_Prepare_Tx_Descriptors+0xee>
    {
      /* Set inner vlan tag value */
      MODIFY_REG(dmatxdesc->DESC2, ETH_DMATXCDESC_IVT, (pTxConfig->InnerVlanTag << 16));
 8104784:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8104786:	689b      	ldr	r3, [r3, #8]
 8104788:	b29a      	uxth	r2, r3
 810478a:	68bb      	ldr	r3, [r7, #8]
 810478c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 810478e:	041b      	lsls	r3, r3, #16
 8104790:	431a      	orrs	r2, r3
 8104792:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8104794:	609a      	str	r2, [r3, #8]
      /* Set inner vlan tag valid bit */
      SET_BIT(dmatxdesc->DESC3, ETH_DMATXCDESC_IVLTV);
 8104796:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8104798:	68db      	ldr	r3, [r3, #12]
 810479a:	f443 3200 	orr.w	r2, r3, #131072	; 0x20000
 810479e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 81047a0:	60da      	str	r2, [r3, #12]

      /* Set Vlan Tag control */
      MODIFY_REG(dmatxdesc->DESC3, ETH_DMATXCDESC_IVTIR, pTxConfig->InnerVlanCtrl);
 81047a2:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 81047a4:	68db      	ldr	r3, [r3, #12]
 81047a6:	f423 2240 	bic.w	r2, r3, #786432	; 0xc0000
 81047aa:	68bb      	ldr	r3, [r7, #8]
 81047ac:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 81047ae:	431a      	orrs	r2, r3
 81047b0:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 81047b2:	60da      	str	r2, [r3, #12]

      /* Set the descriptor as the inner vlan input source */
      SET_BIT(heth->Instance->MACIVIR, ETH_MACIVIR_VLTI);
 81047b4:	68fb      	ldr	r3, [r7, #12]
 81047b6:	681b      	ldr	r3, [r3, #0]
 81047b8:	6e5a      	ldr	r2, [r3, #100]	; 0x64
 81047ba:	68fb      	ldr	r3, [r7, #12]
 81047bc:	681b      	ldr	r3, [r3, #0]
 81047be:	f442 1280 	orr.w	r2, r2, #1048576	; 0x100000
 81047c2:	665a      	str	r2, [r3, #100]	; 0x64
      /* Enable double VLAN processing */
      SET_BIT(heth->Instance->MACVTR, ETH_MACVTR_EDVLP);
 81047c4:	68fb      	ldr	r3, [r7, #12]
 81047c6:	681b      	ldr	r3, [r3, #0]
 81047c8:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 81047ca:	68fb      	ldr	r3, [r7, #12]
 81047cc:	681b      	ldr	r3, [r3, #0]
 81047ce:	f042 6280 	orr.w	r2, r2, #67108864	; 0x4000000
 81047d2:	651a      	str	r2, [r3, #80]	; 0x50
    }
  }

  /* if tcp segmentation is enabled for this packet */
  if (READ_BIT(pTxConfig->Attributes, ETH_TX_PACKETS_FEATURES_TSO) != (uint32_t)RESET)
 81047d4:	68bb      	ldr	r3, [r7, #8]
 81047d6:	681b      	ldr	r3, [r3, #0]
 81047d8:	f003 0310 	and.w	r3, r3, #16
 81047dc:	2b00      	cmp	r3, #0
 81047de:	d010      	beq.n	8104802 <ETH_Prepare_Tx_Descriptors+0x11c>
  {
    /* Set MSS value */
    MODIFY_REG(dmatxdesc->DESC2, ETH_DMATXCDESC_MSS, pTxConfig->MaxSegmentSize);
 81047e0:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 81047e2:	689b      	ldr	r3, [r3, #8]
 81047e4:	f423 537f 	bic.w	r3, r3, #16320	; 0x3fc0
 81047e8:	f023 033f 	bic.w	r3, r3, #63	; 0x3f
 81047ec:	68ba      	ldr	r2, [r7, #8]
 81047ee:	6992      	ldr	r2, [r2, #24]
 81047f0:	431a      	orrs	r2, r3
 81047f2:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 81047f4:	609a      	str	r2, [r3, #8]
    /* Set MSS valid bit */
    SET_BIT(dmatxdesc->DESC3, ETH_DMATXCDESC_TCMSSV);
 81047f6:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 81047f8:	68db      	ldr	r3, [r3, #12]
 81047fa:	f043 6280 	orr.w	r2, r3, #67108864	; 0x4000000
 81047fe:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8104800:	60da      	str	r2, [r3, #12]
  }

  if ((READ_BIT(pTxConfig->Attributes, ETH_TX_PACKETS_FEATURES_VLANTAG) != (uint32_t)RESET)
 8104802:	68bb      	ldr	r3, [r7, #8]
 8104804:	681b      	ldr	r3, [r3, #0]
 8104806:	f003 0304 	and.w	r3, r3, #4
 810480a:	2b00      	cmp	r3, #0
 810480c:	d105      	bne.n	810481a <ETH_Prepare_Tx_Descriptors+0x134>
      || (READ_BIT(pTxConfig->Attributes, ETH_TX_PACKETS_FEATURES_TSO) != (uint32_t)RESET))
 810480e:	68bb      	ldr	r3, [r7, #8]
 8104810:	681b      	ldr	r3, [r3, #0]
 8104812:	f003 0310 	and.w	r3, r3, #16
 8104816:	2b00      	cmp	r3, #0
 8104818:	d036      	beq.n	8104888 <ETH_Prepare_Tx_Descriptors+0x1a2>
  {
    /* Set as context descriptor */
    SET_BIT(dmatxdesc->DESC3, ETH_DMATXCDESC_CTXT);
 810481a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 810481c:	68db      	ldr	r3, [r3, #12]
 810481e:	f043 4280 	orr.w	r2, r3, #1073741824	; 0x40000000
 8104822:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8104824:	60da      	str	r2, [r3, #12]
  __ASM volatile ("dmb 0xF":::"memory");
 8104826:	f3bf 8f5f 	dmb	sy
}
 810482a:	bf00      	nop
    /* Ensure rest of descriptor is written to RAM before the OWN bit */
    __DMB();
    /* Set own bit */
    SET_BIT(dmatxdesc->DESC3, ETH_DMATXCDESC_OWN);
 810482c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 810482e:	68db      	ldr	r3, [r3, #12]
 8104830:	f043 4200 	orr.w	r2, r3, #2147483648	; 0x80000000
 8104834:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8104836:	60da      	str	r2, [r3, #12]
    /* Increment current tx descriptor index */
    INCR_TX_DESC_INDEX(descidx, 1U);
 8104838:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 810483a:	3301      	adds	r3, #1
 810483c:	63fb      	str	r3, [r7, #60]	; 0x3c
 810483e:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8104840:	2b03      	cmp	r3, #3
 8104842:	d902      	bls.n	810484a <ETH_Prepare_Tx_Descriptors+0x164>
 8104844:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8104846:	3b04      	subs	r3, #4
 8104848:	63fb      	str	r3, [r7, #60]	; 0x3c
    /* Get current descriptor address */
    dmatxdesc = (ETH_DMADescTypeDef *)dmatxdesclist->TxDesc[descidx];
 810484a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 810484c:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 810484e:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8104852:	633b      	str	r3, [r7, #48]	; 0x30

    descnbr += 1U;
 8104854:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8104856:	3301      	adds	r3, #1
 8104858:	637b      	str	r3, [r7, #52]	; 0x34

    /* Current Tx Descriptor Owned by DMA: cannot be used by the application  */
    if (READ_BIT(dmatxdesc->DESC3, ETH_DMATXNDESCWBF_OWN) == ETH_DMATXNDESCWBF_OWN)
 810485a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 810485c:	68db      	ldr	r3, [r3, #12]
 810485e:	f003 4300 	and.w	r3, r3, #2147483648	; 0x80000000
 8104862:	f1b3 4f00 	cmp.w	r3, #2147483648	; 0x80000000
 8104866:	d10f      	bne.n	8104888 <ETH_Prepare_Tx_Descriptors+0x1a2>
    {
      dmatxdesc = (ETH_DMADescTypeDef *)dmatxdesclist->TxDesc[firstdescidx];
 8104868:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 810486a:	6a3a      	ldr	r2, [r7, #32]
 810486c:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8104870:	633b      	str	r3, [r7, #48]	; 0x30
  __ASM volatile ("dmb 0xF":::"memory");
 8104872:	f3bf 8f5f 	dmb	sy
}
 8104876:	bf00      	nop
      /* Ensure rest of descriptor is written to RAM before the OWN bit */
      __DMB();
      /* Clear own bit */
      CLEAR_BIT(dmatxdesc->DESC3, ETH_DMATXCDESC_OWN);
 8104878:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 810487a:	68db      	ldr	r3, [r3, #12]
 810487c:	f023 4200 	bic.w	r2, r3, #2147483648	; 0x80000000
 8104880:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8104882:	60da      	str	r2, [r3, #12]

      return HAL_ETH_ERROR_BUSY;
 8104884:	2302      	movs	r3, #2
 8104886:	e1c2      	b.n	8104c0e <ETH_Prepare_Tx_Descriptors+0x528>

  /***************************************************************************/
  /*****************    Normal descriptors configuration     *****************/
  /***************************************************************************/

  descnbr += 1U;
 8104888:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 810488a:	3301      	adds	r3, #1
 810488c:	637b      	str	r3, [r7, #52]	; 0x34

  /* Set header or buffer 1 address */
  WRITE_REG(dmatxdesc->DESC0, (uint32_t)txbuffer->buffer);
 810488e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8104890:	681b      	ldr	r3, [r3, #0]
 8104892:	461a      	mov	r2, r3
 8104894:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8104896:	601a      	str	r2, [r3, #0]
  /* Set header or buffer 1 Length */
  MODIFY_REG(dmatxdesc->DESC2, ETH_DMATXNDESCRF_B1L, txbuffer->len);
 8104898:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 810489a:	689b      	ldr	r3, [r3, #8]
 810489c:	f423 537f 	bic.w	r3, r3, #16320	; 0x3fc0
 81048a0:	f023 033f 	bic.w	r3, r3, #63	; 0x3f
 81048a4:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 81048a6:	6852      	ldr	r2, [r2, #4]
 81048a8:	431a      	orrs	r2, r3
 81048aa:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 81048ac:	609a      	str	r2, [r3, #8]

  if (txbuffer->next != NULL)
 81048ae:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 81048b0:	689b      	ldr	r3, [r3, #8]
 81048b2:	2b00      	cmp	r3, #0
 81048b4:	d014      	beq.n	81048e0 <ETH_Prepare_Tx_Descriptors+0x1fa>
  {
    txbuffer = txbuffer->next;
 81048b6:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 81048b8:	689b      	ldr	r3, [r3, #8]
 81048ba:	62fb      	str	r3, [r7, #44]	; 0x2c
    /* Set buffer 2 address */
    WRITE_REG(dmatxdesc->DESC1, (uint32_t)txbuffer->buffer);
 81048bc:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 81048be:	681b      	ldr	r3, [r3, #0]
 81048c0:	461a      	mov	r2, r3
 81048c2:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 81048c4:	605a      	str	r2, [r3, #4]
    /* Set buffer 2 Length */
    MODIFY_REG(dmatxdesc->DESC2, ETH_DMATXNDESCRF_B2L, (txbuffer->len << 16));
 81048c6:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 81048c8:	689b      	ldr	r3, [r3, #8]
 81048ca:	f023 537f 	bic.w	r3, r3, #1069547520	; 0x3fc00000
 81048ce:	f423 137c 	bic.w	r3, r3, #4128768	; 0x3f0000
 81048d2:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 81048d4:	6852      	ldr	r2, [r2, #4]
 81048d6:	0412      	lsls	r2, r2, #16
 81048d8:	431a      	orrs	r2, r3
 81048da:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 81048dc:	609a      	str	r2, [r3, #8]
 81048de:	e00a      	b.n	81048f6 <ETH_Prepare_Tx_Descriptors+0x210>
  }
  else
  {
    WRITE_REG(dmatxdesc->DESC1, 0x0U);
 81048e0:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 81048e2:	2200      	movs	r2, #0
 81048e4:	605a      	str	r2, [r3, #4]
    /* Set buffer 2 Length */
    MODIFY_REG(dmatxdesc->DESC2, ETH_DMATXNDESCRF_B2L, 0x0U);
 81048e6:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 81048e8:	689b      	ldr	r3, [r3, #8]
 81048ea:	f023 537f 	bic.w	r3, r3, #1069547520	; 0x3fc00000
 81048ee:	f423 137c 	bic.w	r3, r3, #4128768	; 0x3f0000
 81048f2:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 81048f4:	6093      	str	r3, [r2, #8]
  }

  if (READ_BIT(pTxConfig->Attributes, ETH_TX_PACKETS_FEATURES_TSO) != (uint32_t)RESET)
 81048f6:	68bb      	ldr	r3, [r7, #8]
 81048f8:	681b      	ldr	r3, [r3, #0]
 81048fa:	f003 0310 	and.w	r3, r3, #16
 81048fe:	2b00      	cmp	r3, #0
 8104900:	d019      	beq.n	8104936 <ETH_Prepare_Tx_Descriptors+0x250>
  {
    /* Set TCP Header length */
    MODIFY_REG(dmatxdesc->DESC3, ETH_DMATXNDESCRF_THL, (pTxConfig->TCPHeaderLen << 19));
 8104902:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8104904:	68db      	ldr	r3, [r3, #12]
 8104906:	f423 02f0 	bic.w	r2, r3, #7864320	; 0x780000
 810490a:	68bb      	ldr	r3, [r7, #8]
 810490c:	6a1b      	ldr	r3, [r3, #32]
 810490e:	04db      	lsls	r3, r3, #19
 8104910:	431a      	orrs	r2, r3
 8104912:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8104914:	60da      	str	r2, [r3, #12]
    /* Set TCP payload length */
    MODIFY_REG(dmatxdesc->DESC3, ETH_DMATXNDESCRF_TPL, pTxConfig->PayloadLen);
 8104916:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8104918:	68db      	ldr	r3, [r3, #12]
 810491a:	0c9b      	lsrs	r3, r3, #18
 810491c:	049b      	lsls	r3, r3, #18
 810491e:	68ba      	ldr	r2, [r7, #8]
 8104920:	69d2      	ldr	r2, [r2, #28]
 8104922:	431a      	orrs	r2, r3
 8104924:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8104926:	60da      	str	r2, [r3, #12]
    /* Set TCP Segmentation Enabled bit */
    SET_BIT(dmatxdesc->DESC3, ETH_DMATXNDESCRF_TSE);
 8104928:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 810492a:	68db      	ldr	r3, [r3, #12]
 810492c:	f443 2280 	orr.w	r2, r3, #262144	; 0x40000
 8104930:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8104932:	60da      	str	r2, [r3, #12]
 8104934:	e028      	b.n	8104988 <ETH_Prepare_Tx_Descriptors+0x2a2>
  }
  else
  {
    MODIFY_REG(dmatxdesc->DESC3, ETH_DMATXNDESCRF_FL, pTxConfig->Length);
 8104936:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8104938:	68db      	ldr	r3, [r3, #12]
 810493a:	f423 43ff 	bic.w	r3, r3, #32640	; 0x7f80
 810493e:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
 8104942:	68ba      	ldr	r2, [r7, #8]
 8104944:	6852      	ldr	r2, [r2, #4]
 8104946:	431a      	orrs	r2, r3
 8104948:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 810494a:	60da      	str	r2, [r3, #12]

    if (READ_BIT(pTxConfig->Attributes, ETH_TX_PACKETS_FEATURES_CSUM) != (uint32_t)RESET)
 810494c:	68bb      	ldr	r3, [r7, #8]
 810494e:	681b      	ldr	r3, [r3, #0]
 8104950:	f003 0301 	and.w	r3, r3, #1
 8104954:	2b00      	cmp	r3, #0
 8104956:	d008      	beq.n	810496a <ETH_Prepare_Tx_Descriptors+0x284>
    {
      MODIFY_REG(dmatxdesc->DESC3, ETH_DMATXNDESCRF_CIC, pTxConfig->ChecksumCtrl);
 8104958:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 810495a:	68db      	ldr	r3, [r3, #12]
 810495c:	f423 3240 	bic.w	r2, r3, #196608	; 0x30000
 8104960:	68bb      	ldr	r3, [r7, #8]
 8104962:	695b      	ldr	r3, [r3, #20]
 8104964:	431a      	orrs	r2, r3
 8104966:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8104968:	60da      	str	r2, [r3, #12]
    }

    if (READ_BIT(pTxConfig->Attributes, ETH_TX_PACKETS_FEATURES_CRCPAD) != (uint32_t)RESET)
 810496a:	68bb      	ldr	r3, [r7, #8]
 810496c:	681b      	ldr	r3, [r3, #0]
 810496e:	f003 0320 	and.w	r3, r3, #32
 8104972:	2b00      	cmp	r3, #0
 8104974:	d008      	beq.n	8104988 <ETH_Prepare_Tx_Descriptors+0x2a2>
    {
      MODIFY_REG(dmatxdesc->DESC3, ETH_DMATXNDESCRF_CPC, pTxConfig->CRCPadCtrl);
 8104976:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8104978:	68db      	ldr	r3, [r3, #12]
 810497a:	f023 6240 	bic.w	r2, r3, #201326592	; 0xc000000
 810497e:	68bb      	ldr	r3, [r7, #8]
 8104980:	691b      	ldr	r3, [r3, #16]
 8104982:	431a      	orrs	r2, r3
 8104984:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8104986:	60da      	str	r2, [r3, #12]
    }
  }

  if (READ_BIT(pTxConfig->Attributes, ETH_TX_PACKETS_FEATURES_VLANTAG) != (uint32_t)RESET)
 8104988:	68bb      	ldr	r3, [r7, #8]
 810498a:	681b      	ldr	r3, [r3, #0]
 810498c:	f003 0304 	and.w	r3, r3, #4
 8104990:	2b00      	cmp	r3, #0
 8104992:	d008      	beq.n	81049a6 <ETH_Prepare_Tx_Descriptors+0x2c0>
  {
    /* Set Vlan Tag control */
    MODIFY_REG(dmatxdesc->DESC2, ETH_DMATXNDESCRF_VTIR, pTxConfig->VlanCtrl);
 8104994:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8104996:	689b      	ldr	r3, [r3, #8]
 8104998:	f423 4240 	bic.w	r2, r3, #49152	; 0xc000
 810499c:	68bb      	ldr	r3, [r7, #8]
 810499e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 81049a0:	431a      	orrs	r2, r3
 81049a2:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 81049a4:	609a      	str	r2, [r3, #8]
  }

  /* Mark it as First Descriptor */
  SET_BIT(dmatxdesc->DESC3, ETH_DMATXNDESCRF_FD);
 81049a6:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 81049a8:	68db      	ldr	r3, [r3, #12]
 81049aa:	f043 5200 	orr.w	r2, r3, #536870912	; 0x20000000
 81049ae:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 81049b0:	60da      	str	r2, [r3, #12]
  /* Mark it as NORMAL descriptor */
  CLEAR_BIT(dmatxdesc->DESC3, ETH_DMATXNDESCRF_CTXT);
 81049b2:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 81049b4:	68db      	ldr	r3, [r3, #12]
 81049b6:	f023 4280 	bic.w	r2, r3, #1073741824	; 0x40000000
 81049ba:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 81049bc:	60da      	str	r2, [r3, #12]
  __ASM volatile ("dmb 0xF":::"memory");
 81049be:	f3bf 8f5f 	dmb	sy
}
 81049c2:	bf00      	nop
  /* Ensure rest of descriptor is written to RAM before the OWN bit */
  __DMB();
  /* set OWN bit of FIRST descriptor */
  SET_BIT(dmatxdesc->DESC3, ETH_DMATXNDESCRF_OWN);
 81049c4:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 81049c6:	68db      	ldr	r3, [r3, #12]
 81049c8:	f043 4200 	orr.w	r2, r3, #2147483648	; 0x80000000
 81049cc:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 81049ce:	60da      	str	r2, [r3, #12]

  /* If source address insertion/replacement is enabled for this packet */
  if (READ_BIT(pTxConfig->Attributes, ETH_TX_PACKETS_FEATURES_SAIC) != (uint32_t)RESET)
 81049d0:	68bb      	ldr	r3, [r7, #8]
 81049d2:	681b      	ldr	r3, [r3, #0]
 81049d4:	f003 0302 	and.w	r3, r3, #2
 81049d8:	2b00      	cmp	r3, #0
 81049da:	f000 80d9 	beq.w	8104b90 <ETH_Prepare_Tx_Descriptors+0x4aa>
  {
    MODIFY_REG(dmatxdesc->DESC3, ETH_DMATXNDESCRF_SAIC, pTxConfig->SrcAddrCtrl);
 81049de:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 81049e0:	68db      	ldr	r3, [r3, #12]
 81049e2:	f023 7260 	bic.w	r2, r3, #58720256	; 0x3800000
 81049e6:	68bb      	ldr	r3, [r7, #8]
 81049e8:	68db      	ldr	r3, [r3, #12]
 81049ea:	431a      	orrs	r2, r3
 81049ec:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 81049ee:	60da      	str	r2, [r3, #12]
  }

  /* only if the packet is split into more than one descriptors > 1 */
  while (txbuffer->next != NULL)
 81049f0:	e0ce      	b.n	8104b90 <ETH_Prepare_Tx_Descriptors+0x4aa>
  {
    /* Clear the LD bit of previous descriptor */
    CLEAR_BIT(dmatxdesc->DESC3, ETH_DMATXNDESCRF_LD);
 81049f2:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 81049f4:	68db      	ldr	r3, [r3, #12]
 81049f6:	f023 5280 	bic.w	r2, r3, #268435456	; 0x10000000
 81049fa:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 81049fc:	60da      	str	r2, [r3, #12]
    /* Increment current tx descriptor index */
    INCR_TX_DESC_INDEX(descidx, 1U);
 81049fe:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8104a00:	3301      	adds	r3, #1
 8104a02:	63fb      	str	r3, [r7, #60]	; 0x3c
 8104a04:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8104a06:	2b03      	cmp	r3, #3
 8104a08:	d902      	bls.n	8104a10 <ETH_Prepare_Tx_Descriptors+0x32a>
 8104a0a:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8104a0c:	3b04      	subs	r3, #4
 8104a0e:	63fb      	str	r3, [r7, #60]	; 0x3c
    /* Get current descriptor address */
    dmatxdesc = (ETH_DMADescTypeDef *)dmatxdesclist->TxDesc[descidx];
 8104a10:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8104a12:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 8104a14:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8104a18:	633b      	str	r3, [r7, #48]	; 0x30

    /* Clear the FD bit of new Descriptor */
    CLEAR_BIT(dmatxdesc->DESC3, ETH_DMATXNDESCRF_FD);
 8104a1a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8104a1c:	68db      	ldr	r3, [r3, #12]
 8104a1e:	f023 5200 	bic.w	r2, r3, #536870912	; 0x20000000
 8104a22:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8104a24:	60da      	str	r2, [r3, #12]

    /* Current Tx Descriptor Owned by DMA: cannot be used by the application  */
    if ((READ_BIT(dmatxdesc->DESC3, ETH_DMATXNDESCRF_OWN) == ETH_DMATXNDESCRF_OWN)
 8104a26:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8104a28:	68db      	ldr	r3, [r3, #12]
 8104a2a:	f003 4300 	and.w	r3, r3, #2147483648	; 0x80000000
 8104a2e:	f1b3 4f00 	cmp.w	r3, #2147483648	; 0x80000000
 8104a32:	d007      	beq.n	8104a44 <ETH_Prepare_Tx_Descriptors+0x35e>
        || (dmatxdesclist->PacketAddress[descidx] != NULL))
 8104a34:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8104a36:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8104a38:	3304      	adds	r3, #4
 8104a3a:	009b      	lsls	r3, r3, #2
 8104a3c:	4413      	add	r3, r2
 8104a3e:	685b      	ldr	r3, [r3, #4]
 8104a40:	2b00      	cmp	r3, #0
 8104a42:	d029      	beq.n	8104a98 <ETH_Prepare_Tx_Descriptors+0x3b2>
    {
      descidx = firstdescidx;
 8104a44:	6a3b      	ldr	r3, [r7, #32]
 8104a46:	63fb      	str	r3, [r7, #60]	; 0x3c
      dmatxdesc = (ETH_DMADescTypeDef *)dmatxdesclist->TxDesc[descidx];
 8104a48:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8104a4a:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 8104a4c:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8104a50:	633b      	str	r3, [r7, #48]	; 0x30

      /* clear previous desc own bit */
      for (idx = 0; idx < descnbr; idx ++)
 8104a52:	2300      	movs	r3, #0
 8104a54:	63bb      	str	r3, [r7, #56]	; 0x38
 8104a56:	e019      	b.n	8104a8c <ETH_Prepare_Tx_Descriptors+0x3a6>
  __ASM volatile ("dmb 0xF":::"memory");
 8104a58:	f3bf 8f5f 	dmb	sy
}
 8104a5c:	bf00      	nop
      {
        /* Ensure rest of descriptor is written to RAM before the OWN bit */
        __DMB();

        CLEAR_BIT(dmatxdesc->DESC3, ETH_DMATXNDESCRF_OWN);
 8104a5e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8104a60:	68db      	ldr	r3, [r3, #12]
 8104a62:	f023 4200 	bic.w	r2, r3, #2147483648	; 0x80000000
 8104a66:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8104a68:	60da      	str	r2, [r3, #12]

        /* Increment current tx descriptor index */
        INCR_TX_DESC_INDEX(descidx, 1U);
 8104a6a:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8104a6c:	3301      	adds	r3, #1
 8104a6e:	63fb      	str	r3, [r7, #60]	; 0x3c
 8104a70:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8104a72:	2b03      	cmp	r3, #3
 8104a74:	d902      	bls.n	8104a7c <ETH_Prepare_Tx_Descriptors+0x396>
 8104a76:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8104a78:	3b04      	subs	r3, #4
 8104a7a:	63fb      	str	r3, [r7, #60]	; 0x3c
        /* Get current descriptor address */
        dmatxdesc = (ETH_DMADescTypeDef *)dmatxdesclist->TxDesc[descidx];
 8104a7c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8104a7e:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 8104a80:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8104a84:	633b      	str	r3, [r7, #48]	; 0x30
      for (idx = 0; idx < descnbr; idx ++)
 8104a86:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8104a88:	3301      	adds	r3, #1
 8104a8a:	63bb      	str	r3, [r7, #56]	; 0x38
 8104a8c:	6bba      	ldr	r2, [r7, #56]	; 0x38
 8104a8e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8104a90:	429a      	cmp	r2, r3
 8104a92:	d3e1      	bcc.n	8104a58 <ETH_Prepare_Tx_Descriptors+0x372>
      }

      return HAL_ETH_ERROR_BUSY;
 8104a94:	2302      	movs	r3, #2
 8104a96:	e0ba      	b.n	8104c0e <ETH_Prepare_Tx_Descriptors+0x528>
    }

    descnbr += 1U;
 8104a98:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8104a9a:	3301      	adds	r3, #1
 8104a9c:	637b      	str	r3, [r7, #52]	; 0x34

    /* Get the next Tx buffer in the list */
    txbuffer = txbuffer->next;
 8104a9e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8104aa0:	689b      	ldr	r3, [r3, #8]
 8104aa2:	62fb      	str	r3, [r7, #44]	; 0x2c

    /* Set header or buffer 1 address */
    WRITE_REG(dmatxdesc->DESC0, (uint32_t)txbuffer->buffer);
 8104aa4:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8104aa6:	681b      	ldr	r3, [r3, #0]
 8104aa8:	461a      	mov	r2, r3
 8104aaa:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8104aac:	601a      	str	r2, [r3, #0]
    /* Set header or buffer 1 Length */
    MODIFY_REG(dmatxdesc->DESC2, ETH_DMATXNDESCRF_B1L, txbuffer->len);
 8104aae:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8104ab0:	689b      	ldr	r3, [r3, #8]
 8104ab2:	f423 537f 	bic.w	r3, r3, #16320	; 0x3fc0
 8104ab6:	f023 033f 	bic.w	r3, r3, #63	; 0x3f
 8104aba:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8104abc:	6852      	ldr	r2, [r2, #4]
 8104abe:	431a      	orrs	r2, r3
 8104ac0:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8104ac2:	609a      	str	r2, [r3, #8]

    if (txbuffer->next != NULL)
 8104ac4:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8104ac6:	689b      	ldr	r3, [r3, #8]
 8104ac8:	2b00      	cmp	r3, #0
 8104aca:	d014      	beq.n	8104af6 <ETH_Prepare_Tx_Descriptors+0x410>
    {
      /* Get the next Tx buffer in the list */
      txbuffer = txbuffer->next;
 8104acc:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8104ace:	689b      	ldr	r3, [r3, #8]
 8104ad0:	62fb      	str	r3, [r7, #44]	; 0x2c
      /* Set buffer 2 address */
      WRITE_REG(dmatxdesc->DESC1, (uint32_t)txbuffer->buffer);
 8104ad2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8104ad4:	681b      	ldr	r3, [r3, #0]
 8104ad6:	461a      	mov	r2, r3
 8104ad8:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8104ada:	605a      	str	r2, [r3, #4]
      /* Set buffer 2 Length */
      MODIFY_REG(dmatxdesc->DESC2, ETH_DMATXNDESCRF_B2L, (txbuffer->len << 16));
 8104adc:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8104ade:	689b      	ldr	r3, [r3, #8]
 8104ae0:	f023 537f 	bic.w	r3, r3, #1069547520	; 0x3fc00000
 8104ae4:	f423 137c 	bic.w	r3, r3, #4128768	; 0x3f0000
 8104ae8:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8104aea:	6852      	ldr	r2, [r2, #4]
 8104aec:	0412      	lsls	r2, r2, #16
 8104aee:	431a      	orrs	r2, r3
 8104af0:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8104af2:	609a      	str	r2, [r3, #8]
 8104af4:	e00a      	b.n	8104b0c <ETH_Prepare_Tx_Descriptors+0x426>
    }
    else
    {
      WRITE_REG(dmatxdesc->DESC1, 0x0U);
 8104af6:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8104af8:	2200      	movs	r2, #0
 8104afa:	605a      	str	r2, [r3, #4]
      /* Set buffer 2 Length */
      MODIFY_REG(dmatxdesc->DESC2, ETH_DMATXNDESCRF_B2L, 0x0U);
 8104afc:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8104afe:	689b      	ldr	r3, [r3, #8]
 8104b00:	f023 537f 	bic.w	r3, r3, #1069547520	; 0x3fc00000
 8104b04:	f423 137c 	bic.w	r3, r3, #4128768	; 0x3f0000
 8104b08:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 8104b0a:	6093      	str	r3, [r2, #8]
    }

    if (READ_BIT(pTxConfig->Attributes, ETH_TX_PACKETS_FEATURES_TSO) != (uint32_t)RESET)
 8104b0c:	68bb      	ldr	r3, [r7, #8]
 8104b0e:	681b      	ldr	r3, [r3, #0]
 8104b10:	f003 0310 	and.w	r3, r3, #16
 8104b14:	2b00      	cmp	r3, #0
 8104b16:	d00f      	beq.n	8104b38 <ETH_Prepare_Tx_Descriptors+0x452>
    {
      /* Set TCP payload length */
      MODIFY_REG(dmatxdesc->DESC3, ETH_DMATXNDESCRF_TPL, pTxConfig->PayloadLen);
 8104b18:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8104b1a:	68db      	ldr	r3, [r3, #12]
 8104b1c:	0c9b      	lsrs	r3, r3, #18
 8104b1e:	049b      	lsls	r3, r3, #18
 8104b20:	68ba      	ldr	r2, [r7, #8]
 8104b22:	69d2      	ldr	r2, [r2, #28]
 8104b24:	431a      	orrs	r2, r3
 8104b26:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8104b28:	60da      	str	r2, [r3, #12]
      /* Set TCP Segmentation Enabled bit */
      SET_BIT(dmatxdesc->DESC3, ETH_DMATXNDESCRF_TSE);
 8104b2a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8104b2c:	68db      	ldr	r3, [r3, #12]
 8104b2e:	f443 2280 	orr.w	r2, r3, #262144	; 0x40000
 8104b32:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8104b34:	60da      	str	r2, [r3, #12]
 8104b36:	e019      	b.n	8104b6c <ETH_Prepare_Tx_Descriptors+0x486>
    }
    else
    {
      /* Set the packet length */
      MODIFY_REG(dmatxdesc->DESC3, ETH_DMATXNDESCRF_FL, pTxConfig->Length);
 8104b38:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8104b3a:	68db      	ldr	r3, [r3, #12]
 8104b3c:	f423 43ff 	bic.w	r3, r3, #32640	; 0x7f80
 8104b40:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
 8104b44:	68ba      	ldr	r2, [r7, #8]
 8104b46:	6852      	ldr	r2, [r2, #4]
 8104b48:	431a      	orrs	r2, r3
 8104b4a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8104b4c:	60da      	str	r2, [r3, #12]

      if (READ_BIT(pTxConfig->Attributes, ETH_TX_PACKETS_FEATURES_CSUM) != (uint32_t)RESET)
 8104b4e:	68bb      	ldr	r3, [r7, #8]
 8104b50:	681b      	ldr	r3, [r3, #0]
 8104b52:	f003 0301 	and.w	r3, r3, #1
 8104b56:	2b00      	cmp	r3, #0
 8104b58:	d008      	beq.n	8104b6c <ETH_Prepare_Tx_Descriptors+0x486>
      {
        /* Checksum Insertion Control */
        MODIFY_REG(dmatxdesc->DESC3, ETH_DMATXNDESCRF_CIC, pTxConfig->ChecksumCtrl);
 8104b5a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8104b5c:	68db      	ldr	r3, [r3, #12]
 8104b5e:	f423 3240 	bic.w	r2, r3, #196608	; 0x30000
 8104b62:	68bb      	ldr	r3, [r7, #8]
 8104b64:	695b      	ldr	r3, [r3, #20]
 8104b66:	431a      	orrs	r2, r3
 8104b68:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8104b6a:	60da      	str	r2, [r3, #12]
      }
    }

    bd_count += 1U;
 8104b6c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8104b6e:	3301      	adds	r3, #1
 8104b70:	62bb      	str	r3, [r7, #40]	; 0x28
  __ASM volatile ("dmb 0xF":::"memory");
 8104b72:	f3bf 8f5f 	dmb	sy
}
 8104b76:	bf00      	nop

    /* Ensure rest of descriptor is written to RAM before the OWN bit */
    __DMB();
    /* Set Own bit */
    SET_BIT(dmatxdesc->DESC3, ETH_DMATXNDESCRF_OWN);
 8104b78:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8104b7a:	68db      	ldr	r3, [r3, #12]
 8104b7c:	f043 4200 	orr.w	r2, r3, #2147483648	; 0x80000000
 8104b80:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8104b82:	60da      	str	r2, [r3, #12]
    /* Mark it as NORMAL descriptor */
    CLEAR_BIT(dmatxdesc->DESC3, ETH_DMATXNDESCRF_CTXT);
 8104b84:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8104b86:	68db      	ldr	r3, [r3, #12]
 8104b88:	f023 4280 	bic.w	r2, r3, #1073741824	; 0x40000000
 8104b8c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8104b8e:	60da      	str	r2, [r3, #12]
  while (txbuffer->next != NULL)
 8104b90:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8104b92:	689b      	ldr	r3, [r3, #8]
 8104b94:	2b00      	cmp	r3, #0
 8104b96:	f47f af2c 	bne.w	81049f2 <ETH_Prepare_Tx_Descriptors+0x30c>
  }

  if (ItMode != ((uint32_t)RESET))
 8104b9a:	687b      	ldr	r3, [r7, #4]
 8104b9c:	2b00      	cmp	r3, #0
 8104b9e:	d006      	beq.n	8104bae <ETH_Prepare_Tx_Descriptors+0x4c8>
  {
    /* Set Interrupt on completion bit */
    SET_BIT(dmatxdesc->DESC2, ETH_DMATXNDESCRF_IOC);
 8104ba0:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8104ba2:	689b      	ldr	r3, [r3, #8]
 8104ba4:	f043 4200 	orr.w	r2, r3, #2147483648	; 0x80000000
 8104ba8:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8104baa:	609a      	str	r2, [r3, #8]
 8104bac:	e005      	b.n	8104bba <ETH_Prepare_Tx_Descriptors+0x4d4>
  }
  else
  {
    /* Clear Interrupt on completion bit */
    CLEAR_BIT(dmatxdesc->DESC2, ETH_DMATXNDESCRF_IOC);
 8104bae:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8104bb0:	689b      	ldr	r3, [r3, #8]
 8104bb2:	f023 4200 	bic.w	r2, r3, #2147483648	; 0x80000000
 8104bb6:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8104bb8:	609a      	str	r2, [r3, #8]
  }

  /* Mark it as LAST descriptor */
  SET_BIT(dmatxdesc->DESC3, ETH_DMATXNDESCRF_LD);
 8104bba:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8104bbc:	68db      	ldr	r3, [r3, #12]
 8104bbe:	f043 5280 	orr.w	r2, r3, #268435456	; 0x10000000
 8104bc2:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8104bc4:	60da      	str	r2, [r3, #12]
  /* Save the current packet address to expose it to the application */
  dmatxdesclist->PacketAddress[descidx] = dmatxdesclist->CurrentPacketAddress;
 8104bc6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8104bc8:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8104bca:	6a79      	ldr	r1, [r7, #36]	; 0x24
 8104bcc:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8104bce:	3304      	adds	r3, #4
 8104bd0:	009b      	lsls	r3, r3, #2
 8104bd2:	440b      	add	r3, r1
 8104bd4:	605a      	str	r2, [r3, #4]

  dmatxdesclist->CurTxDesc = descidx;
 8104bd6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8104bd8:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 8104bda:	611a      	str	r2, [r3, #16]
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8104bdc:	f3ef 8310 	mrs	r3, PRIMASK
 8104be0:	613b      	str	r3, [r7, #16]
  return(result);
 8104be2:	693b      	ldr	r3, [r7, #16]

  /* Enter critical section */
  primask_bit = __get_PRIMASK();
 8104be4:	61fb      	str	r3, [r7, #28]
 8104be6:	2301      	movs	r3, #1
 8104be8:	617b      	str	r3, [r7, #20]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8104bea:	697b      	ldr	r3, [r7, #20]
 8104bec:	f383 8810 	msr	PRIMASK, r3
}
 8104bf0:	bf00      	nop
  __set_PRIMASK(1);

  dmatxdesclist->BuffersInUse += bd_count + 1U;
 8104bf2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8104bf4:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 8104bf6:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8104bf8:	4413      	add	r3, r2
 8104bfa:	1c5a      	adds	r2, r3, #1
 8104bfc:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8104bfe:	629a      	str	r2, [r3, #40]	; 0x28
 8104c00:	69fb      	ldr	r3, [r7, #28]
 8104c02:	61bb      	str	r3, [r7, #24]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8104c04:	69bb      	ldr	r3, [r7, #24]
 8104c06:	f383 8810 	msr	PRIMASK, r3
}
 8104c0a:	bf00      	nop

  /* Exit critical section: restore previous priority mask */
  __set_PRIMASK(primask_bit);

  /* Return function status */
  return HAL_ETH_ERROR_NONE;
 8104c0c:	2300      	movs	r3, #0
}
 8104c0e:	4618      	mov	r0, r3
 8104c10:	3744      	adds	r7, #68	; 0x44
 8104c12:	46bd      	mov	sp, r7
 8104c14:	f85d 7b04 	ldr.w	r7, [sp], #4
 8104c18:	4770      	bx	lr

08104c1a <HAL_EXTI_RegisterCallback>:
  *         This parameter can be one of @arg @ref EXTI_CallbackIDTypeDef values.
  * @param  pPendingCbfn function pointer to be stored as callback.
  * @retval HAL Status.
  */
HAL_StatusTypeDef HAL_EXTI_RegisterCallback(EXTI_HandleTypeDef *hexti, EXTI_CallbackIDTypeDef CallbackID, void (*pPendingCbfn)(void))
{
 8104c1a:	b480      	push	{r7}
 8104c1c:	b087      	sub	sp, #28
 8104c1e:	af00      	add	r7, sp, #0
 8104c20:	60f8      	str	r0, [r7, #12]
 8104c22:	460b      	mov	r3, r1
 8104c24:	607a      	str	r2, [r7, #4]
 8104c26:	72fb      	strb	r3, [r7, #11]
  HAL_StatusTypeDef status = HAL_OK;
 8104c28:	2300      	movs	r3, #0
 8104c2a:	75fb      	strb	r3, [r7, #23]

  /* Check null pointer */
  if (hexti == NULL)
 8104c2c:	68fb      	ldr	r3, [r7, #12]
 8104c2e:	2b00      	cmp	r3, #0
 8104c30:	d101      	bne.n	8104c36 <HAL_EXTI_RegisterCallback+0x1c>
  {
    return HAL_ERROR;
 8104c32:	2301      	movs	r3, #1
 8104c34:	e00a      	b.n	8104c4c <HAL_EXTI_RegisterCallback+0x32>
  }

  switch (CallbackID)
 8104c36:	7afb      	ldrb	r3, [r7, #11]
 8104c38:	2b00      	cmp	r3, #0
 8104c3a:	d103      	bne.n	8104c44 <HAL_EXTI_RegisterCallback+0x2a>
  {
    case  HAL_EXTI_COMMON_CB_ID:
      hexti->PendingCallback = pPendingCbfn;
 8104c3c:	68fb      	ldr	r3, [r7, #12]
 8104c3e:	687a      	ldr	r2, [r7, #4]
 8104c40:	605a      	str	r2, [r3, #4]
      break;
 8104c42:	e002      	b.n	8104c4a <HAL_EXTI_RegisterCallback+0x30>

    default:
      status = HAL_ERROR;
 8104c44:	2301      	movs	r3, #1
 8104c46:	75fb      	strb	r3, [r7, #23]
      break;
 8104c48:	bf00      	nop
  }

  return status;
 8104c4a:	7dfb      	ldrb	r3, [r7, #23]
}
 8104c4c:	4618      	mov	r0, r3
 8104c4e:	371c      	adds	r7, #28
 8104c50:	46bd      	mov	sp, r7
 8104c52:	f85d 7b04 	ldr.w	r7, [sp], #4
 8104c56:	4770      	bx	lr

08104c58 <HAL_EXTI_GetHandle>:
  * @param  ExtiLine Exti line number.
  *         This parameter can be from 0 to @ref EXTI_LINE_NB.
  * @retval HAL Status.
  */
HAL_StatusTypeDef HAL_EXTI_GetHandle(EXTI_HandleTypeDef *hexti, uint32_t ExtiLine)
{
 8104c58:	b480      	push	{r7}
 8104c5a:	b083      	sub	sp, #12
 8104c5c:	af00      	add	r7, sp, #0
 8104c5e:	6078      	str	r0, [r7, #4]
 8104c60:	6039      	str	r1, [r7, #0]
  /* Check the parameters */
  assert_param(IS_EXTI_LINE(ExtiLine));

  /* Check null pointer */
  if (hexti == NULL)
 8104c62:	687b      	ldr	r3, [r7, #4]
 8104c64:	2b00      	cmp	r3, #0
 8104c66:	d101      	bne.n	8104c6c <HAL_EXTI_GetHandle+0x14>
  {
    return HAL_ERROR;
 8104c68:	2301      	movs	r3, #1
 8104c6a:	e003      	b.n	8104c74 <HAL_EXTI_GetHandle+0x1c>
  }
  else
  {
    /* Store line number as handle private field */
    hexti->Line = ExtiLine;
 8104c6c:	687b      	ldr	r3, [r7, #4]
 8104c6e:	683a      	ldr	r2, [r7, #0]
 8104c70:	601a      	str	r2, [r3, #0]

    return HAL_OK;
 8104c72:	2300      	movs	r3, #0
  }
}
 8104c74:	4618      	mov	r0, r3
 8104c76:	370c      	adds	r7, #12
 8104c78:	46bd      	mov	sp, r7
 8104c7a:	f85d 7b04 	ldr.w	r7, [sp], #4
 8104c7e:	4770      	bx	lr

08104c80 <HAL_EXTI_IRQHandler>:
  * @brief  Handle EXTI interrupt request.
  * @param  hexti Exti handle.
  * @retval none.
  */
void HAL_EXTI_IRQHandler(EXTI_HandleTypeDef *hexti)
{
 8104c80:	b580      	push	{r7, lr}
 8104c82:	b086      	sub	sp, #24
 8104c84:	af00      	add	r7, sp, #0
 8104c86:	6078      	str	r0, [r7, #4]
  uint32_t regval;
  uint32_t maskline;
  uint32_t offset;

  /* Compute line register offset and line mask */
  offset = ((hexti->Line & EXTI_REG_MASK) >> EXTI_REG_SHIFT);
 8104c88:	687b      	ldr	r3, [r7, #4]
 8104c8a:	681b      	ldr	r3, [r3, #0]
 8104c8c:	0c1b      	lsrs	r3, r3, #16
 8104c8e:	f003 0303 	and.w	r3, r3, #3
 8104c92:	613b      	str	r3, [r7, #16]
  maskline = (1UL << (hexti->Line & EXTI_PIN_MASK));
 8104c94:	687b      	ldr	r3, [r7, #4]
 8104c96:	681b      	ldr	r3, [r3, #0]
 8104c98:	f003 031f 	and.w	r3, r3, #31
 8104c9c:	2201      	movs	r2, #1
 8104c9e:	fa02 f303 	lsl.w	r3, r2, r3
 8104ca2:	60fb      	str	r3, [r7, #12]

#if defined(DUAL_CORE)
  if (HAL_GetCurrentCPUID() == CM7_CPUID)
 8104ca4:	f7fe fc80 	bl	81035a8 <HAL_GetCurrentCPUID>
 8104ca8:	4603      	mov	r3, r0
 8104caa:	2b03      	cmp	r3, #3
 8104cac:	d106      	bne.n	8104cbc <HAL_EXTI_IRQHandler+0x3c>
  {
    /* Get pending register address */
    regaddr = (__IO uint32_t *)(&EXTI->PR1 + (EXTI_MODE_OFFSET * offset));
 8104cae:	693b      	ldr	r3, [r7, #16]
 8104cb0:	011b      	lsls	r3, r3, #4
 8104cb2:	f103 43b0 	add.w	r3, r3, #1476395008	; 0x58000000
 8104cb6:	3388      	adds	r3, #136	; 0x88
 8104cb8:	617b      	str	r3, [r7, #20]
 8104cba:	e005      	b.n	8104cc8 <HAL_EXTI_IRQHandler+0x48>
  }
  else /* Cortex-M4*/
  {
    /* Get pending register address */
    regaddr = (__IO uint32_t *)(&EXTI->C2PR1 + (EXTI_MODE_OFFSET * offset));
 8104cbc:	693b      	ldr	r3, [r7, #16]
 8104cbe:	011b      	lsls	r3, r3, #4
 8104cc0:	f103 43b0 	add.w	r3, r3, #1476395008	; 0x58000000
 8104cc4:	33c8      	adds	r3, #200	; 0xc8
 8104cc6:	617b      	str	r3, [r7, #20]
#else
  regaddr = (__IO uint32_t *)(&EXTI->PR1 + (EXTI_MODE_OFFSET * offset));
#endif /* DUAL_CORE */

  /* Get pending bit  */
  regval = (*regaddr & maskline);
 8104cc8:	697b      	ldr	r3, [r7, #20]
 8104cca:	681b      	ldr	r3, [r3, #0]
 8104ccc:	68fa      	ldr	r2, [r7, #12]
 8104cce:	4013      	ands	r3, r2
 8104cd0:	60bb      	str	r3, [r7, #8]

  if (regval != 0x00U)
 8104cd2:	68bb      	ldr	r3, [r7, #8]
 8104cd4:	2b00      	cmp	r3, #0
 8104cd6:	d009      	beq.n	8104cec <HAL_EXTI_IRQHandler+0x6c>
  {
    /* Clear pending bit */
    *regaddr = maskline;
 8104cd8:	697b      	ldr	r3, [r7, #20]
 8104cda:	68fa      	ldr	r2, [r7, #12]
 8104cdc:	601a      	str	r2, [r3, #0]

    /* Call callback */
    if (hexti->PendingCallback != NULL)
 8104cde:	687b      	ldr	r3, [r7, #4]
 8104ce0:	685b      	ldr	r3, [r3, #4]
 8104ce2:	2b00      	cmp	r3, #0
 8104ce4:	d002      	beq.n	8104cec <HAL_EXTI_IRQHandler+0x6c>
    {
      hexti->PendingCallback();
 8104ce6:	687b      	ldr	r3, [r7, #4]
 8104ce8:	685b      	ldr	r3, [r3, #4]
 8104cea:	4798      	blx	r3
    }
  }
}
 8104cec:	bf00      	nop
 8104cee:	3718      	adds	r7, #24
 8104cf0:	46bd      	mov	sp, r7
 8104cf2:	bd80      	pop	{r7, pc}

08104cf4 <HAL_FDCAN_Init>:
  * @param  hfdcan pointer to an FDCAN_HandleTypeDef structure that contains
  *         the configuration information for the specified FDCAN.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_FDCAN_Init(FDCAN_HandleTypeDef *hfdcan)
{
 8104cf4:	b580      	push	{r7, lr}
 8104cf6:	b098      	sub	sp, #96	; 0x60
 8104cf8:	af00      	add	r7, sp, #0
 8104cfa:	6078      	str	r0, [r7, #4]
  uint32_t tickstart;
  HAL_StatusTypeDef status;
  const uint32_t CvtEltSize[] = {0, 0, 0, 0, 0, 1, 2, 3, 4, 0, 5, 0, 0, 0, 6, 0, 0, 0, 7};
 8104cfc:	4a84      	ldr	r2, [pc, #528]	; (8104f10 <HAL_FDCAN_Init+0x21c>)
 8104cfe:	f107 030c 	add.w	r3, r7, #12
 8104d02:	4611      	mov	r1, r2
 8104d04:	224c      	movs	r2, #76	; 0x4c
 8104d06:	4618      	mov	r0, r3
 8104d08:	f016 fdd2 	bl	811b8b0 <memcpy>

  /* Check FDCAN handle */
  if (hfdcan == NULL)
 8104d0c:	687b      	ldr	r3, [r7, #4]
 8104d0e:	2b00      	cmp	r3, #0
 8104d10:	d101      	bne.n	8104d16 <HAL_FDCAN_Init+0x22>
  {
    return HAL_ERROR;
 8104d12:	2301      	movs	r3, #1
 8104d14:	e1c6      	b.n	81050a4 <HAL_FDCAN_Init+0x3b0>
  }

  /* Check FDCAN instance */
  if (hfdcan->Instance == FDCAN1)
 8104d16:	687b      	ldr	r3, [r7, #4]
 8104d18:	681b      	ldr	r3, [r3, #0]
 8104d1a:	4a7e      	ldr	r2, [pc, #504]	; (8104f14 <HAL_FDCAN_Init+0x220>)
 8104d1c:	4293      	cmp	r3, r2
 8104d1e:	d106      	bne.n	8104d2e <HAL_FDCAN_Init+0x3a>
  {
    hfdcan->ttcan = (TTCAN_TypeDef *)((uint32_t)hfdcan->Instance + 0x100U);
 8104d20:	687b      	ldr	r3, [r7, #4]
 8104d22:	681b      	ldr	r3, [r3, #0]
 8104d24:	f503 7380 	add.w	r3, r3, #256	; 0x100
 8104d28:	461a      	mov	r2, r3
 8104d2a:	687b      	ldr	r3, [r7, #4]
 8104d2c:	605a      	str	r2, [r3, #4]

    /* Init the low level hardware: CLOCK, NVIC */
    hfdcan->MspInitCallback(hfdcan);
  }
#else
  if (hfdcan->State == HAL_FDCAN_STATE_RESET)
 8104d2e:	687b      	ldr	r3, [r7, #4]
 8104d30:	f893 3098 	ldrb.w	r3, [r3, #152]	; 0x98
 8104d34:	b2db      	uxtb	r3, r3
 8104d36:	2b00      	cmp	r3, #0
 8104d38:	d106      	bne.n	8104d48 <HAL_FDCAN_Init+0x54>
  {
    /* Allocate lock resource and initialize it */
    hfdcan->Lock = HAL_UNLOCKED;
 8104d3a:	687b      	ldr	r3, [r7, #4]
 8104d3c:	2200      	movs	r2, #0
 8104d3e:	f883 2099 	strb.w	r2, [r3, #153]	; 0x99

    /* Init the low level hardware: CLOCK, NVIC */
    HAL_FDCAN_MspInit(hfdcan);
 8104d42:	6878      	ldr	r0, [r7, #4]
 8104d44:	f7fb ff44 	bl	8100bd0 <HAL_FDCAN_MspInit>
  }
#endif /* USE_HAL_FDCAN_REGISTER_CALLBACKS */

  /* Exit from Sleep mode */
  CLEAR_BIT(hfdcan->Instance->CCCR, FDCAN_CCCR_CSR);
 8104d48:	687b      	ldr	r3, [r7, #4]
 8104d4a:	681b      	ldr	r3, [r3, #0]
 8104d4c:	699a      	ldr	r2, [r3, #24]
 8104d4e:	687b      	ldr	r3, [r7, #4]
 8104d50:	681b      	ldr	r3, [r3, #0]
 8104d52:	f022 0210 	bic.w	r2, r2, #16
 8104d56:	619a      	str	r2, [r3, #24]

  /* Get tick */
  tickstart = HAL_GetTick();
 8104d58:	f7fc fc70 	bl	810163c <HAL_GetTick>
 8104d5c:	65f8      	str	r0, [r7, #92]	; 0x5c

  /* Check Sleep mode acknowledge */
  while ((hfdcan->Instance->CCCR & FDCAN_CCCR_CSA) == FDCAN_CCCR_CSA)
 8104d5e:	e014      	b.n	8104d8a <HAL_FDCAN_Init+0x96>
  {
    if ((HAL_GetTick() - tickstart) > FDCAN_TIMEOUT_VALUE)
 8104d60:	f7fc fc6c 	bl	810163c <HAL_GetTick>
 8104d64:	4602      	mov	r2, r0
 8104d66:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8104d68:	1ad3      	subs	r3, r2, r3
 8104d6a:	2b0a      	cmp	r3, #10
 8104d6c:	d90d      	bls.n	8104d8a <HAL_FDCAN_Init+0x96>
    {
      /* Update error code */
      hfdcan->ErrorCode |= HAL_FDCAN_ERROR_TIMEOUT;
 8104d6e:	687b      	ldr	r3, [r7, #4]
 8104d70:	f8d3 309c 	ldr.w	r3, [r3, #156]	; 0x9c
 8104d74:	f043 0201 	orr.w	r2, r3, #1
 8104d78:	687b      	ldr	r3, [r7, #4]
 8104d7a:	f8c3 209c 	str.w	r2, [r3, #156]	; 0x9c

      /* Change FDCAN state */
      hfdcan->State = HAL_FDCAN_STATE_ERROR;
 8104d7e:	687b      	ldr	r3, [r7, #4]
 8104d80:	2203      	movs	r2, #3
 8104d82:	f883 2098 	strb.w	r2, [r3, #152]	; 0x98

      return HAL_ERROR;
 8104d86:	2301      	movs	r3, #1
 8104d88:	e18c      	b.n	81050a4 <HAL_FDCAN_Init+0x3b0>
  while ((hfdcan->Instance->CCCR & FDCAN_CCCR_CSA) == FDCAN_CCCR_CSA)
 8104d8a:	687b      	ldr	r3, [r7, #4]
 8104d8c:	681b      	ldr	r3, [r3, #0]
 8104d8e:	699b      	ldr	r3, [r3, #24]
 8104d90:	f003 0308 	and.w	r3, r3, #8
 8104d94:	2b08      	cmp	r3, #8
 8104d96:	d0e3      	beq.n	8104d60 <HAL_FDCAN_Init+0x6c>
    }
  }

  /* Request initialisation */
  SET_BIT(hfdcan->Instance->CCCR, FDCAN_CCCR_INIT);
 8104d98:	687b      	ldr	r3, [r7, #4]
 8104d9a:	681b      	ldr	r3, [r3, #0]
 8104d9c:	699a      	ldr	r2, [r3, #24]
 8104d9e:	687b      	ldr	r3, [r7, #4]
 8104da0:	681b      	ldr	r3, [r3, #0]
 8104da2:	f042 0201 	orr.w	r2, r2, #1
 8104da6:	619a      	str	r2, [r3, #24]

  /* Get tick */
  tickstart = HAL_GetTick();
 8104da8:	f7fc fc48 	bl	810163c <HAL_GetTick>
 8104dac:	65f8      	str	r0, [r7, #92]	; 0x5c

  /* Wait until the INIT bit into CCCR register is set */
  while ((hfdcan->Instance->CCCR & FDCAN_CCCR_INIT) == 0U)
 8104dae:	e014      	b.n	8104dda <HAL_FDCAN_Init+0xe6>
  {
    /* Check for the Timeout */
    if ((HAL_GetTick() - tickstart) > FDCAN_TIMEOUT_VALUE)
 8104db0:	f7fc fc44 	bl	810163c <HAL_GetTick>
 8104db4:	4602      	mov	r2, r0
 8104db6:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8104db8:	1ad3      	subs	r3, r2, r3
 8104dba:	2b0a      	cmp	r3, #10
 8104dbc:	d90d      	bls.n	8104dda <HAL_FDCAN_Init+0xe6>
    {
      /* Update error code */
      hfdcan->ErrorCode |= HAL_FDCAN_ERROR_TIMEOUT;
 8104dbe:	687b      	ldr	r3, [r7, #4]
 8104dc0:	f8d3 309c 	ldr.w	r3, [r3, #156]	; 0x9c
 8104dc4:	f043 0201 	orr.w	r2, r3, #1
 8104dc8:	687b      	ldr	r3, [r7, #4]
 8104dca:	f8c3 209c 	str.w	r2, [r3, #156]	; 0x9c

      /* Change FDCAN state */
      hfdcan->State = HAL_FDCAN_STATE_ERROR;
 8104dce:	687b      	ldr	r3, [r7, #4]
 8104dd0:	2203      	movs	r2, #3
 8104dd2:	f883 2098 	strb.w	r2, [r3, #152]	; 0x98

      return HAL_ERROR;
 8104dd6:	2301      	movs	r3, #1
 8104dd8:	e164      	b.n	81050a4 <HAL_FDCAN_Init+0x3b0>
  while ((hfdcan->Instance->CCCR & FDCAN_CCCR_INIT) == 0U)
 8104dda:	687b      	ldr	r3, [r7, #4]
 8104ddc:	681b      	ldr	r3, [r3, #0]
 8104dde:	699b      	ldr	r3, [r3, #24]
 8104de0:	f003 0301 	and.w	r3, r3, #1
 8104de4:	2b00      	cmp	r3, #0
 8104de6:	d0e3      	beq.n	8104db0 <HAL_FDCAN_Init+0xbc>
    }
  }

  /* Enable configuration change */
  SET_BIT(hfdcan->Instance->CCCR, FDCAN_CCCR_CCE);
 8104de8:	687b      	ldr	r3, [r7, #4]
 8104dea:	681b      	ldr	r3, [r3, #0]
 8104dec:	699a      	ldr	r2, [r3, #24]
 8104dee:	687b      	ldr	r3, [r7, #4]
 8104df0:	681b      	ldr	r3, [r3, #0]
 8104df2:	f042 0202 	orr.w	r2, r2, #2
 8104df6:	619a      	str	r2, [r3, #24]

  /* Set the no automatic retransmission */
  if (hfdcan->Init.AutoRetransmission == ENABLE)
 8104df8:	687b      	ldr	r3, [r7, #4]
 8104dfa:	7c1b      	ldrb	r3, [r3, #16]
 8104dfc:	2b01      	cmp	r3, #1
 8104dfe:	d108      	bne.n	8104e12 <HAL_FDCAN_Init+0x11e>
  {
    CLEAR_BIT(hfdcan->Instance->CCCR, FDCAN_CCCR_DAR);
 8104e00:	687b      	ldr	r3, [r7, #4]
 8104e02:	681b      	ldr	r3, [r3, #0]
 8104e04:	699a      	ldr	r2, [r3, #24]
 8104e06:	687b      	ldr	r3, [r7, #4]
 8104e08:	681b      	ldr	r3, [r3, #0]
 8104e0a:	f022 0240 	bic.w	r2, r2, #64	; 0x40
 8104e0e:	619a      	str	r2, [r3, #24]
 8104e10:	e007      	b.n	8104e22 <HAL_FDCAN_Init+0x12e>
  }
  else
  {
    SET_BIT(hfdcan->Instance->CCCR, FDCAN_CCCR_DAR);
 8104e12:	687b      	ldr	r3, [r7, #4]
 8104e14:	681b      	ldr	r3, [r3, #0]
 8104e16:	699a      	ldr	r2, [r3, #24]
 8104e18:	687b      	ldr	r3, [r7, #4]
 8104e1a:	681b      	ldr	r3, [r3, #0]
 8104e1c:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 8104e20:	619a      	str	r2, [r3, #24]
  }

  /* Set the transmit pause feature */
  if (hfdcan->Init.TransmitPause == ENABLE)
 8104e22:	687b      	ldr	r3, [r7, #4]
 8104e24:	7c5b      	ldrb	r3, [r3, #17]
 8104e26:	2b01      	cmp	r3, #1
 8104e28:	d108      	bne.n	8104e3c <HAL_FDCAN_Init+0x148>
  {
    SET_BIT(hfdcan->Instance->CCCR, FDCAN_CCCR_TXP);
 8104e2a:	687b      	ldr	r3, [r7, #4]
 8104e2c:	681b      	ldr	r3, [r3, #0]
 8104e2e:	699a      	ldr	r2, [r3, #24]
 8104e30:	687b      	ldr	r3, [r7, #4]
 8104e32:	681b      	ldr	r3, [r3, #0]
 8104e34:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
 8104e38:	619a      	str	r2, [r3, #24]
 8104e3a:	e007      	b.n	8104e4c <HAL_FDCAN_Init+0x158>
  }
  else
  {
    CLEAR_BIT(hfdcan->Instance->CCCR, FDCAN_CCCR_TXP);
 8104e3c:	687b      	ldr	r3, [r7, #4]
 8104e3e:	681b      	ldr	r3, [r3, #0]
 8104e40:	699a      	ldr	r2, [r3, #24]
 8104e42:	687b      	ldr	r3, [r7, #4]
 8104e44:	681b      	ldr	r3, [r3, #0]
 8104e46:	f422 4280 	bic.w	r2, r2, #16384	; 0x4000
 8104e4a:	619a      	str	r2, [r3, #24]
  }

  /* Set the Protocol Exception Handling */
  if (hfdcan->Init.ProtocolException == ENABLE)
 8104e4c:	687b      	ldr	r3, [r7, #4]
 8104e4e:	7c9b      	ldrb	r3, [r3, #18]
 8104e50:	2b01      	cmp	r3, #1
 8104e52:	d108      	bne.n	8104e66 <HAL_FDCAN_Init+0x172>
  {
    CLEAR_BIT(hfdcan->Instance->CCCR, FDCAN_CCCR_PXHD);
 8104e54:	687b      	ldr	r3, [r7, #4]
 8104e56:	681b      	ldr	r3, [r3, #0]
 8104e58:	699a      	ldr	r2, [r3, #24]
 8104e5a:	687b      	ldr	r3, [r7, #4]
 8104e5c:	681b      	ldr	r3, [r3, #0]
 8104e5e:	f422 5280 	bic.w	r2, r2, #4096	; 0x1000
 8104e62:	619a      	str	r2, [r3, #24]
 8104e64:	e007      	b.n	8104e76 <HAL_FDCAN_Init+0x182>
  }
  else
  {
    SET_BIT(hfdcan->Instance->CCCR, FDCAN_CCCR_PXHD);
 8104e66:	687b      	ldr	r3, [r7, #4]
 8104e68:	681b      	ldr	r3, [r3, #0]
 8104e6a:	699a      	ldr	r2, [r3, #24]
 8104e6c:	687b      	ldr	r3, [r7, #4]
 8104e6e:	681b      	ldr	r3, [r3, #0]
 8104e70:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
 8104e74:	619a      	str	r2, [r3, #24]
  }

  /* Set FDCAN Frame Format */
  MODIFY_REG(hfdcan->Instance->CCCR, FDCAN_FRAME_FD_BRS, hfdcan->Init.FrameFormat);
 8104e76:	687b      	ldr	r3, [r7, #4]
 8104e78:	681b      	ldr	r3, [r3, #0]
 8104e7a:	699b      	ldr	r3, [r3, #24]
 8104e7c:	f423 7140 	bic.w	r1, r3, #768	; 0x300
 8104e80:	687b      	ldr	r3, [r7, #4]
 8104e82:	689a      	ldr	r2, [r3, #8]
 8104e84:	687b      	ldr	r3, [r7, #4]
 8104e86:	681b      	ldr	r3, [r3, #0]
 8104e88:	430a      	orrs	r2, r1
 8104e8a:	619a      	str	r2, [r3, #24]

  /* Reset FDCAN Operation Mode */
  CLEAR_BIT(hfdcan->Instance->CCCR, (FDCAN_CCCR_TEST | FDCAN_CCCR_MON | FDCAN_CCCR_ASM));
 8104e8c:	687b      	ldr	r3, [r7, #4]
 8104e8e:	681b      	ldr	r3, [r3, #0]
 8104e90:	699a      	ldr	r2, [r3, #24]
 8104e92:	687b      	ldr	r3, [r7, #4]
 8104e94:	681b      	ldr	r3, [r3, #0]
 8104e96:	f022 02a4 	bic.w	r2, r2, #164	; 0xa4
 8104e9a:	619a      	str	r2, [r3, #24]
  CLEAR_BIT(hfdcan->Instance->TEST, FDCAN_TEST_LBCK);
 8104e9c:	687b      	ldr	r3, [r7, #4]
 8104e9e:	681b      	ldr	r3, [r3, #0]
 8104ea0:	691a      	ldr	r2, [r3, #16]
 8104ea2:	687b      	ldr	r3, [r7, #4]
 8104ea4:	681b      	ldr	r3, [r3, #0]
 8104ea6:	f022 0210 	bic.w	r2, r2, #16
 8104eaa:	611a      	str	r2, [r3, #16]
     CCCR.TEST |   0    |     0      |     0      |    1     |    1
     CCCR.MON  |   0    |     0      |     1      |    1     |    0
     TEST.LBCK |   0    |     0      |     0      |    1     |    1
     CCCR.ASM  |   0    |     1      |     0      |    0     |    0
  */
  if (hfdcan->Init.Mode == FDCAN_MODE_RESTRICTED_OPERATION)
 8104eac:	687b      	ldr	r3, [r7, #4]
 8104eae:	68db      	ldr	r3, [r3, #12]
 8104eb0:	2b01      	cmp	r3, #1
 8104eb2:	d108      	bne.n	8104ec6 <HAL_FDCAN_Init+0x1d2>
  {
    /* Enable Restricted Operation mode */
    SET_BIT(hfdcan->Instance->CCCR, FDCAN_CCCR_ASM);
 8104eb4:	687b      	ldr	r3, [r7, #4]
 8104eb6:	681b      	ldr	r3, [r3, #0]
 8104eb8:	699a      	ldr	r2, [r3, #24]
 8104eba:	687b      	ldr	r3, [r7, #4]
 8104ebc:	681b      	ldr	r3, [r3, #0]
 8104ebe:	f042 0204 	orr.w	r2, r2, #4
 8104ec2:	619a      	str	r2, [r3, #24]
 8104ec4:	e030      	b.n	8104f28 <HAL_FDCAN_Init+0x234>
  }
  else if (hfdcan->Init.Mode != FDCAN_MODE_NORMAL)
 8104ec6:	687b      	ldr	r3, [r7, #4]
 8104ec8:	68db      	ldr	r3, [r3, #12]
 8104eca:	2b00      	cmp	r3, #0
 8104ecc:	d02c      	beq.n	8104f28 <HAL_FDCAN_Init+0x234>
  {
    if (hfdcan->Init.Mode != FDCAN_MODE_BUS_MONITORING)
 8104ece:	687b      	ldr	r3, [r7, #4]
 8104ed0:	68db      	ldr	r3, [r3, #12]
 8104ed2:	2b02      	cmp	r3, #2
 8104ed4:	d020      	beq.n	8104f18 <HAL_FDCAN_Init+0x224>
    {
      /* Enable write access to TEST register */
      SET_BIT(hfdcan->Instance->CCCR, FDCAN_CCCR_TEST);
 8104ed6:	687b      	ldr	r3, [r7, #4]
 8104ed8:	681b      	ldr	r3, [r3, #0]
 8104eda:	699a      	ldr	r2, [r3, #24]
 8104edc:	687b      	ldr	r3, [r7, #4]
 8104ede:	681b      	ldr	r3, [r3, #0]
 8104ee0:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 8104ee4:	619a      	str	r2, [r3, #24]

      /* Enable LoopBack mode */
      SET_BIT(hfdcan->Instance->TEST, FDCAN_TEST_LBCK);
 8104ee6:	687b      	ldr	r3, [r7, #4]
 8104ee8:	681b      	ldr	r3, [r3, #0]
 8104eea:	691a      	ldr	r2, [r3, #16]
 8104eec:	687b      	ldr	r3, [r7, #4]
 8104eee:	681b      	ldr	r3, [r3, #0]
 8104ef0:	f042 0210 	orr.w	r2, r2, #16
 8104ef4:	611a      	str	r2, [r3, #16]

      if (hfdcan->Init.Mode == FDCAN_MODE_INTERNAL_LOOPBACK)
 8104ef6:	687b      	ldr	r3, [r7, #4]
 8104ef8:	68db      	ldr	r3, [r3, #12]
 8104efa:	2b03      	cmp	r3, #3
 8104efc:	d114      	bne.n	8104f28 <HAL_FDCAN_Init+0x234>
      {
        SET_BIT(hfdcan->Instance->CCCR, FDCAN_CCCR_MON);
 8104efe:	687b      	ldr	r3, [r7, #4]
 8104f00:	681b      	ldr	r3, [r3, #0]
 8104f02:	699a      	ldr	r2, [r3, #24]
 8104f04:	687b      	ldr	r3, [r7, #4]
 8104f06:	681b      	ldr	r3, [r3, #0]
 8104f08:	f042 0220 	orr.w	r2, r2, #32
 8104f0c:	619a      	str	r2, [r3, #24]
 8104f0e:	e00b      	b.n	8104f28 <HAL_FDCAN_Init+0x234>
 8104f10:	0811c6b0 	.word	0x0811c6b0
 8104f14:	4000a000 	.word	0x4000a000
      }
    }
    else
    {
      /* Enable bus monitoring mode */
      SET_BIT(hfdcan->Instance->CCCR, FDCAN_CCCR_MON);
 8104f18:	687b      	ldr	r3, [r7, #4]
 8104f1a:	681b      	ldr	r3, [r3, #0]
 8104f1c:	699a      	ldr	r2, [r3, #24]
 8104f1e:	687b      	ldr	r3, [r7, #4]
 8104f20:	681b      	ldr	r3, [r3, #0]
 8104f22:	f042 0220 	orr.w	r2, r2, #32
 8104f26:	619a      	str	r2, [r3, #24]
  {
    /* Nothing to do: normal mode */
  }

  /* Set the nominal bit timing register */
  hfdcan->Instance->NBTP = ((((uint32_t)hfdcan->Init.NominalSyncJumpWidth - 1U) << FDCAN_NBTP_NSJW_Pos) | \
 8104f28:	687b      	ldr	r3, [r7, #4]
 8104f2a:	699b      	ldr	r3, [r3, #24]
 8104f2c:	3b01      	subs	r3, #1
 8104f2e:	065a      	lsls	r2, r3, #25
                            (((uint32_t)hfdcan->Init.NominalTimeSeg1 - 1U) << FDCAN_NBTP_NTSEG1_Pos)    | \
 8104f30:	687b      	ldr	r3, [r7, #4]
 8104f32:	69db      	ldr	r3, [r3, #28]
 8104f34:	3b01      	subs	r3, #1
 8104f36:	021b      	lsls	r3, r3, #8
  hfdcan->Instance->NBTP = ((((uint32_t)hfdcan->Init.NominalSyncJumpWidth - 1U) << FDCAN_NBTP_NSJW_Pos) | \
 8104f38:	431a      	orrs	r2, r3
                            (((uint32_t)hfdcan->Init.NominalTimeSeg2 - 1U) << FDCAN_NBTP_NTSEG2_Pos)    | \
 8104f3a:	687b      	ldr	r3, [r7, #4]
 8104f3c:	6a1b      	ldr	r3, [r3, #32]
 8104f3e:	3b01      	subs	r3, #1
                            (((uint32_t)hfdcan->Init.NominalTimeSeg1 - 1U) << FDCAN_NBTP_NTSEG1_Pos)    | \
 8104f40:	ea42 0103 	orr.w	r1, r2, r3
                            (((uint32_t)hfdcan->Init.NominalPrescaler - 1U) << FDCAN_NBTP_NBRP_Pos));
 8104f44:	687b      	ldr	r3, [r7, #4]
 8104f46:	695b      	ldr	r3, [r3, #20]
 8104f48:	3b01      	subs	r3, #1
 8104f4a:	041a      	lsls	r2, r3, #16
  hfdcan->Instance->NBTP = ((((uint32_t)hfdcan->Init.NominalSyncJumpWidth - 1U) << FDCAN_NBTP_NSJW_Pos) | \
 8104f4c:	687b      	ldr	r3, [r7, #4]
 8104f4e:	681b      	ldr	r3, [r3, #0]
                            (((uint32_t)hfdcan->Init.NominalTimeSeg2 - 1U) << FDCAN_NBTP_NTSEG2_Pos)    | \
 8104f50:	430a      	orrs	r2, r1
  hfdcan->Instance->NBTP = ((((uint32_t)hfdcan->Init.NominalSyncJumpWidth - 1U) << FDCAN_NBTP_NSJW_Pos) | \
 8104f52:	61da      	str	r2, [r3, #28]

  /* If FD operation with BRS is selected, set the data bit timing register */
  if (hfdcan->Init.FrameFormat == FDCAN_FRAME_FD_BRS)
 8104f54:	687b      	ldr	r3, [r7, #4]
 8104f56:	689b      	ldr	r3, [r3, #8]
 8104f58:	f5b3 7f40 	cmp.w	r3, #768	; 0x300
 8104f5c:	d115      	bne.n	8104f8a <HAL_FDCAN_Init+0x296>
  {
    hfdcan->Instance->DBTP = ((((uint32_t)hfdcan->Init.DataSyncJumpWidth - 1U) << FDCAN_DBTP_DSJW_Pos)  | \
 8104f5e:	687b      	ldr	r3, [r7, #4]
 8104f60:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8104f62:	1e5a      	subs	r2, r3, #1
                              (((uint32_t)hfdcan->Init.DataTimeSeg1 - 1U) << FDCAN_DBTP_DTSEG1_Pos)     | \
 8104f64:	687b      	ldr	r3, [r7, #4]
 8104f66:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8104f68:	3b01      	subs	r3, #1
 8104f6a:	021b      	lsls	r3, r3, #8
    hfdcan->Instance->DBTP = ((((uint32_t)hfdcan->Init.DataSyncJumpWidth - 1U) << FDCAN_DBTP_DSJW_Pos)  | \
 8104f6c:	431a      	orrs	r2, r3
                              (((uint32_t)hfdcan->Init.DataTimeSeg2 - 1U) << FDCAN_DBTP_DTSEG2_Pos)     | \
 8104f6e:	687b      	ldr	r3, [r7, #4]
 8104f70:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8104f72:	3b01      	subs	r3, #1
 8104f74:	011b      	lsls	r3, r3, #4
                              (((uint32_t)hfdcan->Init.DataTimeSeg1 - 1U) << FDCAN_DBTP_DTSEG1_Pos)     | \
 8104f76:	ea42 0103 	orr.w	r1, r2, r3
                              (((uint32_t)hfdcan->Init.DataPrescaler - 1U) << FDCAN_DBTP_DBRP_Pos));
 8104f7a:	687b      	ldr	r3, [r7, #4]
 8104f7c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8104f7e:	3b01      	subs	r3, #1
 8104f80:	041a      	lsls	r2, r3, #16
    hfdcan->Instance->DBTP = ((((uint32_t)hfdcan->Init.DataSyncJumpWidth - 1U) << FDCAN_DBTP_DSJW_Pos)  | \
 8104f82:	687b      	ldr	r3, [r7, #4]
 8104f84:	681b      	ldr	r3, [r3, #0]
                              (((uint32_t)hfdcan->Init.DataTimeSeg2 - 1U) << FDCAN_DBTP_DTSEG2_Pos)     | \
 8104f86:	430a      	orrs	r2, r1
    hfdcan->Instance->DBTP = ((((uint32_t)hfdcan->Init.DataSyncJumpWidth - 1U) << FDCAN_DBTP_DSJW_Pos)  | \
 8104f88:	60da      	str	r2, [r3, #12]
  }

  if (hfdcan->Init.TxFifoQueueElmtsNbr > 0U)
 8104f8a:	687b      	ldr	r3, [r7, #4]
 8104f8c:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 8104f8e:	2b00      	cmp	r3, #0
 8104f90:	d00a      	beq.n	8104fa8 <HAL_FDCAN_Init+0x2b4>
  {
    /* Select between Tx FIFO and Tx Queue operation modes */
    SET_BIT(hfdcan->Instance->TXBC, hfdcan->Init.TxFifoQueueMode);
 8104f92:	687b      	ldr	r3, [r7, #4]
 8104f94:	681b      	ldr	r3, [r3, #0]
 8104f96:	f8d3 10c0 	ldr.w	r1, [r3, #192]	; 0xc0
 8104f9a:	687b      	ldr	r3, [r7, #4]
 8104f9c:	6e5a      	ldr	r2, [r3, #100]	; 0x64
 8104f9e:	687b      	ldr	r3, [r7, #4]
 8104fa0:	681b      	ldr	r3, [r3, #0]
 8104fa2:	430a      	orrs	r2, r1
 8104fa4:	f8c3 20c0 	str.w	r2, [r3, #192]	; 0xc0
  }

  /* Configure Tx element size */
  if ((hfdcan->Init.TxBuffersNbr + hfdcan->Init.TxFifoQueueElmtsNbr) > 0U)
 8104fa8:	687b      	ldr	r3, [r7, #4]
 8104faa:	6dda      	ldr	r2, [r3, #92]	; 0x5c
 8104fac:	687b      	ldr	r3, [r7, #4]
 8104fae:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 8104fb0:	4413      	add	r3, r2
 8104fb2:	2b00      	cmp	r3, #0
 8104fb4:	d011      	beq.n	8104fda <HAL_FDCAN_Init+0x2e6>
  {
    MODIFY_REG(hfdcan->Instance->TXESC, FDCAN_TXESC_TBDS, CvtEltSize[hfdcan->Init.TxElmtSize]);
 8104fb6:	687b      	ldr	r3, [r7, #4]
 8104fb8:	681b      	ldr	r3, [r3, #0]
 8104fba:	f8d3 30c8 	ldr.w	r3, [r3, #200]	; 0xc8
 8104fbe:	f023 0107 	bic.w	r1, r3, #7
 8104fc2:	687b      	ldr	r3, [r7, #4]
 8104fc4:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 8104fc6:	009b      	lsls	r3, r3, #2
 8104fc8:	3360      	adds	r3, #96	; 0x60
 8104fca:	443b      	add	r3, r7
 8104fcc:	f853 2c54 	ldr.w	r2, [r3, #-84]
 8104fd0:	687b      	ldr	r3, [r7, #4]
 8104fd2:	681b      	ldr	r3, [r3, #0]
 8104fd4:	430a      	orrs	r2, r1
 8104fd6:	f8c3 20c8 	str.w	r2, [r3, #200]	; 0xc8
  }

  /* Configure Rx FIFO 0 element size */
  if (hfdcan->Init.RxFifo0ElmtsNbr > 0U)
 8104fda:	687b      	ldr	r3, [r7, #4]
 8104fdc:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8104fde:	2b00      	cmp	r3, #0
 8104fe0:	d011      	beq.n	8105006 <HAL_FDCAN_Init+0x312>
  {
    MODIFY_REG(hfdcan->Instance->RXESC, FDCAN_RXESC_F0DS,
 8104fe2:	687b      	ldr	r3, [r7, #4]
 8104fe4:	681b      	ldr	r3, [r3, #0]
 8104fe6:	f8d3 30bc 	ldr.w	r3, [r3, #188]	; 0xbc
 8104fea:	f023 0107 	bic.w	r1, r3, #7
 8104fee:	687b      	ldr	r3, [r7, #4]
 8104ff0:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8104ff2:	009b      	lsls	r3, r3, #2
 8104ff4:	3360      	adds	r3, #96	; 0x60
 8104ff6:	443b      	add	r3, r7
 8104ff8:	f853 2c54 	ldr.w	r2, [r3, #-84]
 8104ffc:	687b      	ldr	r3, [r7, #4]
 8104ffe:	681b      	ldr	r3, [r3, #0]
 8105000:	430a      	orrs	r2, r1
 8105002:	f8c3 20bc 	str.w	r2, [r3, #188]	; 0xbc
               (CvtEltSize[hfdcan->Init.RxFifo0ElmtSize] << FDCAN_RXESC_F0DS_Pos));
  }

  /* Configure Rx FIFO 1 element size */
  if (hfdcan->Init.RxFifo1ElmtsNbr > 0U)
 8105006:	687b      	ldr	r3, [r7, #4]
 8105008:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 810500a:	2b00      	cmp	r3, #0
 810500c:	d012      	beq.n	8105034 <HAL_FDCAN_Init+0x340>
  {
    MODIFY_REG(hfdcan->Instance->RXESC, FDCAN_RXESC_F1DS,
 810500e:	687b      	ldr	r3, [r7, #4]
 8105010:	681b      	ldr	r3, [r3, #0]
 8105012:	f8d3 30bc 	ldr.w	r3, [r3, #188]	; 0xbc
 8105016:	f023 0170 	bic.w	r1, r3, #112	; 0x70
 810501a:	687b      	ldr	r3, [r7, #4]
 810501c:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 810501e:	009b      	lsls	r3, r3, #2
 8105020:	3360      	adds	r3, #96	; 0x60
 8105022:	443b      	add	r3, r7
 8105024:	f853 3c54 	ldr.w	r3, [r3, #-84]
 8105028:	011a      	lsls	r2, r3, #4
 810502a:	687b      	ldr	r3, [r7, #4]
 810502c:	681b      	ldr	r3, [r3, #0]
 810502e:	430a      	orrs	r2, r1
 8105030:	f8c3 20bc 	str.w	r2, [r3, #188]	; 0xbc
               (CvtEltSize[hfdcan->Init.RxFifo1ElmtSize] << FDCAN_RXESC_F1DS_Pos));
  }

  /* Configure Rx buffer element size */
  if (hfdcan->Init.RxBuffersNbr > 0U)
 8105034:	687b      	ldr	r3, [r7, #4]
 8105036:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8105038:	2b00      	cmp	r3, #0
 810503a:	d012      	beq.n	8105062 <HAL_FDCAN_Init+0x36e>
  {
    MODIFY_REG(hfdcan->Instance->RXESC, FDCAN_RXESC_RBDS,
 810503c:	687b      	ldr	r3, [r7, #4]
 810503e:	681b      	ldr	r3, [r3, #0]
 8105040:	f8d3 30bc 	ldr.w	r3, [r3, #188]	; 0xbc
 8105044:	f423 61e0 	bic.w	r1, r3, #1792	; 0x700
 8105048:	687b      	ldr	r3, [r7, #4]
 810504a:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 810504c:	009b      	lsls	r3, r3, #2
 810504e:	3360      	adds	r3, #96	; 0x60
 8105050:	443b      	add	r3, r7
 8105052:	f853 3c54 	ldr.w	r3, [r3, #-84]
 8105056:	021a      	lsls	r2, r3, #8
 8105058:	687b      	ldr	r3, [r7, #4]
 810505a:	681b      	ldr	r3, [r3, #0]
 810505c:	430a      	orrs	r2, r1
 810505e:	f8c3 20bc 	str.w	r2, [r3, #188]	; 0xbc
  }

  /* By default operation mode is set to Event-driven communication.
     If Time-triggered communication is needed, user should call the
     HAL_FDCAN_TT_ConfigOperation function just after the HAL_FDCAN_Init */
  if (hfdcan->Instance == FDCAN1)
 8105062:	687b      	ldr	r3, [r7, #4]
 8105064:	681b      	ldr	r3, [r3, #0]
 8105066:	4a11      	ldr	r2, [pc, #68]	; (81050ac <HAL_FDCAN_Init+0x3b8>)
 8105068:	4293      	cmp	r3, r2
 810506a:	d107      	bne.n	810507c <HAL_FDCAN_Init+0x388>
  {
    CLEAR_BIT(hfdcan->ttcan->TTOCF, FDCAN_TTOCF_OM);
 810506c:	687b      	ldr	r3, [r7, #4]
 810506e:	685b      	ldr	r3, [r3, #4]
 8105070:	689a      	ldr	r2, [r3, #8]
 8105072:	687b      	ldr	r3, [r7, #4]
 8105074:	685b      	ldr	r3, [r3, #4]
 8105076:	f022 0203 	bic.w	r2, r2, #3
 810507a:	609a      	str	r2, [r3, #8]
  }

  /* Initialize the Latest Tx FIFO/Queue request buffer index */
  hfdcan->LatestTxFifoQRequest = 0U;
 810507c:	687b      	ldr	r3, [r7, #4]
 810507e:	2200      	movs	r2, #0
 8105080:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94

  /* Initialize the error code */
  hfdcan->ErrorCode = HAL_FDCAN_ERROR_NONE;
 8105084:	687b      	ldr	r3, [r7, #4]
 8105086:	2200      	movs	r2, #0
 8105088:	f8c3 209c 	str.w	r2, [r3, #156]	; 0x9c

  /* Initialize the FDCAN state */
  hfdcan->State = HAL_FDCAN_STATE_READY;
 810508c:	687b      	ldr	r3, [r7, #4]
 810508e:	2201      	movs	r2, #1
 8105090:	f883 2098 	strb.w	r2, [r3, #152]	; 0x98

  /* Calculate each RAM block address */
  status = FDCAN_CalcultateRamBlockAddresses(hfdcan);
 8105094:	6878      	ldr	r0, [r7, #4]
 8105096:	f000 f80b 	bl	81050b0 <FDCAN_CalcultateRamBlockAddresses>
 810509a:	4603      	mov	r3, r0
 810509c:	f887 305b 	strb.w	r3, [r7, #91]	; 0x5b

  /* Return function status */
  return status;
 81050a0:	f897 305b 	ldrb.w	r3, [r7, #91]	; 0x5b
}
 81050a4:	4618      	mov	r0, r3
 81050a6:	3760      	adds	r7, #96	; 0x60
 81050a8:	46bd      	mov	sp, r7
 81050aa:	bd80      	pop	{r7, pc}
 81050ac:	4000a000 	.word	0x4000a000

081050b0 <FDCAN_CalcultateRamBlockAddresses>:
  * @param  hfdcan pointer to an FDCAN_HandleTypeDef structure that contains
  *         the configuration information for the specified FDCAN.
  * @retval HAL status
 */
static HAL_StatusTypeDef FDCAN_CalcultateRamBlockAddresses(FDCAN_HandleTypeDef *hfdcan)
{
 81050b0:	b480      	push	{r7}
 81050b2:	b085      	sub	sp, #20
 81050b4:	af00      	add	r7, sp, #0
 81050b6:	6078      	str	r0, [r7, #4]
  uint32_t RAMcounter;
  uint32_t StartAddress;

  StartAddress = hfdcan->Init.MessageRAMOffset;
 81050b8:	687b      	ldr	r3, [r7, #4]
 81050ba:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 81050bc:	60bb      	str	r3, [r7, #8]

  /* Standard filter list start address */
  MODIFY_REG(hfdcan->Instance->SIDFC, FDCAN_SIDFC_FLSSA, (StartAddress << FDCAN_SIDFC_FLSSA_Pos));
 81050be:	687b      	ldr	r3, [r7, #4]
 81050c0:	681b      	ldr	r3, [r3, #0]
 81050c2:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 81050c6:	f423 437f 	bic.w	r3, r3, #65280	; 0xff00
 81050ca:	f023 03fc 	bic.w	r3, r3, #252	; 0xfc
 81050ce:	68ba      	ldr	r2, [r7, #8]
 81050d0:	0091      	lsls	r1, r2, #2
 81050d2:	687a      	ldr	r2, [r7, #4]
 81050d4:	6812      	ldr	r2, [r2, #0]
 81050d6:	430b      	orrs	r3, r1
 81050d8:	f8c2 3084 	str.w	r3, [r2, #132]	; 0x84

  /* Standard filter elements number */
  MODIFY_REG(hfdcan->Instance->SIDFC, FDCAN_SIDFC_LSS, (hfdcan->Init.StdFiltersNbr << FDCAN_SIDFC_LSS_Pos));
 81050dc:	687b      	ldr	r3, [r7, #4]
 81050de:	681b      	ldr	r3, [r3, #0]
 81050e0:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 81050e4:	f423 017f 	bic.w	r1, r3, #16711680	; 0xff0000
 81050e8:	687b      	ldr	r3, [r7, #4]
 81050ea:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 81050ec:	041a      	lsls	r2, r3, #16
 81050ee:	687b      	ldr	r3, [r7, #4]
 81050f0:	681b      	ldr	r3, [r3, #0]
 81050f2:	430a      	orrs	r2, r1
 81050f4:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84

  /* Extended filter list start address */
  StartAddress += hfdcan->Init.StdFiltersNbr;
 81050f8:	687b      	ldr	r3, [r7, #4]
 81050fa:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 81050fc:	68ba      	ldr	r2, [r7, #8]
 81050fe:	4413      	add	r3, r2
 8105100:	60bb      	str	r3, [r7, #8]
  MODIFY_REG(hfdcan->Instance->XIDFC, FDCAN_XIDFC_FLESA, (StartAddress << FDCAN_XIDFC_FLESA_Pos));
 8105102:	687b      	ldr	r3, [r7, #4]
 8105104:	681b      	ldr	r3, [r3, #0]
 8105106:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 810510a:	f423 437f 	bic.w	r3, r3, #65280	; 0xff00
 810510e:	f023 03fc 	bic.w	r3, r3, #252	; 0xfc
 8105112:	68ba      	ldr	r2, [r7, #8]
 8105114:	0091      	lsls	r1, r2, #2
 8105116:	687a      	ldr	r2, [r7, #4]
 8105118:	6812      	ldr	r2, [r2, #0]
 810511a:	430b      	orrs	r3, r1
 810511c:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88

  /* Extended filter elements number */
  MODIFY_REG(hfdcan->Instance->XIDFC, FDCAN_XIDFC_LSE, (hfdcan->Init.ExtFiltersNbr << FDCAN_XIDFC_LSE_Pos));
 8105120:	687b      	ldr	r3, [r7, #4]
 8105122:	681b      	ldr	r3, [r3, #0]
 8105124:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 8105128:	f423 01fe 	bic.w	r1, r3, #8323072	; 0x7f0000
 810512c:	687b      	ldr	r3, [r7, #4]
 810512e:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8105130:	041a      	lsls	r2, r3, #16
 8105132:	687b      	ldr	r3, [r7, #4]
 8105134:	681b      	ldr	r3, [r3, #0]
 8105136:	430a      	orrs	r2, r1
 8105138:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88

  /* Rx FIFO 0 start address */
  StartAddress += (hfdcan->Init.ExtFiltersNbr * 2U);
 810513c:	687b      	ldr	r3, [r7, #4]
 810513e:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8105140:	005b      	lsls	r3, r3, #1
 8105142:	68ba      	ldr	r2, [r7, #8]
 8105144:	4413      	add	r3, r2
 8105146:	60bb      	str	r3, [r7, #8]
  MODIFY_REG(hfdcan->Instance->RXF0C, FDCAN_RXF0C_F0SA, (StartAddress << FDCAN_RXF0C_F0SA_Pos));
 8105148:	687b      	ldr	r3, [r7, #4]
 810514a:	681b      	ldr	r3, [r3, #0]
 810514c:	f8d3 30a0 	ldr.w	r3, [r3, #160]	; 0xa0
 8105150:	f423 437f 	bic.w	r3, r3, #65280	; 0xff00
 8105154:	f023 03fc 	bic.w	r3, r3, #252	; 0xfc
 8105158:	68ba      	ldr	r2, [r7, #8]
 810515a:	0091      	lsls	r1, r2, #2
 810515c:	687a      	ldr	r2, [r7, #4]
 810515e:	6812      	ldr	r2, [r2, #0]
 8105160:	430b      	orrs	r3, r1
 8105162:	f8c2 30a0 	str.w	r3, [r2, #160]	; 0xa0

  /* Rx FIFO 0 elements number */
  MODIFY_REG(hfdcan->Instance->RXF0C, FDCAN_RXF0C_F0S, (hfdcan->Init.RxFifo0ElmtsNbr << FDCAN_RXF0C_F0S_Pos));
 8105166:	687b      	ldr	r3, [r7, #4]
 8105168:	681b      	ldr	r3, [r3, #0]
 810516a:	f8d3 30a0 	ldr.w	r3, [r3, #160]	; 0xa0
 810516e:	f423 01fe 	bic.w	r1, r3, #8323072	; 0x7f0000
 8105172:	687b      	ldr	r3, [r7, #4]
 8105174:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8105176:	041a      	lsls	r2, r3, #16
 8105178:	687b      	ldr	r3, [r7, #4]
 810517a:	681b      	ldr	r3, [r3, #0]
 810517c:	430a      	orrs	r2, r1
 810517e:	f8c3 20a0 	str.w	r2, [r3, #160]	; 0xa0

  /* Rx FIFO 1 start address */
  StartAddress += (hfdcan->Init.RxFifo0ElmtsNbr * hfdcan->Init.RxFifo0ElmtSize);
 8105182:	687b      	ldr	r3, [r7, #4]
 8105184:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8105186:	687a      	ldr	r2, [r7, #4]
 8105188:	6c52      	ldr	r2, [r2, #68]	; 0x44
 810518a:	fb02 f303 	mul.w	r3, r2, r3
 810518e:	68ba      	ldr	r2, [r7, #8]
 8105190:	4413      	add	r3, r2
 8105192:	60bb      	str	r3, [r7, #8]
  MODIFY_REG(hfdcan->Instance->RXF1C, FDCAN_RXF1C_F1SA, (StartAddress << FDCAN_RXF1C_F1SA_Pos));
 8105194:	687b      	ldr	r3, [r7, #4]
 8105196:	681b      	ldr	r3, [r3, #0]
 8105198:	f8d3 30b0 	ldr.w	r3, [r3, #176]	; 0xb0
 810519c:	f423 437f 	bic.w	r3, r3, #65280	; 0xff00
 81051a0:	f023 03fc 	bic.w	r3, r3, #252	; 0xfc
 81051a4:	68ba      	ldr	r2, [r7, #8]
 81051a6:	0091      	lsls	r1, r2, #2
 81051a8:	687a      	ldr	r2, [r7, #4]
 81051aa:	6812      	ldr	r2, [r2, #0]
 81051ac:	430b      	orrs	r3, r1
 81051ae:	f8c2 30b0 	str.w	r3, [r2, #176]	; 0xb0

  /* Rx FIFO 1 elements number */
  MODIFY_REG(hfdcan->Instance->RXF1C, FDCAN_RXF1C_F1S, (hfdcan->Init.RxFifo1ElmtsNbr << FDCAN_RXF1C_F1S_Pos));
 81051b2:	687b      	ldr	r3, [r7, #4]
 81051b4:	681b      	ldr	r3, [r3, #0]
 81051b6:	f8d3 30b0 	ldr.w	r3, [r3, #176]	; 0xb0
 81051ba:	f423 01fe 	bic.w	r1, r3, #8323072	; 0x7f0000
 81051be:	687b      	ldr	r3, [r7, #4]
 81051c0:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 81051c2:	041a      	lsls	r2, r3, #16
 81051c4:	687b      	ldr	r3, [r7, #4]
 81051c6:	681b      	ldr	r3, [r3, #0]
 81051c8:	430a      	orrs	r2, r1
 81051ca:	f8c3 20b0 	str.w	r2, [r3, #176]	; 0xb0

  /* Rx buffer list start address */
  StartAddress += (hfdcan->Init.RxFifo1ElmtsNbr * hfdcan->Init.RxFifo1ElmtSize);
 81051ce:	687b      	ldr	r3, [r7, #4]
 81051d0:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 81051d2:	687a      	ldr	r2, [r7, #4]
 81051d4:	6cd2      	ldr	r2, [r2, #76]	; 0x4c
 81051d6:	fb02 f303 	mul.w	r3, r2, r3
 81051da:	68ba      	ldr	r2, [r7, #8]
 81051dc:	4413      	add	r3, r2
 81051de:	60bb      	str	r3, [r7, #8]
  MODIFY_REG(hfdcan->Instance->RXBC, FDCAN_RXBC_RBSA, (StartAddress << FDCAN_RXBC_RBSA_Pos));
 81051e0:	687b      	ldr	r3, [r7, #4]
 81051e2:	681b      	ldr	r3, [r3, #0]
 81051e4:	f8d3 30ac 	ldr.w	r3, [r3, #172]	; 0xac
 81051e8:	f423 437f 	bic.w	r3, r3, #65280	; 0xff00
 81051ec:	f023 03fc 	bic.w	r3, r3, #252	; 0xfc
 81051f0:	68ba      	ldr	r2, [r7, #8]
 81051f2:	0091      	lsls	r1, r2, #2
 81051f4:	687a      	ldr	r2, [r7, #4]
 81051f6:	6812      	ldr	r2, [r2, #0]
 81051f8:	430b      	orrs	r3, r1
 81051fa:	f8c2 30ac 	str.w	r3, [r2, #172]	; 0xac

  /* Tx event FIFO start address */
  StartAddress += (hfdcan->Init.RxBuffersNbr * hfdcan->Init.RxBufferSize);
 81051fe:	687b      	ldr	r3, [r7, #4]
 8105200:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8105202:	687a      	ldr	r2, [r7, #4]
 8105204:	6d52      	ldr	r2, [r2, #84]	; 0x54
 8105206:	fb02 f303 	mul.w	r3, r2, r3
 810520a:	68ba      	ldr	r2, [r7, #8]
 810520c:	4413      	add	r3, r2
 810520e:	60bb      	str	r3, [r7, #8]
  MODIFY_REG(hfdcan->Instance->TXEFC, FDCAN_TXEFC_EFSA, (StartAddress << FDCAN_TXEFC_EFSA_Pos));
 8105210:	687b      	ldr	r3, [r7, #4]
 8105212:	681b      	ldr	r3, [r3, #0]
 8105214:	f8d3 30f0 	ldr.w	r3, [r3, #240]	; 0xf0
 8105218:	f423 437f 	bic.w	r3, r3, #65280	; 0xff00
 810521c:	f023 03fc 	bic.w	r3, r3, #252	; 0xfc
 8105220:	68ba      	ldr	r2, [r7, #8]
 8105222:	0091      	lsls	r1, r2, #2
 8105224:	687a      	ldr	r2, [r7, #4]
 8105226:	6812      	ldr	r2, [r2, #0]
 8105228:	430b      	orrs	r3, r1
 810522a:	f8c2 30f0 	str.w	r3, [r2, #240]	; 0xf0

  /* Tx event FIFO elements number */
  MODIFY_REG(hfdcan->Instance->TXEFC, FDCAN_TXEFC_EFS, (hfdcan->Init.TxEventsNbr << FDCAN_TXEFC_EFS_Pos));
 810522e:	687b      	ldr	r3, [r7, #4]
 8105230:	681b      	ldr	r3, [r3, #0]
 8105232:	f8d3 30f0 	ldr.w	r3, [r3, #240]	; 0xf0
 8105236:	f423 117c 	bic.w	r1, r3, #4128768	; 0x3f0000
 810523a:	687b      	ldr	r3, [r7, #4]
 810523c:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 810523e:	041a      	lsls	r2, r3, #16
 8105240:	687b      	ldr	r3, [r7, #4]
 8105242:	681b      	ldr	r3, [r3, #0]
 8105244:	430a      	orrs	r2, r1
 8105246:	f8c3 20f0 	str.w	r2, [r3, #240]	; 0xf0

  /* Tx buffer list start address */
  StartAddress += (hfdcan->Init.TxEventsNbr * 2U);
 810524a:	687b      	ldr	r3, [r7, #4]
 810524c:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 810524e:	005b      	lsls	r3, r3, #1
 8105250:	68ba      	ldr	r2, [r7, #8]
 8105252:	4413      	add	r3, r2
 8105254:	60bb      	str	r3, [r7, #8]
  MODIFY_REG(hfdcan->Instance->TXBC, FDCAN_TXBC_TBSA, (StartAddress << FDCAN_TXBC_TBSA_Pos));
 8105256:	687b      	ldr	r3, [r7, #4]
 8105258:	681b      	ldr	r3, [r3, #0]
 810525a:	f8d3 30c0 	ldr.w	r3, [r3, #192]	; 0xc0
 810525e:	f423 437f 	bic.w	r3, r3, #65280	; 0xff00
 8105262:	f023 03fc 	bic.w	r3, r3, #252	; 0xfc
 8105266:	68ba      	ldr	r2, [r7, #8]
 8105268:	0091      	lsls	r1, r2, #2
 810526a:	687a      	ldr	r2, [r7, #4]
 810526c:	6812      	ldr	r2, [r2, #0]
 810526e:	430b      	orrs	r3, r1
 8105270:	f8c2 30c0 	str.w	r3, [r2, #192]	; 0xc0

  /* Dedicated Tx buffers number */
  MODIFY_REG(hfdcan->Instance->TXBC, FDCAN_TXBC_NDTB, (hfdcan->Init.TxBuffersNbr << FDCAN_TXBC_NDTB_Pos));
 8105274:	687b      	ldr	r3, [r7, #4]
 8105276:	681b      	ldr	r3, [r3, #0]
 8105278:	f8d3 30c0 	ldr.w	r3, [r3, #192]	; 0xc0
 810527c:	f423 117c 	bic.w	r1, r3, #4128768	; 0x3f0000
 8105280:	687b      	ldr	r3, [r7, #4]
 8105282:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 8105284:	041a      	lsls	r2, r3, #16
 8105286:	687b      	ldr	r3, [r7, #4]
 8105288:	681b      	ldr	r3, [r3, #0]
 810528a:	430a      	orrs	r2, r1
 810528c:	f8c3 20c0 	str.w	r2, [r3, #192]	; 0xc0

  /* Tx FIFO/queue elements number */
  MODIFY_REG(hfdcan->Instance->TXBC, FDCAN_TXBC_TFQS, (hfdcan->Init.TxFifoQueueElmtsNbr << FDCAN_TXBC_TFQS_Pos));
 8105290:	687b      	ldr	r3, [r7, #4]
 8105292:	681b      	ldr	r3, [r3, #0]
 8105294:	f8d3 30c0 	ldr.w	r3, [r3, #192]	; 0xc0
 8105298:	f023 517c 	bic.w	r1, r3, #1056964608	; 0x3f000000
 810529c:	687b      	ldr	r3, [r7, #4]
 810529e:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 81052a0:	061a      	lsls	r2, r3, #24
 81052a2:	687b      	ldr	r3, [r7, #4]
 81052a4:	681b      	ldr	r3, [r3, #0]
 81052a6:	430a      	orrs	r2, r1
 81052a8:	f8c3 20c0 	str.w	r2, [r3, #192]	; 0xc0

  hfdcan->msgRam.StandardFilterSA = SRAMCAN_BASE + (hfdcan->Init.MessageRAMOffset * 4U);
 81052ac:	687b      	ldr	r3, [r7, #4]
 81052ae:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 81052b0:	f103 5380 	add.w	r3, r3, #268435456	; 0x10000000
 81052b4:	f503 532c 	add.w	r3, r3, #11008	; 0x2b00
 81052b8:	009a      	lsls	r2, r3, #2
 81052ba:	687b      	ldr	r3, [r7, #4]
 81052bc:	66da      	str	r2, [r3, #108]	; 0x6c
  hfdcan->msgRam.ExtendedFilterSA = hfdcan->msgRam.StandardFilterSA + (hfdcan->Init.StdFiltersNbr * 4U);
 81052be:	687b      	ldr	r3, [r7, #4]
 81052c0:	6eda      	ldr	r2, [r3, #108]	; 0x6c
 81052c2:	687b      	ldr	r3, [r7, #4]
 81052c4:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 81052c6:	009b      	lsls	r3, r3, #2
 81052c8:	441a      	add	r2, r3
 81052ca:	687b      	ldr	r3, [r7, #4]
 81052cc:	671a      	str	r2, [r3, #112]	; 0x70
  hfdcan->msgRam.RxFIFO0SA = hfdcan->msgRam.ExtendedFilterSA + (hfdcan->Init.ExtFiltersNbr * 2U * 4U);
 81052ce:	687b      	ldr	r3, [r7, #4]
 81052d0:	6f1a      	ldr	r2, [r3, #112]	; 0x70
 81052d2:	687b      	ldr	r3, [r7, #4]
 81052d4:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 81052d6:	00db      	lsls	r3, r3, #3
 81052d8:	441a      	add	r2, r3
 81052da:	687b      	ldr	r3, [r7, #4]
 81052dc:	675a      	str	r2, [r3, #116]	; 0x74
  hfdcan->msgRam.RxFIFO1SA = hfdcan->msgRam.RxFIFO0SA +
 81052de:	687b      	ldr	r3, [r7, #4]
 81052e0:	6f5a      	ldr	r2, [r3, #116]	; 0x74
                             (hfdcan->Init.RxFifo0ElmtsNbr * hfdcan->Init.RxFifo0ElmtSize * 4U);
 81052e2:	687b      	ldr	r3, [r7, #4]
 81052e4:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 81052e6:	6879      	ldr	r1, [r7, #4]
 81052e8:	6c49      	ldr	r1, [r1, #68]	; 0x44
 81052ea:	fb01 f303 	mul.w	r3, r1, r3
 81052ee:	009b      	lsls	r3, r3, #2
  hfdcan->msgRam.RxFIFO1SA = hfdcan->msgRam.RxFIFO0SA +
 81052f0:	441a      	add	r2, r3
 81052f2:	687b      	ldr	r3, [r7, #4]
 81052f4:	679a      	str	r2, [r3, #120]	; 0x78
  hfdcan->msgRam.RxBufferSA = hfdcan->msgRam.RxFIFO1SA +
 81052f6:	687b      	ldr	r3, [r7, #4]
 81052f8:	6f9a      	ldr	r2, [r3, #120]	; 0x78
                              (hfdcan->Init.RxFifo1ElmtsNbr * hfdcan->Init.RxFifo1ElmtSize * 4U);
 81052fa:	687b      	ldr	r3, [r7, #4]
 81052fc:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 81052fe:	6879      	ldr	r1, [r7, #4]
 8105300:	6cc9      	ldr	r1, [r1, #76]	; 0x4c
 8105302:	fb01 f303 	mul.w	r3, r1, r3
 8105306:	009b      	lsls	r3, r3, #2
  hfdcan->msgRam.RxBufferSA = hfdcan->msgRam.RxFIFO1SA +
 8105308:	441a      	add	r2, r3
 810530a:	687b      	ldr	r3, [r7, #4]
 810530c:	67da      	str	r2, [r3, #124]	; 0x7c
  hfdcan->msgRam.TxEventFIFOSA = hfdcan->msgRam.RxBufferSA +
 810530e:	687b      	ldr	r3, [r7, #4]
 8105310:	6fda      	ldr	r2, [r3, #124]	; 0x7c
                                 (hfdcan->Init.RxBuffersNbr * hfdcan->Init.RxBufferSize * 4U);
 8105312:	687b      	ldr	r3, [r7, #4]
 8105314:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8105316:	6879      	ldr	r1, [r7, #4]
 8105318:	6d49      	ldr	r1, [r1, #84]	; 0x54
 810531a:	fb01 f303 	mul.w	r3, r1, r3
 810531e:	009b      	lsls	r3, r3, #2
  hfdcan->msgRam.TxEventFIFOSA = hfdcan->msgRam.RxBufferSA +
 8105320:	441a      	add	r2, r3
 8105322:	687b      	ldr	r3, [r7, #4]
 8105324:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
  hfdcan->msgRam.TxBufferSA = hfdcan->msgRam.TxEventFIFOSA + (hfdcan->Init.TxEventsNbr * 2U * 4U);
 8105328:	687b      	ldr	r3, [r7, #4]
 810532a:	f8d3 2080 	ldr.w	r2, [r3, #128]	; 0x80
 810532e:	687b      	ldr	r3, [r7, #4]
 8105330:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8105332:	00db      	lsls	r3, r3, #3
 8105334:	441a      	add	r2, r3
 8105336:	687b      	ldr	r3, [r7, #4]
 8105338:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
  hfdcan->msgRam.TxFIFOQSA = hfdcan->msgRam.TxBufferSA + (hfdcan->Init.TxBuffersNbr * hfdcan->Init.TxElmtSize * 4U);
 810533c:	687b      	ldr	r3, [r7, #4]
 810533e:	f8d3 2084 	ldr.w	r2, [r3, #132]	; 0x84
 8105342:	687b      	ldr	r3, [r7, #4]
 8105344:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 8105346:	6879      	ldr	r1, [r7, #4]
 8105348:	6e89      	ldr	r1, [r1, #104]	; 0x68
 810534a:	fb01 f303 	mul.w	r3, r1, r3
 810534e:	009b      	lsls	r3, r3, #2
 8105350:	441a      	add	r2, r3
 8105352:	687b      	ldr	r3, [r7, #4]
 8105354:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88

  hfdcan->msgRam.EndAddress = hfdcan->msgRam.TxFIFOQSA +
 8105358:	687b      	ldr	r3, [r7, #4]
 810535a:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
                              (hfdcan->Init.TxFifoQueueElmtsNbr * hfdcan->Init.TxElmtSize * 4U);
 810535e:	687b      	ldr	r3, [r7, #4]
 8105360:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 8105362:	6879      	ldr	r1, [r7, #4]
 8105364:	6e89      	ldr	r1, [r1, #104]	; 0x68
 8105366:	fb01 f303 	mul.w	r3, r1, r3
 810536a:	009b      	lsls	r3, r3, #2
  hfdcan->msgRam.EndAddress = hfdcan->msgRam.TxFIFOQSA +
 810536c:	441a      	add	r2, r3
 810536e:	687b      	ldr	r3, [r7, #4]
 8105370:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90

  if (hfdcan->msgRam.EndAddress > FDCAN_MESSAGE_RAM_END_ADDRESS) /* Last address of the Message RAM */
 8105374:	687b      	ldr	r3, [r7, #4]
 8105376:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 810537a:	4a14      	ldr	r2, [pc, #80]	; (81053cc <FDCAN_CalcultateRamBlockAddresses+0x31c>)
 810537c:	4293      	cmp	r3, r2
 810537e:	d90d      	bls.n	810539c <FDCAN_CalcultateRamBlockAddresses+0x2ec>
  {
    /* Update error code.
       Message RAM overflow */
    hfdcan->ErrorCode |= HAL_FDCAN_ERROR_PARAM;
 8105380:	687b      	ldr	r3, [r7, #4]
 8105382:	f8d3 309c 	ldr.w	r3, [r3, #156]	; 0x9c
 8105386:	f043 0220 	orr.w	r2, r3, #32
 810538a:	687b      	ldr	r3, [r7, #4]
 810538c:	f8c3 209c 	str.w	r2, [r3, #156]	; 0x9c

    /* Change FDCAN state */
    hfdcan->State = HAL_FDCAN_STATE_ERROR;
 8105390:	687b      	ldr	r3, [r7, #4]
 8105392:	2203      	movs	r2, #3
 8105394:	f883 2098 	strb.w	r2, [r3, #152]	; 0x98

    return HAL_ERROR;
 8105398:	2301      	movs	r3, #1
 810539a:	e010      	b.n	81053be <FDCAN_CalcultateRamBlockAddresses+0x30e>
  }
  else
  {
    /* Flush the allocated Message RAM area */
    for (RAMcounter = hfdcan->msgRam.StandardFilterSA; RAMcounter < hfdcan->msgRam.EndAddress; RAMcounter += 4U)
 810539c:	687b      	ldr	r3, [r7, #4]
 810539e:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 81053a0:	60fb      	str	r3, [r7, #12]
 81053a2:	e005      	b.n	81053b0 <FDCAN_CalcultateRamBlockAddresses+0x300>
    {
      *(uint32_t *)(RAMcounter) = 0x00000000;
 81053a4:	68fb      	ldr	r3, [r7, #12]
 81053a6:	2200      	movs	r2, #0
 81053a8:	601a      	str	r2, [r3, #0]
    for (RAMcounter = hfdcan->msgRam.StandardFilterSA; RAMcounter < hfdcan->msgRam.EndAddress; RAMcounter += 4U)
 81053aa:	68fb      	ldr	r3, [r7, #12]
 81053ac:	3304      	adds	r3, #4
 81053ae:	60fb      	str	r3, [r7, #12]
 81053b0:	687b      	ldr	r3, [r7, #4]
 81053b2:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 81053b6:	68fa      	ldr	r2, [r7, #12]
 81053b8:	429a      	cmp	r2, r3
 81053ba:	d3f3      	bcc.n	81053a4 <FDCAN_CalcultateRamBlockAddresses+0x2f4>
    }
  }

  /* Return function status */
  return HAL_OK;
 81053bc:	2300      	movs	r3, #0
}
 81053be:	4618      	mov	r0, r3
 81053c0:	3714      	adds	r7, #20
 81053c2:	46bd      	mov	sp, r7
 81053c4:	f85d 7b04 	ldr.w	r7, [sp], #4
 81053c8:	4770      	bx	lr
 81053ca:	bf00      	nop
 81053cc:	4000d3fc 	.word	0x4000d3fc

081053d0 <HAL_GPIO_Init>:
  * @param  GPIO_Init: pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{
 81053d0:	b480      	push	{r7}
 81053d2:	b089      	sub	sp, #36	; 0x24
 81053d4:	af00      	add	r7, sp, #0
 81053d6:	6078      	str	r0, [r7, #4]
 81053d8:	6039      	str	r1, [r7, #0]
  uint32_t position = 0x00U;
 81053da:	2300      	movs	r3, #0
 81053dc:	61fb      	str	r3, [r7, #28]
  uint32_t iocurrent;
  uint32_t temp;
  EXTI_Core_TypeDef *EXTI_CurrentCPU;

#if defined(DUAL_CORE) && defined(CORE_CM4)
  EXTI_CurrentCPU = EXTI_D2; /* EXTI for CM4 CPU */
 81053de:	4b89      	ldr	r3, [pc, #548]	; (8105604 <HAL_GPIO_Init+0x234>)
 81053e0:	617b      	str	r3, [r7, #20]
  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));

  /* Configure the port pins */
  while (((GPIO_Init->Pin) >> position) != 0x00U)
 81053e2:	e194      	b.n	810570e <HAL_GPIO_Init+0x33e>
  {
    /* Get current io position */
    iocurrent = (GPIO_Init->Pin) & (1UL << position);
 81053e4:	683b      	ldr	r3, [r7, #0]
 81053e6:	681a      	ldr	r2, [r3, #0]
 81053e8:	2101      	movs	r1, #1
 81053ea:	69fb      	ldr	r3, [r7, #28]
 81053ec:	fa01 f303 	lsl.w	r3, r1, r3
 81053f0:	4013      	ands	r3, r2
 81053f2:	613b      	str	r3, [r7, #16]

    if (iocurrent != 0x00U)
 81053f4:	693b      	ldr	r3, [r7, #16]
 81053f6:	2b00      	cmp	r3, #0
 81053f8:	f000 8186 	beq.w	8105708 <HAL_GPIO_Init+0x338>
    {
      /*--------------------- GPIO Mode Configuration ------------------------*/
      /* In case of Output or Alternate function mode selection */
      if (((GPIO_Init->Mode & GPIO_MODE) == MODE_OUTPUT) || ((GPIO_Init->Mode & GPIO_MODE) == MODE_AF))
 81053fc:	683b      	ldr	r3, [r7, #0]
 81053fe:	685b      	ldr	r3, [r3, #4]
 8105400:	f003 0303 	and.w	r3, r3, #3
 8105404:	2b01      	cmp	r3, #1
 8105406:	d005      	beq.n	8105414 <HAL_GPIO_Init+0x44>
 8105408:	683b      	ldr	r3, [r7, #0]
 810540a:	685b      	ldr	r3, [r3, #4]
 810540c:	f003 0303 	and.w	r3, r3, #3
 8105410:	2b02      	cmp	r3, #2
 8105412:	d130      	bne.n	8105476 <HAL_GPIO_Init+0xa6>
      {
        /* Check the Speed parameter */
        assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));

        /* Configure the IO Speed */
        temp = GPIOx->OSPEEDR;
 8105414:	687b      	ldr	r3, [r7, #4]
 8105416:	689b      	ldr	r3, [r3, #8]
 8105418:	61bb      	str	r3, [r7, #24]
        temp &= ~(GPIO_OSPEEDR_OSPEED0 << (position * 2U));
 810541a:	69fb      	ldr	r3, [r7, #28]
 810541c:	005b      	lsls	r3, r3, #1
 810541e:	2203      	movs	r2, #3
 8105420:	fa02 f303 	lsl.w	r3, r2, r3
 8105424:	43db      	mvns	r3, r3
 8105426:	69ba      	ldr	r2, [r7, #24]
 8105428:	4013      	ands	r3, r2
 810542a:	61bb      	str	r3, [r7, #24]
        temp |= (GPIO_Init->Speed << (position * 2U));
 810542c:	683b      	ldr	r3, [r7, #0]
 810542e:	68da      	ldr	r2, [r3, #12]
 8105430:	69fb      	ldr	r3, [r7, #28]
 8105432:	005b      	lsls	r3, r3, #1
 8105434:	fa02 f303 	lsl.w	r3, r2, r3
 8105438:	69ba      	ldr	r2, [r7, #24]
 810543a:	4313      	orrs	r3, r2
 810543c:	61bb      	str	r3, [r7, #24]
        GPIOx->OSPEEDR = temp;
 810543e:	687b      	ldr	r3, [r7, #4]
 8105440:	69ba      	ldr	r2, [r7, #24]
 8105442:	609a      	str	r2, [r3, #8]

        /* Configure the IO Output Type */
        temp = GPIOx->OTYPER;
 8105444:	687b      	ldr	r3, [r7, #4]
 8105446:	685b      	ldr	r3, [r3, #4]
 8105448:	61bb      	str	r3, [r7, #24]
        temp &= ~(GPIO_OTYPER_OT0 << position) ;
 810544a:	2201      	movs	r2, #1
 810544c:	69fb      	ldr	r3, [r7, #28]
 810544e:	fa02 f303 	lsl.w	r3, r2, r3
 8105452:	43db      	mvns	r3, r3
 8105454:	69ba      	ldr	r2, [r7, #24]
 8105456:	4013      	ands	r3, r2
 8105458:	61bb      	str	r3, [r7, #24]
        temp |= (((GPIO_Init->Mode & OUTPUT_TYPE) >> OUTPUT_TYPE_Pos) << position);
 810545a:	683b      	ldr	r3, [r7, #0]
 810545c:	685b      	ldr	r3, [r3, #4]
 810545e:	091b      	lsrs	r3, r3, #4
 8105460:	f003 0201 	and.w	r2, r3, #1
 8105464:	69fb      	ldr	r3, [r7, #28]
 8105466:	fa02 f303 	lsl.w	r3, r2, r3
 810546a:	69ba      	ldr	r2, [r7, #24]
 810546c:	4313      	orrs	r3, r2
 810546e:	61bb      	str	r3, [r7, #24]
        GPIOx->OTYPER = temp;
 8105470:	687b      	ldr	r3, [r7, #4]
 8105472:	69ba      	ldr	r2, [r7, #24]
 8105474:	605a      	str	r2, [r3, #4]
      }

      if ((GPIO_Init->Mode & GPIO_MODE) != MODE_ANALOG)
 8105476:	683b      	ldr	r3, [r7, #0]
 8105478:	685b      	ldr	r3, [r3, #4]
 810547a:	f003 0303 	and.w	r3, r3, #3
 810547e:	2b03      	cmp	r3, #3
 8105480:	d017      	beq.n	81054b2 <HAL_GPIO_Init+0xe2>
      {
       /* Check the Pull parameter */
       assert_param(IS_GPIO_PULL(GPIO_Init->Pull));

      /* Activate the Pull-up or Pull down resistor for the current IO */
      temp = GPIOx->PUPDR;
 8105482:	687b      	ldr	r3, [r7, #4]
 8105484:	68db      	ldr	r3, [r3, #12]
 8105486:	61bb      	str	r3, [r7, #24]
      temp &= ~(GPIO_PUPDR_PUPD0 << (position * 2U));
 8105488:	69fb      	ldr	r3, [r7, #28]
 810548a:	005b      	lsls	r3, r3, #1
 810548c:	2203      	movs	r2, #3
 810548e:	fa02 f303 	lsl.w	r3, r2, r3
 8105492:	43db      	mvns	r3, r3
 8105494:	69ba      	ldr	r2, [r7, #24]
 8105496:	4013      	ands	r3, r2
 8105498:	61bb      	str	r3, [r7, #24]
      temp |= ((GPIO_Init->Pull) << (position * 2U));
 810549a:	683b      	ldr	r3, [r7, #0]
 810549c:	689a      	ldr	r2, [r3, #8]
 810549e:	69fb      	ldr	r3, [r7, #28]
 81054a0:	005b      	lsls	r3, r3, #1
 81054a2:	fa02 f303 	lsl.w	r3, r2, r3
 81054a6:	69ba      	ldr	r2, [r7, #24]
 81054a8:	4313      	orrs	r3, r2
 81054aa:	61bb      	str	r3, [r7, #24]
      GPIOx->PUPDR = temp;
 81054ac:	687b      	ldr	r3, [r7, #4]
 81054ae:	69ba      	ldr	r2, [r7, #24]
 81054b0:	60da      	str	r2, [r3, #12]
      }

      /* In case of Alternate function mode selection */
      if ((GPIO_Init->Mode & GPIO_MODE) == MODE_AF)
 81054b2:	683b      	ldr	r3, [r7, #0]
 81054b4:	685b      	ldr	r3, [r3, #4]
 81054b6:	f003 0303 	and.w	r3, r3, #3
 81054ba:	2b02      	cmp	r3, #2
 81054bc:	d123      	bne.n	8105506 <HAL_GPIO_Init+0x136>
        /* Check the Alternate function parameters */
        assert_param(IS_GPIO_AF_INSTANCE(GPIOx));
        assert_param(IS_GPIO_AF(GPIO_Init->Alternate));

        /* Configure Alternate function mapped with the current IO */
        temp = GPIOx->AFR[position >> 3U];
 81054be:	69fb      	ldr	r3, [r7, #28]
 81054c0:	08da      	lsrs	r2, r3, #3
 81054c2:	687b      	ldr	r3, [r7, #4]
 81054c4:	3208      	adds	r2, #8
 81054c6:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 81054ca:	61bb      	str	r3, [r7, #24]
        temp &= ~(0xFU << ((position & 0x07U) * 4U));
 81054cc:	69fb      	ldr	r3, [r7, #28]
 81054ce:	f003 0307 	and.w	r3, r3, #7
 81054d2:	009b      	lsls	r3, r3, #2
 81054d4:	220f      	movs	r2, #15
 81054d6:	fa02 f303 	lsl.w	r3, r2, r3
 81054da:	43db      	mvns	r3, r3
 81054dc:	69ba      	ldr	r2, [r7, #24]
 81054de:	4013      	ands	r3, r2
 81054e0:	61bb      	str	r3, [r7, #24]
        temp |= ((GPIO_Init->Alternate) << ((position & 0x07U) * 4U));
 81054e2:	683b      	ldr	r3, [r7, #0]
 81054e4:	691a      	ldr	r2, [r3, #16]
 81054e6:	69fb      	ldr	r3, [r7, #28]
 81054e8:	f003 0307 	and.w	r3, r3, #7
 81054ec:	009b      	lsls	r3, r3, #2
 81054ee:	fa02 f303 	lsl.w	r3, r2, r3
 81054f2:	69ba      	ldr	r2, [r7, #24]
 81054f4:	4313      	orrs	r3, r2
 81054f6:	61bb      	str	r3, [r7, #24]
        GPIOx->AFR[position >> 3U] = temp;
 81054f8:	69fb      	ldr	r3, [r7, #28]
 81054fa:	08da      	lsrs	r2, r3, #3
 81054fc:	687b      	ldr	r3, [r7, #4]
 81054fe:	3208      	adds	r2, #8
 8105500:	69b9      	ldr	r1, [r7, #24]
 8105502:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
      }

      /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
      temp = GPIOx->MODER;
 8105506:	687b      	ldr	r3, [r7, #4]
 8105508:	681b      	ldr	r3, [r3, #0]
 810550a:	61bb      	str	r3, [r7, #24]
      temp &= ~(GPIO_MODER_MODE0 << (position * 2U));
 810550c:	69fb      	ldr	r3, [r7, #28]
 810550e:	005b      	lsls	r3, r3, #1
 8105510:	2203      	movs	r2, #3
 8105512:	fa02 f303 	lsl.w	r3, r2, r3
 8105516:	43db      	mvns	r3, r3
 8105518:	69ba      	ldr	r2, [r7, #24]
 810551a:	4013      	ands	r3, r2
 810551c:	61bb      	str	r3, [r7, #24]
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
 810551e:	683b      	ldr	r3, [r7, #0]
 8105520:	685b      	ldr	r3, [r3, #4]
 8105522:	f003 0203 	and.w	r2, r3, #3
 8105526:	69fb      	ldr	r3, [r7, #28]
 8105528:	005b      	lsls	r3, r3, #1
 810552a:	fa02 f303 	lsl.w	r3, r2, r3
 810552e:	69ba      	ldr	r2, [r7, #24]
 8105530:	4313      	orrs	r3, r2
 8105532:	61bb      	str	r3, [r7, #24]
      GPIOx->MODER = temp;
 8105534:	687b      	ldr	r3, [r7, #4]
 8105536:	69ba      	ldr	r2, [r7, #24]
 8105538:	601a      	str	r2, [r3, #0]

      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if ((GPIO_Init->Mode & EXTI_MODE) != 0x00U)
 810553a:	683b      	ldr	r3, [r7, #0]
 810553c:	685b      	ldr	r3, [r3, #4]
 810553e:	f403 3340 	and.w	r3, r3, #196608	; 0x30000
 8105542:	2b00      	cmp	r3, #0
 8105544:	f000 80e0 	beq.w	8105708 <HAL_GPIO_Init+0x338>
      {
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 8105548:	4b2f      	ldr	r3, [pc, #188]	; (8105608 <HAL_GPIO_Init+0x238>)
 810554a:	f8d3 30f4 	ldr.w	r3, [r3, #244]	; 0xf4
 810554e:	4a2e      	ldr	r2, [pc, #184]	; (8105608 <HAL_GPIO_Init+0x238>)
 8105550:	f043 0302 	orr.w	r3, r3, #2
 8105554:	f8c2 30f4 	str.w	r3, [r2, #244]	; 0xf4
 8105558:	4b2b      	ldr	r3, [pc, #172]	; (8105608 <HAL_GPIO_Init+0x238>)
 810555a:	f8d3 30f4 	ldr.w	r3, [r3, #244]	; 0xf4
 810555e:	f003 0302 	and.w	r3, r3, #2
 8105562:	60fb      	str	r3, [r7, #12]
 8105564:	68fb      	ldr	r3, [r7, #12]

        temp = SYSCFG->EXTICR[position >> 2U];
 8105566:	4a29      	ldr	r2, [pc, #164]	; (810560c <HAL_GPIO_Init+0x23c>)
 8105568:	69fb      	ldr	r3, [r7, #28]
 810556a:	089b      	lsrs	r3, r3, #2
 810556c:	3302      	adds	r3, #2
 810556e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8105572:	61bb      	str	r3, [r7, #24]
        temp &= ~(0x0FUL << (4U * (position & 0x03U)));
 8105574:	69fb      	ldr	r3, [r7, #28]
 8105576:	f003 0303 	and.w	r3, r3, #3
 810557a:	009b      	lsls	r3, r3, #2
 810557c:	220f      	movs	r2, #15
 810557e:	fa02 f303 	lsl.w	r3, r2, r3
 8105582:	43db      	mvns	r3, r3
 8105584:	69ba      	ldr	r2, [r7, #24]
 8105586:	4013      	ands	r3, r2
 8105588:	61bb      	str	r3, [r7, #24]
        temp |= (GPIO_GET_INDEX(GPIOx) << (4U * (position & 0x03U)));
 810558a:	687b      	ldr	r3, [r7, #4]
 810558c:	4a20      	ldr	r2, [pc, #128]	; (8105610 <HAL_GPIO_Init+0x240>)
 810558e:	4293      	cmp	r3, r2
 8105590:	d052      	beq.n	8105638 <HAL_GPIO_Init+0x268>
 8105592:	687b      	ldr	r3, [r7, #4]
 8105594:	4a1f      	ldr	r2, [pc, #124]	; (8105614 <HAL_GPIO_Init+0x244>)
 8105596:	4293      	cmp	r3, r2
 8105598:	d031      	beq.n	81055fe <HAL_GPIO_Init+0x22e>
 810559a:	687b      	ldr	r3, [r7, #4]
 810559c:	4a1e      	ldr	r2, [pc, #120]	; (8105618 <HAL_GPIO_Init+0x248>)
 810559e:	4293      	cmp	r3, r2
 81055a0:	d02b      	beq.n	81055fa <HAL_GPIO_Init+0x22a>
 81055a2:	687b      	ldr	r3, [r7, #4]
 81055a4:	4a1d      	ldr	r2, [pc, #116]	; (810561c <HAL_GPIO_Init+0x24c>)
 81055a6:	4293      	cmp	r3, r2
 81055a8:	d025      	beq.n	81055f6 <HAL_GPIO_Init+0x226>
 81055aa:	687b      	ldr	r3, [r7, #4]
 81055ac:	4a1c      	ldr	r2, [pc, #112]	; (8105620 <HAL_GPIO_Init+0x250>)
 81055ae:	4293      	cmp	r3, r2
 81055b0:	d01f      	beq.n	81055f2 <HAL_GPIO_Init+0x222>
 81055b2:	687b      	ldr	r3, [r7, #4]
 81055b4:	4a1b      	ldr	r2, [pc, #108]	; (8105624 <HAL_GPIO_Init+0x254>)
 81055b6:	4293      	cmp	r3, r2
 81055b8:	d019      	beq.n	81055ee <HAL_GPIO_Init+0x21e>
 81055ba:	687b      	ldr	r3, [r7, #4]
 81055bc:	4a1a      	ldr	r2, [pc, #104]	; (8105628 <HAL_GPIO_Init+0x258>)
 81055be:	4293      	cmp	r3, r2
 81055c0:	d013      	beq.n	81055ea <HAL_GPIO_Init+0x21a>
 81055c2:	687b      	ldr	r3, [r7, #4]
 81055c4:	4a19      	ldr	r2, [pc, #100]	; (810562c <HAL_GPIO_Init+0x25c>)
 81055c6:	4293      	cmp	r3, r2
 81055c8:	d00d      	beq.n	81055e6 <HAL_GPIO_Init+0x216>
 81055ca:	687b      	ldr	r3, [r7, #4]
 81055cc:	4a18      	ldr	r2, [pc, #96]	; (8105630 <HAL_GPIO_Init+0x260>)
 81055ce:	4293      	cmp	r3, r2
 81055d0:	d007      	beq.n	81055e2 <HAL_GPIO_Init+0x212>
 81055d2:	687b      	ldr	r3, [r7, #4]
 81055d4:	4a17      	ldr	r2, [pc, #92]	; (8105634 <HAL_GPIO_Init+0x264>)
 81055d6:	4293      	cmp	r3, r2
 81055d8:	d101      	bne.n	81055de <HAL_GPIO_Init+0x20e>
 81055da:	2309      	movs	r3, #9
 81055dc:	e02d      	b.n	810563a <HAL_GPIO_Init+0x26a>
 81055de:	230a      	movs	r3, #10
 81055e0:	e02b      	b.n	810563a <HAL_GPIO_Init+0x26a>
 81055e2:	2308      	movs	r3, #8
 81055e4:	e029      	b.n	810563a <HAL_GPIO_Init+0x26a>
 81055e6:	2307      	movs	r3, #7
 81055e8:	e027      	b.n	810563a <HAL_GPIO_Init+0x26a>
 81055ea:	2306      	movs	r3, #6
 81055ec:	e025      	b.n	810563a <HAL_GPIO_Init+0x26a>
 81055ee:	2305      	movs	r3, #5
 81055f0:	e023      	b.n	810563a <HAL_GPIO_Init+0x26a>
 81055f2:	2304      	movs	r3, #4
 81055f4:	e021      	b.n	810563a <HAL_GPIO_Init+0x26a>
 81055f6:	2303      	movs	r3, #3
 81055f8:	e01f      	b.n	810563a <HAL_GPIO_Init+0x26a>
 81055fa:	2302      	movs	r3, #2
 81055fc:	e01d      	b.n	810563a <HAL_GPIO_Init+0x26a>
 81055fe:	2301      	movs	r3, #1
 8105600:	e01b      	b.n	810563a <HAL_GPIO_Init+0x26a>
 8105602:	bf00      	nop
 8105604:	580000c0 	.word	0x580000c0
 8105608:	58024400 	.word	0x58024400
 810560c:	58000400 	.word	0x58000400
 8105610:	58020000 	.word	0x58020000
 8105614:	58020400 	.word	0x58020400
 8105618:	58020800 	.word	0x58020800
 810561c:	58020c00 	.word	0x58020c00
 8105620:	58021000 	.word	0x58021000
 8105624:	58021400 	.word	0x58021400
 8105628:	58021800 	.word	0x58021800
 810562c:	58021c00 	.word	0x58021c00
 8105630:	58022000 	.word	0x58022000
 8105634:	58022400 	.word	0x58022400
 8105638:	2300      	movs	r3, #0
 810563a:	69fa      	ldr	r2, [r7, #28]
 810563c:	f002 0203 	and.w	r2, r2, #3
 8105640:	0092      	lsls	r2, r2, #2
 8105642:	4093      	lsls	r3, r2
 8105644:	69ba      	ldr	r2, [r7, #24]
 8105646:	4313      	orrs	r3, r2
 8105648:	61bb      	str	r3, [r7, #24]
        SYSCFG->EXTICR[position >> 2U] = temp;
 810564a:	4938      	ldr	r1, [pc, #224]	; (810572c <HAL_GPIO_Init+0x35c>)
 810564c:	69fb      	ldr	r3, [r7, #28]
 810564e:	089b      	lsrs	r3, r3, #2
 8105650:	3302      	adds	r3, #2
 8105652:	69ba      	ldr	r2, [r7, #24]
 8105654:	f841 2023 	str.w	r2, [r1, r3, lsl #2]

        /* Clear Rising Falling edge configuration */
        temp = EXTI->RTSR1;
 8105658:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 810565c:	681b      	ldr	r3, [r3, #0]
 810565e:	61bb      	str	r3, [r7, #24]
        temp &= ~(iocurrent);
 8105660:	693b      	ldr	r3, [r7, #16]
 8105662:	43db      	mvns	r3, r3
 8105664:	69ba      	ldr	r2, [r7, #24]
 8105666:	4013      	ands	r3, r2
 8105668:	61bb      	str	r3, [r7, #24]
        if ((GPIO_Init->Mode & TRIGGER_RISING) != 0x00U)
 810566a:	683b      	ldr	r3, [r7, #0]
 810566c:	685b      	ldr	r3, [r3, #4]
 810566e:	f403 1380 	and.w	r3, r3, #1048576	; 0x100000
 8105672:	2b00      	cmp	r3, #0
 8105674:	d003      	beq.n	810567e <HAL_GPIO_Init+0x2ae>
        {
          temp |= iocurrent;
 8105676:	69ba      	ldr	r2, [r7, #24]
 8105678:	693b      	ldr	r3, [r7, #16]
 810567a:	4313      	orrs	r3, r2
 810567c:	61bb      	str	r3, [r7, #24]
        }
        EXTI->RTSR1 = temp;
 810567e:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 8105682:	69bb      	ldr	r3, [r7, #24]
 8105684:	6013      	str	r3, [r2, #0]

        temp = EXTI->FTSR1;
 8105686:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 810568a:	685b      	ldr	r3, [r3, #4]
 810568c:	61bb      	str	r3, [r7, #24]
        temp &= ~(iocurrent);
 810568e:	693b      	ldr	r3, [r7, #16]
 8105690:	43db      	mvns	r3, r3
 8105692:	69ba      	ldr	r2, [r7, #24]
 8105694:	4013      	ands	r3, r2
 8105696:	61bb      	str	r3, [r7, #24]
        if ((GPIO_Init->Mode & TRIGGER_FALLING) != 0x00U)
 8105698:	683b      	ldr	r3, [r7, #0]
 810569a:	685b      	ldr	r3, [r3, #4]
 810569c:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
 81056a0:	2b00      	cmp	r3, #0
 81056a2:	d003      	beq.n	81056ac <HAL_GPIO_Init+0x2dc>
        {
          temp |= iocurrent;
 81056a4:	69ba      	ldr	r2, [r7, #24]
 81056a6:	693b      	ldr	r3, [r7, #16]
 81056a8:	4313      	orrs	r3, r2
 81056aa:	61bb      	str	r3, [r7, #24]
        }
        EXTI->FTSR1 = temp;
 81056ac:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 81056b0:	69bb      	ldr	r3, [r7, #24]
 81056b2:	6053      	str	r3, [r2, #4]

        temp = EXTI_CurrentCPU->EMR1;
 81056b4:	697b      	ldr	r3, [r7, #20]
 81056b6:	685b      	ldr	r3, [r3, #4]
 81056b8:	61bb      	str	r3, [r7, #24]
        temp &= ~(iocurrent);
 81056ba:	693b      	ldr	r3, [r7, #16]
 81056bc:	43db      	mvns	r3, r3
 81056be:	69ba      	ldr	r2, [r7, #24]
 81056c0:	4013      	ands	r3, r2
 81056c2:	61bb      	str	r3, [r7, #24]
        if ((GPIO_Init->Mode & EXTI_EVT) != 0x00U)
 81056c4:	683b      	ldr	r3, [r7, #0]
 81056c6:	685b      	ldr	r3, [r3, #4]
 81056c8:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 81056cc:	2b00      	cmp	r3, #0
 81056ce:	d003      	beq.n	81056d8 <HAL_GPIO_Init+0x308>
        {
          temp |= iocurrent;
 81056d0:	69ba      	ldr	r2, [r7, #24]
 81056d2:	693b      	ldr	r3, [r7, #16]
 81056d4:	4313      	orrs	r3, r2
 81056d6:	61bb      	str	r3, [r7, #24]
        }
        EXTI_CurrentCPU->EMR1 = temp;
 81056d8:	697b      	ldr	r3, [r7, #20]
 81056da:	69ba      	ldr	r2, [r7, #24]
 81056dc:	605a      	str	r2, [r3, #4]

        /* Clear EXTI line configuration */
        temp = EXTI_CurrentCPU->IMR1;
 81056de:	697b      	ldr	r3, [r7, #20]
 81056e0:	681b      	ldr	r3, [r3, #0]
 81056e2:	61bb      	str	r3, [r7, #24]
        temp &= ~(iocurrent);
 81056e4:	693b      	ldr	r3, [r7, #16]
 81056e6:	43db      	mvns	r3, r3
 81056e8:	69ba      	ldr	r2, [r7, #24]
 81056ea:	4013      	ands	r3, r2
 81056ec:	61bb      	str	r3, [r7, #24]
        if ((GPIO_Init->Mode & EXTI_IT) != 0x00U)
 81056ee:	683b      	ldr	r3, [r7, #0]
 81056f0:	685b      	ldr	r3, [r3, #4]
 81056f2:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
 81056f6:	2b00      	cmp	r3, #0
 81056f8:	d003      	beq.n	8105702 <HAL_GPIO_Init+0x332>
        {
          temp |= iocurrent;
 81056fa:	69ba      	ldr	r2, [r7, #24]
 81056fc:	693b      	ldr	r3, [r7, #16]
 81056fe:	4313      	orrs	r3, r2
 8105700:	61bb      	str	r3, [r7, #24]
        }
        EXTI_CurrentCPU->IMR1 = temp;
 8105702:	697b      	ldr	r3, [r7, #20]
 8105704:	69ba      	ldr	r2, [r7, #24]
 8105706:	601a      	str	r2, [r3, #0]
      }
    }

    position++;
 8105708:	69fb      	ldr	r3, [r7, #28]
 810570a:	3301      	adds	r3, #1
 810570c:	61fb      	str	r3, [r7, #28]
  while (((GPIO_Init->Pin) >> position) != 0x00U)
 810570e:	683b      	ldr	r3, [r7, #0]
 8105710:	681a      	ldr	r2, [r3, #0]
 8105712:	69fb      	ldr	r3, [r7, #28]
 8105714:	fa22 f303 	lsr.w	r3, r2, r3
 8105718:	2b00      	cmp	r3, #0
 810571a:	f47f ae63 	bne.w	81053e4 <HAL_GPIO_Init+0x14>
  }
}
 810571e:	bf00      	nop
 8105720:	bf00      	nop
 8105722:	3724      	adds	r7, #36	; 0x24
 8105724:	46bd      	mov	sp, r7
 8105726:	f85d 7b04 	ldr.w	r7, [sp], #4
 810572a:	4770      	bx	lr
 810572c:	58000400 	.word	0x58000400

08105730 <HAL_GPIO_WritePin>:
  *            @arg GPIO_PIN_RESET: to clear the port pin
  *            @arg GPIO_PIN_SET: to set the port pin
  * @retval None
  */
void HAL_GPIO_WritePin(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin, GPIO_PinState PinState)
{
 8105730:	b480      	push	{r7}
 8105732:	b083      	sub	sp, #12
 8105734:	af00      	add	r7, sp, #0
 8105736:	6078      	str	r0, [r7, #4]
 8105738:	460b      	mov	r3, r1
 810573a:	807b      	strh	r3, [r7, #2]
 810573c:	4613      	mov	r3, r2
 810573e:	707b      	strb	r3, [r7, #1]
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  assert_param(IS_GPIO_PIN_ACTION(PinState));

  if (PinState != GPIO_PIN_RESET)
 8105740:	787b      	ldrb	r3, [r7, #1]
 8105742:	2b00      	cmp	r3, #0
 8105744:	d003      	beq.n	810574e <HAL_GPIO_WritePin+0x1e>
  {
    GPIOx->BSRR = GPIO_Pin;
 8105746:	887a      	ldrh	r2, [r7, #2]
 8105748:	687b      	ldr	r3, [r7, #4]
 810574a:	619a      	str	r2, [r3, #24]
  }
  else
  {
    GPIOx->BSRR = (uint32_t)GPIO_Pin << GPIO_NUMBER;
  }
}
 810574c:	e003      	b.n	8105756 <HAL_GPIO_WritePin+0x26>
    GPIOx->BSRR = (uint32_t)GPIO_Pin << GPIO_NUMBER;
 810574e:	887b      	ldrh	r3, [r7, #2]
 8105750:	041a      	lsls	r2, r3, #16
 8105752:	687b      	ldr	r3, [r7, #4]
 8105754:	619a      	str	r2, [r3, #24]
}
 8105756:	bf00      	nop
 8105758:	370c      	adds	r7, #12
 810575a:	46bd      	mov	sp, r7
 810575c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8105760:	4770      	bx	lr
	...

08105764 <HAL_HSEM_ActivateNotification>:
  * @brief  Activate Semaphore release Notification for a given Semaphores Mask .
  * @param  SemMask: Mask of Released semaphores
  * @retval Semaphore Key
  */
void HAL_HSEM_ActivateNotification(uint32_t SemMask)
{
 8105764:	b480      	push	{r7}
 8105766:	b083      	sub	sp, #12
 8105768:	af00      	add	r7, sp, #0
 810576a:	6078      	str	r0, [r7, #4]
  {
    /*Use interrupt line 1 for CPU2 Master*/
    HSEM->C2IER |= SemMask;
  }
#else
  HSEM_COMMON->IER |= SemMask;
 810576c:	4b05      	ldr	r3, [pc, #20]	; (8105784 <HAL_HSEM_ActivateNotification+0x20>)
 810576e:	681a      	ldr	r2, [r3, #0]
 8105770:	4904      	ldr	r1, [pc, #16]	; (8105784 <HAL_HSEM_ActivateNotification+0x20>)
 8105772:	687b      	ldr	r3, [r7, #4]
 8105774:	4313      	orrs	r3, r2
 8105776:	600b      	str	r3, [r1, #0]
#endif
}
 8105778:	bf00      	nop
 810577a:	370c      	adds	r7, #12
 810577c:	46bd      	mov	sp, r7
 810577e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8105782:	4770      	bx	lr
 8105784:	58026510 	.word	0x58026510

08105788 <HAL_PCD_Init>:
  *         parameters in the PCD_InitTypeDef and initialize the associated handle.
  * @param  hpcd PCD handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_Init(PCD_HandleTypeDef *hpcd)
{
 8105788:	b580      	push	{r7, lr}
 810578a:	b086      	sub	sp, #24
 810578c:	af02      	add	r7, sp, #8
 810578e:	6078      	str	r0, [r7, #4]
  uint8_t i;

  /* Check the PCD handle allocation */
  if (hpcd == NULL)
 8105790:	687b      	ldr	r3, [r7, #4]
 8105792:	2b00      	cmp	r3, #0
 8105794:	d101      	bne.n	810579a <HAL_PCD_Init+0x12>
  {
    return HAL_ERROR;
 8105796:	2301      	movs	r3, #1
 8105798:	e0fe      	b.n	8105998 <HAL_PCD_Init+0x210>
  }

  /* Check the parameters */
  assert_param(IS_PCD_ALL_INSTANCE(hpcd->Instance));

  if (hpcd->State == HAL_PCD_STATE_RESET)
 810579a:	687b      	ldr	r3, [r7, #4]
 810579c:	f893 3495 	ldrb.w	r3, [r3, #1173]	; 0x495
 81057a0:	b2db      	uxtb	r3, r3
 81057a2:	2b00      	cmp	r3, #0
 81057a4:	d106      	bne.n	81057b4 <HAL_PCD_Init+0x2c>
  {
    /* Allocate lock resource and initialize it */
    hpcd->Lock = HAL_UNLOCKED;
 81057a6:	687b      	ldr	r3, [r7, #4]
 81057a8:	2200      	movs	r2, #0
 81057aa:	f883 2494 	strb.w	r2, [r3, #1172]	; 0x494

    /* Init the low level hardware */
    hpcd->MspInitCallback(hpcd);
#else
    /* Init the low level hardware : GPIO, CLOCK, NVIC... */
    HAL_PCD_MspInit(hpcd);
 81057ae:	6878      	ldr	r0, [r7, #4]
 81057b0:	f015 fbfe 	bl	811afb0 <HAL_PCD_MspInit>
#endif /* (USE_HAL_PCD_REGISTER_CALLBACKS) */
  }

  hpcd->State = HAL_PCD_STATE_BUSY;
 81057b4:	687b      	ldr	r3, [r7, #4]
 81057b6:	2203      	movs	r2, #3
 81057b8:	f883 2495 	strb.w	r2, [r3, #1173]	; 0x495

  /* Disable the Interrupts */
  __HAL_PCD_DISABLE(hpcd);
 81057bc:	687b      	ldr	r3, [r7, #4]
 81057be:	681b      	ldr	r3, [r3, #0]
 81057c0:	4618      	mov	r0, r3
 81057c2:	f005 fb68 	bl	810ae96 <USB_DisableGlobalInt>

  /*Init the Core (common init.) */
  if (USB_CoreInit(hpcd->Instance, hpcd->Init) != HAL_OK)
 81057c6:	687b      	ldr	r3, [r7, #4]
 81057c8:	6818      	ldr	r0, [r3, #0]
 81057ca:	687b      	ldr	r3, [r7, #4]
 81057cc:	7c1a      	ldrb	r2, [r3, #16]
 81057ce:	f88d 2000 	strb.w	r2, [sp]
 81057d2:	3304      	adds	r3, #4
 81057d4:	cb0e      	ldmia	r3, {r1, r2, r3}
 81057d6:	f005 fa3a 	bl	810ac4e <USB_CoreInit>
 81057da:	4603      	mov	r3, r0
 81057dc:	2b00      	cmp	r3, #0
 81057de:	d005      	beq.n	81057ec <HAL_PCD_Init+0x64>
  {
    hpcd->State = HAL_PCD_STATE_ERROR;
 81057e0:	687b      	ldr	r3, [r7, #4]
 81057e2:	2202      	movs	r2, #2
 81057e4:	f883 2495 	strb.w	r2, [r3, #1173]	; 0x495
    return HAL_ERROR;
 81057e8:	2301      	movs	r3, #1
 81057ea:	e0d5      	b.n	8105998 <HAL_PCD_Init+0x210>
  }

  /* Force Device Mode */
  if (USB_SetCurrentMode(hpcd->Instance, USB_DEVICE_MODE) != HAL_OK)
 81057ec:	687b      	ldr	r3, [r7, #4]
 81057ee:	681b      	ldr	r3, [r3, #0]
 81057f0:	2100      	movs	r1, #0
 81057f2:	4618      	mov	r0, r3
 81057f4:	f005 fb60 	bl	810aeb8 <USB_SetCurrentMode>
 81057f8:	4603      	mov	r3, r0
 81057fa:	2b00      	cmp	r3, #0
 81057fc:	d005      	beq.n	810580a <HAL_PCD_Init+0x82>
  {
    hpcd->State = HAL_PCD_STATE_ERROR;
 81057fe:	687b      	ldr	r3, [r7, #4]
 8105800:	2202      	movs	r2, #2
 8105802:	f883 2495 	strb.w	r2, [r3, #1173]	; 0x495
    return HAL_ERROR;
 8105806:	2301      	movs	r3, #1
 8105808:	e0c6      	b.n	8105998 <HAL_PCD_Init+0x210>
  }

  /* Init endpoints structures */
  for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 810580a:	2300      	movs	r3, #0
 810580c:	73fb      	strb	r3, [r7, #15]
 810580e:	e04a      	b.n	81058a6 <HAL_PCD_Init+0x11e>
  {
    /* Init ep structure */
    hpcd->IN_ep[i].is_in = 1U;
 8105810:	7bfa      	ldrb	r2, [r7, #15]
 8105812:	6879      	ldr	r1, [r7, #4]
 8105814:	4613      	mov	r3, r2
 8105816:	00db      	lsls	r3, r3, #3
 8105818:	4413      	add	r3, r2
 810581a:	009b      	lsls	r3, r3, #2
 810581c:	440b      	add	r3, r1
 810581e:	3315      	adds	r3, #21
 8105820:	2201      	movs	r2, #1
 8105822:	701a      	strb	r2, [r3, #0]
    hpcd->IN_ep[i].num = i;
 8105824:	7bfa      	ldrb	r2, [r7, #15]
 8105826:	6879      	ldr	r1, [r7, #4]
 8105828:	4613      	mov	r3, r2
 810582a:	00db      	lsls	r3, r3, #3
 810582c:	4413      	add	r3, r2
 810582e:	009b      	lsls	r3, r3, #2
 8105830:	440b      	add	r3, r1
 8105832:	3314      	adds	r3, #20
 8105834:	7bfa      	ldrb	r2, [r7, #15]
 8105836:	701a      	strb	r2, [r3, #0]
    hpcd->IN_ep[i].tx_fifo_num = i;
 8105838:	7bfa      	ldrb	r2, [r7, #15]
 810583a:	7bfb      	ldrb	r3, [r7, #15]
 810583c:	b298      	uxth	r0, r3
 810583e:	6879      	ldr	r1, [r7, #4]
 8105840:	4613      	mov	r3, r2
 8105842:	00db      	lsls	r3, r3, #3
 8105844:	4413      	add	r3, r2
 8105846:	009b      	lsls	r3, r3, #2
 8105848:	440b      	add	r3, r1
 810584a:	332e      	adds	r3, #46	; 0x2e
 810584c:	4602      	mov	r2, r0
 810584e:	801a      	strh	r2, [r3, #0]
    /* Control until ep is activated */
    hpcd->IN_ep[i].type = EP_TYPE_CTRL;
 8105850:	7bfa      	ldrb	r2, [r7, #15]
 8105852:	6879      	ldr	r1, [r7, #4]
 8105854:	4613      	mov	r3, r2
 8105856:	00db      	lsls	r3, r3, #3
 8105858:	4413      	add	r3, r2
 810585a:	009b      	lsls	r3, r3, #2
 810585c:	440b      	add	r3, r1
 810585e:	3318      	adds	r3, #24
 8105860:	2200      	movs	r2, #0
 8105862:	701a      	strb	r2, [r3, #0]
    hpcd->IN_ep[i].maxpacket = 0U;
 8105864:	7bfa      	ldrb	r2, [r7, #15]
 8105866:	6879      	ldr	r1, [r7, #4]
 8105868:	4613      	mov	r3, r2
 810586a:	00db      	lsls	r3, r3, #3
 810586c:	4413      	add	r3, r2
 810586e:	009b      	lsls	r3, r3, #2
 8105870:	440b      	add	r3, r1
 8105872:	331c      	adds	r3, #28
 8105874:	2200      	movs	r2, #0
 8105876:	601a      	str	r2, [r3, #0]
    hpcd->IN_ep[i].xfer_buff = 0U;
 8105878:	7bfa      	ldrb	r2, [r7, #15]
 810587a:	6879      	ldr	r1, [r7, #4]
 810587c:	4613      	mov	r3, r2
 810587e:	00db      	lsls	r3, r3, #3
 8105880:	4413      	add	r3, r2
 8105882:	009b      	lsls	r3, r3, #2
 8105884:	440b      	add	r3, r1
 8105886:	3320      	adds	r3, #32
 8105888:	2200      	movs	r2, #0
 810588a:	601a      	str	r2, [r3, #0]
    hpcd->IN_ep[i].xfer_len = 0U;
 810588c:	7bfa      	ldrb	r2, [r7, #15]
 810588e:	6879      	ldr	r1, [r7, #4]
 8105890:	4613      	mov	r3, r2
 8105892:	00db      	lsls	r3, r3, #3
 8105894:	4413      	add	r3, r2
 8105896:	009b      	lsls	r3, r3, #2
 8105898:	440b      	add	r3, r1
 810589a:	3324      	adds	r3, #36	; 0x24
 810589c:	2200      	movs	r2, #0
 810589e:	601a      	str	r2, [r3, #0]
  for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 81058a0:	7bfb      	ldrb	r3, [r7, #15]
 81058a2:	3301      	adds	r3, #1
 81058a4:	73fb      	strb	r3, [r7, #15]
 81058a6:	687b      	ldr	r3, [r7, #4]
 81058a8:	791b      	ldrb	r3, [r3, #4]
 81058aa:	7bfa      	ldrb	r2, [r7, #15]
 81058ac:	429a      	cmp	r2, r3
 81058ae:	d3af      	bcc.n	8105810 <HAL_PCD_Init+0x88>
  }

  for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 81058b0:	2300      	movs	r3, #0
 81058b2:	73fb      	strb	r3, [r7, #15]
 81058b4:	e044      	b.n	8105940 <HAL_PCD_Init+0x1b8>
  {
    hpcd->OUT_ep[i].is_in = 0U;
 81058b6:	7bfa      	ldrb	r2, [r7, #15]
 81058b8:	6879      	ldr	r1, [r7, #4]
 81058ba:	4613      	mov	r3, r2
 81058bc:	00db      	lsls	r3, r3, #3
 81058be:	4413      	add	r3, r2
 81058c0:	009b      	lsls	r3, r3, #2
 81058c2:	440b      	add	r3, r1
 81058c4:	f203 2355 	addw	r3, r3, #597	; 0x255
 81058c8:	2200      	movs	r2, #0
 81058ca:	701a      	strb	r2, [r3, #0]
    hpcd->OUT_ep[i].num = i;
 81058cc:	7bfa      	ldrb	r2, [r7, #15]
 81058ce:	6879      	ldr	r1, [r7, #4]
 81058d0:	4613      	mov	r3, r2
 81058d2:	00db      	lsls	r3, r3, #3
 81058d4:	4413      	add	r3, r2
 81058d6:	009b      	lsls	r3, r3, #2
 81058d8:	440b      	add	r3, r1
 81058da:	f503 7315 	add.w	r3, r3, #596	; 0x254
 81058de:	7bfa      	ldrb	r2, [r7, #15]
 81058e0:	701a      	strb	r2, [r3, #0]
    /* Control until ep is activated */
    hpcd->OUT_ep[i].type = EP_TYPE_CTRL;
 81058e2:	7bfa      	ldrb	r2, [r7, #15]
 81058e4:	6879      	ldr	r1, [r7, #4]
 81058e6:	4613      	mov	r3, r2
 81058e8:	00db      	lsls	r3, r3, #3
 81058ea:	4413      	add	r3, r2
 81058ec:	009b      	lsls	r3, r3, #2
 81058ee:	440b      	add	r3, r1
 81058f0:	f503 7316 	add.w	r3, r3, #600	; 0x258
 81058f4:	2200      	movs	r2, #0
 81058f6:	701a      	strb	r2, [r3, #0]
    hpcd->OUT_ep[i].maxpacket = 0U;
 81058f8:	7bfa      	ldrb	r2, [r7, #15]
 81058fa:	6879      	ldr	r1, [r7, #4]
 81058fc:	4613      	mov	r3, r2
 81058fe:	00db      	lsls	r3, r3, #3
 8105900:	4413      	add	r3, r2
 8105902:	009b      	lsls	r3, r3, #2
 8105904:	440b      	add	r3, r1
 8105906:	f503 7317 	add.w	r3, r3, #604	; 0x25c
 810590a:	2200      	movs	r2, #0
 810590c:	601a      	str	r2, [r3, #0]
    hpcd->OUT_ep[i].xfer_buff = 0U;
 810590e:	7bfa      	ldrb	r2, [r7, #15]
 8105910:	6879      	ldr	r1, [r7, #4]
 8105912:	4613      	mov	r3, r2
 8105914:	00db      	lsls	r3, r3, #3
 8105916:	4413      	add	r3, r2
 8105918:	009b      	lsls	r3, r3, #2
 810591a:	440b      	add	r3, r1
 810591c:	f503 7318 	add.w	r3, r3, #608	; 0x260
 8105920:	2200      	movs	r2, #0
 8105922:	601a      	str	r2, [r3, #0]
    hpcd->OUT_ep[i].xfer_len = 0U;
 8105924:	7bfa      	ldrb	r2, [r7, #15]
 8105926:	6879      	ldr	r1, [r7, #4]
 8105928:	4613      	mov	r3, r2
 810592a:	00db      	lsls	r3, r3, #3
 810592c:	4413      	add	r3, r2
 810592e:	009b      	lsls	r3, r3, #2
 8105930:	440b      	add	r3, r1
 8105932:	f503 7319 	add.w	r3, r3, #612	; 0x264
 8105936:	2200      	movs	r2, #0
 8105938:	601a      	str	r2, [r3, #0]
  for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 810593a:	7bfb      	ldrb	r3, [r7, #15]
 810593c:	3301      	adds	r3, #1
 810593e:	73fb      	strb	r3, [r7, #15]
 8105940:	687b      	ldr	r3, [r7, #4]
 8105942:	791b      	ldrb	r3, [r3, #4]
 8105944:	7bfa      	ldrb	r2, [r7, #15]
 8105946:	429a      	cmp	r2, r3
 8105948:	d3b5      	bcc.n	81058b6 <HAL_PCD_Init+0x12e>
  }

  /* Init Device */
  if (USB_DevInit(hpcd->Instance, hpcd->Init) != HAL_OK)
 810594a:	687b      	ldr	r3, [r7, #4]
 810594c:	6818      	ldr	r0, [r3, #0]
 810594e:	687b      	ldr	r3, [r7, #4]
 8105950:	7c1a      	ldrb	r2, [r3, #16]
 8105952:	f88d 2000 	strb.w	r2, [sp]
 8105956:	3304      	adds	r3, #4
 8105958:	cb0e      	ldmia	r3, {r1, r2, r3}
 810595a:	f005 faf9 	bl	810af50 <USB_DevInit>
 810595e:	4603      	mov	r3, r0
 8105960:	2b00      	cmp	r3, #0
 8105962:	d005      	beq.n	8105970 <HAL_PCD_Init+0x1e8>
  {
    hpcd->State = HAL_PCD_STATE_ERROR;
 8105964:	687b      	ldr	r3, [r7, #4]
 8105966:	2202      	movs	r2, #2
 8105968:	f883 2495 	strb.w	r2, [r3, #1173]	; 0x495
    return HAL_ERROR;
 810596c:	2301      	movs	r3, #1
 810596e:	e013      	b.n	8105998 <HAL_PCD_Init+0x210>
  }

  hpcd->USB_Address = 0U;
 8105970:	687b      	ldr	r3, [r7, #4]
 8105972:	2200      	movs	r2, #0
 8105974:	745a      	strb	r2, [r3, #17]
  hpcd->State = HAL_PCD_STATE_READY;
 8105976:	687b      	ldr	r3, [r7, #4]
 8105978:	2201      	movs	r2, #1
 810597a:	f883 2495 	strb.w	r2, [r3, #1173]	; 0x495

  /* Activate LPM */
  if (hpcd->Init.lpm_enable == 1U)
 810597e:	687b      	ldr	r3, [r7, #4]
 8105980:	7b1b      	ldrb	r3, [r3, #12]
 8105982:	2b01      	cmp	r3, #1
 8105984:	d102      	bne.n	810598c <HAL_PCD_Init+0x204>
  {
    (void)HAL_PCDEx_ActivateLPM(hpcd);
 8105986:	6878      	ldr	r0, [r7, #4]
 8105988:	f001 f954 	bl	8106c34 <HAL_PCDEx_ActivateLPM>
  }

  (void)USB_DevDisconnect(hpcd->Instance);
 810598c:	687b      	ldr	r3, [r7, #4]
 810598e:	681b      	ldr	r3, [r3, #0]
 8105990:	4618      	mov	r0, r3
 8105992:	f006 fb30 	bl	810bff6 <USB_DevDisconnect>

  return HAL_OK;
 8105996:	2300      	movs	r3, #0
}
 8105998:	4618      	mov	r0, r3
 810599a:	3710      	adds	r7, #16
 810599c:	46bd      	mov	sp, r7
 810599e:	bd80      	pop	{r7, pc}

081059a0 <HAL_PCD_Start>:
  * @brief  Start the USB device
  * @param  hpcd PCD handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_Start(PCD_HandleTypeDef *hpcd)
{
 81059a0:	b580      	push	{r7, lr}
 81059a2:	b084      	sub	sp, #16
 81059a4:	af00      	add	r7, sp, #0
 81059a6:	6078      	str	r0, [r7, #4]
  USB_OTG_GlobalTypeDef *USBx = hpcd->Instance;
 81059a8:	687b      	ldr	r3, [r7, #4]
 81059aa:	681b      	ldr	r3, [r3, #0]
 81059ac:	60fb      	str	r3, [r7, #12]

  __HAL_LOCK(hpcd);
 81059ae:	687b      	ldr	r3, [r7, #4]
 81059b0:	f893 3494 	ldrb.w	r3, [r3, #1172]	; 0x494
 81059b4:	2b01      	cmp	r3, #1
 81059b6:	d101      	bne.n	81059bc <HAL_PCD_Start+0x1c>
 81059b8:	2302      	movs	r3, #2
 81059ba:	e022      	b.n	8105a02 <HAL_PCD_Start+0x62>
 81059bc:	687b      	ldr	r3, [r7, #4]
 81059be:	2201      	movs	r2, #1
 81059c0:	f883 2494 	strb.w	r2, [r3, #1172]	; 0x494

  if (((USBx->GUSBCFG & USB_OTG_GUSBCFG_PHYSEL) != 0U) &&
 81059c4:	68fb      	ldr	r3, [r7, #12]
 81059c6:	68db      	ldr	r3, [r3, #12]
 81059c8:	f003 0340 	and.w	r3, r3, #64	; 0x40
 81059cc:	2b00      	cmp	r3, #0
 81059ce:	d009      	beq.n	81059e4 <HAL_PCD_Start+0x44>
      (hpcd->Init.battery_charging_enable == 1U))
 81059d0:	687b      	ldr	r3, [r7, #4]
 81059d2:	7b5b      	ldrb	r3, [r3, #13]
  if (((USBx->GUSBCFG & USB_OTG_GUSBCFG_PHYSEL) != 0U) &&
 81059d4:	2b01      	cmp	r3, #1
 81059d6:	d105      	bne.n	81059e4 <HAL_PCD_Start+0x44>
  {
    /* Enable USB Transceiver */
    USBx->GCCFG |= USB_OTG_GCCFG_PWRDWN;
 81059d8:	68fb      	ldr	r3, [r7, #12]
 81059da:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 81059dc:	f443 3280 	orr.w	r2, r3, #65536	; 0x10000
 81059e0:	68fb      	ldr	r3, [r7, #12]
 81059e2:	639a      	str	r2, [r3, #56]	; 0x38
  }

  __HAL_PCD_ENABLE(hpcd);
 81059e4:	687b      	ldr	r3, [r7, #4]
 81059e6:	681b      	ldr	r3, [r3, #0]
 81059e8:	4618      	mov	r0, r3
 81059ea:	f005 fa43 	bl	810ae74 <USB_EnableGlobalInt>
  (void)USB_DevConnect(hpcd->Instance);
 81059ee:	687b      	ldr	r3, [r7, #4]
 81059f0:	681b      	ldr	r3, [r3, #0]
 81059f2:	4618      	mov	r0, r3
 81059f4:	f006 fade 	bl	810bfb4 <USB_DevConnect>
  __HAL_UNLOCK(hpcd);
 81059f8:	687b      	ldr	r3, [r7, #4]
 81059fa:	2200      	movs	r2, #0
 81059fc:	f883 2494 	strb.w	r2, [r3, #1172]	; 0x494

  return HAL_OK;
 8105a00:	2300      	movs	r3, #0
}
 8105a02:	4618      	mov	r0, r3
 8105a04:	3710      	adds	r7, #16
 8105a06:	46bd      	mov	sp, r7
 8105a08:	bd80      	pop	{r7, pc}

08105a0a <HAL_PCD_IRQHandler>:
  * @brief  Handles PCD interrupt request.
  * @param  hpcd PCD handle
  * @retval HAL status
  */
void HAL_PCD_IRQHandler(PCD_HandleTypeDef *hpcd)
{
 8105a0a:	b590      	push	{r4, r7, lr}
 8105a0c:	b08d      	sub	sp, #52	; 0x34
 8105a0e:	af00      	add	r7, sp, #0
 8105a10:	6078      	str	r0, [r7, #4]
  USB_OTG_GlobalTypeDef *USBx = hpcd->Instance;
 8105a12:	687b      	ldr	r3, [r7, #4]
 8105a14:	681b      	ldr	r3, [r3, #0]
 8105a16:	623b      	str	r3, [r7, #32]
  uint32_t USBx_BASE = (uint32_t)USBx;
 8105a18:	6a3b      	ldr	r3, [r7, #32]
 8105a1a:	61fb      	str	r3, [r7, #28]
  uint32_t epnum;
  uint32_t fifoemptymsk;
  uint32_t RegVal;

  /* ensure that we are in device mode */
  if (USB_GetMode(hpcd->Instance) == USB_OTG_MODE_DEVICE)
 8105a1c:	687b      	ldr	r3, [r7, #4]
 8105a1e:	681b      	ldr	r3, [r3, #0]
 8105a20:	4618      	mov	r0, r3
 8105a22:	f006 fb9c 	bl	810c15e <USB_GetMode>
 8105a26:	4603      	mov	r3, r0
 8105a28:	2b00      	cmp	r3, #0
 8105a2a:	f040 84b9 	bne.w	81063a0 <HAL_PCD_IRQHandler+0x996>
  {
    /* avoid spurious interrupt */
    if (__HAL_PCD_IS_INVALID_INTERRUPT(hpcd))
 8105a2e:	687b      	ldr	r3, [r7, #4]
 8105a30:	681b      	ldr	r3, [r3, #0]
 8105a32:	4618      	mov	r0, r3
 8105a34:	f006 fb00 	bl	810c038 <USB_ReadInterrupts>
 8105a38:	4603      	mov	r3, r0
 8105a3a:	2b00      	cmp	r3, #0
 8105a3c:	f000 84af 	beq.w	810639e <HAL_PCD_IRQHandler+0x994>
    {
      return;
    }

    /* store current frame number */
    hpcd->FrameNumber = (USBx_DEVICE->DSTS & USB_OTG_DSTS_FNSOF_Msk) >> USB_OTG_DSTS_FNSOF_Pos;
 8105a40:	69fb      	ldr	r3, [r7, #28]
 8105a42:	f503 6300 	add.w	r3, r3, #2048	; 0x800
 8105a46:	689b      	ldr	r3, [r3, #8]
 8105a48:	0a1b      	lsrs	r3, r3, #8
 8105a4a:	f3c3 020d 	ubfx	r2, r3, #0, #14
 8105a4e:	687b      	ldr	r3, [r7, #4]
 8105a50:	f8c3 24d4 	str.w	r2, [r3, #1236]	; 0x4d4

    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_MMIS))
 8105a54:	687b      	ldr	r3, [r7, #4]
 8105a56:	681b      	ldr	r3, [r3, #0]
 8105a58:	4618      	mov	r0, r3
 8105a5a:	f006 faed 	bl	810c038 <USB_ReadInterrupts>
 8105a5e:	4603      	mov	r3, r0
 8105a60:	f003 0302 	and.w	r3, r3, #2
 8105a64:	2b02      	cmp	r3, #2
 8105a66:	d107      	bne.n	8105a78 <HAL_PCD_IRQHandler+0x6e>
    {
      /* incorrect mode, acknowledge the interrupt */
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_MMIS);
 8105a68:	687b      	ldr	r3, [r7, #4]
 8105a6a:	681b      	ldr	r3, [r3, #0]
 8105a6c:	695a      	ldr	r2, [r3, #20]
 8105a6e:	687b      	ldr	r3, [r7, #4]
 8105a70:	681b      	ldr	r3, [r3, #0]
 8105a72:	f002 0202 	and.w	r2, r2, #2
 8105a76:	615a      	str	r2, [r3, #20]
    }

    /* Handle RxQLevel Interrupt */
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_RXFLVL))
 8105a78:	687b      	ldr	r3, [r7, #4]
 8105a7a:	681b      	ldr	r3, [r3, #0]
 8105a7c:	4618      	mov	r0, r3
 8105a7e:	f006 fadb 	bl	810c038 <USB_ReadInterrupts>
 8105a82:	4603      	mov	r3, r0
 8105a84:	f003 0310 	and.w	r3, r3, #16
 8105a88:	2b10      	cmp	r3, #16
 8105a8a:	d161      	bne.n	8105b50 <HAL_PCD_IRQHandler+0x146>
    {
      USB_MASK_INTERRUPT(hpcd->Instance, USB_OTG_GINTSTS_RXFLVL);
 8105a8c:	687b      	ldr	r3, [r7, #4]
 8105a8e:	681b      	ldr	r3, [r3, #0]
 8105a90:	699a      	ldr	r2, [r3, #24]
 8105a92:	687b      	ldr	r3, [r7, #4]
 8105a94:	681b      	ldr	r3, [r3, #0]
 8105a96:	f022 0210 	bic.w	r2, r2, #16
 8105a9a:	619a      	str	r2, [r3, #24]

      RegVal = USBx->GRXSTSP;
 8105a9c:	6a3b      	ldr	r3, [r7, #32]
 8105a9e:	6a1b      	ldr	r3, [r3, #32]
 8105aa0:	61bb      	str	r3, [r7, #24]

      ep = &hpcd->OUT_ep[RegVal & USB_OTG_GRXSTSP_EPNUM];
 8105aa2:	69bb      	ldr	r3, [r7, #24]
 8105aa4:	f003 020f 	and.w	r2, r3, #15
 8105aa8:	4613      	mov	r3, r2
 8105aaa:	00db      	lsls	r3, r3, #3
 8105aac:	4413      	add	r3, r2
 8105aae:	009b      	lsls	r3, r3, #2
 8105ab0:	f503 7314 	add.w	r3, r3, #592	; 0x250
 8105ab4:	687a      	ldr	r2, [r7, #4]
 8105ab6:	4413      	add	r3, r2
 8105ab8:	3304      	adds	r3, #4
 8105aba:	617b      	str	r3, [r7, #20]

      if (((RegVal & USB_OTG_GRXSTSP_PKTSTS) >> 17) ==  STS_DATA_UPDT)
 8105abc:	69bb      	ldr	r3, [r7, #24]
 8105abe:	0c5b      	lsrs	r3, r3, #17
 8105ac0:	f003 030f 	and.w	r3, r3, #15
 8105ac4:	2b02      	cmp	r3, #2
 8105ac6:	d124      	bne.n	8105b12 <HAL_PCD_IRQHandler+0x108>
      {
        if ((RegVal & USB_OTG_GRXSTSP_BCNT) != 0U)
 8105ac8:	69ba      	ldr	r2, [r7, #24]
 8105aca:	f647 73f0 	movw	r3, #32752	; 0x7ff0
 8105ace:	4013      	ands	r3, r2
 8105ad0:	2b00      	cmp	r3, #0
 8105ad2:	d035      	beq.n	8105b40 <HAL_PCD_IRQHandler+0x136>
        {
          (void)USB_ReadPacket(USBx, ep->xfer_buff,
 8105ad4:	697b      	ldr	r3, [r7, #20]
 8105ad6:	68d9      	ldr	r1, [r3, #12]
                               (uint16_t)((RegVal & USB_OTG_GRXSTSP_BCNT) >> 4));
 8105ad8:	69bb      	ldr	r3, [r7, #24]
 8105ada:	091b      	lsrs	r3, r3, #4
 8105adc:	b29b      	uxth	r3, r3
          (void)USB_ReadPacket(USBx, ep->xfer_buff,
 8105ade:	f3c3 030a 	ubfx	r3, r3, #0, #11
 8105ae2:	b29b      	uxth	r3, r3
 8105ae4:	461a      	mov	r2, r3
 8105ae6:	6a38      	ldr	r0, [r7, #32]
 8105ae8:	f006 f912 	bl	810bd10 <USB_ReadPacket>

          ep->xfer_buff += (RegVal & USB_OTG_GRXSTSP_BCNT) >> 4;
 8105aec:	697b      	ldr	r3, [r7, #20]
 8105aee:	68da      	ldr	r2, [r3, #12]
 8105af0:	69bb      	ldr	r3, [r7, #24]
 8105af2:	091b      	lsrs	r3, r3, #4
 8105af4:	f3c3 030a 	ubfx	r3, r3, #0, #11
 8105af8:	441a      	add	r2, r3
 8105afa:	697b      	ldr	r3, [r7, #20]
 8105afc:	60da      	str	r2, [r3, #12]
          ep->xfer_count += (RegVal & USB_OTG_GRXSTSP_BCNT) >> 4;
 8105afe:	697b      	ldr	r3, [r7, #20]
 8105b00:	695a      	ldr	r2, [r3, #20]
 8105b02:	69bb      	ldr	r3, [r7, #24]
 8105b04:	091b      	lsrs	r3, r3, #4
 8105b06:	f3c3 030a 	ubfx	r3, r3, #0, #11
 8105b0a:	441a      	add	r2, r3
 8105b0c:	697b      	ldr	r3, [r7, #20]
 8105b0e:	615a      	str	r2, [r3, #20]
 8105b10:	e016      	b.n	8105b40 <HAL_PCD_IRQHandler+0x136>
        }
      }
      else if (((RegVal & USB_OTG_GRXSTSP_PKTSTS) >> 17) == STS_SETUP_UPDT)
 8105b12:	69bb      	ldr	r3, [r7, #24]
 8105b14:	0c5b      	lsrs	r3, r3, #17
 8105b16:	f003 030f 	and.w	r3, r3, #15
 8105b1a:	2b06      	cmp	r3, #6
 8105b1c:	d110      	bne.n	8105b40 <HAL_PCD_IRQHandler+0x136>
      {
        (void)USB_ReadPacket(USBx, (uint8_t *)hpcd->Setup, 8U);
 8105b1e:	687b      	ldr	r3, [r7, #4]
 8105b20:	f203 439c 	addw	r3, r3, #1180	; 0x49c
 8105b24:	2208      	movs	r2, #8
 8105b26:	4619      	mov	r1, r3
 8105b28:	6a38      	ldr	r0, [r7, #32]
 8105b2a:	f006 f8f1 	bl	810bd10 <USB_ReadPacket>
        ep->xfer_count += (RegVal & USB_OTG_GRXSTSP_BCNT) >> 4;
 8105b2e:	697b      	ldr	r3, [r7, #20]
 8105b30:	695a      	ldr	r2, [r3, #20]
 8105b32:	69bb      	ldr	r3, [r7, #24]
 8105b34:	091b      	lsrs	r3, r3, #4
 8105b36:	f3c3 030a 	ubfx	r3, r3, #0, #11
 8105b3a:	441a      	add	r2, r3
 8105b3c:	697b      	ldr	r3, [r7, #20]
 8105b3e:	615a      	str	r2, [r3, #20]
      else
      {
        /* ... */
      }

      USB_UNMASK_INTERRUPT(hpcd->Instance, USB_OTG_GINTSTS_RXFLVL);
 8105b40:	687b      	ldr	r3, [r7, #4]
 8105b42:	681b      	ldr	r3, [r3, #0]
 8105b44:	699a      	ldr	r2, [r3, #24]
 8105b46:	687b      	ldr	r3, [r7, #4]
 8105b48:	681b      	ldr	r3, [r3, #0]
 8105b4a:	f042 0210 	orr.w	r2, r2, #16
 8105b4e:	619a      	str	r2, [r3, #24]
    }

    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_OEPINT))
 8105b50:	687b      	ldr	r3, [r7, #4]
 8105b52:	681b      	ldr	r3, [r3, #0]
 8105b54:	4618      	mov	r0, r3
 8105b56:	f006 fa6f 	bl	810c038 <USB_ReadInterrupts>
 8105b5a:	4603      	mov	r3, r0
 8105b5c:	f403 2300 	and.w	r3, r3, #524288	; 0x80000
 8105b60:	f5b3 2f00 	cmp.w	r3, #524288	; 0x80000
 8105b64:	f040 80a7 	bne.w	8105cb6 <HAL_PCD_IRQHandler+0x2ac>
    {
      epnum = 0U;
 8105b68:	2300      	movs	r3, #0
 8105b6a:	627b      	str	r3, [r7, #36]	; 0x24

      /* Read in the device interrupt bits */
      ep_intr = USB_ReadDevAllOutEpInterrupt(hpcd->Instance);
 8105b6c:	687b      	ldr	r3, [r7, #4]
 8105b6e:	681b      	ldr	r3, [r3, #0]
 8105b70:	4618      	mov	r0, r3
 8105b72:	f006 fa74 	bl	810c05e <USB_ReadDevAllOutEpInterrupt>
 8105b76:	62b8      	str	r0, [r7, #40]	; 0x28

      while (ep_intr != 0U)
 8105b78:	e099      	b.n	8105cae <HAL_PCD_IRQHandler+0x2a4>
      {
        if ((ep_intr & 0x1U) != 0U)
 8105b7a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8105b7c:	f003 0301 	and.w	r3, r3, #1
 8105b80:	2b00      	cmp	r3, #0
 8105b82:	f000 808e 	beq.w	8105ca2 <HAL_PCD_IRQHandler+0x298>
        {
          epint = USB_ReadDevOutEPInterrupt(hpcd->Instance, (uint8_t)epnum);
 8105b86:	687b      	ldr	r3, [r7, #4]
 8105b88:	681b      	ldr	r3, [r3, #0]
 8105b8a:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8105b8c:	b2d2      	uxtb	r2, r2
 8105b8e:	4611      	mov	r1, r2
 8105b90:	4618      	mov	r0, r3
 8105b92:	f006 fa98 	bl	810c0c6 <USB_ReadDevOutEPInterrupt>
 8105b96:	6138      	str	r0, [r7, #16]

          if ((epint & USB_OTG_DOEPINT_XFRC) == USB_OTG_DOEPINT_XFRC)
 8105b98:	693b      	ldr	r3, [r7, #16]
 8105b9a:	f003 0301 	and.w	r3, r3, #1
 8105b9e:	2b00      	cmp	r3, #0
 8105ba0:	d00c      	beq.n	8105bbc <HAL_PCD_IRQHandler+0x1b2>
          {
            CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_XFRC);
 8105ba2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8105ba4:	015a      	lsls	r2, r3, #5
 8105ba6:	69fb      	ldr	r3, [r7, #28]
 8105ba8:	4413      	add	r3, r2
 8105baa:	f503 6330 	add.w	r3, r3, #2816	; 0xb00
 8105bae:	461a      	mov	r2, r3
 8105bb0:	2301      	movs	r3, #1
 8105bb2:	6093      	str	r3, [r2, #8]
            (void)PCD_EP_OutXfrComplete_int(hpcd, epnum);
 8105bb4:	6a79      	ldr	r1, [r7, #36]	; 0x24
 8105bb6:	6878      	ldr	r0, [r7, #4]
 8105bb8:	f000 feb6 	bl	8106928 <PCD_EP_OutXfrComplete_int>
          }

          if ((epint & USB_OTG_DOEPINT_STUP) == USB_OTG_DOEPINT_STUP)
 8105bbc:	693b      	ldr	r3, [r7, #16]
 8105bbe:	f003 0308 	and.w	r3, r3, #8
 8105bc2:	2b00      	cmp	r3, #0
 8105bc4:	d00c      	beq.n	8105be0 <HAL_PCD_IRQHandler+0x1d6>
          {
            CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_STUP);
 8105bc6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8105bc8:	015a      	lsls	r2, r3, #5
 8105bca:	69fb      	ldr	r3, [r7, #28]
 8105bcc:	4413      	add	r3, r2
 8105bce:	f503 6330 	add.w	r3, r3, #2816	; 0xb00
 8105bd2:	461a      	mov	r2, r3
 8105bd4:	2308      	movs	r3, #8
 8105bd6:	6093      	str	r3, [r2, #8]
            /* Class B setup phase done for previous decoded setup */
            (void)PCD_EP_OutSetupPacket_int(hpcd, epnum);
 8105bd8:	6a79      	ldr	r1, [r7, #36]	; 0x24
 8105bda:	6878      	ldr	r0, [r7, #4]
 8105bdc:	f000 ff8c 	bl	8106af8 <PCD_EP_OutSetupPacket_int>
          }

          if ((epint & USB_OTG_DOEPINT_OTEPDIS) == USB_OTG_DOEPINT_OTEPDIS)
 8105be0:	693b      	ldr	r3, [r7, #16]
 8105be2:	f003 0310 	and.w	r3, r3, #16
 8105be6:	2b00      	cmp	r3, #0
 8105be8:	d008      	beq.n	8105bfc <HAL_PCD_IRQHandler+0x1f2>
          {
            CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_OTEPDIS);
 8105bea:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8105bec:	015a      	lsls	r2, r3, #5
 8105bee:	69fb      	ldr	r3, [r7, #28]
 8105bf0:	4413      	add	r3, r2
 8105bf2:	f503 6330 	add.w	r3, r3, #2816	; 0xb00
 8105bf6:	461a      	mov	r2, r3
 8105bf8:	2310      	movs	r3, #16
 8105bfa:	6093      	str	r3, [r2, #8]
          }

          /* Clear OUT Endpoint disable interrupt */
          if ((epint & USB_OTG_DOEPINT_EPDISD) == USB_OTG_DOEPINT_EPDISD)
 8105bfc:	693b      	ldr	r3, [r7, #16]
 8105bfe:	f003 0302 	and.w	r3, r3, #2
 8105c02:	2b00      	cmp	r3, #0
 8105c04:	d030      	beq.n	8105c68 <HAL_PCD_IRQHandler+0x25e>
          {
            if ((USBx->GINTSTS & USB_OTG_GINTSTS_BOUTNAKEFF) == USB_OTG_GINTSTS_BOUTNAKEFF)
 8105c06:	6a3b      	ldr	r3, [r7, #32]
 8105c08:	695b      	ldr	r3, [r3, #20]
 8105c0a:	f003 0380 	and.w	r3, r3, #128	; 0x80
 8105c0e:	2b80      	cmp	r3, #128	; 0x80
 8105c10:	d109      	bne.n	8105c26 <HAL_PCD_IRQHandler+0x21c>
            {
              USBx_DEVICE->DCTL |= USB_OTG_DCTL_CGONAK;
 8105c12:	69fb      	ldr	r3, [r7, #28]
 8105c14:	f503 6300 	add.w	r3, r3, #2048	; 0x800
 8105c18:	685b      	ldr	r3, [r3, #4]
 8105c1a:	69fa      	ldr	r2, [r7, #28]
 8105c1c:	f502 6200 	add.w	r2, r2, #2048	; 0x800
 8105c20:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
 8105c24:	6053      	str	r3, [r2, #4]
            }

            ep = &hpcd->OUT_ep[epnum];
 8105c26:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8105c28:	4613      	mov	r3, r2
 8105c2a:	00db      	lsls	r3, r3, #3
 8105c2c:	4413      	add	r3, r2
 8105c2e:	009b      	lsls	r3, r3, #2
 8105c30:	f503 7314 	add.w	r3, r3, #592	; 0x250
 8105c34:	687a      	ldr	r2, [r7, #4]
 8105c36:	4413      	add	r3, r2
 8105c38:	3304      	adds	r3, #4
 8105c3a:	617b      	str	r3, [r7, #20]

            if (ep->is_iso_incomplete == 1U)
 8105c3c:	697b      	ldr	r3, [r7, #20]
 8105c3e:	78db      	ldrb	r3, [r3, #3]
 8105c40:	2b01      	cmp	r3, #1
 8105c42:	d108      	bne.n	8105c56 <HAL_PCD_IRQHandler+0x24c>
            {
              ep->is_iso_incomplete = 0U;
 8105c44:	697b      	ldr	r3, [r7, #20]
 8105c46:	2200      	movs	r2, #0
 8105c48:	70da      	strb	r2, [r3, #3]

#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
              hpcd->ISOOUTIncompleteCallback(hpcd, (uint8_t)epnum);
#else
              HAL_PCD_ISOOUTIncompleteCallback(hpcd, (uint8_t)epnum);
 8105c4a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8105c4c:	b2db      	uxtb	r3, r3
 8105c4e:	4619      	mov	r1, r3
 8105c50:	6878      	ldr	r0, [r7, #4]
 8105c52:	f015 fae7 	bl	811b224 <HAL_PCD_ISOOUTIncompleteCallback>
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
            }

            CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_EPDISD);
 8105c56:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8105c58:	015a      	lsls	r2, r3, #5
 8105c5a:	69fb      	ldr	r3, [r7, #28]
 8105c5c:	4413      	add	r3, r2
 8105c5e:	f503 6330 	add.w	r3, r3, #2816	; 0xb00
 8105c62:	461a      	mov	r2, r3
 8105c64:	2302      	movs	r3, #2
 8105c66:	6093      	str	r3, [r2, #8]
          }

          /* Clear Status Phase Received interrupt */
          if ((epint & USB_OTG_DOEPINT_OTEPSPR) == USB_OTG_DOEPINT_OTEPSPR)
 8105c68:	693b      	ldr	r3, [r7, #16]
 8105c6a:	f003 0320 	and.w	r3, r3, #32
 8105c6e:	2b00      	cmp	r3, #0
 8105c70:	d008      	beq.n	8105c84 <HAL_PCD_IRQHandler+0x27a>
          {
            CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_OTEPSPR);
 8105c72:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8105c74:	015a      	lsls	r2, r3, #5
 8105c76:	69fb      	ldr	r3, [r7, #28]
 8105c78:	4413      	add	r3, r2
 8105c7a:	f503 6330 	add.w	r3, r3, #2816	; 0xb00
 8105c7e:	461a      	mov	r2, r3
 8105c80:	2320      	movs	r3, #32
 8105c82:	6093      	str	r3, [r2, #8]
          }

          /* Clear OUT NAK interrupt */
          if ((epint & USB_OTG_DOEPINT_NAK) == USB_OTG_DOEPINT_NAK)
 8105c84:	693b      	ldr	r3, [r7, #16]
 8105c86:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
 8105c8a:	2b00      	cmp	r3, #0
 8105c8c:	d009      	beq.n	8105ca2 <HAL_PCD_IRQHandler+0x298>
          {
            CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_NAK);
 8105c8e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8105c90:	015a      	lsls	r2, r3, #5
 8105c92:	69fb      	ldr	r3, [r7, #28]
 8105c94:	4413      	add	r3, r2
 8105c96:	f503 6330 	add.w	r3, r3, #2816	; 0xb00
 8105c9a:	461a      	mov	r2, r3
 8105c9c:	f44f 5300 	mov.w	r3, #8192	; 0x2000
 8105ca0:	6093      	str	r3, [r2, #8]
          }
        }
        epnum++;
 8105ca2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8105ca4:	3301      	adds	r3, #1
 8105ca6:	627b      	str	r3, [r7, #36]	; 0x24
        ep_intr >>= 1U;
 8105ca8:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8105caa:	085b      	lsrs	r3, r3, #1
 8105cac:	62bb      	str	r3, [r7, #40]	; 0x28
      while (ep_intr != 0U)
 8105cae:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8105cb0:	2b00      	cmp	r3, #0
 8105cb2:	f47f af62 	bne.w	8105b7a <HAL_PCD_IRQHandler+0x170>
      }
    }

    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_IEPINT))
 8105cb6:	687b      	ldr	r3, [r7, #4]
 8105cb8:	681b      	ldr	r3, [r3, #0]
 8105cba:	4618      	mov	r0, r3
 8105cbc:	f006 f9bc 	bl	810c038 <USB_ReadInterrupts>
 8105cc0:	4603      	mov	r3, r0
 8105cc2:	f403 2380 	and.w	r3, r3, #262144	; 0x40000
 8105cc6:	f5b3 2f80 	cmp.w	r3, #262144	; 0x40000
 8105cca:	f040 80db 	bne.w	8105e84 <HAL_PCD_IRQHandler+0x47a>
    {
      /* Read in the device interrupt bits */
      ep_intr = USB_ReadDevAllInEpInterrupt(hpcd->Instance);
 8105cce:	687b      	ldr	r3, [r7, #4]
 8105cd0:	681b      	ldr	r3, [r3, #0]
 8105cd2:	4618      	mov	r0, r3
 8105cd4:	f006 f9dd 	bl	810c092 <USB_ReadDevAllInEpInterrupt>
 8105cd8:	62b8      	str	r0, [r7, #40]	; 0x28

      epnum = 0U;
 8105cda:	2300      	movs	r3, #0
 8105cdc:	627b      	str	r3, [r7, #36]	; 0x24

      while (ep_intr != 0U)
 8105cde:	e0cd      	b.n	8105e7c <HAL_PCD_IRQHandler+0x472>
      {
        if ((ep_intr & 0x1U) != 0U) /* In ITR */
 8105ce0:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8105ce2:	f003 0301 	and.w	r3, r3, #1
 8105ce6:	2b00      	cmp	r3, #0
 8105ce8:	f000 80c2 	beq.w	8105e70 <HAL_PCD_IRQHandler+0x466>
        {
          epint = USB_ReadDevInEPInterrupt(hpcd->Instance, (uint8_t)epnum);
 8105cec:	687b      	ldr	r3, [r7, #4]
 8105cee:	681b      	ldr	r3, [r3, #0]
 8105cf0:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8105cf2:	b2d2      	uxtb	r2, r2
 8105cf4:	4611      	mov	r1, r2
 8105cf6:	4618      	mov	r0, r3
 8105cf8:	f006 fa03 	bl	810c102 <USB_ReadDevInEPInterrupt>
 8105cfc:	6138      	str	r0, [r7, #16]

          if ((epint & USB_OTG_DIEPINT_XFRC) == USB_OTG_DIEPINT_XFRC)
 8105cfe:	693b      	ldr	r3, [r7, #16]
 8105d00:	f003 0301 	and.w	r3, r3, #1
 8105d04:	2b00      	cmp	r3, #0
 8105d06:	d057      	beq.n	8105db8 <HAL_PCD_IRQHandler+0x3ae>
          {
            fifoemptymsk = (uint32_t)(0x1UL << (epnum & EP_ADDR_MSK));
 8105d08:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8105d0a:	f003 030f 	and.w	r3, r3, #15
 8105d0e:	2201      	movs	r2, #1
 8105d10:	fa02 f303 	lsl.w	r3, r2, r3
 8105d14:	60fb      	str	r3, [r7, #12]
            USBx_DEVICE->DIEPEMPMSK &= ~fifoemptymsk;
 8105d16:	69fb      	ldr	r3, [r7, #28]
 8105d18:	f503 6300 	add.w	r3, r3, #2048	; 0x800
 8105d1c:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8105d1e:	68fb      	ldr	r3, [r7, #12]
 8105d20:	43db      	mvns	r3, r3
 8105d22:	69f9      	ldr	r1, [r7, #28]
 8105d24:	f501 6100 	add.w	r1, r1, #2048	; 0x800
 8105d28:	4013      	ands	r3, r2
 8105d2a:	634b      	str	r3, [r1, #52]	; 0x34

            CLEAR_IN_EP_INTR(epnum, USB_OTG_DIEPINT_XFRC);
 8105d2c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8105d2e:	015a      	lsls	r2, r3, #5
 8105d30:	69fb      	ldr	r3, [r7, #28]
 8105d32:	4413      	add	r3, r2
 8105d34:	f503 6310 	add.w	r3, r3, #2304	; 0x900
 8105d38:	461a      	mov	r2, r3
 8105d3a:	2301      	movs	r3, #1
 8105d3c:	6093      	str	r3, [r2, #8]

            if (hpcd->Init.dma_enable == 1U)
 8105d3e:	687b      	ldr	r3, [r7, #4]
 8105d40:	799b      	ldrb	r3, [r3, #6]
 8105d42:	2b01      	cmp	r3, #1
 8105d44:	d132      	bne.n	8105dac <HAL_PCD_IRQHandler+0x3a2>
            {
              hpcd->IN_ep[epnum].xfer_buff += hpcd->IN_ep[epnum].maxpacket;
 8105d46:	6879      	ldr	r1, [r7, #4]
 8105d48:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8105d4a:	4613      	mov	r3, r2
 8105d4c:	00db      	lsls	r3, r3, #3
 8105d4e:	4413      	add	r3, r2
 8105d50:	009b      	lsls	r3, r3, #2
 8105d52:	440b      	add	r3, r1
 8105d54:	3320      	adds	r3, #32
 8105d56:	6819      	ldr	r1, [r3, #0]
 8105d58:	6878      	ldr	r0, [r7, #4]
 8105d5a:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8105d5c:	4613      	mov	r3, r2
 8105d5e:	00db      	lsls	r3, r3, #3
 8105d60:	4413      	add	r3, r2
 8105d62:	009b      	lsls	r3, r3, #2
 8105d64:	4403      	add	r3, r0
 8105d66:	331c      	adds	r3, #28
 8105d68:	681b      	ldr	r3, [r3, #0]
 8105d6a:	4419      	add	r1, r3
 8105d6c:	6878      	ldr	r0, [r7, #4]
 8105d6e:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8105d70:	4613      	mov	r3, r2
 8105d72:	00db      	lsls	r3, r3, #3
 8105d74:	4413      	add	r3, r2
 8105d76:	009b      	lsls	r3, r3, #2
 8105d78:	4403      	add	r3, r0
 8105d7a:	3320      	adds	r3, #32
 8105d7c:	6019      	str	r1, [r3, #0]

              /* this is ZLP, so prepare EP0 for next setup */
              if ((epnum == 0U) && (hpcd->IN_ep[epnum].xfer_len == 0U))
 8105d7e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8105d80:	2b00      	cmp	r3, #0
 8105d82:	d113      	bne.n	8105dac <HAL_PCD_IRQHandler+0x3a2>
 8105d84:	6879      	ldr	r1, [r7, #4]
 8105d86:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8105d88:	4613      	mov	r3, r2
 8105d8a:	00db      	lsls	r3, r3, #3
 8105d8c:	4413      	add	r3, r2
 8105d8e:	009b      	lsls	r3, r3, #2
 8105d90:	440b      	add	r3, r1
 8105d92:	3324      	adds	r3, #36	; 0x24
 8105d94:	681b      	ldr	r3, [r3, #0]
 8105d96:	2b00      	cmp	r3, #0
 8105d98:	d108      	bne.n	8105dac <HAL_PCD_IRQHandler+0x3a2>
              {
                /* prepare to rx more setup packets */
                (void)USB_EP0_OutStart(hpcd->Instance, 1U, (uint8_t *)hpcd->Setup);
 8105d9a:	687b      	ldr	r3, [r7, #4]
 8105d9c:	6818      	ldr	r0, [r3, #0]
 8105d9e:	687b      	ldr	r3, [r7, #4]
 8105da0:	f203 439c 	addw	r3, r3, #1180	; 0x49c
 8105da4:	461a      	mov	r2, r3
 8105da6:	2101      	movs	r1, #1
 8105da8:	f006 fa0a 	bl	810c1c0 <USB_EP0_OutStart>
            }

#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
            hpcd->DataInStageCallback(hpcd, (uint8_t)epnum);
#else
            HAL_PCD_DataInStageCallback(hpcd, (uint8_t)epnum);
 8105dac:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8105dae:	b2db      	uxtb	r3, r3
 8105db0:	4619      	mov	r1, r3
 8105db2:	6878      	ldr	r0, [r7, #4]
 8105db4:	f015 f9b1 	bl	811b11a <HAL_PCD_DataInStageCallback>
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
          }
          if ((epint & USB_OTG_DIEPINT_TOC) == USB_OTG_DIEPINT_TOC)
 8105db8:	693b      	ldr	r3, [r7, #16]
 8105dba:	f003 0308 	and.w	r3, r3, #8
 8105dbe:	2b00      	cmp	r3, #0
 8105dc0:	d008      	beq.n	8105dd4 <HAL_PCD_IRQHandler+0x3ca>
          {
            CLEAR_IN_EP_INTR(epnum, USB_OTG_DIEPINT_TOC);
 8105dc2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8105dc4:	015a      	lsls	r2, r3, #5
 8105dc6:	69fb      	ldr	r3, [r7, #28]
 8105dc8:	4413      	add	r3, r2
 8105dca:	f503 6310 	add.w	r3, r3, #2304	; 0x900
 8105dce:	461a      	mov	r2, r3
 8105dd0:	2308      	movs	r3, #8
 8105dd2:	6093      	str	r3, [r2, #8]
          }
          if ((epint & USB_OTG_DIEPINT_ITTXFE) == USB_OTG_DIEPINT_ITTXFE)
 8105dd4:	693b      	ldr	r3, [r7, #16]
 8105dd6:	f003 0310 	and.w	r3, r3, #16
 8105dda:	2b00      	cmp	r3, #0
 8105ddc:	d008      	beq.n	8105df0 <HAL_PCD_IRQHandler+0x3e6>
          {
            CLEAR_IN_EP_INTR(epnum, USB_OTG_DIEPINT_ITTXFE);
 8105dde:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8105de0:	015a      	lsls	r2, r3, #5
 8105de2:	69fb      	ldr	r3, [r7, #28]
 8105de4:	4413      	add	r3, r2
 8105de6:	f503 6310 	add.w	r3, r3, #2304	; 0x900
 8105dea:	461a      	mov	r2, r3
 8105dec:	2310      	movs	r3, #16
 8105dee:	6093      	str	r3, [r2, #8]
          }
          if ((epint & USB_OTG_DIEPINT_INEPNE) == USB_OTG_DIEPINT_INEPNE)
 8105df0:	693b      	ldr	r3, [r7, #16]
 8105df2:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8105df6:	2b00      	cmp	r3, #0
 8105df8:	d008      	beq.n	8105e0c <HAL_PCD_IRQHandler+0x402>
          {
            CLEAR_IN_EP_INTR(epnum, USB_OTG_DIEPINT_INEPNE);
 8105dfa:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8105dfc:	015a      	lsls	r2, r3, #5
 8105dfe:	69fb      	ldr	r3, [r7, #28]
 8105e00:	4413      	add	r3, r2
 8105e02:	f503 6310 	add.w	r3, r3, #2304	; 0x900
 8105e06:	461a      	mov	r2, r3
 8105e08:	2340      	movs	r3, #64	; 0x40
 8105e0a:	6093      	str	r3, [r2, #8]
          }
          if ((epint & USB_OTG_DIEPINT_EPDISD) == USB_OTG_DIEPINT_EPDISD)
 8105e0c:	693b      	ldr	r3, [r7, #16]
 8105e0e:	f003 0302 	and.w	r3, r3, #2
 8105e12:	2b00      	cmp	r3, #0
 8105e14:	d023      	beq.n	8105e5e <HAL_PCD_IRQHandler+0x454>
          {
            (void)USB_FlushTxFifo(USBx, epnum);
 8105e16:	6a79      	ldr	r1, [r7, #36]	; 0x24
 8105e18:	6a38      	ldr	r0, [r7, #32]
 8105e1a:	f005 f9f7 	bl	810b20c <USB_FlushTxFifo>

            ep = &hpcd->IN_ep[epnum];
 8105e1e:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8105e20:	4613      	mov	r3, r2
 8105e22:	00db      	lsls	r3, r3, #3
 8105e24:	4413      	add	r3, r2
 8105e26:	009b      	lsls	r3, r3, #2
 8105e28:	3310      	adds	r3, #16
 8105e2a:	687a      	ldr	r2, [r7, #4]
 8105e2c:	4413      	add	r3, r2
 8105e2e:	3304      	adds	r3, #4
 8105e30:	617b      	str	r3, [r7, #20]

            if (ep->is_iso_incomplete == 1U)
 8105e32:	697b      	ldr	r3, [r7, #20]
 8105e34:	78db      	ldrb	r3, [r3, #3]
 8105e36:	2b01      	cmp	r3, #1
 8105e38:	d108      	bne.n	8105e4c <HAL_PCD_IRQHandler+0x442>
            {
              ep->is_iso_incomplete = 0U;
 8105e3a:	697b      	ldr	r3, [r7, #20]
 8105e3c:	2200      	movs	r2, #0
 8105e3e:	70da      	strb	r2, [r3, #3]

#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
              hpcd->ISOINIncompleteCallback(hpcd, (uint8_t)epnum);
#else
              HAL_PCD_ISOINIncompleteCallback(hpcd, (uint8_t)epnum);
 8105e40:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8105e42:	b2db      	uxtb	r3, r3
 8105e44:	4619      	mov	r1, r3
 8105e46:	6878      	ldr	r0, [r7, #4]
 8105e48:	f015 f9fe 	bl	811b248 <HAL_PCD_ISOINIncompleteCallback>
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
            }

            CLEAR_IN_EP_INTR(epnum, USB_OTG_DIEPINT_EPDISD);
 8105e4c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8105e4e:	015a      	lsls	r2, r3, #5
 8105e50:	69fb      	ldr	r3, [r7, #28]
 8105e52:	4413      	add	r3, r2
 8105e54:	f503 6310 	add.w	r3, r3, #2304	; 0x900
 8105e58:	461a      	mov	r2, r3
 8105e5a:	2302      	movs	r3, #2
 8105e5c:	6093      	str	r3, [r2, #8]
          }
          if ((epint & USB_OTG_DIEPINT_TXFE) == USB_OTG_DIEPINT_TXFE)
 8105e5e:	693b      	ldr	r3, [r7, #16]
 8105e60:	f003 0380 	and.w	r3, r3, #128	; 0x80
 8105e64:	2b00      	cmp	r3, #0
 8105e66:	d003      	beq.n	8105e70 <HAL_PCD_IRQHandler+0x466>
          {
            (void)PCD_WriteEmptyTxFifo(hpcd, epnum);
 8105e68:	6a79      	ldr	r1, [r7, #36]	; 0x24
 8105e6a:	6878      	ldr	r0, [r7, #4]
 8105e6c:	f000 fcd0 	bl	8106810 <PCD_WriteEmptyTxFifo>
          }
        }
        epnum++;
 8105e70:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8105e72:	3301      	adds	r3, #1
 8105e74:	627b      	str	r3, [r7, #36]	; 0x24
        ep_intr >>= 1U;
 8105e76:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8105e78:	085b      	lsrs	r3, r3, #1
 8105e7a:	62bb      	str	r3, [r7, #40]	; 0x28
      while (ep_intr != 0U)
 8105e7c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8105e7e:	2b00      	cmp	r3, #0
 8105e80:	f47f af2e 	bne.w	8105ce0 <HAL_PCD_IRQHandler+0x2d6>
      }
    }

    /* Handle Resume Interrupt */
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_WKUINT))
 8105e84:	687b      	ldr	r3, [r7, #4]
 8105e86:	681b      	ldr	r3, [r3, #0]
 8105e88:	4618      	mov	r0, r3
 8105e8a:	f006 f8d5 	bl	810c038 <USB_ReadInterrupts>
 8105e8e:	4603      	mov	r3, r0
 8105e90:	f003 4300 	and.w	r3, r3, #2147483648	; 0x80000000
 8105e94:	f1b3 4f00 	cmp.w	r3, #2147483648	; 0x80000000
 8105e98:	d122      	bne.n	8105ee0 <HAL_PCD_IRQHandler+0x4d6>
    {
      /* Clear the Remote Wake-up Signaling */
      USBx_DEVICE->DCTL &= ~USB_OTG_DCTL_RWUSIG;
 8105e9a:	69fb      	ldr	r3, [r7, #28]
 8105e9c:	f503 6300 	add.w	r3, r3, #2048	; 0x800
 8105ea0:	685b      	ldr	r3, [r3, #4]
 8105ea2:	69fa      	ldr	r2, [r7, #28]
 8105ea4:	f502 6200 	add.w	r2, r2, #2048	; 0x800
 8105ea8:	f023 0301 	bic.w	r3, r3, #1
 8105eac:	6053      	str	r3, [r2, #4]

      if (hpcd->LPM_State == LPM_L1)
 8105eae:	687b      	ldr	r3, [r7, #4]
 8105eb0:	f893 34cc 	ldrb.w	r3, [r3, #1228]	; 0x4cc
 8105eb4:	2b01      	cmp	r3, #1
 8105eb6:	d108      	bne.n	8105eca <HAL_PCD_IRQHandler+0x4c0>
      {
        hpcd->LPM_State = LPM_L0;
 8105eb8:	687b      	ldr	r3, [r7, #4]
 8105eba:	2200      	movs	r2, #0
 8105ebc:	f883 24cc 	strb.w	r2, [r3, #1228]	; 0x4cc

#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
        hpcd->LPMCallback(hpcd, PCD_LPM_L0_ACTIVE);
#else
        HAL_PCDEx_LPM_Callback(hpcd, PCD_LPM_L0_ACTIVE);
 8105ec0:	2100      	movs	r1, #0
 8105ec2:	6878      	ldr	r0, [r7, #4]
 8105ec4:	f000 feda 	bl	8106c7c <HAL_PCDEx_LPM_Callback>
 8105ec8:	e002      	b.n	8105ed0 <HAL_PCD_IRQHandler+0x4c6>
      else
      {
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
        hpcd->ResumeCallback(hpcd);
#else
        HAL_PCD_ResumeCallback(hpcd);
 8105eca:	6878      	ldr	r0, [r7, #4]
 8105ecc:	f015 f99c 	bl	811b208 <HAL_PCD_ResumeCallback>
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
      }

      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_WKUINT);
 8105ed0:	687b      	ldr	r3, [r7, #4]
 8105ed2:	681b      	ldr	r3, [r3, #0]
 8105ed4:	695a      	ldr	r2, [r3, #20]
 8105ed6:	687b      	ldr	r3, [r7, #4]
 8105ed8:	681b      	ldr	r3, [r3, #0]
 8105eda:	f002 4200 	and.w	r2, r2, #2147483648	; 0x80000000
 8105ede:	615a      	str	r2, [r3, #20]
    }

    /* Handle Suspend Interrupt */
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_USBSUSP))
 8105ee0:	687b      	ldr	r3, [r7, #4]
 8105ee2:	681b      	ldr	r3, [r3, #0]
 8105ee4:	4618      	mov	r0, r3
 8105ee6:	f006 f8a7 	bl	810c038 <USB_ReadInterrupts>
 8105eea:	4603      	mov	r3, r0
 8105eec:	f403 6300 	and.w	r3, r3, #2048	; 0x800
 8105ef0:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
 8105ef4:	d112      	bne.n	8105f1c <HAL_PCD_IRQHandler+0x512>
    {
      if ((USBx_DEVICE->DSTS & USB_OTG_DSTS_SUSPSTS) == USB_OTG_DSTS_SUSPSTS)
 8105ef6:	69fb      	ldr	r3, [r7, #28]
 8105ef8:	f503 6300 	add.w	r3, r3, #2048	; 0x800
 8105efc:	689b      	ldr	r3, [r3, #8]
 8105efe:	f003 0301 	and.w	r3, r3, #1
 8105f02:	2b01      	cmp	r3, #1
 8105f04:	d102      	bne.n	8105f0c <HAL_PCD_IRQHandler+0x502>
      {
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
        hpcd->SuspendCallback(hpcd);
#else
        HAL_PCD_SuspendCallback(hpcd);
 8105f06:	6878      	ldr	r0, [r7, #4]
 8105f08:	f015 f958 	bl	811b1bc <HAL_PCD_SuspendCallback>
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
      }
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_USBSUSP);
 8105f0c:	687b      	ldr	r3, [r7, #4]
 8105f0e:	681b      	ldr	r3, [r3, #0]
 8105f10:	695a      	ldr	r2, [r3, #20]
 8105f12:	687b      	ldr	r3, [r7, #4]
 8105f14:	681b      	ldr	r3, [r3, #0]
 8105f16:	f402 6200 	and.w	r2, r2, #2048	; 0x800
 8105f1a:	615a      	str	r2, [r3, #20]
    }

    /* Handle LPM Interrupt */
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_LPMINT))
 8105f1c:	687b      	ldr	r3, [r7, #4]
 8105f1e:	681b      	ldr	r3, [r3, #0]
 8105f20:	4618      	mov	r0, r3
 8105f22:	f006 f889 	bl	810c038 <USB_ReadInterrupts>
 8105f26:	4603      	mov	r3, r0
 8105f28:	f003 6300 	and.w	r3, r3, #134217728	; 0x8000000
 8105f2c:	f1b3 6f00 	cmp.w	r3, #134217728	; 0x8000000
 8105f30:	d121      	bne.n	8105f76 <HAL_PCD_IRQHandler+0x56c>
    {
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_LPMINT);
 8105f32:	687b      	ldr	r3, [r7, #4]
 8105f34:	681b      	ldr	r3, [r3, #0]
 8105f36:	695a      	ldr	r2, [r3, #20]
 8105f38:	687b      	ldr	r3, [r7, #4]
 8105f3a:	681b      	ldr	r3, [r3, #0]
 8105f3c:	f002 6200 	and.w	r2, r2, #134217728	; 0x8000000
 8105f40:	615a      	str	r2, [r3, #20]

      if (hpcd->LPM_State == LPM_L0)
 8105f42:	687b      	ldr	r3, [r7, #4]
 8105f44:	f893 34cc 	ldrb.w	r3, [r3, #1228]	; 0x4cc
 8105f48:	2b00      	cmp	r3, #0
 8105f4a:	d111      	bne.n	8105f70 <HAL_PCD_IRQHandler+0x566>
      {
        hpcd->LPM_State = LPM_L1;
 8105f4c:	687b      	ldr	r3, [r7, #4]
 8105f4e:	2201      	movs	r2, #1
 8105f50:	f883 24cc 	strb.w	r2, [r3, #1228]	; 0x4cc
        hpcd->BESL = (hpcd->Instance->GLPMCFG & USB_OTG_GLPMCFG_BESL) >> 2U;
 8105f54:	687b      	ldr	r3, [r7, #4]
 8105f56:	681b      	ldr	r3, [r3, #0]
 8105f58:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8105f5a:	089b      	lsrs	r3, r3, #2
 8105f5c:	f003 020f 	and.w	r2, r3, #15
 8105f60:	687b      	ldr	r3, [r7, #4]
 8105f62:	f8c3 24d0 	str.w	r2, [r3, #1232]	; 0x4d0

#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
        hpcd->LPMCallback(hpcd, PCD_LPM_L1_ACTIVE);
#else
        HAL_PCDEx_LPM_Callback(hpcd, PCD_LPM_L1_ACTIVE);
 8105f66:	2101      	movs	r1, #1
 8105f68:	6878      	ldr	r0, [r7, #4]
 8105f6a:	f000 fe87 	bl	8106c7c <HAL_PCDEx_LPM_Callback>
 8105f6e:	e002      	b.n	8105f76 <HAL_PCD_IRQHandler+0x56c>
      else
      {
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
        hpcd->SuspendCallback(hpcd);
#else
        HAL_PCD_SuspendCallback(hpcd);
 8105f70:	6878      	ldr	r0, [r7, #4]
 8105f72:	f015 f923 	bl	811b1bc <HAL_PCD_SuspendCallback>
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
      }
    }

    /* Handle Reset Interrupt */
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_USBRST))
 8105f76:	687b      	ldr	r3, [r7, #4]
 8105f78:	681b      	ldr	r3, [r3, #0]
 8105f7a:	4618      	mov	r0, r3
 8105f7c:	f006 f85c 	bl	810c038 <USB_ReadInterrupts>
 8105f80:	4603      	mov	r3, r0
 8105f82:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
 8105f86:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
 8105f8a:	f040 80b7 	bne.w	81060fc <HAL_PCD_IRQHandler+0x6f2>
    {
      USBx_DEVICE->DCTL &= ~USB_OTG_DCTL_RWUSIG;
 8105f8e:	69fb      	ldr	r3, [r7, #28]
 8105f90:	f503 6300 	add.w	r3, r3, #2048	; 0x800
 8105f94:	685b      	ldr	r3, [r3, #4]
 8105f96:	69fa      	ldr	r2, [r7, #28]
 8105f98:	f502 6200 	add.w	r2, r2, #2048	; 0x800
 8105f9c:	f023 0301 	bic.w	r3, r3, #1
 8105fa0:	6053      	str	r3, [r2, #4]
      (void)USB_FlushTxFifo(hpcd->Instance, 0x10U);
 8105fa2:	687b      	ldr	r3, [r7, #4]
 8105fa4:	681b      	ldr	r3, [r3, #0]
 8105fa6:	2110      	movs	r1, #16
 8105fa8:	4618      	mov	r0, r3
 8105faa:	f005 f92f 	bl	810b20c <USB_FlushTxFifo>

      for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 8105fae:	2300      	movs	r3, #0
 8105fb0:	62fb      	str	r3, [r7, #44]	; 0x2c
 8105fb2:	e046      	b.n	8106042 <HAL_PCD_IRQHandler+0x638>
      {
        USBx_INEP(i)->DIEPINT = 0xFB7FU;
 8105fb4:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8105fb6:	015a      	lsls	r2, r3, #5
 8105fb8:	69fb      	ldr	r3, [r7, #28]
 8105fba:	4413      	add	r3, r2
 8105fbc:	f503 6310 	add.w	r3, r3, #2304	; 0x900
 8105fc0:	461a      	mov	r2, r3
 8105fc2:	f64f 337f 	movw	r3, #64383	; 0xfb7f
 8105fc6:	6093      	str	r3, [r2, #8]
        USBx_INEP(i)->DIEPCTL &= ~USB_OTG_DIEPCTL_STALL;
 8105fc8:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8105fca:	015a      	lsls	r2, r3, #5
 8105fcc:	69fb      	ldr	r3, [r7, #28]
 8105fce:	4413      	add	r3, r2
 8105fd0:	f503 6310 	add.w	r3, r3, #2304	; 0x900
 8105fd4:	681b      	ldr	r3, [r3, #0]
 8105fd6:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8105fd8:	0151      	lsls	r1, r2, #5
 8105fda:	69fa      	ldr	r2, [r7, #28]
 8105fdc:	440a      	add	r2, r1
 8105fde:	f502 6210 	add.w	r2, r2, #2304	; 0x900
 8105fe2:	f423 1300 	bic.w	r3, r3, #2097152	; 0x200000
 8105fe6:	6013      	str	r3, [r2, #0]
        USBx_OUTEP(i)->DOEPINT = 0xFB7FU;
 8105fe8:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8105fea:	015a      	lsls	r2, r3, #5
 8105fec:	69fb      	ldr	r3, [r7, #28]
 8105fee:	4413      	add	r3, r2
 8105ff0:	f503 6330 	add.w	r3, r3, #2816	; 0xb00
 8105ff4:	461a      	mov	r2, r3
 8105ff6:	f64f 337f 	movw	r3, #64383	; 0xfb7f
 8105ffa:	6093      	str	r3, [r2, #8]
        USBx_OUTEP(i)->DOEPCTL &= ~USB_OTG_DOEPCTL_STALL;
 8105ffc:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8105ffe:	015a      	lsls	r2, r3, #5
 8106000:	69fb      	ldr	r3, [r7, #28]
 8106002:	4413      	add	r3, r2
 8106004:	f503 6330 	add.w	r3, r3, #2816	; 0xb00
 8106008:	681b      	ldr	r3, [r3, #0]
 810600a:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 810600c:	0151      	lsls	r1, r2, #5
 810600e:	69fa      	ldr	r2, [r7, #28]
 8106010:	440a      	add	r2, r1
 8106012:	f502 6230 	add.w	r2, r2, #2816	; 0xb00
 8106016:	f423 1300 	bic.w	r3, r3, #2097152	; 0x200000
 810601a:	6013      	str	r3, [r2, #0]
        USBx_OUTEP(i)->DOEPCTL |= USB_OTG_DOEPCTL_SNAK;
 810601c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 810601e:	015a      	lsls	r2, r3, #5
 8106020:	69fb      	ldr	r3, [r7, #28]
 8106022:	4413      	add	r3, r2
 8106024:	f503 6330 	add.w	r3, r3, #2816	; 0xb00
 8106028:	681b      	ldr	r3, [r3, #0]
 810602a:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 810602c:	0151      	lsls	r1, r2, #5
 810602e:	69fa      	ldr	r2, [r7, #28]
 8106030:	440a      	add	r2, r1
 8106032:	f502 6230 	add.w	r2, r2, #2816	; 0xb00
 8106036:	f043 6300 	orr.w	r3, r3, #134217728	; 0x8000000
 810603a:	6013      	str	r3, [r2, #0]
      for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 810603c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 810603e:	3301      	adds	r3, #1
 8106040:	62fb      	str	r3, [r7, #44]	; 0x2c
 8106042:	687b      	ldr	r3, [r7, #4]
 8106044:	791b      	ldrb	r3, [r3, #4]
 8106046:	461a      	mov	r2, r3
 8106048:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 810604a:	4293      	cmp	r3, r2
 810604c:	d3b2      	bcc.n	8105fb4 <HAL_PCD_IRQHandler+0x5aa>
      }
      USBx_DEVICE->DAINTMSK |= 0x10001U;
 810604e:	69fb      	ldr	r3, [r7, #28]
 8106050:	f503 6300 	add.w	r3, r3, #2048	; 0x800
 8106054:	69db      	ldr	r3, [r3, #28]
 8106056:	69fa      	ldr	r2, [r7, #28]
 8106058:	f502 6200 	add.w	r2, r2, #2048	; 0x800
 810605c:	f043 1301 	orr.w	r3, r3, #65537	; 0x10001
 8106060:	61d3      	str	r3, [r2, #28]

      if (hpcd->Init.use_dedicated_ep1 != 0U)
 8106062:	687b      	ldr	r3, [r7, #4]
 8106064:	7bdb      	ldrb	r3, [r3, #15]
 8106066:	2b00      	cmp	r3, #0
 8106068:	d016      	beq.n	8106098 <HAL_PCD_IRQHandler+0x68e>
      {
        USBx_DEVICE->DOUTEP1MSK |= USB_OTG_DOEPMSK_STUPM |
 810606a:	69fb      	ldr	r3, [r7, #28]
 810606c:	f503 6300 	add.w	r3, r3, #2048	; 0x800
 8106070:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 8106074:	69fa      	ldr	r2, [r7, #28]
 8106076:	f502 6200 	add.w	r2, r2, #2048	; 0x800
 810607a:	f043 030b 	orr.w	r3, r3, #11
 810607e:	f8c2 3084 	str.w	r3, [r2, #132]	; 0x84
                                   USB_OTG_DOEPMSK_XFRCM |
                                   USB_OTG_DOEPMSK_EPDM;

        USBx_DEVICE->DINEP1MSK |= USB_OTG_DIEPMSK_TOM |
 8106082:	69fb      	ldr	r3, [r7, #28]
 8106084:	f503 6300 	add.w	r3, r3, #2048	; 0x800
 8106088:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 810608a:	69fa      	ldr	r2, [r7, #28]
 810608c:	f502 6200 	add.w	r2, r2, #2048	; 0x800
 8106090:	f043 030b 	orr.w	r3, r3, #11
 8106094:	6453      	str	r3, [r2, #68]	; 0x44
 8106096:	e015      	b.n	81060c4 <HAL_PCD_IRQHandler+0x6ba>
                                  USB_OTG_DIEPMSK_XFRCM |
                                  USB_OTG_DIEPMSK_EPDM;
      }
      else
      {
        USBx_DEVICE->DOEPMSK |= USB_OTG_DOEPMSK_STUPM |
 8106098:	69fb      	ldr	r3, [r7, #28]
 810609a:	f503 6300 	add.w	r3, r3, #2048	; 0x800
 810609e:	695b      	ldr	r3, [r3, #20]
 81060a0:	69fa      	ldr	r2, [r7, #28]
 81060a2:	f502 6200 	add.w	r2, r2, #2048	; 0x800
 81060a6:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 81060aa:	f043 032b 	orr.w	r3, r3, #43	; 0x2b
 81060ae:	6153      	str	r3, [r2, #20]
                                USB_OTG_DOEPMSK_XFRCM |
                                USB_OTG_DOEPMSK_EPDM |
                                USB_OTG_DOEPMSK_OTEPSPRM |
                                USB_OTG_DOEPMSK_NAKM;

        USBx_DEVICE->DIEPMSK |= USB_OTG_DIEPMSK_TOM |
 81060b0:	69fb      	ldr	r3, [r7, #28]
 81060b2:	f503 6300 	add.w	r3, r3, #2048	; 0x800
 81060b6:	691b      	ldr	r3, [r3, #16]
 81060b8:	69fa      	ldr	r2, [r7, #28]
 81060ba:	f502 6200 	add.w	r2, r2, #2048	; 0x800
 81060be:	f043 030b 	orr.w	r3, r3, #11
 81060c2:	6113      	str	r3, [r2, #16]
                                USB_OTG_DIEPMSK_XFRCM |
                                USB_OTG_DIEPMSK_EPDM;
      }

      /* Set Default Address to 0 */
      USBx_DEVICE->DCFG &= ~USB_OTG_DCFG_DAD;
 81060c4:	69fb      	ldr	r3, [r7, #28]
 81060c6:	f503 6300 	add.w	r3, r3, #2048	; 0x800
 81060ca:	681b      	ldr	r3, [r3, #0]
 81060cc:	69fa      	ldr	r2, [r7, #28]
 81060ce:	f502 6200 	add.w	r2, r2, #2048	; 0x800
 81060d2:	f423 63fe 	bic.w	r3, r3, #2032	; 0x7f0
 81060d6:	6013      	str	r3, [r2, #0]

      /* setup EP0 to receive SETUP packets */
      (void)USB_EP0_OutStart(hpcd->Instance, (uint8_t)hpcd->Init.dma_enable,
 81060d8:	687b      	ldr	r3, [r7, #4]
 81060da:	6818      	ldr	r0, [r3, #0]
 81060dc:	687b      	ldr	r3, [r7, #4]
 81060de:	7999      	ldrb	r1, [r3, #6]
                             (uint8_t *)hpcd->Setup);
 81060e0:	687b      	ldr	r3, [r7, #4]
 81060e2:	f203 439c 	addw	r3, r3, #1180	; 0x49c
      (void)USB_EP0_OutStart(hpcd->Instance, (uint8_t)hpcd->Init.dma_enable,
 81060e6:	461a      	mov	r2, r3
 81060e8:	f006 f86a 	bl	810c1c0 <USB_EP0_OutStart>

      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_USBRST);
 81060ec:	687b      	ldr	r3, [r7, #4]
 81060ee:	681b      	ldr	r3, [r3, #0]
 81060f0:	695a      	ldr	r2, [r3, #20]
 81060f2:	687b      	ldr	r3, [r7, #4]
 81060f4:	681b      	ldr	r3, [r3, #0]
 81060f6:	f402 5280 	and.w	r2, r2, #4096	; 0x1000
 81060fa:	615a      	str	r2, [r3, #20]
    }

    /* Handle Enumeration done Interrupt */
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_ENUMDNE))
 81060fc:	687b      	ldr	r3, [r7, #4]
 81060fe:	681b      	ldr	r3, [r3, #0]
 8106100:	4618      	mov	r0, r3
 8106102:	f005 ff99 	bl	810c038 <USB_ReadInterrupts>
 8106106:	4603      	mov	r3, r0
 8106108:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
 810610c:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
 8106110:	d123      	bne.n	810615a <HAL_PCD_IRQHandler+0x750>
    {
      (void)USB_ActivateSetup(hpcd->Instance);
 8106112:	687b      	ldr	r3, [r7, #4]
 8106114:	681b      	ldr	r3, [r3, #0]
 8106116:	4618      	mov	r0, r3
 8106118:	f006 f82f 	bl	810c17a <USB_ActivateSetup>
      hpcd->Init.speed = USB_GetDevSpeed(hpcd->Instance);
 810611c:	687b      	ldr	r3, [r7, #4]
 810611e:	681b      	ldr	r3, [r3, #0]
 8106120:	4618      	mov	r0, r3
 8106122:	f005 f8ec 	bl	810b2fe <USB_GetDevSpeed>
 8106126:	4603      	mov	r3, r0
 8106128:	461a      	mov	r2, r3
 810612a:	687b      	ldr	r3, [r7, #4]
 810612c:	71da      	strb	r2, [r3, #7]

      /* Set USB Turnaround time */
      (void)USB_SetTurnaroundTime(hpcd->Instance,
 810612e:	687b      	ldr	r3, [r7, #4]
 8106130:	681c      	ldr	r4, [r3, #0]
 8106132:	f000 ffc1 	bl	81070b8 <HAL_RCC_GetHCLKFreq>
 8106136:	4601      	mov	r1, r0
                                  HAL_RCC_GetHCLKFreq(),
                                  (uint8_t)hpcd->Init.speed);
 8106138:	687b      	ldr	r3, [r7, #4]
 810613a:	79db      	ldrb	r3, [r3, #7]
      (void)USB_SetTurnaroundTime(hpcd->Instance,
 810613c:	461a      	mov	r2, r3
 810613e:	4620      	mov	r0, r4
 8106140:	f004 fdf6 	bl	810ad30 <USB_SetTurnaroundTime>

#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
      hpcd->ResetCallback(hpcd);
#else
      HAL_PCD_ResetCallback(hpcd);
 8106144:	6878      	ldr	r0, [r7, #4]
 8106146:	f015 f810 	bl	811b16a <HAL_PCD_ResetCallback>
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */

      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_ENUMDNE);
 810614a:	687b      	ldr	r3, [r7, #4]
 810614c:	681b      	ldr	r3, [r3, #0]
 810614e:	695a      	ldr	r2, [r3, #20]
 8106150:	687b      	ldr	r3, [r7, #4]
 8106152:	681b      	ldr	r3, [r3, #0]
 8106154:	f402 5200 	and.w	r2, r2, #8192	; 0x2000
 8106158:	615a      	str	r2, [r3, #20]
    }

    /* Handle SOF Interrupt */
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_SOF))
 810615a:	687b      	ldr	r3, [r7, #4]
 810615c:	681b      	ldr	r3, [r3, #0]
 810615e:	4618      	mov	r0, r3
 8106160:	f005 ff6a 	bl	810c038 <USB_ReadInterrupts>
 8106164:	4603      	mov	r3, r0
 8106166:	f003 0308 	and.w	r3, r3, #8
 810616a:	2b08      	cmp	r3, #8
 810616c:	d10a      	bne.n	8106184 <HAL_PCD_IRQHandler+0x77a>
    {
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
      hpcd->SOFCallback(hpcd);
#else
      HAL_PCD_SOFCallback(hpcd);
 810616e:	6878      	ldr	r0, [r7, #4]
 8106170:	f014 ffed 	bl	811b14e <HAL_PCD_SOFCallback>
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */

      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_SOF);
 8106174:	687b      	ldr	r3, [r7, #4]
 8106176:	681b      	ldr	r3, [r3, #0]
 8106178:	695a      	ldr	r2, [r3, #20]
 810617a:	687b      	ldr	r3, [r7, #4]
 810617c:	681b      	ldr	r3, [r3, #0]
 810617e:	f002 0208 	and.w	r2, r2, #8
 8106182:	615a      	str	r2, [r3, #20]
    }

    /* Handle Global OUT NAK effective Interrupt */
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_BOUTNAKEFF))
 8106184:	687b      	ldr	r3, [r7, #4]
 8106186:	681b      	ldr	r3, [r3, #0]
 8106188:	4618      	mov	r0, r3
 810618a:	f005 ff55 	bl	810c038 <USB_ReadInterrupts>
 810618e:	4603      	mov	r3, r0
 8106190:	f003 0380 	and.w	r3, r3, #128	; 0x80
 8106194:	2b80      	cmp	r3, #128	; 0x80
 8106196:	d123      	bne.n	81061e0 <HAL_PCD_IRQHandler+0x7d6>
    {
      USBx->GINTMSK &= ~USB_OTG_GINTMSK_GONAKEFFM;
 8106198:	6a3b      	ldr	r3, [r7, #32]
 810619a:	699b      	ldr	r3, [r3, #24]
 810619c:	f023 0280 	bic.w	r2, r3, #128	; 0x80
 81061a0:	6a3b      	ldr	r3, [r7, #32]
 81061a2:	619a      	str	r2, [r3, #24]

      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 81061a4:	2301      	movs	r3, #1
 81061a6:	627b      	str	r3, [r7, #36]	; 0x24
 81061a8:	e014      	b.n	81061d4 <HAL_PCD_IRQHandler+0x7ca>
      {
        if (hpcd->OUT_ep[epnum].is_iso_incomplete == 1U)
 81061aa:	6879      	ldr	r1, [r7, #4]
 81061ac:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 81061ae:	4613      	mov	r3, r2
 81061b0:	00db      	lsls	r3, r3, #3
 81061b2:	4413      	add	r3, r2
 81061b4:	009b      	lsls	r3, r3, #2
 81061b6:	440b      	add	r3, r1
 81061b8:	f203 2357 	addw	r3, r3, #599	; 0x257
 81061bc:	781b      	ldrb	r3, [r3, #0]
 81061be:	2b01      	cmp	r3, #1
 81061c0:	d105      	bne.n	81061ce <HAL_PCD_IRQHandler+0x7c4>
        {
          /* Abort current transaction and disable the EP */
          (void)HAL_PCD_EP_Abort(hpcd, (uint8_t)epnum);
 81061c2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 81061c4:	b2db      	uxtb	r3, r3
 81061c6:	4619      	mov	r1, r3
 81061c8:	6878      	ldr	r0, [r7, #4]
 81061ca:	f000 faf0 	bl	81067ae <HAL_PCD_EP_Abort>
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 81061ce:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 81061d0:	3301      	adds	r3, #1
 81061d2:	627b      	str	r3, [r7, #36]	; 0x24
 81061d4:	687b      	ldr	r3, [r7, #4]
 81061d6:	791b      	ldrb	r3, [r3, #4]
 81061d8:	461a      	mov	r2, r3
 81061da:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 81061dc:	4293      	cmp	r3, r2
 81061de:	d3e4      	bcc.n	81061aa <HAL_PCD_IRQHandler+0x7a0>
        }
      }
    }

    /* Handle Incomplete ISO IN Interrupt */
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_IISOIXFR))
 81061e0:	687b      	ldr	r3, [r7, #4]
 81061e2:	681b      	ldr	r3, [r3, #0]
 81061e4:	4618      	mov	r0, r3
 81061e6:	f005 ff27 	bl	810c038 <USB_ReadInterrupts>
 81061ea:	4603      	mov	r3, r0
 81061ec:	f403 1380 	and.w	r3, r3, #1048576	; 0x100000
 81061f0:	f5b3 1f80 	cmp.w	r3, #1048576	; 0x100000
 81061f4:	d13c      	bne.n	8106270 <HAL_PCD_IRQHandler+0x866>
    {
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 81061f6:	2301      	movs	r3, #1
 81061f8:	627b      	str	r3, [r7, #36]	; 0x24
 81061fa:	e02b      	b.n	8106254 <HAL_PCD_IRQHandler+0x84a>
      {
        RegVal = USBx_INEP(epnum)->DIEPCTL;
 81061fc:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 81061fe:	015a      	lsls	r2, r3, #5
 8106200:	69fb      	ldr	r3, [r7, #28]
 8106202:	4413      	add	r3, r2
 8106204:	f503 6310 	add.w	r3, r3, #2304	; 0x900
 8106208:	681b      	ldr	r3, [r3, #0]
 810620a:	61bb      	str	r3, [r7, #24]

        if ((hpcd->IN_ep[epnum].type == EP_TYPE_ISOC) &&
 810620c:	6879      	ldr	r1, [r7, #4]
 810620e:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8106210:	4613      	mov	r3, r2
 8106212:	00db      	lsls	r3, r3, #3
 8106214:	4413      	add	r3, r2
 8106216:	009b      	lsls	r3, r3, #2
 8106218:	440b      	add	r3, r1
 810621a:	3318      	adds	r3, #24
 810621c:	781b      	ldrb	r3, [r3, #0]
 810621e:	2b01      	cmp	r3, #1
 8106220:	d115      	bne.n	810624e <HAL_PCD_IRQHandler+0x844>
            ((RegVal & USB_OTG_DIEPCTL_EPENA) == USB_OTG_DIEPCTL_EPENA))
 8106222:	69bb      	ldr	r3, [r7, #24]
        if ((hpcd->IN_ep[epnum].type == EP_TYPE_ISOC) &&
 8106224:	2b00      	cmp	r3, #0
 8106226:	da12      	bge.n	810624e <HAL_PCD_IRQHandler+0x844>
        {
          hpcd->IN_ep[epnum].is_iso_incomplete = 1U;
 8106228:	6879      	ldr	r1, [r7, #4]
 810622a:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 810622c:	4613      	mov	r3, r2
 810622e:	00db      	lsls	r3, r3, #3
 8106230:	4413      	add	r3, r2
 8106232:	009b      	lsls	r3, r3, #2
 8106234:	440b      	add	r3, r1
 8106236:	3317      	adds	r3, #23
 8106238:	2201      	movs	r2, #1
 810623a:	701a      	strb	r2, [r3, #0]

          /* Abort current transaction and disable the EP */
          (void)HAL_PCD_EP_Abort(hpcd, (uint8_t)(epnum | 0x80U));
 810623c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 810623e:	b2db      	uxtb	r3, r3
 8106240:	f063 037f 	orn	r3, r3, #127	; 0x7f
 8106244:	b2db      	uxtb	r3, r3
 8106246:	4619      	mov	r1, r3
 8106248:	6878      	ldr	r0, [r7, #4]
 810624a:	f000 fab0 	bl	81067ae <HAL_PCD_EP_Abort>
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 810624e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8106250:	3301      	adds	r3, #1
 8106252:	627b      	str	r3, [r7, #36]	; 0x24
 8106254:	687b      	ldr	r3, [r7, #4]
 8106256:	791b      	ldrb	r3, [r3, #4]
 8106258:	461a      	mov	r2, r3
 810625a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 810625c:	4293      	cmp	r3, r2
 810625e:	d3cd      	bcc.n	81061fc <HAL_PCD_IRQHandler+0x7f2>
        }
      }

      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_IISOIXFR);
 8106260:	687b      	ldr	r3, [r7, #4]
 8106262:	681b      	ldr	r3, [r3, #0]
 8106264:	695a      	ldr	r2, [r3, #20]
 8106266:	687b      	ldr	r3, [r7, #4]
 8106268:	681b      	ldr	r3, [r3, #0]
 810626a:	f402 1280 	and.w	r2, r2, #1048576	; 0x100000
 810626e:	615a      	str	r2, [r3, #20]
    }

    /* Handle Incomplete ISO OUT Interrupt */
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_PXFR_INCOMPISOOUT))
 8106270:	687b      	ldr	r3, [r7, #4]
 8106272:	681b      	ldr	r3, [r3, #0]
 8106274:	4618      	mov	r0, r3
 8106276:	f005 fedf 	bl	810c038 <USB_ReadInterrupts>
 810627a:	4603      	mov	r3, r0
 810627c:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
 8106280:	f5b3 1f00 	cmp.w	r3, #2097152	; 0x200000
 8106284:	d156      	bne.n	8106334 <HAL_PCD_IRQHandler+0x92a>
    {
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 8106286:	2301      	movs	r3, #1
 8106288:	627b      	str	r3, [r7, #36]	; 0x24
 810628a:	e045      	b.n	8106318 <HAL_PCD_IRQHandler+0x90e>
      {
        RegVal = USBx_OUTEP(epnum)->DOEPCTL;
 810628c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 810628e:	015a      	lsls	r2, r3, #5
 8106290:	69fb      	ldr	r3, [r7, #28]
 8106292:	4413      	add	r3, r2
 8106294:	f503 6330 	add.w	r3, r3, #2816	; 0xb00
 8106298:	681b      	ldr	r3, [r3, #0]
 810629a:	61bb      	str	r3, [r7, #24]

        if ((hpcd->OUT_ep[epnum].type == EP_TYPE_ISOC) &&
 810629c:	6879      	ldr	r1, [r7, #4]
 810629e:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 81062a0:	4613      	mov	r3, r2
 81062a2:	00db      	lsls	r3, r3, #3
 81062a4:	4413      	add	r3, r2
 81062a6:	009b      	lsls	r3, r3, #2
 81062a8:	440b      	add	r3, r1
 81062aa:	f503 7316 	add.w	r3, r3, #600	; 0x258
 81062ae:	781b      	ldrb	r3, [r3, #0]
 81062b0:	2b01      	cmp	r3, #1
 81062b2:	d12e      	bne.n	8106312 <HAL_PCD_IRQHandler+0x908>
            ((RegVal & USB_OTG_DOEPCTL_EPENA) == USB_OTG_DOEPCTL_EPENA) &&
 81062b4:	69bb      	ldr	r3, [r7, #24]
        if ((hpcd->OUT_ep[epnum].type == EP_TYPE_ISOC) &&
 81062b6:	2b00      	cmp	r3, #0
 81062b8:	da2b      	bge.n	8106312 <HAL_PCD_IRQHandler+0x908>
            ((RegVal & (0x1U << 16)) == (hpcd->FrameNumber & 0x1U)))
 81062ba:	69bb      	ldr	r3, [r7, #24]
 81062bc:	f403 3280 	and.w	r2, r3, #65536	; 0x10000
 81062c0:	687b      	ldr	r3, [r7, #4]
 81062c2:	f8d3 34d4 	ldr.w	r3, [r3, #1236]	; 0x4d4
 81062c6:	f003 0301 	and.w	r3, r3, #1
            ((RegVal & USB_OTG_DOEPCTL_EPENA) == USB_OTG_DOEPCTL_EPENA) &&
 81062ca:	429a      	cmp	r2, r3
 81062cc:	d121      	bne.n	8106312 <HAL_PCD_IRQHandler+0x908>
        {
          hpcd->OUT_ep[epnum].is_iso_incomplete = 1U;
 81062ce:	6879      	ldr	r1, [r7, #4]
 81062d0:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 81062d2:	4613      	mov	r3, r2
 81062d4:	00db      	lsls	r3, r3, #3
 81062d6:	4413      	add	r3, r2
 81062d8:	009b      	lsls	r3, r3, #2
 81062da:	440b      	add	r3, r1
 81062dc:	f203 2357 	addw	r3, r3, #599	; 0x257
 81062e0:	2201      	movs	r2, #1
 81062e2:	701a      	strb	r2, [r3, #0]

          USBx->GINTMSK |= USB_OTG_GINTMSK_GONAKEFFM;
 81062e4:	6a3b      	ldr	r3, [r7, #32]
 81062e6:	699b      	ldr	r3, [r3, #24]
 81062e8:	f043 0280 	orr.w	r2, r3, #128	; 0x80
 81062ec:	6a3b      	ldr	r3, [r7, #32]
 81062ee:	619a      	str	r2, [r3, #24]

          if ((USBx->GINTSTS & USB_OTG_GINTSTS_BOUTNAKEFF) == 0U)
 81062f0:	6a3b      	ldr	r3, [r7, #32]
 81062f2:	695b      	ldr	r3, [r3, #20]
 81062f4:	f003 0380 	and.w	r3, r3, #128	; 0x80
 81062f8:	2b00      	cmp	r3, #0
 81062fa:	d10a      	bne.n	8106312 <HAL_PCD_IRQHandler+0x908>
          {
            USBx_DEVICE->DCTL |= USB_OTG_DCTL_SGONAK;
 81062fc:	69fb      	ldr	r3, [r7, #28]
 81062fe:	f503 6300 	add.w	r3, r3, #2048	; 0x800
 8106302:	685b      	ldr	r3, [r3, #4]
 8106304:	69fa      	ldr	r2, [r7, #28]
 8106306:	f502 6200 	add.w	r2, r2, #2048	; 0x800
 810630a:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 810630e:	6053      	str	r3, [r2, #4]
            break;
 8106310:	e008      	b.n	8106324 <HAL_PCD_IRQHandler+0x91a>
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 8106312:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8106314:	3301      	adds	r3, #1
 8106316:	627b      	str	r3, [r7, #36]	; 0x24
 8106318:	687b      	ldr	r3, [r7, #4]
 810631a:	791b      	ldrb	r3, [r3, #4]
 810631c:	461a      	mov	r2, r3
 810631e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8106320:	4293      	cmp	r3, r2
 8106322:	d3b3      	bcc.n	810628c <HAL_PCD_IRQHandler+0x882>
          }
        }
      }

      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_PXFR_INCOMPISOOUT);
 8106324:	687b      	ldr	r3, [r7, #4]
 8106326:	681b      	ldr	r3, [r3, #0]
 8106328:	695a      	ldr	r2, [r3, #20]
 810632a:	687b      	ldr	r3, [r7, #4]
 810632c:	681b      	ldr	r3, [r3, #0]
 810632e:	f402 1200 	and.w	r2, r2, #2097152	; 0x200000
 8106332:	615a      	str	r2, [r3, #20]
    }

    /* Handle Connection event Interrupt */
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_SRQINT))
 8106334:	687b      	ldr	r3, [r7, #4]
 8106336:	681b      	ldr	r3, [r3, #0]
 8106338:	4618      	mov	r0, r3
 810633a:	f005 fe7d 	bl	810c038 <USB_ReadInterrupts>
 810633e:	4603      	mov	r3, r0
 8106340:	f003 4380 	and.w	r3, r3, #1073741824	; 0x40000000
 8106344:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
 8106348:	d10a      	bne.n	8106360 <HAL_PCD_IRQHandler+0x956>
    {
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
      hpcd->ConnectCallback(hpcd);
#else
      HAL_PCD_ConnectCallback(hpcd);
 810634a:	6878      	ldr	r0, [r7, #4]
 810634c:	f014 ff8e 	bl	811b26c <HAL_PCD_ConnectCallback>
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */

      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_SRQINT);
 8106350:	687b      	ldr	r3, [r7, #4]
 8106352:	681b      	ldr	r3, [r3, #0]
 8106354:	695a      	ldr	r2, [r3, #20]
 8106356:	687b      	ldr	r3, [r7, #4]
 8106358:	681b      	ldr	r3, [r3, #0]
 810635a:	f002 4280 	and.w	r2, r2, #1073741824	; 0x40000000
 810635e:	615a      	str	r2, [r3, #20]
    }

    /* Handle Disconnection event Interrupt */
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_OTGINT))
 8106360:	687b      	ldr	r3, [r7, #4]
 8106362:	681b      	ldr	r3, [r3, #0]
 8106364:	4618      	mov	r0, r3
 8106366:	f005 fe67 	bl	810c038 <USB_ReadInterrupts>
 810636a:	4603      	mov	r3, r0
 810636c:	f003 0304 	and.w	r3, r3, #4
 8106370:	2b04      	cmp	r3, #4
 8106372:	d115      	bne.n	81063a0 <HAL_PCD_IRQHandler+0x996>
    {
      RegVal = hpcd->Instance->GOTGINT;
 8106374:	687b      	ldr	r3, [r7, #4]
 8106376:	681b      	ldr	r3, [r3, #0]
 8106378:	685b      	ldr	r3, [r3, #4]
 810637a:	61bb      	str	r3, [r7, #24]

      if ((RegVal & USB_OTG_GOTGINT_SEDET) == USB_OTG_GOTGINT_SEDET)
 810637c:	69bb      	ldr	r3, [r7, #24]
 810637e:	f003 0304 	and.w	r3, r3, #4
 8106382:	2b00      	cmp	r3, #0
 8106384:	d002      	beq.n	810638c <HAL_PCD_IRQHandler+0x982>
      {
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
        hpcd->DisconnectCallback(hpcd);
#else
        HAL_PCD_DisconnectCallback(hpcd);
 8106386:	6878      	ldr	r0, [r7, #4]
 8106388:	f014 ff7e 	bl	811b288 <HAL_PCD_DisconnectCallback>
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
      }
      hpcd->Instance->GOTGINT |= RegVal;
 810638c:	687b      	ldr	r3, [r7, #4]
 810638e:	681b      	ldr	r3, [r3, #0]
 8106390:	6859      	ldr	r1, [r3, #4]
 8106392:	687b      	ldr	r3, [r7, #4]
 8106394:	681b      	ldr	r3, [r3, #0]
 8106396:	69ba      	ldr	r2, [r7, #24]
 8106398:	430a      	orrs	r2, r1
 810639a:	605a      	str	r2, [r3, #4]
 810639c:	e000      	b.n	81063a0 <HAL_PCD_IRQHandler+0x996>
      return;
 810639e:	bf00      	nop
    }
  }
}
 81063a0:	3734      	adds	r7, #52	; 0x34
 81063a2:	46bd      	mov	sp, r7
 81063a4:	bd90      	pop	{r4, r7, pc}

081063a6 <HAL_PCD_SetAddress>:
  * @param  hpcd PCD handle
  * @param  address new device address
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_SetAddress(PCD_HandleTypeDef *hpcd, uint8_t address)
{
 81063a6:	b580      	push	{r7, lr}
 81063a8:	b082      	sub	sp, #8
 81063aa:	af00      	add	r7, sp, #0
 81063ac:	6078      	str	r0, [r7, #4]
 81063ae:	460b      	mov	r3, r1
 81063b0:	70fb      	strb	r3, [r7, #3]
  __HAL_LOCK(hpcd);
 81063b2:	687b      	ldr	r3, [r7, #4]
 81063b4:	f893 3494 	ldrb.w	r3, [r3, #1172]	; 0x494
 81063b8:	2b01      	cmp	r3, #1
 81063ba:	d101      	bne.n	81063c0 <HAL_PCD_SetAddress+0x1a>
 81063bc:	2302      	movs	r3, #2
 81063be:	e012      	b.n	81063e6 <HAL_PCD_SetAddress+0x40>
 81063c0:	687b      	ldr	r3, [r7, #4]
 81063c2:	2201      	movs	r2, #1
 81063c4:	f883 2494 	strb.w	r2, [r3, #1172]	; 0x494
  hpcd->USB_Address = address;
 81063c8:	687b      	ldr	r3, [r7, #4]
 81063ca:	78fa      	ldrb	r2, [r7, #3]
 81063cc:	745a      	strb	r2, [r3, #17]
  (void)USB_SetDevAddress(hpcd->Instance, address);
 81063ce:	687b      	ldr	r3, [r7, #4]
 81063d0:	681b      	ldr	r3, [r3, #0]
 81063d2:	78fa      	ldrb	r2, [r7, #3]
 81063d4:	4611      	mov	r1, r2
 81063d6:	4618      	mov	r0, r3
 81063d8:	f005 fdc6 	bl	810bf68 <USB_SetDevAddress>
  __HAL_UNLOCK(hpcd);
 81063dc:	687b      	ldr	r3, [r7, #4]
 81063de:	2200      	movs	r2, #0
 81063e0:	f883 2494 	strb.w	r2, [r3, #1172]	; 0x494

  return HAL_OK;
 81063e4:	2300      	movs	r3, #0
}
 81063e6:	4618      	mov	r0, r3
 81063e8:	3708      	adds	r7, #8
 81063ea:	46bd      	mov	sp, r7
 81063ec:	bd80      	pop	{r7, pc}

081063ee <HAL_PCD_EP_Open>:
  * @param  ep_type endpoint type
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_EP_Open(PCD_HandleTypeDef *hpcd, uint8_t ep_addr,
                                  uint16_t ep_mps, uint8_t ep_type)
{
 81063ee:	b580      	push	{r7, lr}
 81063f0:	b084      	sub	sp, #16
 81063f2:	af00      	add	r7, sp, #0
 81063f4:	6078      	str	r0, [r7, #4]
 81063f6:	4608      	mov	r0, r1
 81063f8:	4611      	mov	r1, r2
 81063fa:	461a      	mov	r2, r3
 81063fc:	4603      	mov	r3, r0
 81063fe:	70fb      	strb	r3, [r7, #3]
 8106400:	460b      	mov	r3, r1
 8106402:	803b      	strh	r3, [r7, #0]
 8106404:	4613      	mov	r3, r2
 8106406:	70bb      	strb	r3, [r7, #2]
  HAL_StatusTypeDef  ret = HAL_OK;
 8106408:	2300      	movs	r3, #0
 810640a:	72fb      	strb	r3, [r7, #11]
  PCD_EPTypeDef *ep;

  if ((ep_addr & 0x80U) == 0x80U)
 810640c:	f997 3003 	ldrsb.w	r3, [r7, #3]
 8106410:	2b00      	cmp	r3, #0
 8106412:	da0f      	bge.n	8106434 <HAL_PCD_EP_Open+0x46>
  {
    ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
 8106414:	78fb      	ldrb	r3, [r7, #3]
 8106416:	f003 020f 	and.w	r2, r3, #15
 810641a:	4613      	mov	r3, r2
 810641c:	00db      	lsls	r3, r3, #3
 810641e:	4413      	add	r3, r2
 8106420:	009b      	lsls	r3, r3, #2
 8106422:	3310      	adds	r3, #16
 8106424:	687a      	ldr	r2, [r7, #4]
 8106426:	4413      	add	r3, r2
 8106428:	3304      	adds	r3, #4
 810642a:	60fb      	str	r3, [r7, #12]
    ep->is_in = 1U;
 810642c:	68fb      	ldr	r3, [r7, #12]
 810642e:	2201      	movs	r2, #1
 8106430:	705a      	strb	r2, [r3, #1]
 8106432:	e00f      	b.n	8106454 <HAL_PCD_EP_Open+0x66>
  }
  else
  {
    ep = &hpcd->OUT_ep[ep_addr & EP_ADDR_MSK];
 8106434:	78fb      	ldrb	r3, [r7, #3]
 8106436:	f003 020f 	and.w	r2, r3, #15
 810643a:	4613      	mov	r3, r2
 810643c:	00db      	lsls	r3, r3, #3
 810643e:	4413      	add	r3, r2
 8106440:	009b      	lsls	r3, r3, #2
 8106442:	f503 7314 	add.w	r3, r3, #592	; 0x250
 8106446:	687a      	ldr	r2, [r7, #4]
 8106448:	4413      	add	r3, r2
 810644a:	3304      	adds	r3, #4
 810644c:	60fb      	str	r3, [r7, #12]
    ep->is_in = 0U;
 810644e:	68fb      	ldr	r3, [r7, #12]
 8106450:	2200      	movs	r2, #0
 8106452:	705a      	strb	r2, [r3, #1]
  }

  ep->num = ep_addr & EP_ADDR_MSK;
 8106454:	78fb      	ldrb	r3, [r7, #3]
 8106456:	f003 030f 	and.w	r3, r3, #15
 810645a:	b2da      	uxtb	r2, r3
 810645c:	68fb      	ldr	r3, [r7, #12]
 810645e:	701a      	strb	r2, [r3, #0]
  ep->maxpacket = ep_mps;
 8106460:	883a      	ldrh	r2, [r7, #0]
 8106462:	68fb      	ldr	r3, [r7, #12]
 8106464:	609a      	str	r2, [r3, #8]
  ep->type = ep_type;
 8106466:	68fb      	ldr	r3, [r7, #12]
 8106468:	78ba      	ldrb	r2, [r7, #2]
 810646a:	711a      	strb	r2, [r3, #4]

  if (ep->is_in != 0U)
 810646c:	68fb      	ldr	r3, [r7, #12]
 810646e:	785b      	ldrb	r3, [r3, #1]
 8106470:	2b00      	cmp	r3, #0
 8106472:	d004      	beq.n	810647e <HAL_PCD_EP_Open+0x90>
  {
    /* Assign a Tx FIFO */
    ep->tx_fifo_num = ep->num;
 8106474:	68fb      	ldr	r3, [r7, #12]
 8106476:	781b      	ldrb	r3, [r3, #0]
 8106478:	b29a      	uxth	r2, r3
 810647a:	68fb      	ldr	r3, [r7, #12]
 810647c:	835a      	strh	r2, [r3, #26]
  }

  /* Set initial data PID. */
  if (ep_type == EP_TYPE_BULK)
 810647e:	78bb      	ldrb	r3, [r7, #2]
 8106480:	2b02      	cmp	r3, #2
 8106482:	d102      	bne.n	810648a <HAL_PCD_EP_Open+0x9c>
  {
    ep->data_pid_start = 0U;
 8106484:	68fb      	ldr	r3, [r7, #12]
 8106486:	2200      	movs	r2, #0
 8106488:	715a      	strb	r2, [r3, #5]
  }

  __HAL_LOCK(hpcd);
 810648a:	687b      	ldr	r3, [r7, #4]
 810648c:	f893 3494 	ldrb.w	r3, [r3, #1172]	; 0x494
 8106490:	2b01      	cmp	r3, #1
 8106492:	d101      	bne.n	8106498 <HAL_PCD_EP_Open+0xaa>
 8106494:	2302      	movs	r3, #2
 8106496:	e00e      	b.n	81064b6 <HAL_PCD_EP_Open+0xc8>
 8106498:	687b      	ldr	r3, [r7, #4]
 810649a:	2201      	movs	r2, #1
 810649c:	f883 2494 	strb.w	r2, [r3, #1172]	; 0x494
  (void)USB_ActivateEndpoint(hpcd->Instance, ep);
 81064a0:	687b      	ldr	r3, [r7, #4]
 81064a2:	681b      	ldr	r3, [r3, #0]
 81064a4:	68f9      	ldr	r1, [r7, #12]
 81064a6:	4618      	mov	r0, r3
 81064a8:	f004 ff4e 	bl	810b348 <USB_ActivateEndpoint>
  __HAL_UNLOCK(hpcd);
 81064ac:	687b      	ldr	r3, [r7, #4]
 81064ae:	2200      	movs	r2, #0
 81064b0:	f883 2494 	strb.w	r2, [r3, #1172]	; 0x494

  return ret;
 81064b4:	7afb      	ldrb	r3, [r7, #11]
}
 81064b6:	4618      	mov	r0, r3
 81064b8:	3710      	adds	r7, #16
 81064ba:	46bd      	mov	sp, r7
 81064bc:	bd80      	pop	{r7, pc}

081064be <HAL_PCD_EP_Close>:
  * @param  hpcd PCD handle
  * @param  ep_addr endpoint address
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_EP_Close(PCD_HandleTypeDef *hpcd, uint8_t ep_addr)
{
 81064be:	b580      	push	{r7, lr}
 81064c0:	b084      	sub	sp, #16
 81064c2:	af00      	add	r7, sp, #0
 81064c4:	6078      	str	r0, [r7, #4]
 81064c6:	460b      	mov	r3, r1
 81064c8:	70fb      	strb	r3, [r7, #3]
  PCD_EPTypeDef *ep;

  if ((ep_addr & 0x80U) == 0x80U)
 81064ca:	f997 3003 	ldrsb.w	r3, [r7, #3]
 81064ce:	2b00      	cmp	r3, #0
 81064d0:	da0f      	bge.n	81064f2 <HAL_PCD_EP_Close+0x34>
  {
    ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
 81064d2:	78fb      	ldrb	r3, [r7, #3]
 81064d4:	f003 020f 	and.w	r2, r3, #15
 81064d8:	4613      	mov	r3, r2
 81064da:	00db      	lsls	r3, r3, #3
 81064dc:	4413      	add	r3, r2
 81064de:	009b      	lsls	r3, r3, #2
 81064e0:	3310      	adds	r3, #16
 81064e2:	687a      	ldr	r2, [r7, #4]
 81064e4:	4413      	add	r3, r2
 81064e6:	3304      	adds	r3, #4
 81064e8:	60fb      	str	r3, [r7, #12]
    ep->is_in = 1U;
 81064ea:	68fb      	ldr	r3, [r7, #12]
 81064ec:	2201      	movs	r2, #1
 81064ee:	705a      	strb	r2, [r3, #1]
 81064f0:	e00f      	b.n	8106512 <HAL_PCD_EP_Close+0x54>
  }
  else
  {
    ep = &hpcd->OUT_ep[ep_addr & EP_ADDR_MSK];
 81064f2:	78fb      	ldrb	r3, [r7, #3]
 81064f4:	f003 020f 	and.w	r2, r3, #15
 81064f8:	4613      	mov	r3, r2
 81064fa:	00db      	lsls	r3, r3, #3
 81064fc:	4413      	add	r3, r2
 81064fe:	009b      	lsls	r3, r3, #2
 8106500:	f503 7314 	add.w	r3, r3, #592	; 0x250
 8106504:	687a      	ldr	r2, [r7, #4]
 8106506:	4413      	add	r3, r2
 8106508:	3304      	adds	r3, #4
 810650a:	60fb      	str	r3, [r7, #12]
    ep->is_in = 0U;
 810650c:	68fb      	ldr	r3, [r7, #12]
 810650e:	2200      	movs	r2, #0
 8106510:	705a      	strb	r2, [r3, #1]
  }
  ep->num = ep_addr & EP_ADDR_MSK;
 8106512:	78fb      	ldrb	r3, [r7, #3]
 8106514:	f003 030f 	and.w	r3, r3, #15
 8106518:	b2da      	uxtb	r2, r3
 810651a:	68fb      	ldr	r3, [r7, #12]
 810651c:	701a      	strb	r2, [r3, #0]

  __HAL_LOCK(hpcd);
 810651e:	687b      	ldr	r3, [r7, #4]
 8106520:	f893 3494 	ldrb.w	r3, [r3, #1172]	; 0x494
 8106524:	2b01      	cmp	r3, #1
 8106526:	d101      	bne.n	810652c <HAL_PCD_EP_Close+0x6e>
 8106528:	2302      	movs	r3, #2
 810652a:	e00e      	b.n	810654a <HAL_PCD_EP_Close+0x8c>
 810652c:	687b      	ldr	r3, [r7, #4]
 810652e:	2201      	movs	r2, #1
 8106530:	f883 2494 	strb.w	r2, [r3, #1172]	; 0x494
  (void)USB_DeactivateEndpoint(hpcd->Instance, ep);
 8106534:	687b      	ldr	r3, [r7, #4]
 8106536:	681b      	ldr	r3, [r3, #0]
 8106538:	68f9      	ldr	r1, [r7, #12]
 810653a:	4618      	mov	r0, r3
 810653c:	f004 ff8c 	bl	810b458 <USB_DeactivateEndpoint>
  __HAL_UNLOCK(hpcd);
 8106540:	687b      	ldr	r3, [r7, #4]
 8106542:	2200      	movs	r2, #0
 8106544:	f883 2494 	strb.w	r2, [r3, #1172]	; 0x494
  return HAL_OK;
 8106548:	2300      	movs	r3, #0
}
 810654a:	4618      	mov	r0, r3
 810654c:	3710      	adds	r7, #16
 810654e:	46bd      	mov	sp, r7
 8106550:	bd80      	pop	{r7, pc}

08106552 <HAL_PCD_EP_Receive>:
  * @param  pBuf pointer to the reception buffer
  * @param  len amount of data to be received
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_EP_Receive(PCD_HandleTypeDef *hpcd, uint8_t ep_addr, uint8_t *pBuf, uint32_t len)
{
 8106552:	b580      	push	{r7, lr}
 8106554:	b086      	sub	sp, #24
 8106556:	af00      	add	r7, sp, #0
 8106558:	60f8      	str	r0, [r7, #12]
 810655a:	607a      	str	r2, [r7, #4]
 810655c:	603b      	str	r3, [r7, #0]
 810655e:	460b      	mov	r3, r1
 8106560:	72fb      	strb	r3, [r7, #11]
  PCD_EPTypeDef *ep;

  ep = &hpcd->OUT_ep[ep_addr & EP_ADDR_MSK];
 8106562:	7afb      	ldrb	r3, [r7, #11]
 8106564:	f003 020f 	and.w	r2, r3, #15
 8106568:	4613      	mov	r3, r2
 810656a:	00db      	lsls	r3, r3, #3
 810656c:	4413      	add	r3, r2
 810656e:	009b      	lsls	r3, r3, #2
 8106570:	f503 7314 	add.w	r3, r3, #592	; 0x250
 8106574:	68fa      	ldr	r2, [r7, #12]
 8106576:	4413      	add	r3, r2
 8106578:	3304      	adds	r3, #4
 810657a:	617b      	str	r3, [r7, #20]

  /*setup and start the Xfer */
  ep->xfer_buff = pBuf;
 810657c:	697b      	ldr	r3, [r7, #20]
 810657e:	687a      	ldr	r2, [r7, #4]
 8106580:	60da      	str	r2, [r3, #12]
  ep->xfer_len = len;
 8106582:	697b      	ldr	r3, [r7, #20]
 8106584:	683a      	ldr	r2, [r7, #0]
 8106586:	611a      	str	r2, [r3, #16]
  ep->xfer_count = 0U;
 8106588:	697b      	ldr	r3, [r7, #20]
 810658a:	2200      	movs	r2, #0
 810658c:	615a      	str	r2, [r3, #20]
  ep->is_in = 0U;
 810658e:	697b      	ldr	r3, [r7, #20]
 8106590:	2200      	movs	r2, #0
 8106592:	705a      	strb	r2, [r3, #1]
  ep->num = ep_addr & EP_ADDR_MSK;
 8106594:	7afb      	ldrb	r3, [r7, #11]
 8106596:	f003 030f 	and.w	r3, r3, #15
 810659a:	b2da      	uxtb	r2, r3
 810659c:	697b      	ldr	r3, [r7, #20]
 810659e:	701a      	strb	r2, [r3, #0]

  if (hpcd->Init.dma_enable == 1U)
 81065a0:	68fb      	ldr	r3, [r7, #12]
 81065a2:	799b      	ldrb	r3, [r3, #6]
 81065a4:	2b01      	cmp	r3, #1
 81065a6:	d102      	bne.n	81065ae <HAL_PCD_EP_Receive+0x5c>
  {
    ep->dma_addr = (uint32_t)pBuf;
 81065a8:	687a      	ldr	r2, [r7, #4]
 81065aa:	697b      	ldr	r3, [r7, #20]
 81065ac:	61da      	str	r2, [r3, #28]
  }

  (void)USB_EPStartXfer(hpcd->Instance, ep, (uint8_t)hpcd->Init.dma_enable);
 81065ae:	68fb      	ldr	r3, [r7, #12]
 81065b0:	6818      	ldr	r0, [r3, #0]
 81065b2:	68fb      	ldr	r3, [r7, #12]
 81065b4:	799b      	ldrb	r3, [r3, #6]
 81065b6:	461a      	mov	r2, r3
 81065b8:	6979      	ldr	r1, [r7, #20]
 81065ba:	f005 f829 	bl	810b610 <USB_EPStartXfer>

  return HAL_OK;
 81065be:	2300      	movs	r3, #0
}
 81065c0:	4618      	mov	r0, r3
 81065c2:	3718      	adds	r7, #24
 81065c4:	46bd      	mov	sp, r7
 81065c6:	bd80      	pop	{r7, pc}

081065c8 <HAL_PCD_EP_Transmit>:
  * @param  pBuf pointer to the transmission buffer
  * @param  len amount of data to be sent
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_EP_Transmit(PCD_HandleTypeDef *hpcd, uint8_t ep_addr, uint8_t *pBuf, uint32_t len)
{
 81065c8:	b580      	push	{r7, lr}
 81065ca:	b086      	sub	sp, #24
 81065cc:	af00      	add	r7, sp, #0
 81065ce:	60f8      	str	r0, [r7, #12]
 81065d0:	607a      	str	r2, [r7, #4]
 81065d2:	603b      	str	r3, [r7, #0]
 81065d4:	460b      	mov	r3, r1
 81065d6:	72fb      	strb	r3, [r7, #11]
  PCD_EPTypeDef *ep;

  ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
 81065d8:	7afb      	ldrb	r3, [r7, #11]
 81065da:	f003 020f 	and.w	r2, r3, #15
 81065de:	4613      	mov	r3, r2
 81065e0:	00db      	lsls	r3, r3, #3
 81065e2:	4413      	add	r3, r2
 81065e4:	009b      	lsls	r3, r3, #2
 81065e6:	3310      	adds	r3, #16
 81065e8:	68fa      	ldr	r2, [r7, #12]
 81065ea:	4413      	add	r3, r2
 81065ec:	3304      	adds	r3, #4
 81065ee:	617b      	str	r3, [r7, #20]

  /*setup and start the Xfer */
  ep->xfer_buff = pBuf;
 81065f0:	697b      	ldr	r3, [r7, #20]
 81065f2:	687a      	ldr	r2, [r7, #4]
 81065f4:	60da      	str	r2, [r3, #12]
  ep->xfer_len = len;
 81065f6:	697b      	ldr	r3, [r7, #20]
 81065f8:	683a      	ldr	r2, [r7, #0]
 81065fa:	611a      	str	r2, [r3, #16]
  ep->xfer_count = 0U;
 81065fc:	697b      	ldr	r3, [r7, #20]
 81065fe:	2200      	movs	r2, #0
 8106600:	615a      	str	r2, [r3, #20]
  ep->is_in = 1U;
 8106602:	697b      	ldr	r3, [r7, #20]
 8106604:	2201      	movs	r2, #1
 8106606:	705a      	strb	r2, [r3, #1]
  ep->num = ep_addr & EP_ADDR_MSK;
 8106608:	7afb      	ldrb	r3, [r7, #11]
 810660a:	f003 030f 	and.w	r3, r3, #15
 810660e:	b2da      	uxtb	r2, r3
 8106610:	697b      	ldr	r3, [r7, #20]
 8106612:	701a      	strb	r2, [r3, #0]

  if (hpcd->Init.dma_enable == 1U)
 8106614:	68fb      	ldr	r3, [r7, #12]
 8106616:	799b      	ldrb	r3, [r3, #6]
 8106618:	2b01      	cmp	r3, #1
 810661a:	d102      	bne.n	8106622 <HAL_PCD_EP_Transmit+0x5a>
  {
    ep->dma_addr = (uint32_t)pBuf;
 810661c:	687a      	ldr	r2, [r7, #4]
 810661e:	697b      	ldr	r3, [r7, #20]
 8106620:	61da      	str	r2, [r3, #28]
  }

  (void)USB_EPStartXfer(hpcd->Instance, ep, (uint8_t)hpcd->Init.dma_enable);
 8106622:	68fb      	ldr	r3, [r7, #12]
 8106624:	6818      	ldr	r0, [r3, #0]
 8106626:	68fb      	ldr	r3, [r7, #12]
 8106628:	799b      	ldrb	r3, [r3, #6]
 810662a:	461a      	mov	r2, r3
 810662c:	6979      	ldr	r1, [r7, #20]
 810662e:	f004 ffef 	bl	810b610 <USB_EPStartXfer>

  return HAL_OK;
 8106632:	2300      	movs	r3, #0
}
 8106634:	4618      	mov	r0, r3
 8106636:	3718      	adds	r7, #24
 8106638:	46bd      	mov	sp, r7
 810663a:	bd80      	pop	{r7, pc}

0810663c <HAL_PCD_EP_SetStall>:
  * @param  hpcd PCD handle
  * @param  ep_addr endpoint address
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_EP_SetStall(PCD_HandleTypeDef *hpcd, uint8_t ep_addr)
{
 810663c:	b580      	push	{r7, lr}
 810663e:	b084      	sub	sp, #16
 8106640:	af00      	add	r7, sp, #0
 8106642:	6078      	str	r0, [r7, #4]
 8106644:	460b      	mov	r3, r1
 8106646:	70fb      	strb	r3, [r7, #3]
  PCD_EPTypeDef *ep;

  if (((uint32_t)ep_addr & EP_ADDR_MSK) > hpcd->Init.dev_endpoints)
 8106648:	78fb      	ldrb	r3, [r7, #3]
 810664a:	f003 030f 	and.w	r3, r3, #15
 810664e:	687a      	ldr	r2, [r7, #4]
 8106650:	7912      	ldrb	r2, [r2, #4]
 8106652:	4293      	cmp	r3, r2
 8106654:	d901      	bls.n	810665a <HAL_PCD_EP_SetStall+0x1e>
  {
    return HAL_ERROR;
 8106656:	2301      	movs	r3, #1
 8106658:	e04f      	b.n	81066fa <HAL_PCD_EP_SetStall+0xbe>
  }

  if ((0x80U & ep_addr) == 0x80U)
 810665a:	f997 3003 	ldrsb.w	r3, [r7, #3]
 810665e:	2b00      	cmp	r3, #0
 8106660:	da0f      	bge.n	8106682 <HAL_PCD_EP_SetStall+0x46>
  {
    ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
 8106662:	78fb      	ldrb	r3, [r7, #3]
 8106664:	f003 020f 	and.w	r2, r3, #15
 8106668:	4613      	mov	r3, r2
 810666a:	00db      	lsls	r3, r3, #3
 810666c:	4413      	add	r3, r2
 810666e:	009b      	lsls	r3, r3, #2
 8106670:	3310      	adds	r3, #16
 8106672:	687a      	ldr	r2, [r7, #4]
 8106674:	4413      	add	r3, r2
 8106676:	3304      	adds	r3, #4
 8106678:	60fb      	str	r3, [r7, #12]
    ep->is_in = 1U;
 810667a:	68fb      	ldr	r3, [r7, #12]
 810667c:	2201      	movs	r2, #1
 810667e:	705a      	strb	r2, [r3, #1]
 8106680:	e00d      	b.n	810669e <HAL_PCD_EP_SetStall+0x62>
  }
  else
  {
    ep = &hpcd->OUT_ep[ep_addr];
 8106682:	78fa      	ldrb	r2, [r7, #3]
 8106684:	4613      	mov	r3, r2
 8106686:	00db      	lsls	r3, r3, #3
 8106688:	4413      	add	r3, r2
 810668a:	009b      	lsls	r3, r3, #2
 810668c:	f503 7314 	add.w	r3, r3, #592	; 0x250
 8106690:	687a      	ldr	r2, [r7, #4]
 8106692:	4413      	add	r3, r2
 8106694:	3304      	adds	r3, #4
 8106696:	60fb      	str	r3, [r7, #12]
    ep->is_in = 0U;
 8106698:	68fb      	ldr	r3, [r7, #12]
 810669a:	2200      	movs	r2, #0
 810669c:	705a      	strb	r2, [r3, #1]
  }

  ep->is_stall = 1U;
 810669e:	68fb      	ldr	r3, [r7, #12]
 81066a0:	2201      	movs	r2, #1
 81066a2:	709a      	strb	r2, [r3, #2]
  ep->num = ep_addr & EP_ADDR_MSK;
 81066a4:	78fb      	ldrb	r3, [r7, #3]
 81066a6:	f003 030f 	and.w	r3, r3, #15
 81066aa:	b2da      	uxtb	r2, r3
 81066ac:	68fb      	ldr	r3, [r7, #12]
 81066ae:	701a      	strb	r2, [r3, #0]

  __HAL_LOCK(hpcd);
 81066b0:	687b      	ldr	r3, [r7, #4]
 81066b2:	f893 3494 	ldrb.w	r3, [r3, #1172]	; 0x494
 81066b6:	2b01      	cmp	r3, #1
 81066b8:	d101      	bne.n	81066be <HAL_PCD_EP_SetStall+0x82>
 81066ba:	2302      	movs	r3, #2
 81066bc:	e01d      	b.n	81066fa <HAL_PCD_EP_SetStall+0xbe>
 81066be:	687b      	ldr	r3, [r7, #4]
 81066c0:	2201      	movs	r2, #1
 81066c2:	f883 2494 	strb.w	r2, [r3, #1172]	; 0x494

  (void)USB_EPSetStall(hpcd->Instance, ep);
 81066c6:	687b      	ldr	r3, [r7, #4]
 81066c8:	681b      	ldr	r3, [r3, #0]
 81066ca:	68f9      	ldr	r1, [r7, #12]
 81066cc:	4618      	mov	r0, r3
 81066ce:	f005 fb77 	bl	810bdc0 <USB_EPSetStall>

  if ((ep_addr & EP_ADDR_MSK) == 0U)
 81066d2:	78fb      	ldrb	r3, [r7, #3]
 81066d4:	f003 030f 	and.w	r3, r3, #15
 81066d8:	2b00      	cmp	r3, #0
 81066da:	d109      	bne.n	81066f0 <HAL_PCD_EP_SetStall+0xb4>
  {
    (void)USB_EP0_OutStart(hpcd->Instance, (uint8_t)hpcd->Init.dma_enable, (uint8_t *)hpcd->Setup);
 81066dc:	687b      	ldr	r3, [r7, #4]
 81066de:	6818      	ldr	r0, [r3, #0]
 81066e0:	687b      	ldr	r3, [r7, #4]
 81066e2:	7999      	ldrb	r1, [r3, #6]
 81066e4:	687b      	ldr	r3, [r7, #4]
 81066e6:	f203 439c 	addw	r3, r3, #1180	; 0x49c
 81066ea:	461a      	mov	r2, r3
 81066ec:	f005 fd68 	bl	810c1c0 <USB_EP0_OutStart>
  }

  __HAL_UNLOCK(hpcd);
 81066f0:	687b      	ldr	r3, [r7, #4]
 81066f2:	2200      	movs	r2, #0
 81066f4:	f883 2494 	strb.w	r2, [r3, #1172]	; 0x494

  return HAL_OK;
 81066f8:	2300      	movs	r3, #0
}
 81066fa:	4618      	mov	r0, r3
 81066fc:	3710      	adds	r7, #16
 81066fe:	46bd      	mov	sp, r7
 8106700:	bd80      	pop	{r7, pc}

08106702 <HAL_PCD_EP_ClrStall>:
  * @param  hpcd PCD handle
  * @param  ep_addr endpoint address
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_EP_ClrStall(PCD_HandleTypeDef *hpcd, uint8_t ep_addr)
{
 8106702:	b580      	push	{r7, lr}
 8106704:	b084      	sub	sp, #16
 8106706:	af00      	add	r7, sp, #0
 8106708:	6078      	str	r0, [r7, #4]
 810670a:	460b      	mov	r3, r1
 810670c:	70fb      	strb	r3, [r7, #3]
  PCD_EPTypeDef *ep;

  if (((uint32_t)ep_addr & 0x0FU) > hpcd->Init.dev_endpoints)
 810670e:	78fb      	ldrb	r3, [r7, #3]
 8106710:	f003 030f 	and.w	r3, r3, #15
 8106714:	687a      	ldr	r2, [r7, #4]
 8106716:	7912      	ldrb	r2, [r2, #4]
 8106718:	4293      	cmp	r3, r2
 810671a:	d901      	bls.n	8106720 <HAL_PCD_EP_ClrStall+0x1e>
  {
    return HAL_ERROR;
 810671c:	2301      	movs	r3, #1
 810671e:	e042      	b.n	81067a6 <HAL_PCD_EP_ClrStall+0xa4>
  }

  if ((0x80U & ep_addr) == 0x80U)
 8106720:	f997 3003 	ldrsb.w	r3, [r7, #3]
 8106724:	2b00      	cmp	r3, #0
 8106726:	da0f      	bge.n	8106748 <HAL_PCD_EP_ClrStall+0x46>
  {
    ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
 8106728:	78fb      	ldrb	r3, [r7, #3]
 810672a:	f003 020f 	and.w	r2, r3, #15
 810672e:	4613      	mov	r3, r2
 8106730:	00db      	lsls	r3, r3, #3
 8106732:	4413      	add	r3, r2
 8106734:	009b      	lsls	r3, r3, #2
 8106736:	3310      	adds	r3, #16
 8106738:	687a      	ldr	r2, [r7, #4]
 810673a:	4413      	add	r3, r2
 810673c:	3304      	adds	r3, #4
 810673e:	60fb      	str	r3, [r7, #12]
    ep->is_in = 1U;
 8106740:	68fb      	ldr	r3, [r7, #12]
 8106742:	2201      	movs	r2, #1
 8106744:	705a      	strb	r2, [r3, #1]
 8106746:	e00f      	b.n	8106768 <HAL_PCD_EP_ClrStall+0x66>
  }
  else
  {
    ep = &hpcd->OUT_ep[ep_addr & EP_ADDR_MSK];
 8106748:	78fb      	ldrb	r3, [r7, #3]
 810674a:	f003 020f 	and.w	r2, r3, #15
 810674e:	4613      	mov	r3, r2
 8106750:	00db      	lsls	r3, r3, #3
 8106752:	4413      	add	r3, r2
 8106754:	009b      	lsls	r3, r3, #2
 8106756:	f503 7314 	add.w	r3, r3, #592	; 0x250
 810675a:	687a      	ldr	r2, [r7, #4]
 810675c:	4413      	add	r3, r2
 810675e:	3304      	adds	r3, #4
 8106760:	60fb      	str	r3, [r7, #12]
    ep->is_in = 0U;
 8106762:	68fb      	ldr	r3, [r7, #12]
 8106764:	2200      	movs	r2, #0
 8106766:	705a      	strb	r2, [r3, #1]
  }

  ep->is_stall = 0U;
 8106768:	68fb      	ldr	r3, [r7, #12]
 810676a:	2200      	movs	r2, #0
 810676c:	709a      	strb	r2, [r3, #2]
  ep->num = ep_addr & EP_ADDR_MSK;
 810676e:	78fb      	ldrb	r3, [r7, #3]
 8106770:	f003 030f 	and.w	r3, r3, #15
 8106774:	b2da      	uxtb	r2, r3
 8106776:	68fb      	ldr	r3, [r7, #12]
 8106778:	701a      	strb	r2, [r3, #0]

  __HAL_LOCK(hpcd);
 810677a:	687b      	ldr	r3, [r7, #4]
 810677c:	f893 3494 	ldrb.w	r3, [r3, #1172]	; 0x494
 8106780:	2b01      	cmp	r3, #1
 8106782:	d101      	bne.n	8106788 <HAL_PCD_EP_ClrStall+0x86>
 8106784:	2302      	movs	r3, #2
 8106786:	e00e      	b.n	81067a6 <HAL_PCD_EP_ClrStall+0xa4>
 8106788:	687b      	ldr	r3, [r7, #4]
 810678a:	2201      	movs	r2, #1
 810678c:	f883 2494 	strb.w	r2, [r3, #1172]	; 0x494
  (void)USB_EPClearStall(hpcd->Instance, ep);
 8106790:	687b      	ldr	r3, [r7, #4]
 8106792:	681b      	ldr	r3, [r3, #0]
 8106794:	68f9      	ldr	r1, [r7, #12]
 8106796:	4618      	mov	r0, r3
 8106798:	f005 fb80 	bl	810be9c <USB_EPClearStall>
  __HAL_UNLOCK(hpcd);
 810679c:	687b      	ldr	r3, [r7, #4]
 810679e:	2200      	movs	r2, #0
 81067a0:	f883 2494 	strb.w	r2, [r3, #1172]	; 0x494

  return HAL_OK;
 81067a4:	2300      	movs	r3, #0
}
 81067a6:	4618      	mov	r0, r3
 81067a8:	3710      	adds	r7, #16
 81067aa:	46bd      	mov	sp, r7
 81067ac:	bd80      	pop	{r7, pc}

081067ae <HAL_PCD_EP_Abort>:
   * @param  hpcd PCD handle
   * @param  ep_addr endpoint address
   * @retval HAL status
   */
HAL_StatusTypeDef HAL_PCD_EP_Abort(PCD_HandleTypeDef *hpcd, uint8_t ep_addr)
{
 81067ae:	b580      	push	{r7, lr}
 81067b0:	b084      	sub	sp, #16
 81067b2:	af00      	add	r7, sp, #0
 81067b4:	6078      	str	r0, [r7, #4]
 81067b6:	460b      	mov	r3, r1
 81067b8:	70fb      	strb	r3, [r7, #3]
  HAL_StatusTypeDef ret;
  PCD_EPTypeDef *ep;

  if ((0x80U & ep_addr) == 0x80U)
 81067ba:	f997 3003 	ldrsb.w	r3, [r7, #3]
 81067be:	2b00      	cmp	r3, #0
 81067c0:	da0c      	bge.n	81067dc <HAL_PCD_EP_Abort+0x2e>
  {
    ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
 81067c2:	78fb      	ldrb	r3, [r7, #3]
 81067c4:	f003 020f 	and.w	r2, r3, #15
 81067c8:	4613      	mov	r3, r2
 81067ca:	00db      	lsls	r3, r3, #3
 81067cc:	4413      	add	r3, r2
 81067ce:	009b      	lsls	r3, r3, #2
 81067d0:	3310      	adds	r3, #16
 81067d2:	687a      	ldr	r2, [r7, #4]
 81067d4:	4413      	add	r3, r2
 81067d6:	3304      	adds	r3, #4
 81067d8:	60fb      	str	r3, [r7, #12]
 81067da:	e00c      	b.n	81067f6 <HAL_PCD_EP_Abort+0x48>
  }
  else
  {
    ep = &hpcd->OUT_ep[ep_addr & EP_ADDR_MSK];
 81067dc:	78fb      	ldrb	r3, [r7, #3]
 81067de:	f003 020f 	and.w	r2, r3, #15
 81067e2:	4613      	mov	r3, r2
 81067e4:	00db      	lsls	r3, r3, #3
 81067e6:	4413      	add	r3, r2
 81067e8:	009b      	lsls	r3, r3, #2
 81067ea:	f503 7314 	add.w	r3, r3, #592	; 0x250
 81067ee:	687a      	ldr	r2, [r7, #4]
 81067f0:	4413      	add	r3, r2
 81067f2:	3304      	adds	r3, #4
 81067f4:	60fb      	str	r3, [r7, #12]
  }

  /* Stop Xfer */
  ret = USB_EPStopXfer(hpcd->Instance, ep);
 81067f6:	687b      	ldr	r3, [r7, #4]
 81067f8:	681b      	ldr	r3, [r3, #0]
 81067fa:	68f9      	ldr	r1, [r7, #12]
 81067fc:	4618      	mov	r0, r3
 81067fe:	f005 f99f 	bl	810bb40 <USB_EPStopXfer>
 8106802:	4603      	mov	r3, r0
 8106804:	72fb      	strb	r3, [r7, #11]

  return ret;
 8106806:	7afb      	ldrb	r3, [r7, #11]
}
 8106808:	4618      	mov	r0, r3
 810680a:	3710      	adds	r7, #16
 810680c:	46bd      	mov	sp, r7
 810680e:	bd80      	pop	{r7, pc}

08106810 <PCD_WriteEmptyTxFifo>:
  * @param  hpcd PCD handle
  * @param  epnum endpoint number
  * @retval HAL status
  */
static HAL_StatusTypeDef PCD_WriteEmptyTxFifo(PCD_HandleTypeDef *hpcd, uint32_t epnum)
{
 8106810:	b580      	push	{r7, lr}
 8106812:	b08a      	sub	sp, #40	; 0x28
 8106814:	af02      	add	r7, sp, #8
 8106816:	6078      	str	r0, [r7, #4]
 8106818:	6039      	str	r1, [r7, #0]
  USB_OTG_GlobalTypeDef *USBx = hpcd->Instance;
 810681a:	687b      	ldr	r3, [r7, #4]
 810681c:	681b      	ldr	r3, [r3, #0]
 810681e:	617b      	str	r3, [r7, #20]
  uint32_t USBx_BASE = (uint32_t)USBx;
 8106820:	697b      	ldr	r3, [r7, #20]
 8106822:	613b      	str	r3, [r7, #16]
  USB_OTG_EPTypeDef *ep;
  uint32_t len;
  uint32_t len32b;
  uint32_t fifoemptymsk;

  ep = &hpcd->IN_ep[epnum];
 8106824:	683a      	ldr	r2, [r7, #0]
 8106826:	4613      	mov	r3, r2
 8106828:	00db      	lsls	r3, r3, #3
 810682a:	4413      	add	r3, r2
 810682c:	009b      	lsls	r3, r3, #2
 810682e:	3310      	adds	r3, #16
 8106830:	687a      	ldr	r2, [r7, #4]
 8106832:	4413      	add	r3, r2
 8106834:	3304      	adds	r3, #4
 8106836:	60fb      	str	r3, [r7, #12]

  if (ep->xfer_count > ep->xfer_len)
 8106838:	68fb      	ldr	r3, [r7, #12]
 810683a:	695a      	ldr	r2, [r3, #20]
 810683c:	68fb      	ldr	r3, [r7, #12]
 810683e:	691b      	ldr	r3, [r3, #16]
 8106840:	429a      	cmp	r2, r3
 8106842:	d901      	bls.n	8106848 <PCD_WriteEmptyTxFifo+0x38>
  {
    return HAL_ERROR;
 8106844:	2301      	movs	r3, #1
 8106846:	e06b      	b.n	8106920 <PCD_WriteEmptyTxFifo+0x110>
  }

  len = ep->xfer_len - ep->xfer_count;
 8106848:	68fb      	ldr	r3, [r7, #12]
 810684a:	691a      	ldr	r2, [r3, #16]
 810684c:	68fb      	ldr	r3, [r7, #12]
 810684e:	695b      	ldr	r3, [r3, #20]
 8106850:	1ad3      	subs	r3, r2, r3
 8106852:	61fb      	str	r3, [r7, #28]

  if (len > ep->maxpacket)
 8106854:	68fb      	ldr	r3, [r7, #12]
 8106856:	689b      	ldr	r3, [r3, #8]
 8106858:	69fa      	ldr	r2, [r7, #28]
 810685a:	429a      	cmp	r2, r3
 810685c:	d902      	bls.n	8106864 <PCD_WriteEmptyTxFifo+0x54>
  {
    len = ep->maxpacket;
 810685e:	68fb      	ldr	r3, [r7, #12]
 8106860:	689b      	ldr	r3, [r3, #8]
 8106862:	61fb      	str	r3, [r7, #28]
  }

  len32b = (len + 3U) / 4U;
 8106864:	69fb      	ldr	r3, [r7, #28]
 8106866:	3303      	adds	r3, #3
 8106868:	089b      	lsrs	r3, r3, #2
 810686a:	61bb      	str	r3, [r7, #24]

  while (((USBx_INEP(epnum)->DTXFSTS & USB_OTG_DTXFSTS_INEPTFSAV) >= len32b) &&
 810686c:	e02a      	b.n	81068c4 <PCD_WriteEmptyTxFifo+0xb4>
         (ep->xfer_count < ep->xfer_len) && (ep->xfer_len != 0U))
  {
    /* Write the FIFO */
    len = ep->xfer_len - ep->xfer_count;
 810686e:	68fb      	ldr	r3, [r7, #12]
 8106870:	691a      	ldr	r2, [r3, #16]
 8106872:	68fb      	ldr	r3, [r7, #12]
 8106874:	695b      	ldr	r3, [r3, #20]
 8106876:	1ad3      	subs	r3, r2, r3
 8106878:	61fb      	str	r3, [r7, #28]

    if (len > ep->maxpacket)
 810687a:	68fb      	ldr	r3, [r7, #12]
 810687c:	689b      	ldr	r3, [r3, #8]
 810687e:	69fa      	ldr	r2, [r7, #28]
 8106880:	429a      	cmp	r2, r3
 8106882:	d902      	bls.n	810688a <PCD_WriteEmptyTxFifo+0x7a>
    {
      len = ep->maxpacket;
 8106884:	68fb      	ldr	r3, [r7, #12]
 8106886:	689b      	ldr	r3, [r3, #8]
 8106888:	61fb      	str	r3, [r7, #28]
    }
    len32b = (len + 3U) / 4U;
 810688a:	69fb      	ldr	r3, [r7, #28]
 810688c:	3303      	adds	r3, #3
 810688e:	089b      	lsrs	r3, r3, #2
 8106890:	61bb      	str	r3, [r7, #24]

    (void)USB_WritePacket(USBx, ep->xfer_buff, (uint8_t)epnum, (uint16_t)len,
 8106892:	68fb      	ldr	r3, [r7, #12]
 8106894:	68d9      	ldr	r1, [r3, #12]
 8106896:	683b      	ldr	r3, [r7, #0]
 8106898:	b2da      	uxtb	r2, r3
 810689a:	69fb      	ldr	r3, [r7, #28]
 810689c:	b298      	uxth	r0, r3
                          (uint8_t)hpcd->Init.dma_enable);
 810689e:	687b      	ldr	r3, [r7, #4]
 81068a0:	799b      	ldrb	r3, [r3, #6]
    (void)USB_WritePacket(USBx, ep->xfer_buff, (uint8_t)epnum, (uint16_t)len,
 81068a2:	9300      	str	r3, [sp, #0]
 81068a4:	4603      	mov	r3, r0
 81068a6:	6978      	ldr	r0, [r7, #20]
 81068a8:	f005 f9f4 	bl	810bc94 <USB_WritePacket>

    ep->xfer_buff  += len;
 81068ac:	68fb      	ldr	r3, [r7, #12]
 81068ae:	68da      	ldr	r2, [r3, #12]
 81068b0:	69fb      	ldr	r3, [r7, #28]
 81068b2:	441a      	add	r2, r3
 81068b4:	68fb      	ldr	r3, [r7, #12]
 81068b6:	60da      	str	r2, [r3, #12]
    ep->xfer_count += len;
 81068b8:	68fb      	ldr	r3, [r7, #12]
 81068ba:	695a      	ldr	r2, [r3, #20]
 81068bc:	69fb      	ldr	r3, [r7, #28]
 81068be:	441a      	add	r2, r3
 81068c0:	68fb      	ldr	r3, [r7, #12]
 81068c2:	615a      	str	r2, [r3, #20]
  while (((USBx_INEP(epnum)->DTXFSTS & USB_OTG_DTXFSTS_INEPTFSAV) >= len32b) &&
 81068c4:	683b      	ldr	r3, [r7, #0]
 81068c6:	015a      	lsls	r2, r3, #5
 81068c8:	693b      	ldr	r3, [r7, #16]
 81068ca:	4413      	add	r3, r2
 81068cc:	f503 6310 	add.w	r3, r3, #2304	; 0x900
 81068d0:	699b      	ldr	r3, [r3, #24]
 81068d2:	b29b      	uxth	r3, r3
         (ep->xfer_count < ep->xfer_len) && (ep->xfer_len != 0U))
 81068d4:	69ba      	ldr	r2, [r7, #24]
 81068d6:	429a      	cmp	r2, r3
 81068d8:	d809      	bhi.n	81068ee <PCD_WriteEmptyTxFifo+0xde>
 81068da:	68fb      	ldr	r3, [r7, #12]
 81068dc:	695a      	ldr	r2, [r3, #20]
 81068de:	68fb      	ldr	r3, [r7, #12]
 81068e0:	691b      	ldr	r3, [r3, #16]
  while (((USBx_INEP(epnum)->DTXFSTS & USB_OTG_DTXFSTS_INEPTFSAV) >= len32b) &&
 81068e2:	429a      	cmp	r2, r3
 81068e4:	d203      	bcs.n	81068ee <PCD_WriteEmptyTxFifo+0xde>
         (ep->xfer_count < ep->xfer_len) && (ep->xfer_len != 0U))
 81068e6:	68fb      	ldr	r3, [r7, #12]
 81068e8:	691b      	ldr	r3, [r3, #16]
 81068ea:	2b00      	cmp	r3, #0
 81068ec:	d1bf      	bne.n	810686e <PCD_WriteEmptyTxFifo+0x5e>
  }

  if (ep->xfer_len <= ep->xfer_count)
 81068ee:	68fb      	ldr	r3, [r7, #12]
 81068f0:	691a      	ldr	r2, [r3, #16]
 81068f2:	68fb      	ldr	r3, [r7, #12]
 81068f4:	695b      	ldr	r3, [r3, #20]
 81068f6:	429a      	cmp	r2, r3
 81068f8:	d811      	bhi.n	810691e <PCD_WriteEmptyTxFifo+0x10e>
  {
    fifoemptymsk = (uint32_t)(0x1UL << (epnum & EP_ADDR_MSK));
 81068fa:	683b      	ldr	r3, [r7, #0]
 81068fc:	f003 030f 	and.w	r3, r3, #15
 8106900:	2201      	movs	r2, #1
 8106902:	fa02 f303 	lsl.w	r3, r2, r3
 8106906:	60bb      	str	r3, [r7, #8]
    USBx_DEVICE->DIEPEMPMSK &= ~fifoemptymsk;
 8106908:	693b      	ldr	r3, [r7, #16]
 810690a:	f503 6300 	add.w	r3, r3, #2048	; 0x800
 810690e:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8106910:	68bb      	ldr	r3, [r7, #8]
 8106912:	43db      	mvns	r3, r3
 8106914:	6939      	ldr	r1, [r7, #16]
 8106916:	f501 6100 	add.w	r1, r1, #2048	; 0x800
 810691a:	4013      	ands	r3, r2
 810691c:	634b      	str	r3, [r1, #52]	; 0x34
  }

  return HAL_OK;
 810691e:	2300      	movs	r3, #0
}
 8106920:	4618      	mov	r0, r3
 8106922:	3720      	adds	r7, #32
 8106924:	46bd      	mov	sp, r7
 8106926:	bd80      	pop	{r7, pc}

08106928 <PCD_EP_OutXfrComplete_int>:
  * @param  hpcd PCD handle
  * @param  epnum endpoint number
  * @retval HAL status
  */
static HAL_StatusTypeDef PCD_EP_OutXfrComplete_int(PCD_HandleTypeDef *hpcd, uint32_t epnum)
{
 8106928:	b580      	push	{r7, lr}
 810692a:	b088      	sub	sp, #32
 810692c:	af00      	add	r7, sp, #0
 810692e:	6078      	str	r0, [r7, #4]
 8106930:	6039      	str	r1, [r7, #0]
  USB_OTG_EPTypeDef *ep;
  const USB_OTG_GlobalTypeDef *USBx = hpcd->Instance;
 8106932:	687b      	ldr	r3, [r7, #4]
 8106934:	681b      	ldr	r3, [r3, #0]
 8106936:	61fb      	str	r3, [r7, #28]
  uint32_t USBx_BASE = (uint32_t)USBx;
 8106938:	69fb      	ldr	r3, [r7, #28]
 810693a:	61bb      	str	r3, [r7, #24]
  uint32_t gSNPSiD = *(__IO const uint32_t *)(&USBx->CID + 0x1U);
 810693c:	69fb      	ldr	r3, [r7, #28]
 810693e:	333c      	adds	r3, #60	; 0x3c
 8106940:	3304      	adds	r3, #4
 8106942:	681b      	ldr	r3, [r3, #0]
 8106944:	617b      	str	r3, [r7, #20]
  uint32_t DoepintReg = USBx_OUTEP(epnum)->DOEPINT;
 8106946:	683b      	ldr	r3, [r7, #0]
 8106948:	015a      	lsls	r2, r3, #5
 810694a:	69bb      	ldr	r3, [r7, #24]
 810694c:	4413      	add	r3, r2
 810694e:	f503 6330 	add.w	r3, r3, #2816	; 0xb00
 8106952:	689b      	ldr	r3, [r3, #8]
 8106954:	613b      	str	r3, [r7, #16]

  if (hpcd->Init.dma_enable == 1U)
 8106956:	687b      	ldr	r3, [r7, #4]
 8106958:	799b      	ldrb	r3, [r3, #6]
 810695a:	2b01      	cmp	r3, #1
 810695c:	d17b      	bne.n	8106a56 <PCD_EP_OutXfrComplete_int+0x12e>
  {
    if ((DoepintReg & USB_OTG_DOEPINT_STUP) == USB_OTG_DOEPINT_STUP) /* Class C */
 810695e:	693b      	ldr	r3, [r7, #16]
 8106960:	f003 0308 	and.w	r3, r3, #8
 8106964:	2b00      	cmp	r3, #0
 8106966:	d015      	beq.n	8106994 <PCD_EP_OutXfrComplete_int+0x6c>
    {
      /* StupPktRcvd = 1 this is a setup packet */
      if ((gSNPSiD > USB_OTG_CORE_ID_300A) &&
 8106968:	697b      	ldr	r3, [r7, #20]
 810696a:	4a61      	ldr	r2, [pc, #388]	; (8106af0 <PCD_EP_OutXfrComplete_int+0x1c8>)
 810696c:	4293      	cmp	r3, r2
 810696e:	f240 80b9 	bls.w	8106ae4 <PCD_EP_OutXfrComplete_int+0x1bc>
          ((DoepintReg & USB_OTG_DOEPINT_STPKTRX) == USB_OTG_DOEPINT_STPKTRX))
 8106972:	693b      	ldr	r3, [r7, #16]
 8106974:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
      if ((gSNPSiD > USB_OTG_CORE_ID_300A) &&
 8106978:	2b00      	cmp	r3, #0
 810697a:	f000 80b3 	beq.w	8106ae4 <PCD_EP_OutXfrComplete_int+0x1bc>
      {
        CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_STPKTRX);
 810697e:	683b      	ldr	r3, [r7, #0]
 8106980:	015a      	lsls	r2, r3, #5
 8106982:	69bb      	ldr	r3, [r7, #24]
 8106984:	4413      	add	r3, r2
 8106986:	f503 6330 	add.w	r3, r3, #2816	; 0xb00
 810698a:	461a      	mov	r2, r3
 810698c:	f44f 4300 	mov.w	r3, #32768	; 0x8000
 8106990:	6093      	str	r3, [r2, #8]
 8106992:	e0a7      	b.n	8106ae4 <PCD_EP_OutXfrComplete_int+0x1bc>
      }
    }
    else if ((DoepintReg & USB_OTG_DOEPINT_OTEPSPR) == USB_OTG_DOEPINT_OTEPSPR) /* Class E */
 8106994:	693b      	ldr	r3, [r7, #16]
 8106996:	f003 0320 	and.w	r3, r3, #32
 810699a:	2b00      	cmp	r3, #0
 810699c:	d009      	beq.n	81069b2 <PCD_EP_OutXfrComplete_int+0x8a>
    {
      CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_OTEPSPR);
 810699e:	683b      	ldr	r3, [r7, #0]
 81069a0:	015a      	lsls	r2, r3, #5
 81069a2:	69bb      	ldr	r3, [r7, #24]
 81069a4:	4413      	add	r3, r2
 81069a6:	f503 6330 	add.w	r3, r3, #2816	; 0xb00
 81069aa:	461a      	mov	r2, r3
 81069ac:	2320      	movs	r3, #32
 81069ae:	6093      	str	r3, [r2, #8]
 81069b0:	e098      	b.n	8106ae4 <PCD_EP_OutXfrComplete_int+0x1bc>
    }
    else if ((DoepintReg & (USB_OTG_DOEPINT_STUP | USB_OTG_DOEPINT_OTEPSPR)) == 0U)
 81069b2:	693b      	ldr	r3, [r7, #16]
 81069b4:	f003 0328 	and.w	r3, r3, #40	; 0x28
 81069b8:	2b00      	cmp	r3, #0
 81069ba:	f040 8093 	bne.w	8106ae4 <PCD_EP_OutXfrComplete_int+0x1bc>
    {
      /* StupPktRcvd = 1 this is a setup packet */
      if ((gSNPSiD > USB_OTG_CORE_ID_300A) &&
 81069be:	697b      	ldr	r3, [r7, #20]
 81069c0:	4a4b      	ldr	r2, [pc, #300]	; (8106af0 <PCD_EP_OutXfrComplete_int+0x1c8>)
 81069c2:	4293      	cmp	r3, r2
 81069c4:	d90f      	bls.n	81069e6 <PCD_EP_OutXfrComplete_int+0xbe>
          ((DoepintReg & USB_OTG_DOEPINT_STPKTRX) == USB_OTG_DOEPINT_STPKTRX))
 81069c6:	693b      	ldr	r3, [r7, #16]
 81069c8:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
      if ((gSNPSiD > USB_OTG_CORE_ID_300A) &&
 81069cc:	2b00      	cmp	r3, #0
 81069ce:	d00a      	beq.n	81069e6 <PCD_EP_OutXfrComplete_int+0xbe>
      {
        CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_STPKTRX);
 81069d0:	683b      	ldr	r3, [r7, #0]
 81069d2:	015a      	lsls	r2, r3, #5
 81069d4:	69bb      	ldr	r3, [r7, #24]
 81069d6:	4413      	add	r3, r2
 81069d8:	f503 6330 	add.w	r3, r3, #2816	; 0xb00
 81069dc:	461a      	mov	r2, r3
 81069de:	f44f 4300 	mov.w	r3, #32768	; 0x8000
 81069e2:	6093      	str	r3, [r2, #8]
 81069e4:	e07e      	b.n	8106ae4 <PCD_EP_OutXfrComplete_int+0x1bc>
      }
      else
      {
        ep = &hpcd->OUT_ep[epnum];
 81069e6:	683a      	ldr	r2, [r7, #0]
 81069e8:	4613      	mov	r3, r2
 81069ea:	00db      	lsls	r3, r3, #3
 81069ec:	4413      	add	r3, r2
 81069ee:	009b      	lsls	r3, r3, #2
 81069f0:	f503 7314 	add.w	r3, r3, #592	; 0x250
 81069f4:	687a      	ldr	r2, [r7, #4]
 81069f6:	4413      	add	r3, r2
 81069f8:	3304      	adds	r3, #4
 81069fa:	60fb      	str	r3, [r7, #12]

        /* out data packet received over EP */
        ep->xfer_count = ep->xfer_size - (USBx_OUTEP(epnum)->DOEPTSIZ & USB_OTG_DOEPTSIZ_XFRSIZ);
 81069fc:	68fb      	ldr	r3, [r7, #12]
 81069fe:	6a1a      	ldr	r2, [r3, #32]
 8106a00:	683b      	ldr	r3, [r7, #0]
 8106a02:	0159      	lsls	r1, r3, #5
 8106a04:	69bb      	ldr	r3, [r7, #24]
 8106a06:	440b      	add	r3, r1
 8106a08:	f503 6330 	add.w	r3, r3, #2816	; 0xb00
 8106a0c:	691b      	ldr	r3, [r3, #16]
 8106a0e:	f3c3 0312 	ubfx	r3, r3, #0, #19
 8106a12:	1ad2      	subs	r2, r2, r3
 8106a14:	68fb      	ldr	r3, [r7, #12]
 8106a16:	615a      	str	r2, [r3, #20]

        if (epnum == 0U)
 8106a18:	683b      	ldr	r3, [r7, #0]
 8106a1a:	2b00      	cmp	r3, #0
 8106a1c:	d114      	bne.n	8106a48 <PCD_EP_OutXfrComplete_int+0x120>
        {
          if (ep->xfer_len == 0U)
 8106a1e:	68fb      	ldr	r3, [r7, #12]
 8106a20:	691b      	ldr	r3, [r3, #16]
 8106a22:	2b00      	cmp	r3, #0
 8106a24:	d109      	bne.n	8106a3a <PCD_EP_OutXfrComplete_int+0x112>
          {
            /* this is ZLP, so prepare EP0 for next setup */
            (void)USB_EP0_OutStart(hpcd->Instance, 1U, (uint8_t *)hpcd->Setup);
 8106a26:	687b      	ldr	r3, [r7, #4]
 8106a28:	6818      	ldr	r0, [r3, #0]
 8106a2a:	687b      	ldr	r3, [r7, #4]
 8106a2c:	f203 439c 	addw	r3, r3, #1180	; 0x49c
 8106a30:	461a      	mov	r2, r3
 8106a32:	2101      	movs	r1, #1
 8106a34:	f005 fbc4 	bl	810c1c0 <USB_EP0_OutStart>
 8106a38:	e006      	b.n	8106a48 <PCD_EP_OutXfrComplete_int+0x120>
          }
          else
          {
            ep->xfer_buff += ep->xfer_count;
 8106a3a:	68fb      	ldr	r3, [r7, #12]
 8106a3c:	68da      	ldr	r2, [r3, #12]
 8106a3e:	68fb      	ldr	r3, [r7, #12]
 8106a40:	695b      	ldr	r3, [r3, #20]
 8106a42:	441a      	add	r2, r3
 8106a44:	68fb      	ldr	r3, [r7, #12]
 8106a46:	60da      	str	r2, [r3, #12]
        }

#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
        hpcd->DataOutStageCallback(hpcd, (uint8_t)epnum);
#else
        HAL_PCD_DataOutStageCallback(hpcd, (uint8_t)epnum);
 8106a48:	683b      	ldr	r3, [r7, #0]
 8106a4a:	b2db      	uxtb	r3, r3
 8106a4c:	4619      	mov	r1, r3
 8106a4e:	6878      	ldr	r0, [r7, #4]
 8106a50:	f014 fb48 	bl	811b0e4 <HAL_PCD_DataOutStageCallback>
 8106a54:	e046      	b.n	8106ae4 <PCD_EP_OutXfrComplete_int+0x1bc>
      /* ... */
    }
  }
  else
  {
    if (gSNPSiD == USB_OTG_CORE_ID_310A)
 8106a56:	697b      	ldr	r3, [r7, #20]
 8106a58:	4a26      	ldr	r2, [pc, #152]	; (8106af4 <PCD_EP_OutXfrComplete_int+0x1cc>)
 8106a5a:	4293      	cmp	r3, r2
 8106a5c:	d124      	bne.n	8106aa8 <PCD_EP_OutXfrComplete_int+0x180>
    {
      /* StupPktRcvd = 1 this is a setup packet */
      if ((DoepintReg & USB_OTG_DOEPINT_STPKTRX) == USB_OTG_DOEPINT_STPKTRX)
 8106a5e:	693b      	ldr	r3, [r7, #16]
 8106a60:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
 8106a64:	2b00      	cmp	r3, #0
 8106a66:	d00a      	beq.n	8106a7e <PCD_EP_OutXfrComplete_int+0x156>
      {
        CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_STPKTRX);
 8106a68:	683b      	ldr	r3, [r7, #0]
 8106a6a:	015a      	lsls	r2, r3, #5
 8106a6c:	69bb      	ldr	r3, [r7, #24]
 8106a6e:	4413      	add	r3, r2
 8106a70:	f503 6330 	add.w	r3, r3, #2816	; 0xb00
 8106a74:	461a      	mov	r2, r3
 8106a76:	f44f 4300 	mov.w	r3, #32768	; 0x8000
 8106a7a:	6093      	str	r3, [r2, #8]
 8106a7c:	e032      	b.n	8106ae4 <PCD_EP_OutXfrComplete_int+0x1bc>
      }
      else
      {
        if ((DoepintReg & USB_OTG_DOEPINT_OTEPSPR) == USB_OTG_DOEPINT_OTEPSPR)
 8106a7e:	693b      	ldr	r3, [r7, #16]
 8106a80:	f003 0320 	and.w	r3, r3, #32
 8106a84:	2b00      	cmp	r3, #0
 8106a86:	d008      	beq.n	8106a9a <PCD_EP_OutXfrComplete_int+0x172>
        {
          CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_OTEPSPR);
 8106a88:	683b      	ldr	r3, [r7, #0]
 8106a8a:	015a      	lsls	r2, r3, #5
 8106a8c:	69bb      	ldr	r3, [r7, #24]
 8106a8e:	4413      	add	r3, r2
 8106a90:	f503 6330 	add.w	r3, r3, #2816	; 0xb00
 8106a94:	461a      	mov	r2, r3
 8106a96:	2320      	movs	r3, #32
 8106a98:	6093      	str	r3, [r2, #8]
        }

#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
        hpcd->DataOutStageCallback(hpcd, (uint8_t)epnum);
#else
        HAL_PCD_DataOutStageCallback(hpcd, (uint8_t)epnum);
 8106a9a:	683b      	ldr	r3, [r7, #0]
 8106a9c:	b2db      	uxtb	r3, r3
 8106a9e:	4619      	mov	r1, r3
 8106aa0:	6878      	ldr	r0, [r7, #4]
 8106aa2:	f014 fb1f 	bl	811b0e4 <HAL_PCD_DataOutStageCallback>
 8106aa6:	e01d      	b.n	8106ae4 <PCD_EP_OutXfrComplete_int+0x1bc>
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
      }
    }
    else
    {
      if ((epnum == 0U) && (hpcd->OUT_ep[epnum].xfer_len == 0U))
 8106aa8:	683b      	ldr	r3, [r7, #0]
 8106aaa:	2b00      	cmp	r3, #0
 8106aac:	d114      	bne.n	8106ad8 <PCD_EP_OutXfrComplete_int+0x1b0>
 8106aae:	6879      	ldr	r1, [r7, #4]
 8106ab0:	683a      	ldr	r2, [r7, #0]
 8106ab2:	4613      	mov	r3, r2
 8106ab4:	00db      	lsls	r3, r3, #3
 8106ab6:	4413      	add	r3, r2
 8106ab8:	009b      	lsls	r3, r3, #2
 8106aba:	440b      	add	r3, r1
 8106abc:	f503 7319 	add.w	r3, r3, #612	; 0x264
 8106ac0:	681b      	ldr	r3, [r3, #0]
 8106ac2:	2b00      	cmp	r3, #0
 8106ac4:	d108      	bne.n	8106ad8 <PCD_EP_OutXfrComplete_int+0x1b0>
      {
        /* this is ZLP, so prepare EP0 for next setup */
        (void)USB_EP0_OutStart(hpcd->Instance, 0U, (uint8_t *)hpcd->Setup);
 8106ac6:	687b      	ldr	r3, [r7, #4]
 8106ac8:	6818      	ldr	r0, [r3, #0]
 8106aca:	687b      	ldr	r3, [r7, #4]
 8106acc:	f203 439c 	addw	r3, r3, #1180	; 0x49c
 8106ad0:	461a      	mov	r2, r3
 8106ad2:	2100      	movs	r1, #0
 8106ad4:	f005 fb74 	bl	810c1c0 <USB_EP0_OutStart>
      }

#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
      hpcd->DataOutStageCallback(hpcd, (uint8_t)epnum);
#else
      HAL_PCD_DataOutStageCallback(hpcd, (uint8_t)epnum);
 8106ad8:	683b      	ldr	r3, [r7, #0]
 8106ada:	b2db      	uxtb	r3, r3
 8106adc:	4619      	mov	r1, r3
 8106ade:	6878      	ldr	r0, [r7, #4]
 8106ae0:	f014 fb00 	bl	811b0e4 <HAL_PCD_DataOutStageCallback>
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
    }
  }

  return HAL_OK;
 8106ae4:	2300      	movs	r3, #0
}
 8106ae6:	4618      	mov	r0, r3
 8106ae8:	3720      	adds	r7, #32
 8106aea:	46bd      	mov	sp, r7
 8106aec:	bd80      	pop	{r7, pc}
 8106aee:	bf00      	nop
 8106af0:	4f54300a 	.word	0x4f54300a
 8106af4:	4f54310a 	.word	0x4f54310a

08106af8 <PCD_EP_OutSetupPacket_int>:
  * @param  hpcd PCD handle
  * @param  epnum endpoint number
  * @retval HAL status
  */
static HAL_StatusTypeDef PCD_EP_OutSetupPacket_int(PCD_HandleTypeDef *hpcd, uint32_t epnum)
{
 8106af8:	b580      	push	{r7, lr}
 8106afa:	b086      	sub	sp, #24
 8106afc:	af00      	add	r7, sp, #0
 8106afe:	6078      	str	r0, [r7, #4]
 8106b00:	6039      	str	r1, [r7, #0]
  const USB_OTG_GlobalTypeDef *USBx = hpcd->Instance;
 8106b02:	687b      	ldr	r3, [r7, #4]
 8106b04:	681b      	ldr	r3, [r3, #0]
 8106b06:	617b      	str	r3, [r7, #20]
  uint32_t USBx_BASE = (uint32_t)USBx;
 8106b08:	697b      	ldr	r3, [r7, #20]
 8106b0a:	613b      	str	r3, [r7, #16]
  uint32_t gSNPSiD = *(__IO const uint32_t *)(&USBx->CID + 0x1U);
 8106b0c:	697b      	ldr	r3, [r7, #20]
 8106b0e:	333c      	adds	r3, #60	; 0x3c
 8106b10:	3304      	adds	r3, #4
 8106b12:	681b      	ldr	r3, [r3, #0]
 8106b14:	60fb      	str	r3, [r7, #12]
  uint32_t DoepintReg = USBx_OUTEP(epnum)->DOEPINT;
 8106b16:	683b      	ldr	r3, [r7, #0]
 8106b18:	015a      	lsls	r2, r3, #5
 8106b1a:	693b      	ldr	r3, [r7, #16]
 8106b1c:	4413      	add	r3, r2
 8106b1e:	f503 6330 	add.w	r3, r3, #2816	; 0xb00
 8106b22:	689b      	ldr	r3, [r3, #8]
 8106b24:	60bb      	str	r3, [r7, #8]

  if ((gSNPSiD > USB_OTG_CORE_ID_300A) &&
 8106b26:	68fb      	ldr	r3, [r7, #12]
 8106b28:	4a15      	ldr	r2, [pc, #84]	; (8106b80 <PCD_EP_OutSetupPacket_int+0x88>)
 8106b2a:	4293      	cmp	r3, r2
 8106b2c:	d90e      	bls.n	8106b4c <PCD_EP_OutSetupPacket_int+0x54>
      ((DoepintReg & USB_OTG_DOEPINT_STPKTRX) == USB_OTG_DOEPINT_STPKTRX))
 8106b2e:	68bb      	ldr	r3, [r7, #8]
 8106b30:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
  if ((gSNPSiD > USB_OTG_CORE_ID_300A) &&
 8106b34:	2b00      	cmp	r3, #0
 8106b36:	d009      	beq.n	8106b4c <PCD_EP_OutSetupPacket_int+0x54>
  {
    CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_STPKTRX);
 8106b38:	683b      	ldr	r3, [r7, #0]
 8106b3a:	015a      	lsls	r2, r3, #5
 8106b3c:	693b      	ldr	r3, [r7, #16]
 8106b3e:	4413      	add	r3, r2
 8106b40:	f503 6330 	add.w	r3, r3, #2816	; 0xb00
 8106b44:	461a      	mov	r2, r3
 8106b46:	f44f 4300 	mov.w	r3, #32768	; 0x8000
 8106b4a:	6093      	str	r3, [r2, #8]

  /* Inform the upper layer that a setup packet is available */
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
  hpcd->SetupStageCallback(hpcd);
#else
  HAL_PCD_SetupStageCallback(hpcd);
 8106b4c:	6878      	ldr	r0, [r7, #4]
 8106b4e:	f014 fab7 	bl	811b0c0 <HAL_PCD_SetupStageCallback>
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */

  if ((gSNPSiD > USB_OTG_CORE_ID_300A) && (hpcd->Init.dma_enable == 1U))
 8106b52:	68fb      	ldr	r3, [r7, #12]
 8106b54:	4a0a      	ldr	r2, [pc, #40]	; (8106b80 <PCD_EP_OutSetupPacket_int+0x88>)
 8106b56:	4293      	cmp	r3, r2
 8106b58:	d90c      	bls.n	8106b74 <PCD_EP_OutSetupPacket_int+0x7c>
 8106b5a:	687b      	ldr	r3, [r7, #4]
 8106b5c:	799b      	ldrb	r3, [r3, #6]
 8106b5e:	2b01      	cmp	r3, #1
 8106b60:	d108      	bne.n	8106b74 <PCD_EP_OutSetupPacket_int+0x7c>
  {
    (void)USB_EP0_OutStart(hpcd->Instance, 1U, (uint8_t *)hpcd->Setup);
 8106b62:	687b      	ldr	r3, [r7, #4]
 8106b64:	6818      	ldr	r0, [r3, #0]
 8106b66:	687b      	ldr	r3, [r7, #4]
 8106b68:	f203 439c 	addw	r3, r3, #1180	; 0x49c
 8106b6c:	461a      	mov	r2, r3
 8106b6e:	2101      	movs	r1, #1
 8106b70:	f005 fb26 	bl	810c1c0 <USB_EP0_OutStart>
  }

  return HAL_OK;
 8106b74:	2300      	movs	r3, #0
}
 8106b76:	4618      	mov	r0, r3
 8106b78:	3718      	adds	r7, #24
 8106b7a:	46bd      	mov	sp, r7
 8106b7c:	bd80      	pop	{r7, pc}
 8106b7e:	bf00      	nop
 8106b80:	4f54300a 	.word	0x4f54300a

08106b84 <HAL_PCDEx_SetTxFiFo>:
  * @param  fifo The number of Tx fifo
  * @param  size Fifo size
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCDEx_SetTxFiFo(PCD_HandleTypeDef *hpcd, uint8_t fifo, uint16_t size)
{
 8106b84:	b480      	push	{r7}
 8106b86:	b085      	sub	sp, #20
 8106b88:	af00      	add	r7, sp, #0
 8106b8a:	6078      	str	r0, [r7, #4]
 8106b8c:	460b      	mov	r3, r1
 8106b8e:	70fb      	strb	r3, [r7, #3]
 8106b90:	4613      	mov	r3, r2
 8106b92:	803b      	strh	r3, [r7, #0]
         --> Txn should be configured with the minimum space of 16 words
     The FIFO is used optimally when used TxFIFOs are allocated in the top
         of the FIFO.Ex: use EP1 and EP2 as IN instead of EP1 and EP3 as IN ones.
     When DMA is used 3n * FIFO locations should be reserved for internal DMA registers */

  Tx_Offset = hpcd->Instance->GRXFSIZ;
 8106b94:	687b      	ldr	r3, [r7, #4]
 8106b96:	681b      	ldr	r3, [r3, #0]
 8106b98:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8106b9a:	60bb      	str	r3, [r7, #8]

  if (fifo == 0U)
 8106b9c:	78fb      	ldrb	r3, [r7, #3]
 8106b9e:	2b00      	cmp	r3, #0
 8106ba0:	d107      	bne.n	8106bb2 <HAL_PCDEx_SetTxFiFo+0x2e>
  {
    hpcd->Instance->DIEPTXF0_HNPTXFSIZ = ((uint32_t)size << 16) | Tx_Offset;
 8106ba2:	883b      	ldrh	r3, [r7, #0]
 8106ba4:	0419      	lsls	r1, r3, #16
 8106ba6:	687b      	ldr	r3, [r7, #4]
 8106ba8:	681b      	ldr	r3, [r3, #0]
 8106baa:	68ba      	ldr	r2, [r7, #8]
 8106bac:	430a      	orrs	r2, r1
 8106bae:	629a      	str	r2, [r3, #40]	; 0x28
 8106bb0:	e028      	b.n	8106c04 <HAL_PCDEx_SetTxFiFo+0x80>
  }
  else
  {
    Tx_Offset += (hpcd->Instance->DIEPTXF0_HNPTXFSIZ) >> 16;
 8106bb2:	687b      	ldr	r3, [r7, #4]
 8106bb4:	681b      	ldr	r3, [r3, #0]
 8106bb6:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8106bb8:	0c1b      	lsrs	r3, r3, #16
 8106bba:	68ba      	ldr	r2, [r7, #8]
 8106bbc:	4413      	add	r3, r2
 8106bbe:	60bb      	str	r3, [r7, #8]
    for (i = 0U; i < (fifo - 1U); i++)
 8106bc0:	2300      	movs	r3, #0
 8106bc2:	73fb      	strb	r3, [r7, #15]
 8106bc4:	e00d      	b.n	8106be2 <HAL_PCDEx_SetTxFiFo+0x5e>
    {
      Tx_Offset += (hpcd->Instance->DIEPTXF[i] >> 16);
 8106bc6:	687b      	ldr	r3, [r7, #4]
 8106bc8:	681a      	ldr	r2, [r3, #0]
 8106bca:	7bfb      	ldrb	r3, [r7, #15]
 8106bcc:	3340      	adds	r3, #64	; 0x40
 8106bce:	009b      	lsls	r3, r3, #2
 8106bd0:	4413      	add	r3, r2
 8106bd2:	685b      	ldr	r3, [r3, #4]
 8106bd4:	0c1b      	lsrs	r3, r3, #16
 8106bd6:	68ba      	ldr	r2, [r7, #8]
 8106bd8:	4413      	add	r3, r2
 8106bda:	60bb      	str	r3, [r7, #8]
    for (i = 0U; i < (fifo - 1U); i++)
 8106bdc:	7bfb      	ldrb	r3, [r7, #15]
 8106bde:	3301      	adds	r3, #1
 8106be0:	73fb      	strb	r3, [r7, #15]
 8106be2:	7bfa      	ldrb	r2, [r7, #15]
 8106be4:	78fb      	ldrb	r3, [r7, #3]
 8106be6:	3b01      	subs	r3, #1
 8106be8:	429a      	cmp	r2, r3
 8106bea:	d3ec      	bcc.n	8106bc6 <HAL_PCDEx_SetTxFiFo+0x42>
    }

    /* Multiply Tx_Size by 2 to get higher performance */
    hpcd->Instance->DIEPTXF[fifo - 1U] = ((uint32_t)size << 16) | Tx_Offset;
 8106bec:	883b      	ldrh	r3, [r7, #0]
 8106bee:	0418      	lsls	r0, r3, #16
 8106bf0:	687b      	ldr	r3, [r7, #4]
 8106bf2:	6819      	ldr	r1, [r3, #0]
 8106bf4:	78fb      	ldrb	r3, [r7, #3]
 8106bf6:	3b01      	subs	r3, #1
 8106bf8:	68ba      	ldr	r2, [r7, #8]
 8106bfa:	4302      	orrs	r2, r0
 8106bfc:	3340      	adds	r3, #64	; 0x40
 8106bfe:	009b      	lsls	r3, r3, #2
 8106c00:	440b      	add	r3, r1
 8106c02:	605a      	str	r2, [r3, #4]
  }

  return HAL_OK;
 8106c04:	2300      	movs	r3, #0
}
 8106c06:	4618      	mov	r0, r3
 8106c08:	3714      	adds	r7, #20
 8106c0a:	46bd      	mov	sp, r7
 8106c0c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8106c10:	4770      	bx	lr

08106c12 <HAL_PCDEx_SetRxFiFo>:
  * @param  hpcd PCD handle
  * @param  size Size of Rx fifo
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCDEx_SetRxFiFo(PCD_HandleTypeDef *hpcd, uint16_t size)
{
 8106c12:	b480      	push	{r7}
 8106c14:	b083      	sub	sp, #12
 8106c16:	af00      	add	r7, sp, #0
 8106c18:	6078      	str	r0, [r7, #4]
 8106c1a:	460b      	mov	r3, r1
 8106c1c:	807b      	strh	r3, [r7, #2]
  hpcd->Instance->GRXFSIZ = size;
 8106c1e:	687b      	ldr	r3, [r7, #4]
 8106c20:	681b      	ldr	r3, [r3, #0]
 8106c22:	887a      	ldrh	r2, [r7, #2]
 8106c24:	625a      	str	r2, [r3, #36]	; 0x24

  return HAL_OK;
 8106c26:	2300      	movs	r3, #0
}
 8106c28:	4618      	mov	r0, r3
 8106c2a:	370c      	adds	r7, #12
 8106c2c:	46bd      	mov	sp, r7
 8106c2e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8106c32:	4770      	bx	lr

08106c34 <HAL_PCDEx_ActivateLPM>:
  * @brief  Activate LPM feature.
  * @param  hpcd PCD handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCDEx_ActivateLPM(PCD_HandleTypeDef *hpcd)
{
 8106c34:	b480      	push	{r7}
 8106c36:	b085      	sub	sp, #20
 8106c38:	af00      	add	r7, sp, #0
 8106c3a:	6078      	str	r0, [r7, #4]
  USB_OTG_GlobalTypeDef *USBx = hpcd->Instance;
 8106c3c:	687b      	ldr	r3, [r7, #4]
 8106c3e:	681b      	ldr	r3, [r3, #0]
 8106c40:	60fb      	str	r3, [r7, #12]

  hpcd->lpm_active = 1U;
 8106c42:	687b      	ldr	r3, [r7, #4]
 8106c44:	2201      	movs	r2, #1
 8106c46:	f8c3 24d8 	str.w	r2, [r3, #1240]	; 0x4d8
  hpcd->LPM_State = LPM_L0;
 8106c4a:	687b      	ldr	r3, [r7, #4]
 8106c4c:	2200      	movs	r2, #0
 8106c4e:	f883 24cc 	strb.w	r2, [r3, #1228]	; 0x4cc
  USBx->GINTMSK |= USB_OTG_GINTMSK_LPMINTM;
 8106c52:	68fb      	ldr	r3, [r7, #12]
 8106c54:	699b      	ldr	r3, [r3, #24]
 8106c56:	f043 6200 	orr.w	r2, r3, #134217728	; 0x8000000
 8106c5a:	68fb      	ldr	r3, [r7, #12]
 8106c5c:	619a      	str	r2, [r3, #24]
  USBx->GLPMCFG |= (USB_OTG_GLPMCFG_LPMEN | USB_OTG_GLPMCFG_LPMACK | USB_OTG_GLPMCFG_ENBESL);
 8106c5e:	68fb      	ldr	r3, [r7, #12]
 8106c60:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8106c62:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 8106c66:	f043 0303 	orr.w	r3, r3, #3
 8106c6a:	68fa      	ldr	r2, [r7, #12]
 8106c6c:	6553      	str	r3, [r2, #84]	; 0x54

  return HAL_OK;
 8106c6e:	2300      	movs	r3, #0
}
 8106c70:	4618      	mov	r0, r3
 8106c72:	3714      	adds	r7, #20
 8106c74:	46bd      	mov	sp, r7
 8106c76:	f85d 7b04 	ldr.w	r7, [sp], #4
 8106c7a:	4770      	bx	lr

08106c7c <HAL_PCDEx_LPM_Callback>:
  * @param  hpcd PCD handle
  * @param  msg LPM message
  * @retval HAL status
  */
__weak void HAL_PCDEx_LPM_Callback(PCD_HandleTypeDef *hpcd, PCD_LPM_MsgTypeDef msg)
{
 8106c7c:	b480      	push	{r7}
 8106c7e:	b083      	sub	sp, #12
 8106c80:	af00      	add	r7, sp, #0
 8106c82:	6078      	str	r0, [r7, #4]
 8106c84:	460b      	mov	r3, r1
 8106c86:	70fb      	strb	r3, [r7, #3]
  UNUSED(msg);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_PCDEx_LPM_Callback could be implemented in the user file
   */
}
 8106c88:	bf00      	nop
 8106c8a:	370c      	adds	r7, #12
 8106c8c:	46bd      	mov	sp, r7
 8106c8e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8106c92:	4770      	bx	lr

08106c94 <HAL_PWREx_EnterSTOPMode>:
  *            @arg PWR_D2_DOMAIN : Enter D2 Domain to DSTOP mode.
  *            @arg PWR_D3_DOMAIN : Enter D3/SRD Domain to DSTOP mode.
  * @retval None.
  */
void HAL_PWREx_EnterSTOPMode (uint32_t Regulator, uint8_t STOPEntry, uint32_t Domain)
{
 8106c94:	b580      	push	{r7, lr}
 8106c96:	b084      	sub	sp, #16
 8106c98:	af00      	add	r7, sp, #0
 8106c9a:	60f8      	str	r0, [r7, #12]
 8106c9c:	460b      	mov	r3, r1
 8106c9e:	607a      	str	r2, [r7, #4]
 8106ca0:	72fb      	strb	r3, [r7, #11]
  assert_param (IS_PWR_REGULATOR (Regulator));
  assert_param (IS_PWR_STOP_ENTRY (STOPEntry));
  assert_param (IS_PWR_DOMAIN (Domain));

  /* Select the regulator state in Stop mode */
  MODIFY_REG (PWR->CR1, PWR_CR1_LPDS, Regulator);
 8106ca2:	4b37      	ldr	r3, [pc, #220]	; (8106d80 <HAL_PWREx_EnterSTOPMode+0xec>)
 8106ca4:	681b      	ldr	r3, [r3, #0]
 8106ca6:	f023 0201 	bic.w	r2, r3, #1
 8106caa:	4935      	ldr	r1, [pc, #212]	; (8106d80 <HAL_PWREx_EnterSTOPMode+0xec>)
 8106cac:	68fb      	ldr	r3, [r7, #12]
 8106cae:	4313      	orrs	r3, r2
 8106cb0:	600b      	str	r3, [r1, #0]

  /* Select the domain Power Down DeepSleep */
  if (Domain == PWR_D1_DOMAIN)
 8106cb2:	687b      	ldr	r3, [r7, #4]
 8106cb4:	2b00      	cmp	r3, #0
 8106cb6:	d123      	bne.n	8106d00 <HAL_PWREx_EnterSTOPMode+0x6c>
  {
#if defined (DUAL_CORE)
    /* Check current core */
    if (HAL_GetCurrentCPUID () != CM7_CPUID)
 8106cb8:	f7fc fc76 	bl	81035a8 <HAL_GetCurrentCPUID>
 8106cbc:	4603      	mov	r3, r0
 8106cbe:	2b03      	cmp	r3, #3
 8106cc0:	d158      	bne.n	8106d74 <HAL_PWREx_EnterSTOPMode+0xe0>
      return;
    }
#endif /* defined (DUAL_CORE) */

    /* Keep DSTOP mode when D1/CD domain enters Deepsleep */
    CLEAR_BIT (PWR->CPUCR, PWR_CPUCR_PDDS_D1);
 8106cc2:	4b2f      	ldr	r3, [pc, #188]	; (8106d80 <HAL_PWREx_EnterSTOPMode+0xec>)
 8106cc4:	691b      	ldr	r3, [r3, #16]
 8106cc6:	4a2e      	ldr	r2, [pc, #184]	; (8106d80 <HAL_PWREx_EnterSTOPMode+0xec>)
 8106cc8:	f023 0301 	bic.w	r3, r3, #1
 8106ccc:	6113      	str	r3, [r2, #16]

    /* Set SLEEPDEEP bit of Cortex System Control Register */
    SET_BIT (SCB->SCR, SCB_SCR_SLEEPDEEP_Msk);
 8106cce:	4b2d      	ldr	r3, [pc, #180]	; (8106d84 <HAL_PWREx_EnterSTOPMode+0xf0>)
 8106cd0:	691b      	ldr	r3, [r3, #16]
 8106cd2:	4a2c      	ldr	r2, [pc, #176]	; (8106d84 <HAL_PWREx_EnterSTOPMode+0xf0>)
 8106cd4:	f043 0304 	orr.w	r3, r3, #4
 8106cd8:	6113      	str	r3, [r2, #16]
  __ASM volatile ("dsb 0xF":::"memory");
 8106cda:	f3bf 8f4f 	dsb	sy
}
 8106cde:	bf00      	nop
  __ASM volatile ("isb 0xF":::"memory");
 8106ce0:	f3bf 8f6f 	isb	sy
}
 8106ce4:	bf00      	nop
    /* Ensure that all instructions are done before entering STOP mode */
    __DSB ();
    __ISB ();

    /* Select Stop mode entry */
    if (STOPEntry == PWR_STOPENTRY_WFI)
 8106ce6:	7afb      	ldrb	r3, [r7, #11]
 8106ce8:	2b01      	cmp	r3, #1
 8106cea:	d101      	bne.n	8106cf0 <HAL_PWREx_EnterSTOPMode+0x5c>
    {
      /* Request Wait For Interrupt */
      __WFI ();
 8106cec:	bf30      	wfi
 8106cee:	e000      	b.n	8106cf2 <HAL_PWREx_EnterSTOPMode+0x5e>
    }
    else
    {
      /* Request Wait For Event */
      __WFE ();
 8106cf0:	bf20      	wfe
    }

    /* Clear SLEEPDEEP bit of Cortex-Mx in the System Control Register */
    CLEAR_BIT (SCB->SCR, SCB_SCR_SLEEPDEEP_Msk);
 8106cf2:	4b24      	ldr	r3, [pc, #144]	; (8106d84 <HAL_PWREx_EnterSTOPMode+0xf0>)
 8106cf4:	691b      	ldr	r3, [r3, #16]
 8106cf6:	4a23      	ldr	r2, [pc, #140]	; (8106d84 <HAL_PWREx_EnterSTOPMode+0xf0>)
 8106cf8:	f023 0304 	bic.w	r3, r3, #4
 8106cfc:	6113      	str	r3, [r2, #16]
 8106cfe:	e03c      	b.n	8106d7a <HAL_PWREx_EnterSTOPMode+0xe6>
  }
#if defined (PWR_CPUCR_PDDS_D2)
  else if (Domain == PWR_D2_DOMAIN)
 8106d00:	687b      	ldr	r3, [r7, #4]
 8106d02:	2b01      	cmp	r3, #1
 8106d04:	d123      	bne.n	8106d4e <HAL_PWREx_EnterSTOPMode+0xba>
  {
#if defined (DUAL_CORE)
    /* Check current core */
    if (HAL_GetCurrentCPUID () != CM4_CPUID)
 8106d06:	f7fc fc4f 	bl	81035a8 <HAL_GetCurrentCPUID>
 8106d0a:	4603      	mov	r3, r0
 8106d0c:	2b01      	cmp	r3, #1
 8106d0e:	d133      	bne.n	8106d78 <HAL_PWREx_EnterSTOPMode+0xe4>
      */
      return;
    }

    /* Keep DSTOP mode when D2 domain enters Deepsleep */
    CLEAR_BIT (PWR->CPU2CR, PWR_CPU2CR_PDDS_D2);
 8106d10:	4b1b      	ldr	r3, [pc, #108]	; (8106d80 <HAL_PWREx_EnterSTOPMode+0xec>)
 8106d12:	695b      	ldr	r3, [r3, #20]
 8106d14:	4a1a      	ldr	r2, [pc, #104]	; (8106d80 <HAL_PWREx_EnterSTOPMode+0xec>)
 8106d16:	f023 0302 	bic.w	r3, r3, #2
 8106d1a:	6153      	str	r3, [r2, #20]

    /* Set SLEEPDEEP bit of Cortex System Control Register */
    SET_BIT (SCB->SCR, SCB_SCR_SLEEPDEEP_Msk);
 8106d1c:	4b19      	ldr	r3, [pc, #100]	; (8106d84 <HAL_PWREx_EnterSTOPMode+0xf0>)
 8106d1e:	691b      	ldr	r3, [r3, #16]
 8106d20:	4a18      	ldr	r2, [pc, #96]	; (8106d84 <HAL_PWREx_EnterSTOPMode+0xf0>)
 8106d22:	f043 0304 	orr.w	r3, r3, #4
 8106d26:	6113      	str	r3, [r2, #16]
  __ASM volatile ("dsb 0xF":::"memory");
 8106d28:	f3bf 8f4f 	dsb	sy
}
 8106d2c:	bf00      	nop
  __ASM volatile ("isb 0xF":::"memory");
 8106d2e:	f3bf 8f6f 	isb	sy
}
 8106d32:	bf00      	nop
    /* Ensure that all instructions are done before entering STOP mode */
    __DSB ();
    __ISB ();

    /* Select Stop mode entry */
    if (STOPEntry == PWR_STOPENTRY_WFI)
 8106d34:	7afb      	ldrb	r3, [r7, #11]
 8106d36:	2b01      	cmp	r3, #1
 8106d38:	d101      	bne.n	8106d3e <HAL_PWREx_EnterSTOPMode+0xaa>
    {
      /* Request Wait For Interrupt */
      __WFI ();
 8106d3a:	bf30      	wfi
 8106d3c:	e000      	b.n	8106d40 <HAL_PWREx_EnterSTOPMode+0xac>
    }
    else
    {
      /* Request Wait For Event */
      __WFE ();
 8106d3e:	bf20      	wfe
    }

    /* Clear SLEEPDEEP bit of Cortex-Mx in the System Control Register */
    CLEAR_BIT (SCB->SCR, SCB_SCR_SLEEPDEEP_Msk);
 8106d40:	4b10      	ldr	r3, [pc, #64]	; (8106d84 <HAL_PWREx_EnterSTOPMode+0xf0>)
 8106d42:	691b      	ldr	r3, [r3, #16]
 8106d44:	4a0f      	ldr	r2, [pc, #60]	; (8106d84 <HAL_PWREx_EnterSTOPMode+0xf0>)
 8106d46:	f023 0304 	bic.w	r3, r3, #4
 8106d4a:	6113      	str	r3, [r2, #16]
 8106d4c:	e015      	b.n	8106d7a <HAL_PWREx_EnterSTOPMode+0xe6>
#endif /* defined (PWR_CPUCR_PDDS_D2) */
  else
  {
#if defined (DUAL_CORE)
    /* Check current core */
    if (HAL_GetCurrentCPUID () == CM7_CPUID)
 8106d4e:	f7fc fc2b 	bl	81035a8 <HAL_GetCurrentCPUID>
 8106d52:	4603      	mov	r3, r0
 8106d54:	2b03      	cmp	r3, #3
 8106d56:	d106      	bne.n	8106d66 <HAL_PWREx_EnterSTOPMode+0xd2>
    {
      /* Keep DSTOP mode when D3 domain enters Deepsleep */
      CLEAR_BIT (PWR->CPUCR, PWR_CPUCR_PDDS_D3);
 8106d58:	4b09      	ldr	r3, [pc, #36]	; (8106d80 <HAL_PWREx_EnterSTOPMode+0xec>)
 8106d5a:	691b      	ldr	r3, [r3, #16]
 8106d5c:	4a08      	ldr	r2, [pc, #32]	; (8106d80 <HAL_PWREx_EnterSTOPMode+0xec>)
 8106d5e:	f023 0304 	bic.w	r3, r3, #4
 8106d62:	6113      	str	r3, [r2, #16]
 8106d64:	e009      	b.n	8106d7a <HAL_PWREx_EnterSTOPMode+0xe6>
    }
    else
    {
      /* Keep DSTOP mode when D3 domain enters Deepsleep */
      CLEAR_BIT (PWR->CPU2CR, PWR_CPU2CR_PDDS_D3);
 8106d66:	4b06      	ldr	r3, [pc, #24]	; (8106d80 <HAL_PWREx_EnterSTOPMode+0xec>)
 8106d68:	695b      	ldr	r3, [r3, #20]
 8106d6a:	4a05      	ldr	r2, [pc, #20]	; (8106d80 <HAL_PWREx_EnterSTOPMode+0xec>)
 8106d6c:	f023 0304 	bic.w	r3, r3, #4
 8106d70:	6153      	str	r3, [r2, #20]
 8106d72:	e002      	b.n	8106d7a <HAL_PWREx_EnterSTOPMode+0xe6>
      return;
 8106d74:	bf00      	nop
 8106d76:	e000      	b.n	8106d7a <HAL_PWREx_EnterSTOPMode+0xe6>
      return;
 8106d78:	bf00      	nop
#else
    /* Keep DSTOP mode when D3/SRD domain enters Deepsleep */
    CLEAR_BIT (PWR->CPUCR, PWR_CPUCR_PDDS_D3);
#endif  /* defined (DUAL_CORE) */
  }
}
 8106d7a:	3710      	adds	r7, #16
 8106d7c:	46bd      	mov	sp, r7
 8106d7e:	bd80      	pop	{r7, pc}
 8106d80:	58024800 	.word	0x58024800
 8106d84:	e000ed00 	.word	0xe000ed00

08106d88 <HAL_PWREx_ClearPendingEvent>:
  *         enter low power mode using Wait For Event request.
  * @note   Cortex-M7 must be in CRUN mode when calling this API by Cortex-M4.
  * @retval None.
  */
void HAL_PWREx_ClearPendingEvent (void)
{
 8106d88:	b580      	push	{r7, lr}
 8106d8a:	af00      	add	r7, sp, #0
#if defined (DUAL_CORE)
  /* Check the current Core */
  if (HAL_GetCurrentCPUID () == CM7_CPUID)
 8106d8c:	f7fc fc0c 	bl	81035a8 <HAL_GetCurrentCPUID>
 8106d90:	4603      	mov	r3, r0
 8106d92:	2b03      	cmp	r3, #3
 8106d94:	d101      	bne.n	8106d9a <HAL_PWREx_ClearPendingEvent+0x12>
  {
    __WFE ();
 8106d96:	bf20      	wfe
    __WFE ();
  }
#else
  __WFE ();
#endif /* defined (DUAL_CORE) */
}
 8106d98:	e001      	b.n	8106d9e <HAL_PWREx_ClearPendingEvent+0x16>
    __SEV ();
 8106d9a:	bf40      	sev
    __WFE ();
 8106d9c:	bf20      	wfe
}
 8106d9e:	bf00      	nop
 8106da0:	bd80      	pop	{r7, pc}
	...

08106da4 <HAL_PWREx_EnableUSBVoltageDetector>:
/**
  * @brief Enable the USB voltage level detector.
  * @retval None.
  */
void HAL_PWREx_EnableUSBVoltageDetector (void)
{
 8106da4:	b480      	push	{r7}
 8106da6:	af00      	add	r7, sp, #0
  /* Enable the USB voltage detector */
  SET_BIT (PWR->CR3, PWR_CR3_USB33DEN);
 8106da8:	4b05      	ldr	r3, [pc, #20]	; (8106dc0 <HAL_PWREx_EnableUSBVoltageDetector+0x1c>)
 8106daa:	68db      	ldr	r3, [r3, #12]
 8106dac:	4a04      	ldr	r2, [pc, #16]	; (8106dc0 <HAL_PWREx_EnableUSBVoltageDetector+0x1c>)
 8106dae:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 8106db2:	60d3      	str	r3, [r2, #12]
}
 8106db4:	bf00      	nop
 8106db6:	46bd      	mov	sp, r7
 8106db8:	f85d 7b04 	ldr.w	r7, [sp], #4
 8106dbc:	4770      	bx	lr
 8106dbe:	bf00      	nop
 8106dc0:	58024800 	.word	0x58024800

08106dc4 <HAL_RCC_GetSysClockFreq>:
  *
  *
  * @retval SYSCLK frequency
  */
uint32_t HAL_RCC_GetSysClockFreq(void)
{
 8106dc4:	b480      	push	{r7}
 8106dc6:	b089      	sub	sp, #36	; 0x24
 8106dc8:	af00      	add	r7, sp, #0
  float_t fracn1, pllvco;
  uint32_t sysclockfreq;

  /* Get SYSCLK source -------------------------------------------------------*/

  switch (RCC->CFGR & RCC_CFGR_SWS)
 8106dca:	4bb3      	ldr	r3, [pc, #716]	; (8107098 <HAL_RCC_GetSysClockFreq+0x2d4>)
 8106dcc:	691b      	ldr	r3, [r3, #16]
 8106dce:	f003 0338 	and.w	r3, r3, #56	; 0x38
 8106dd2:	2b18      	cmp	r3, #24
 8106dd4:	f200 8155 	bhi.w	8107082 <HAL_RCC_GetSysClockFreq+0x2be>
 8106dd8:	a201      	add	r2, pc, #4	; (adr r2, 8106de0 <HAL_RCC_GetSysClockFreq+0x1c>)
 8106dda:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8106dde:	bf00      	nop
 8106de0:	08106e45 	.word	0x08106e45
 8106de4:	08107083 	.word	0x08107083
 8106de8:	08107083 	.word	0x08107083
 8106dec:	08107083 	.word	0x08107083
 8106df0:	08107083 	.word	0x08107083
 8106df4:	08107083 	.word	0x08107083
 8106df8:	08107083 	.word	0x08107083
 8106dfc:	08107083 	.word	0x08107083
 8106e00:	08106e6b 	.word	0x08106e6b
 8106e04:	08107083 	.word	0x08107083
 8106e08:	08107083 	.word	0x08107083
 8106e0c:	08107083 	.word	0x08107083
 8106e10:	08107083 	.word	0x08107083
 8106e14:	08107083 	.word	0x08107083
 8106e18:	08107083 	.word	0x08107083
 8106e1c:	08107083 	.word	0x08107083
 8106e20:	08106e71 	.word	0x08106e71
 8106e24:	08107083 	.word	0x08107083
 8106e28:	08107083 	.word	0x08107083
 8106e2c:	08107083 	.word	0x08107083
 8106e30:	08107083 	.word	0x08107083
 8106e34:	08107083 	.word	0x08107083
 8106e38:	08107083 	.word	0x08107083
 8106e3c:	08107083 	.word	0x08107083
 8106e40:	08106e77 	.word	0x08106e77
  {
    case RCC_CFGR_SWS_HSI:  /* HSI used as system clock source */

      if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIV) != 0U)
 8106e44:	4b94      	ldr	r3, [pc, #592]	; (8107098 <HAL_RCC_GetSysClockFreq+0x2d4>)
 8106e46:	681b      	ldr	r3, [r3, #0]
 8106e48:	f003 0320 	and.w	r3, r3, #32
 8106e4c:	2b00      	cmp	r3, #0
 8106e4e:	d009      	beq.n	8106e64 <HAL_RCC_GetSysClockFreq+0xa0>
      {
        sysclockfreq = (uint32_t)(HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> 3));
 8106e50:	4b91      	ldr	r3, [pc, #580]	; (8107098 <HAL_RCC_GetSysClockFreq+0x2d4>)
 8106e52:	681b      	ldr	r3, [r3, #0]
 8106e54:	08db      	lsrs	r3, r3, #3
 8106e56:	f003 0303 	and.w	r3, r3, #3
 8106e5a:	4a90      	ldr	r2, [pc, #576]	; (810709c <HAL_RCC_GetSysClockFreq+0x2d8>)
 8106e5c:	fa22 f303 	lsr.w	r3, r2, r3
 8106e60:	61bb      	str	r3, [r7, #24]
      else
      {
        sysclockfreq = (uint32_t) HSI_VALUE;
      }

      break;
 8106e62:	e111      	b.n	8107088 <HAL_RCC_GetSysClockFreq+0x2c4>
        sysclockfreq = (uint32_t) HSI_VALUE;
 8106e64:	4b8d      	ldr	r3, [pc, #564]	; (810709c <HAL_RCC_GetSysClockFreq+0x2d8>)
 8106e66:	61bb      	str	r3, [r7, #24]
      break;
 8106e68:	e10e      	b.n	8107088 <HAL_RCC_GetSysClockFreq+0x2c4>

    case RCC_CFGR_SWS_CSI:  /* CSI used as system clock  source */
      sysclockfreq = CSI_VALUE;
 8106e6a:	4b8d      	ldr	r3, [pc, #564]	; (81070a0 <HAL_RCC_GetSysClockFreq+0x2dc>)
 8106e6c:	61bb      	str	r3, [r7, #24]
      break;
 8106e6e:	e10b      	b.n	8107088 <HAL_RCC_GetSysClockFreq+0x2c4>

    case RCC_CFGR_SWS_HSE:  /* HSE used as system clock  source */
      sysclockfreq = HSE_VALUE;
 8106e70:	4b8c      	ldr	r3, [pc, #560]	; (81070a4 <HAL_RCC_GetSysClockFreq+0x2e0>)
 8106e72:	61bb      	str	r3, [r7, #24]
      break;
 8106e74:	e108      	b.n	8107088 <HAL_RCC_GetSysClockFreq+0x2c4>
    case RCC_CFGR_SWS_PLL1:  /* PLL1 used as system clock  source */

      /* PLL_VCO = (HSE_VALUE or HSI_VALUE or CSI_VALUE/ PLLM) * PLLN
      SYSCLK = PLL_VCO / PLLR
      */
      pllsource = (RCC->PLLCKSELR & RCC_PLLCKSELR_PLLSRC);
 8106e76:	4b88      	ldr	r3, [pc, #544]	; (8107098 <HAL_RCC_GetSysClockFreq+0x2d4>)
 8106e78:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8106e7a:	f003 0303 	and.w	r3, r3, #3
 8106e7e:	617b      	str	r3, [r7, #20]
      pllm = ((RCC->PLLCKSELR & RCC_PLLCKSELR_DIVM1) >> 4)  ;
 8106e80:	4b85      	ldr	r3, [pc, #532]	; (8107098 <HAL_RCC_GetSysClockFreq+0x2d4>)
 8106e82:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8106e84:	091b      	lsrs	r3, r3, #4
 8106e86:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 8106e8a:	613b      	str	r3, [r7, #16]
      pllfracen = ((RCC-> PLLCFGR & RCC_PLLCFGR_PLL1FRACEN) >> RCC_PLLCFGR_PLL1FRACEN_Pos);
 8106e8c:	4b82      	ldr	r3, [pc, #520]	; (8107098 <HAL_RCC_GetSysClockFreq+0x2d4>)
 8106e8e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8106e90:	f003 0301 	and.w	r3, r3, #1
 8106e94:	60fb      	str	r3, [r7, #12]
      fracn1 = (float_t)(uint32_t)(pllfracen * ((RCC->PLL1FRACR & RCC_PLL1FRACR_FRACN1) >> 3));
 8106e96:	4b80      	ldr	r3, [pc, #512]	; (8107098 <HAL_RCC_GetSysClockFreq+0x2d4>)
 8106e98:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8106e9a:	08db      	lsrs	r3, r3, #3
 8106e9c:	f3c3 030c 	ubfx	r3, r3, #0, #13
 8106ea0:	68fa      	ldr	r2, [r7, #12]
 8106ea2:	fb02 f303 	mul.w	r3, r2, r3
 8106ea6:	ee07 3a90 	vmov	s15, r3
 8106eaa:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8106eae:	edc7 7a02 	vstr	s15, [r7, #8]

      if (pllm != 0U)
 8106eb2:	693b      	ldr	r3, [r7, #16]
 8106eb4:	2b00      	cmp	r3, #0
 8106eb6:	f000 80e1 	beq.w	810707c <HAL_RCC_GetSysClockFreq+0x2b8>
 8106eba:	697b      	ldr	r3, [r7, #20]
 8106ebc:	2b02      	cmp	r3, #2
 8106ebe:	f000 8083 	beq.w	8106fc8 <HAL_RCC_GetSysClockFreq+0x204>
 8106ec2:	697b      	ldr	r3, [r7, #20]
 8106ec4:	2b02      	cmp	r3, #2
 8106ec6:	f200 80a1 	bhi.w	810700c <HAL_RCC_GetSysClockFreq+0x248>
 8106eca:	697b      	ldr	r3, [r7, #20]
 8106ecc:	2b00      	cmp	r3, #0
 8106ece:	d003      	beq.n	8106ed8 <HAL_RCC_GetSysClockFreq+0x114>
 8106ed0:	697b      	ldr	r3, [r7, #20]
 8106ed2:	2b01      	cmp	r3, #1
 8106ed4:	d056      	beq.n	8106f84 <HAL_RCC_GetSysClockFreq+0x1c0>
 8106ed6:	e099      	b.n	810700c <HAL_RCC_GetSysClockFreq+0x248>
      {
        switch (pllsource)
        {
          case RCC_PLLSOURCE_HSI:  /* HSI used as PLL clock source */

            if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIV) != 0U)
 8106ed8:	4b6f      	ldr	r3, [pc, #444]	; (8107098 <HAL_RCC_GetSysClockFreq+0x2d4>)
 8106eda:	681b      	ldr	r3, [r3, #0]
 8106edc:	f003 0320 	and.w	r3, r3, #32
 8106ee0:	2b00      	cmp	r3, #0
 8106ee2:	d02d      	beq.n	8106f40 <HAL_RCC_GetSysClockFreq+0x17c>
            {
              hsivalue = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> 3));
 8106ee4:	4b6c      	ldr	r3, [pc, #432]	; (8107098 <HAL_RCC_GetSysClockFreq+0x2d4>)
 8106ee6:	681b      	ldr	r3, [r3, #0]
 8106ee8:	08db      	lsrs	r3, r3, #3
 8106eea:	f003 0303 	and.w	r3, r3, #3
 8106eee:	4a6b      	ldr	r2, [pc, #428]	; (810709c <HAL_RCC_GetSysClockFreq+0x2d8>)
 8106ef0:	fa22 f303 	lsr.w	r3, r2, r3
 8106ef4:	607b      	str	r3, [r7, #4]
              pllvco = ((float_t)hsivalue / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1 / (float_t)0x2000) + (float_t)1);
 8106ef6:	687b      	ldr	r3, [r7, #4]
 8106ef8:	ee07 3a90 	vmov	s15, r3
 8106efc:	eef8 6a67 	vcvt.f32.u32	s13, s15
 8106f00:	693b      	ldr	r3, [r7, #16]
 8106f02:	ee07 3a90 	vmov	s15, r3
 8106f06:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8106f0a:	ee86 7aa7 	vdiv.f32	s14, s13, s15
 8106f0e:	4b62      	ldr	r3, [pc, #392]	; (8107098 <HAL_RCC_GetSysClockFreq+0x2d4>)
 8106f10:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8106f12:	f3c3 0308 	ubfx	r3, r3, #0, #9
 8106f16:	ee07 3a90 	vmov	s15, r3
 8106f1a:	eef8 6a67 	vcvt.f32.u32	s13, s15
 8106f1e:	ed97 6a02 	vldr	s12, [r7, #8]
 8106f22:	eddf 5a61 	vldr	s11, [pc, #388]	; 81070a8 <HAL_RCC_GetSysClockFreq+0x2e4>
 8106f26:	eec6 7a25 	vdiv.f32	s15, s12, s11
 8106f2a:	ee76 7aa7 	vadd.f32	s15, s13, s15
 8106f2e:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
 8106f32:	ee77 7aa6 	vadd.f32	s15, s15, s13
 8106f36:	ee67 7a27 	vmul.f32	s15, s14, s15
 8106f3a:	edc7 7a07 	vstr	s15, [r7, #28]
            }
            else
            {
              pllvco = ((float_t)HSI_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1 / (float_t)0x2000) + (float_t)1);
            }
            break;
 8106f3e:	e087      	b.n	8107050 <HAL_RCC_GetSysClockFreq+0x28c>
              pllvco = ((float_t)HSI_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1 / (float_t)0x2000) + (float_t)1);
 8106f40:	693b      	ldr	r3, [r7, #16]
 8106f42:	ee07 3a90 	vmov	s15, r3
 8106f46:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8106f4a:	eddf 6a58 	vldr	s13, [pc, #352]	; 81070ac <HAL_RCC_GetSysClockFreq+0x2e8>
 8106f4e:	ee86 7aa7 	vdiv.f32	s14, s13, s15
 8106f52:	4b51      	ldr	r3, [pc, #324]	; (8107098 <HAL_RCC_GetSysClockFreq+0x2d4>)
 8106f54:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8106f56:	f3c3 0308 	ubfx	r3, r3, #0, #9
 8106f5a:	ee07 3a90 	vmov	s15, r3
 8106f5e:	eef8 6a67 	vcvt.f32.u32	s13, s15
 8106f62:	ed97 6a02 	vldr	s12, [r7, #8]
 8106f66:	eddf 5a50 	vldr	s11, [pc, #320]	; 81070a8 <HAL_RCC_GetSysClockFreq+0x2e4>
 8106f6a:	eec6 7a25 	vdiv.f32	s15, s12, s11
 8106f6e:	ee76 7aa7 	vadd.f32	s15, s13, s15
 8106f72:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
 8106f76:	ee77 7aa6 	vadd.f32	s15, s15, s13
 8106f7a:	ee67 7a27 	vmul.f32	s15, s14, s15
 8106f7e:	edc7 7a07 	vstr	s15, [r7, #28]
            break;
 8106f82:	e065      	b.n	8107050 <HAL_RCC_GetSysClockFreq+0x28c>

          case RCC_PLLSOURCE_CSI:  /* CSI used as PLL clock source */
            pllvco = ((float_t)CSI_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1 / (float_t)0x2000) + (float_t)1);
 8106f84:	693b      	ldr	r3, [r7, #16]
 8106f86:	ee07 3a90 	vmov	s15, r3
 8106f8a:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8106f8e:	eddf 6a48 	vldr	s13, [pc, #288]	; 81070b0 <HAL_RCC_GetSysClockFreq+0x2ec>
 8106f92:	ee86 7aa7 	vdiv.f32	s14, s13, s15
 8106f96:	4b40      	ldr	r3, [pc, #256]	; (8107098 <HAL_RCC_GetSysClockFreq+0x2d4>)
 8106f98:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8106f9a:	f3c3 0308 	ubfx	r3, r3, #0, #9
 8106f9e:	ee07 3a90 	vmov	s15, r3
 8106fa2:	eef8 6a67 	vcvt.f32.u32	s13, s15
 8106fa6:	ed97 6a02 	vldr	s12, [r7, #8]
 8106faa:	eddf 5a3f 	vldr	s11, [pc, #252]	; 81070a8 <HAL_RCC_GetSysClockFreq+0x2e4>
 8106fae:	eec6 7a25 	vdiv.f32	s15, s12, s11
 8106fb2:	ee76 7aa7 	vadd.f32	s15, s13, s15
 8106fb6:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
 8106fba:	ee77 7aa6 	vadd.f32	s15, s15, s13
 8106fbe:	ee67 7a27 	vmul.f32	s15, s14, s15
 8106fc2:	edc7 7a07 	vstr	s15, [r7, #28]
            break;
 8106fc6:	e043      	b.n	8107050 <HAL_RCC_GetSysClockFreq+0x28c>

          case RCC_PLLSOURCE_HSE:  /* HSE used as PLL clock source */
            pllvco = ((float_t)HSE_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1 / (float_t)0x2000) + (float_t)1);
 8106fc8:	693b      	ldr	r3, [r7, #16]
 8106fca:	ee07 3a90 	vmov	s15, r3
 8106fce:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8106fd2:	eddf 6a38 	vldr	s13, [pc, #224]	; 81070b4 <HAL_RCC_GetSysClockFreq+0x2f0>
 8106fd6:	ee86 7aa7 	vdiv.f32	s14, s13, s15
 8106fda:	4b2f      	ldr	r3, [pc, #188]	; (8107098 <HAL_RCC_GetSysClockFreq+0x2d4>)
 8106fdc:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8106fde:	f3c3 0308 	ubfx	r3, r3, #0, #9
 8106fe2:	ee07 3a90 	vmov	s15, r3
 8106fe6:	eef8 6a67 	vcvt.f32.u32	s13, s15
 8106fea:	ed97 6a02 	vldr	s12, [r7, #8]
 8106fee:	eddf 5a2e 	vldr	s11, [pc, #184]	; 81070a8 <HAL_RCC_GetSysClockFreq+0x2e4>
 8106ff2:	eec6 7a25 	vdiv.f32	s15, s12, s11
 8106ff6:	ee76 7aa7 	vadd.f32	s15, s13, s15
 8106ffa:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
 8106ffe:	ee77 7aa6 	vadd.f32	s15, s15, s13
 8107002:	ee67 7a27 	vmul.f32	s15, s14, s15
 8107006:	edc7 7a07 	vstr	s15, [r7, #28]
            break;
 810700a:	e021      	b.n	8107050 <HAL_RCC_GetSysClockFreq+0x28c>

          default:
            pllvco = ((float_t)CSI_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1 / (float_t)0x2000) + (float_t)1);
 810700c:	693b      	ldr	r3, [r7, #16]
 810700e:	ee07 3a90 	vmov	s15, r3
 8107012:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8107016:	eddf 6a26 	vldr	s13, [pc, #152]	; 81070b0 <HAL_RCC_GetSysClockFreq+0x2ec>
 810701a:	ee86 7aa7 	vdiv.f32	s14, s13, s15
 810701e:	4b1e      	ldr	r3, [pc, #120]	; (8107098 <HAL_RCC_GetSysClockFreq+0x2d4>)
 8107020:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8107022:	f3c3 0308 	ubfx	r3, r3, #0, #9
 8107026:	ee07 3a90 	vmov	s15, r3
 810702a:	eef8 6a67 	vcvt.f32.u32	s13, s15
 810702e:	ed97 6a02 	vldr	s12, [r7, #8]
 8107032:	eddf 5a1d 	vldr	s11, [pc, #116]	; 81070a8 <HAL_RCC_GetSysClockFreq+0x2e4>
 8107036:	eec6 7a25 	vdiv.f32	s15, s12, s11
 810703a:	ee76 7aa7 	vadd.f32	s15, s13, s15
 810703e:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
 8107042:	ee77 7aa6 	vadd.f32	s15, s15, s13
 8107046:	ee67 7a27 	vmul.f32	s15, s14, s15
 810704a:	edc7 7a07 	vstr	s15, [r7, #28]
            break;
 810704e:	bf00      	nop
        }
        pllp = (((RCC->PLL1DIVR & RCC_PLL1DIVR_P1) >> 9) + 1U) ;
 8107050:	4b11      	ldr	r3, [pc, #68]	; (8107098 <HAL_RCC_GetSysClockFreq+0x2d4>)
 8107052:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8107054:	0a5b      	lsrs	r3, r3, #9
 8107056:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 810705a:	3301      	adds	r3, #1
 810705c:	603b      	str	r3, [r7, #0]
        sysclockfreq = (uint32_t)(float_t)(pllvco / (float_t)pllp);
 810705e:	683b      	ldr	r3, [r7, #0]
 8107060:	ee07 3a90 	vmov	s15, r3
 8107064:	eeb8 7a67 	vcvt.f32.u32	s14, s15
 8107068:	edd7 6a07 	vldr	s13, [r7, #28]
 810706c:	eec6 7a87 	vdiv.f32	s15, s13, s14
 8107070:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 8107074:	ee17 3a90 	vmov	r3, s15
 8107078:	61bb      	str	r3, [r7, #24]
      }
      else
      {
        sysclockfreq = 0U;
      }
      break;
 810707a:	e005      	b.n	8107088 <HAL_RCC_GetSysClockFreq+0x2c4>
        sysclockfreq = 0U;
 810707c:	2300      	movs	r3, #0
 810707e:	61bb      	str	r3, [r7, #24]
      break;
 8107080:	e002      	b.n	8107088 <HAL_RCC_GetSysClockFreq+0x2c4>

    default:
      sysclockfreq = CSI_VALUE;
 8107082:	4b07      	ldr	r3, [pc, #28]	; (81070a0 <HAL_RCC_GetSysClockFreq+0x2dc>)
 8107084:	61bb      	str	r3, [r7, #24]
      break;
 8107086:	bf00      	nop
  }

  return sysclockfreq;
 8107088:	69bb      	ldr	r3, [r7, #24]
}
 810708a:	4618      	mov	r0, r3
 810708c:	3724      	adds	r7, #36	; 0x24
 810708e:	46bd      	mov	sp, r7
 8107090:	f85d 7b04 	ldr.w	r7, [sp], #4
 8107094:	4770      	bx	lr
 8107096:	bf00      	nop
 8107098:	58024400 	.word	0x58024400
 810709c:	03d09000 	.word	0x03d09000
 81070a0:	003d0900 	.word	0x003d0900
 81070a4:	017d7840 	.word	0x017d7840
 81070a8:	46000000 	.word	0x46000000
 81070ac:	4c742400 	.word	0x4c742400
 81070b0:	4a742400 	.word	0x4a742400
 81070b4:	4bbebc20 	.word	0x4bbebc20

081070b8 <HAL_RCC_GetHCLKFreq>:
  * @note   The SystemD2Clock CMSIS variable is used to store System domain2 Clock Frequency
  *         and updated within this function
  * @retval HCLK frequency
  */
uint32_t HAL_RCC_GetHCLKFreq(void)
{
 81070b8:	b580      	push	{r7, lr}
 81070ba:	b082      	sub	sp, #8
 81070bc:	af00      	add	r7, sp, #0
  uint32_t common_system_clock;

#if defined(RCC_D1CFGR_D1CPRE)
  common_system_clock = HAL_RCC_GetSysClockFreq() >> (D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_D1CPRE) >> RCC_D1CFGR_D1CPRE_Pos] & 0x1FU);
 81070be:	f7ff fe81 	bl	8106dc4 <HAL_RCC_GetSysClockFreq>
 81070c2:	4602      	mov	r2, r0
 81070c4:	4b11      	ldr	r3, [pc, #68]	; (810710c <HAL_RCC_GetHCLKFreq+0x54>)
 81070c6:	699b      	ldr	r3, [r3, #24]
 81070c8:	0a1b      	lsrs	r3, r3, #8
 81070ca:	f003 030f 	and.w	r3, r3, #15
 81070ce:	4910      	ldr	r1, [pc, #64]	; (8107110 <HAL_RCC_GetHCLKFreq+0x58>)
 81070d0:	5ccb      	ldrb	r3, [r1, r3]
 81070d2:	f003 031f 	and.w	r3, r3, #31
 81070d6:	fa22 f303 	lsr.w	r3, r2, r3
 81070da:	607b      	str	r3, [r7, #4]
#else
  common_system_clock = HAL_RCC_GetSysClockFreq() >> (D1CorePrescTable[(RCC->CDCFGR1 & RCC_CDCFGR1_CDCPRE) >> RCC_CDCFGR1_CDCPRE_Pos] & 0x1FU);
#endif

#if defined(RCC_D1CFGR_HPRE)
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE) >> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));
 81070dc:	4b0b      	ldr	r3, [pc, #44]	; (810710c <HAL_RCC_GetHCLKFreq+0x54>)
 81070de:	699b      	ldr	r3, [r3, #24]
 81070e0:	f003 030f 	and.w	r3, r3, #15
 81070e4:	4a0a      	ldr	r2, [pc, #40]	; (8107110 <HAL_RCC_GetHCLKFreq+0x58>)
 81070e6:	5cd3      	ldrb	r3, [r2, r3]
 81070e8:	f003 031f 	and.w	r3, r3, #31
 81070ec:	687a      	ldr	r2, [r7, #4]
 81070ee:	fa22 f303 	lsr.w	r3, r2, r3
 81070f2:	4a08      	ldr	r2, [pc, #32]	; (8107114 <HAL_RCC_GetHCLKFreq+0x5c>)
 81070f4:	6013      	str	r3, [r2, #0]
#else
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->CDCFGR1 & RCC_CDCFGR1_HPRE) >> RCC_CDCFGR1_HPRE_Pos]) & 0x1FU));
#endif

#if defined(DUAL_CORE) && defined(CORE_CM4)
  SystemCoreClock = SystemD2Clock;
 81070f6:	4b07      	ldr	r3, [pc, #28]	; (8107114 <HAL_RCC_GetHCLKFreq+0x5c>)
 81070f8:	681b      	ldr	r3, [r3, #0]
 81070fa:	4a07      	ldr	r2, [pc, #28]	; (8107118 <HAL_RCC_GetHCLKFreq+0x60>)
 81070fc:	6013      	str	r3, [r2, #0]
#else
  SystemCoreClock = common_system_clock;
#endif /* DUAL_CORE && CORE_CM4 */

  return SystemD2Clock;
 81070fe:	4b05      	ldr	r3, [pc, #20]	; (8107114 <HAL_RCC_GetHCLKFreq+0x5c>)
 8107100:	681b      	ldr	r3, [r3, #0]
}
 8107102:	4618      	mov	r0, r3
 8107104:	3708      	adds	r7, #8
 8107106:	46bd      	mov	sp, r7
 8107108:	bd80      	pop	{r7, pc}
 810710a:	bf00      	nop
 810710c:	58024400 	.word	0x58024400
 8107110:	0811f8e4 	.word	0x0811f8e4
 8107114:	10000004 	.word	0x10000004
 8107118:	10000000 	.word	0x10000000

0810711c <HAL_RCC_GetPCLK1Freq>:
  * @note   Each time PCLK1 changes, this function must be called to update the
  *         right PCLK1 value. Otherwise, any configuration based on this function will be incorrect.
  * @retval PCLK1 frequency
  */
uint32_t HAL_RCC_GetPCLK1Freq(void)
{
 810711c:	b580      	push	{r7, lr}
 810711e:	af00      	add	r7, sp, #0
#if defined (RCC_D2CFGR_D2PPRE1)
  /* Get HCLK source and Compute PCLK1 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq() >> ((D1CorePrescTable[(RCC->D2CFGR & RCC_D2CFGR_D2PPRE1) >> RCC_D2CFGR_D2PPRE1_Pos]) & 0x1FU));
 8107120:	f7ff ffca 	bl	81070b8 <HAL_RCC_GetHCLKFreq>
 8107124:	4602      	mov	r2, r0
 8107126:	4b06      	ldr	r3, [pc, #24]	; (8107140 <HAL_RCC_GetPCLK1Freq+0x24>)
 8107128:	69db      	ldr	r3, [r3, #28]
 810712a:	091b      	lsrs	r3, r3, #4
 810712c:	f003 0307 	and.w	r3, r3, #7
 8107130:	4904      	ldr	r1, [pc, #16]	; (8107144 <HAL_RCC_GetPCLK1Freq+0x28>)
 8107132:	5ccb      	ldrb	r3, [r1, r3]
 8107134:	f003 031f 	and.w	r3, r3, #31
 8107138:	fa22 f303 	lsr.w	r3, r2, r3
#else
  /* Get HCLK source and Compute PCLK1 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq() >> ((D1CorePrescTable[(RCC->CDCFGR2 & RCC_CDCFGR2_CDPPRE1) >> RCC_CDCFGR2_CDPPRE1_Pos]) & 0x1FU));
#endif
}
 810713c:	4618      	mov	r0, r3
 810713e:	bd80      	pop	{r7, pc}
 8107140:	58024400 	.word	0x58024400
 8107144:	0811f8e4 	.word	0x0811f8e4

08107148 <HAL_RCC_GetPCLK2Freq>:
  * @note   Each time PCLK2 changes, this function must be called to update the
  *         right PCLK2 value. Otherwise, any configuration based on this function will be incorrect.
  * @retval PCLK1 frequency
  */
uint32_t HAL_RCC_GetPCLK2Freq(void)
{
 8107148:	b580      	push	{r7, lr}
 810714a:	af00      	add	r7, sp, #0
  /* Get HCLK source and Compute PCLK1 frequency ---------------------------*/
#if defined(RCC_D2CFGR_D2PPRE2)
  return (HAL_RCC_GetHCLKFreq() >> ((D1CorePrescTable[(RCC->D2CFGR & RCC_D2CFGR_D2PPRE2) >> RCC_D2CFGR_D2PPRE2_Pos]) & 0x1FU));
 810714c:	f7ff ffb4 	bl	81070b8 <HAL_RCC_GetHCLKFreq>
 8107150:	4602      	mov	r2, r0
 8107152:	4b06      	ldr	r3, [pc, #24]	; (810716c <HAL_RCC_GetPCLK2Freq+0x24>)
 8107154:	69db      	ldr	r3, [r3, #28]
 8107156:	0a1b      	lsrs	r3, r3, #8
 8107158:	f003 0307 	and.w	r3, r3, #7
 810715c:	4904      	ldr	r1, [pc, #16]	; (8107170 <HAL_RCC_GetPCLK2Freq+0x28>)
 810715e:	5ccb      	ldrb	r3, [r1, r3]
 8107160:	f003 031f 	and.w	r3, r3, #31
 8107164:	fa22 f303 	lsr.w	r3, r2, r3
#else
  return (HAL_RCC_GetHCLKFreq() >> ((D1CorePrescTable[(RCC->CDCFGR2 & RCC_CDCFGR2_CDPPRE2) >> RCC_CDCFGR2_CDPPRE2_Pos]) & 0x1FU));
#endif
}
 8107168:	4618      	mov	r0, r3
 810716a:	bd80      	pop	{r7, pc}
 810716c:	58024400 	.word	0x58024400
 8107170:	0811f8e4 	.word	0x0811f8e4

08107174 <HAL_RCCEx_PeriphCLKConfig>:
  * (*) : Available on some STM32H7 lines only.
  *
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCCEx_PeriphCLKConfig(RCC_PeriphCLKInitTypeDef  *PeriphClkInit)
{
 8107174:	e92d 4fb0 	stmdb	sp!, {r4, r5, r7, r8, r9, sl, fp, lr}
 8107178:	b0ca      	sub	sp, #296	; 0x128
 810717a:	af00      	add	r7, sp, #0
 810717c:	f8c7 0114 	str.w	r0, [r7, #276]	; 0x114
  uint32_t tmpreg;
  uint32_t tickstart;
  HAL_StatusTypeDef ret = HAL_OK;      /* Intermediate status */
 8107180:	2300      	movs	r3, #0
 8107182:	f887 3127 	strb.w	r3, [r7, #295]	; 0x127
  HAL_StatusTypeDef status = HAL_OK;   /* Final status */
 8107186:	2300      	movs	r3, #0
 8107188:	f887 3126 	strb.w	r3, [r7, #294]	; 0x126

  /*---------------------------- SPDIFRX configuration -------------------------------*/

  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SPDIFRX) == RCC_PERIPHCLK_SPDIFRX)
 810718c:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 8107190:	e9d3 2300 	ldrd	r2, r3, [r3]
 8107194:	f002 6400 	and.w	r4, r2, #134217728	; 0x8000000
 8107198:	2500      	movs	r5, #0
 810719a:	ea54 0305 	orrs.w	r3, r4, r5
 810719e:	d049      	beq.n	8107234 <HAL_RCCEx_PeriphCLKConfig+0xc0>
  {

    switch (PeriphClkInit->SpdifrxClockSelection)
 81071a0:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 81071a4:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 81071a6:	f5b3 1f40 	cmp.w	r3, #3145728	; 0x300000
 81071aa:	d02f      	beq.n	810720c <HAL_RCCEx_PeriphCLKConfig+0x98>
 81071ac:	f5b3 1f40 	cmp.w	r3, #3145728	; 0x300000
 81071b0:	d828      	bhi.n	8107204 <HAL_RCCEx_PeriphCLKConfig+0x90>
 81071b2:	f5b3 1f00 	cmp.w	r3, #2097152	; 0x200000
 81071b6:	d01a      	beq.n	81071ee <HAL_RCCEx_PeriphCLKConfig+0x7a>
 81071b8:	f5b3 1f00 	cmp.w	r3, #2097152	; 0x200000
 81071bc:	d822      	bhi.n	8107204 <HAL_RCCEx_PeriphCLKConfig+0x90>
 81071be:	2b00      	cmp	r3, #0
 81071c0:	d003      	beq.n	81071ca <HAL_RCCEx_PeriphCLKConfig+0x56>
 81071c2:	f5b3 1f80 	cmp.w	r3, #1048576	; 0x100000
 81071c6:	d007      	beq.n	81071d8 <HAL_RCCEx_PeriphCLKConfig+0x64>
 81071c8:	e01c      	b.n	8107204 <HAL_RCCEx_PeriphCLKConfig+0x90>
    {
      case RCC_SPDIFRXCLKSOURCE_PLL:      /* PLL is used as clock source for SPDIFRX*/
        /* Enable PLL1Q Clock output generated form System PLL . */
        __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
 81071ca:	4bb8      	ldr	r3, [pc, #736]	; (81074ac <HAL_RCCEx_PeriphCLKConfig+0x338>)
 81071cc:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 81071ce:	4ab7      	ldr	r2, [pc, #732]	; (81074ac <HAL_RCCEx_PeriphCLKConfig+0x338>)
 81071d0:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 81071d4:	62d3      	str	r3, [r2, #44]	; 0x2c

        /* SPDIFRX clock source configuration done later after clock selection check */
        break;
 81071d6:	e01a      	b.n	810720e <HAL_RCCEx_PeriphCLKConfig+0x9a>

      case RCC_SPDIFRXCLKSOURCE_PLL2: /* PLL2 is used as clock source for SPDIFRX*/

        ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2), DIVIDER_R_UPDATE);
 81071d8:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 81071dc:	3308      	adds	r3, #8
 81071de:	2102      	movs	r1, #2
 81071e0:	4618      	mov	r0, r3
 81071e2:	f002 fb61 	bl	81098a8 <RCCEx_PLL2_Config>
 81071e6:	4603      	mov	r3, r0
 81071e8:	f887 3127 	strb.w	r3, [r7, #295]	; 0x127

        /* SPDIFRX clock source configuration done later after clock selection check */
        break;
 81071ec:	e00f      	b.n	810720e <HAL_RCCEx_PeriphCLKConfig+0x9a>

      case RCC_SPDIFRXCLKSOURCE_PLL3:  /* PLL3 is used as clock source for SPDIFRX*/
        ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3), DIVIDER_R_UPDATE);
 81071ee:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 81071f2:	3328      	adds	r3, #40	; 0x28
 81071f4:	2102      	movs	r1, #2
 81071f6:	4618      	mov	r0, r3
 81071f8:	f002 fc08 	bl	8109a0c <RCCEx_PLL3_Config>
 81071fc:	4603      	mov	r3, r0
 81071fe:	f887 3127 	strb.w	r3, [r7, #295]	; 0x127

        /* SPDIFRX clock source configuration done later after clock selection check */
        break;
 8107202:	e004      	b.n	810720e <HAL_RCCEx_PeriphCLKConfig+0x9a>
        /* Internal OSC clock is used as source of SPDIFRX clock*/
        /* SPDIFRX clock source configuration done later after clock selection check */
        break;

      default:
        ret = HAL_ERROR;
 8107204:	2301      	movs	r3, #1
 8107206:	f887 3127 	strb.w	r3, [r7, #295]	; 0x127
        break;
 810720a:	e000      	b.n	810720e <HAL_RCCEx_PeriphCLKConfig+0x9a>
        break;
 810720c:	bf00      	nop
    }

    if (ret == HAL_OK)
 810720e:	f897 3127 	ldrb.w	r3, [r7, #295]	; 0x127
 8107212:	2b00      	cmp	r3, #0
 8107214:	d10a      	bne.n	810722c <HAL_RCCEx_PeriphCLKConfig+0xb8>
    {
      /* Set the source of SPDIFRX clock*/
      __HAL_RCC_SPDIFRX_CONFIG(PeriphClkInit->SpdifrxClockSelection);
 8107216:	4ba5      	ldr	r3, [pc, #660]	; (81074ac <HAL_RCCEx_PeriphCLKConfig+0x338>)
 8107218:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 810721a:	f423 1140 	bic.w	r1, r3, #3145728	; 0x300000
 810721e:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 8107222:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 8107224:	4aa1      	ldr	r2, [pc, #644]	; (81074ac <HAL_RCCEx_PeriphCLKConfig+0x338>)
 8107226:	430b      	orrs	r3, r1
 8107228:	6513      	str	r3, [r2, #80]	; 0x50
 810722a:	e003      	b.n	8107234 <HAL_RCCEx_PeriphCLKConfig+0xc0>
    }
    else
    {
      /* set overall return value */
      status = ret;
 810722c:	f897 3127 	ldrb.w	r3, [r7, #295]	; 0x127
 8107230:	f887 3126 	strb.w	r3, [r7, #294]	; 0x126
    }
  }

  /*---------------------------- SAI1 configuration -------------------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI1) == RCC_PERIPHCLK_SAI1)
 8107234:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 8107238:	e9d3 2300 	ldrd	r2, r3, [r3]
 810723c:	f402 7880 	and.w	r8, r2, #256	; 0x100
 8107240:	f04f 0900 	mov.w	r9, #0
 8107244:	ea58 0309 	orrs.w	r3, r8, r9
 8107248:	d047      	beq.n	81072da <HAL_RCCEx_PeriphCLKConfig+0x166>
  {
    switch (PeriphClkInit->Sai1ClockSelection)
 810724a:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 810724e:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8107250:	2b04      	cmp	r3, #4
 8107252:	d82a      	bhi.n	81072aa <HAL_RCCEx_PeriphCLKConfig+0x136>
 8107254:	a201      	add	r2, pc, #4	; (adr r2, 810725c <HAL_RCCEx_PeriphCLKConfig+0xe8>)
 8107256:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 810725a:	bf00      	nop
 810725c:	08107271 	.word	0x08107271
 8107260:	0810727f 	.word	0x0810727f
 8107264:	08107295 	.word	0x08107295
 8107268:	081072b3 	.word	0x081072b3
 810726c:	081072b3 	.word	0x081072b3
    {
      case RCC_SAI1CLKSOURCE_PLL:      /* PLL is used as clock source for SAI1*/
        /* Enable SAI Clock output generated form System PLL . */
        __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
 8107270:	4b8e      	ldr	r3, [pc, #568]	; (81074ac <HAL_RCCEx_PeriphCLKConfig+0x338>)
 8107272:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8107274:	4a8d      	ldr	r2, [pc, #564]	; (81074ac <HAL_RCCEx_PeriphCLKConfig+0x338>)
 8107276:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 810727a:	62d3      	str	r3, [r2, #44]	; 0x2c

        /* SAI1 clock source configuration done later after clock selection check */
        break;
 810727c:	e01a      	b.n	81072b4 <HAL_RCCEx_PeriphCLKConfig+0x140>

      case RCC_SAI1CLKSOURCE_PLL2: /* PLL2 is used as clock source for SAI1*/

        ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2), DIVIDER_P_UPDATE);
 810727e:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 8107282:	3308      	adds	r3, #8
 8107284:	2100      	movs	r1, #0
 8107286:	4618      	mov	r0, r3
 8107288:	f002 fb0e 	bl	81098a8 <RCCEx_PLL2_Config>
 810728c:	4603      	mov	r3, r0
 810728e:	f887 3127 	strb.w	r3, [r7, #295]	; 0x127

        /* SAI1 clock source configuration done later after clock selection check */
        break;
 8107292:	e00f      	b.n	81072b4 <HAL_RCCEx_PeriphCLKConfig+0x140>

      case RCC_SAI1CLKSOURCE_PLL3:  /* PLL3 is used as clock source for SAI1*/
        ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3), DIVIDER_P_UPDATE);
 8107294:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 8107298:	3328      	adds	r3, #40	; 0x28
 810729a:	2100      	movs	r1, #0
 810729c:	4618      	mov	r0, r3
 810729e:	f002 fbb5 	bl	8109a0c <RCCEx_PLL3_Config>
 81072a2:	4603      	mov	r3, r0
 81072a4:	f887 3127 	strb.w	r3, [r7, #295]	; 0x127

        /* SAI1 clock source configuration done later after clock selection check */
        break;
 81072a8:	e004      	b.n	81072b4 <HAL_RCCEx_PeriphCLKConfig+0x140>
        /* HSI, HSE, or CSI oscillator is used as source of SAI1 clock */
        /* SAI1 clock source configuration done later after clock selection check */
        break;

      default:
        ret = HAL_ERROR;
 81072aa:	2301      	movs	r3, #1
 81072ac:	f887 3127 	strb.w	r3, [r7, #295]	; 0x127
        break;
 81072b0:	e000      	b.n	81072b4 <HAL_RCCEx_PeriphCLKConfig+0x140>
        break;
 81072b2:	bf00      	nop
    }

    if (ret == HAL_OK)
 81072b4:	f897 3127 	ldrb.w	r3, [r7, #295]	; 0x127
 81072b8:	2b00      	cmp	r3, #0
 81072ba:	d10a      	bne.n	81072d2 <HAL_RCCEx_PeriphCLKConfig+0x15e>
    {
      /* Set the source of SAI1 clock*/
      __HAL_RCC_SAI1_CONFIG(PeriphClkInit->Sai1ClockSelection);
 81072bc:	4b7b      	ldr	r3, [pc, #492]	; (81074ac <HAL_RCCEx_PeriphCLKConfig+0x338>)
 81072be:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 81072c0:	f023 0107 	bic.w	r1, r3, #7
 81072c4:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 81072c8:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 81072ca:	4a78      	ldr	r2, [pc, #480]	; (81074ac <HAL_RCCEx_PeriphCLKConfig+0x338>)
 81072cc:	430b      	orrs	r3, r1
 81072ce:	6513      	str	r3, [r2, #80]	; 0x50
 81072d0:	e003      	b.n	81072da <HAL_RCCEx_PeriphCLKConfig+0x166>
    }
    else
    {
      /* set overall return value */
      status = ret;
 81072d2:	f897 3127 	ldrb.w	r3, [r7, #295]	; 0x127
 81072d6:	f887 3126 	strb.w	r3, [r7, #294]	; 0x126
    }
  }

#if defined(SAI3)
  /*---------------------------- SAI2/3 configuration -------------------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI23) == RCC_PERIPHCLK_SAI23)
 81072da:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 81072de:	e9d3 2300 	ldrd	r2, r3, [r3]
 81072e2:	f402 7a00 	and.w	sl, r2, #512	; 0x200
 81072e6:	f04f 0b00 	mov.w	fp, #0
 81072ea:	ea5a 030b 	orrs.w	r3, sl, fp
 81072ee:	d04c      	beq.n	810738a <HAL_RCCEx_PeriphCLKConfig+0x216>
  {
    switch (PeriphClkInit->Sai23ClockSelection)
 81072f0:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 81072f4:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 81072f6:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 81072fa:	d030      	beq.n	810735e <HAL_RCCEx_PeriphCLKConfig+0x1ea>
 81072fc:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 8107300:	d829      	bhi.n	8107356 <HAL_RCCEx_PeriphCLKConfig+0x1e2>
 8107302:	2bc0      	cmp	r3, #192	; 0xc0
 8107304:	d02d      	beq.n	8107362 <HAL_RCCEx_PeriphCLKConfig+0x1ee>
 8107306:	2bc0      	cmp	r3, #192	; 0xc0
 8107308:	d825      	bhi.n	8107356 <HAL_RCCEx_PeriphCLKConfig+0x1e2>
 810730a:	2b80      	cmp	r3, #128	; 0x80
 810730c:	d018      	beq.n	8107340 <HAL_RCCEx_PeriphCLKConfig+0x1cc>
 810730e:	2b80      	cmp	r3, #128	; 0x80
 8107310:	d821      	bhi.n	8107356 <HAL_RCCEx_PeriphCLKConfig+0x1e2>
 8107312:	2b00      	cmp	r3, #0
 8107314:	d002      	beq.n	810731c <HAL_RCCEx_PeriphCLKConfig+0x1a8>
 8107316:	2b40      	cmp	r3, #64	; 0x40
 8107318:	d007      	beq.n	810732a <HAL_RCCEx_PeriphCLKConfig+0x1b6>
 810731a:	e01c      	b.n	8107356 <HAL_RCCEx_PeriphCLKConfig+0x1e2>
    {
      case RCC_SAI23CLKSOURCE_PLL:      /* PLL is used as clock source for SAI2/3 */
        /* Enable SAI Clock output generated form System PLL . */
        __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
 810731c:	4b63      	ldr	r3, [pc, #396]	; (81074ac <HAL_RCCEx_PeriphCLKConfig+0x338>)
 810731e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8107320:	4a62      	ldr	r2, [pc, #392]	; (81074ac <HAL_RCCEx_PeriphCLKConfig+0x338>)
 8107322:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 8107326:	62d3      	str	r3, [r2, #44]	; 0x2c

        /* SAI2/3 clock source configuration done later after clock selection check */
        break;
 8107328:	e01c      	b.n	8107364 <HAL_RCCEx_PeriphCLKConfig+0x1f0>

      case RCC_SAI23CLKSOURCE_PLL2: /* PLL2 is used as clock source for SAI2/3 */

        ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2), DIVIDER_P_UPDATE);
 810732a:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 810732e:	3308      	adds	r3, #8
 8107330:	2100      	movs	r1, #0
 8107332:	4618      	mov	r0, r3
 8107334:	f002 fab8 	bl	81098a8 <RCCEx_PLL2_Config>
 8107338:	4603      	mov	r3, r0
 810733a:	f887 3127 	strb.w	r3, [r7, #295]	; 0x127

        /* SAI2/3 clock source configuration done later after clock selection check */
        break;
 810733e:	e011      	b.n	8107364 <HAL_RCCEx_PeriphCLKConfig+0x1f0>

      case RCC_SAI23CLKSOURCE_PLL3:  /* PLL3 is used as clock source for SAI2/3 */
        ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3), DIVIDER_P_UPDATE);
 8107340:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 8107344:	3328      	adds	r3, #40	; 0x28
 8107346:	2100      	movs	r1, #0
 8107348:	4618      	mov	r0, r3
 810734a:	f002 fb5f 	bl	8109a0c <RCCEx_PLL3_Config>
 810734e:	4603      	mov	r3, r0
 8107350:	f887 3127 	strb.w	r3, [r7, #295]	; 0x127

        /* SAI2/3 clock source configuration done later after clock selection check */
        break;
 8107354:	e006      	b.n	8107364 <HAL_RCCEx_PeriphCLKConfig+0x1f0>
        /* HSI, HSE, or CSI oscillator is used as source of SAI2/3 clock */
        /* SAI2/3 clock source configuration done later after clock selection check */
        break;

      default:
        ret = HAL_ERROR;
 8107356:	2301      	movs	r3, #1
 8107358:	f887 3127 	strb.w	r3, [r7, #295]	; 0x127
        break;
 810735c:	e002      	b.n	8107364 <HAL_RCCEx_PeriphCLKConfig+0x1f0>
        break;
 810735e:	bf00      	nop
 8107360:	e000      	b.n	8107364 <HAL_RCCEx_PeriphCLKConfig+0x1f0>
        break;
 8107362:	bf00      	nop
    }

    if (ret == HAL_OK)
 8107364:	f897 3127 	ldrb.w	r3, [r7, #295]	; 0x127
 8107368:	2b00      	cmp	r3, #0
 810736a:	d10a      	bne.n	8107382 <HAL_RCCEx_PeriphCLKConfig+0x20e>
    {
      /* Set the source of SAI2/3 clock*/
      __HAL_RCC_SAI23_CONFIG(PeriphClkInit->Sai23ClockSelection);
 810736c:	4b4f      	ldr	r3, [pc, #316]	; (81074ac <HAL_RCCEx_PeriphCLKConfig+0x338>)
 810736e:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8107370:	f423 71e0 	bic.w	r1, r3, #448	; 0x1c0
 8107374:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 8107378:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 810737a:	4a4c      	ldr	r2, [pc, #304]	; (81074ac <HAL_RCCEx_PeriphCLKConfig+0x338>)
 810737c:	430b      	orrs	r3, r1
 810737e:	6513      	str	r3, [r2, #80]	; 0x50
 8107380:	e003      	b.n	810738a <HAL_RCCEx_PeriphCLKConfig+0x216>
    }
    else
    {
      /* set overall return value */
      status = ret;
 8107382:	f897 3127 	ldrb.w	r3, [r7, #295]	; 0x127
 8107386:	f887 3126 	strb.w	r3, [r7, #294]	; 0x126
  }
#endif  /*SAI2B*/

#if defined(SAI4)
  /*---------------------------- SAI4A configuration -------------------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI4A) == RCC_PERIPHCLK_SAI4A)
 810738a:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 810738e:	e9d3 2300 	ldrd	r2, r3, [r3]
 8107392:	f402 6380 	and.w	r3, r2, #1024	; 0x400
 8107396:	f8c7 3108 	str.w	r3, [r7, #264]	; 0x108
 810739a:	2300      	movs	r3, #0
 810739c:	f8c7 310c 	str.w	r3, [r7, #268]	; 0x10c
 81073a0:	e9d7 1242 	ldrd	r1, r2, [r7, #264]	; 0x108
 81073a4:	460b      	mov	r3, r1
 81073a6:	4313      	orrs	r3, r2
 81073a8:	d053      	beq.n	8107452 <HAL_RCCEx_PeriphCLKConfig+0x2de>
  {
    switch (PeriphClkInit->Sai4AClockSelection)
 81073aa:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 81073ae:	f8d3 30a8 	ldr.w	r3, [r3, #168]	; 0xa8
 81073b2:	f5b3 0f00 	cmp.w	r3, #8388608	; 0x800000
 81073b6:	d035      	beq.n	8107424 <HAL_RCCEx_PeriphCLKConfig+0x2b0>
 81073b8:	f5b3 0f00 	cmp.w	r3, #8388608	; 0x800000
 81073bc:	d82e      	bhi.n	810741c <HAL_RCCEx_PeriphCLKConfig+0x2a8>
 81073be:	f5b3 0fc0 	cmp.w	r3, #6291456	; 0x600000
 81073c2:	d031      	beq.n	8107428 <HAL_RCCEx_PeriphCLKConfig+0x2b4>
 81073c4:	f5b3 0fc0 	cmp.w	r3, #6291456	; 0x600000
 81073c8:	d828      	bhi.n	810741c <HAL_RCCEx_PeriphCLKConfig+0x2a8>
 81073ca:	f5b3 0f80 	cmp.w	r3, #4194304	; 0x400000
 81073ce:	d01a      	beq.n	8107406 <HAL_RCCEx_PeriphCLKConfig+0x292>
 81073d0:	f5b3 0f80 	cmp.w	r3, #4194304	; 0x400000
 81073d4:	d822      	bhi.n	810741c <HAL_RCCEx_PeriphCLKConfig+0x2a8>
 81073d6:	2b00      	cmp	r3, #0
 81073d8:	d003      	beq.n	81073e2 <HAL_RCCEx_PeriphCLKConfig+0x26e>
 81073da:	f5b3 1f00 	cmp.w	r3, #2097152	; 0x200000
 81073de:	d007      	beq.n	81073f0 <HAL_RCCEx_PeriphCLKConfig+0x27c>
 81073e0:	e01c      	b.n	810741c <HAL_RCCEx_PeriphCLKConfig+0x2a8>
    {
      case RCC_SAI4ACLKSOURCE_PLL:      /* PLL is used as clock source for SAI2*/
        /* Enable SAI Clock output generated form System PLL . */
        __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
 81073e2:	4b32      	ldr	r3, [pc, #200]	; (81074ac <HAL_RCCEx_PeriphCLKConfig+0x338>)
 81073e4:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 81073e6:	4a31      	ldr	r2, [pc, #196]	; (81074ac <HAL_RCCEx_PeriphCLKConfig+0x338>)
 81073e8:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 81073ec:	62d3      	str	r3, [r2, #44]	; 0x2c

        /* SAI1 clock source configuration done later after clock selection check */
        break;
 81073ee:	e01c      	b.n	810742a <HAL_RCCEx_PeriphCLKConfig+0x2b6>

      case RCC_SAI4ACLKSOURCE_PLL2: /* PLL2 is used as clock source for SAI2*/

        ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2), DIVIDER_P_UPDATE);
 81073f0:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 81073f4:	3308      	adds	r3, #8
 81073f6:	2100      	movs	r1, #0
 81073f8:	4618      	mov	r0, r3
 81073fa:	f002 fa55 	bl	81098a8 <RCCEx_PLL2_Config>
 81073fe:	4603      	mov	r3, r0
 8107400:	f887 3127 	strb.w	r3, [r7, #295]	; 0x127

        /* SAI2 clock source configuration done later after clock selection check */
        break;
 8107404:	e011      	b.n	810742a <HAL_RCCEx_PeriphCLKConfig+0x2b6>

      case RCC_SAI4ACLKSOURCE_PLL3:  /* PLL3 is used as clock source for SAI2*/
        ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3), DIVIDER_P_UPDATE);
 8107406:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 810740a:	3328      	adds	r3, #40	; 0x28
 810740c:	2100      	movs	r1, #0
 810740e:	4618      	mov	r0, r3
 8107410:	f002 fafc 	bl	8109a0c <RCCEx_PLL3_Config>
 8107414:	4603      	mov	r3, r0
 8107416:	f887 3127 	strb.w	r3, [r7, #295]	; 0x127

        /* SAI1 clock source configuration done later after clock selection check */
        break;
 810741a:	e006      	b.n	810742a <HAL_RCCEx_PeriphCLKConfig+0x2b6>
        /* SAI4A clock source configuration done later after clock selection check */
        break;
#endif /* RCC_VER_3_0 */

      default:
        ret = HAL_ERROR;
 810741c:	2301      	movs	r3, #1
 810741e:	f887 3127 	strb.w	r3, [r7, #295]	; 0x127
        break;
 8107422:	e002      	b.n	810742a <HAL_RCCEx_PeriphCLKConfig+0x2b6>
        break;
 8107424:	bf00      	nop
 8107426:	e000      	b.n	810742a <HAL_RCCEx_PeriphCLKConfig+0x2b6>
        break;
 8107428:	bf00      	nop
    }

    if (ret == HAL_OK)
 810742a:	f897 3127 	ldrb.w	r3, [r7, #295]	; 0x127
 810742e:	2b00      	cmp	r3, #0
 8107430:	d10b      	bne.n	810744a <HAL_RCCEx_PeriphCLKConfig+0x2d6>
    {
      /* Set the source of SAI4A clock*/
      __HAL_RCC_SAI4A_CONFIG(PeriphClkInit->Sai4AClockSelection);
 8107432:	4b1e      	ldr	r3, [pc, #120]	; (81074ac <HAL_RCCEx_PeriphCLKConfig+0x338>)
 8107434:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8107436:	f423 0160 	bic.w	r1, r3, #14680064	; 0xe00000
 810743a:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 810743e:	f8d3 30a8 	ldr.w	r3, [r3, #168]	; 0xa8
 8107442:	4a1a      	ldr	r2, [pc, #104]	; (81074ac <HAL_RCCEx_PeriphCLKConfig+0x338>)
 8107444:	430b      	orrs	r3, r1
 8107446:	6593      	str	r3, [r2, #88]	; 0x58
 8107448:	e003      	b.n	8107452 <HAL_RCCEx_PeriphCLKConfig+0x2de>
    }
    else
    {
      /* set overall return value */
      status = ret;
 810744a:	f897 3127 	ldrb.w	r3, [r7, #295]	; 0x127
 810744e:	f887 3126 	strb.w	r3, [r7, #294]	; 0x126
    }
  }
  /*---------------------------- SAI4B configuration -------------------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI4B) == RCC_PERIPHCLK_SAI4B)
 8107452:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 8107456:	e9d3 2300 	ldrd	r2, r3, [r3]
 810745a:	f402 6300 	and.w	r3, r2, #2048	; 0x800
 810745e:	f8c7 3100 	str.w	r3, [r7, #256]	; 0x100
 8107462:	2300      	movs	r3, #0
 8107464:	f8c7 3104 	str.w	r3, [r7, #260]	; 0x104
 8107468:	e9d7 1240 	ldrd	r1, r2, [r7, #256]	; 0x100
 810746c:	460b      	mov	r3, r1
 810746e:	4313      	orrs	r3, r2
 8107470:	d056      	beq.n	8107520 <HAL_RCCEx_PeriphCLKConfig+0x3ac>
  {
    switch (PeriphClkInit->Sai4BClockSelection)
 8107472:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 8107476:	f8d3 30ac 	ldr.w	r3, [r3, #172]	; 0xac
 810747a:	f1b3 6f80 	cmp.w	r3, #67108864	; 0x4000000
 810747e:	d038      	beq.n	81074f2 <HAL_RCCEx_PeriphCLKConfig+0x37e>
 8107480:	f1b3 6f80 	cmp.w	r3, #67108864	; 0x4000000
 8107484:	d831      	bhi.n	81074ea <HAL_RCCEx_PeriphCLKConfig+0x376>
 8107486:	f1b3 7f40 	cmp.w	r3, #50331648	; 0x3000000
 810748a:	d034      	beq.n	81074f6 <HAL_RCCEx_PeriphCLKConfig+0x382>
 810748c:	f1b3 7f40 	cmp.w	r3, #50331648	; 0x3000000
 8107490:	d82b      	bhi.n	81074ea <HAL_RCCEx_PeriphCLKConfig+0x376>
 8107492:	f1b3 7f00 	cmp.w	r3, #33554432	; 0x2000000
 8107496:	d01d      	beq.n	81074d4 <HAL_RCCEx_PeriphCLKConfig+0x360>
 8107498:	f1b3 7f00 	cmp.w	r3, #33554432	; 0x2000000
 810749c:	d825      	bhi.n	81074ea <HAL_RCCEx_PeriphCLKConfig+0x376>
 810749e:	2b00      	cmp	r3, #0
 81074a0:	d006      	beq.n	81074b0 <HAL_RCCEx_PeriphCLKConfig+0x33c>
 81074a2:	f1b3 7f80 	cmp.w	r3, #16777216	; 0x1000000
 81074a6:	d00a      	beq.n	81074be <HAL_RCCEx_PeriphCLKConfig+0x34a>
 81074a8:	e01f      	b.n	81074ea <HAL_RCCEx_PeriphCLKConfig+0x376>
 81074aa:	bf00      	nop
 81074ac:	58024400 	.word	0x58024400
    {
      case RCC_SAI4BCLKSOURCE_PLL:      /* PLL is used as clock source for SAI2*/
        /* Enable SAI Clock output generated form System PLL . */
        __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
 81074b0:	4ba2      	ldr	r3, [pc, #648]	; (810773c <HAL_RCCEx_PeriphCLKConfig+0x5c8>)
 81074b2:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 81074b4:	4aa1      	ldr	r2, [pc, #644]	; (810773c <HAL_RCCEx_PeriphCLKConfig+0x5c8>)
 81074b6:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 81074ba:	62d3      	str	r3, [r2, #44]	; 0x2c

        /* SAI1 clock source configuration done later after clock selection check */
        break;
 81074bc:	e01c      	b.n	81074f8 <HAL_RCCEx_PeriphCLKConfig+0x384>

      case RCC_SAI4BCLKSOURCE_PLL2: /* PLL2 is used as clock source for SAI2*/

        ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2), DIVIDER_P_UPDATE);
 81074be:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 81074c2:	3308      	adds	r3, #8
 81074c4:	2100      	movs	r1, #0
 81074c6:	4618      	mov	r0, r3
 81074c8:	f002 f9ee 	bl	81098a8 <RCCEx_PLL2_Config>
 81074cc:	4603      	mov	r3, r0
 81074ce:	f887 3127 	strb.w	r3, [r7, #295]	; 0x127

        /* SAI2 clock source configuration done later after clock selection check */
        break;
 81074d2:	e011      	b.n	81074f8 <HAL_RCCEx_PeriphCLKConfig+0x384>

      case RCC_SAI4BCLKSOURCE_PLL3:  /* PLL3 is used as clock source for SAI2*/
        ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3), DIVIDER_P_UPDATE);
 81074d4:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 81074d8:	3328      	adds	r3, #40	; 0x28
 81074da:	2100      	movs	r1, #0
 81074dc:	4618      	mov	r0, r3
 81074de:	f002 fa95 	bl	8109a0c <RCCEx_PLL3_Config>
 81074e2:	4603      	mov	r3, r0
 81074e4:	f887 3127 	strb.w	r3, [r7, #295]	; 0x127

        /* SAI1 clock source configuration done later after clock selection check */
        break;
 81074e8:	e006      	b.n	81074f8 <HAL_RCCEx_PeriphCLKConfig+0x384>
        /* SAI4B clock source configuration done later after clock selection check */
        break;
#endif /* RCC_VER_3_0 */

      default:
        ret = HAL_ERROR;
 81074ea:	2301      	movs	r3, #1
 81074ec:	f887 3127 	strb.w	r3, [r7, #295]	; 0x127
        break;
 81074f0:	e002      	b.n	81074f8 <HAL_RCCEx_PeriphCLKConfig+0x384>
        break;
 81074f2:	bf00      	nop
 81074f4:	e000      	b.n	81074f8 <HAL_RCCEx_PeriphCLKConfig+0x384>
        break;
 81074f6:	bf00      	nop
    }

    if (ret == HAL_OK)
 81074f8:	f897 3127 	ldrb.w	r3, [r7, #295]	; 0x127
 81074fc:	2b00      	cmp	r3, #0
 81074fe:	d10b      	bne.n	8107518 <HAL_RCCEx_PeriphCLKConfig+0x3a4>
    {
      /* Set the source of SAI4B clock*/
      __HAL_RCC_SAI4B_CONFIG(PeriphClkInit->Sai4BClockSelection);
 8107500:	4b8e      	ldr	r3, [pc, #568]	; (810773c <HAL_RCCEx_PeriphCLKConfig+0x5c8>)
 8107502:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8107504:	f023 61e0 	bic.w	r1, r3, #117440512	; 0x7000000
 8107508:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 810750c:	f8d3 30ac 	ldr.w	r3, [r3, #172]	; 0xac
 8107510:	4a8a      	ldr	r2, [pc, #552]	; (810773c <HAL_RCCEx_PeriphCLKConfig+0x5c8>)
 8107512:	430b      	orrs	r3, r1
 8107514:	6593      	str	r3, [r2, #88]	; 0x58
 8107516:	e003      	b.n	8107520 <HAL_RCCEx_PeriphCLKConfig+0x3ac>
    }
    else
    {
      /* set overall return value */
      status = ret;
 8107518:	f897 3127 	ldrb.w	r3, [r7, #295]	; 0x127
 810751c:	f887 3126 	strb.w	r3, [r7, #294]	; 0x126
  }
#endif  /*SAI4*/

#if defined(QUADSPI)
  /*---------------------------- QSPI configuration -------------------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_QSPI) == RCC_PERIPHCLK_QSPI)
 8107520:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 8107524:	e9d3 2300 	ldrd	r2, r3, [r3]
 8107528:	f002 7300 	and.w	r3, r2, #33554432	; 0x2000000
 810752c:	f8c7 30f8 	str.w	r3, [r7, #248]	; 0xf8
 8107530:	2300      	movs	r3, #0
 8107532:	f8c7 30fc 	str.w	r3, [r7, #252]	; 0xfc
 8107536:	e9d7 123e 	ldrd	r1, r2, [r7, #248]	; 0xf8
 810753a:	460b      	mov	r3, r1
 810753c:	4313      	orrs	r3, r2
 810753e:	d03a      	beq.n	81075b6 <HAL_RCCEx_PeriphCLKConfig+0x442>
  {
    switch (PeriphClkInit->QspiClockSelection)
 8107540:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 8107544:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8107546:	2b30      	cmp	r3, #48	; 0x30
 8107548:	d01f      	beq.n	810758a <HAL_RCCEx_PeriphCLKConfig+0x416>
 810754a:	2b30      	cmp	r3, #48	; 0x30
 810754c:	d819      	bhi.n	8107582 <HAL_RCCEx_PeriphCLKConfig+0x40e>
 810754e:	2b20      	cmp	r3, #32
 8107550:	d00c      	beq.n	810756c <HAL_RCCEx_PeriphCLKConfig+0x3f8>
 8107552:	2b20      	cmp	r3, #32
 8107554:	d815      	bhi.n	8107582 <HAL_RCCEx_PeriphCLKConfig+0x40e>
 8107556:	2b00      	cmp	r3, #0
 8107558:	d019      	beq.n	810758e <HAL_RCCEx_PeriphCLKConfig+0x41a>
 810755a:	2b10      	cmp	r3, #16
 810755c:	d111      	bne.n	8107582 <HAL_RCCEx_PeriphCLKConfig+0x40e>
    {
      case RCC_QSPICLKSOURCE_PLL:      /* PLL is used as clock source for QSPI*/
        /* Enable QSPI Clock output generated form System PLL . */
        __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
 810755e:	4b77      	ldr	r3, [pc, #476]	; (810773c <HAL_RCCEx_PeriphCLKConfig+0x5c8>)
 8107560:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8107562:	4a76      	ldr	r2, [pc, #472]	; (810773c <HAL_RCCEx_PeriphCLKConfig+0x5c8>)
 8107564:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 8107568:	62d3      	str	r3, [r2, #44]	; 0x2c

        /* QSPI clock source configuration done later after clock selection check */
        break;
 810756a:	e011      	b.n	8107590 <HAL_RCCEx_PeriphCLKConfig+0x41c>

      case RCC_QSPICLKSOURCE_PLL2: /* PLL2 is used as clock source for QSPI*/

        ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2), DIVIDER_R_UPDATE);
 810756c:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 8107570:	3308      	adds	r3, #8
 8107572:	2102      	movs	r1, #2
 8107574:	4618      	mov	r0, r3
 8107576:	f002 f997 	bl	81098a8 <RCCEx_PLL2_Config>
 810757a:	4603      	mov	r3, r0
 810757c:	f887 3127 	strb.w	r3, [r7, #295]	; 0x127

        /* QSPI clock source configuration done later after clock selection check */
        break;
 8107580:	e006      	b.n	8107590 <HAL_RCCEx_PeriphCLKConfig+0x41c>
      case RCC_QSPICLKSOURCE_D1HCLK:
        /* Domain1 HCLK  clock selected as QSPI kernel peripheral clock */
        break;

      default:
        ret = HAL_ERROR;
 8107582:	2301      	movs	r3, #1
 8107584:	f887 3127 	strb.w	r3, [r7, #295]	; 0x127
        break;
 8107588:	e002      	b.n	8107590 <HAL_RCCEx_PeriphCLKConfig+0x41c>
        break;
 810758a:	bf00      	nop
 810758c:	e000      	b.n	8107590 <HAL_RCCEx_PeriphCLKConfig+0x41c>
        break;
 810758e:	bf00      	nop
    }

    if (ret == HAL_OK)
 8107590:	f897 3127 	ldrb.w	r3, [r7, #295]	; 0x127
 8107594:	2b00      	cmp	r3, #0
 8107596:	d10a      	bne.n	81075ae <HAL_RCCEx_PeriphCLKConfig+0x43a>
    {
      /* Set the source of QSPI clock*/
      __HAL_RCC_QSPI_CONFIG(PeriphClkInit->QspiClockSelection);
 8107598:	4b68      	ldr	r3, [pc, #416]	; (810773c <HAL_RCCEx_PeriphCLKConfig+0x5c8>)
 810759a:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 810759c:	f023 0130 	bic.w	r1, r3, #48	; 0x30
 81075a0:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 81075a4:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 81075a6:	4a65      	ldr	r2, [pc, #404]	; (810773c <HAL_RCCEx_PeriphCLKConfig+0x5c8>)
 81075a8:	430b      	orrs	r3, r1
 81075aa:	64d3      	str	r3, [r2, #76]	; 0x4c
 81075ac:	e003      	b.n	81075b6 <HAL_RCCEx_PeriphCLKConfig+0x442>
    }
    else
    {
      /* set overall return value */
      status = ret;
 81075ae:	f897 3127 	ldrb.w	r3, [r7, #295]	; 0x127
 81075b2:	f887 3126 	strb.w	r3, [r7, #294]	; 0x126
    }
  }
#endif  /*OCTOSPI*/

  /*---------------------------- SPI1/2/3 configuration -------------------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SPI123) == RCC_PERIPHCLK_SPI123)
 81075b6:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 81075ba:	e9d3 2300 	ldrd	r2, r3, [r3]
 81075be:	f402 5380 	and.w	r3, r2, #4096	; 0x1000
 81075c2:	f8c7 30f0 	str.w	r3, [r7, #240]	; 0xf0
 81075c6:	2300      	movs	r3, #0
 81075c8:	f8c7 30f4 	str.w	r3, [r7, #244]	; 0xf4
 81075cc:	e9d7 123c 	ldrd	r1, r2, [r7, #240]	; 0xf0
 81075d0:	460b      	mov	r3, r1
 81075d2:	4313      	orrs	r3, r2
 81075d4:	d051      	beq.n	810767a <HAL_RCCEx_PeriphCLKConfig+0x506>
  {
    switch (PeriphClkInit->Spi123ClockSelection)
 81075d6:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 81075da:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 81075dc:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
 81075e0:	d035      	beq.n	810764e <HAL_RCCEx_PeriphCLKConfig+0x4da>
 81075e2:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
 81075e6:	d82e      	bhi.n	8107646 <HAL_RCCEx_PeriphCLKConfig+0x4d2>
 81075e8:	f5b3 5f40 	cmp.w	r3, #12288	; 0x3000
 81075ec:	d031      	beq.n	8107652 <HAL_RCCEx_PeriphCLKConfig+0x4de>
 81075ee:	f5b3 5f40 	cmp.w	r3, #12288	; 0x3000
 81075f2:	d828      	bhi.n	8107646 <HAL_RCCEx_PeriphCLKConfig+0x4d2>
 81075f4:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
 81075f8:	d01a      	beq.n	8107630 <HAL_RCCEx_PeriphCLKConfig+0x4bc>
 81075fa:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
 81075fe:	d822      	bhi.n	8107646 <HAL_RCCEx_PeriphCLKConfig+0x4d2>
 8107600:	2b00      	cmp	r3, #0
 8107602:	d003      	beq.n	810760c <HAL_RCCEx_PeriphCLKConfig+0x498>
 8107604:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
 8107608:	d007      	beq.n	810761a <HAL_RCCEx_PeriphCLKConfig+0x4a6>
 810760a:	e01c      	b.n	8107646 <HAL_RCCEx_PeriphCLKConfig+0x4d2>
    {
      case RCC_SPI123CLKSOURCE_PLL:      /* PLL is used as clock source for SPI1/2/3 */
        /* Enable SPI Clock output generated form System PLL . */
        __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
 810760c:	4b4b      	ldr	r3, [pc, #300]	; (810773c <HAL_RCCEx_PeriphCLKConfig+0x5c8>)
 810760e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8107610:	4a4a      	ldr	r2, [pc, #296]	; (810773c <HAL_RCCEx_PeriphCLKConfig+0x5c8>)
 8107612:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 8107616:	62d3      	str	r3, [r2, #44]	; 0x2c

        /* SPI1/2/3 clock source configuration done later after clock selection check */
        break;
 8107618:	e01c      	b.n	8107654 <HAL_RCCEx_PeriphCLKConfig+0x4e0>

      case RCC_SPI123CLKSOURCE_PLL2: /* PLL2 is used as clock source for SPI1/2/3 */
        ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2), DIVIDER_P_UPDATE);
 810761a:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 810761e:	3308      	adds	r3, #8
 8107620:	2100      	movs	r1, #0
 8107622:	4618      	mov	r0, r3
 8107624:	f002 f940 	bl	81098a8 <RCCEx_PLL2_Config>
 8107628:	4603      	mov	r3, r0
 810762a:	f887 3127 	strb.w	r3, [r7, #295]	; 0x127

        /* SPI1/2/3 clock source configuration done later after clock selection check */
        break;
 810762e:	e011      	b.n	8107654 <HAL_RCCEx_PeriphCLKConfig+0x4e0>

      case RCC_SPI123CLKSOURCE_PLL3:  /* PLL3 is used as clock source for SPI1/2/3 */
        ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3), DIVIDER_P_UPDATE);
 8107630:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 8107634:	3328      	adds	r3, #40	; 0x28
 8107636:	2100      	movs	r1, #0
 8107638:	4618      	mov	r0, r3
 810763a:	f002 f9e7 	bl	8109a0c <RCCEx_PLL3_Config>
 810763e:	4603      	mov	r3, r0
 8107640:	f887 3127 	strb.w	r3, [r7, #295]	; 0x127

        /* SPI1/2/3 clock source configuration done later after clock selection check */
        break;
 8107644:	e006      	b.n	8107654 <HAL_RCCEx_PeriphCLKConfig+0x4e0>
        /* HSI, HSE, or CSI oscillator is used as source of SPI1/2/3 clock */
        /* SPI1/2/3 clock source configuration done later after clock selection check */
        break;

      default:
        ret = HAL_ERROR;
 8107646:	2301      	movs	r3, #1
 8107648:	f887 3127 	strb.w	r3, [r7, #295]	; 0x127
        break;
 810764c:	e002      	b.n	8107654 <HAL_RCCEx_PeriphCLKConfig+0x4e0>
        break;
 810764e:	bf00      	nop
 8107650:	e000      	b.n	8107654 <HAL_RCCEx_PeriphCLKConfig+0x4e0>
        break;
 8107652:	bf00      	nop
    }

    if (ret == HAL_OK)
 8107654:	f897 3127 	ldrb.w	r3, [r7, #295]	; 0x127
 8107658:	2b00      	cmp	r3, #0
 810765a:	d10a      	bne.n	8107672 <HAL_RCCEx_PeriphCLKConfig+0x4fe>
    {
      /* Set the source of SPI1/2/3 clock*/
      __HAL_RCC_SPI123_CONFIG(PeriphClkInit->Spi123ClockSelection);
 810765c:	4b37      	ldr	r3, [pc, #220]	; (810773c <HAL_RCCEx_PeriphCLKConfig+0x5c8>)
 810765e:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8107660:	f423 41e0 	bic.w	r1, r3, #28672	; 0x7000
 8107664:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 8107668:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 810766a:	4a34      	ldr	r2, [pc, #208]	; (810773c <HAL_RCCEx_PeriphCLKConfig+0x5c8>)
 810766c:	430b      	orrs	r3, r1
 810766e:	6513      	str	r3, [r2, #80]	; 0x50
 8107670:	e003      	b.n	810767a <HAL_RCCEx_PeriphCLKConfig+0x506>
    }
    else
    {
      /* set overall return value */
      status = ret;
 8107672:	f897 3127 	ldrb.w	r3, [r7, #295]	; 0x127
 8107676:	f887 3126 	strb.w	r3, [r7, #294]	; 0x126
    }
  }

  /*---------------------------- SPI4/5 configuration -------------------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SPI45) == RCC_PERIPHCLK_SPI45)
 810767a:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 810767e:	e9d3 2300 	ldrd	r2, r3, [r3]
 8107682:	f402 5300 	and.w	r3, r2, #8192	; 0x2000
 8107686:	f8c7 30e8 	str.w	r3, [r7, #232]	; 0xe8
 810768a:	2300      	movs	r3, #0
 810768c:	f8c7 30ec 	str.w	r3, [r7, #236]	; 0xec
 8107690:	e9d7 123a 	ldrd	r1, r2, [r7, #232]	; 0xe8
 8107694:	460b      	mov	r3, r1
 8107696:	4313      	orrs	r3, r2
 8107698:	d056      	beq.n	8107748 <HAL_RCCEx_PeriphCLKConfig+0x5d4>
  {
    switch (PeriphClkInit->Spi45ClockSelection)
 810769a:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 810769e:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 81076a0:	f5b3 2fa0 	cmp.w	r3, #327680	; 0x50000
 81076a4:	d033      	beq.n	810770e <HAL_RCCEx_PeriphCLKConfig+0x59a>
 81076a6:	f5b3 2fa0 	cmp.w	r3, #327680	; 0x50000
 81076aa:	d82c      	bhi.n	8107706 <HAL_RCCEx_PeriphCLKConfig+0x592>
 81076ac:	f5b3 2f80 	cmp.w	r3, #262144	; 0x40000
 81076b0:	d02f      	beq.n	8107712 <HAL_RCCEx_PeriphCLKConfig+0x59e>
 81076b2:	f5b3 2f80 	cmp.w	r3, #262144	; 0x40000
 81076b6:	d826      	bhi.n	8107706 <HAL_RCCEx_PeriphCLKConfig+0x592>
 81076b8:	f5b3 3f40 	cmp.w	r3, #196608	; 0x30000
 81076bc:	d02b      	beq.n	8107716 <HAL_RCCEx_PeriphCLKConfig+0x5a2>
 81076be:	f5b3 3f40 	cmp.w	r3, #196608	; 0x30000
 81076c2:	d820      	bhi.n	8107706 <HAL_RCCEx_PeriphCLKConfig+0x592>
 81076c4:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
 81076c8:	d012      	beq.n	81076f0 <HAL_RCCEx_PeriphCLKConfig+0x57c>
 81076ca:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
 81076ce:	d81a      	bhi.n	8107706 <HAL_RCCEx_PeriphCLKConfig+0x592>
 81076d0:	2b00      	cmp	r3, #0
 81076d2:	d022      	beq.n	810771a <HAL_RCCEx_PeriphCLKConfig+0x5a6>
 81076d4:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 81076d8:	d115      	bne.n	8107706 <HAL_RCCEx_PeriphCLKConfig+0x592>
        /* SPI4/5 clock source configuration done later after clock selection check */
        break;

      case RCC_SPI45CLKSOURCE_PLL2: /* PLL2 is used as clock source for SPI4/5 */

        ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2), DIVIDER_Q_UPDATE);
 81076da:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 81076de:	3308      	adds	r3, #8
 81076e0:	2101      	movs	r1, #1
 81076e2:	4618      	mov	r0, r3
 81076e4:	f002 f8e0 	bl	81098a8 <RCCEx_PLL2_Config>
 81076e8:	4603      	mov	r3, r0
 81076ea:	f887 3127 	strb.w	r3, [r7, #295]	; 0x127

        /* SPI4/5 clock source configuration done later after clock selection check */
        break;
 81076ee:	e015      	b.n	810771c <HAL_RCCEx_PeriphCLKConfig+0x5a8>
      case RCC_SPI45CLKSOURCE_PLL3:  /* PLL3 is used as clock source for SPI4/5 */
        ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3), DIVIDER_Q_UPDATE);
 81076f0:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 81076f4:	3328      	adds	r3, #40	; 0x28
 81076f6:	2101      	movs	r1, #1
 81076f8:	4618      	mov	r0, r3
 81076fa:	f002 f987 	bl	8109a0c <RCCEx_PLL3_Config>
 81076fe:	4603      	mov	r3, r0
 8107700:	f887 3127 	strb.w	r3, [r7, #295]	; 0x127
        /* SPI4/5 clock source configuration done later after clock selection check */
        break;
 8107704:	e00a      	b.n	810771c <HAL_RCCEx_PeriphCLKConfig+0x5a8>
        /* HSE,  oscillator is used as source of SPI4/5 clock */
        /* SPI4/5 clock source configuration done later after clock selection check */
        break;

      default:
        ret = HAL_ERROR;
 8107706:	2301      	movs	r3, #1
 8107708:	f887 3127 	strb.w	r3, [r7, #295]	; 0x127
        break;
 810770c:	e006      	b.n	810771c <HAL_RCCEx_PeriphCLKConfig+0x5a8>
        break;
 810770e:	bf00      	nop
 8107710:	e004      	b.n	810771c <HAL_RCCEx_PeriphCLKConfig+0x5a8>
        break;
 8107712:	bf00      	nop
 8107714:	e002      	b.n	810771c <HAL_RCCEx_PeriphCLKConfig+0x5a8>
        break;
 8107716:	bf00      	nop
 8107718:	e000      	b.n	810771c <HAL_RCCEx_PeriphCLKConfig+0x5a8>
        break;
 810771a:	bf00      	nop
    }

    if (ret == HAL_OK)
 810771c:	f897 3127 	ldrb.w	r3, [r7, #295]	; 0x127
 8107720:	2b00      	cmp	r3, #0
 8107722:	d10d      	bne.n	8107740 <HAL_RCCEx_PeriphCLKConfig+0x5cc>
    {
      /* Set the source of SPI4/5 clock*/
      __HAL_RCC_SPI45_CONFIG(PeriphClkInit->Spi45ClockSelection);
 8107724:	4b05      	ldr	r3, [pc, #20]	; (810773c <HAL_RCCEx_PeriphCLKConfig+0x5c8>)
 8107726:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8107728:	f423 21e0 	bic.w	r1, r3, #458752	; 0x70000
 810772c:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 8107730:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 8107732:	4a02      	ldr	r2, [pc, #8]	; (810773c <HAL_RCCEx_PeriphCLKConfig+0x5c8>)
 8107734:	430b      	orrs	r3, r1
 8107736:	6513      	str	r3, [r2, #80]	; 0x50
 8107738:	e006      	b.n	8107748 <HAL_RCCEx_PeriphCLKConfig+0x5d4>
 810773a:	bf00      	nop
 810773c:	58024400 	.word	0x58024400
    }
    else
    {
      /* set overall return value */
      status = ret;
 8107740:	f897 3127 	ldrb.w	r3, [r7, #295]	; 0x127
 8107744:	f887 3126 	strb.w	r3, [r7, #294]	; 0x126
    }
  }

  /*---------------------------- SPI6 configuration -------------------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SPI6) == RCC_PERIPHCLK_SPI6)
 8107748:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 810774c:	e9d3 2300 	ldrd	r2, r3, [r3]
 8107750:	f402 4380 	and.w	r3, r2, #16384	; 0x4000
 8107754:	f8c7 30e0 	str.w	r3, [r7, #224]	; 0xe0
 8107758:	2300      	movs	r3, #0
 810775a:	f8c7 30e4 	str.w	r3, [r7, #228]	; 0xe4
 810775e:	e9d7 1238 	ldrd	r1, r2, [r7, #224]	; 0xe0
 8107762:	460b      	mov	r3, r1
 8107764:	4313      	orrs	r3, r2
 8107766:	d055      	beq.n	8107814 <HAL_RCCEx_PeriphCLKConfig+0x6a0>
  {
    switch (PeriphClkInit->Spi6ClockSelection)
 8107768:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 810776c:	f8d3 30b0 	ldr.w	r3, [r3, #176]	; 0xb0
 8107770:	f1b3 4fa0 	cmp.w	r3, #1342177280	; 0x50000000
 8107774:	d033      	beq.n	81077de <HAL_RCCEx_PeriphCLKConfig+0x66a>
 8107776:	f1b3 4fa0 	cmp.w	r3, #1342177280	; 0x50000000
 810777a:	d82c      	bhi.n	81077d6 <HAL_RCCEx_PeriphCLKConfig+0x662>
 810777c:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
 8107780:	d02f      	beq.n	81077e2 <HAL_RCCEx_PeriphCLKConfig+0x66e>
 8107782:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
 8107786:	d826      	bhi.n	81077d6 <HAL_RCCEx_PeriphCLKConfig+0x662>
 8107788:	f1b3 5f40 	cmp.w	r3, #805306368	; 0x30000000
 810778c:	d02b      	beq.n	81077e6 <HAL_RCCEx_PeriphCLKConfig+0x672>
 810778e:	f1b3 5f40 	cmp.w	r3, #805306368	; 0x30000000
 8107792:	d820      	bhi.n	81077d6 <HAL_RCCEx_PeriphCLKConfig+0x662>
 8107794:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
 8107798:	d012      	beq.n	81077c0 <HAL_RCCEx_PeriphCLKConfig+0x64c>
 810779a:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
 810779e:	d81a      	bhi.n	81077d6 <HAL_RCCEx_PeriphCLKConfig+0x662>
 81077a0:	2b00      	cmp	r3, #0
 81077a2:	d022      	beq.n	81077ea <HAL_RCCEx_PeriphCLKConfig+0x676>
 81077a4:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
 81077a8:	d115      	bne.n	81077d6 <HAL_RCCEx_PeriphCLKConfig+0x662>
        /* SPI6 clock source configuration done later after clock selection check */
        break;

      case RCC_SPI6CLKSOURCE_PLL2: /* PLL2 is used as clock source for SPI6*/

        ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2), DIVIDER_Q_UPDATE);
 81077aa:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 81077ae:	3308      	adds	r3, #8
 81077b0:	2101      	movs	r1, #1
 81077b2:	4618      	mov	r0, r3
 81077b4:	f002 f878 	bl	81098a8 <RCCEx_PLL2_Config>
 81077b8:	4603      	mov	r3, r0
 81077ba:	f887 3127 	strb.w	r3, [r7, #295]	; 0x127

        /* SPI6 clock source configuration done later after clock selection check */
        break;
 81077be:	e015      	b.n	81077ec <HAL_RCCEx_PeriphCLKConfig+0x678>
      case RCC_SPI6CLKSOURCE_PLL3:  /* PLL3 is used as clock source for SPI6*/
        ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3), DIVIDER_Q_UPDATE);
 81077c0:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 81077c4:	3328      	adds	r3, #40	; 0x28
 81077c6:	2101      	movs	r1, #1
 81077c8:	4618      	mov	r0, r3
 81077ca:	f002 f91f 	bl	8109a0c <RCCEx_PLL3_Config>
 81077ce:	4603      	mov	r3, r0
 81077d0:	f887 3127 	strb.w	r3, [r7, #295]	; 0x127
        /* SPI6 clock source configuration done later after clock selection check */
        break;
 81077d4:	e00a      	b.n	81077ec <HAL_RCCEx_PeriphCLKConfig+0x678>
        /* SPI6 clock source configuration done later after clock selection check */
        break;
#endif

      default:
        ret = HAL_ERROR;
 81077d6:	2301      	movs	r3, #1
 81077d8:	f887 3127 	strb.w	r3, [r7, #295]	; 0x127
        break;
 81077dc:	e006      	b.n	81077ec <HAL_RCCEx_PeriphCLKConfig+0x678>
        break;
 81077de:	bf00      	nop
 81077e0:	e004      	b.n	81077ec <HAL_RCCEx_PeriphCLKConfig+0x678>
        break;
 81077e2:	bf00      	nop
 81077e4:	e002      	b.n	81077ec <HAL_RCCEx_PeriphCLKConfig+0x678>
        break;
 81077e6:	bf00      	nop
 81077e8:	e000      	b.n	81077ec <HAL_RCCEx_PeriphCLKConfig+0x678>
        break;
 81077ea:	bf00      	nop
    }

    if (ret == HAL_OK)
 81077ec:	f897 3127 	ldrb.w	r3, [r7, #295]	; 0x127
 81077f0:	2b00      	cmp	r3, #0
 81077f2:	d10b      	bne.n	810780c <HAL_RCCEx_PeriphCLKConfig+0x698>
    {
      /* Set the source of SPI6 clock*/
      __HAL_RCC_SPI6_CONFIG(PeriphClkInit->Spi6ClockSelection);
 81077f4:	4ba4      	ldr	r3, [pc, #656]	; (8107a88 <HAL_RCCEx_PeriphCLKConfig+0x914>)
 81077f6:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 81077f8:	f023 41e0 	bic.w	r1, r3, #1879048192	; 0x70000000
 81077fc:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 8107800:	f8d3 30b0 	ldr.w	r3, [r3, #176]	; 0xb0
 8107804:	4aa0      	ldr	r2, [pc, #640]	; (8107a88 <HAL_RCCEx_PeriphCLKConfig+0x914>)
 8107806:	430b      	orrs	r3, r1
 8107808:	6593      	str	r3, [r2, #88]	; 0x58
 810780a:	e003      	b.n	8107814 <HAL_RCCEx_PeriphCLKConfig+0x6a0>
    }
    else
    {
      /* set overall return value */
      status = ret;
 810780c:	f897 3127 	ldrb.w	r3, [r7, #295]	; 0x127
 8107810:	f887 3126 	strb.w	r3, [r7, #294]	; 0x126
  }
#endif /*DSI*/

#if defined(FDCAN1) || defined(FDCAN2)
  /*---------------------------- FDCAN configuration -------------------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_FDCAN) == RCC_PERIPHCLK_FDCAN)
 8107814:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 8107818:	e9d3 2300 	ldrd	r2, r3, [r3]
 810781c:	f402 4300 	and.w	r3, r2, #32768	; 0x8000
 8107820:	f8c7 30d8 	str.w	r3, [r7, #216]	; 0xd8
 8107824:	2300      	movs	r3, #0
 8107826:	f8c7 30dc 	str.w	r3, [r7, #220]	; 0xdc
 810782a:	e9d7 1236 	ldrd	r1, r2, [r7, #216]	; 0xd8
 810782e:	460b      	mov	r3, r1
 8107830:	4313      	orrs	r3, r2
 8107832:	d037      	beq.n	81078a4 <HAL_RCCEx_PeriphCLKConfig+0x730>
  {
    switch (PeriphClkInit->FdcanClockSelection)
 8107834:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 8107838:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 810783a:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
 810783e:	d00e      	beq.n	810785e <HAL_RCCEx_PeriphCLKConfig+0x6ea>
 8107840:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
 8107844:	d816      	bhi.n	8107874 <HAL_RCCEx_PeriphCLKConfig+0x700>
 8107846:	2b00      	cmp	r3, #0
 8107848:	d018      	beq.n	810787c <HAL_RCCEx_PeriphCLKConfig+0x708>
 810784a:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
 810784e:	d111      	bne.n	8107874 <HAL_RCCEx_PeriphCLKConfig+0x700>
    {
      case RCC_FDCANCLKSOURCE_PLL:      /* PLL is used as clock source for FDCAN*/
        /* Enable FDCAN Clock output generated form System PLL . */
        __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
 8107850:	4b8d      	ldr	r3, [pc, #564]	; (8107a88 <HAL_RCCEx_PeriphCLKConfig+0x914>)
 8107852:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8107854:	4a8c      	ldr	r2, [pc, #560]	; (8107a88 <HAL_RCCEx_PeriphCLKConfig+0x914>)
 8107856:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 810785a:	62d3      	str	r3, [r2, #44]	; 0x2c

        /* FDCAN clock source configuration done later after clock selection check */
        break;
 810785c:	e00f      	b.n	810787e <HAL_RCCEx_PeriphCLKConfig+0x70a>

      case RCC_FDCANCLKSOURCE_PLL2: /* PLL2 is used as clock source for FDCAN*/

        ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2), DIVIDER_Q_UPDATE);
 810785e:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 8107862:	3308      	adds	r3, #8
 8107864:	2101      	movs	r1, #1
 8107866:	4618      	mov	r0, r3
 8107868:	f002 f81e 	bl	81098a8 <RCCEx_PLL2_Config>
 810786c:	4603      	mov	r3, r0
 810786e:	f887 3127 	strb.w	r3, [r7, #295]	; 0x127

        /* FDCAN clock source configuration done later after clock selection check */
        break;
 8107872:	e004      	b.n	810787e <HAL_RCCEx_PeriphCLKConfig+0x70a>
        /* HSE is used as clock source for FDCAN*/
        /* FDCAN clock source configuration done later after clock selection check */
        break;

      default:
        ret = HAL_ERROR;
 8107874:	2301      	movs	r3, #1
 8107876:	f887 3127 	strb.w	r3, [r7, #295]	; 0x127
        break;
 810787a:	e000      	b.n	810787e <HAL_RCCEx_PeriphCLKConfig+0x70a>
        break;
 810787c:	bf00      	nop
    }

    if (ret == HAL_OK)
 810787e:	f897 3127 	ldrb.w	r3, [r7, #295]	; 0x127
 8107882:	2b00      	cmp	r3, #0
 8107884:	d10a      	bne.n	810789c <HAL_RCCEx_PeriphCLKConfig+0x728>
    {
      /* Set the source of FDCAN clock*/
      __HAL_RCC_FDCAN_CONFIG(PeriphClkInit->FdcanClockSelection);
 8107886:	4b80      	ldr	r3, [pc, #512]	; (8107a88 <HAL_RCCEx_PeriphCLKConfig+0x914>)
 8107888:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 810788a:	f023 5140 	bic.w	r1, r3, #805306368	; 0x30000000
 810788e:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 8107892:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8107894:	4a7c      	ldr	r2, [pc, #496]	; (8107a88 <HAL_RCCEx_PeriphCLKConfig+0x914>)
 8107896:	430b      	orrs	r3, r1
 8107898:	6513      	str	r3, [r2, #80]	; 0x50
 810789a:	e003      	b.n	81078a4 <HAL_RCCEx_PeriphCLKConfig+0x730>
    }
    else
    {
      /* set overall return value */
      status = ret;
 810789c:	f897 3127 	ldrb.w	r3, [r7, #295]	; 0x127
 81078a0:	f887 3126 	strb.w	r3, [r7, #294]	; 0x126
    }
  }
#endif /*FDCAN1 || FDCAN2*/

  /*---------------------------- FMC configuration -------------------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_FMC) == RCC_PERIPHCLK_FMC)
 81078a4:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 81078a8:	e9d3 2300 	ldrd	r2, r3, [r3]
 81078ac:	f002 7380 	and.w	r3, r2, #16777216	; 0x1000000
 81078b0:	f8c7 30d0 	str.w	r3, [r7, #208]	; 0xd0
 81078b4:	2300      	movs	r3, #0
 81078b6:	f8c7 30d4 	str.w	r3, [r7, #212]	; 0xd4
 81078ba:	e9d7 1234 	ldrd	r1, r2, [r7, #208]	; 0xd0
 81078be:	460b      	mov	r3, r1
 81078c0:	4313      	orrs	r3, r2
 81078c2:	d039      	beq.n	8107938 <HAL_RCCEx_PeriphCLKConfig+0x7c4>
  {
    switch (PeriphClkInit->FmcClockSelection)
 81078c4:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 81078c8:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 81078ca:	2b03      	cmp	r3, #3
 81078cc:	d81c      	bhi.n	8107908 <HAL_RCCEx_PeriphCLKConfig+0x794>
 81078ce:	a201      	add	r2, pc, #4	; (adr r2, 81078d4 <HAL_RCCEx_PeriphCLKConfig+0x760>)
 81078d0:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 81078d4:	08107911 	.word	0x08107911
 81078d8:	081078e5 	.word	0x081078e5
 81078dc:	081078f3 	.word	0x081078f3
 81078e0:	08107911 	.word	0x08107911
    {
      case RCC_FMCCLKSOURCE_PLL:      /* PLL is used as clock source for FMC*/
        /* Enable FMC Clock output generated form System PLL . */
        __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
 81078e4:	4b68      	ldr	r3, [pc, #416]	; (8107a88 <HAL_RCCEx_PeriphCLKConfig+0x914>)
 81078e6:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 81078e8:	4a67      	ldr	r2, [pc, #412]	; (8107a88 <HAL_RCCEx_PeriphCLKConfig+0x914>)
 81078ea:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 81078ee:	62d3      	str	r3, [r2, #44]	; 0x2c

        /* FMC clock source configuration done later after clock selection check */
        break;
 81078f0:	e00f      	b.n	8107912 <HAL_RCCEx_PeriphCLKConfig+0x79e>

      case RCC_FMCCLKSOURCE_PLL2: /* PLL2 is used as clock source for FMC*/

        ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2), DIVIDER_R_UPDATE);
 81078f2:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 81078f6:	3308      	adds	r3, #8
 81078f8:	2102      	movs	r1, #2
 81078fa:	4618      	mov	r0, r3
 81078fc:	f001 ffd4 	bl	81098a8 <RCCEx_PLL2_Config>
 8107900:	4603      	mov	r3, r0
 8107902:	f887 3127 	strb.w	r3, [r7, #295]	; 0x127

        /* FMC clock source configuration done later after clock selection check */
        break;
 8107906:	e004      	b.n	8107912 <HAL_RCCEx_PeriphCLKConfig+0x79e>
      case RCC_FMCCLKSOURCE_HCLK:
        /* D1/CD HCLK  clock selected as FMC kernel peripheral clock */
        break;

      default:
        ret = HAL_ERROR;
 8107908:	2301      	movs	r3, #1
 810790a:	f887 3127 	strb.w	r3, [r7, #295]	; 0x127
        break;
 810790e:	e000      	b.n	8107912 <HAL_RCCEx_PeriphCLKConfig+0x79e>
        break;
 8107910:	bf00      	nop
    }

    if (ret == HAL_OK)
 8107912:	f897 3127 	ldrb.w	r3, [r7, #295]	; 0x127
 8107916:	2b00      	cmp	r3, #0
 8107918:	d10a      	bne.n	8107930 <HAL_RCCEx_PeriphCLKConfig+0x7bc>
    {
      /* Set the source of FMC clock*/
      __HAL_RCC_FMC_CONFIG(PeriphClkInit->FmcClockSelection);
 810791a:	4b5b      	ldr	r3, [pc, #364]	; (8107a88 <HAL_RCCEx_PeriphCLKConfig+0x914>)
 810791c:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 810791e:	f023 0103 	bic.w	r1, r3, #3
 8107922:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 8107926:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8107928:	4a57      	ldr	r2, [pc, #348]	; (8107a88 <HAL_RCCEx_PeriphCLKConfig+0x914>)
 810792a:	430b      	orrs	r3, r1
 810792c:	64d3      	str	r3, [r2, #76]	; 0x4c
 810792e:	e003      	b.n	8107938 <HAL_RCCEx_PeriphCLKConfig+0x7c4>
    }
    else
    {
      /* set overall return value */
      status = ret;
 8107930:	f897 3127 	ldrb.w	r3, [r7, #295]	; 0x127
 8107934:	f887 3126 	strb.w	r3, [r7, #294]	; 0x126
    }
  }

  /*---------------------------- RTC configuration -------------------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RTC) == RCC_PERIPHCLK_RTC)
 8107938:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 810793c:	e9d3 2300 	ldrd	r2, r3, [r3]
 8107940:	f402 0380 	and.w	r3, r2, #4194304	; 0x400000
 8107944:	f8c7 30c8 	str.w	r3, [r7, #200]	; 0xc8
 8107948:	2300      	movs	r3, #0
 810794a:	f8c7 30cc 	str.w	r3, [r7, #204]	; 0xcc
 810794e:	e9d7 1232 	ldrd	r1, r2, [r7, #200]	; 0xc8
 8107952:	460b      	mov	r3, r1
 8107954:	4313      	orrs	r3, r2
 8107956:	f000 809f 	beq.w	8107a98 <HAL_RCCEx_PeriphCLKConfig+0x924>
  {
    /* check for RTC Parameters used to output RTCCLK */
    assert_param(IS_RCC_RTCCLKSOURCE(PeriphClkInit->RTCClockSelection));

    /* Enable write access to Backup domain */
    SET_BIT(PWR->CR1, PWR_CR1_DBP);
 810795a:	4b4c      	ldr	r3, [pc, #304]	; (8107a8c <HAL_RCCEx_PeriphCLKConfig+0x918>)
 810795c:	681b      	ldr	r3, [r3, #0]
 810795e:	4a4b      	ldr	r2, [pc, #300]	; (8107a8c <HAL_RCCEx_PeriphCLKConfig+0x918>)
 8107960:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8107964:	6013      	str	r3, [r2, #0]

    /* Wait for Backup domain Write protection disable */
    tickstart = HAL_GetTick();
 8107966:	f7f9 fe69 	bl	810163c <HAL_GetTick>
 810796a:	f8c7 0120 	str.w	r0, [r7, #288]	; 0x120

    while ((PWR->CR1 & PWR_CR1_DBP) == 0U)
 810796e:	e00b      	b.n	8107988 <HAL_RCCEx_PeriphCLKConfig+0x814>
    {
      if ((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 8107970:	f7f9 fe64 	bl	810163c <HAL_GetTick>
 8107974:	4602      	mov	r2, r0
 8107976:	f8d7 3120 	ldr.w	r3, [r7, #288]	; 0x120
 810797a:	1ad3      	subs	r3, r2, r3
 810797c:	2b64      	cmp	r3, #100	; 0x64
 810797e:	d903      	bls.n	8107988 <HAL_RCCEx_PeriphCLKConfig+0x814>
      {
        ret = HAL_TIMEOUT;
 8107980:	2303      	movs	r3, #3
 8107982:	f887 3127 	strb.w	r3, [r7, #295]	; 0x127
        break;
 8107986:	e005      	b.n	8107994 <HAL_RCCEx_PeriphCLKConfig+0x820>
    while ((PWR->CR1 & PWR_CR1_DBP) == 0U)
 8107988:	4b40      	ldr	r3, [pc, #256]	; (8107a8c <HAL_RCCEx_PeriphCLKConfig+0x918>)
 810798a:	681b      	ldr	r3, [r3, #0]
 810798c:	f403 7380 	and.w	r3, r3, #256	; 0x100
 8107990:	2b00      	cmp	r3, #0
 8107992:	d0ed      	beq.n	8107970 <HAL_RCCEx_PeriphCLKConfig+0x7fc>
      }
    }

    if (ret == HAL_OK)
 8107994:	f897 3127 	ldrb.w	r3, [r7, #295]	; 0x127
 8107998:	2b00      	cmp	r3, #0
 810799a:	d179      	bne.n	8107a90 <HAL_RCCEx_PeriphCLKConfig+0x91c>
    {
      /* Reset the Backup domain only if the RTC Clock source selection is modified */
      if ((RCC->BDCR & RCC_BDCR_RTCSEL) != (PeriphClkInit->RTCClockSelection & RCC_BDCR_RTCSEL))
 810799c:	4b3a      	ldr	r3, [pc, #232]	; (8107a88 <HAL_RCCEx_PeriphCLKConfig+0x914>)
 810799e:	6f1a      	ldr	r2, [r3, #112]	; 0x70
 81079a0:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 81079a4:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 81079a8:	4053      	eors	r3, r2
 81079aa:	f403 7340 	and.w	r3, r3, #768	; 0x300
 81079ae:	2b00      	cmp	r3, #0
 81079b0:	d015      	beq.n	81079de <HAL_RCCEx_PeriphCLKConfig+0x86a>
      {
        /* Store the content of BDCR register before the reset of Backup Domain */
        tmpreg = (RCC->BDCR & ~(RCC_BDCR_RTCSEL));
 81079b2:	4b35      	ldr	r3, [pc, #212]	; (8107a88 <HAL_RCCEx_PeriphCLKConfig+0x914>)
 81079b4:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 81079b6:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 81079ba:	f8c7 311c 	str.w	r3, [r7, #284]	; 0x11c
        /* RTC Clock selection can be changed only if the Backup Domain is reset */
        __HAL_RCC_BACKUPRESET_FORCE();
 81079be:	4b32      	ldr	r3, [pc, #200]	; (8107a88 <HAL_RCCEx_PeriphCLKConfig+0x914>)
 81079c0:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 81079c2:	4a31      	ldr	r2, [pc, #196]	; (8107a88 <HAL_RCCEx_PeriphCLKConfig+0x914>)
 81079c4:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 81079c8:	6713      	str	r3, [r2, #112]	; 0x70
        __HAL_RCC_BACKUPRESET_RELEASE();
 81079ca:	4b2f      	ldr	r3, [pc, #188]	; (8107a88 <HAL_RCCEx_PeriphCLKConfig+0x914>)
 81079cc:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 81079ce:	4a2e      	ldr	r2, [pc, #184]	; (8107a88 <HAL_RCCEx_PeriphCLKConfig+0x914>)
 81079d0:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 81079d4:	6713      	str	r3, [r2, #112]	; 0x70
        /* Restore the Content of BDCR register */
        RCC->BDCR = tmpreg;
 81079d6:	4a2c      	ldr	r2, [pc, #176]	; (8107a88 <HAL_RCCEx_PeriphCLKConfig+0x914>)
 81079d8:	f8d7 311c 	ldr.w	r3, [r7, #284]	; 0x11c
 81079dc:	6713      	str	r3, [r2, #112]	; 0x70
      }

      /* If LSE is selected as RTC clock source (and enabled prior to Backup Domain reset), wait for LSE reactivation */
      if (PeriphClkInit->RTCClockSelection == RCC_RTCCLKSOURCE_LSE)
 81079de:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 81079e2:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 81079e6:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 81079ea:	d118      	bne.n	8107a1e <HAL_RCCEx_PeriphCLKConfig+0x8aa>
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 81079ec:	f7f9 fe26 	bl	810163c <HAL_GetTick>
 81079f0:	f8c7 0120 	str.w	r0, [r7, #288]	; 0x120

        /* Wait till LSE is ready */
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == 0U)
 81079f4:	e00d      	b.n	8107a12 <HAL_RCCEx_PeriphCLKConfig+0x89e>
        {
          if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 81079f6:	f7f9 fe21 	bl	810163c <HAL_GetTick>
 81079fa:	4602      	mov	r2, r0
 81079fc:	f8d7 3120 	ldr.w	r3, [r7, #288]	; 0x120
 8107a00:	1ad2      	subs	r2, r2, r3
 8107a02:	f241 3388 	movw	r3, #5000	; 0x1388
 8107a06:	429a      	cmp	r2, r3
 8107a08:	d903      	bls.n	8107a12 <HAL_RCCEx_PeriphCLKConfig+0x89e>
          {
            ret = HAL_TIMEOUT;
 8107a0a:	2303      	movs	r3, #3
 8107a0c:	f887 3127 	strb.w	r3, [r7, #295]	; 0x127
            break;
 8107a10:	e005      	b.n	8107a1e <HAL_RCCEx_PeriphCLKConfig+0x8aa>
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == 0U)
 8107a12:	4b1d      	ldr	r3, [pc, #116]	; (8107a88 <HAL_RCCEx_PeriphCLKConfig+0x914>)
 8107a14:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8107a16:	f003 0302 	and.w	r3, r3, #2
 8107a1a:	2b00      	cmp	r3, #0
 8107a1c:	d0eb      	beq.n	81079f6 <HAL_RCCEx_PeriphCLKConfig+0x882>
          }
        }
      }

      if (ret == HAL_OK)
 8107a1e:	f897 3127 	ldrb.w	r3, [r7, #295]	; 0x127
 8107a22:	2b00      	cmp	r3, #0
 8107a24:	d12b      	bne.n	8107a7e <HAL_RCCEx_PeriphCLKConfig+0x90a>
      {
        __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection);
 8107a26:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 8107a2a:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8107a2e:	f403 7340 	and.w	r3, r3, #768	; 0x300
 8107a32:	f5b3 7f40 	cmp.w	r3, #768	; 0x300
 8107a36:	d110      	bne.n	8107a5a <HAL_RCCEx_PeriphCLKConfig+0x8e6>
 8107a38:	4b13      	ldr	r3, [pc, #76]	; (8107a88 <HAL_RCCEx_PeriphCLKConfig+0x914>)
 8107a3a:	691b      	ldr	r3, [r3, #16]
 8107a3c:	f423 517c 	bic.w	r1, r3, #16128	; 0x3f00
 8107a40:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 8107a44:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8107a48:	091b      	lsrs	r3, r3, #4
 8107a4a:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
 8107a4e:	f023 0330 	bic.w	r3, r3, #48	; 0x30
 8107a52:	4a0d      	ldr	r2, [pc, #52]	; (8107a88 <HAL_RCCEx_PeriphCLKConfig+0x914>)
 8107a54:	430b      	orrs	r3, r1
 8107a56:	6113      	str	r3, [r2, #16]
 8107a58:	e005      	b.n	8107a66 <HAL_RCCEx_PeriphCLKConfig+0x8f2>
 8107a5a:	4b0b      	ldr	r3, [pc, #44]	; (8107a88 <HAL_RCCEx_PeriphCLKConfig+0x914>)
 8107a5c:	691b      	ldr	r3, [r3, #16]
 8107a5e:	4a0a      	ldr	r2, [pc, #40]	; (8107a88 <HAL_RCCEx_PeriphCLKConfig+0x914>)
 8107a60:	f423 537c 	bic.w	r3, r3, #16128	; 0x3f00
 8107a64:	6113      	str	r3, [r2, #16]
 8107a66:	4b08      	ldr	r3, [pc, #32]	; (8107a88 <HAL_RCCEx_PeriphCLKConfig+0x914>)
 8107a68:	6f19      	ldr	r1, [r3, #112]	; 0x70
 8107a6a:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 8107a6e:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8107a72:	f3c3 030b 	ubfx	r3, r3, #0, #12
 8107a76:	4a04      	ldr	r2, [pc, #16]	; (8107a88 <HAL_RCCEx_PeriphCLKConfig+0x914>)
 8107a78:	430b      	orrs	r3, r1
 8107a7a:	6713      	str	r3, [r2, #112]	; 0x70
 8107a7c:	e00c      	b.n	8107a98 <HAL_RCCEx_PeriphCLKConfig+0x924>
      }
      else
      {
        /* set overall return value */
        status = ret;
 8107a7e:	f897 3127 	ldrb.w	r3, [r7, #295]	; 0x127
 8107a82:	f887 3126 	strb.w	r3, [r7, #294]	; 0x126
 8107a86:	e007      	b.n	8107a98 <HAL_RCCEx_PeriphCLKConfig+0x924>
 8107a88:	58024400 	.word	0x58024400
 8107a8c:	58024800 	.word	0x58024800
      }
    }
    else
    {
      /* set overall return value */
      status = ret;
 8107a90:	f897 3127 	ldrb.w	r3, [r7, #295]	; 0x127
 8107a94:	f887 3126 	strb.w	r3, [r7, #294]	; 0x126
    }
  }


  /*-------------------------- USART1/6 configuration --------------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART16) == RCC_PERIPHCLK_USART16)
 8107a98:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 8107a9c:	e9d3 2300 	ldrd	r2, r3, [r3]
 8107aa0:	f002 0301 	and.w	r3, r2, #1
 8107aa4:	f8c7 30c0 	str.w	r3, [r7, #192]	; 0xc0
 8107aa8:	2300      	movs	r3, #0
 8107aaa:	f8c7 30c4 	str.w	r3, [r7, #196]	; 0xc4
 8107aae:	e9d7 1230 	ldrd	r1, r2, [r7, #192]	; 0xc0
 8107ab2:	460b      	mov	r3, r1
 8107ab4:	4313      	orrs	r3, r2
 8107ab6:	f000 8089 	beq.w	8107bcc <HAL_RCCEx_PeriphCLKConfig+0xa58>
  {
    switch (PeriphClkInit->Usart16ClockSelection)
 8107aba:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 8107abe:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 8107ac0:	2b28      	cmp	r3, #40	; 0x28
 8107ac2:	d86b      	bhi.n	8107b9c <HAL_RCCEx_PeriphCLKConfig+0xa28>
 8107ac4:	a201      	add	r2, pc, #4	; (adr r2, 8107acc <HAL_RCCEx_PeriphCLKConfig+0x958>)
 8107ac6:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8107aca:	bf00      	nop
 8107acc:	08107ba5 	.word	0x08107ba5
 8107ad0:	08107b9d 	.word	0x08107b9d
 8107ad4:	08107b9d 	.word	0x08107b9d
 8107ad8:	08107b9d 	.word	0x08107b9d
 8107adc:	08107b9d 	.word	0x08107b9d
 8107ae0:	08107b9d 	.word	0x08107b9d
 8107ae4:	08107b9d 	.word	0x08107b9d
 8107ae8:	08107b9d 	.word	0x08107b9d
 8107aec:	08107b71 	.word	0x08107b71
 8107af0:	08107b9d 	.word	0x08107b9d
 8107af4:	08107b9d 	.word	0x08107b9d
 8107af8:	08107b9d 	.word	0x08107b9d
 8107afc:	08107b9d 	.word	0x08107b9d
 8107b00:	08107b9d 	.word	0x08107b9d
 8107b04:	08107b9d 	.word	0x08107b9d
 8107b08:	08107b9d 	.word	0x08107b9d
 8107b0c:	08107b87 	.word	0x08107b87
 8107b10:	08107b9d 	.word	0x08107b9d
 8107b14:	08107b9d 	.word	0x08107b9d
 8107b18:	08107b9d 	.word	0x08107b9d
 8107b1c:	08107b9d 	.word	0x08107b9d
 8107b20:	08107b9d 	.word	0x08107b9d
 8107b24:	08107b9d 	.word	0x08107b9d
 8107b28:	08107b9d 	.word	0x08107b9d
 8107b2c:	08107ba5 	.word	0x08107ba5
 8107b30:	08107b9d 	.word	0x08107b9d
 8107b34:	08107b9d 	.word	0x08107b9d
 8107b38:	08107b9d 	.word	0x08107b9d
 8107b3c:	08107b9d 	.word	0x08107b9d
 8107b40:	08107b9d 	.word	0x08107b9d
 8107b44:	08107b9d 	.word	0x08107b9d
 8107b48:	08107b9d 	.word	0x08107b9d
 8107b4c:	08107ba5 	.word	0x08107ba5
 8107b50:	08107b9d 	.word	0x08107b9d
 8107b54:	08107b9d 	.word	0x08107b9d
 8107b58:	08107b9d 	.word	0x08107b9d
 8107b5c:	08107b9d 	.word	0x08107b9d
 8107b60:	08107b9d 	.word	0x08107b9d
 8107b64:	08107b9d 	.word	0x08107b9d
 8107b68:	08107b9d 	.word	0x08107b9d
 8107b6c:	08107ba5 	.word	0x08107ba5
      case RCC_USART16CLKSOURCE_PCLK2: /* CD/D2 PCLK2 as clock source for USART1/6 */
        /* USART1/6 clock source configuration done later after clock selection check */
        break;

      case RCC_USART16CLKSOURCE_PLL2: /* PLL2 is used as clock source for USART1/6 */
        ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2), DIVIDER_Q_UPDATE);
 8107b70:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 8107b74:	3308      	adds	r3, #8
 8107b76:	2101      	movs	r1, #1
 8107b78:	4618      	mov	r0, r3
 8107b7a:	f001 fe95 	bl	81098a8 <RCCEx_PLL2_Config>
 8107b7e:	4603      	mov	r3, r0
 8107b80:	f887 3127 	strb.w	r3, [r7, #295]	; 0x127
        /* USART1/6 clock source configuration done later after clock selection check */
        break;
 8107b84:	e00f      	b.n	8107ba6 <HAL_RCCEx_PeriphCLKConfig+0xa32>

      case RCC_USART16CLKSOURCE_PLL3: /* PLL3 is used as clock source for USART1/6 */
        ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3), DIVIDER_Q_UPDATE);
 8107b86:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 8107b8a:	3328      	adds	r3, #40	; 0x28
 8107b8c:	2101      	movs	r1, #1
 8107b8e:	4618      	mov	r0, r3
 8107b90:	f001 ff3c 	bl	8109a0c <RCCEx_PLL3_Config>
 8107b94:	4603      	mov	r3, r0
 8107b96:	f887 3127 	strb.w	r3, [r7, #295]	; 0x127
        /* USART1/6 clock source configuration done later after clock selection check */
        break;
 8107b9a:	e004      	b.n	8107ba6 <HAL_RCCEx_PeriphCLKConfig+0xa32>
        /* LSE,  oscillator is used as source of USART1/6 clock */
        /* USART1/6 clock source configuration done later after clock selection check */
        break;

      default:
        ret = HAL_ERROR;
 8107b9c:	2301      	movs	r3, #1
 8107b9e:	f887 3127 	strb.w	r3, [r7, #295]	; 0x127
        break;
 8107ba2:	e000      	b.n	8107ba6 <HAL_RCCEx_PeriphCLKConfig+0xa32>
        break;
 8107ba4:	bf00      	nop
    }

    if (ret == HAL_OK)
 8107ba6:	f897 3127 	ldrb.w	r3, [r7, #295]	; 0x127
 8107baa:	2b00      	cmp	r3, #0
 8107bac:	d10a      	bne.n	8107bc4 <HAL_RCCEx_PeriphCLKConfig+0xa50>
    {
      /* Set the source of USART1/6 clock */
      __HAL_RCC_USART16_CONFIG(PeriphClkInit->Usart16ClockSelection);
 8107bae:	4bbf      	ldr	r3, [pc, #764]	; (8107eac <HAL_RCCEx_PeriphCLKConfig+0xd38>)
 8107bb0:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8107bb2:	f023 0138 	bic.w	r1, r3, #56	; 0x38
 8107bb6:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 8107bba:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 8107bbc:	4abb      	ldr	r2, [pc, #748]	; (8107eac <HAL_RCCEx_PeriphCLKConfig+0xd38>)
 8107bbe:	430b      	orrs	r3, r1
 8107bc0:	6553      	str	r3, [r2, #84]	; 0x54
 8107bc2:	e003      	b.n	8107bcc <HAL_RCCEx_PeriphCLKConfig+0xa58>
    }
    else
    {
      /* set overall return value */
      status = ret;
 8107bc4:	f897 3127 	ldrb.w	r3, [r7, #295]	; 0x127
 8107bc8:	f887 3126 	strb.w	r3, [r7, #294]	; 0x126
    }
  }

  /*-------------------------- USART2/3/4/5/7/8 Configuration --------------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART234578) == RCC_PERIPHCLK_USART234578)
 8107bcc:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 8107bd0:	e9d3 2300 	ldrd	r2, r3, [r3]
 8107bd4:	f002 0302 	and.w	r3, r2, #2
 8107bd8:	f8c7 30b8 	str.w	r3, [r7, #184]	; 0xb8
 8107bdc:	2300      	movs	r3, #0
 8107bde:	f8c7 30bc 	str.w	r3, [r7, #188]	; 0xbc
 8107be2:	e9d7 122e 	ldrd	r1, r2, [r7, #184]	; 0xb8
 8107be6:	460b      	mov	r3, r1
 8107be8:	4313      	orrs	r3, r2
 8107bea:	d041      	beq.n	8107c70 <HAL_RCCEx_PeriphCLKConfig+0xafc>
  {
    switch (PeriphClkInit->Usart234578ClockSelection)
 8107bec:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 8107bf0:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 8107bf2:	2b05      	cmp	r3, #5
 8107bf4:	d824      	bhi.n	8107c40 <HAL_RCCEx_PeriphCLKConfig+0xacc>
 8107bf6:	a201      	add	r2, pc, #4	; (adr r2, 8107bfc <HAL_RCCEx_PeriphCLKConfig+0xa88>)
 8107bf8:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8107bfc:	08107c49 	.word	0x08107c49
 8107c00:	08107c15 	.word	0x08107c15
 8107c04:	08107c2b 	.word	0x08107c2b
 8107c08:	08107c49 	.word	0x08107c49
 8107c0c:	08107c49 	.word	0x08107c49
 8107c10:	08107c49 	.word	0x08107c49
      case RCC_USART234578CLKSOURCE_PCLK1: /* CD/D2 PCLK1 as clock source for USART2/3/4/5/7/8 */
        /* USART2/3/4/5/7/8 clock source configuration done later after clock selection check */
        break;

      case RCC_USART234578CLKSOURCE_PLL2: /* PLL2 is used as clock source for USART2/3/4/5/7/8 */
        ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2), DIVIDER_Q_UPDATE);
 8107c14:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 8107c18:	3308      	adds	r3, #8
 8107c1a:	2101      	movs	r1, #1
 8107c1c:	4618      	mov	r0, r3
 8107c1e:	f001 fe43 	bl	81098a8 <RCCEx_PLL2_Config>
 8107c22:	4603      	mov	r3, r0
 8107c24:	f887 3127 	strb.w	r3, [r7, #295]	; 0x127
        /* USART2/3/4/5/7/8 clock source configuration done later after clock selection check */
        break;
 8107c28:	e00f      	b.n	8107c4a <HAL_RCCEx_PeriphCLKConfig+0xad6>

      case RCC_USART234578CLKSOURCE_PLL3: /* PLL3 is used as clock source for USART2/3/4/5/7/8 */
        ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3), DIVIDER_Q_UPDATE);
 8107c2a:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 8107c2e:	3328      	adds	r3, #40	; 0x28
 8107c30:	2101      	movs	r1, #1
 8107c32:	4618      	mov	r0, r3
 8107c34:	f001 feea 	bl	8109a0c <RCCEx_PLL3_Config>
 8107c38:	4603      	mov	r3, r0
 8107c3a:	f887 3127 	strb.w	r3, [r7, #295]	; 0x127
        /* USART2/3/4/5/7/8 clock source configuration done later after clock selection check */
        break;
 8107c3e:	e004      	b.n	8107c4a <HAL_RCCEx_PeriphCLKConfig+0xad6>
        /* LSE,  oscillator is used as source of USART2/3/4/5/7/8 clock */
        /* USART2/3/4/5/7/8 clock source configuration done later after clock selection check */
        break;

      default:
        ret = HAL_ERROR;
 8107c40:	2301      	movs	r3, #1
 8107c42:	f887 3127 	strb.w	r3, [r7, #295]	; 0x127
        break;
 8107c46:	e000      	b.n	8107c4a <HAL_RCCEx_PeriphCLKConfig+0xad6>
        break;
 8107c48:	bf00      	nop
    }

    if (ret == HAL_OK)
 8107c4a:	f897 3127 	ldrb.w	r3, [r7, #295]	; 0x127
 8107c4e:	2b00      	cmp	r3, #0
 8107c50:	d10a      	bne.n	8107c68 <HAL_RCCEx_PeriphCLKConfig+0xaf4>
    {
      /* Set the source of USART2/3/4/5/7/8 clock */
      __HAL_RCC_USART234578_CONFIG(PeriphClkInit->Usart234578ClockSelection);
 8107c52:	4b96      	ldr	r3, [pc, #600]	; (8107eac <HAL_RCCEx_PeriphCLKConfig+0xd38>)
 8107c54:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8107c56:	f023 0107 	bic.w	r1, r3, #7
 8107c5a:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 8107c5e:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 8107c60:	4a92      	ldr	r2, [pc, #584]	; (8107eac <HAL_RCCEx_PeriphCLKConfig+0xd38>)
 8107c62:	430b      	orrs	r3, r1
 8107c64:	6553      	str	r3, [r2, #84]	; 0x54
 8107c66:	e003      	b.n	8107c70 <HAL_RCCEx_PeriphCLKConfig+0xafc>
    }
    else
    {
      /* set overall return value */
      status = ret;
 8107c68:	f897 3127 	ldrb.w	r3, [r7, #295]	; 0x127
 8107c6c:	f887 3126 	strb.w	r3, [r7, #294]	; 0x126
    }
  }

  /*-------------------------- LPUART1 Configuration -------------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPUART1) == RCC_PERIPHCLK_LPUART1)
 8107c70:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 8107c74:	e9d3 2300 	ldrd	r2, r3, [r3]
 8107c78:	f002 0304 	and.w	r3, r2, #4
 8107c7c:	f8c7 30b0 	str.w	r3, [r7, #176]	; 0xb0
 8107c80:	2300      	movs	r3, #0
 8107c82:	f8c7 30b4 	str.w	r3, [r7, #180]	; 0xb4
 8107c86:	e9d7 122c 	ldrd	r1, r2, [r7, #176]	; 0xb0
 8107c8a:	460b      	mov	r3, r1
 8107c8c:	4313      	orrs	r3, r2
 8107c8e:	d044      	beq.n	8107d1a <HAL_RCCEx_PeriphCLKConfig+0xba6>
  {
    switch (PeriphClkInit->Lpuart1ClockSelection)
 8107c90:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 8107c94:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 8107c98:	2b05      	cmp	r3, #5
 8107c9a:	d825      	bhi.n	8107ce8 <HAL_RCCEx_PeriphCLKConfig+0xb74>
 8107c9c:	a201      	add	r2, pc, #4	; (adr r2, 8107ca4 <HAL_RCCEx_PeriphCLKConfig+0xb30>)
 8107c9e:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8107ca2:	bf00      	nop
 8107ca4:	08107cf1 	.word	0x08107cf1
 8107ca8:	08107cbd 	.word	0x08107cbd
 8107cac:	08107cd3 	.word	0x08107cd3
 8107cb0:	08107cf1 	.word	0x08107cf1
 8107cb4:	08107cf1 	.word	0x08107cf1
 8107cb8:	08107cf1 	.word	0x08107cf1
      case RCC_LPUART1CLKSOURCE_PCLK4: /* SRD/D3 PCLK1 (PCLK4) as clock source for LPUART1 */
        /* LPUART1 clock source configuration done later after clock selection check */
        break;

      case RCC_LPUART1CLKSOURCE_PLL2: /* PLL2 is used as clock source for LPUART1 */
        ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2), DIVIDER_Q_UPDATE);
 8107cbc:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 8107cc0:	3308      	adds	r3, #8
 8107cc2:	2101      	movs	r1, #1
 8107cc4:	4618      	mov	r0, r3
 8107cc6:	f001 fdef 	bl	81098a8 <RCCEx_PLL2_Config>
 8107cca:	4603      	mov	r3, r0
 8107ccc:	f887 3127 	strb.w	r3, [r7, #295]	; 0x127
        /* LPUART1 clock source configuration done later after clock selection check */
        break;
 8107cd0:	e00f      	b.n	8107cf2 <HAL_RCCEx_PeriphCLKConfig+0xb7e>

      case RCC_LPUART1CLKSOURCE_PLL3: /* PLL3 is used as clock source for LPUART1 */
        ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3), DIVIDER_Q_UPDATE);
 8107cd2:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 8107cd6:	3328      	adds	r3, #40	; 0x28
 8107cd8:	2101      	movs	r1, #1
 8107cda:	4618      	mov	r0, r3
 8107cdc:	f001 fe96 	bl	8109a0c <RCCEx_PLL3_Config>
 8107ce0:	4603      	mov	r3, r0
 8107ce2:	f887 3127 	strb.w	r3, [r7, #295]	; 0x127
        /* LPUART1 clock source configuration done later after clock selection check */
        break;
 8107ce6:	e004      	b.n	8107cf2 <HAL_RCCEx_PeriphCLKConfig+0xb7e>
        /* LSE,  oscillator is used as source of LPUART1 clock */
        /* LPUART1 clock source configuration done later after clock selection check */
        break;

      default:
        ret = HAL_ERROR;
 8107ce8:	2301      	movs	r3, #1
 8107cea:	f887 3127 	strb.w	r3, [r7, #295]	; 0x127
        break;
 8107cee:	e000      	b.n	8107cf2 <HAL_RCCEx_PeriphCLKConfig+0xb7e>
        break;
 8107cf0:	bf00      	nop
    }

    if (ret == HAL_OK)
 8107cf2:	f897 3127 	ldrb.w	r3, [r7, #295]	; 0x127
 8107cf6:	2b00      	cmp	r3, #0
 8107cf8:	d10b      	bne.n	8107d12 <HAL_RCCEx_PeriphCLKConfig+0xb9e>
    {
      /* Set the source of LPUART1 clock */
      __HAL_RCC_LPUART1_CONFIG(PeriphClkInit->Lpuart1ClockSelection);
 8107cfa:	4b6c      	ldr	r3, [pc, #432]	; (8107eac <HAL_RCCEx_PeriphCLKConfig+0xd38>)
 8107cfc:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8107cfe:	f023 0107 	bic.w	r1, r3, #7
 8107d02:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 8107d06:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 8107d0a:	4a68      	ldr	r2, [pc, #416]	; (8107eac <HAL_RCCEx_PeriphCLKConfig+0xd38>)
 8107d0c:	430b      	orrs	r3, r1
 8107d0e:	6593      	str	r3, [r2, #88]	; 0x58
 8107d10:	e003      	b.n	8107d1a <HAL_RCCEx_PeriphCLKConfig+0xba6>
    }
    else
    {
      /* set overall return value */
      status = ret;
 8107d12:	f897 3127 	ldrb.w	r3, [r7, #295]	; 0x127
 8107d16:	f887 3126 	strb.w	r3, [r7, #294]	; 0x126
    }
  }

  /*---------------------------- LPTIM1 configuration -------------------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM1) == RCC_PERIPHCLK_LPTIM1)
 8107d1a:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 8107d1e:	e9d3 2300 	ldrd	r2, r3, [r3]
 8107d22:	f002 0320 	and.w	r3, r2, #32
 8107d26:	f8c7 30a8 	str.w	r3, [r7, #168]	; 0xa8
 8107d2a:	2300      	movs	r3, #0
 8107d2c:	f8c7 30ac 	str.w	r3, [r7, #172]	; 0xac
 8107d30:	e9d7 122a 	ldrd	r1, r2, [r7, #168]	; 0xa8
 8107d34:	460b      	mov	r3, r1
 8107d36:	4313      	orrs	r3, r2
 8107d38:	d055      	beq.n	8107de6 <HAL_RCCEx_PeriphCLKConfig+0xc72>
  {
    switch (PeriphClkInit->Lptim1ClockSelection)
 8107d3a:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 8107d3e:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 8107d42:	f1b3 4fa0 	cmp.w	r3, #1342177280	; 0x50000000
 8107d46:	d033      	beq.n	8107db0 <HAL_RCCEx_PeriphCLKConfig+0xc3c>
 8107d48:	f1b3 4fa0 	cmp.w	r3, #1342177280	; 0x50000000
 8107d4c:	d82c      	bhi.n	8107da8 <HAL_RCCEx_PeriphCLKConfig+0xc34>
 8107d4e:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
 8107d52:	d02f      	beq.n	8107db4 <HAL_RCCEx_PeriphCLKConfig+0xc40>
 8107d54:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
 8107d58:	d826      	bhi.n	8107da8 <HAL_RCCEx_PeriphCLKConfig+0xc34>
 8107d5a:	f1b3 5f40 	cmp.w	r3, #805306368	; 0x30000000
 8107d5e:	d02b      	beq.n	8107db8 <HAL_RCCEx_PeriphCLKConfig+0xc44>
 8107d60:	f1b3 5f40 	cmp.w	r3, #805306368	; 0x30000000
 8107d64:	d820      	bhi.n	8107da8 <HAL_RCCEx_PeriphCLKConfig+0xc34>
 8107d66:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
 8107d6a:	d012      	beq.n	8107d92 <HAL_RCCEx_PeriphCLKConfig+0xc1e>
 8107d6c:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
 8107d70:	d81a      	bhi.n	8107da8 <HAL_RCCEx_PeriphCLKConfig+0xc34>
 8107d72:	2b00      	cmp	r3, #0
 8107d74:	d022      	beq.n	8107dbc <HAL_RCCEx_PeriphCLKConfig+0xc48>
 8107d76:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
 8107d7a:	d115      	bne.n	8107da8 <HAL_RCCEx_PeriphCLKConfig+0xc34>
        /* LPTIM1 clock source configuration done later after clock selection check */
        break;

      case RCC_LPTIM1CLKSOURCE_PLL2: /* PLL2 is used as clock source for LPTIM1*/

        ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2), DIVIDER_P_UPDATE);
 8107d7c:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 8107d80:	3308      	adds	r3, #8
 8107d82:	2100      	movs	r1, #0
 8107d84:	4618      	mov	r0, r3
 8107d86:	f001 fd8f 	bl	81098a8 <RCCEx_PLL2_Config>
 8107d8a:	4603      	mov	r3, r0
 8107d8c:	f887 3127 	strb.w	r3, [r7, #295]	; 0x127

        /* LPTIM1 clock source configuration done later after clock selection check */
        break;
 8107d90:	e015      	b.n	8107dbe <HAL_RCCEx_PeriphCLKConfig+0xc4a>

      case RCC_LPTIM1CLKSOURCE_PLL3:  /* PLL3 is used as clock source for LPTIM1*/
        ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3), DIVIDER_R_UPDATE);
 8107d92:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 8107d96:	3328      	adds	r3, #40	; 0x28
 8107d98:	2102      	movs	r1, #2
 8107d9a:	4618      	mov	r0, r3
 8107d9c:	f001 fe36 	bl	8109a0c <RCCEx_PLL3_Config>
 8107da0:	4603      	mov	r3, r0
 8107da2:	f887 3127 	strb.w	r3, [r7, #295]	; 0x127

        /* LPTIM1 clock source configuration done later after clock selection check */
        break;
 8107da6:	e00a      	b.n	8107dbe <HAL_RCCEx_PeriphCLKConfig+0xc4a>
        /* HSI, HSE, or CSI oscillator is used as source of LPTIM1 clock */
        /* LPTIM1 clock source configuration done later after clock selection check */
        break;

      default:
        ret = HAL_ERROR;
 8107da8:	2301      	movs	r3, #1
 8107daa:	f887 3127 	strb.w	r3, [r7, #295]	; 0x127
        break;
 8107dae:	e006      	b.n	8107dbe <HAL_RCCEx_PeriphCLKConfig+0xc4a>
        break;
 8107db0:	bf00      	nop
 8107db2:	e004      	b.n	8107dbe <HAL_RCCEx_PeriphCLKConfig+0xc4a>
        break;
 8107db4:	bf00      	nop
 8107db6:	e002      	b.n	8107dbe <HAL_RCCEx_PeriphCLKConfig+0xc4a>
        break;
 8107db8:	bf00      	nop
 8107dba:	e000      	b.n	8107dbe <HAL_RCCEx_PeriphCLKConfig+0xc4a>
        break;
 8107dbc:	bf00      	nop
    }

    if (ret == HAL_OK)
 8107dbe:	f897 3127 	ldrb.w	r3, [r7, #295]	; 0x127
 8107dc2:	2b00      	cmp	r3, #0
 8107dc4:	d10b      	bne.n	8107dde <HAL_RCCEx_PeriphCLKConfig+0xc6a>
    {
      /* Set the source of LPTIM1 clock*/
      __HAL_RCC_LPTIM1_CONFIG(PeriphClkInit->Lptim1ClockSelection);
 8107dc6:	4b39      	ldr	r3, [pc, #228]	; (8107eac <HAL_RCCEx_PeriphCLKConfig+0xd38>)
 8107dc8:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8107dca:	f023 41e0 	bic.w	r1, r3, #1879048192	; 0x70000000
 8107dce:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 8107dd2:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 8107dd6:	4a35      	ldr	r2, [pc, #212]	; (8107eac <HAL_RCCEx_PeriphCLKConfig+0xd38>)
 8107dd8:	430b      	orrs	r3, r1
 8107dda:	6553      	str	r3, [r2, #84]	; 0x54
 8107ddc:	e003      	b.n	8107de6 <HAL_RCCEx_PeriphCLKConfig+0xc72>
    }
    else
    {
      /* set overall return value */
      status = ret;
 8107dde:	f897 3127 	ldrb.w	r3, [r7, #295]	; 0x127
 8107de2:	f887 3126 	strb.w	r3, [r7, #294]	; 0x126
    }
  }

  /*---------------------------- LPTIM2 configuration -------------------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM2) == RCC_PERIPHCLK_LPTIM2)
 8107de6:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 8107dea:	e9d3 2300 	ldrd	r2, r3, [r3]
 8107dee:	f002 0340 	and.w	r3, r2, #64	; 0x40
 8107df2:	f8c7 30a0 	str.w	r3, [r7, #160]	; 0xa0
 8107df6:	2300      	movs	r3, #0
 8107df8:	f8c7 30a4 	str.w	r3, [r7, #164]	; 0xa4
 8107dfc:	e9d7 1228 	ldrd	r1, r2, [r7, #160]	; 0xa0
 8107e00:	460b      	mov	r3, r1
 8107e02:	4313      	orrs	r3, r2
 8107e04:	d058      	beq.n	8107eb8 <HAL_RCCEx_PeriphCLKConfig+0xd44>
  {
    switch (PeriphClkInit->Lptim2ClockSelection)
 8107e06:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 8107e0a:	f8d3 309c 	ldr.w	r3, [r3, #156]	; 0x9c
 8107e0e:	f5b3 5fa0 	cmp.w	r3, #5120	; 0x1400
 8107e12:	d033      	beq.n	8107e7c <HAL_RCCEx_PeriphCLKConfig+0xd08>
 8107e14:	f5b3 5fa0 	cmp.w	r3, #5120	; 0x1400
 8107e18:	d82c      	bhi.n	8107e74 <HAL_RCCEx_PeriphCLKConfig+0xd00>
 8107e1a:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
 8107e1e:	d02f      	beq.n	8107e80 <HAL_RCCEx_PeriphCLKConfig+0xd0c>
 8107e20:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
 8107e24:	d826      	bhi.n	8107e74 <HAL_RCCEx_PeriphCLKConfig+0xd00>
 8107e26:	f5b3 6f40 	cmp.w	r3, #3072	; 0xc00
 8107e2a:	d02b      	beq.n	8107e84 <HAL_RCCEx_PeriphCLKConfig+0xd10>
 8107e2c:	f5b3 6f40 	cmp.w	r3, #3072	; 0xc00
 8107e30:	d820      	bhi.n	8107e74 <HAL_RCCEx_PeriphCLKConfig+0xd00>
 8107e32:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
 8107e36:	d012      	beq.n	8107e5e <HAL_RCCEx_PeriphCLKConfig+0xcea>
 8107e38:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
 8107e3c:	d81a      	bhi.n	8107e74 <HAL_RCCEx_PeriphCLKConfig+0xd00>
 8107e3e:	2b00      	cmp	r3, #0
 8107e40:	d022      	beq.n	8107e88 <HAL_RCCEx_PeriphCLKConfig+0xd14>
 8107e42:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 8107e46:	d115      	bne.n	8107e74 <HAL_RCCEx_PeriphCLKConfig+0xd00>
        /* LPTIM2 clock source configuration done later after clock selection check */
        break;

      case RCC_LPTIM2CLKSOURCE_PLL2: /* PLL2 is used as clock source for LPTIM2*/

        ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2), DIVIDER_P_UPDATE);
 8107e48:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 8107e4c:	3308      	adds	r3, #8
 8107e4e:	2100      	movs	r1, #0
 8107e50:	4618      	mov	r0, r3
 8107e52:	f001 fd29 	bl	81098a8 <RCCEx_PLL2_Config>
 8107e56:	4603      	mov	r3, r0
 8107e58:	f887 3127 	strb.w	r3, [r7, #295]	; 0x127

        /* LPTIM2 clock source configuration done later after clock selection check */
        break;
 8107e5c:	e015      	b.n	8107e8a <HAL_RCCEx_PeriphCLKConfig+0xd16>

      case RCC_LPTIM2CLKSOURCE_PLL3:  /* PLL3 is used as clock source for LPTIM2*/
        ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3), DIVIDER_R_UPDATE);
 8107e5e:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 8107e62:	3328      	adds	r3, #40	; 0x28
 8107e64:	2102      	movs	r1, #2
 8107e66:	4618      	mov	r0, r3
 8107e68:	f001 fdd0 	bl	8109a0c <RCCEx_PLL3_Config>
 8107e6c:	4603      	mov	r3, r0
 8107e6e:	f887 3127 	strb.w	r3, [r7, #295]	; 0x127

        /* LPTIM2 clock source configuration done later after clock selection check */
        break;
 8107e72:	e00a      	b.n	8107e8a <HAL_RCCEx_PeriphCLKConfig+0xd16>
        /* HSI, HSE, or CSI oscillator is used as source of LPTIM2 clock */
        /* LPTIM2 clock source configuration done later after clock selection check */
        break;

      default:
        ret = HAL_ERROR;
 8107e74:	2301      	movs	r3, #1
 8107e76:	f887 3127 	strb.w	r3, [r7, #295]	; 0x127
        break;
 8107e7a:	e006      	b.n	8107e8a <HAL_RCCEx_PeriphCLKConfig+0xd16>
        break;
 8107e7c:	bf00      	nop
 8107e7e:	e004      	b.n	8107e8a <HAL_RCCEx_PeriphCLKConfig+0xd16>
        break;
 8107e80:	bf00      	nop
 8107e82:	e002      	b.n	8107e8a <HAL_RCCEx_PeriphCLKConfig+0xd16>
        break;
 8107e84:	bf00      	nop
 8107e86:	e000      	b.n	8107e8a <HAL_RCCEx_PeriphCLKConfig+0xd16>
        break;
 8107e88:	bf00      	nop
    }

    if (ret == HAL_OK)
 8107e8a:	f897 3127 	ldrb.w	r3, [r7, #295]	; 0x127
 8107e8e:	2b00      	cmp	r3, #0
 8107e90:	d10e      	bne.n	8107eb0 <HAL_RCCEx_PeriphCLKConfig+0xd3c>
    {
      /* Set the source of LPTIM2 clock*/
      __HAL_RCC_LPTIM2_CONFIG(PeriphClkInit->Lptim2ClockSelection);
 8107e92:	4b06      	ldr	r3, [pc, #24]	; (8107eac <HAL_RCCEx_PeriphCLKConfig+0xd38>)
 8107e94:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8107e96:	f423 51e0 	bic.w	r1, r3, #7168	; 0x1c00
 8107e9a:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 8107e9e:	f8d3 309c 	ldr.w	r3, [r3, #156]	; 0x9c
 8107ea2:	4a02      	ldr	r2, [pc, #8]	; (8107eac <HAL_RCCEx_PeriphCLKConfig+0xd38>)
 8107ea4:	430b      	orrs	r3, r1
 8107ea6:	6593      	str	r3, [r2, #88]	; 0x58
 8107ea8:	e006      	b.n	8107eb8 <HAL_RCCEx_PeriphCLKConfig+0xd44>
 8107eaa:	bf00      	nop
 8107eac:	58024400 	.word	0x58024400
    }
    else
    {
      /* set overall return value */
      status = ret;
 8107eb0:	f897 3127 	ldrb.w	r3, [r7, #295]	; 0x127
 8107eb4:	f887 3126 	strb.w	r3, [r7, #294]	; 0x126
    }
  }

  /*---------------------------- LPTIM345 configuration -------------------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM345) == RCC_PERIPHCLK_LPTIM345)
 8107eb8:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 8107ebc:	e9d3 2300 	ldrd	r2, r3, [r3]
 8107ec0:	f002 0380 	and.w	r3, r2, #128	; 0x80
 8107ec4:	f8c7 3098 	str.w	r3, [r7, #152]	; 0x98
 8107ec8:	2300      	movs	r3, #0
 8107eca:	f8c7 309c 	str.w	r3, [r7, #156]	; 0x9c
 8107ece:	e9d7 1226 	ldrd	r1, r2, [r7, #152]	; 0x98
 8107ed2:	460b      	mov	r3, r1
 8107ed4:	4313      	orrs	r3, r2
 8107ed6:	d055      	beq.n	8107f84 <HAL_RCCEx_PeriphCLKConfig+0xe10>
  {
    switch (PeriphClkInit->Lptim345ClockSelection)
 8107ed8:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 8107edc:	f8d3 30a0 	ldr.w	r3, [r3, #160]	; 0xa0
 8107ee0:	f5b3 4f20 	cmp.w	r3, #40960	; 0xa000
 8107ee4:	d033      	beq.n	8107f4e <HAL_RCCEx_PeriphCLKConfig+0xdda>
 8107ee6:	f5b3 4f20 	cmp.w	r3, #40960	; 0xa000
 8107eea:	d82c      	bhi.n	8107f46 <HAL_RCCEx_PeriphCLKConfig+0xdd2>
 8107eec:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
 8107ef0:	d02f      	beq.n	8107f52 <HAL_RCCEx_PeriphCLKConfig+0xdde>
 8107ef2:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
 8107ef6:	d826      	bhi.n	8107f46 <HAL_RCCEx_PeriphCLKConfig+0xdd2>
 8107ef8:	f5b3 4fc0 	cmp.w	r3, #24576	; 0x6000
 8107efc:	d02b      	beq.n	8107f56 <HAL_RCCEx_PeriphCLKConfig+0xde2>
 8107efe:	f5b3 4fc0 	cmp.w	r3, #24576	; 0x6000
 8107f02:	d820      	bhi.n	8107f46 <HAL_RCCEx_PeriphCLKConfig+0xdd2>
 8107f04:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
 8107f08:	d012      	beq.n	8107f30 <HAL_RCCEx_PeriphCLKConfig+0xdbc>
 8107f0a:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
 8107f0e:	d81a      	bhi.n	8107f46 <HAL_RCCEx_PeriphCLKConfig+0xdd2>
 8107f10:	2b00      	cmp	r3, #0
 8107f12:	d022      	beq.n	8107f5a <HAL_RCCEx_PeriphCLKConfig+0xde6>
 8107f14:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
 8107f18:	d115      	bne.n	8107f46 <HAL_RCCEx_PeriphCLKConfig+0xdd2>
      case RCC_LPTIM345CLKSOURCE_PCLK4:      /* SRD/D3 PCLK1 (PCLK4) as clock source for LPTIM3/4/5 */
        /* LPTIM3/4/5 clock source configuration done later after clock selection check */
        break;

      case RCC_LPTIM345CLKSOURCE_PLL2: /* PLL2 is used as clock source for LPTIM3/4/5 */
        ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2), DIVIDER_P_UPDATE);
 8107f1a:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 8107f1e:	3308      	adds	r3, #8
 8107f20:	2100      	movs	r1, #0
 8107f22:	4618      	mov	r0, r3
 8107f24:	f001 fcc0 	bl	81098a8 <RCCEx_PLL2_Config>
 8107f28:	4603      	mov	r3, r0
 8107f2a:	f887 3127 	strb.w	r3, [r7, #295]	; 0x127

        /* LPTIM3/4/5 clock source configuration done later after clock selection check */
        break;
 8107f2e:	e015      	b.n	8107f5c <HAL_RCCEx_PeriphCLKConfig+0xde8>

      case RCC_LPTIM345CLKSOURCE_PLL3:  /* PLL3 is used as clock source for LPTIM3/4/5 */
        ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3), DIVIDER_R_UPDATE);
 8107f30:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 8107f34:	3328      	adds	r3, #40	; 0x28
 8107f36:	2102      	movs	r1, #2
 8107f38:	4618      	mov	r0, r3
 8107f3a:	f001 fd67 	bl	8109a0c <RCCEx_PLL3_Config>
 8107f3e:	4603      	mov	r3, r0
 8107f40:	f887 3127 	strb.w	r3, [r7, #295]	; 0x127

        /* LPTIM3/4/5 clock source configuration done later after clock selection check */
        break;
 8107f44:	e00a      	b.n	8107f5c <HAL_RCCEx_PeriphCLKConfig+0xde8>
        /* HSI, HSE, or CSI oscillator is used as source of LPTIM3/4/5 clock */
        /* LPTIM3/4/5 clock source configuration done later after clock selection check */
        break;

      default:
        ret = HAL_ERROR;
 8107f46:	2301      	movs	r3, #1
 8107f48:	f887 3127 	strb.w	r3, [r7, #295]	; 0x127
        break;
 8107f4c:	e006      	b.n	8107f5c <HAL_RCCEx_PeriphCLKConfig+0xde8>
        break;
 8107f4e:	bf00      	nop
 8107f50:	e004      	b.n	8107f5c <HAL_RCCEx_PeriphCLKConfig+0xde8>
        break;
 8107f52:	bf00      	nop
 8107f54:	e002      	b.n	8107f5c <HAL_RCCEx_PeriphCLKConfig+0xde8>
        break;
 8107f56:	bf00      	nop
 8107f58:	e000      	b.n	8107f5c <HAL_RCCEx_PeriphCLKConfig+0xde8>
        break;
 8107f5a:	bf00      	nop
    }

    if (ret == HAL_OK)
 8107f5c:	f897 3127 	ldrb.w	r3, [r7, #295]	; 0x127
 8107f60:	2b00      	cmp	r3, #0
 8107f62:	d10b      	bne.n	8107f7c <HAL_RCCEx_PeriphCLKConfig+0xe08>
    {
      /* Set the source of LPTIM3/4/5 clock */
      __HAL_RCC_LPTIM345_CONFIG(PeriphClkInit->Lptim345ClockSelection);
 8107f64:	4ba1      	ldr	r3, [pc, #644]	; (81081ec <HAL_RCCEx_PeriphCLKConfig+0x1078>)
 8107f66:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8107f68:	f423 4160 	bic.w	r1, r3, #57344	; 0xe000
 8107f6c:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 8107f70:	f8d3 30a0 	ldr.w	r3, [r3, #160]	; 0xa0
 8107f74:	4a9d      	ldr	r2, [pc, #628]	; (81081ec <HAL_RCCEx_PeriphCLKConfig+0x1078>)
 8107f76:	430b      	orrs	r3, r1
 8107f78:	6593      	str	r3, [r2, #88]	; 0x58
 8107f7a:	e003      	b.n	8107f84 <HAL_RCCEx_PeriphCLKConfig+0xe10>
    }
    else
    {
      /* set overall return value */
      status = ret;
 8107f7c:	f897 3127 	ldrb.w	r3, [r7, #295]	; 0x127
 8107f80:	f887 3126 	strb.w	r3, [r7, #294]	; 0x126

    __HAL_RCC_I2C1235_CONFIG(PeriphClkInit->I2c1235ClockSelection);

  }
#else
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C123) == RCC_PERIPHCLK_I2C123)
 8107f84:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 8107f88:	e9d3 2300 	ldrd	r2, r3, [r3]
 8107f8c:	f002 0308 	and.w	r3, r2, #8
 8107f90:	f8c7 3090 	str.w	r3, [r7, #144]	; 0x90
 8107f94:	2300      	movs	r3, #0
 8107f96:	f8c7 3094 	str.w	r3, [r7, #148]	; 0x94
 8107f9a:	e9d7 1224 	ldrd	r1, r2, [r7, #144]	; 0x90
 8107f9e:	460b      	mov	r3, r1
 8107fa0:	4313      	orrs	r3, r2
 8107fa2:	d01e      	beq.n	8107fe2 <HAL_RCCEx_PeriphCLKConfig+0xe6e>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C123CLKSOURCE(PeriphClkInit->I2c123ClockSelection));

    if ((PeriphClkInit->I2c123ClockSelection) == RCC_I2C123CLKSOURCE_PLL3)
 8107fa4:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 8107fa8:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 8107fac:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
 8107fb0:	d10c      	bne.n	8107fcc <HAL_RCCEx_PeriphCLKConfig+0xe58>
    {
      if (RCCEx_PLL3_Config(&(PeriphClkInit->PLL3), DIVIDER_R_UPDATE) != HAL_OK)
 8107fb2:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 8107fb6:	3328      	adds	r3, #40	; 0x28
 8107fb8:	2102      	movs	r1, #2
 8107fba:	4618      	mov	r0, r3
 8107fbc:	f001 fd26 	bl	8109a0c <RCCEx_PLL3_Config>
 8107fc0:	4603      	mov	r3, r0
 8107fc2:	2b00      	cmp	r3, #0
 8107fc4:	d002      	beq.n	8107fcc <HAL_RCCEx_PeriphCLKConfig+0xe58>
      {
        status = HAL_ERROR;
 8107fc6:	2301      	movs	r3, #1
 8107fc8:	f887 3126 	strb.w	r3, [r7, #294]	; 0x126
      }
    }

    __HAL_RCC_I2C123_CONFIG(PeriphClkInit->I2c123ClockSelection);
 8107fcc:	4b87      	ldr	r3, [pc, #540]	; (81081ec <HAL_RCCEx_PeriphCLKConfig+0x1078>)
 8107fce:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8107fd0:	f423 5140 	bic.w	r1, r3, #12288	; 0x3000
 8107fd4:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 8107fd8:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 8107fdc:	4a83      	ldr	r2, [pc, #524]	; (81081ec <HAL_RCCEx_PeriphCLKConfig+0x1078>)
 8107fde:	430b      	orrs	r3, r1
 8107fe0:	6553      	str	r3, [r2, #84]	; 0x54

  }
#endif /* I2C5 */

  /*------------------------------ I2C4 Configuration ------------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C4) == RCC_PERIPHCLK_I2C4)
 8107fe2:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 8107fe6:	e9d3 2300 	ldrd	r2, r3, [r3]
 8107fea:	f002 0310 	and.w	r3, r2, #16
 8107fee:	f8c7 3088 	str.w	r3, [r7, #136]	; 0x88
 8107ff2:	2300      	movs	r3, #0
 8107ff4:	f8c7 308c 	str.w	r3, [r7, #140]	; 0x8c
 8107ff8:	e9d7 1222 	ldrd	r1, r2, [r7, #136]	; 0x88
 8107ffc:	460b      	mov	r3, r1
 8107ffe:	4313      	orrs	r3, r2
 8108000:	d01e      	beq.n	8108040 <HAL_RCCEx_PeriphCLKConfig+0xecc>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C4CLKSOURCE(PeriphClkInit->I2c4ClockSelection));

    if ((PeriphClkInit->I2c4ClockSelection) == RCC_I2C4CLKSOURCE_PLL3)
 8108002:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 8108006:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
 810800a:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 810800e:	d10c      	bne.n	810802a <HAL_RCCEx_PeriphCLKConfig+0xeb6>
    {
      if (RCCEx_PLL3_Config(&(PeriphClkInit->PLL3), DIVIDER_R_UPDATE) != HAL_OK)
 8108010:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 8108014:	3328      	adds	r3, #40	; 0x28
 8108016:	2102      	movs	r1, #2
 8108018:	4618      	mov	r0, r3
 810801a:	f001 fcf7 	bl	8109a0c <RCCEx_PLL3_Config>
 810801e:	4603      	mov	r3, r0
 8108020:	2b00      	cmp	r3, #0
 8108022:	d002      	beq.n	810802a <HAL_RCCEx_PeriphCLKConfig+0xeb6>
      {
        status = HAL_ERROR;
 8108024:	2301      	movs	r3, #1
 8108026:	f887 3126 	strb.w	r3, [r7, #294]	; 0x126
      }
    }

    __HAL_RCC_I2C4_CONFIG(PeriphClkInit->I2c4ClockSelection);
 810802a:	4b70      	ldr	r3, [pc, #448]	; (81081ec <HAL_RCCEx_PeriphCLKConfig+0x1078>)
 810802c:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 810802e:	f423 7140 	bic.w	r1, r3, #768	; 0x300
 8108032:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 8108036:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
 810803a:	4a6c      	ldr	r2, [pc, #432]	; (81081ec <HAL_RCCEx_PeriphCLKConfig+0x1078>)
 810803c:	430b      	orrs	r3, r1
 810803e:	6593      	str	r3, [r2, #88]	; 0x58

  }

  /*---------------------------- ADC configuration -------------------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_ADC) == RCC_PERIPHCLK_ADC)
 8108040:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 8108044:	e9d3 2300 	ldrd	r2, r3, [r3]
 8108048:	f402 2300 	and.w	r3, r2, #524288	; 0x80000
 810804c:	f8c7 3080 	str.w	r3, [r7, #128]	; 0x80
 8108050:	2300      	movs	r3, #0
 8108052:	f8c7 3084 	str.w	r3, [r7, #132]	; 0x84
 8108056:	e9d7 1220 	ldrd	r1, r2, [r7, #128]	; 0x80
 810805a:	460b      	mov	r3, r1
 810805c:	4313      	orrs	r3, r2
 810805e:	d03e      	beq.n	81080de <HAL_RCCEx_PeriphCLKConfig+0xf6a>
  {
    switch (PeriphClkInit->AdcClockSelection)
 8108060:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 8108064:	f8d3 30a4 	ldr.w	r3, [r3, #164]	; 0xa4
 8108068:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
 810806c:	d022      	beq.n	81080b4 <HAL_RCCEx_PeriphCLKConfig+0xf40>
 810806e:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
 8108072:	d81b      	bhi.n	81080ac <HAL_RCCEx_PeriphCLKConfig+0xf38>
 8108074:	2b00      	cmp	r3, #0
 8108076:	d003      	beq.n	8108080 <HAL_RCCEx_PeriphCLKConfig+0xf0c>
 8108078:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 810807c:	d00b      	beq.n	8108096 <HAL_RCCEx_PeriphCLKConfig+0xf22>
 810807e:	e015      	b.n	81080ac <HAL_RCCEx_PeriphCLKConfig+0xf38>
    {

      case RCC_ADCCLKSOURCE_PLL2: /* PLL2 is used as clock source for ADC*/

        ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2), DIVIDER_P_UPDATE);
 8108080:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 8108084:	3308      	adds	r3, #8
 8108086:	2100      	movs	r1, #0
 8108088:	4618      	mov	r0, r3
 810808a:	f001 fc0d 	bl	81098a8 <RCCEx_PLL2_Config>
 810808e:	4603      	mov	r3, r0
 8108090:	f887 3127 	strb.w	r3, [r7, #295]	; 0x127

        /* ADC clock source configuration done later after clock selection check */
        break;
 8108094:	e00f      	b.n	81080b6 <HAL_RCCEx_PeriphCLKConfig+0xf42>

      case RCC_ADCCLKSOURCE_PLL3:  /* PLL3 is used as clock source for ADC*/
        ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3), DIVIDER_R_UPDATE);
 8108096:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 810809a:	3328      	adds	r3, #40	; 0x28
 810809c:	2102      	movs	r1, #2
 810809e:	4618      	mov	r0, r3
 81080a0:	f001 fcb4 	bl	8109a0c <RCCEx_PLL3_Config>
 81080a4:	4603      	mov	r3, r0
 81080a6:	f887 3127 	strb.w	r3, [r7, #295]	; 0x127

        /* ADC clock source configuration done later after clock selection check */
        break;
 81080aa:	e004      	b.n	81080b6 <HAL_RCCEx_PeriphCLKConfig+0xf42>
        /* HSI, HSE, or CSI oscillator is used as source of ADC clock */
        /* ADC clock source configuration done later after clock selection check */
        break;

      default:
        ret = HAL_ERROR;
 81080ac:	2301      	movs	r3, #1
 81080ae:	f887 3127 	strb.w	r3, [r7, #295]	; 0x127
        break;
 81080b2:	e000      	b.n	81080b6 <HAL_RCCEx_PeriphCLKConfig+0xf42>
        break;
 81080b4:	bf00      	nop
    }

    if (ret == HAL_OK)
 81080b6:	f897 3127 	ldrb.w	r3, [r7, #295]	; 0x127
 81080ba:	2b00      	cmp	r3, #0
 81080bc:	d10b      	bne.n	81080d6 <HAL_RCCEx_PeriphCLKConfig+0xf62>
    {
      /* Set the source of ADC clock*/
      __HAL_RCC_ADC_CONFIG(PeriphClkInit->AdcClockSelection);
 81080be:	4b4b      	ldr	r3, [pc, #300]	; (81081ec <HAL_RCCEx_PeriphCLKConfig+0x1078>)
 81080c0:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 81080c2:	f423 3140 	bic.w	r1, r3, #196608	; 0x30000
 81080c6:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 81080ca:	f8d3 30a4 	ldr.w	r3, [r3, #164]	; 0xa4
 81080ce:	4a47      	ldr	r2, [pc, #284]	; (81081ec <HAL_RCCEx_PeriphCLKConfig+0x1078>)
 81080d0:	430b      	orrs	r3, r1
 81080d2:	6593      	str	r3, [r2, #88]	; 0x58
 81080d4:	e003      	b.n	81080de <HAL_RCCEx_PeriphCLKConfig+0xf6a>
    }
    else
    {
      /* set overall return value */
      status = ret;
 81080d6:	f897 3127 	ldrb.w	r3, [r7, #295]	; 0x127
 81080da:	f887 3126 	strb.w	r3, [r7, #294]	; 0x126
    }
  }

  /*------------------------------ USB Configuration -------------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USB) == RCC_PERIPHCLK_USB)
 81080de:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 81080e2:	e9d3 2300 	ldrd	r2, r3, [r3]
 81080e6:	f402 2380 	and.w	r3, r2, #262144	; 0x40000
 81080ea:	67bb      	str	r3, [r7, #120]	; 0x78
 81080ec:	2300      	movs	r3, #0
 81080ee:	67fb      	str	r3, [r7, #124]	; 0x7c
 81080f0:	e9d7 121e 	ldrd	r1, r2, [r7, #120]	; 0x78
 81080f4:	460b      	mov	r3, r1
 81080f6:	4313      	orrs	r3, r2
 81080f8:	d03b      	beq.n	8108172 <HAL_RCCEx_PeriphCLKConfig+0xffe>
  {

    switch (PeriphClkInit->UsbClockSelection)
 81080fa:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 81080fe:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 8108102:	f5b3 1f40 	cmp.w	r3, #3145728	; 0x300000
 8108106:	d01f      	beq.n	8108148 <HAL_RCCEx_PeriphCLKConfig+0xfd4>
 8108108:	f5b3 1f40 	cmp.w	r3, #3145728	; 0x300000
 810810c:	d818      	bhi.n	8108140 <HAL_RCCEx_PeriphCLKConfig+0xfcc>
 810810e:	f5b3 1f80 	cmp.w	r3, #1048576	; 0x100000
 8108112:	d003      	beq.n	810811c <HAL_RCCEx_PeriphCLKConfig+0xfa8>
 8108114:	f5b3 1f00 	cmp.w	r3, #2097152	; 0x200000
 8108118:	d007      	beq.n	810812a <HAL_RCCEx_PeriphCLKConfig+0xfb6>
 810811a:	e011      	b.n	8108140 <HAL_RCCEx_PeriphCLKConfig+0xfcc>
    {
      case RCC_USBCLKSOURCE_PLL:      /* PLL is used as clock source for USB*/
        /* Enable USB Clock output generated form System USB . */
        __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
 810811c:	4b33      	ldr	r3, [pc, #204]	; (81081ec <HAL_RCCEx_PeriphCLKConfig+0x1078>)
 810811e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8108120:	4a32      	ldr	r2, [pc, #200]	; (81081ec <HAL_RCCEx_PeriphCLKConfig+0x1078>)
 8108122:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 8108126:	62d3      	str	r3, [r2, #44]	; 0x2c

        /* USB clock source configuration done later after clock selection check */
        break;
 8108128:	e00f      	b.n	810814a <HAL_RCCEx_PeriphCLKConfig+0xfd6>

      case RCC_USBCLKSOURCE_PLL3: /* PLL3 is used as clock source for USB*/

        ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3), DIVIDER_Q_UPDATE);
 810812a:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 810812e:	3328      	adds	r3, #40	; 0x28
 8108130:	2101      	movs	r1, #1
 8108132:	4618      	mov	r0, r3
 8108134:	f001 fc6a 	bl	8109a0c <RCCEx_PLL3_Config>
 8108138:	4603      	mov	r3, r0
 810813a:	f887 3127 	strb.w	r3, [r7, #295]	; 0x127

        /* USB clock source configuration done later after clock selection check */
        break;
 810813e:	e004      	b.n	810814a <HAL_RCCEx_PeriphCLKConfig+0xfd6>
        /* HSI48 oscillator is used as source of USB clock */
        /* USB clock source configuration done later after clock selection check */
        break;

      default:
        ret = HAL_ERROR;
 8108140:	2301      	movs	r3, #1
 8108142:	f887 3127 	strb.w	r3, [r7, #295]	; 0x127
        break;
 8108146:	e000      	b.n	810814a <HAL_RCCEx_PeriphCLKConfig+0xfd6>
        break;
 8108148:	bf00      	nop
    }

    if (ret == HAL_OK)
 810814a:	f897 3127 	ldrb.w	r3, [r7, #295]	; 0x127
 810814e:	2b00      	cmp	r3, #0
 8108150:	d10b      	bne.n	810816a <HAL_RCCEx_PeriphCLKConfig+0xff6>
    {
      /* Set the source of USB clock*/
      __HAL_RCC_USB_CONFIG(PeriphClkInit->UsbClockSelection);
 8108152:	4b26      	ldr	r3, [pc, #152]	; (81081ec <HAL_RCCEx_PeriphCLKConfig+0x1078>)
 8108154:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8108156:	f423 1140 	bic.w	r1, r3, #3145728	; 0x300000
 810815a:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 810815e:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 8108162:	4a22      	ldr	r2, [pc, #136]	; (81081ec <HAL_RCCEx_PeriphCLKConfig+0x1078>)
 8108164:	430b      	orrs	r3, r1
 8108166:	6553      	str	r3, [r2, #84]	; 0x54
 8108168:	e003      	b.n	8108172 <HAL_RCCEx_PeriphCLKConfig+0xffe>
    }
    else
    {
      /* set overall return value */
      status = ret;
 810816a:	f897 3127 	ldrb.w	r3, [r7, #295]	; 0x127
 810816e:	f887 3126 	strb.w	r3, [r7, #294]	; 0x126
    }

  }

  /*------------------------------------- SDMMC Configuration ------------------------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SDMMC) == RCC_PERIPHCLK_SDMMC)
 8108172:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 8108176:	e9d3 2300 	ldrd	r2, r3, [r3]
 810817a:	f402 3380 	and.w	r3, r2, #65536	; 0x10000
 810817e:	673b      	str	r3, [r7, #112]	; 0x70
 8108180:	2300      	movs	r3, #0
 8108182:	677b      	str	r3, [r7, #116]	; 0x74
 8108184:	e9d7 121c 	ldrd	r1, r2, [r7, #112]	; 0x70
 8108188:	460b      	mov	r3, r1
 810818a:	4313      	orrs	r3, r2
 810818c:	d034      	beq.n	81081f8 <HAL_RCCEx_PeriphCLKConfig+0x1084>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SDMMC(PeriphClkInit->SdmmcClockSelection));

    switch (PeriphClkInit->SdmmcClockSelection)
 810818e:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 8108192:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8108194:	2b00      	cmp	r3, #0
 8108196:	d003      	beq.n	81081a0 <HAL_RCCEx_PeriphCLKConfig+0x102c>
 8108198:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 810819c:	d007      	beq.n	81081ae <HAL_RCCEx_PeriphCLKConfig+0x103a>
 810819e:	e011      	b.n	81081c4 <HAL_RCCEx_PeriphCLKConfig+0x1050>
    {
      case RCC_SDMMCCLKSOURCE_PLL:      /* PLL is used as clock source for SDMMC*/
        /* Enable SDMMC Clock output generated form System PLL . */
        __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
 81081a0:	4b12      	ldr	r3, [pc, #72]	; (81081ec <HAL_RCCEx_PeriphCLKConfig+0x1078>)
 81081a2:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 81081a4:	4a11      	ldr	r2, [pc, #68]	; (81081ec <HAL_RCCEx_PeriphCLKConfig+0x1078>)
 81081a6:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 81081aa:	62d3      	str	r3, [r2, #44]	; 0x2c

        /* SDMMC clock source configuration done later after clock selection check */
        break;
 81081ac:	e00e      	b.n	81081cc <HAL_RCCEx_PeriphCLKConfig+0x1058>

      case RCC_SDMMCCLKSOURCE_PLL2: /* PLL2 is used as clock source for SDMMC*/

        ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2), DIVIDER_R_UPDATE);
 81081ae:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 81081b2:	3308      	adds	r3, #8
 81081b4:	2102      	movs	r1, #2
 81081b6:	4618      	mov	r0, r3
 81081b8:	f001 fb76 	bl	81098a8 <RCCEx_PLL2_Config>
 81081bc:	4603      	mov	r3, r0
 81081be:	f887 3127 	strb.w	r3, [r7, #295]	; 0x127

        /* SDMMC clock source configuration done later after clock selection check */
        break;
 81081c2:	e003      	b.n	81081cc <HAL_RCCEx_PeriphCLKConfig+0x1058>

      default:
        ret = HAL_ERROR;
 81081c4:	2301      	movs	r3, #1
 81081c6:	f887 3127 	strb.w	r3, [r7, #295]	; 0x127
        break;
 81081ca:	bf00      	nop
    }

    if (ret == HAL_OK)
 81081cc:	f897 3127 	ldrb.w	r3, [r7, #295]	; 0x127
 81081d0:	2b00      	cmp	r3, #0
 81081d2:	d10d      	bne.n	81081f0 <HAL_RCCEx_PeriphCLKConfig+0x107c>
    {
      /* Set the source of SDMMC clock*/
      __HAL_RCC_SDMMC_CONFIG(PeriphClkInit->SdmmcClockSelection);
 81081d4:	4b05      	ldr	r3, [pc, #20]	; (81081ec <HAL_RCCEx_PeriphCLKConfig+0x1078>)
 81081d6:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 81081d8:	f423 3180 	bic.w	r1, r3, #65536	; 0x10000
 81081dc:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 81081e0:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 81081e2:	4a02      	ldr	r2, [pc, #8]	; (81081ec <HAL_RCCEx_PeriphCLKConfig+0x1078>)
 81081e4:	430b      	orrs	r3, r1
 81081e6:	64d3      	str	r3, [r2, #76]	; 0x4c
 81081e8:	e006      	b.n	81081f8 <HAL_RCCEx_PeriphCLKConfig+0x1084>
 81081ea:	bf00      	nop
 81081ec:	58024400 	.word	0x58024400
    }
    else
    {
      /* set overall return value */
      status = ret;
 81081f0:	f897 3127 	ldrb.w	r3, [r7, #295]	; 0x127
 81081f4:	f887 3126 	strb.w	r3, [r7, #294]	; 0x126
    }
  }

#if defined(LTDC)
  /*-------------------------------------- LTDC Configuration -----------------------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LTDC) == RCC_PERIPHCLK_LTDC)
 81081f8:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 81081fc:	e9d3 2300 	ldrd	r2, r3, [r3]
 8108200:	f002 5300 	and.w	r3, r2, #536870912	; 0x20000000
 8108204:	66bb      	str	r3, [r7, #104]	; 0x68
 8108206:	2300      	movs	r3, #0
 8108208:	66fb      	str	r3, [r7, #108]	; 0x6c
 810820a:	e9d7 121a 	ldrd	r1, r2, [r7, #104]	; 0x68
 810820e:	460b      	mov	r3, r1
 8108210:	4313      	orrs	r3, r2
 8108212:	d00c      	beq.n	810822e <HAL_RCCEx_PeriphCLKConfig+0x10ba>
  {
    if (RCCEx_PLL3_Config(&(PeriphClkInit->PLL3), DIVIDER_R_UPDATE) != HAL_OK)
 8108214:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 8108218:	3328      	adds	r3, #40	; 0x28
 810821a:	2102      	movs	r1, #2
 810821c:	4618      	mov	r0, r3
 810821e:	f001 fbf5 	bl	8109a0c <RCCEx_PLL3_Config>
 8108222:	4603      	mov	r3, r0
 8108224:	2b00      	cmp	r3, #0
 8108226:	d002      	beq.n	810822e <HAL_RCCEx_PeriphCLKConfig+0x10ba>
    {
      status = HAL_ERROR;
 8108228:	2301      	movs	r3, #1
 810822a:	f887 3126 	strb.w	r3, [r7, #294]	; 0x126
    }
  }
#endif /* LTDC */

  /*------------------------------ RNG Configuration -------------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RNG) == RCC_PERIPHCLK_RNG)
 810822e:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 8108232:	e9d3 2300 	ldrd	r2, r3, [r3]
 8108236:	f402 3300 	and.w	r3, r2, #131072	; 0x20000
 810823a:	663b      	str	r3, [r7, #96]	; 0x60
 810823c:	2300      	movs	r3, #0
 810823e:	667b      	str	r3, [r7, #100]	; 0x64
 8108240:	e9d7 1218 	ldrd	r1, r2, [r7, #96]	; 0x60
 8108244:	460b      	mov	r3, r1
 8108246:	4313      	orrs	r3, r2
 8108248:	d038      	beq.n	81082bc <HAL_RCCEx_PeriphCLKConfig+0x1148>
  {

    switch (PeriphClkInit->RngClockSelection)
 810824a:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 810824e:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
 8108252:	f5b3 7f40 	cmp.w	r3, #768	; 0x300
 8108256:	d018      	beq.n	810828a <HAL_RCCEx_PeriphCLKConfig+0x1116>
 8108258:	f5b3 7f40 	cmp.w	r3, #768	; 0x300
 810825c:	d811      	bhi.n	8108282 <HAL_RCCEx_PeriphCLKConfig+0x110e>
 810825e:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 8108262:	d014      	beq.n	810828e <HAL_RCCEx_PeriphCLKConfig+0x111a>
 8108264:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 8108268:	d80b      	bhi.n	8108282 <HAL_RCCEx_PeriphCLKConfig+0x110e>
 810826a:	2b00      	cmp	r3, #0
 810826c:	d011      	beq.n	8108292 <HAL_RCCEx_PeriphCLKConfig+0x111e>
 810826e:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 8108272:	d106      	bne.n	8108282 <HAL_RCCEx_PeriphCLKConfig+0x110e>
    {
      case RCC_RNGCLKSOURCE_PLL:     /* PLL is used as clock source for RNG*/
        /* Enable RNG Clock output generated form System RNG . */
        __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
 8108274:	4bc3      	ldr	r3, [pc, #780]	; (8108584 <HAL_RCCEx_PeriphCLKConfig+0x1410>)
 8108276:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8108278:	4ac2      	ldr	r2, [pc, #776]	; (8108584 <HAL_RCCEx_PeriphCLKConfig+0x1410>)
 810827a:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 810827e:	62d3      	str	r3, [r2, #44]	; 0x2c

        /* RNG clock source configuration done later after clock selection check */
        break;
 8108280:	e008      	b.n	8108294 <HAL_RCCEx_PeriphCLKConfig+0x1120>
        /* HSI48 oscillator is used as source of RNG clock */
        /* RNG clock source configuration done later after clock selection check */
        break;

      default:
        ret = HAL_ERROR;
 8108282:	2301      	movs	r3, #1
 8108284:	f887 3127 	strb.w	r3, [r7, #295]	; 0x127
        break;
 8108288:	e004      	b.n	8108294 <HAL_RCCEx_PeriphCLKConfig+0x1120>
        break;
 810828a:	bf00      	nop
 810828c:	e002      	b.n	8108294 <HAL_RCCEx_PeriphCLKConfig+0x1120>
        break;
 810828e:	bf00      	nop
 8108290:	e000      	b.n	8108294 <HAL_RCCEx_PeriphCLKConfig+0x1120>
        break;
 8108292:	bf00      	nop
    }

    if (ret == HAL_OK)
 8108294:	f897 3127 	ldrb.w	r3, [r7, #295]	; 0x127
 8108298:	2b00      	cmp	r3, #0
 810829a:	d10b      	bne.n	81082b4 <HAL_RCCEx_PeriphCLKConfig+0x1140>
    {
      /* Set the source of RNG clock*/
      __HAL_RCC_RNG_CONFIG(PeriphClkInit->RngClockSelection);
 810829c:	4bb9      	ldr	r3, [pc, #740]	; (8108584 <HAL_RCCEx_PeriphCLKConfig+0x1410>)
 810829e:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 81082a0:	f423 7140 	bic.w	r1, r3, #768	; 0x300
 81082a4:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 81082a8:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
 81082ac:	4ab5      	ldr	r2, [pc, #724]	; (8108584 <HAL_RCCEx_PeriphCLKConfig+0x1410>)
 81082ae:	430b      	orrs	r3, r1
 81082b0:	6553      	str	r3, [r2, #84]	; 0x54
 81082b2:	e003      	b.n	81082bc <HAL_RCCEx_PeriphCLKConfig+0x1148>
    }
    else
    {
      /* set overall return value */
      status = ret;
 81082b4:	f897 3127 	ldrb.w	r3, [r7, #295]	; 0x127
 81082b8:	f887 3126 	strb.w	r3, [r7, #294]	; 0x126
    }

  }

  /*------------------------------ SWPMI1 Configuration ------------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SWPMI1) == RCC_PERIPHCLK_SWPMI1)
 81082bc:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 81082c0:	e9d3 2300 	ldrd	r2, r3, [r3]
 81082c4:	f402 1380 	and.w	r3, r2, #1048576	; 0x100000
 81082c8:	65bb      	str	r3, [r7, #88]	; 0x58
 81082ca:	2300      	movs	r3, #0
 81082cc:	65fb      	str	r3, [r7, #92]	; 0x5c
 81082ce:	e9d7 1216 	ldrd	r1, r2, [r7, #88]	; 0x58
 81082d2:	460b      	mov	r3, r1
 81082d4:	4313      	orrs	r3, r2
 81082d6:	d009      	beq.n	81082ec <HAL_RCCEx_PeriphCLKConfig+0x1178>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SWPMI1CLKSOURCE(PeriphClkInit->Swpmi1ClockSelection));

    /* Configure the SWPMI1 interface clock source */
    __HAL_RCC_SWPMI1_CONFIG(PeriphClkInit->Swpmi1ClockSelection);
 81082d8:	4baa      	ldr	r3, [pc, #680]	; (8108584 <HAL_RCCEx_PeriphCLKConfig+0x1410>)
 81082da:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 81082dc:	f023 4100 	bic.w	r1, r3, #2147483648	; 0x80000000
 81082e0:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 81082e4:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 81082e6:	4aa7      	ldr	r2, [pc, #668]	; (8108584 <HAL_RCCEx_PeriphCLKConfig+0x1410>)
 81082e8:	430b      	orrs	r3, r1
 81082ea:	6513      	str	r3, [r2, #80]	; 0x50
  }
#if defined(HRTIM1)
  /*------------------------------ HRTIM1 clock Configuration ----------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_HRTIM1) == RCC_PERIPHCLK_HRTIM1)
 81082ec:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 81082f0:	e9d3 2300 	ldrd	r2, r3, [r3]
 81082f4:	f002 5380 	and.w	r3, r2, #268435456	; 0x10000000
 81082f8:	653b      	str	r3, [r7, #80]	; 0x50
 81082fa:	2300      	movs	r3, #0
 81082fc:	657b      	str	r3, [r7, #84]	; 0x54
 81082fe:	e9d7 1214 	ldrd	r1, r2, [r7, #80]	; 0x50
 8108302:	460b      	mov	r3, r1
 8108304:	4313      	orrs	r3, r2
 8108306:	d00a      	beq.n	810831e <HAL_RCCEx_PeriphCLKConfig+0x11aa>
  {
    /* Check the parameters */
    assert_param(IS_RCC_HRTIM1CLKSOURCE(PeriphClkInit->Hrtim1ClockSelection));

    /* Configure the HRTIM1 clock source */
    __HAL_RCC_HRTIM1_CONFIG(PeriphClkInit->Hrtim1ClockSelection);
 8108308:	4b9e      	ldr	r3, [pc, #632]	; (8108584 <HAL_RCCEx_PeriphCLKConfig+0x1410>)
 810830a:	691b      	ldr	r3, [r3, #16]
 810830c:	f423 4180 	bic.w	r1, r3, #16384	; 0x4000
 8108310:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 8108314:	f8d3 30b8 	ldr.w	r3, [r3, #184]	; 0xb8
 8108318:	4a9a      	ldr	r2, [pc, #616]	; (8108584 <HAL_RCCEx_PeriphCLKConfig+0x1410>)
 810831a:	430b      	orrs	r3, r1
 810831c:	6113      	str	r3, [r2, #16]
  }
#endif  /*HRTIM1*/
  /*------------------------------ DFSDM1 Configuration ------------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_DFSDM1) == RCC_PERIPHCLK_DFSDM1)
 810831e:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 8108322:	e9d3 2300 	ldrd	r2, r3, [r3]
 8108326:	f402 1300 	and.w	r3, r2, #2097152	; 0x200000
 810832a:	64bb      	str	r3, [r7, #72]	; 0x48
 810832c:	2300      	movs	r3, #0
 810832e:	64fb      	str	r3, [r7, #76]	; 0x4c
 8108330:	e9d7 1212 	ldrd	r1, r2, [r7, #72]	; 0x48
 8108334:	460b      	mov	r3, r1
 8108336:	4313      	orrs	r3, r2
 8108338:	d009      	beq.n	810834e <HAL_RCCEx_PeriphCLKConfig+0x11da>
  {
    /* Check the parameters */
    assert_param(IS_RCC_DFSDM1CLKSOURCE(PeriphClkInit->Dfsdm1ClockSelection));

    /* Configure the DFSDM1 interface clock source */
    __HAL_RCC_DFSDM1_CONFIG(PeriphClkInit->Dfsdm1ClockSelection);
 810833a:	4b92      	ldr	r3, [pc, #584]	; (8108584 <HAL_RCCEx_PeriphCLKConfig+0x1410>)
 810833c:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 810833e:	f023 7180 	bic.w	r1, r3, #16777216	; 0x1000000
 8108342:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 8108346:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 8108348:	4a8e      	ldr	r2, [pc, #568]	; (8108584 <HAL_RCCEx_PeriphCLKConfig+0x1410>)
 810834a:	430b      	orrs	r3, r1
 810834c:	6513      	str	r3, [r2, #80]	; 0x50
    __HAL_RCC_DFSDM2_CONFIG(PeriphClkInit->Dfsdm2ClockSelection);
  }
#endif  /* DFSDM2 */

  /*------------------------------------ TIM configuration --------------------------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_TIM) == RCC_PERIPHCLK_TIM)
 810834e:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 8108352:	e9d3 2300 	ldrd	r2, r3, [r3]
 8108356:	f002 4380 	and.w	r3, r2, #1073741824	; 0x40000000
 810835a:	643b      	str	r3, [r7, #64]	; 0x40
 810835c:	2300      	movs	r3, #0
 810835e:	647b      	str	r3, [r7, #68]	; 0x44
 8108360:	e9d7 1210 	ldrd	r1, r2, [r7, #64]	; 0x40
 8108364:	460b      	mov	r3, r1
 8108366:	4313      	orrs	r3, r2
 8108368:	d00e      	beq.n	8108388 <HAL_RCCEx_PeriphCLKConfig+0x1214>
  {
    /* Check the parameters */
    assert_param(IS_RCC_TIMPRES(PeriphClkInit->TIMPresSelection));

    /* Configure Timer Prescaler */
    __HAL_RCC_TIMCLKPRESCALER(PeriphClkInit->TIMPresSelection);
 810836a:	4b86      	ldr	r3, [pc, #536]	; (8108584 <HAL_RCCEx_PeriphCLKConfig+0x1410>)
 810836c:	691b      	ldr	r3, [r3, #16]
 810836e:	4a85      	ldr	r2, [pc, #532]	; (8108584 <HAL_RCCEx_PeriphCLKConfig+0x1410>)
 8108370:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
 8108374:	6113      	str	r3, [r2, #16]
 8108376:	4b83      	ldr	r3, [pc, #524]	; (8108584 <HAL_RCCEx_PeriphCLKConfig+0x1410>)
 8108378:	6919      	ldr	r1, [r3, #16]
 810837a:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 810837e:	f8d3 30bc 	ldr.w	r3, [r3, #188]	; 0xbc
 8108382:	4a80      	ldr	r2, [pc, #512]	; (8108584 <HAL_RCCEx_PeriphCLKConfig+0x1410>)
 8108384:	430b      	orrs	r3, r1
 8108386:	6113      	str	r3, [r2, #16]
  }

  /*------------------------------------ CKPER configuration --------------------------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_CKPER) == RCC_PERIPHCLK_CKPER)
 8108388:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 810838c:	e9d3 2300 	ldrd	r2, r3, [r3]
 8108390:	f002 4300 	and.w	r3, r2, #2147483648	; 0x80000000
 8108394:	63bb      	str	r3, [r7, #56]	; 0x38
 8108396:	2300      	movs	r3, #0
 8108398:	63fb      	str	r3, [r7, #60]	; 0x3c
 810839a:	e9d7 120e 	ldrd	r1, r2, [r7, #56]	; 0x38
 810839e:	460b      	mov	r3, r1
 81083a0:	4313      	orrs	r3, r2
 81083a2:	d009      	beq.n	81083b8 <HAL_RCCEx_PeriphCLKConfig+0x1244>
  {
    /* Check the parameters */
    assert_param(IS_RCC_CLKPSOURCE(PeriphClkInit->CkperClockSelection));

    /* Configure the CKPER clock source */
    __HAL_RCC_CLKP_CONFIG(PeriphClkInit->CkperClockSelection);
 81083a4:	4b77      	ldr	r3, [pc, #476]	; (8108584 <HAL_RCCEx_PeriphCLKConfig+0x1410>)
 81083a6:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 81083a8:	f023 5140 	bic.w	r1, r3, #805306368	; 0x30000000
 81083ac:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 81083b0:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 81083b2:	4a74      	ldr	r2, [pc, #464]	; (8108584 <HAL_RCCEx_PeriphCLKConfig+0x1410>)
 81083b4:	430b      	orrs	r3, r1
 81083b6:	64d3      	str	r3, [r2, #76]	; 0x4c
  }

  /*------------------------------ CEC Configuration ------------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_CEC) == RCC_PERIPHCLK_CEC)
 81083b8:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 81083bc:	e9d3 2300 	ldrd	r2, r3, [r3]
 81083c0:	f402 0300 	and.w	r3, r2, #8388608	; 0x800000
 81083c4:	633b      	str	r3, [r7, #48]	; 0x30
 81083c6:	2300      	movs	r3, #0
 81083c8:	637b      	str	r3, [r7, #52]	; 0x34
 81083ca:	e9d7 120c 	ldrd	r1, r2, [r7, #48]	; 0x30
 81083ce:	460b      	mov	r3, r1
 81083d0:	4313      	orrs	r3, r2
 81083d2:	d00a      	beq.n	81083ea <HAL_RCCEx_PeriphCLKConfig+0x1276>
  {
    /* Check the parameters */
    assert_param(IS_RCC_CECCLKSOURCE(PeriphClkInit->CecClockSelection));

    /* Configure the CEC interface clock source */
    __HAL_RCC_CEC_CONFIG(PeriphClkInit->CecClockSelection);
 81083d4:	4b6b      	ldr	r3, [pc, #428]	; (8108584 <HAL_RCCEx_PeriphCLKConfig+0x1410>)
 81083d6:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 81083d8:	f423 0140 	bic.w	r1, r3, #12582912	; 0xc00000
 81083dc:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 81083e0:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 81083e4:	4a67      	ldr	r2, [pc, #412]	; (8108584 <HAL_RCCEx_PeriphCLKConfig+0x1410>)
 81083e6:	430b      	orrs	r3, r1
 81083e8:	6553      	str	r3, [r2, #84]	; 0x54
  }

  /*---------------------------- PLL2 configuration -------------------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_PLL2_DIVP) == RCC_PERIPHCLK_PLL2_DIVP)
 81083ea:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 81083ee:	e9d3 2300 	ldrd	r2, r3, [r3]
 81083f2:	2100      	movs	r1, #0
 81083f4:	62b9      	str	r1, [r7, #40]	; 0x28
 81083f6:	f003 0301 	and.w	r3, r3, #1
 81083fa:	62fb      	str	r3, [r7, #44]	; 0x2c
 81083fc:	e9d7 120a 	ldrd	r1, r2, [r7, #40]	; 0x28
 8108400:	460b      	mov	r3, r1
 8108402:	4313      	orrs	r3, r2
 8108404:	d011      	beq.n	810842a <HAL_RCCEx_PeriphCLKConfig+0x12b6>
  {
    ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2), DIVIDER_P_UPDATE);
 8108406:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 810840a:	3308      	adds	r3, #8
 810840c:	2100      	movs	r1, #0
 810840e:	4618      	mov	r0, r3
 8108410:	f001 fa4a 	bl	81098a8 <RCCEx_PLL2_Config>
 8108414:	4603      	mov	r3, r0
 8108416:	f887 3127 	strb.w	r3, [r7, #295]	; 0x127
    
    if (ret == HAL_OK)
 810841a:	f897 3127 	ldrb.w	r3, [r7, #295]	; 0x127
 810841e:	2b00      	cmp	r3, #0
 8108420:	d003      	beq.n	810842a <HAL_RCCEx_PeriphCLKConfig+0x12b6>
      /*Nothing to do*/
    }
    else
    {
      /* set overall return value */
      status = ret;
 8108422:	f897 3127 	ldrb.w	r3, [r7, #295]	; 0x127
 8108426:	f887 3126 	strb.w	r3, [r7, #294]	; 0x126
    } 
  }
  
  
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_PLL2_DIVQ) == RCC_PERIPHCLK_PLL2_DIVQ)
 810842a:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 810842e:	e9d3 2300 	ldrd	r2, r3, [r3]
 8108432:	2100      	movs	r1, #0
 8108434:	6239      	str	r1, [r7, #32]
 8108436:	f003 0302 	and.w	r3, r3, #2
 810843a:	627b      	str	r3, [r7, #36]	; 0x24
 810843c:	e9d7 1208 	ldrd	r1, r2, [r7, #32]
 8108440:	460b      	mov	r3, r1
 8108442:	4313      	orrs	r3, r2
 8108444:	d011      	beq.n	810846a <HAL_RCCEx_PeriphCLKConfig+0x12f6>
  {
    ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2), DIVIDER_Q_UPDATE);
 8108446:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 810844a:	3308      	adds	r3, #8
 810844c:	2101      	movs	r1, #1
 810844e:	4618      	mov	r0, r3
 8108450:	f001 fa2a 	bl	81098a8 <RCCEx_PLL2_Config>
 8108454:	4603      	mov	r3, r0
 8108456:	f887 3127 	strb.w	r3, [r7, #295]	; 0x127
    
    if (ret == HAL_OK)
 810845a:	f897 3127 	ldrb.w	r3, [r7, #295]	; 0x127
 810845e:	2b00      	cmp	r3, #0
 8108460:	d003      	beq.n	810846a <HAL_RCCEx_PeriphCLKConfig+0x12f6>
      /*Nothing to do*/
    }
    else
    {
      /* set overall return value */
      status = ret;
 8108462:	f897 3127 	ldrb.w	r3, [r7, #295]	; 0x127
 8108466:	f887 3126 	strb.w	r3, [r7, #294]	; 0x126
    }
  }
  
  
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_PLL2_DIVR) == RCC_PERIPHCLK_PLL2_DIVR)
 810846a:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 810846e:	e9d3 2300 	ldrd	r2, r3, [r3]
 8108472:	2100      	movs	r1, #0
 8108474:	61b9      	str	r1, [r7, #24]
 8108476:	f003 0304 	and.w	r3, r3, #4
 810847a:	61fb      	str	r3, [r7, #28]
 810847c:	e9d7 1206 	ldrd	r1, r2, [r7, #24]
 8108480:	460b      	mov	r3, r1
 8108482:	4313      	orrs	r3, r2
 8108484:	d011      	beq.n	81084aa <HAL_RCCEx_PeriphCLKConfig+0x1336>
  {
    ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2), DIVIDER_R_UPDATE);
 8108486:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 810848a:	3308      	adds	r3, #8
 810848c:	2102      	movs	r1, #2
 810848e:	4618      	mov	r0, r3
 8108490:	f001 fa0a 	bl	81098a8 <RCCEx_PLL2_Config>
 8108494:	4603      	mov	r3, r0
 8108496:	f887 3127 	strb.w	r3, [r7, #295]	; 0x127
    
    if (ret == HAL_OK)
 810849a:	f897 3127 	ldrb.w	r3, [r7, #295]	; 0x127
 810849e:	2b00      	cmp	r3, #0
 81084a0:	d003      	beq.n	81084aa <HAL_RCCEx_PeriphCLKConfig+0x1336>
      /*Nothing to do*/
    }
    else
    {
      /* set overall return value */
      status = ret;
 81084a2:	f897 3127 	ldrb.w	r3, [r7, #295]	; 0x127
 81084a6:	f887 3126 	strb.w	r3, [r7, #294]	; 0x126
    }
  }
  

  /*---------------------------- PLL3 configuration -------------------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_PLL3_DIVP) == RCC_PERIPHCLK_PLL3_DIVP)
 81084aa:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 81084ae:	e9d3 2300 	ldrd	r2, r3, [r3]
 81084b2:	2100      	movs	r1, #0
 81084b4:	6139      	str	r1, [r7, #16]
 81084b6:	f003 0308 	and.w	r3, r3, #8
 81084ba:	617b      	str	r3, [r7, #20]
 81084bc:	e9d7 1204 	ldrd	r1, r2, [r7, #16]
 81084c0:	460b      	mov	r3, r1
 81084c2:	4313      	orrs	r3, r2
 81084c4:	d011      	beq.n	81084ea <HAL_RCCEx_PeriphCLKConfig+0x1376>
  {
    ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3), DIVIDER_P_UPDATE);
 81084c6:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 81084ca:	3328      	adds	r3, #40	; 0x28
 81084cc:	2100      	movs	r1, #0
 81084ce:	4618      	mov	r0, r3
 81084d0:	f001 fa9c 	bl	8109a0c <RCCEx_PLL3_Config>
 81084d4:	4603      	mov	r3, r0
 81084d6:	f887 3127 	strb.w	r3, [r7, #295]	; 0x127
  
    if (ret == HAL_OK)
 81084da:	f897 3127 	ldrb.w	r3, [r7, #295]	; 0x127
 81084de:	2b00      	cmp	r3, #0
 81084e0:	d003      	beq.n	81084ea <HAL_RCCEx_PeriphCLKConfig+0x1376>
      /*Nothing to do*/
    }
    else
    {
      /* set overall return value */
      status = ret;
 81084e2:	f897 3127 	ldrb.w	r3, [r7, #295]	; 0x127
 81084e6:	f887 3126 	strb.w	r3, [r7, #294]	; 0x126
    }
  }
  
  
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_PLL3_DIVQ) == RCC_PERIPHCLK_PLL3_DIVQ)
 81084ea:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 81084ee:	e9d3 2300 	ldrd	r2, r3, [r3]
 81084f2:	2100      	movs	r1, #0
 81084f4:	60b9      	str	r1, [r7, #8]
 81084f6:	f003 0310 	and.w	r3, r3, #16
 81084fa:	60fb      	str	r3, [r7, #12]
 81084fc:	e9d7 1202 	ldrd	r1, r2, [r7, #8]
 8108500:	460b      	mov	r3, r1
 8108502:	4313      	orrs	r3, r2
 8108504:	d011      	beq.n	810852a <HAL_RCCEx_PeriphCLKConfig+0x13b6>
  {
    ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3), DIVIDER_Q_UPDATE);
 8108506:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 810850a:	3328      	adds	r3, #40	; 0x28
 810850c:	2101      	movs	r1, #1
 810850e:	4618      	mov	r0, r3
 8108510:	f001 fa7c 	bl	8109a0c <RCCEx_PLL3_Config>
 8108514:	4603      	mov	r3, r0
 8108516:	f887 3127 	strb.w	r3, [r7, #295]	; 0x127
    
    if (ret == HAL_OK)
 810851a:	f897 3127 	ldrb.w	r3, [r7, #295]	; 0x127
 810851e:	2b00      	cmp	r3, #0
 8108520:	d003      	beq.n	810852a <HAL_RCCEx_PeriphCLKConfig+0x13b6>
      /*Nothing to do*/
    }
    else
    {
      /* set overall return value */
      status = ret;
 8108522:	f897 3127 	ldrb.w	r3, [r7, #295]	; 0x127
 8108526:	f887 3126 	strb.w	r3, [r7, #294]	; 0x126
    }
  }
  
  
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_PLL3_DIVR) == RCC_PERIPHCLK_PLL3_DIVR)
 810852a:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 810852e:	e9d3 2300 	ldrd	r2, r3, [r3]
 8108532:	2100      	movs	r1, #0
 8108534:	6039      	str	r1, [r7, #0]
 8108536:	f003 0320 	and.w	r3, r3, #32
 810853a:	607b      	str	r3, [r7, #4]
 810853c:	e9d7 1200 	ldrd	r1, r2, [r7]
 8108540:	460b      	mov	r3, r1
 8108542:	4313      	orrs	r3, r2
 8108544:	d011      	beq.n	810856a <HAL_RCCEx_PeriphCLKConfig+0x13f6>
  {
    ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3), DIVIDER_R_UPDATE);
 8108546:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 810854a:	3328      	adds	r3, #40	; 0x28
 810854c:	2102      	movs	r1, #2
 810854e:	4618      	mov	r0, r3
 8108550:	f001 fa5c 	bl	8109a0c <RCCEx_PLL3_Config>
 8108554:	4603      	mov	r3, r0
 8108556:	f887 3127 	strb.w	r3, [r7, #295]	; 0x127
    
    if (ret == HAL_OK)
 810855a:	f897 3127 	ldrb.w	r3, [r7, #295]	; 0x127
 810855e:	2b00      	cmp	r3, #0
 8108560:	d003      	beq.n	810856a <HAL_RCCEx_PeriphCLKConfig+0x13f6>
      /*Nothing to do*/
    }
    else
    {
      /* set overall return value */
      status = ret;
 8108562:	f897 3127 	ldrb.w	r3, [r7, #295]	; 0x127
 8108566:	f887 3126 	strb.w	r3, [r7, #294]	; 0x126
    } 
  }

  if (status == HAL_OK)
 810856a:	f897 3126 	ldrb.w	r3, [r7, #294]	; 0x126
 810856e:	2b00      	cmp	r3, #0
 8108570:	d101      	bne.n	8108576 <HAL_RCCEx_PeriphCLKConfig+0x1402>
  {
    return HAL_OK;
 8108572:	2300      	movs	r3, #0
 8108574:	e000      	b.n	8108578 <HAL_RCCEx_PeriphCLKConfig+0x1404>
  }
  return HAL_ERROR;
 8108576:	2301      	movs	r3, #1
}
 8108578:	4618      	mov	r0, r3
 810857a:	f507 7794 	add.w	r7, r7, #296	; 0x128
 810857e:	46bd      	mov	sp, r7
 8108580:	e8bd 8fb0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, sl, fp, pc}
 8108584:	58024400 	.word	0x58024400

08108588 <HAL_RCCEx_GetPeriphCLKFreq>:
  * @retval Frequency in KHz
  *
  *  (*) : Available on some STM32H7 lines only.
  */
uint32_t HAL_RCCEx_GetPeriphCLKFreq(uint64_t PeriphClk)
{
 8108588:	b580      	push	{r7, lr}
 810858a:	b090      	sub	sp, #64	; 0x40
 810858c:	af00      	add	r7, sp, #0
 810858e:	e9c7 0100 	strd	r0, r1, [r7]
  /* This variable is used to store the SAI and CKP clock source */
  uint32_t saiclocksource;
  uint32_t ckpclocksource;
  uint32_t srcclk;

  if (PeriphClk == RCC_PERIPHCLK_SAI1)
 8108592:	e9d7 2300 	ldrd	r2, r3, [r7]
 8108596:	f5a2 7180 	sub.w	r1, r2, #256	; 0x100
 810859a:	430b      	orrs	r3, r1
 810859c:	f040 8094 	bne.w	81086c8 <HAL_RCCEx_GetPeriphCLKFreq+0x140>
  {

    saiclocksource = __HAL_RCC_GET_SAI1_SOURCE();
 81085a0:	4b9e      	ldr	r3, [pc, #632]	; (810881c <HAL_RCCEx_GetPeriphCLKFreq+0x294>)
 81085a2:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 81085a4:	f003 0307 	and.w	r3, r3, #7
 81085a8:	633b      	str	r3, [r7, #48]	; 0x30

    switch (saiclocksource)
 81085aa:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 81085ac:	2b04      	cmp	r3, #4
 81085ae:	f200 8087 	bhi.w	81086c0 <HAL_RCCEx_GetPeriphCLKFreq+0x138>
 81085b2:	a201      	add	r2, pc, #4	; (adr r2, 81085b8 <HAL_RCCEx_GetPeriphCLKFreq+0x30>)
 81085b4:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 81085b8:	081085cd 	.word	0x081085cd
 81085bc:	081085f5 	.word	0x081085f5
 81085c0:	0810861d 	.word	0x0810861d
 81085c4:	081086b9 	.word	0x081086b9
 81085c8:	08108645 	.word	0x08108645
    {
      case RCC_SAI1CLKSOURCE_PLL: /* PLL1 is the clock source for SAI1 */
      {
        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL1RDY))
 81085cc:	4b93      	ldr	r3, [pc, #588]	; (810881c <HAL_RCCEx_GetPeriphCLKFreq+0x294>)
 81085ce:	681b      	ldr	r3, [r3, #0]
 81085d0:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 81085d4:	f1b3 7f00 	cmp.w	r3, #33554432	; 0x2000000
 81085d8:	d108      	bne.n	81085ec <HAL_RCCEx_GetPeriphCLKFreq+0x64>
        {
          HAL_RCCEx_GetPLL1ClockFreq(&pll1_clocks);
 81085da:	f107 0324 	add.w	r3, r7, #36	; 0x24
 81085de:	4618      	mov	r0, r3
 81085e0:	f001 f810 	bl	8109604 <HAL_RCCEx_GetPLL1ClockFreq>
          frequency = pll1_clocks.PLL1_Q_Frequency;
 81085e4:	6abb      	ldr	r3, [r7, #40]	; 0x28
 81085e6:	63fb      	str	r3, [r7, #60]	; 0x3c
        }
        else
        {
          frequency = 0;
        }
        break;
 81085e8:	f000 bd45 	b.w	8109076 <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
          frequency = 0;
 81085ec:	2300      	movs	r3, #0
 81085ee:	63fb      	str	r3, [r7, #60]	; 0x3c
        break;
 81085f0:	f000 bd41 	b.w	8109076 <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
      }
      case RCC_SAI1CLKSOURCE_PLL2: /* PLL2 is the clock source for SAI1 */
      {
        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL2RDY))
 81085f4:	4b89      	ldr	r3, [pc, #548]	; (810881c <HAL_RCCEx_GetPeriphCLKFreq+0x294>)
 81085f6:	681b      	ldr	r3, [r3, #0]
 81085f8:	f003 6300 	and.w	r3, r3, #134217728	; 0x8000000
 81085fc:	f1b3 6f00 	cmp.w	r3, #134217728	; 0x8000000
 8108600:	d108      	bne.n	8108614 <HAL_RCCEx_GetPeriphCLKFreq+0x8c>
        {
          HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
 8108602:	f107 0318 	add.w	r3, r7, #24
 8108606:	4618      	mov	r0, r3
 8108608:	f000 fd54 	bl	81090b4 <HAL_RCCEx_GetPLL2ClockFreq>
          frequency = pll2_clocks.PLL2_P_Frequency;
 810860c:	69bb      	ldr	r3, [r7, #24]
 810860e:	63fb      	str	r3, [r7, #60]	; 0x3c
        }
        else
        {
          frequency = 0;
        }
        break;
 8108610:	f000 bd31 	b.w	8109076 <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
          frequency = 0;
 8108614:	2300      	movs	r3, #0
 8108616:	63fb      	str	r3, [r7, #60]	; 0x3c
        break;
 8108618:	f000 bd2d 	b.w	8109076 <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
      }

      case RCC_SAI1CLKSOURCE_PLL3: /* PLL3 is the clock source for SAI1 */
      {
        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL3RDY))
 810861c:	4b7f      	ldr	r3, [pc, #508]	; (810881c <HAL_RCCEx_GetPeriphCLKFreq+0x294>)
 810861e:	681b      	ldr	r3, [r3, #0]
 8108620:	f003 5300 	and.w	r3, r3, #536870912	; 0x20000000
 8108624:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
 8108628:	d108      	bne.n	810863c <HAL_RCCEx_GetPeriphCLKFreq+0xb4>
        {
          HAL_RCCEx_GetPLL3ClockFreq(&pll3_clocks);
 810862a:	f107 030c 	add.w	r3, r7, #12
 810862e:	4618      	mov	r0, r3
 8108630:	f000 fe94 	bl	810935c <HAL_RCCEx_GetPLL3ClockFreq>
          frequency = pll3_clocks.PLL3_P_Frequency;
 8108634:	68fb      	ldr	r3, [r7, #12]
 8108636:	63fb      	str	r3, [r7, #60]	; 0x3c
        }
        else
        {
          frequency = 0;
        }
        break;
 8108638:	f000 bd1d 	b.w	8109076 <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
          frequency = 0;
 810863c:	2300      	movs	r3, #0
 810863e:	63fb      	str	r3, [r7, #60]	; 0x3c
        break;
 8108640:	f000 bd19 	b.w	8109076 <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
      }

      case RCC_SAI1CLKSOURCE_CLKP: /* CKPER is the clock source for SAI1*/
      {

        ckpclocksource = __HAL_RCC_GET_CLKP_SOURCE();
 8108644:	4b75      	ldr	r3, [pc, #468]	; (810881c <HAL_RCCEx_GetPeriphCLKFreq+0x294>)
 8108646:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8108648:	f003 5340 	and.w	r3, r3, #805306368	; 0x30000000
 810864c:	637b      	str	r3, [r7, #52]	; 0x34

        if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY)) && (ckpclocksource == RCC_CLKPSOURCE_HSI))
 810864e:	4b73      	ldr	r3, [pc, #460]	; (810881c <HAL_RCCEx_GetPeriphCLKFreq+0x294>)
 8108650:	681b      	ldr	r3, [r3, #0]
 8108652:	f003 0304 	and.w	r3, r3, #4
 8108656:	2b04      	cmp	r3, #4
 8108658:	d10c      	bne.n	8108674 <HAL_RCCEx_GetPeriphCLKFreq+0xec>
 810865a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 810865c:	2b00      	cmp	r3, #0
 810865e:	d109      	bne.n	8108674 <HAL_RCCEx_GetPeriphCLKFreq+0xec>
        {
          /* In Case the CKPER Source is HSI */
          frequency = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> 3));
 8108660:	4b6e      	ldr	r3, [pc, #440]	; (810881c <HAL_RCCEx_GetPeriphCLKFreq+0x294>)
 8108662:	681b      	ldr	r3, [r3, #0]
 8108664:	08db      	lsrs	r3, r3, #3
 8108666:	f003 0303 	and.w	r3, r3, #3
 810866a:	4a6d      	ldr	r2, [pc, #436]	; (8108820 <HAL_RCCEx_GetPeriphCLKFreq+0x298>)
 810866c:	fa22 f303 	lsr.w	r3, r2, r3
 8108670:	63fb      	str	r3, [r7, #60]	; 0x3c
 8108672:	e01f      	b.n	81086b4 <HAL_RCCEx_GetPeriphCLKFreq+0x12c>
        }

        else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_CSIRDY)) && (ckpclocksource == RCC_CLKPSOURCE_CSI))
 8108674:	4b69      	ldr	r3, [pc, #420]	; (810881c <HAL_RCCEx_GetPeriphCLKFreq+0x294>)
 8108676:	681b      	ldr	r3, [r3, #0]
 8108678:	f403 7380 	and.w	r3, r3, #256	; 0x100
 810867c:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 8108680:	d106      	bne.n	8108690 <HAL_RCCEx_GetPeriphCLKFreq+0x108>
 8108682:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8108684:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
 8108688:	d102      	bne.n	8108690 <HAL_RCCEx_GetPeriphCLKFreq+0x108>
        {
          /* In Case the CKPER Source is CSI */
          frequency = CSI_VALUE;
 810868a:	4b66      	ldr	r3, [pc, #408]	; (8108824 <HAL_RCCEx_GetPeriphCLKFreq+0x29c>)
 810868c:	63fb      	str	r3, [r7, #60]	; 0x3c
 810868e:	e011      	b.n	81086b4 <HAL_RCCEx_GetPeriphCLKFreq+0x12c>
        }

        else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSERDY)) && (ckpclocksource == RCC_CLKPSOURCE_HSE))
 8108690:	4b62      	ldr	r3, [pc, #392]	; (810881c <HAL_RCCEx_GetPeriphCLKFreq+0x294>)
 8108692:	681b      	ldr	r3, [r3, #0]
 8108694:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 8108698:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
 810869c:	d106      	bne.n	81086ac <HAL_RCCEx_GetPeriphCLKFreq+0x124>
 810869e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 81086a0:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
 81086a4:	d102      	bne.n	81086ac <HAL_RCCEx_GetPeriphCLKFreq+0x124>
        {
          /* In Case the CKPER Source is HSE */
          frequency = HSE_VALUE;
 81086a6:	4b60      	ldr	r3, [pc, #384]	; (8108828 <HAL_RCCEx_GetPeriphCLKFreq+0x2a0>)
 81086a8:	63fb      	str	r3, [r7, #60]	; 0x3c
 81086aa:	e003      	b.n	81086b4 <HAL_RCCEx_GetPeriphCLKFreq+0x12c>
        }

        else
        {
          /* In Case the CKPER is disabled*/
          frequency = 0;
 81086ac:	2300      	movs	r3, #0
 81086ae:	63fb      	str	r3, [r7, #60]	; 0x3c
        }

        break;
 81086b0:	f000 bce1 	b.w	8109076 <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
 81086b4:	f000 bcdf 	b.w	8109076 <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
      }

      case (RCC_SAI1CLKSOURCE_PIN): /* External clock is the clock source for SAI1 */
      {
        frequency = EXTERNAL_CLOCK_VALUE;
 81086b8:	4b5c      	ldr	r3, [pc, #368]	; (810882c <HAL_RCCEx_GetPeriphCLKFreq+0x2a4>)
 81086ba:	63fb      	str	r3, [r7, #60]	; 0x3c
        break;
 81086bc:	f000 bcdb 	b.w	8109076 <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
      }
      default :
      {
        frequency = 0;
 81086c0:	2300      	movs	r3, #0
 81086c2:	63fb      	str	r3, [r7, #60]	; 0x3c
        break;
 81086c4:	f000 bcd7 	b.w	8109076 <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
      }
    }
  }

#if defined(SAI3)
  else if (PeriphClk == RCC_PERIPHCLK_SAI23)
 81086c8:	e9d7 2300 	ldrd	r2, r3, [r7]
 81086cc:	f5a2 7100 	sub.w	r1, r2, #512	; 0x200
 81086d0:	430b      	orrs	r3, r1
 81086d2:	f040 80ad 	bne.w	8108830 <HAL_RCCEx_GetPeriphCLKFreq+0x2a8>
  {

    saiclocksource = __HAL_RCC_GET_SAI23_SOURCE();
 81086d6:	4b51      	ldr	r3, [pc, #324]	; (810881c <HAL_RCCEx_GetPeriphCLKFreq+0x294>)
 81086d8:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 81086da:	f403 73e0 	and.w	r3, r3, #448	; 0x1c0
 81086de:	633b      	str	r3, [r7, #48]	; 0x30

    switch (saiclocksource)
 81086e0:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 81086e2:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 81086e6:	d056      	beq.n	8108796 <HAL_RCCEx_GetPeriphCLKFreq+0x20e>
 81086e8:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 81086ea:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 81086ee:	f200 8090 	bhi.w	8108812 <HAL_RCCEx_GetPeriphCLKFreq+0x28a>
 81086f2:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 81086f4:	2bc0      	cmp	r3, #192	; 0xc0
 81086f6:	f000 8088 	beq.w	810880a <HAL_RCCEx_GetPeriphCLKFreq+0x282>
 81086fa:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 81086fc:	2bc0      	cmp	r3, #192	; 0xc0
 81086fe:	f200 8088 	bhi.w	8108812 <HAL_RCCEx_GetPeriphCLKFreq+0x28a>
 8108702:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8108704:	2b80      	cmp	r3, #128	; 0x80
 8108706:	d032      	beq.n	810876e <HAL_RCCEx_GetPeriphCLKFreq+0x1e6>
 8108708:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 810870a:	2b80      	cmp	r3, #128	; 0x80
 810870c:	f200 8081 	bhi.w	8108812 <HAL_RCCEx_GetPeriphCLKFreq+0x28a>
 8108710:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8108712:	2b00      	cmp	r3, #0
 8108714:	d003      	beq.n	810871e <HAL_RCCEx_GetPeriphCLKFreq+0x196>
 8108716:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8108718:	2b40      	cmp	r3, #64	; 0x40
 810871a:	d014      	beq.n	8108746 <HAL_RCCEx_GetPeriphCLKFreq+0x1be>
 810871c:	e079      	b.n	8108812 <HAL_RCCEx_GetPeriphCLKFreq+0x28a>
    {
      case RCC_SAI23CLKSOURCE_PLL: /* PLL1 is the clock source for SAI2/3 */
      {
        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL1RDY))
 810871e:	4b3f      	ldr	r3, [pc, #252]	; (810881c <HAL_RCCEx_GetPeriphCLKFreq+0x294>)
 8108720:	681b      	ldr	r3, [r3, #0]
 8108722:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 8108726:	f1b3 7f00 	cmp.w	r3, #33554432	; 0x2000000
 810872a:	d108      	bne.n	810873e <HAL_RCCEx_GetPeriphCLKFreq+0x1b6>
        {
          HAL_RCCEx_GetPLL1ClockFreq(&pll1_clocks);
 810872c:	f107 0324 	add.w	r3, r7, #36	; 0x24
 8108730:	4618      	mov	r0, r3
 8108732:	f000 ff67 	bl	8109604 <HAL_RCCEx_GetPLL1ClockFreq>
          frequency = pll1_clocks.PLL1_Q_Frequency;
 8108736:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8108738:	63fb      	str	r3, [r7, #60]	; 0x3c
        }
        else
        {
          frequency = 0;
        }
        break;
 810873a:	f000 bc9c 	b.w	8109076 <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
          frequency = 0;
 810873e:	2300      	movs	r3, #0
 8108740:	63fb      	str	r3, [r7, #60]	; 0x3c
        break;
 8108742:	f000 bc98 	b.w	8109076 <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
      }
      case RCC_SAI23CLKSOURCE_PLL2: /* PLL2 is the clock source for SAI2/3 */
      {
        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL2RDY))
 8108746:	4b35      	ldr	r3, [pc, #212]	; (810881c <HAL_RCCEx_GetPeriphCLKFreq+0x294>)
 8108748:	681b      	ldr	r3, [r3, #0]
 810874a:	f003 6300 	and.w	r3, r3, #134217728	; 0x8000000
 810874e:	f1b3 6f00 	cmp.w	r3, #134217728	; 0x8000000
 8108752:	d108      	bne.n	8108766 <HAL_RCCEx_GetPeriphCLKFreq+0x1de>
        {
          HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
 8108754:	f107 0318 	add.w	r3, r7, #24
 8108758:	4618      	mov	r0, r3
 810875a:	f000 fcab 	bl	81090b4 <HAL_RCCEx_GetPLL2ClockFreq>
          frequency = pll2_clocks.PLL2_P_Frequency;
 810875e:	69bb      	ldr	r3, [r7, #24]
 8108760:	63fb      	str	r3, [r7, #60]	; 0x3c
        }
        else
        {
          frequency = 0;
        }
        break;
 8108762:	f000 bc88 	b.w	8109076 <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
          frequency = 0;
 8108766:	2300      	movs	r3, #0
 8108768:	63fb      	str	r3, [r7, #60]	; 0x3c
        break;
 810876a:	f000 bc84 	b.w	8109076 <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
      }

      case RCC_SAI23CLKSOURCE_PLL3: /* PLL3 is the clock source for SAI2/3 */
      {
        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL3RDY))
 810876e:	4b2b      	ldr	r3, [pc, #172]	; (810881c <HAL_RCCEx_GetPeriphCLKFreq+0x294>)
 8108770:	681b      	ldr	r3, [r3, #0]
 8108772:	f003 5300 	and.w	r3, r3, #536870912	; 0x20000000
 8108776:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
 810877a:	d108      	bne.n	810878e <HAL_RCCEx_GetPeriphCLKFreq+0x206>
        {
          HAL_RCCEx_GetPLL3ClockFreq(&pll3_clocks);
 810877c:	f107 030c 	add.w	r3, r7, #12
 8108780:	4618      	mov	r0, r3
 8108782:	f000 fdeb 	bl	810935c <HAL_RCCEx_GetPLL3ClockFreq>
          frequency = pll3_clocks.PLL3_P_Frequency;
 8108786:	68fb      	ldr	r3, [r7, #12]
 8108788:	63fb      	str	r3, [r7, #60]	; 0x3c
        }
        else
        {
          frequency = 0;
        }
        break;
 810878a:	f000 bc74 	b.w	8109076 <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
          frequency = 0;
 810878e:	2300      	movs	r3, #0
 8108790:	63fb      	str	r3, [r7, #60]	; 0x3c
        break;
 8108792:	f000 bc70 	b.w	8109076 <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
      }

      case RCC_SAI23CLKSOURCE_CLKP: /* CKPER is the clock source for SAI2/3 */
      {

        ckpclocksource = __HAL_RCC_GET_CLKP_SOURCE();
 8108796:	4b21      	ldr	r3, [pc, #132]	; (810881c <HAL_RCCEx_GetPeriphCLKFreq+0x294>)
 8108798:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 810879a:	f003 5340 	and.w	r3, r3, #805306368	; 0x30000000
 810879e:	637b      	str	r3, [r7, #52]	; 0x34

        if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY)) && (ckpclocksource == RCC_CLKPSOURCE_HSI))
 81087a0:	4b1e      	ldr	r3, [pc, #120]	; (810881c <HAL_RCCEx_GetPeriphCLKFreq+0x294>)
 81087a2:	681b      	ldr	r3, [r3, #0]
 81087a4:	f003 0304 	and.w	r3, r3, #4
 81087a8:	2b04      	cmp	r3, #4
 81087aa:	d10c      	bne.n	81087c6 <HAL_RCCEx_GetPeriphCLKFreq+0x23e>
 81087ac:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 81087ae:	2b00      	cmp	r3, #0
 81087b0:	d109      	bne.n	81087c6 <HAL_RCCEx_GetPeriphCLKFreq+0x23e>
        {
          /* In Case the CKPER Source is HSI */
          frequency = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> 3));
 81087b2:	4b1a      	ldr	r3, [pc, #104]	; (810881c <HAL_RCCEx_GetPeriphCLKFreq+0x294>)
 81087b4:	681b      	ldr	r3, [r3, #0]
 81087b6:	08db      	lsrs	r3, r3, #3
 81087b8:	f003 0303 	and.w	r3, r3, #3
 81087bc:	4a18      	ldr	r2, [pc, #96]	; (8108820 <HAL_RCCEx_GetPeriphCLKFreq+0x298>)
 81087be:	fa22 f303 	lsr.w	r3, r2, r3
 81087c2:	63fb      	str	r3, [r7, #60]	; 0x3c
 81087c4:	e01f      	b.n	8108806 <HAL_RCCEx_GetPeriphCLKFreq+0x27e>
        }

        else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_CSIRDY)) && (ckpclocksource == RCC_CLKPSOURCE_CSI))
 81087c6:	4b15      	ldr	r3, [pc, #84]	; (810881c <HAL_RCCEx_GetPeriphCLKFreq+0x294>)
 81087c8:	681b      	ldr	r3, [r3, #0]
 81087ca:	f403 7380 	and.w	r3, r3, #256	; 0x100
 81087ce:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 81087d2:	d106      	bne.n	81087e2 <HAL_RCCEx_GetPeriphCLKFreq+0x25a>
 81087d4:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 81087d6:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
 81087da:	d102      	bne.n	81087e2 <HAL_RCCEx_GetPeriphCLKFreq+0x25a>
        {
          /* In Case the CKPER Source is CSI */
          frequency = CSI_VALUE;
 81087dc:	4b11      	ldr	r3, [pc, #68]	; (8108824 <HAL_RCCEx_GetPeriphCLKFreq+0x29c>)
 81087de:	63fb      	str	r3, [r7, #60]	; 0x3c
 81087e0:	e011      	b.n	8108806 <HAL_RCCEx_GetPeriphCLKFreq+0x27e>
        }

        else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSERDY)) && (ckpclocksource == RCC_CLKPSOURCE_HSE))
 81087e2:	4b0e      	ldr	r3, [pc, #56]	; (810881c <HAL_RCCEx_GetPeriphCLKFreq+0x294>)
 81087e4:	681b      	ldr	r3, [r3, #0]
 81087e6:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 81087ea:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
 81087ee:	d106      	bne.n	81087fe <HAL_RCCEx_GetPeriphCLKFreq+0x276>
 81087f0:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 81087f2:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
 81087f6:	d102      	bne.n	81087fe <HAL_RCCEx_GetPeriphCLKFreq+0x276>
        {
          /* In Case the CKPER Source is HSE */
          frequency = HSE_VALUE;
 81087f8:	4b0b      	ldr	r3, [pc, #44]	; (8108828 <HAL_RCCEx_GetPeriphCLKFreq+0x2a0>)
 81087fa:	63fb      	str	r3, [r7, #60]	; 0x3c
 81087fc:	e003      	b.n	8108806 <HAL_RCCEx_GetPeriphCLKFreq+0x27e>
        }

        else
        {
          /* In Case the CKPER is disabled*/
          frequency = 0;
 81087fe:	2300      	movs	r3, #0
 8108800:	63fb      	str	r3, [r7, #60]	; 0x3c
        }

        break;
 8108802:	f000 bc38 	b.w	8109076 <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
 8108806:	f000 bc36 	b.w	8109076 <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
      }

      case (RCC_SAI23CLKSOURCE_PIN): /* External clock is the clock source for SAI2/3 */
      {
        frequency = EXTERNAL_CLOCK_VALUE;
 810880a:	4b08      	ldr	r3, [pc, #32]	; (810882c <HAL_RCCEx_GetPeriphCLKFreq+0x2a4>)
 810880c:	63fb      	str	r3, [r7, #60]	; 0x3c
        break;
 810880e:	f000 bc32 	b.w	8109076 <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
      }
      default :
      {
        frequency = 0;
 8108812:	2300      	movs	r3, #0
 8108814:	63fb      	str	r3, [r7, #60]	; 0x3c
        break;
 8108816:	f000 bc2e 	b.w	8109076 <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
 810881a:	bf00      	nop
 810881c:	58024400 	.word	0x58024400
 8108820:	03d09000 	.word	0x03d09000
 8108824:	003d0900 	.word	0x003d0900
 8108828:	017d7840 	.word	0x017d7840
 810882c:	00bb8000 	.word	0x00bb8000
    }
  }
#endif

#if defined(SAI4)
  else if (PeriphClk == RCC_PERIPHCLK_SAI4A)
 8108830:	e9d7 2300 	ldrd	r2, r3, [r7]
 8108834:	f5a2 6180 	sub.w	r1, r2, #1024	; 0x400
 8108838:	430b      	orrs	r3, r1
 810883a:	f040 809c 	bne.w	8108976 <HAL_RCCEx_GetPeriphCLKFreq+0x3ee>
  {

    saiclocksource = __HAL_RCC_GET_SAI4A_SOURCE();
 810883e:	4b9e      	ldr	r3, [pc, #632]	; (8108ab8 <HAL_RCCEx_GetPeriphCLKFreq+0x530>)
 8108840:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8108842:	f403 0360 	and.w	r3, r3, #14680064	; 0xe00000
 8108846:	633b      	str	r3, [r7, #48]	; 0x30

    switch (saiclocksource)
 8108848:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 810884a:	f5b3 0f00 	cmp.w	r3, #8388608	; 0x800000
 810884e:	d054      	beq.n	81088fa <HAL_RCCEx_GetPeriphCLKFreq+0x372>
 8108850:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8108852:	f5b3 0f00 	cmp.w	r3, #8388608	; 0x800000
 8108856:	f200 808b 	bhi.w	8108970 <HAL_RCCEx_GetPeriphCLKFreq+0x3e8>
 810885a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 810885c:	f5b3 0fc0 	cmp.w	r3, #6291456	; 0x600000
 8108860:	f000 8083 	beq.w	810896a <HAL_RCCEx_GetPeriphCLKFreq+0x3e2>
 8108864:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8108866:	f5b3 0fc0 	cmp.w	r3, #6291456	; 0x600000
 810886a:	f200 8081 	bhi.w	8108970 <HAL_RCCEx_GetPeriphCLKFreq+0x3e8>
 810886e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8108870:	f5b3 0f80 	cmp.w	r3, #4194304	; 0x400000
 8108874:	d02f      	beq.n	81088d6 <HAL_RCCEx_GetPeriphCLKFreq+0x34e>
 8108876:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8108878:	f5b3 0f80 	cmp.w	r3, #4194304	; 0x400000
 810887c:	d878      	bhi.n	8108970 <HAL_RCCEx_GetPeriphCLKFreq+0x3e8>
 810887e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8108880:	2b00      	cmp	r3, #0
 8108882:	d004      	beq.n	810888e <HAL_RCCEx_GetPeriphCLKFreq+0x306>
 8108884:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8108886:	f5b3 1f00 	cmp.w	r3, #2097152	; 0x200000
 810888a:	d012      	beq.n	81088b2 <HAL_RCCEx_GetPeriphCLKFreq+0x32a>
 810888c:	e070      	b.n	8108970 <HAL_RCCEx_GetPeriphCLKFreq+0x3e8>
    {
      case RCC_SAI4ACLKSOURCE_PLL: /* PLL1 is the clock source for SAI4A */
      {
        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL1RDY))
 810888e:	4b8a      	ldr	r3, [pc, #552]	; (8108ab8 <HAL_RCCEx_GetPeriphCLKFreq+0x530>)
 8108890:	681b      	ldr	r3, [r3, #0]
 8108892:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 8108896:	f1b3 7f00 	cmp.w	r3, #33554432	; 0x2000000
 810889a:	d107      	bne.n	81088ac <HAL_RCCEx_GetPeriphCLKFreq+0x324>
        {
          HAL_RCCEx_GetPLL1ClockFreq(&pll1_clocks);
 810889c:	f107 0324 	add.w	r3, r7, #36	; 0x24
 81088a0:	4618      	mov	r0, r3
 81088a2:	f000 feaf 	bl	8109604 <HAL_RCCEx_GetPLL1ClockFreq>
          frequency = pll1_clocks.PLL1_Q_Frequency;
 81088a6:	6abb      	ldr	r3, [r7, #40]	; 0x28
 81088a8:	63fb      	str	r3, [r7, #60]	; 0x3c
        }
        else
        {
          frequency = 0;
        }
        break;
 81088aa:	e3e4      	b.n	8109076 <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
          frequency = 0;
 81088ac:	2300      	movs	r3, #0
 81088ae:	63fb      	str	r3, [r7, #60]	; 0x3c
        break;
 81088b0:	e3e1      	b.n	8109076 <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
      }
      case RCC_SAI4ACLKSOURCE_PLL2: /* PLLI2 is the clock source for SAI4A */
      {
        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL2RDY))
 81088b2:	4b81      	ldr	r3, [pc, #516]	; (8108ab8 <HAL_RCCEx_GetPeriphCLKFreq+0x530>)
 81088b4:	681b      	ldr	r3, [r3, #0]
 81088b6:	f003 6300 	and.w	r3, r3, #134217728	; 0x8000000
 81088ba:	f1b3 6f00 	cmp.w	r3, #134217728	; 0x8000000
 81088be:	d107      	bne.n	81088d0 <HAL_RCCEx_GetPeriphCLKFreq+0x348>
        {
          HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
 81088c0:	f107 0318 	add.w	r3, r7, #24
 81088c4:	4618      	mov	r0, r3
 81088c6:	f000 fbf5 	bl	81090b4 <HAL_RCCEx_GetPLL2ClockFreq>
          frequency = pll2_clocks.PLL2_P_Frequency;
 81088ca:	69bb      	ldr	r3, [r7, #24]
 81088cc:	63fb      	str	r3, [r7, #60]	; 0x3c
        }
        else
        {
          frequency = 0;
        }
        break;
 81088ce:	e3d2      	b.n	8109076 <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
          frequency = 0;
 81088d0:	2300      	movs	r3, #0
 81088d2:	63fb      	str	r3, [r7, #60]	; 0x3c
        break;
 81088d4:	e3cf      	b.n	8109076 <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
      }

      case RCC_SAI4ACLKSOURCE_PLL3: /* PLLI3 is the clock source for SAI4A */
      {
        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL3RDY))
 81088d6:	4b78      	ldr	r3, [pc, #480]	; (8108ab8 <HAL_RCCEx_GetPeriphCLKFreq+0x530>)
 81088d8:	681b      	ldr	r3, [r3, #0]
 81088da:	f003 5300 	and.w	r3, r3, #536870912	; 0x20000000
 81088de:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
 81088e2:	d107      	bne.n	81088f4 <HAL_RCCEx_GetPeriphCLKFreq+0x36c>
        {
          HAL_RCCEx_GetPLL3ClockFreq(&pll3_clocks);
 81088e4:	f107 030c 	add.w	r3, r7, #12
 81088e8:	4618      	mov	r0, r3
 81088ea:	f000 fd37 	bl	810935c <HAL_RCCEx_GetPLL3ClockFreq>
          frequency = pll3_clocks.PLL3_P_Frequency;
 81088ee:	68fb      	ldr	r3, [r7, #12]
 81088f0:	63fb      	str	r3, [r7, #60]	; 0x3c
        }
        else
        {
          frequency = 0;
        }
        break;
 81088f2:	e3c0      	b.n	8109076 <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
          frequency = 0;
 81088f4:	2300      	movs	r3, #0
 81088f6:	63fb      	str	r3, [r7, #60]	; 0x3c
        break;
 81088f8:	e3bd      	b.n	8109076 <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
      }

      case RCC_SAI4ACLKSOURCE_CLKP: /* CKPER is the clock source for SAI4A*/
      {

        ckpclocksource = __HAL_RCC_GET_CLKP_SOURCE();
 81088fa:	4b6f      	ldr	r3, [pc, #444]	; (8108ab8 <HAL_RCCEx_GetPeriphCLKFreq+0x530>)
 81088fc:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 81088fe:	f003 5340 	and.w	r3, r3, #805306368	; 0x30000000
 8108902:	637b      	str	r3, [r7, #52]	; 0x34

        if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY)) && (ckpclocksource == RCC_CLKPSOURCE_HSI))
 8108904:	4b6c      	ldr	r3, [pc, #432]	; (8108ab8 <HAL_RCCEx_GetPeriphCLKFreq+0x530>)
 8108906:	681b      	ldr	r3, [r3, #0]
 8108908:	f003 0304 	and.w	r3, r3, #4
 810890c:	2b04      	cmp	r3, #4
 810890e:	d10c      	bne.n	810892a <HAL_RCCEx_GetPeriphCLKFreq+0x3a2>
 8108910:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8108912:	2b00      	cmp	r3, #0
 8108914:	d109      	bne.n	810892a <HAL_RCCEx_GetPeriphCLKFreq+0x3a2>
        {
          /* In Case the CKPER Source is HSI */
          frequency = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> 3));
 8108916:	4b68      	ldr	r3, [pc, #416]	; (8108ab8 <HAL_RCCEx_GetPeriphCLKFreq+0x530>)
 8108918:	681b      	ldr	r3, [r3, #0]
 810891a:	08db      	lsrs	r3, r3, #3
 810891c:	f003 0303 	and.w	r3, r3, #3
 8108920:	4a66      	ldr	r2, [pc, #408]	; (8108abc <HAL_RCCEx_GetPeriphCLKFreq+0x534>)
 8108922:	fa22 f303 	lsr.w	r3, r2, r3
 8108926:	63fb      	str	r3, [r7, #60]	; 0x3c
 8108928:	e01e      	b.n	8108968 <HAL_RCCEx_GetPeriphCLKFreq+0x3e0>
        }

        else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_CSIRDY)) && (ckpclocksource == RCC_CLKPSOURCE_CSI))
 810892a:	4b63      	ldr	r3, [pc, #396]	; (8108ab8 <HAL_RCCEx_GetPeriphCLKFreq+0x530>)
 810892c:	681b      	ldr	r3, [r3, #0]
 810892e:	f403 7380 	and.w	r3, r3, #256	; 0x100
 8108932:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 8108936:	d106      	bne.n	8108946 <HAL_RCCEx_GetPeriphCLKFreq+0x3be>
 8108938:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 810893a:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
 810893e:	d102      	bne.n	8108946 <HAL_RCCEx_GetPeriphCLKFreq+0x3be>
        {
          /* In Case the CKPER Source is CSI */
          frequency = CSI_VALUE;
 8108940:	4b5f      	ldr	r3, [pc, #380]	; (8108ac0 <HAL_RCCEx_GetPeriphCLKFreq+0x538>)
 8108942:	63fb      	str	r3, [r7, #60]	; 0x3c
 8108944:	e010      	b.n	8108968 <HAL_RCCEx_GetPeriphCLKFreq+0x3e0>
        }

        else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSERDY)) && (ckpclocksource == RCC_CLKPSOURCE_HSE))
 8108946:	4b5c      	ldr	r3, [pc, #368]	; (8108ab8 <HAL_RCCEx_GetPeriphCLKFreq+0x530>)
 8108948:	681b      	ldr	r3, [r3, #0]
 810894a:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 810894e:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
 8108952:	d106      	bne.n	8108962 <HAL_RCCEx_GetPeriphCLKFreq+0x3da>
 8108954:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8108956:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
 810895a:	d102      	bne.n	8108962 <HAL_RCCEx_GetPeriphCLKFreq+0x3da>
        {
          /* In Case the CKPER Source is HSE */
          frequency = HSE_VALUE;
 810895c:	4b59      	ldr	r3, [pc, #356]	; (8108ac4 <HAL_RCCEx_GetPeriphCLKFreq+0x53c>)
 810895e:	63fb      	str	r3, [r7, #60]	; 0x3c
 8108960:	e002      	b.n	8108968 <HAL_RCCEx_GetPeriphCLKFreq+0x3e0>
        }

        else
        {
          /* In Case the CKPER is disabled*/
          frequency = 0;
 8108962:	2300      	movs	r3, #0
 8108964:	63fb      	str	r3, [r7, #60]	; 0x3c
        }

        break;
 8108966:	e386      	b.n	8109076 <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
 8108968:	e385      	b.n	8109076 <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
      }

      case RCC_SAI4ACLKSOURCE_PIN: /* External clock is the clock source for SAI4A */
      {
        frequency = EXTERNAL_CLOCK_VALUE;
 810896a:	4b57      	ldr	r3, [pc, #348]	; (8108ac8 <HAL_RCCEx_GetPeriphCLKFreq+0x540>)
 810896c:	63fb      	str	r3, [r7, #60]	; 0x3c
        break;
 810896e:	e382      	b.n	8109076 <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
      }

      default :
      {
        frequency = 0;
 8108970:	2300      	movs	r3, #0
 8108972:	63fb      	str	r3, [r7, #60]	; 0x3c
        break;
 8108974:	e37f      	b.n	8109076 <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
      }
    }
  }

  else if (PeriphClk == RCC_PERIPHCLK_SAI4B)
 8108976:	e9d7 2300 	ldrd	r2, r3, [r7]
 810897a:	f5a2 6100 	sub.w	r1, r2, #2048	; 0x800
 810897e:	430b      	orrs	r3, r1
 8108980:	f040 80a7 	bne.w	8108ad2 <HAL_RCCEx_GetPeriphCLKFreq+0x54a>
  {

    saiclocksource = __HAL_RCC_GET_SAI4B_SOURCE();
 8108984:	4b4c      	ldr	r3, [pc, #304]	; (8108ab8 <HAL_RCCEx_GetPeriphCLKFreq+0x530>)
 8108986:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8108988:	f003 63e0 	and.w	r3, r3, #117440512	; 0x7000000
 810898c:	633b      	str	r3, [r7, #48]	; 0x30

    switch (saiclocksource)
 810898e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8108990:	f1b3 6f80 	cmp.w	r3, #67108864	; 0x4000000
 8108994:	d055      	beq.n	8108a42 <HAL_RCCEx_GetPeriphCLKFreq+0x4ba>
 8108996:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8108998:	f1b3 6f80 	cmp.w	r3, #67108864	; 0x4000000
 810899c:	f200 8096 	bhi.w	8108acc <HAL_RCCEx_GetPeriphCLKFreq+0x544>
 81089a0:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 81089a2:	f1b3 7f40 	cmp.w	r3, #50331648	; 0x3000000
 81089a6:	f000 8084 	beq.w	8108ab2 <HAL_RCCEx_GetPeriphCLKFreq+0x52a>
 81089aa:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 81089ac:	f1b3 7f40 	cmp.w	r3, #50331648	; 0x3000000
 81089b0:	f200 808c 	bhi.w	8108acc <HAL_RCCEx_GetPeriphCLKFreq+0x544>
 81089b4:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 81089b6:	f1b3 7f00 	cmp.w	r3, #33554432	; 0x2000000
 81089ba:	d030      	beq.n	8108a1e <HAL_RCCEx_GetPeriphCLKFreq+0x496>
 81089bc:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 81089be:	f1b3 7f00 	cmp.w	r3, #33554432	; 0x2000000
 81089c2:	f200 8083 	bhi.w	8108acc <HAL_RCCEx_GetPeriphCLKFreq+0x544>
 81089c6:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 81089c8:	2b00      	cmp	r3, #0
 81089ca:	d004      	beq.n	81089d6 <HAL_RCCEx_GetPeriphCLKFreq+0x44e>
 81089cc:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 81089ce:	f1b3 7f80 	cmp.w	r3, #16777216	; 0x1000000
 81089d2:	d012      	beq.n	81089fa <HAL_RCCEx_GetPeriphCLKFreq+0x472>
 81089d4:	e07a      	b.n	8108acc <HAL_RCCEx_GetPeriphCLKFreq+0x544>
    {
      case RCC_SAI4BCLKSOURCE_PLL: /* PLL1 is the clock source for SAI4B */
      {
        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL1RDY))
 81089d6:	4b38      	ldr	r3, [pc, #224]	; (8108ab8 <HAL_RCCEx_GetPeriphCLKFreq+0x530>)
 81089d8:	681b      	ldr	r3, [r3, #0]
 81089da:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 81089de:	f1b3 7f00 	cmp.w	r3, #33554432	; 0x2000000
 81089e2:	d107      	bne.n	81089f4 <HAL_RCCEx_GetPeriphCLKFreq+0x46c>
        {
          HAL_RCCEx_GetPLL1ClockFreq(&pll1_clocks);
 81089e4:	f107 0324 	add.w	r3, r7, #36	; 0x24
 81089e8:	4618      	mov	r0, r3
 81089ea:	f000 fe0b 	bl	8109604 <HAL_RCCEx_GetPLL1ClockFreq>
          frequency = pll1_clocks.PLL1_Q_Frequency;
 81089ee:	6abb      	ldr	r3, [r7, #40]	; 0x28
 81089f0:	63fb      	str	r3, [r7, #60]	; 0x3c
        }
        else
        {
          frequency = 0;
        }
        break;
 81089f2:	e340      	b.n	8109076 <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
          frequency = 0;
 81089f4:	2300      	movs	r3, #0
 81089f6:	63fb      	str	r3, [r7, #60]	; 0x3c
        break;
 81089f8:	e33d      	b.n	8109076 <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
      }
      case RCC_SAI4BCLKSOURCE_PLL2: /* PLLI2 is the clock source for SAI4B */
      {
        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL2RDY))
 81089fa:	4b2f      	ldr	r3, [pc, #188]	; (8108ab8 <HAL_RCCEx_GetPeriphCLKFreq+0x530>)
 81089fc:	681b      	ldr	r3, [r3, #0]
 81089fe:	f003 6300 	and.w	r3, r3, #134217728	; 0x8000000
 8108a02:	f1b3 6f00 	cmp.w	r3, #134217728	; 0x8000000
 8108a06:	d107      	bne.n	8108a18 <HAL_RCCEx_GetPeriphCLKFreq+0x490>
        {
          HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
 8108a08:	f107 0318 	add.w	r3, r7, #24
 8108a0c:	4618      	mov	r0, r3
 8108a0e:	f000 fb51 	bl	81090b4 <HAL_RCCEx_GetPLL2ClockFreq>
          frequency = pll2_clocks.PLL2_P_Frequency;
 8108a12:	69bb      	ldr	r3, [r7, #24]
 8108a14:	63fb      	str	r3, [r7, #60]	; 0x3c
        }
        else
        {
          frequency = 0;
        }
        break;
 8108a16:	e32e      	b.n	8109076 <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
          frequency = 0;
 8108a18:	2300      	movs	r3, #0
 8108a1a:	63fb      	str	r3, [r7, #60]	; 0x3c
        break;
 8108a1c:	e32b      	b.n	8109076 <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
      }

      case RCC_SAI4BCLKSOURCE_PLL3: /* PLLI3 is the clock source for SAI4B */
      {
        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL3RDY))
 8108a1e:	4b26      	ldr	r3, [pc, #152]	; (8108ab8 <HAL_RCCEx_GetPeriphCLKFreq+0x530>)
 8108a20:	681b      	ldr	r3, [r3, #0]
 8108a22:	f003 5300 	and.w	r3, r3, #536870912	; 0x20000000
 8108a26:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
 8108a2a:	d107      	bne.n	8108a3c <HAL_RCCEx_GetPeriphCLKFreq+0x4b4>
        {
          HAL_RCCEx_GetPLL3ClockFreq(&pll3_clocks);
 8108a2c:	f107 030c 	add.w	r3, r7, #12
 8108a30:	4618      	mov	r0, r3
 8108a32:	f000 fc93 	bl	810935c <HAL_RCCEx_GetPLL3ClockFreq>
          frequency = pll3_clocks.PLL3_P_Frequency;
 8108a36:	68fb      	ldr	r3, [r7, #12]
 8108a38:	63fb      	str	r3, [r7, #60]	; 0x3c
        }
        else
        {
          frequency = 0;
        }
        break;
 8108a3a:	e31c      	b.n	8109076 <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
          frequency = 0;
 8108a3c:	2300      	movs	r3, #0
 8108a3e:	63fb      	str	r3, [r7, #60]	; 0x3c
        break;
 8108a40:	e319      	b.n	8109076 <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
      }

      case RCC_SAI4BCLKSOURCE_CLKP: /* CKPER is the clock source for SAI4B*/
      {

        ckpclocksource = __HAL_RCC_GET_CLKP_SOURCE();
 8108a42:	4b1d      	ldr	r3, [pc, #116]	; (8108ab8 <HAL_RCCEx_GetPeriphCLKFreq+0x530>)
 8108a44:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8108a46:	f003 5340 	and.w	r3, r3, #805306368	; 0x30000000
 8108a4a:	637b      	str	r3, [r7, #52]	; 0x34

        if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY)) && (ckpclocksource == RCC_CLKPSOURCE_HSI))
 8108a4c:	4b1a      	ldr	r3, [pc, #104]	; (8108ab8 <HAL_RCCEx_GetPeriphCLKFreq+0x530>)
 8108a4e:	681b      	ldr	r3, [r3, #0]
 8108a50:	f003 0304 	and.w	r3, r3, #4
 8108a54:	2b04      	cmp	r3, #4
 8108a56:	d10c      	bne.n	8108a72 <HAL_RCCEx_GetPeriphCLKFreq+0x4ea>
 8108a58:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8108a5a:	2b00      	cmp	r3, #0
 8108a5c:	d109      	bne.n	8108a72 <HAL_RCCEx_GetPeriphCLKFreq+0x4ea>
        {
          /* In Case the CKPER Source is HSI */
          frequency = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> 3));
 8108a5e:	4b16      	ldr	r3, [pc, #88]	; (8108ab8 <HAL_RCCEx_GetPeriphCLKFreq+0x530>)
 8108a60:	681b      	ldr	r3, [r3, #0]
 8108a62:	08db      	lsrs	r3, r3, #3
 8108a64:	f003 0303 	and.w	r3, r3, #3
 8108a68:	4a14      	ldr	r2, [pc, #80]	; (8108abc <HAL_RCCEx_GetPeriphCLKFreq+0x534>)
 8108a6a:	fa22 f303 	lsr.w	r3, r2, r3
 8108a6e:	63fb      	str	r3, [r7, #60]	; 0x3c
 8108a70:	e01e      	b.n	8108ab0 <HAL_RCCEx_GetPeriphCLKFreq+0x528>
        }

        else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_CSIRDY)) && (ckpclocksource == RCC_CLKPSOURCE_CSI))
 8108a72:	4b11      	ldr	r3, [pc, #68]	; (8108ab8 <HAL_RCCEx_GetPeriphCLKFreq+0x530>)
 8108a74:	681b      	ldr	r3, [r3, #0]
 8108a76:	f403 7380 	and.w	r3, r3, #256	; 0x100
 8108a7a:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 8108a7e:	d106      	bne.n	8108a8e <HAL_RCCEx_GetPeriphCLKFreq+0x506>
 8108a80:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8108a82:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
 8108a86:	d102      	bne.n	8108a8e <HAL_RCCEx_GetPeriphCLKFreq+0x506>
        {
          /* In Case the CKPER Source is CSI */
          frequency = CSI_VALUE;
 8108a88:	4b0d      	ldr	r3, [pc, #52]	; (8108ac0 <HAL_RCCEx_GetPeriphCLKFreq+0x538>)
 8108a8a:	63fb      	str	r3, [r7, #60]	; 0x3c
 8108a8c:	e010      	b.n	8108ab0 <HAL_RCCEx_GetPeriphCLKFreq+0x528>
        }

        else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSERDY)) && (ckpclocksource == RCC_CLKPSOURCE_HSE))
 8108a8e:	4b0a      	ldr	r3, [pc, #40]	; (8108ab8 <HAL_RCCEx_GetPeriphCLKFreq+0x530>)
 8108a90:	681b      	ldr	r3, [r3, #0]
 8108a92:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 8108a96:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
 8108a9a:	d106      	bne.n	8108aaa <HAL_RCCEx_GetPeriphCLKFreq+0x522>
 8108a9c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8108a9e:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
 8108aa2:	d102      	bne.n	8108aaa <HAL_RCCEx_GetPeriphCLKFreq+0x522>
        {
          /* In Case the CKPER Source is HSE */
          frequency = HSE_VALUE;
 8108aa4:	4b07      	ldr	r3, [pc, #28]	; (8108ac4 <HAL_RCCEx_GetPeriphCLKFreq+0x53c>)
 8108aa6:	63fb      	str	r3, [r7, #60]	; 0x3c
 8108aa8:	e002      	b.n	8108ab0 <HAL_RCCEx_GetPeriphCLKFreq+0x528>
        }

        else
        {
          /* In Case the CKPER is disabled*/
          frequency = 0;
 8108aaa:	2300      	movs	r3, #0
 8108aac:	63fb      	str	r3, [r7, #60]	; 0x3c
        }

        break;
 8108aae:	e2e2      	b.n	8109076 <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
 8108ab0:	e2e1      	b.n	8109076 <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
      }

      case RCC_SAI4BCLKSOURCE_PIN: /* External clock is the clock source for SAI4B */
      {
        frequency = EXTERNAL_CLOCK_VALUE;
 8108ab2:	4b05      	ldr	r3, [pc, #20]	; (8108ac8 <HAL_RCCEx_GetPeriphCLKFreq+0x540>)
 8108ab4:	63fb      	str	r3, [r7, #60]	; 0x3c
        break;
 8108ab6:	e2de      	b.n	8109076 <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
 8108ab8:	58024400 	.word	0x58024400
 8108abc:	03d09000 	.word	0x03d09000
 8108ac0:	003d0900 	.word	0x003d0900
 8108ac4:	017d7840 	.word	0x017d7840
 8108ac8:	00bb8000 	.word	0x00bb8000
      }

      default :
      {
        frequency = 0;
 8108acc:	2300      	movs	r3, #0
 8108ace:	63fb      	str	r3, [r7, #60]	; 0x3c
        break;
 8108ad0:	e2d1      	b.n	8109076 <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
      }
    }
  }
#endif /*SAI4*/
  else if (PeriphClk == RCC_PERIPHCLK_SPI123)
 8108ad2:	e9d7 2300 	ldrd	r2, r3, [r7]
 8108ad6:	f5a2 5180 	sub.w	r1, r2, #4096	; 0x1000
 8108ada:	430b      	orrs	r3, r1
 8108adc:	f040 809c 	bne.w	8108c18 <HAL_RCCEx_GetPeriphCLKFreq+0x690>
  {
    /* Get SPI1/2/3 clock source */
    srcclk = __HAL_RCC_GET_SPI123_SOURCE();
 8108ae0:	4b93      	ldr	r3, [pc, #588]	; (8108d30 <HAL_RCCEx_GetPeriphCLKFreq+0x7a8>)
 8108ae2:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8108ae4:	f403 43e0 	and.w	r3, r3, #28672	; 0x7000
 8108ae8:	63bb      	str	r3, [r7, #56]	; 0x38

    switch (srcclk)
 8108aea:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8108aec:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
 8108af0:	d054      	beq.n	8108b9c <HAL_RCCEx_GetPeriphCLKFreq+0x614>
 8108af2:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8108af4:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
 8108af8:	f200 808b 	bhi.w	8108c12 <HAL_RCCEx_GetPeriphCLKFreq+0x68a>
 8108afc:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8108afe:	f5b3 5f40 	cmp.w	r3, #12288	; 0x3000
 8108b02:	f000 8083 	beq.w	8108c0c <HAL_RCCEx_GetPeriphCLKFreq+0x684>
 8108b06:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8108b08:	f5b3 5f40 	cmp.w	r3, #12288	; 0x3000
 8108b0c:	f200 8081 	bhi.w	8108c12 <HAL_RCCEx_GetPeriphCLKFreq+0x68a>
 8108b10:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8108b12:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
 8108b16:	d02f      	beq.n	8108b78 <HAL_RCCEx_GetPeriphCLKFreq+0x5f0>
 8108b18:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8108b1a:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
 8108b1e:	d878      	bhi.n	8108c12 <HAL_RCCEx_GetPeriphCLKFreq+0x68a>
 8108b20:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8108b22:	2b00      	cmp	r3, #0
 8108b24:	d004      	beq.n	8108b30 <HAL_RCCEx_GetPeriphCLKFreq+0x5a8>
 8108b26:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8108b28:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
 8108b2c:	d012      	beq.n	8108b54 <HAL_RCCEx_GetPeriphCLKFreq+0x5cc>
 8108b2e:	e070      	b.n	8108c12 <HAL_RCCEx_GetPeriphCLKFreq+0x68a>
    {
      case RCC_SPI123CLKSOURCE_PLL: /* PLL1 is the clock source for SPI123 */
      {
        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL1RDY))
 8108b30:	4b7f      	ldr	r3, [pc, #508]	; (8108d30 <HAL_RCCEx_GetPeriphCLKFreq+0x7a8>)
 8108b32:	681b      	ldr	r3, [r3, #0]
 8108b34:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 8108b38:	f1b3 7f00 	cmp.w	r3, #33554432	; 0x2000000
 8108b3c:	d107      	bne.n	8108b4e <HAL_RCCEx_GetPeriphCLKFreq+0x5c6>
        {
          HAL_RCCEx_GetPLL1ClockFreq(&pll1_clocks);
 8108b3e:	f107 0324 	add.w	r3, r7, #36	; 0x24
 8108b42:	4618      	mov	r0, r3
 8108b44:	f000 fd5e 	bl	8109604 <HAL_RCCEx_GetPLL1ClockFreq>
          frequency = pll1_clocks.PLL1_Q_Frequency;
 8108b48:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8108b4a:	63fb      	str	r3, [r7, #60]	; 0x3c
        }
        else
        {
          frequency = 0;
        }
        break;
 8108b4c:	e293      	b.n	8109076 <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
          frequency = 0;
 8108b4e:	2300      	movs	r3, #0
 8108b50:	63fb      	str	r3, [r7, #60]	; 0x3c
        break;
 8108b52:	e290      	b.n	8109076 <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
      }
      case RCC_SPI123CLKSOURCE_PLL2: /* PLL2 is the clock source for SPI123 */
      {
        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL2RDY))
 8108b54:	4b76      	ldr	r3, [pc, #472]	; (8108d30 <HAL_RCCEx_GetPeriphCLKFreq+0x7a8>)
 8108b56:	681b      	ldr	r3, [r3, #0]
 8108b58:	f003 6300 	and.w	r3, r3, #134217728	; 0x8000000
 8108b5c:	f1b3 6f00 	cmp.w	r3, #134217728	; 0x8000000
 8108b60:	d107      	bne.n	8108b72 <HAL_RCCEx_GetPeriphCLKFreq+0x5ea>
        {
          HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
 8108b62:	f107 0318 	add.w	r3, r7, #24
 8108b66:	4618      	mov	r0, r3
 8108b68:	f000 faa4 	bl	81090b4 <HAL_RCCEx_GetPLL2ClockFreq>
          frequency = pll2_clocks.PLL2_P_Frequency;
 8108b6c:	69bb      	ldr	r3, [r7, #24]
 8108b6e:	63fb      	str	r3, [r7, #60]	; 0x3c
        }
        else
        {
          frequency = 0;
        }
        break;
 8108b70:	e281      	b.n	8109076 <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
          frequency = 0;
 8108b72:	2300      	movs	r3, #0
 8108b74:	63fb      	str	r3, [r7, #60]	; 0x3c
        break;
 8108b76:	e27e      	b.n	8109076 <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
      }

      case RCC_SPI123CLKSOURCE_PLL3: /* PLL3 is the clock source for SPI123 */
      {
        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL3RDY))
 8108b78:	4b6d      	ldr	r3, [pc, #436]	; (8108d30 <HAL_RCCEx_GetPeriphCLKFreq+0x7a8>)
 8108b7a:	681b      	ldr	r3, [r3, #0]
 8108b7c:	f003 5300 	and.w	r3, r3, #536870912	; 0x20000000
 8108b80:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
 8108b84:	d107      	bne.n	8108b96 <HAL_RCCEx_GetPeriphCLKFreq+0x60e>
        {
          HAL_RCCEx_GetPLL3ClockFreq(&pll3_clocks);
 8108b86:	f107 030c 	add.w	r3, r7, #12
 8108b8a:	4618      	mov	r0, r3
 8108b8c:	f000 fbe6 	bl	810935c <HAL_RCCEx_GetPLL3ClockFreq>
          frequency = pll3_clocks.PLL3_P_Frequency;
 8108b90:	68fb      	ldr	r3, [r7, #12]
 8108b92:	63fb      	str	r3, [r7, #60]	; 0x3c
        }
        else
        {
          frequency = 0;
        }
        break;
 8108b94:	e26f      	b.n	8109076 <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
          frequency = 0;
 8108b96:	2300      	movs	r3, #0
 8108b98:	63fb      	str	r3, [r7, #60]	; 0x3c
        break;
 8108b9a:	e26c      	b.n	8109076 <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
      }

      case RCC_SPI123CLKSOURCE_CLKP: /* CKPER is the clock source for SPI123 */
      {

        ckpclocksource = __HAL_RCC_GET_CLKP_SOURCE();
 8108b9c:	4b64      	ldr	r3, [pc, #400]	; (8108d30 <HAL_RCCEx_GetPeriphCLKFreq+0x7a8>)
 8108b9e:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8108ba0:	f003 5340 	and.w	r3, r3, #805306368	; 0x30000000
 8108ba4:	637b      	str	r3, [r7, #52]	; 0x34

        if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY)) && (ckpclocksource == RCC_CLKPSOURCE_HSI))
 8108ba6:	4b62      	ldr	r3, [pc, #392]	; (8108d30 <HAL_RCCEx_GetPeriphCLKFreq+0x7a8>)
 8108ba8:	681b      	ldr	r3, [r3, #0]
 8108baa:	f003 0304 	and.w	r3, r3, #4
 8108bae:	2b04      	cmp	r3, #4
 8108bb0:	d10c      	bne.n	8108bcc <HAL_RCCEx_GetPeriphCLKFreq+0x644>
 8108bb2:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8108bb4:	2b00      	cmp	r3, #0
 8108bb6:	d109      	bne.n	8108bcc <HAL_RCCEx_GetPeriphCLKFreq+0x644>
        {
          /* In Case the CKPER Source is HSI */
          frequency = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> 3));
 8108bb8:	4b5d      	ldr	r3, [pc, #372]	; (8108d30 <HAL_RCCEx_GetPeriphCLKFreq+0x7a8>)
 8108bba:	681b      	ldr	r3, [r3, #0]
 8108bbc:	08db      	lsrs	r3, r3, #3
 8108bbe:	f003 0303 	and.w	r3, r3, #3
 8108bc2:	4a5c      	ldr	r2, [pc, #368]	; (8108d34 <HAL_RCCEx_GetPeriphCLKFreq+0x7ac>)
 8108bc4:	fa22 f303 	lsr.w	r3, r2, r3
 8108bc8:	63fb      	str	r3, [r7, #60]	; 0x3c
 8108bca:	e01e      	b.n	8108c0a <HAL_RCCEx_GetPeriphCLKFreq+0x682>
        }

        else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_CSIRDY)) && (ckpclocksource == RCC_CLKPSOURCE_CSI))
 8108bcc:	4b58      	ldr	r3, [pc, #352]	; (8108d30 <HAL_RCCEx_GetPeriphCLKFreq+0x7a8>)
 8108bce:	681b      	ldr	r3, [r3, #0]
 8108bd0:	f403 7380 	and.w	r3, r3, #256	; 0x100
 8108bd4:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 8108bd8:	d106      	bne.n	8108be8 <HAL_RCCEx_GetPeriphCLKFreq+0x660>
 8108bda:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8108bdc:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
 8108be0:	d102      	bne.n	8108be8 <HAL_RCCEx_GetPeriphCLKFreq+0x660>
        {
          /* In Case the CKPER Source is CSI */
          frequency = CSI_VALUE;
 8108be2:	4b55      	ldr	r3, [pc, #340]	; (8108d38 <HAL_RCCEx_GetPeriphCLKFreq+0x7b0>)
 8108be4:	63fb      	str	r3, [r7, #60]	; 0x3c
 8108be6:	e010      	b.n	8108c0a <HAL_RCCEx_GetPeriphCLKFreq+0x682>
        }

        else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSERDY)) && (ckpclocksource == RCC_CLKPSOURCE_HSE))
 8108be8:	4b51      	ldr	r3, [pc, #324]	; (8108d30 <HAL_RCCEx_GetPeriphCLKFreq+0x7a8>)
 8108bea:	681b      	ldr	r3, [r3, #0]
 8108bec:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 8108bf0:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
 8108bf4:	d106      	bne.n	8108c04 <HAL_RCCEx_GetPeriphCLKFreq+0x67c>
 8108bf6:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8108bf8:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
 8108bfc:	d102      	bne.n	8108c04 <HAL_RCCEx_GetPeriphCLKFreq+0x67c>
        {
          /* In Case the CKPER Source is HSE */
          frequency = HSE_VALUE;
 8108bfe:	4b4f      	ldr	r3, [pc, #316]	; (8108d3c <HAL_RCCEx_GetPeriphCLKFreq+0x7b4>)
 8108c00:	63fb      	str	r3, [r7, #60]	; 0x3c
 8108c02:	e002      	b.n	8108c0a <HAL_RCCEx_GetPeriphCLKFreq+0x682>
        }

        else
        {
          /* In Case the CKPER is disabled*/
          frequency = 0;
 8108c04:	2300      	movs	r3, #0
 8108c06:	63fb      	str	r3, [r7, #60]	; 0x3c
        }

        break;
 8108c08:	e235      	b.n	8109076 <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
 8108c0a:	e234      	b.n	8109076 <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
      }

      case (RCC_SPI123CLKSOURCE_PIN): /* External clock is the clock source for I2S */
      {
        frequency = EXTERNAL_CLOCK_VALUE;
 8108c0c:	4b4c      	ldr	r3, [pc, #304]	; (8108d40 <HAL_RCCEx_GetPeriphCLKFreq+0x7b8>)
 8108c0e:	63fb      	str	r3, [r7, #60]	; 0x3c
        break;
 8108c10:	e231      	b.n	8109076 <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
      }
      default :
      {
        frequency = 0;
 8108c12:	2300      	movs	r3, #0
 8108c14:	63fb      	str	r3, [r7, #60]	; 0x3c
        break;
 8108c16:	e22e      	b.n	8109076 <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
      }
    }
  }
  else if (PeriphClk == RCC_PERIPHCLK_SPI45)
 8108c18:	e9d7 2300 	ldrd	r2, r3, [r7]
 8108c1c:	f5a2 5100 	sub.w	r1, r2, #8192	; 0x2000
 8108c20:	430b      	orrs	r3, r1
 8108c22:	f040 808f 	bne.w	8108d44 <HAL_RCCEx_GetPeriphCLKFreq+0x7bc>
  {
    /* Get SPI45 clock source */
    srcclk = __HAL_RCC_GET_SPI45_SOURCE();
 8108c26:	4b42      	ldr	r3, [pc, #264]	; (8108d30 <HAL_RCCEx_GetPeriphCLKFreq+0x7a8>)
 8108c28:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8108c2a:	f403 23e0 	and.w	r3, r3, #458752	; 0x70000
 8108c2e:	63bb      	str	r3, [r7, #56]	; 0x38
    switch (srcclk)
 8108c30:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8108c32:	f5b3 2fa0 	cmp.w	r3, #327680	; 0x50000
 8108c36:	d06b      	beq.n	8108d10 <HAL_RCCEx_GetPeriphCLKFreq+0x788>
 8108c38:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8108c3a:	f5b3 2fa0 	cmp.w	r3, #327680	; 0x50000
 8108c3e:	d874      	bhi.n	8108d2a <HAL_RCCEx_GetPeriphCLKFreq+0x7a2>
 8108c40:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8108c42:	f5b3 2f80 	cmp.w	r3, #262144	; 0x40000
 8108c46:	d056      	beq.n	8108cf6 <HAL_RCCEx_GetPeriphCLKFreq+0x76e>
 8108c48:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8108c4a:	f5b3 2f80 	cmp.w	r3, #262144	; 0x40000
 8108c4e:	d86c      	bhi.n	8108d2a <HAL_RCCEx_GetPeriphCLKFreq+0x7a2>
 8108c50:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8108c52:	f5b3 3f40 	cmp.w	r3, #196608	; 0x30000
 8108c56:	d03b      	beq.n	8108cd0 <HAL_RCCEx_GetPeriphCLKFreq+0x748>
 8108c58:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8108c5a:	f5b3 3f40 	cmp.w	r3, #196608	; 0x30000
 8108c5e:	d864      	bhi.n	8108d2a <HAL_RCCEx_GetPeriphCLKFreq+0x7a2>
 8108c60:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8108c62:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
 8108c66:	d021      	beq.n	8108cac <HAL_RCCEx_GetPeriphCLKFreq+0x724>
 8108c68:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8108c6a:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
 8108c6e:	d85c      	bhi.n	8108d2a <HAL_RCCEx_GetPeriphCLKFreq+0x7a2>
 8108c70:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8108c72:	2b00      	cmp	r3, #0
 8108c74:	d004      	beq.n	8108c80 <HAL_RCCEx_GetPeriphCLKFreq+0x6f8>
 8108c76:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8108c78:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 8108c7c:	d004      	beq.n	8108c88 <HAL_RCCEx_GetPeriphCLKFreq+0x700>
 8108c7e:	e054      	b.n	8108d2a <HAL_RCCEx_GetPeriphCLKFreq+0x7a2>
    {
      case RCC_SPI45CLKSOURCE_PCLK2: /* CD/D2 PCLK2 is the clock source for SPI4/5 */
      {
        frequency = HAL_RCC_GetPCLK1Freq();
 8108c80:	f7fe fa4c 	bl	810711c <HAL_RCC_GetPCLK1Freq>
 8108c84:	63f8      	str	r0, [r7, #60]	; 0x3c
        break;
 8108c86:	e1f6      	b.n	8109076 <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
      }
      case RCC_SPI45CLKSOURCE_PLL2: /* PLL2 is the clock source for SPI45 */
      {
        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL2RDY))
 8108c88:	4b29      	ldr	r3, [pc, #164]	; (8108d30 <HAL_RCCEx_GetPeriphCLKFreq+0x7a8>)
 8108c8a:	681b      	ldr	r3, [r3, #0]
 8108c8c:	f003 6300 	and.w	r3, r3, #134217728	; 0x8000000
 8108c90:	f1b3 6f00 	cmp.w	r3, #134217728	; 0x8000000
 8108c94:	d107      	bne.n	8108ca6 <HAL_RCCEx_GetPeriphCLKFreq+0x71e>
        {
          HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
 8108c96:	f107 0318 	add.w	r3, r7, #24
 8108c9a:	4618      	mov	r0, r3
 8108c9c:	f000 fa0a 	bl	81090b4 <HAL_RCCEx_GetPLL2ClockFreq>
          frequency = pll2_clocks.PLL2_Q_Frequency;
 8108ca0:	69fb      	ldr	r3, [r7, #28]
 8108ca2:	63fb      	str	r3, [r7, #60]	; 0x3c
        }
        else
        {
          frequency = 0;
        }
        break;
 8108ca4:	e1e7      	b.n	8109076 <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
          frequency = 0;
 8108ca6:	2300      	movs	r3, #0
 8108ca8:	63fb      	str	r3, [r7, #60]	; 0x3c
        break;
 8108caa:	e1e4      	b.n	8109076 <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
      }
      case RCC_SPI45CLKSOURCE_PLL3: /* PLL3 is the clock source for SPI45 */
      {
        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL3RDY))
 8108cac:	4b20      	ldr	r3, [pc, #128]	; (8108d30 <HAL_RCCEx_GetPeriphCLKFreq+0x7a8>)
 8108cae:	681b      	ldr	r3, [r3, #0]
 8108cb0:	f003 5300 	and.w	r3, r3, #536870912	; 0x20000000
 8108cb4:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
 8108cb8:	d107      	bne.n	8108cca <HAL_RCCEx_GetPeriphCLKFreq+0x742>
        {
          HAL_RCCEx_GetPLL3ClockFreq(&pll3_clocks);
 8108cba:	f107 030c 	add.w	r3, r7, #12
 8108cbe:	4618      	mov	r0, r3
 8108cc0:	f000 fb4c 	bl	810935c <HAL_RCCEx_GetPLL3ClockFreq>
          frequency = pll3_clocks.PLL3_Q_Frequency;
 8108cc4:	693b      	ldr	r3, [r7, #16]
 8108cc6:	63fb      	str	r3, [r7, #60]	; 0x3c
        }
        else
        {
          frequency = 0;
        }
        break;
 8108cc8:	e1d5      	b.n	8109076 <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
          frequency = 0;
 8108cca:	2300      	movs	r3, #0
 8108ccc:	63fb      	str	r3, [r7, #60]	; 0x3c
        break;
 8108cce:	e1d2      	b.n	8109076 <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
      }
      case RCC_SPI45CLKSOURCE_HSI: /* HSI is the clock source for SPI45 */
      {
        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY))
 8108cd0:	4b17      	ldr	r3, [pc, #92]	; (8108d30 <HAL_RCCEx_GetPeriphCLKFreq+0x7a8>)
 8108cd2:	681b      	ldr	r3, [r3, #0]
 8108cd4:	f003 0304 	and.w	r3, r3, #4
 8108cd8:	2b04      	cmp	r3, #4
 8108cda:	d109      	bne.n	8108cf0 <HAL_RCCEx_GetPeriphCLKFreq+0x768>
        {
          frequency = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> 3));
 8108cdc:	4b14      	ldr	r3, [pc, #80]	; (8108d30 <HAL_RCCEx_GetPeriphCLKFreq+0x7a8>)
 8108cde:	681b      	ldr	r3, [r3, #0]
 8108ce0:	08db      	lsrs	r3, r3, #3
 8108ce2:	f003 0303 	and.w	r3, r3, #3
 8108ce6:	4a13      	ldr	r2, [pc, #76]	; (8108d34 <HAL_RCCEx_GetPeriphCLKFreq+0x7ac>)
 8108ce8:	fa22 f303 	lsr.w	r3, r2, r3
 8108cec:	63fb      	str	r3, [r7, #60]	; 0x3c
        }
        else
        {
          frequency = 0;
        }
        break;
 8108cee:	e1c2      	b.n	8109076 <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
          frequency = 0;
 8108cf0:	2300      	movs	r3, #0
 8108cf2:	63fb      	str	r3, [r7, #60]	; 0x3c
        break;
 8108cf4:	e1bf      	b.n	8109076 <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
      }
      case RCC_SPI45CLKSOURCE_CSI: /* CSI is the clock source for SPI45 */
      {
        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_CSIRDY))
 8108cf6:	4b0e      	ldr	r3, [pc, #56]	; (8108d30 <HAL_RCCEx_GetPeriphCLKFreq+0x7a8>)
 8108cf8:	681b      	ldr	r3, [r3, #0]
 8108cfa:	f403 7380 	and.w	r3, r3, #256	; 0x100
 8108cfe:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 8108d02:	d102      	bne.n	8108d0a <HAL_RCCEx_GetPeriphCLKFreq+0x782>
        {
          frequency = CSI_VALUE;
 8108d04:	4b0c      	ldr	r3, [pc, #48]	; (8108d38 <HAL_RCCEx_GetPeriphCLKFreq+0x7b0>)
 8108d06:	63fb      	str	r3, [r7, #60]	; 0x3c
        }
        else
        {
          frequency = 0;
        }
        break;
 8108d08:	e1b5      	b.n	8109076 <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
          frequency = 0;
 8108d0a:	2300      	movs	r3, #0
 8108d0c:	63fb      	str	r3, [r7, #60]	; 0x3c
        break;
 8108d0e:	e1b2      	b.n	8109076 <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
      }
      case RCC_SPI45CLKSOURCE_HSE: /* HSE is the clock source for SPI45 */
      {
        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSERDY))
 8108d10:	4b07      	ldr	r3, [pc, #28]	; (8108d30 <HAL_RCCEx_GetPeriphCLKFreq+0x7a8>)
 8108d12:	681b      	ldr	r3, [r3, #0]
 8108d14:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 8108d18:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
 8108d1c:	d102      	bne.n	8108d24 <HAL_RCCEx_GetPeriphCLKFreq+0x79c>
        {
          frequency = HSE_VALUE;
 8108d1e:	4b07      	ldr	r3, [pc, #28]	; (8108d3c <HAL_RCCEx_GetPeriphCLKFreq+0x7b4>)
 8108d20:	63fb      	str	r3, [r7, #60]	; 0x3c
        }
        else
        {
          frequency = 0;
        }
        break;
 8108d22:	e1a8      	b.n	8109076 <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
          frequency = 0;
 8108d24:	2300      	movs	r3, #0
 8108d26:	63fb      	str	r3, [r7, #60]	; 0x3c
        break;
 8108d28:	e1a5      	b.n	8109076 <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
      }
      default :
      {
        frequency = 0;
 8108d2a:	2300      	movs	r3, #0
 8108d2c:	63fb      	str	r3, [r7, #60]	; 0x3c
        break;
 8108d2e:	e1a2      	b.n	8109076 <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
 8108d30:	58024400 	.word	0x58024400
 8108d34:	03d09000 	.word	0x03d09000
 8108d38:	003d0900 	.word	0x003d0900
 8108d3c:	017d7840 	.word	0x017d7840
 8108d40:	00bb8000 	.word	0x00bb8000
      }
    }
  }
  else if (PeriphClk == RCC_PERIPHCLK_ADC)
 8108d44:	e9d7 2300 	ldrd	r2, r3, [r7]
 8108d48:	f5a2 2100 	sub.w	r1, r2, #524288	; 0x80000
 8108d4c:	430b      	orrs	r3, r1
 8108d4e:	d173      	bne.n	8108e38 <HAL_RCCEx_GetPeriphCLKFreq+0x8b0>
  {
    /* Get ADC clock source */
    srcclk = __HAL_RCC_GET_ADC_SOURCE();
 8108d50:	4b9c      	ldr	r3, [pc, #624]	; (8108fc4 <HAL_RCCEx_GetPeriphCLKFreq+0xa3c>)
 8108d52:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8108d54:	f403 3340 	and.w	r3, r3, #196608	; 0x30000
 8108d58:	63bb      	str	r3, [r7, #56]	; 0x38

    switch (srcclk)
 8108d5a:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8108d5c:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
 8108d60:	d02f      	beq.n	8108dc2 <HAL_RCCEx_GetPeriphCLKFreq+0x83a>
 8108d62:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8108d64:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
 8108d68:	d863      	bhi.n	8108e32 <HAL_RCCEx_GetPeriphCLKFreq+0x8aa>
 8108d6a:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8108d6c:	2b00      	cmp	r3, #0
 8108d6e:	d004      	beq.n	8108d7a <HAL_RCCEx_GetPeriphCLKFreq+0x7f2>
 8108d70:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8108d72:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 8108d76:	d012      	beq.n	8108d9e <HAL_RCCEx_GetPeriphCLKFreq+0x816>
 8108d78:	e05b      	b.n	8108e32 <HAL_RCCEx_GetPeriphCLKFreq+0x8aa>
    {
      case RCC_ADCCLKSOURCE_PLL2:
      {
        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL2RDY))
 8108d7a:	4b92      	ldr	r3, [pc, #584]	; (8108fc4 <HAL_RCCEx_GetPeriphCLKFreq+0xa3c>)
 8108d7c:	681b      	ldr	r3, [r3, #0]
 8108d7e:	f003 6300 	and.w	r3, r3, #134217728	; 0x8000000
 8108d82:	f1b3 6f00 	cmp.w	r3, #134217728	; 0x8000000
 8108d86:	d107      	bne.n	8108d98 <HAL_RCCEx_GetPeriphCLKFreq+0x810>
        {
          HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
 8108d88:	f107 0318 	add.w	r3, r7, #24
 8108d8c:	4618      	mov	r0, r3
 8108d8e:	f000 f991 	bl	81090b4 <HAL_RCCEx_GetPLL2ClockFreq>
          frequency = pll2_clocks.PLL2_P_Frequency;
 8108d92:	69bb      	ldr	r3, [r7, #24]
 8108d94:	63fb      	str	r3, [r7, #60]	; 0x3c
        }
        else
        {
          frequency = 0;
        }
        break;
 8108d96:	e16e      	b.n	8109076 <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
          frequency = 0;
 8108d98:	2300      	movs	r3, #0
 8108d9a:	63fb      	str	r3, [r7, #60]	; 0x3c
        break;
 8108d9c:	e16b      	b.n	8109076 <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
      }
      case RCC_ADCCLKSOURCE_PLL3:
      {
        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL3RDY))
 8108d9e:	4b89      	ldr	r3, [pc, #548]	; (8108fc4 <HAL_RCCEx_GetPeriphCLKFreq+0xa3c>)
 8108da0:	681b      	ldr	r3, [r3, #0]
 8108da2:	f003 5300 	and.w	r3, r3, #536870912	; 0x20000000
 8108da6:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
 8108daa:	d107      	bne.n	8108dbc <HAL_RCCEx_GetPeriphCLKFreq+0x834>
        {
          HAL_RCCEx_GetPLL3ClockFreq(&pll3_clocks);
 8108dac:	f107 030c 	add.w	r3, r7, #12
 8108db0:	4618      	mov	r0, r3
 8108db2:	f000 fad3 	bl	810935c <HAL_RCCEx_GetPLL3ClockFreq>
          frequency = pll3_clocks.PLL3_R_Frequency;
 8108db6:	697b      	ldr	r3, [r7, #20]
 8108db8:	63fb      	str	r3, [r7, #60]	; 0x3c
        }
        else
        {
          frequency = 0;
        }
        break;
 8108dba:	e15c      	b.n	8109076 <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
          frequency = 0;
 8108dbc:	2300      	movs	r3, #0
 8108dbe:	63fb      	str	r3, [r7, #60]	; 0x3c
        break;
 8108dc0:	e159      	b.n	8109076 <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
      }

      case RCC_ADCCLKSOURCE_CLKP:
      {

        ckpclocksource = __HAL_RCC_GET_CLKP_SOURCE();
 8108dc2:	4b80      	ldr	r3, [pc, #512]	; (8108fc4 <HAL_RCCEx_GetPeriphCLKFreq+0xa3c>)
 8108dc4:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8108dc6:	f003 5340 	and.w	r3, r3, #805306368	; 0x30000000
 8108dca:	637b      	str	r3, [r7, #52]	; 0x34

        if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY)) && (ckpclocksource == RCC_CLKPSOURCE_HSI))
 8108dcc:	4b7d      	ldr	r3, [pc, #500]	; (8108fc4 <HAL_RCCEx_GetPeriphCLKFreq+0xa3c>)
 8108dce:	681b      	ldr	r3, [r3, #0]
 8108dd0:	f003 0304 	and.w	r3, r3, #4
 8108dd4:	2b04      	cmp	r3, #4
 8108dd6:	d10c      	bne.n	8108df2 <HAL_RCCEx_GetPeriphCLKFreq+0x86a>
 8108dd8:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8108dda:	2b00      	cmp	r3, #0
 8108ddc:	d109      	bne.n	8108df2 <HAL_RCCEx_GetPeriphCLKFreq+0x86a>
        {
          /* In Case the CKPER Source is HSI */
          frequency = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> 3));
 8108dde:	4b79      	ldr	r3, [pc, #484]	; (8108fc4 <HAL_RCCEx_GetPeriphCLKFreq+0xa3c>)
 8108de0:	681b      	ldr	r3, [r3, #0]
 8108de2:	08db      	lsrs	r3, r3, #3
 8108de4:	f003 0303 	and.w	r3, r3, #3
 8108de8:	4a77      	ldr	r2, [pc, #476]	; (8108fc8 <HAL_RCCEx_GetPeriphCLKFreq+0xa40>)
 8108dea:	fa22 f303 	lsr.w	r3, r2, r3
 8108dee:	63fb      	str	r3, [r7, #60]	; 0x3c
 8108df0:	e01e      	b.n	8108e30 <HAL_RCCEx_GetPeriphCLKFreq+0x8a8>
        }

        else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_CSIRDY)) && (ckpclocksource == RCC_CLKPSOURCE_CSI))
 8108df2:	4b74      	ldr	r3, [pc, #464]	; (8108fc4 <HAL_RCCEx_GetPeriphCLKFreq+0xa3c>)
 8108df4:	681b      	ldr	r3, [r3, #0]
 8108df6:	f403 7380 	and.w	r3, r3, #256	; 0x100
 8108dfa:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 8108dfe:	d106      	bne.n	8108e0e <HAL_RCCEx_GetPeriphCLKFreq+0x886>
 8108e00:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8108e02:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
 8108e06:	d102      	bne.n	8108e0e <HAL_RCCEx_GetPeriphCLKFreq+0x886>
        {
          /* In Case the CKPER Source is CSI */
          frequency = CSI_VALUE;
 8108e08:	4b70      	ldr	r3, [pc, #448]	; (8108fcc <HAL_RCCEx_GetPeriphCLKFreq+0xa44>)
 8108e0a:	63fb      	str	r3, [r7, #60]	; 0x3c
 8108e0c:	e010      	b.n	8108e30 <HAL_RCCEx_GetPeriphCLKFreq+0x8a8>
        }

        else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSERDY)) && (ckpclocksource == RCC_CLKPSOURCE_HSE))
 8108e0e:	4b6d      	ldr	r3, [pc, #436]	; (8108fc4 <HAL_RCCEx_GetPeriphCLKFreq+0xa3c>)
 8108e10:	681b      	ldr	r3, [r3, #0]
 8108e12:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 8108e16:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
 8108e1a:	d106      	bne.n	8108e2a <HAL_RCCEx_GetPeriphCLKFreq+0x8a2>
 8108e1c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8108e1e:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
 8108e22:	d102      	bne.n	8108e2a <HAL_RCCEx_GetPeriphCLKFreq+0x8a2>
        {
          /* In Case the CKPER Source is HSE */
          frequency = HSE_VALUE;
 8108e24:	4b6a      	ldr	r3, [pc, #424]	; (8108fd0 <HAL_RCCEx_GetPeriphCLKFreq+0xa48>)
 8108e26:	63fb      	str	r3, [r7, #60]	; 0x3c
 8108e28:	e002      	b.n	8108e30 <HAL_RCCEx_GetPeriphCLKFreq+0x8a8>
        }

        else
        {
          /* In Case the CKPER is disabled*/
          frequency = 0;
 8108e2a:	2300      	movs	r3, #0
 8108e2c:	63fb      	str	r3, [r7, #60]	; 0x3c
        }

        break;
 8108e2e:	e122      	b.n	8109076 <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
 8108e30:	e121      	b.n	8109076 <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
      }

      default :
      {
        frequency = 0;
 8108e32:	2300      	movs	r3, #0
 8108e34:	63fb      	str	r3, [r7, #60]	; 0x3c
        break;
 8108e36:	e11e      	b.n	8109076 <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
      }
    }
  }
  else if (PeriphClk == RCC_PERIPHCLK_SDMMC)
 8108e38:	e9d7 2300 	ldrd	r2, r3, [r7]
 8108e3c:	f5a2 3180 	sub.w	r1, r2, #65536	; 0x10000
 8108e40:	430b      	orrs	r3, r1
 8108e42:	d133      	bne.n	8108eac <HAL_RCCEx_GetPeriphCLKFreq+0x924>
  {
    /* Get SDMMC clock source */
    srcclk = __HAL_RCC_GET_SDMMC_SOURCE();
 8108e44:	4b5f      	ldr	r3, [pc, #380]	; (8108fc4 <HAL_RCCEx_GetPeriphCLKFreq+0xa3c>)
 8108e46:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8108e48:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
 8108e4c:	63bb      	str	r3, [r7, #56]	; 0x38

    switch (srcclk)
 8108e4e:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8108e50:	2b00      	cmp	r3, #0
 8108e52:	d004      	beq.n	8108e5e <HAL_RCCEx_GetPeriphCLKFreq+0x8d6>
 8108e54:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8108e56:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 8108e5a:	d012      	beq.n	8108e82 <HAL_RCCEx_GetPeriphCLKFreq+0x8fa>
 8108e5c:	e023      	b.n	8108ea6 <HAL_RCCEx_GetPeriphCLKFreq+0x91e>
    {
      case RCC_SDMMCCLKSOURCE_PLL: /* PLL1 is the clock source for SDMMC */
      {
        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL1RDY))
 8108e5e:	4b59      	ldr	r3, [pc, #356]	; (8108fc4 <HAL_RCCEx_GetPeriphCLKFreq+0xa3c>)
 8108e60:	681b      	ldr	r3, [r3, #0]
 8108e62:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 8108e66:	f1b3 7f00 	cmp.w	r3, #33554432	; 0x2000000
 8108e6a:	d107      	bne.n	8108e7c <HAL_RCCEx_GetPeriphCLKFreq+0x8f4>
        {
          HAL_RCCEx_GetPLL1ClockFreq(&pll1_clocks);
 8108e6c:	f107 0324 	add.w	r3, r7, #36	; 0x24
 8108e70:	4618      	mov	r0, r3
 8108e72:	f000 fbc7 	bl	8109604 <HAL_RCCEx_GetPLL1ClockFreq>
          frequency = pll1_clocks.PLL1_Q_Frequency;
 8108e76:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8108e78:	63fb      	str	r3, [r7, #60]	; 0x3c
        }
        else
        {
          frequency = 0;
        }
        break;
 8108e7a:	e0fc      	b.n	8109076 <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
          frequency = 0;
 8108e7c:	2300      	movs	r3, #0
 8108e7e:	63fb      	str	r3, [r7, #60]	; 0x3c
        break;
 8108e80:	e0f9      	b.n	8109076 <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
      }
      case RCC_SDMMCCLKSOURCE_PLL2: /* PLL2 is the clock source for SDMMC */
      {
        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL2RDY))
 8108e82:	4b50      	ldr	r3, [pc, #320]	; (8108fc4 <HAL_RCCEx_GetPeriphCLKFreq+0xa3c>)
 8108e84:	681b      	ldr	r3, [r3, #0]
 8108e86:	f003 6300 	and.w	r3, r3, #134217728	; 0x8000000
 8108e8a:	f1b3 6f00 	cmp.w	r3, #134217728	; 0x8000000
 8108e8e:	d107      	bne.n	8108ea0 <HAL_RCCEx_GetPeriphCLKFreq+0x918>
        {
          HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
 8108e90:	f107 0318 	add.w	r3, r7, #24
 8108e94:	4618      	mov	r0, r3
 8108e96:	f000 f90d 	bl	81090b4 <HAL_RCCEx_GetPLL2ClockFreq>
          frequency = pll2_clocks.PLL2_R_Frequency;
 8108e9a:	6a3b      	ldr	r3, [r7, #32]
 8108e9c:	63fb      	str	r3, [r7, #60]	; 0x3c
        }
        else
        {
          frequency = 0;
        }
        break;
 8108e9e:	e0ea      	b.n	8109076 <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
          frequency = 0;
 8108ea0:	2300      	movs	r3, #0
 8108ea2:	63fb      	str	r3, [r7, #60]	; 0x3c
        break;
 8108ea4:	e0e7      	b.n	8109076 <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
      }

      default :
      {
        frequency = 0;
 8108ea6:	2300      	movs	r3, #0
 8108ea8:	63fb      	str	r3, [r7, #60]	; 0x3c
        break;
 8108eaa:	e0e4      	b.n	8109076 <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
      }
    }
  }
  else if (PeriphClk == RCC_PERIPHCLK_SPI6)
 8108eac:	e9d7 2300 	ldrd	r2, r3, [r7]
 8108eb0:	f5a2 4180 	sub.w	r1, r2, #16384	; 0x4000
 8108eb4:	430b      	orrs	r3, r1
 8108eb6:	f040 808d 	bne.w	8108fd4 <HAL_RCCEx_GetPeriphCLKFreq+0xa4c>
  {
    /* Get SPI6 clock source */
    srcclk = __HAL_RCC_GET_SPI6_SOURCE();
 8108eba:	4b42      	ldr	r3, [pc, #264]	; (8108fc4 <HAL_RCCEx_GetPeriphCLKFreq+0xa3c>)
 8108ebc:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8108ebe:	f003 43e0 	and.w	r3, r3, #1879048192	; 0x70000000
 8108ec2:	63bb      	str	r3, [r7, #56]	; 0x38

    switch (srcclk)
 8108ec4:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8108ec6:	f1b3 4fa0 	cmp.w	r3, #1342177280	; 0x50000000
 8108eca:	d06b      	beq.n	8108fa4 <HAL_RCCEx_GetPeriphCLKFreq+0xa1c>
 8108ecc:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8108ece:	f1b3 4fa0 	cmp.w	r3, #1342177280	; 0x50000000
 8108ed2:	d874      	bhi.n	8108fbe <HAL_RCCEx_GetPeriphCLKFreq+0xa36>
 8108ed4:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8108ed6:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
 8108eda:	d056      	beq.n	8108f8a <HAL_RCCEx_GetPeriphCLKFreq+0xa02>
 8108edc:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8108ede:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
 8108ee2:	d86c      	bhi.n	8108fbe <HAL_RCCEx_GetPeriphCLKFreq+0xa36>
 8108ee4:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8108ee6:	f1b3 5f40 	cmp.w	r3, #805306368	; 0x30000000
 8108eea:	d03b      	beq.n	8108f64 <HAL_RCCEx_GetPeriphCLKFreq+0x9dc>
 8108eec:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8108eee:	f1b3 5f40 	cmp.w	r3, #805306368	; 0x30000000
 8108ef2:	d864      	bhi.n	8108fbe <HAL_RCCEx_GetPeriphCLKFreq+0xa36>
 8108ef4:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8108ef6:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
 8108efa:	d021      	beq.n	8108f40 <HAL_RCCEx_GetPeriphCLKFreq+0x9b8>
 8108efc:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8108efe:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
 8108f02:	d85c      	bhi.n	8108fbe <HAL_RCCEx_GetPeriphCLKFreq+0xa36>
 8108f04:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8108f06:	2b00      	cmp	r3, #0
 8108f08:	d004      	beq.n	8108f14 <HAL_RCCEx_GetPeriphCLKFreq+0x98c>
 8108f0a:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8108f0c:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
 8108f10:	d004      	beq.n	8108f1c <HAL_RCCEx_GetPeriphCLKFreq+0x994>
 8108f12:	e054      	b.n	8108fbe <HAL_RCCEx_GetPeriphCLKFreq+0xa36>
    {
      case RCC_SPI6CLKSOURCE_D3PCLK1: /* D3PCLK1 (PCLK4) is the clock source for SPI6 */
      {
        frequency = HAL_RCCEx_GetD3PCLK1Freq();
 8108f14:	f000 f8b8 	bl	8109088 <HAL_RCCEx_GetD3PCLK1Freq>
 8108f18:	63f8      	str	r0, [r7, #60]	; 0x3c
        break;
 8108f1a:	e0ac      	b.n	8109076 <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
      }
      case RCC_SPI6CLKSOURCE_PLL2: /* PLL2 is the clock source for SPI6 */
      {
        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL2RDY))
 8108f1c:	4b29      	ldr	r3, [pc, #164]	; (8108fc4 <HAL_RCCEx_GetPeriphCLKFreq+0xa3c>)
 8108f1e:	681b      	ldr	r3, [r3, #0]
 8108f20:	f003 6300 	and.w	r3, r3, #134217728	; 0x8000000
 8108f24:	f1b3 6f00 	cmp.w	r3, #134217728	; 0x8000000
 8108f28:	d107      	bne.n	8108f3a <HAL_RCCEx_GetPeriphCLKFreq+0x9b2>
        {
          HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
 8108f2a:	f107 0318 	add.w	r3, r7, #24
 8108f2e:	4618      	mov	r0, r3
 8108f30:	f000 f8c0 	bl	81090b4 <HAL_RCCEx_GetPLL2ClockFreq>
          frequency = pll2_clocks.PLL2_Q_Frequency;
 8108f34:	69fb      	ldr	r3, [r7, #28]
 8108f36:	63fb      	str	r3, [r7, #60]	; 0x3c
        }
        else
        {
          frequency = 0;
        }
        break;
 8108f38:	e09d      	b.n	8109076 <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
          frequency = 0;
 8108f3a:	2300      	movs	r3, #0
 8108f3c:	63fb      	str	r3, [r7, #60]	; 0x3c
        break;
 8108f3e:	e09a      	b.n	8109076 <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
      }
      case RCC_SPI6CLKSOURCE_PLL3: /* PLL3 is the clock source for SPI6 */
      {
        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL3RDY))
 8108f40:	4b20      	ldr	r3, [pc, #128]	; (8108fc4 <HAL_RCCEx_GetPeriphCLKFreq+0xa3c>)
 8108f42:	681b      	ldr	r3, [r3, #0]
 8108f44:	f003 5300 	and.w	r3, r3, #536870912	; 0x20000000
 8108f48:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
 8108f4c:	d107      	bne.n	8108f5e <HAL_RCCEx_GetPeriphCLKFreq+0x9d6>
        {
          HAL_RCCEx_GetPLL3ClockFreq(&pll3_clocks);
 8108f4e:	f107 030c 	add.w	r3, r7, #12
 8108f52:	4618      	mov	r0, r3
 8108f54:	f000 fa02 	bl	810935c <HAL_RCCEx_GetPLL3ClockFreq>
          frequency = pll3_clocks.PLL3_Q_Frequency;
 8108f58:	693b      	ldr	r3, [r7, #16]
 8108f5a:	63fb      	str	r3, [r7, #60]	; 0x3c
        }
        else
        {
          frequency = 0;
        }
        break;
 8108f5c:	e08b      	b.n	8109076 <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
          frequency = 0;
 8108f5e:	2300      	movs	r3, #0
 8108f60:	63fb      	str	r3, [r7, #60]	; 0x3c
        break;
 8108f62:	e088      	b.n	8109076 <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
      }
      case RCC_SPI6CLKSOURCE_HSI: /* HSI is the clock source for SPI6 */
      {
        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY))
 8108f64:	4b17      	ldr	r3, [pc, #92]	; (8108fc4 <HAL_RCCEx_GetPeriphCLKFreq+0xa3c>)
 8108f66:	681b      	ldr	r3, [r3, #0]
 8108f68:	f003 0304 	and.w	r3, r3, #4
 8108f6c:	2b04      	cmp	r3, #4
 8108f6e:	d109      	bne.n	8108f84 <HAL_RCCEx_GetPeriphCLKFreq+0x9fc>
        {
          frequency = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> 3));
 8108f70:	4b14      	ldr	r3, [pc, #80]	; (8108fc4 <HAL_RCCEx_GetPeriphCLKFreq+0xa3c>)
 8108f72:	681b      	ldr	r3, [r3, #0]
 8108f74:	08db      	lsrs	r3, r3, #3
 8108f76:	f003 0303 	and.w	r3, r3, #3
 8108f7a:	4a13      	ldr	r2, [pc, #76]	; (8108fc8 <HAL_RCCEx_GetPeriphCLKFreq+0xa40>)
 8108f7c:	fa22 f303 	lsr.w	r3, r2, r3
 8108f80:	63fb      	str	r3, [r7, #60]	; 0x3c
        }
        else
        {
          frequency = 0;
        }
        break;
 8108f82:	e078      	b.n	8109076 <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
          frequency = 0;
 8108f84:	2300      	movs	r3, #0
 8108f86:	63fb      	str	r3, [r7, #60]	; 0x3c
        break;
 8108f88:	e075      	b.n	8109076 <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
      }
      case RCC_SPI6CLKSOURCE_CSI: /* CSI is the clock source for SPI6 */
      {
        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_CSIRDY))
 8108f8a:	4b0e      	ldr	r3, [pc, #56]	; (8108fc4 <HAL_RCCEx_GetPeriphCLKFreq+0xa3c>)
 8108f8c:	681b      	ldr	r3, [r3, #0]
 8108f8e:	f403 7380 	and.w	r3, r3, #256	; 0x100
 8108f92:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 8108f96:	d102      	bne.n	8108f9e <HAL_RCCEx_GetPeriphCLKFreq+0xa16>
        {
          frequency = CSI_VALUE;
 8108f98:	4b0c      	ldr	r3, [pc, #48]	; (8108fcc <HAL_RCCEx_GetPeriphCLKFreq+0xa44>)
 8108f9a:	63fb      	str	r3, [r7, #60]	; 0x3c
        }
        else
        {
          frequency = 0;
        }
        break;
 8108f9c:	e06b      	b.n	8109076 <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
          frequency = 0;
 8108f9e:	2300      	movs	r3, #0
 8108fa0:	63fb      	str	r3, [r7, #60]	; 0x3c
        break;
 8108fa2:	e068      	b.n	8109076 <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
      }
      case RCC_SPI6CLKSOURCE_HSE: /* HSE is the clock source for SPI6 */
      {
        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSERDY))
 8108fa4:	4b07      	ldr	r3, [pc, #28]	; (8108fc4 <HAL_RCCEx_GetPeriphCLKFreq+0xa3c>)
 8108fa6:	681b      	ldr	r3, [r3, #0]
 8108fa8:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 8108fac:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
 8108fb0:	d102      	bne.n	8108fb8 <HAL_RCCEx_GetPeriphCLKFreq+0xa30>
        {
          frequency = HSE_VALUE;
 8108fb2:	4b07      	ldr	r3, [pc, #28]	; (8108fd0 <HAL_RCCEx_GetPeriphCLKFreq+0xa48>)
 8108fb4:	63fb      	str	r3, [r7, #60]	; 0x3c
        }
        else
        {
          frequency = 0;
        }
        break;
 8108fb6:	e05e      	b.n	8109076 <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
          frequency = 0;
 8108fb8:	2300      	movs	r3, #0
 8108fba:	63fb      	str	r3, [r7, #60]	; 0x3c
        break;
 8108fbc:	e05b      	b.n	8109076 <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
        break;
      }
#endif /* RCC_SPI6CLKSOURCE_PIN */
      default :
      {
        frequency = 0;
 8108fbe:	2300      	movs	r3, #0
 8108fc0:	63fb      	str	r3, [r7, #60]	; 0x3c
        break;
 8108fc2:	e058      	b.n	8109076 <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
 8108fc4:	58024400 	.word	0x58024400
 8108fc8:	03d09000 	.word	0x03d09000
 8108fcc:	003d0900 	.word	0x003d0900
 8108fd0:	017d7840 	.word	0x017d7840
      }
    }
  }
  else if (PeriphClk == RCC_PERIPHCLK_FDCAN)
 8108fd4:	e9d7 2300 	ldrd	r2, r3, [r7]
 8108fd8:	f5a2 4100 	sub.w	r1, r2, #32768	; 0x8000
 8108fdc:	430b      	orrs	r3, r1
 8108fde:	d148      	bne.n	8109072 <HAL_RCCEx_GetPeriphCLKFreq+0xaea>
  {
    /* Get FDCAN clock source */
    srcclk = __HAL_RCC_GET_FDCAN_SOURCE();
 8108fe0:	4b27      	ldr	r3, [pc, #156]	; (8109080 <HAL_RCCEx_GetPeriphCLKFreq+0xaf8>)
 8108fe2:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8108fe4:	f003 5340 	and.w	r3, r3, #805306368	; 0x30000000
 8108fe8:	63bb      	str	r3, [r7, #56]	; 0x38

    switch (srcclk)
 8108fea:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8108fec:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
 8108ff0:	d02a      	beq.n	8109048 <HAL_RCCEx_GetPeriphCLKFreq+0xac0>
 8108ff2:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8108ff4:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
 8108ff8:	d838      	bhi.n	810906c <HAL_RCCEx_GetPeriphCLKFreq+0xae4>
 8108ffa:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8108ffc:	2b00      	cmp	r3, #0
 8108ffe:	d004      	beq.n	810900a <HAL_RCCEx_GetPeriphCLKFreq+0xa82>
 8109000:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8109002:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
 8109006:	d00d      	beq.n	8109024 <HAL_RCCEx_GetPeriphCLKFreq+0xa9c>
 8109008:	e030      	b.n	810906c <HAL_RCCEx_GetPeriphCLKFreq+0xae4>
    {
      case RCC_FDCANCLKSOURCE_HSE: /* HSE is the clock source for FDCAN */
      {
        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSERDY))
 810900a:	4b1d      	ldr	r3, [pc, #116]	; (8109080 <HAL_RCCEx_GetPeriphCLKFreq+0xaf8>)
 810900c:	681b      	ldr	r3, [r3, #0]
 810900e:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 8109012:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
 8109016:	d102      	bne.n	810901e <HAL_RCCEx_GetPeriphCLKFreq+0xa96>
        {
          frequency = HSE_VALUE;
 8109018:	4b1a      	ldr	r3, [pc, #104]	; (8109084 <HAL_RCCEx_GetPeriphCLKFreq+0xafc>)
 810901a:	63fb      	str	r3, [r7, #60]	; 0x3c
        }
        else
        {
          frequency = 0;
        }
        break;
 810901c:	e02b      	b.n	8109076 <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
          frequency = 0;
 810901e:	2300      	movs	r3, #0
 8109020:	63fb      	str	r3, [r7, #60]	; 0x3c
        break;
 8109022:	e028      	b.n	8109076 <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
      }
      case RCC_FDCANCLKSOURCE_PLL: /* PLL is the clock source for FDCAN */
      {
        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL1RDY))
 8109024:	4b16      	ldr	r3, [pc, #88]	; (8109080 <HAL_RCCEx_GetPeriphCLKFreq+0xaf8>)
 8109026:	681b      	ldr	r3, [r3, #0]
 8109028:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 810902c:	f1b3 7f00 	cmp.w	r3, #33554432	; 0x2000000
 8109030:	d107      	bne.n	8109042 <HAL_RCCEx_GetPeriphCLKFreq+0xaba>
        {
          HAL_RCCEx_GetPLL1ClockFreq(&pll1_clocks);
 8109032:	f107 0324 	add.w	r3, r7, #36	; 0x24
 8109036:	4618      	mov	r0, r3
 8109038:	f000 fae4 	bl	8109604 <HAL_RCCEx_GetPLL1ClockFreq>
          frequency = pll1_clocks.PLL1_Q_Frequency;
 810903c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 810903e:	63fb      	str	r3, [r7, #60]	; 0x3c
        }
        else
        {
          frequency = 0;
        }
        break;
 8109040:	e019      	b.n	8109076 <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
          frequency = 0;
 8109042:	2300      	movs	r3, #0
 8109044:	63fb      	str	r3, [r7, #60]	; 0x3c
        break;
 8109046:	e016      	b.n	8109076 <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
      }
      case RCC_FDCANCLKSOURCE_PLL2: /* PLL2 is the clock source for FDCAN */
      {
        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL2RDY))
 8109048:	4b0d      	ldr	r3, [pc, #52]	; (8109080 <HAL_RCCEx_GetPeriphCLKFreq+0xaf8>)
 810904a:	681b      	ldr	r3, [r3, #0]
 810904c:	f003 6300 	and.w	r3, r3, #134217728	; 0x8000000
 8109050:	f1b3 6f00 	cmp.w	r3, #134217728	; 0x8000000
 8109054:	d107      	bne.n	8109066 <HAL_RCCEx_GetPeriphCLKFreq+0xade>
        {
          HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
 8109056:	f107 0318 	add.w	r3, r7, #24
 810905a:	4618      	mov	r0, r3
 810905c:	f000 f82a 	bl	81090b4 <HAL_RCCEx_GetPLL2ClockFreq>
          frequency = pll2_clocks.PLL2_Q_Frequency;
 8109060:	69fb      	ldr	r3, [r7, #28]
 8109062:	63fb      	str	r3, [r7, #60]	; 0x3c
        }
        else
        {
          frequency = 0;
        }
        break;
 8109064:	e007      	b.n	8109076 <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
          frequency = 0;
 8109066:	2300      	movs	r3, #0
 8109068:	63fb      	str	r3, [r7, #60]	; 0x3c
        break;
 810906a:	e004      	b.n	8109076 <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
      }
      default :
      {
        frequency = 0;
 810906c:	2300      	movs	r3, #0
 810906e:	63fb      	str	r3, [r7, #60]	; 0x3c
        break;
 8109070:	e001      	b.n	8109076 <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
      }
    }
  }
  else
  {
    frequency = 0;
 8109072:	2300      	movs	r3, #0
 8109074:	63fb      	str	r3, [r7, #60]	; 0x3c
  }

  return frequency;
 8109076:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
}
 8109078:	4618      	mov	r0, r3
 810907a:	3740      	adds	r7, #64	; 0x40
 810907c:	46bd      	mov	sp, r7
 810907e:	bd80      	pop	{r7, pc}
 8109080:	58024400 	.word	0x58024400
 8109084:	017d7840 	.word	0x017d7840

08109088 <HAL_RCCEx_GetD3PCLK1Freq>:
  * @note   Each time D3PCLK1 changes, this function must be called to update the
  *         right D3PCLK1 value. Otherwise, any configuration based on this function will be incorrect.
  * @retval D3PCLK1 frequency
  */
uint32_t HAL_RCCEx_GetD3PCLK1Freq(void)
{
 8109088:	b580      	push	{r7, lr}
 810908a:	af00      	add	r7, sp, #0
#if defined(RCC_D3CFGR_D3PPRE)
  /* Get HCLK source and Compute D3PCLK1 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq() >> (D1CorePrescTable[(RCC->D3CFGR & RCC_D3CFGR_D3PPRE) >> RCC_D3CFGR_D3PPRE_Pos] & 0x1FU));
 810908c:	f7fe f814 	bl	81070b8 <HAL_RCC_GetHCLKFreq>
 8109090:	4602      	mov	r2, r0
 8109092:	4b06      	ldr	r3, [pc, #24]	; (81090ac <HAL_RCCEx_GetD3PCLK1Freq+0x24>)
 8109094:	6a1b      	ldr	r3, [r3, #32]
 8109096:	091b      	lsrs	r3, r3, #4
 8109098:	f003 0307 	and.w	r3, r3, #7
 810909c:	4904      	ldr	r1, [pc, #16]	; (81090b0 <HAL_RCCEx_GetD3PCLK1Freq+0x28>)
 810909e:	5ccb      	ldrb	r3, [r1, r3]
 81090a0:	f003 031f 	and.w	r3, r3, #31
 81090a4:	fa22 f303 	lsr.w	r3, r2, r3
#else
  /* Get HCLK source and Compute D3PCLK1 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq() >> (D1CorePrescTable[(RCC->SRDCFGR & RCC_SRDCFGR_SRDPPRE) >> RCC_SRDCFGR_SRDPPRE_Pos] & 0x1FU));
#endif
}
 81090a8:	4618      	mov	r0, r3
 81090aa:	bd80      	pop	{r7, pc}
 81090ac:	58024400 	.word	0x58024400
 81090b0:	0811f8e4 	.word	0x0811f8e4

081090b4 <HAL_RCCEx_GetPLL2ClockFreq>:
  *         right PLL2CLK value. Otherwise, any configuration based on this function will be incorrect.
  * @param  PLL2_Clocks structure.
  * @retval None
  */
void HAL_RCCEx_GetPLL2ClockFreq(PLL2_ClocksTypeDef *PLL2_Clocks)
{
 81090b4:	b480      	push	{r7}
 81090b6:	b089      	sub	sp, #36	; 0x24
 81090b8:	af00      	add	r7, sp, #0
 81090ba:	6078      	str	r0, [r7, #4]
  float_t fracn2, pll2vco;

  /* PLL_VCO = (HSE_VALUE or HSI_VALUE or CSI_VALUE/ PLL2M) * PLL2N
     PLL2xCLK = PLL2_VCO / PLL2x
  */
  pllsource = (RCC->PLLCKSELR & RCC_PLLCKSELR_PLLSRC);
 81090bc:	4ba1      	ldr	r3, [pc, #644]	; (8109344 <HAL_RCCEx_GetPLL2ClockFreq+0x290>)
 81090be:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 81090c0:	f003 0303 	and.w	r3, r3, #3
 81090c4:	61bb      	str	r3, [r7, #24]
  pll2m = ((RCC->PLLCKSELR & RCC_PLLCKSELR_DIVM2) >> 12);
 81090c6:	4b9f      	ldr	r3, [pc, #636]	; (8109344 <HAL_RCCEx_GetPLL2ClockFreq+0x290>)
 81090c8:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 81090ca:	0b1b      	lsrs	r3, r3, #12
 81090cc:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 81090d0:	617b      	str	r3, [r7, #20]
  pll2fracen = (RCC->PLLCFGR & RCC_PLLCFGR_PLL2FRACEN) >> RCC_PLLCFGR_PLL2FRACEN_Pos;
 81090d2:	4b9c      	ldr	r3, [pc, #624]	; (8109344 <HAL_RCCEx_GetPLL2ClockFreq+0x290>)
 81090d4:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 81090d6:	091b      	lsrs	r3, r3, #4
 81090d8:	f003 0301 	and.w	r3, r3, #1
 81090dc:	613b      	str	r3, [r7, #16]
  fracn2 = (float_t)(uint32_t)(pll2fracen * ((RCC->PLL2FRACR & RCC_PLL2FRACR_FRACN2) >> 3));
 81090de:	4b99      	ldr	r3, [pc, #612]	; (8109344 <HAL_RCCEx_GetPLL2ClockFreq+0x290>)
 81090e0:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 81090e2:	08db      	lsrs	r3, r3, #3
 81090e4:	f3c3 030c 	ubfx	r3, r3, #0, #13
 81090e8:	693a      	ldr	r2, [r7, #16]
 81090ea:	fb02 f303 	mul.w	r3, r2, r3
 81090ee:	ee07 3a90 	vmov	s15, r3
 81090f2:	eef8 7a67 	vcvt.f32.u32	s15, s15
 81090f6:	edc7 7a03 	vstr	s15, [r7, #12]

  if (pll2m != 0U)
 81090fa:	697b      	ldr	r3, [r7, #20]
 81090fc:	2b00      	cmp	r3, #0
 81090fe:	f000 8111 	beq.w	8109324 <HAL_RCCEx_GetPLL2ClockFreq+0x270>
  {
    switch (pllsource)
 8109102:	69bb      	ldr	r3, [r7, #24]
 8109104:	2b02      	cmp	r3, #2
 8109106:	f000 8083 	beq.w	8109210 <HAL_RCCEx_GetPLL2ClockFreq+0x15c>
 810910a:	69bb      	ldr	r3, [r7, #24]
 810910c:	2b02      	cmp	r3, #2
 810910e:	f200 80a1 	bhi.w	8109254 <HAL_RCCEx_GetPLL2ClockFreq+0x1a0>
 8109112:	69bb      	ldr	r3, [r7, #24]
 8109114:	2b00      	cmp	r3, #0
 8109116:	d003      	beq.n	8109120 <HAL_RCCEx_GetPLL2ClockFreq+0x6c>
 8109118:	69bb      	ldr	r3, [r7, #24]
 810911a:	2b01      	cmp	r3, #1
 810911c:	d056      	beq.n	81091cc <HAL_RCCEx_GetPLL2ClockFreq+0x118>
 810911e:	e099      	b.n	8109254 <HAL_RCCEx_GetPLL2ClockFreq+0x1a0>
    {

      case RCC_PLLSOURCE_HSI:  /* HSI used as PLL clock source */

        if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIV) != 0U)
 8109120:	4b88      	ldr	r3, [pc, #544]	; (8109344 <HAL_RCCEx_GetPLL2ClockFreq+0x290>)
 8109122:	681b      	ldr	r3, [r3, #0]
 8109124:	f003 0320 	and.w	r3, r3, #32
 8109128:	2b00      	cmp	r3, #0
 810912a:	d02d      	beq.n	8109188 <HAL_RCCEx_GetPLL2ClockFreq+0xd4>
        {
          hsivalue = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> 3));
 810912c:	4b85      	ldr	r3, [pc, #532]	; (8109344 <HAL_RCCEx_GetPLL2ClockFreq+0x290>)
 810912e:	681b      	ldr	r3, [r3, #0]
 8109130:	08db      	lsrs	r3, r3, #3
 8109132:	f003 0303 	and.w	r3, r3, #3
 8109136:	4a84      	ldr	r2, [pc, #528]	; (8109348 <HAL_RCCEx_GetPLL2ClockFreq+0x294>)
 8109138:	fa22 f303 	lsr.w	r3, r2, r3
 810913c:	60bb      	str	r3, [r7, #8]
          pll2vco = ((float_t)hsivalue / (float_t)pll2m) * ((float_t)(uint32_t)(RCC->PLL2DIVR & RCC_PLL2DIVR_N2) + (fracn2 / (float_t)0x2000) + (float_t)1);
 810913e:	68bb      	ldr	r3, [r7, #8]
 8109140:	ee07 3a90 	vmov	s15, r3
 8109144:	eef8 6a67 	vcvt.f32.u32	s13, s15
 8109148:	697b      	ldr	r3, [r7, #20]
 810914a:	ee07 3a90 	vmov	s15, r3
 810914e:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8109152:	ee86 7aa7 	vdiv.f32	s14, s13, s15
 8109156:	4b7b      	ldr	r3, [pc, #492]	; (8109344 <HAL_RCCEx_GetPLL2ClockFreq+0x290>)
 8109158:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 810915a:	f3c3 0308 	ubfx	r3, r3, #0, #9
 810915e:	ee07 3a90 	vmov	s15, r3
 8109162:	eef8 6a67 	vcvt.f32.u32	s13, s15
 8109166:	ed97 6a03 	vldr	s12, [r7, #12]
 810916a:	eddf 5a78 	vldr	s11, [pc, #480]	; 810934c <HAL_RCCEx_GetPLL2ClockFreq+0x298>
 810916e:	eec6 7a25 	vdiv.f32	s15, s12, s11
 8109172:	ee76 7aa7 	vadd.f32	s15, s13, s15
 8109176:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
 810917a:	ee77 7aa6 	vadd.f32	s15, s15, s13
 810917e:	ee67 7a27 	vmul.f32	s15, s14, s15
 8109182:	edc7 7a07 	vstr	s15, [r7, #28]
        }
        else
        {
          pll2vco = ((float_t)HSI_VALUE / (float_t)pll2m) * ((float_t)(uint32_t)(RCC->PLL2DIVR & RCC_PLL2DIVR_N2) + (fracn2 / (float_t)0x2000) + (float_t)1);
        }
        break;
 8109186:	e087      	b.n	8109298 <HAL_RCCEx_GetPLL2ClockFreq+0x1e4>
          pll2vco = ((float_t)HSI_VALUE / (float_t)pll2m) * ((float_t)(uint32_t)(RCC->PLL2DIVR & RCC_PLL2DIVR_N2) + (fracn2 / (float_t)0x2000) + (float_t)1);
 8109188:	697b      	ldr	r3, [r7, #20]
 810918a:	ee07 3a90 	vmov	s15, r3
 810918e:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8109192:	eddf 6a6f 	vldr	s13, [pc, #444]	; 8109350 <HAL_RCCEx_GetPLL2ClockFreq+0x29c>
 8109196:	ee86 7aa7 	vdiv.f32	s14, s13, s15
 810919a:	4b6a      	ldr	r3, [pc, #424]	; (8109344 <HAL_RCCEx_GetPLL2ClockFreq+0x290>)
 810919c:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 810919e:	f3c3 0308 	ubfx	r3, r3, #0, #9
 81091a2:	ee07 3a90 	vmov	s15, r3
 81091a6:	eef8 6a67 	vcvt.f32.u32	s13, s15
 81091aa:	ed97 6a03 	vldr	s12, [r7, #12]
 81091ae:	eddf 5a67 	vldr	s11, [pc, #412]	; 810934c <HAL_RCCEx_GetPLL2ClockFreq+0x298>
 81091b2:	eec6 7a25 	vdiv.f32	s15, s12, s11
 81091b6:	ee76 7aa7 	vadd.f32	s15, s13, s15
 81091ba:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
 81091be:	ee77 7aa6 	vadd.f32	s15, s15, s13
 81091c2:	ee67 7a27 	vmul.f32	s15, s14, s15
 81091c6:	edc7 7a07 	vstr	s15, [r7, #28]
        break;
 81091ca:	e065      	b.n	8109298 <HAL_RCCEx_GetPLL2ClockFreq+0x1e4>

      case RCC_PLLSOURCE_CSI:  /* CSI used as PLL clock source */
        pll2vco = ((float_t)CSI_VALUE / (float_t)pll2m) * ((float_t)(uint32_t)(RCC->PLL2DIVR & RCC_PLL2DIVR_N2) + (fracn2 / (float_t)0x2000) + (float_t)1);
 81091cc:	697b      	ldr	r3, [r7, #20]
 81091ce:	ee07 3a90 	vmov	s15, r3
 81091d2:	eef8 7a67 	vcvt.f32.u32	s15, s15
 81091d6:	eddf 6a5f 	vldr	s13, [pc, #380]	; 8109354 <HAL_RCCEx_GetPLL2ClockFreq+0x2a0>
 81091da:	ee86 7aa7 	vdiv.f32	s14, s13, s15
 81091de:	4b59      	ldr	r3, [pc, #356]	; (8109344 <HAL_RCCEx_GetPLL2ClockFreq+0x290>)
 81091e0:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 81091e2:	f3c3 0308 	ubfx	r3, r3, #0, #9
 81091e6:	ee07 3a90 	vmov	s15, r3
 81091ea:	eef8 6a67 	vcvt.f32.u32	s13, s15
 81091ee:	ed97 6a03 	vldr	s12, [r7, #12]
 81091f2:	eddf 5a56 	vldr	s11, [pc, #344]	; 810934c <HAL_RCCEx_GetPLL2ClockFreq+0x298>
 81091f6:	eec6 7a25 	vdiv.f32	s15, s12, s11
 81091fa:	ee76 7aa7 	vadd.f32	s15, s13, s15
 81091fe:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
 8109202:	ee77 7aa6 	vadd.f32	s15, s15, s13
 8109206:	ee67 7a27 	vmul.f32	s15, s14, s15
 810920a:	edc7 7a07 	vstr	s15, [r7, #28]
        break;
 810920e:	e043      	b.n	8109298 <HAL_RCCEx_GetPLL2ClockFreq+0x1e4>

      case RCC_PLLSOURCE_HSE:  /* HSE used as PLL clock source */
        pll2vco = ((float_t)HSE_VALUE / (float_t)pll2m) * ((float_t)(uint32_t)(RCC->PLL2DIVR & RCC_PLL2DIVR_N2) + (fracn2 / (float_t)0x2000) + (float_t)1);
 8109210:	697b      	ldr	r3, [r7, #20]
 8109212:	ee07 3a90 	vmov	s15, r3
 8109216:	eef8 7a67 	vcvt.f32.u32	s15, s15
 810921a:	eddf 6a4f 	vldr	s13, [pc, #316]	; 8109358 <HAL_RCCEx_GetPLL2ClockFreq+0x2a4>
 810921e:	ee86 7aa7 	vdiv.f32	s14, s13, s15
 8109222:	4b48      	ldr	r3, [pc, #288]	; (8109344 <HAL_RCCEx_GetPLL2ClockFreq+0x290>)
 8109224:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8109226:	f3c3 0308 	ubfx	r3, r3, #0, #9
 810922a:	ee07 3a90 	vmov	s15, r3
 810922e:	eef8 6a67 	vcvt.f32.u32	s13, s15
 8109232:	ed97 6a03 	vldr	s12, [r7, #12]
 8109236:	eddf 5a45 	vldr	s11, [pc, #276]	; 810934c <HAL_RCCEx_GetPLL2ClockFreq+0x298>
 810923a:	eec6 7a25 	vdiv.f32	s15, s12, s11
 810923e:	ee76 7aa7 	vadd.f32	s15, s13, s15
 8109242:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
 8109246:	ee77 7aa6 	vadd.f32	s15, s15, s13
 810924a:	ee67 7a27 	vmul.f32	s15, s14, s15
 810924e:	edc7 7a07 	vstr	s15, [r7, #28]
        break;
 8109252:	e021      	b.n	8109298 <HAL_RCCEx_GetPLL2ClockFreq+0x1e4>

      default:
        pll2vco = ((float_t)CSI_VALUE / (float_t)pll2m) * ((float_t)(uint32_t)(RCC->PLL2DIVR & RCC_PLL2DIVR_N2) + (fracn2 / (float_t)0x2000) + (float_t)1);
 8109254:	697b      	ldr	r3, [r7, #20]
 8109256:	ee07 3a90 	vmov	s15, r3
 810925a:	eef8 7a67 	vcvt.f32.u32	s15, s15
 810925e:	eddf 6a3d 	vldr	s13, [pc, #244]	; 8109354 <HAL_RCCEx_GetPLL2ClockFreq+0x2a0>
 8109262:	ee86 7aa7 	vdiv.f32	s14, s13, s15
 8109266:	4b37      	ldr	r3, [pc, #220]	; (8109344 <HAL_RCCEx_GetPLL2ClockFreq+0x290>)
 8109268:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 810926a:	f3c3 0308 	ubfx	r3, r3, #0, #9
 810926e:	ee07 3a90 	vmov	s15, r3
 8109272:	eef8 6a67 	vcvt.f32.u32	s13, s15
 8109276:	ed97 6a03 	vldr	s12, [r7, #12]
 810927a:	eddf 5a34 	vldr	s11, [pc, #208]	; 810934c <HAL_RCCEx_GetPLL2ClockFreq+0x298>
 810927e:	eec6 7a25 	vdiv.f32	s15, s12, s11
 8109282:	ee76 7aa7 	vadd.f32	s15, s13, s15
 8109286:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
 810928a:	ee77 7aa6 	vadd.f32	s15, s15, s13
 810928e:	ee67 7a27 	vmul.f32	s15, s14, s15
 8109292:	edc7 7a07 	vstr	s15, [r7, #28]
        break;
 8109296:	bf00      	nop
    }
    PLL2_Clocks->PLL2_P_Frequency = (uint32_t)(float_t)(pll2vco / ((float_t)(uint32_t)((RCC->PLL2DIVR & RCC_PLL2DIVR_P2) >> 9)  + (float_t)1)) ;
 8109298:	4b2a      	ldr	r3, [pc, #168]	; (8109344 <HAL_RCCEx_GetPLL2ClockFreq+0x290>)
 810929a:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 810929c:	0a5b      	lsrs	r3, r3, #9
 810929e:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 81092a2:	ee07 3a90 	vmov	s15, r3
 81092a6:	eef8 7a67 	vcvt.f32.u32	s15, s15
 81092aa:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
 81092ae:	ee37 7a87 	vadd.f32	s14, s15, s14
 81092b2:	edd7 6a07 	vldr	s13, [r7, #28]
 81092b6:	eec6 7a87 	vdiv.f32	s15, s13, s14
 81092ba:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 81092be:	ee17 2a90 	vmov	r2, s15
 81092c2:	687b      	ldr	r3, [r7, #4]
 81092c4:	601a      	str	r2, [r3, #0]
    PLL2_Clocks->PLL2_Q_Frequency = (uint32_t)(float_t)(pll2vco / ((float_t)(uint32_t)((RCC->PLL2DIVR & RCC_PLL2DIVR_Q2) >> 16) + (float_t)1)) ;
 81092c6:	4b1f      	ldr	r3, [pc, #124]	; (8109344 <HAL_RCCEx_GetPLL2ClockFreq+0x290>)
 81092c8:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 81092ca:	0c1b      	lsrs	r3, r3, #16
 81092cc:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 81092d0:	ee07 3a90 	vmov	s15, r3
 81092d4:	eef8 7a67 	vcvt.f32.u32	s15, s15
 81092d8:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
 81092dc:	ee37 7a87 	vadd.f32	s14, s15, s14
 81092e0:	edd7 6a07 	vldr	s13, [r7, #28]
 81092e4:	eec6 7a87 	vdiv.f32	s15, s13, s14
 81092e8:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 81092ec:	ee17 2a90 	vmov	r2, s15
 81092f0:	687b      	ldr	r3, [r7, #4]
 81092f2:	605a      	str	r2, [r3, #4]
    PLL2_Clocks->PLL2_R_Frequency = (uint32_t)(float_t)(pll2vco / ((float_t)(uint32_t)((RCC->PLL2DIVR & RCC_PLL2DIVR_R2) >> 24) + (float_t)1)) ;
 81092f4:	4b13      	ldr	r3, [pc, #76]	; (8109344 <HAL_RCCEx_GetPLL2ClockFreq+0x290>)
 81092f6:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 81092f8:	0e1b      	lsrs	r3, r3, #24
 81092fa:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 81092fe:	ee07 3a90 	vmov	s15, r3
 8109302:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8109306:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
 810930a:	ee37 7a87 	vadd.f32	s14, s15, s14
 810930e:	edd7 6a07 	vldr	s13, [r7, #28]
 8109312:	eec6 7a87 	vdiv.f32	s15, s13, s14
 8109316:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 810931a:	ee17 2a90 	vmov	r2, s15
 810931e:	687b      	ldr	r3, [r7, #4]
 8109320:	609a      	str	r2, [r3, #8]
  {
    PLL2_Clocks->PLL2_P_Frequency = 0U;
    PLL2_Clocks->PLL2_Q_Frequency = 0U;
    PLL2_Clocks->PLL2_R_Frequency = 0U;
  }
}
 8109322:	e008      	b.n	8109336 <HAL_RCCEx_GetPLL2ClockFreq+0x282>
    PLL2_Clocks->PLL2_P_Frequency = 0U;
 8109324:	687b      	ldr	r3, [r7, #4]
 8109326:	2200      	movs	r2, #0
 8109328:	601a      	str	r2, [r3, #0]
    PLL2_Clocks->PLL2_Q_Frequency = 0U;
 810932a:	687b      	ldr	r3, [r7, #4]
 810932c:	2200      	movs	r2, #0
 810932e:	605a      	str	r2, [r3, #4]
    PLL2_Clocks->PLL2_R_Frequency = 0U;
 8109330:	687b      	ldr	r3, [r7, #4]
 8109332:	2200      	movs	r2, #0
 8109334:	609a      	str	r2, [r3, #8]
}
 8109336:	bf00      	nop
 8109338:	3724      	adds	r7, #36	; 0x24
 810933a:	46bd      	mov	sp, r7
 810933c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8109340:	4770      	bx	lr
 8109342:	bf00      	nop
 8109344:	58024400 	.word	0x58024400
 8109348:	03d09000 	.word	0x03d09000
 810934c:	46000000 	.word	0x46000000
 8109350:	4c742400 	.word	0x4c742400
 8109354:	4a742400 	.word	0x4a742400
 8109358:	4bbebc20 	.word	0x4bbebc20

0810935c <HAL_RCCEx_GetPLL3ClockFreq>:
  *         right PLL3CLK value. Otherwise, any configuration based on this function will be incorrect.
  * @param  PLL3_Clocks structure.
  * @retval None
  */
void HAL_RCCEx_GetPLL3ClockFreq(PLL3_ClocksTypeDef *PLL3_Clocks)
{
 810935c:	b480      	push	{r7}
 810935e:	b089      	sub	sp, #36	; 0x24
 8109360:	af00      	add	r7, sp, #0
 8109362:	6078      	str	r0, [r7, #4]
  float_t fracn3, pll3vco;

  /* PLL3_VCO = (HSE_VALUE or HSI_VALUE or CSI_VALUE/ PLL3M) * PLL3N
     PLL3xCLK = PLL3_VCO / PLLxR
  */
  pllsource = (RCC->PLLCKSELR & RCC_PLLCKSELR_PLLSRC);
 8109364:	4ba1      	ldr	r3, [pc, #644]	; (81095ec <HAL_RCCEx_GetPLL3ClockFreq+0x290>)
 8109366:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8109368:	f003 0303 	and.w	r3, r3, #3
 810936c:	61bb      	str	r3, [r7, #24]
  pll3m = ((RCC->PLLCKSELR & RCC_PLLCKSELR_DIVM3) >> 20)  ;
 810936e:	4b9f      	ldr	r3, [pc, #636]	; (81095ec <HAL_RCCEx_GetPLL3ClockFreq+0x290>)
 8109370:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8109372:	0d1b      	lsrs	r3, r3, #20
 8109374:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 8109378:	617b      	str	r3, [r7, #20]
  pll3fracen = (RCC->PLLCFGR & RCC_PLLCFGR_PLL3FRACEN) >> RCC_PLLCFGR_PLL3FRACEN_Pos;
 810937a:	4b9c      	ldr	r3, [pc, #624]	; (81095ec <HAL_RCCEx_GetPLL3ClockFreq+0x290>)
 810937c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 810937e:	0a1b      	lsrs	r3, r3, #8
 8109380:	f003 0301 	and.w	r3, r3, #1
 8109384:	613b      	str	r3, [r7, #16]
  fracn3 = (float_t)(uint32_t)(pll3fracen * ((RCC->PLL3FRACR & RCC_PLL3FRACR_FRACN3) >> 3));
 8109386:	4b99      	ldr	r3, [pc, #612]	; (81095ec <HAL_RCCEx_GetPLL3ClockFreq+0x290>)
 8109388:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 810938a:	08db      	lsrs	r3, r3, #3
 810938c:	f3c3 030c 	ubfx	r3, r3, #0, #13
 8109390:	693a      	ldr	r2, [r7, #16]
 8109392:	fb02 f303 	mul.w	r3, r2, r3
 8109396:	ee07 3a90 	vmov	s15, r3
 810939a:	eef8 7a67 	vcvt.f32.u32	s15, s15
 810939e:	edc7 7a03 	vstr	s15, [r7, #12]

  if (pll3m != 0U)
 81093a2:	697b      	ldr	r3, [r7, #20]
 81093a4:	2b00      	cmp	r3, #0
 81093a6:	f000 8111 	beq.w	81095cc <HAL_RCCEx_GetPLL3ClockFreq+0x270>
  {
    switch (pllsource)
 81093aa:	69bb      	ldr	r3, [r7, #24]
 81093ac:	2b02      	cmp	r3, #2
 81093ae:	f000 8083 	beq.w	81094b8 <HAL_RCCEx_GetPLL3ClockFreq+0x15c>
 81093b2:	69bb      	ldr	r3, [r7, #24]
 81093b4:	2b02      	cmp	r3, #2
 81093b6:	f200 80a1 	bhi.w	81094fc <HAL_RCCEx_GetPLL3ClockFreq+0x1a0>
 81093ba:	69bb      	ldr	r3, [r7, #24]
 81093bc:	2b00      	cmp	r3, #0
 81093be:	d003      	beq.n	81093c8 <HAL_RCCEx_GetPLL3ClockFreq+0x6c>
 81093c0:	69bb      	ldr	r3, [r7, #24]
 81093c2:	2b01      	cmp	r3, #1
 81093c4:	d056      	beq.n	8109474 <HAL_RCCEx_GetPLL3ClockFreq+0x118>
 81093c6:	e099      	b.n	81094fc <HAL_RCCEx_GetPLL3ClockFreq+0x1a0>
    {
      case RCC_PLLSOURCE_HSI:  /* HSI used as PLL clock source */

        if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIV) != 0U)
 81093c8:	4b88      	ldr	r3, [pc, #544]	; (81095ec <HAL_RCCEx_GetPLL3ClockFreq+0x290>)
 81093ca:	681b      	ldr	r3, [r3, #0]
 81093cc:	f003 0320 	and.w	r3, r3, #32
 81093d0:	2b00      	cmp	r3, #0
 81093d2:	d02d      	beq.n	8109430 <HAL_RCCEx_GetPLL3ClockFreq+0xd4>
        {
          hsivalue = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> 3));
 81093d4:	4b85      	ldr	r3, [pc, #532]	; (81095ec <HAL_RCCEx_GetPLL3ClockFreq+0x290>)
 81093d6:	681b      	ldr	r3, [r3, #0]
 81093d8:	08db      	lsrs	r3, r3, #3
 81093da:	f003 0303 	and.w	r3, r3, #3
 81093de:	4a84      	ldr	r2, [pc, #528]	; (81095f0 <HAL_RCCEx_GetPLL3ClockFreq+0x294>)
 81093e0:	fa22 f303 	lsr.w	r3, r2, r3
 81093e4:	60bb      	str	r3, [r7, #8]
          pll3vco = ((float_t)hsivalue / (float_t)pll3m) * ((float_t)(uint32_t)(RCC->PLL3DIVR & RCC_PLL3DIVR_N3) + (fracn3 / (float_t)0x2000) + (float_t)1);
 81093e6:	68bb      	ldr	r3, [r7, #8]
 81093e8:	ee07 3a90 	vmov	s15, r3
 81093ec:	eef8 6a67 	vcvt.f32.u32	s13, s15
 81093f0:	697b      	ldr	r3, [r7, #20]
 81093f2:	ee07 3a90 	vmov	s15, r3
 81093f6:	eef8 7a67 	vcvt.f32.u32	s15, s15
 81093fa:	ee86 7aa7 	vdiv.f32	s14, s13, s15
 81093fe:	4b7b      	ldr	r3, [pc, #492]	; (81095ec <HAL_RCCEx_GetPLL3ClockFreq+0x290>)
 8109400:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8109402:	f3c3 0308 	ubfx	r3, r3, #0, #9
 8109406:	ee07 3a90 	vmov	s15, r3
 810940a:	eef8 6a67 	vcvt.f32.u32	s13, s15
 810940e:	ed97 6a03 	vldr	s12, [r7, #12]
 8109412:	eddf 5a78 	vldr	s11, [pc, #480]	; 81095f4 <HAL_RCCEx_GetPLL3ClockFreq+0x298>
 8109416:	eec6 7a25 	vdiv.f32	s15, s12, s11
 810941a:	ee76 7aa7 	vadd.f32	s15, s13, s15
 810941e:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
 8109422:	ee77 7aa6 	vadd.f32	s15, s15, s13
 8109426:	ee67 7a27 	vmul.f32	s15, s14, s15
 810942a:	edc7 7a07 	vstr	s15, [r7, #28]
        }
        else
        {
          pll3vco = ((float_t)HSI_VALUE / (float_t)pll3m) * ((float_t)(uint32_t)(RCC->PLL3DIVR & RCC_PLL3DIVR_N3) + (fracn3 / (float_t)0x2000) + (float_t)1);
        }
        break;
 810942e:	e087      	b.n	8109540 <HAL_RCCEx_GetPLL3ClockFreq+0x1e4>
          pll3vco = ((float_t)HSI_VALUE / (float_t)pll3m) * ((float_t)(uint32_t)(RCC->PLL3DIVR & RCC_PLL3DIVR_N3) + (fracn3 / (float_t)0x2000) + (float_t)1);
 8109430:	697b      	ldr	r3, [r7, #20]
 8109432:	ee07 3a90 	vmov	s15, r3
 8109436:	eef8 7a67 	vcvt.f32.u32	s15, s15
 810943a:	eddf 6a6f 	vldr	s13, [pc, #444]	; 81095f8 <HAL_RCCEx_GetPLL3ClockFreq+0x29c>
 810943e:	ee86 7aa7 	vdiv.f32	s14, s13, s15
 8109442:	4b6a      	ldr	r3, [pc, #424]	; (81095ec <HAL_RCCEx_GetPLL3ClockFreq+0x290>)
 8109444:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8109446:	f3c3 0308 	ubfx	r3, r3, #0, #9
 810944a:	ee07 3a90 	vmov	s15, r3
 810944e:	eef8 6a67 	vcvt.f32.u32	s13, s15
 8109452:	ed97 6a03 	vldr	s12, [r7, #12]
 8109456:	eddf 5a67 	vldr	s11, [pc, #412]	; 81095f4 <HAL_RCCEx_GetPLL3ClockFreq+0x298>
 810945a:	eec6 7a25 	vdiv.f32	s15, s12, s11
 810945e:	ee76 7aa7 	vadd.f32	s15, s13, s15
 8109462:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
 8109466:	ee77 7aa6 	vadd.f32	s15, s15, s13
 810946a:	ee67 7a27 	vmul.f32	s15, s14, s15
 810946e:	edc7 7a07 	vstr	s15, [r7, #28]
        break;
 8109472:	e065      	b.n	8109540 <HAL_RCCEx_GetPLL3ClockFreq+0x1e4>
      case RCC_PLLSOURCE_CSI:  /* CSI used as PLL clock source */
        pll3vco = ((float_t)CSI_VALUE / (float_t)pll3m) * ((float_t)(uint32_t)(RCC->PLL3DIVR & RCC_PLL3DIVR_N3) + (fracn3 / (float_t)0x2000) + (float_t)1);
 8109474:	697b      	ldr	r3, [r7, #20]
 8109476:	ee07 3a90 	vmov	s15, r3
 810947a:	eef8 7a67 	vcvt.f32.u32	s15, s15
 810947e:	eddf 6a5f 	vldr	s13, [pc, #380]	; 81095fc <HAL_RCCEx_GetPLL3ClockFreq+0x2a0>
 8109482:	ee86 7aa7 	vdiv.f32	s14, s13, s15
 8109486:	4b59      	ldr	r3, [pc, #356]	; (81095ec <HAL_RCCEx_GetPLL3ClockFreq+0x290>)
 8109488:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 810948a:	f3c3 0308 	ubfx	r3, r3, #0, #9
 810948e:	ee07 3a90 	vmov	s15, r3
 8109492:	eef8 6a67 	vcvt.f32.u32	s13, s15
 8109496:	ed97 6a03 	vldr	s12, [r7, #12]
 810949a:	eddf 5a56 	vldr	s11, [pc, #344]	; 81095f4 <HAL_RCCEx_GetPLL3ClockFreq+0x298>
 810949e:	eec6 7a25 	vdiv.f32	s15, s12, s11
 81094a2:	ee76 7aa7 	vadd.f32	s15, s13, s15
 81094a6:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
 81094aa:	ee77 7aa6 	vadd.f32	s15, s15, s13
 81094ae:	ee67 7a27 	vmul.f32	s15, s14, s15
 81094b2:	edc7 7a07 	vstr	s15, [r7, #28]
        break;
 81094b6:	e043      	b.n	8109540 <HAL_RCCEx_GetPLL3ClockFreq+0x1e4>

      case RCC_PLLSOURCE_HSE:  /* HSE used as PLL clock source */
        pll3vco = ((float_t)HSE_VALUE / (float_t)pll3m) * ((float_t)(uint32_t)(RCC->PLL3DIVR & RCC_PLL3DIVR_N3) + (fracn3 / (float_t)0x2000) + (float_t)1);
 81094b8:	697b      	ldr	r3, [r7, #20]
 81094ba:	ee07 3a90 	vmov	s15, r3
 81094be:	eef8 7a67 	vcvt.f32.u32	s15, s15
 81094c2:	eddf 6a4f 	vldr	s13, [pc, #316]	; 8109600 <HAL_RCCEx_GetPLL3ClockFreq+0x2a4>
 81094c6:	ee86 7aa7 	vdiv.f32	s14, s13, s15
 81094ca:	4b48      	ldr	r3, [pc, #288]	; (81095ec <HAL_RCCEx_GetPLL3ClockFreq+0x290>)
 81094cc:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 81094ce:	f3c3 0308 	ubfx	r3, r3, #0, #9
 81094d2:	ee07 3a90 	vmov	s15, r3
 81094d6:	eef8 6a67 	vcvt.f32.u32	s13, s15
 81094da:	ed97 6a03 	vldr	s12, [r7, #12]
 81094de:	eddf 5a45 	vldr	s11, [pc, #276]	; 81095f4 <HAL_RCCEx_GetPLL3ClockFreq+0x298>
 81094e2:	eec6 7a25 	vdiv.f32	s15, s12, s11
 81094e6:	ee76 7aa7 	vadd.f32	s15, s13, s15
 81094ea:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
 81094ee:	ee77 7aa6 	vadd.f32	s15, s15, s13
 81094f2:	ee67 7a27 	vmul.f32	s15, s14, s15
 81094f6:	edc7 7a07 	vstr	s15, [r7, #28]
        break;
 81094fa:	e021      	b.n	8109540 <HAL_RCCEx_GetPLL3ClockFreq+0x1e4>

      default:
        pll3vco = ((float_t)CSI_VALUE / (float_t)pll3m) * ((float_t)(uint32_t)(RCC->PLL3DIVR & RCC_PLL3DIVR_N3) + (fracn3 / (float_t)0x2000) + (float_t)1);
 81094fc:	697b      	ldr	r3, [r7, #20]
 81094fe:	ee07 3a90 	vmov	s15, r3
 8109502:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8109506:	eddf 6a3d 	vldr	s13, [pc, #244]	; 81095fc <HAL_RCCEx_GetPLL3ClockFreq+0x2a0>
 810950a:	ee86 7aa7 	vdiv.f32	s14, s13, s15
 810950e:	4b37      	ldr	r3, [pc, #220]	; (81095ec <HAL_RCCEx_GetPLL3ClockFreq+0x290>)
 8109510:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8109512:	f3c3 0308 	ubfx	r3, r3, #0, #9
 8109516:	ee07 3a90 	vmov	s15, r3
 810951a:	eef8 6a67 	vcvt.f32.u32	s13, s15
 810951e:	ed97 6a03 	vldr	s12, [r7, #12]
 8109522:	eddf 5a34 	vldr	s11, [pc, #208]	; 81095f4 <HAL_RCCEx_GetPLL3ClockFreq+0x298>
 8109526:	eec6 7a25 	vdiv.f32	s15, s12, s11
 810952a:	ee76 7aa7 	vadd.f32	s15, s13, s15
 810952e:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
 8109532:	ee77 7aa6 	vadd.f32	s15, s15, s13
 8109536:	ee67 7a27 	vmul.f32	s15, s14, s15
 810953a:	edc7 7a07 	vstr	s15, [r7, #28]
        break;
 810953e:	bf00      	nop
    }
    PLL3_Clocks->PLL3_P_Frequency = (uint32_t)(float_t)(pll3vco / ((float_t)(uint32_t)((RCC->PLL3DIVR & RCC_PLL3DIVR_P3) >> 9)  + (float_t)1)) ;
 8109540:	4b2a      	ldr	r3, [pc, #168]	; (81095ec <HAL_RCCEx_GetPLL3ClockFreq+0x290>)
 8109542:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8109544:	0a5b      	lsrs	r3, r3, #9
 8109546:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 810954a:	ee07 3a90 	vmov	s15, r3
 810954e:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8109552:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
 8109556:	ee37 7a87 	vadd.f32	s14, s15, s14
 810955a:	edd7 6a07 	vldr	s13, [r7, #28]
 810955e:	eec6 7a87 	vdiv.f32	s15, s13, s14
 8109562:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 8109566:	ee17 2a90 	vmov	r2, s15
 810956a:	687b      	ldr	r3, [r7, #4]
 810956c:	601a      	str	r2, [r3, #0]
    PLL3_Clocks->PLL3_Q_Frequency = (uint32_t)(float_t)(pll3vco / ((float_t)(uint32_t)((RCC->PLL3DIVR & RCC_PLL3DIVR_Q3) >> 16) + (float_t)1)) ;
 810956e:	4b1f      	ldr	r3, [pc, #124]	; (81095ec <HAL_RCCEx_GetPLL3ClockFreq+0x290>)
 8109570:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8109572:	0c1b      	lsrs	r3, r3, #16
 8109574:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 8109578:	ee07 3a90 	vmov	s15, r3
 810957c:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8109580:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
 8109584:	ee37 7a87 	vadd.f32	s14, s15, s14
 8109588:	edd7 6a07 	vldr	s13, [r7, #28]
 810958c:	eec6 7a87 	vdiv.f32	s15, s13, s14
 8109590:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 8109594:	ee17 2a90 	vmov	r2, s15
 8109598:	687b      	ldr	r3, [r7, #4]
 810959a:	605a      	str	r2, [r3, #4]
    PLL3_Clocks->PLL3_R_Frequency = (uint32_t)(float_t)(pll3vco / ((float_t)(uint32_t)((RCC->PLL3DIVR & RCC_PLL3DIVR_R3) >> 24) + (float_t)1)) ;
 810959c:	4b13      	ldr	r3, [pc, #76]	; (81095ec <HAL_RCCEx_GetPLL3ClockFreq+0x290>)
 810959e:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 81095a0:	0e1b      	lsrs	r3, r3, #24
 81095a2:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 81095a6:	ee07 3a90 	vmov	s15, r3
 81095aa:	eef8 7a67 	vcvt.f32.u32	s15, s15
 81095ae:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
 81095b2:	ee37 7a87 	vadd.f32	s14, s15, s14
 81095b6:	edd7 6a07 	vldr	s13, [r7, #28]
 81095ba:	eec6 7a87 	vdiv.f32	s15, s13, s14
 81095be:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 81095c2:	ee17 2a90 	vmov	r2, s15
 81095c6:	687b      	ldr	r3, [r7, #4]
 81095c8:	609a      	str	r2, [r3, #8]
    PLL3_Clocks->PLL3_P_Frequency = 0U;
    PLL3_Clocks->PLL3_Q_Frequency = 0U;
    PLL3_Clocks->PLL3_R_Frequency = 0U;
  }

}
 81095ca:	e008      	b.n	81095de <HAL_RCCEx_GetPLL3ClockFreq+0x282>
    PLL3_Clocks->PLL3_P_Frequency = 0U;
 81095cc:	687b      	ldr	r3, [r7, #4]
 81095ce:	2200      	movs	r2, #0
 81095d0:	601a      	str	r2, [r3, #0]
    PLL3_Clocks->PLL3_Q_Frequency = 0U;
 81095d2:	687b      	ldr	r3, [r7, #4]
 81095d4:	2200      	movs	r2, #0
 81095d6:	605a      	str	r2, [r3, #4]
    PLL3_Clocks->PLL3_R_Frequency = 0U;
 81095d8:	687b      	ldr	r3, [r7, #4]
 81095da:	2200      	movs	r2, #0
 81095dc:	609a      	str	r2, [r3, #8]
}
 81095de:	bf00      	nop
 81095e0:	3724      	adds	r7, #36	; 0x24
 81095e2:	46bd      	mov	sp, r7
 81095e4:	f85d 7b04 	ldr.w	r7, [sp], #4
 81095e8:	4770      	bx	lr
 81095ea:	bf00      	nop
 81095ec:	58024400 	.word	0x58024400
 81095f0:	03d09000 	.word	0x03d09000
 81095f4:	46000000 	.word	0x46000000
 81095f8:	4c742400 	.word	0x4c742400
 81095fc:	4a742400 	.word	0x4a742400
 8109600:	4bbebc20 	.word	0x4bbebc20

08109604 <HAL_RCCEx_GetPLL1ClockFreq>:
  *         right PLL1CLK value. Otherwise, any configuration based on this function will be incorrect.
  * @param  PLL1_Clocks structure.
  * @retval None
  */
void HAL_RCCEx_GetPLL1ClockFreq(PLL1_ClocksTypeDef *PLL1_Clocks)
{
 8109604:	b480      	push	{r7}
 8109606:	b089      	sub	sp, #36	; 0x24
 8109608:	af00      	add	r7, sp, #0
 810960a:	6078      	str	r0, [r7, #4]
  uint32_t pllsource, pll1m, pll1fracen, hsivalue;
  float_t fracn1, pll1vco;

  pllsource = (RCC->PLLCKSELR & RCC_PLLCKSELR_PLLSRC);
 810960c:	4ba0      	ldr	r3, [pc, #640]	; (8109890 <HAL_RCCEx_GetPLL1ClockFreq+0x28c>)
 810960e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8109610:	f003 0303 	and.w	r3, r3, #3
 8109614:	61bb      	str	r3, [r7, #24]
  pll1m = ((RCC->PLLCKSELR & RCC_PLLCKSELR_DIVM1) >> 4);
 8109616:	4b9e      	ldr	r3, [pc, #632]	; (8109890 <HAL_RCCEx_GetPLL1ClockFreq+0x28c>)
 8109618:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 810961a:	091b      	lsrs	r3, r3, #4
 810961c:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 8109620:	617b      	str	r3, [r7, #20]
  pll1fracen = RCC->PLLCFGR & RCC_PLLCFGR_PLL1FRACEN;
 8109622:	4b9b      	ldr	r3, [pc, #620]	; (8109890 <HAL_RCCEx_GetPLL1ClockFreq+0x28c>)
 8109624:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8109626:	f003 0301 	and.w	r3, r3, #1
 810962a:	613b      	str	r3, [r7, #16]
  fracn1 = (float_t)(uint32_t)(pll1fracen * ((RCC->PLL1FRACR & RCC_PLL1FRACR_FRACN1) >> 3));
 810962c:	4b98      	ldr	r3, [pc, #608]	; (8109890 <HAL_RCCEx_GetPLL1ClockFreq+0x28c>)
 810962e:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8109630:	08db      	lsrs	r3, r3, #3
 8109632:	f3c3 030c 	ubfx	r3, r3, #0, #13
 8109636:	693a      	ldr	r2, [r7, #16]
 8109638:	fb02 f303 	mul.w	r3, r2, r3
 810963c:	ee07 3a90 	vmov	s15, r3
 8109640:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8109644:	edc7 7a03 	vstr	s15, [r7, #12]

  if (pll1m != 0U)
 8109648:	697b      	ldr	r3, [r7, #20]
 810964a:	2b00      	cmp	r3, #0
 810964c:	f000 8111 	beq.w	8109872 <HAL_RCCEx_GetPLL1ClockFreq+0x26e>
  {
    switch (pllsource)
 8109650:	69bb      	ldr	r3, [r7, #24]
 8109652:	2b02      	cmp	r3, #2
 8109654:	f000 8083 	beq.w	810975e <HAL_RCCEx_GetPLL1ClockFreq+0x15a>
 8109658:	69bb      	ldr	r3, [r7, #24]
 810965a:	2b02      	cmp	r3, #2
 810965c:	f200 80a1 	bhi.w	81097a2 <HAL_RCCEx_GetPLL1ClockFreq+0x19e>
 8109660:	69bb      	ldr	r3, [r7, #24]
 8109662:	2b00      	cmp	r3, #0
 8109664:	d003      	beq.n	810966e <HAL_RCCEx_GetPLL1ClockFreq+0x6a>
 8109666:	69bb      	ldr	r3, [r7, #24]
 8109668:	2b01      	cmp	r3, #1
 810966a:	d056      	beq.n	810971a <HAL_RCCEx_GetPLL1ClockFreq+0x116>
 810966c:	e099      	b.n	81097a2 <HAL_RCCEx_GetPLL1ClockFreq+0x19e>
    {

      case RCC_PLLSOURCE_HSI:  /* HSI used as PLL clock source */

        if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIV) != 0U)
 810966e:	4b88      	ldr	r3, [pc, #544]	; (8109890 <HAL_RCCEx_GetPLL1ClockFreq+0x28c>)
 8109670:	681b      	ldr	r3, [r3, #0]
 8109672:	f003 0320 	and.w	r3, r3, #32
 8109676:	2b00      	cmp	r3, #0
 8109678:	d02d      	beq.n	81096d6 <HAL_RCCEx_GetPLL1ClockFreq+0xd2>
        {
          hsivalue = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> 3));
 810967a:	4b85      	ldr	r3, [pc, #532]	; (8109890 <HAL_RCCEx_GetPLL1ClockFreq+0x28c>)
 810967c:	681b      	ldr	r3, [r3, #0]
 810967e:	08db      	lsrs	r3, r3, #3
 8109680:	f003 0303 	and.w	r3, r3, #3
 8109684:	4a83      	ldr	r2, [pc, #524]	; (8109894 <HAL_RCCEx_GetPLL1ClockFreq+0x290>)
 8109686:	fa22 f303 	lsr.w	r3, r2, r3
 810968a:	60bb      	str	r3, [r7, #8]
          pll1vco = ((float_t)hsivalue / (float_t)pll1m) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1 / (float_t)0x2000) + (float_t)1);
 810968c:	68bb      	ldr	r3, [r7, #8]
 810968e:	ee07 3a90 	vmov	s15, r3
 8109692:	eef8 6a67 	vcvt.f32.u32	s13, s15
 8109696:	697b      	ldr	r3, [r7, #20]
 8109698:	ee07 3a90 	vmov	s15, r3
 810969c:	eef8 7a67 	vcvt.f32.u32	s15, s15
 81096a0:	ee86 7aa7 	vdiv.f32	s14, s13, s15
 81096a4:	4b7a      	ldr	r3, [pc, #488]	; (8109890 <HAL_RCCEx_GetPLL1ClockFreq+0x28c>)
 81096a6:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 81096a8:	f3c3 0308 	ubfx	r3, r3, #0, #9
 81096ac:	ee07 3a90 	vmov	s15, r3
 81096b0:	eef8 6a67 	vcvt.f32.u32	s13, s15
 81096b4:	ed97 6a03 	vldr	s12, [r7, #12]
 81096b8:	eddf 5a77 	vldr	s11, [pc, #476]	; 8109898 <HAL_RCCEx_GetPLL1ClockFreq+0x294>
 81096bc:	eec6 7a25 	vdiv.f32	s15, s12, s11
 81096c0:	ee76 7aa7 	vadd.f32	s15, s13, s15
 81096c4:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
 81096c8:	ee77 7aa6 	vadd.f32	s15, s15, s13
 81096cc:	ee67 7a27 	vmul.f32	s15, s14, s15
 81096d0:	edc7 7a07 	vstr	s15, [r7, #28]
        }
        else
        {
          pll1vco = ((float_t)HSI_VALUE / (float_t)pll1m) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1 / (float_t)0x2000) + (float_t)1);
        }
        break;
 81096d4:	e087      	b.n	81097e6 <HAL_RCCEx_GetPLL1ClockFreq+0x1e2>
          pll1vco = ((float_t)HSI_VALUE / (float_t)pll1m) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1 / (float_t)0x2000) + (float_t)1);
 81096d6:	697b      	ldr	r3, [r7, #20]
 81096d8:	ee07 3a90 	vmov	s15, r3
 81096dc:	eef8 7a67 	vcvt.f32.u32	s15, s15
 81096e0:	eddf 6a6e 	vldr	s13, [pc, #440]	; 810989c <HAL_RCCEx_GetPLL1ClockFreq+0x298>
 81096e4:	ee86 7aa7 	vdiv.f32	s14, s13, s15
 81096e8:	4b69      	ldr	r3, [pc, #420]	; (8109890 <HAL_RCCEx_GetPLL1ClockFreq+0x28c>)
 81096ea:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 81096ec:	f3c3 0308 	ubfx	r3, r3, #0, #9
 81096f0:	ee07 3a90 	vmov	s15, r3
 81096f4:	eef8 6a67 	vcvt.f32.u32	s13, s15
 81096f8:	ed97 6a03 	vldr	s12, [r7, #12]
 81096fc:	eddf 5a66 	vldr	s11, [pc, #408]	; 8109898 <HAL_RCCEx_GetPLL1ClockFreq+0x294>
 8109700:	eec6 7a25 	vdiv.f32	s15, s12, s11
 8109704:	ee76 7aa7 	vadd.f32	s15, s13, s15
 8109708:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
 810970c:	ee77 7aa6 	vadd.f32	s15, s15, s13
 8109710:	ee67 7a27 	vmul.f32	s15, s14, s15
 8109714:	edc7 7a07 	vstr	s15, [r7, #28]
        break;
 8109718:	e065      	b.n	81097e6 <HAL_RCCEx_GetPLL1ClockFreq+0x1e2>
      case RCC_PLLSOURCE_CSI:  /* CSI used as PLL clock source */
        pll1vco = ((float_t)CSI_VALUE / (float_t)pll1m) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1 / (float_t)0x2000) + (float_t)1);
 810971a:	697b      	ldr	r3, [r7, #20]
 810971c:	ee07 3a90 	vmov	s15, r3
 8109720:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8109724:	eddf 6a5e 	vldr	s13, [pc, #376]	; 81098a0 <HAL_RCCEx_GetPLL1ClockFreq+0x29c>
 8109728:	ee86 7aa7 	vdiv.f32	s14, s13, s15
 810972c:	4b58      	ldr	r3, [pc, #352]	; (8109890 <HAL_RCCEx_GetPLL1ClockFreq+0x28c>)
 810972e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8109730:	f3c3 0308 	ubfx	r3, r3, #0, #9
 8109734:	ee07 3a90 	vmov	s15, r3
 8109738:	eef8 6a67 	vcvt.f32.u32	s13, s15
 810973c:	ed97 6a03 	vldr	s12, [r7, #12]
 8109740:	eddf 5a55 	vldr	s11, [pc, #340]	; 8109898 <HAL_RCCEx_GetPLL1ClockFreq+0x294>
 8109744:	eec6 7a25 	vdiv.f32	s15, s12, s11
 8109748:	ee76 7aa7 	vadd.f32	s15, s13, s15
 810974c:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
 8109750:	ee77 7aa6 	vadd.f32	s15, s15, s13
 8109754:	ee67 7a27 	vmul.f32	s15, s14, s15
 8109758:	edc7 7a07 	vstr	s15, [r7, #28]
        break;
 810975c:	e043      	b.n	81097e6 <HAL_RCCEx_GetPLL1ClockFreq+0x1e2>

      case RCC_PLLSOURCE_HSE:  /* HSE used as PLL clock source */
        pll1vco = ((float_t)HSE_VALUE / (float_t)pll1m) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1 / (float_t)0x2000) + (float_t)1);
 810975e:	697b      	ldr	r3, [r7, #20]
 8109760:	ee07 3a90 	vmov	s15, r3
 8109764:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8109768:	eddf 6a4e 	vldr	s13, [pc, #312]	; 81098a4 <HAL_RCCEx_GetPLL1ClockFreq+0x2a0>
 810976c:	ee86 7aa7 	vdiv.f32	s14, s13, s15
 8109770:	4b47      	ldr	r3, [pc, #284]	; (8109890 <HAL_RCCEx_GetPLL1ClockFreq+0x28c>)
 8109772:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8109774:	f3c3 0308 	ubfx	r3, r3, #0, #9
 8109778:	ee07 3a90 	vmov	s15, r3
 810977c:	eef8 6a67 	vcvt.f32.u32	s13, s15
 8109780:	ed97 6a03 	vldr	s12, [r7, #12]
 8109784:	eddf 5a44 	vldr	s11, [pc, #272]	; 8109898 <HAL_RCCEx_GetPLL1ClockFreq+0x294>
 8109788:	eec6 7a25 	vdiv.f32	s15, s12, s11
 810978c:	ee76 7aa7 	vadd.f32	s15, s13, s15
 8109790:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
 8109794:	ee77 7aa6 	vadd.f32	s15, s15, s13
 8109798:	ee67 7a27 	vmul.f32	s15, s14, s15
 810979c:	edc7 7a07 	vstr	s15, [r7, #28]
        break;
 81097a0:	e021      	b.n	81097e6 <HAL_RCCEx_GetPLL1ClockFreq+0x1e2>

      default:
        pll1vco = ((float_t)HSI_VALUE / (float_t)pll1m) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1 / (float_t)0x2000) + (float_t)1);
 81097a2:	697b      	ldr	r3, [r7, #20]
 81097a4:	ee07 3a90 	vmov	s15, r3
 81097a8:	eef8 7a67 	vcvt.f32.u32	s15, s15
 81097ac:	eddf 6a3b 	vldr	s13, [pc, #236]	; 810989c <HAL_RCCEx_GetPLL1ClockFreq+0x298>
 81097b0:	ee86 7aa7 	vdiv.f32	s14, s13, s15
 81097b4:	4b36      	ldr	r3, [pc, #216]	; (8109890 <HAL_RCCEx_GetPLL1ClockFreq+0x28c>)
 81097b6:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 81097b8:	f3c3 0308 	ubfx	r3, r3, #0, #9
 81097bc:	ee07 3a90 	vmov	s15, r3
 81097c0:	eef8 6a67 	vcvt.f32.u32	s13, s15
 81097c4:	ed97 6a03 	vldr	s12, [r7, #12]
 81097c8:	eddf 5a33 	vldr	s11, [pc, #204]	; 8109898 <HAL_RCCEx_GetPLL1ClockFreq+0x294>
 81097cc:	eec6 7a25 	vdiv.f32	s15, s12, s11
 81097d0:	ee76 7aa7 	vadd.f32	s15, s13, s15
 81097d4:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
 81097d8:	ee77 7aa6 	vadd.f32	s15, s15, s13
 81097dc:	ee67 7a27 	vmul.f32	s15, s14, s15
 81097e0:	edc7 7a07 	vstr	s15, [r7, #28]
        break;
 81097e4:	bf00      	nop
    }

    PLL1_Clocks->PLL1_P_Frequency = (uint32_t)(float_t)(pll1vco / ((float_t)(uint32_t)((RCC->PLL1DIVR & RCC_PLL1DIVR_P1) >> 9)  + (float_t)1)) ;
 81097e6:	4b2a      	ldr	r3, [pc, #168]	; (8109890 <HAL_RCCEx_GetPLL1ClockFreq+0x28c>)
 81097e8:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 81097ea:	0a5b      	lsrs	r3, r3, #9
 81097ec:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 81097f0:	ee07 3a90 	vmov	s15, r3
 81097f4:	eef8 7a67 	vcvt.f32.u32	s15, s15
 81097f8:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
 81097fc:	ee37 7a87 	vadd.f32	s14, s15, s14
 8109800:	edd7 6a07 	vldr	s13, [r7, #28]
 8109804:	eec6 7a87 	vdiv.f32	s15, s13, s14
 8109808:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 810980c:	ee17 2a90 	vmov	r2, s15
 8109810:	687b      	ldr	r3, [r7, #4]
 8109812:	601a      	str	r2, [r3, #0]
    PLL1_Clocks->PLL1_Q_Frequency = (uint32_t)(float_t)(pll1vco / ((float_t)(uint32_t)((RCC->PLL1DIVR & RCC_PLL1DIVR_Q1) >> 16) + (float_t)1)) ;
 8109814:	4b1e      	ldr	r3, [pc, #120]	; (8109890 <HAL_RCCEx_GetPLL1ClockFreq+0x28c>)
 8109816:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8109818:	0c1b      	lsrs	r3, r3, #16
 810981a:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 810981e:	ee07 3a90 	vmov	s15, r3
 8109822:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8109826:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
 810982a:	ee37 7a87 	vadd.f32	s14, s15, s14
 810982e:	edd7 6a07 	vldr	s13, [r7, #28]
 8109832:	eec6 7a87 	vdiv.f32	s15, s13, s14
 8109836:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 810983a:	ee17 2a90 	vmov	r2, s15
 810983e:	687b      	ldr	r3, [r7, #4]
 8109840:	605a      	str	r2, [r3, #4]
    PLL1_Clocks->PLL1_R_Frequency = (uint32_t)(float_t)(pll1vco / ((float_t)(uint32_t)((RCC->PLL1DIVR & RCC_PLL1DIVR_R1) >> 24) + (float_t)1)) ;
 8109842:	4b13      	ldr	r3, [pc, #76]	; (8109890 <HAL_RCCEx_GetPLL1ClockFreq+0x28c>)
 8109844:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8109846:	0e1b      	lsrs	r3, r3, #24
 8109848:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 810984c:	ee07 3a90 	vmov	s15, r3
 8109850:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8109854:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
 8109858:	ee37 7a87 	vadd.f32	s14, s15, s14
 810985c:	edd7 6a07 	vldr	s13, [r7, #28]
 8109860:	eec6 7a87 	vdiv.f32	s15, s13, s14
 8109864:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 8109868:	ee17 2a90 	vmov	r2, s15
 810986c:	687b      	ldr	r3, [r7, #4]
 810986e:	609a      	str	r2, [r3, #8]
    PLL1_Clocks->PLL1_P_Frequency = 0U;
    PLL1_Clocks->PLL1_Q_Frequency = 0U;
    PLL1_Clocks->PLL1_R_Frequency = 0U;
  }

}
 8109870:	e008      	b.n	8109884 <HAL_RCCEx_GetPLL1ClockFreq+0x280>
    PLL1_Clocks->PLL1_P_Frequency = 0U;
 8109872:	687b      	ldr	r3, [r7, #4]
 8109874:	2200      	movs	r2, #0
 8109876:	601a      	str	r2, [r3, #0]
    PLL1_Clocks->PLL1_Q_Frequency = 0U;
 8109878:	687b      	ldr	r3, [r7, #4]
 810987a:	2200      	movs	r2, #0
 810987c:	605a      	str	r2, [r3, #4]
    PLL1_Clocks->PLL1_R_Frequency = 0U;
 810987e:	687b      	ldr	r3, [r7, #4]
 8109880:	2200      	movs	r2, #0
 8109882:	609a      	str	r2, [r3, #8]
}
 8109884:	bf00      	nop
 8109886:	3724      	adds	r7, #36	; 0x24
 8109888:	46bd      	mov	sp, r7
 810988a:	f85d 7b04 	ldr.w	r7, [sp], #4
 810988e:	4770      	bx	lr
 8109890:	58024400 	.word	0x58024400
 8109894:	03d09000 	.word	0x03d09000
 8109898:	46000000 	.word	0x46000000
 810989c:	4c742400 	.word	0x4c742400
 81098a0:	4a742400 	.word	0x4a742400
 81098a4:	4bbebc20 	.word	0x4bbebc20

081098a8 <RCCEx_PLL2_Config>:
  * @note   PLL2 is temporary disabled to apply new parameters
  *
  * @retval HAL status
  */
static HAL_StatusTypeDef RCCEx_PLL2_Config(RCC_PLL2InitTypeDef *pll2, uint32_t Divider)
{
 81098a8:	b580      	push	{r7, lr}
 81098aa:	b084      	sub	sp, #16
 81098ac:	af00      	add	r7, sp, #0
 81098ae:	6078      	str	r0, [r7, #4]
 81098b0:	6039      	str	r1, [r7, #0]

  uint32_t tickstart;
  HAL_StatusTypeDef status = HAL_OK;
 81098b2:	2300      	movs	r3, #0
 81098b4:	73fb      	strb	r3, [r7, #15]
  assert_param(IS_RCC_PLL2RGE_VALUE(pll2->PLL2RGE));
  assert_param(IS_RCC_PLL2VCO_VALUE(pll2->PLL2VCOSEL));
  assert_param(IS_RCC_PLLFRACN_VALUE(pll2->PLL2FRACN));

  /* Check that PLL2 OSC clock source is already set */
  if (__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_NONE)
 81098b6:	4b54      	ldr	r3, [pc, #336]	; (8109a08 <RCCEx_PLL2_Config+0x160>)
 81098b8:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 81098ba:	f003 0303 	and.w	r3, r3, #3
 81098be:	2b03      	cmp	r3, #3
 81098c0:	d101      	bne.n	81098c6 <RCCEx_PLL2_Config+0x1e>
  {
    return HAL_ERROR;
 81098c2:	2301      	movs	r3, #1
 81098c4:	e09b      	b.n	81099fe <RCCEx_PLL2_Config+0x156>


  else
  {
    /* Disable  PLL2. */
    __HAL_RCC_PLL2_DISABLE();
 81098c6:	4b50      	ldr	r3, [pc, #320]	; (8109a08 <RCCEx_PLL2_Config+0x160>)
 81098c8:	681b      	ldr	r3, [r3, #0]
 81098ca:	4a4f      	ldr	r2, [pc, #316]	; (8109a08 <RCCEx_PLL2_Config+0x160>)
 81098cc:	f023 6380 	bic.w	r3, r3, #67108864	; 0x4000000
 81098d0:	6013      	str	r3, [r2, #0]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
 81098d2:	f7f7 feb3 	bl	810163c <HAL_GetTick>
 81098d6:	60b8      	str	r0, [r7, #8]

    /* Wait till PLL is disabled */
    while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLL2RDY) != 0U)
 81098d8:	e008      	b.n	81098ec <RCCEx_PLL2_Config+0x44>
    {
      if ((HAL_GetTick() - tickstart) > PLL2_TIMEOUT_VALUE)
 81098da:	f7f7 feaf 	bl	810163c <HAL_GetTick>
 81098de:	4602      	mov	r2, r0
 81098e0:	68bb      	ldr	r3, [r7, #8]
 81098e2:	1ad3      	subs	r3, r2, r3
 81098e4:	2b02      	cmp	r3, #2
 81098e6:	d901      	bls.n	81098ec <RCCEx_PLL2_Config+0x44>
      {
        return HAL_TIMEOUT;
 81098e8:	2303      	movs	r3, #3
 81098ea:	e088      	b.n	81099fe <RCCEx_PLL2_Config+0x156>
    while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLL2RDY) != 0U)
 81098ec:	4b46      	ldr	r3, [pc, #280]	; (8109a08 <RCCEx_PLL2_Config+0x160>)
 81098ee:	681b      	ldr	r3, [r3, #0]
 81098f0:	f003 6300 	and.w	r3, r3, #134217728	; 0x8000000
 81098f4:	2b00      	cmp	r3, #0
 81098f6:	d1f0      	bne.n	81098da <RCCEx_PLL2_Config+0x32>
      }
    }

    /* Configure PLL2 multiplication and division factors. */
    __HAL_RCC_PLL2_CONFIG(pll2->PLL2M,
 81098f8:	4b43      	ldr	r3, [pc, #268]	; (8109a08 <RCCEx_PLL2_Config+0x160>)
 81098fa:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 81098fc:	f423 327c 	bic.w	r2, r3, #258048	; 0x3f000
 8109900:	687b      	ldr	r3, [r7, #4]
 8109902:	681b      	ldr	r3, [r3, #0]
 8109904:	031b      	lsls	r3, r3, #12
 8109906:	4940      	ldr	r1, [pc, #256]	; (8109a08 <RCCEx_PLL2_Config+0x160>)
 8109908:	4313      	orrs	r3, r2
 810990a:	628b      	str	r3, [r1, #40]	; 0x28
 810990c:	687b      	ldr	r3, [r7, #4]
 810990e:	685b      	ldr	r3, [r3, #4]
 8109910:	3b01      	subs	r3, #1
 8109912:	f3c3 0208 	ubfx	r2, r3, #0, #9
 8109916:	687b      	ldr	r3, [r7, #4]
 8109918:	689b      	ldr	r3, [r3, #8]
 810991a:	3b01      	subs	r3, #1
 810991c:	025b      	lsls	r3, r3, #9
 810991e:	b29b      	uxth	r3, r3
 8109920:	431a      	orrs	r2, r3
 8109922:	687b      	ldr	r3, [r7, #4]
 8109924:	68db      	ldr	r3, [r3, #12]
 8109926:	3b01      	subs	r3, #1
 8109928:	041b      	lsls	r3, r3, #16
 810992a:	f403 03fe 	and.w	r3, r3, #8323072	; 0x7f0000
 810992e:	431a      	orrs	r2, r3
 8109930:	687b      	ldr	r3, [r7, #4]
 8109932:	691b      	ldr	r3, [r3, #16]
 8109934:	3b01      	subs	r3, #1
 8109936:	061b      	lsls	r3, r3, #24
 8109938:	f003 43fe 	and.w	r3, r3, #2130706432	; 0x7f000000
 810993c:	4932      	ldr	r1, [pc, #200]	; (8109a08 <RCCEx_PLL2_Config+0x160>)
 810993e:	4313      	orrs	r3, r2
 8109940:	638b      	str	r3, [r1, #56]	; 0x38
                          pll2->PLL2P,
                          pll2->PLL2Q,
                          pll2->PLL2R);

    /* Select PLL2 input reference frequency range: VCI */
    __HAL_RCC_PLL2_VCIRANGE(pll2->PLL2RGE) ;
 8109942:	4b31      	ldr	r3, [pc, #196]	; (8109a08 <RCCEx_PLL2_Config+0x160>)
 8109944:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8109946:	f023 02c0 	bic.w	r2, r3, #192	; 0xc0
 810994a:	687b      	ldr	r3, [r7, #4]
 810994c:	695b      	ldr	r3, [r3, #20]
 810994e:	492e      	ldr	r1, [pc, #184]	; (8109a08 <RCCEx_PLL2_Config+0x160>)
 8109950:	4313      	orrs	r3, r2
 8109952:	62cb      	str	r3, [r1, #44]	; 0x2c

    /* Select PLL2 output frequency range : VCO */
    __HAL_RCC_PLL2_VCORANGE(pll2->PLL2VCOSEL) ;
 8109954:	4b2c      	ldr	r3, [pc, #176]	; (8109a08 <RCCEx_PLL2_Config+0x160>)
 8109956:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8109958:	f023 0220 	bic.w	r2, r3, #32
 810995c:	687b      	ldr	r3, [r7, #4]
 810995e:	699b      	ldr	r3, [r3, #24]
 8109960:	4929      	ldr	r1, [pc, #164]	; (8109a08 <RCCEx_PLL2_Config+0x160>)
 8109962:	4313      	orrs	r3, r2
 8109964:	62cb      	str	r3, [r1, #44]	; 0x2c

    /* Disable PLL2FRACN . */
    __HAL_RCC_PLL2FRACN_DISABLE();
 8109966:	4b28      	ldr	r3, [pc, #160]	; (8109a08 <RCCEx_PLL2_Config+0x160>)
 8109968:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 810996a:	4a27      	ldr	r2, [pc, #156]	; (8109a08 <RCCEx_PLL2_Config+0x160>)
 810996c:	f023 0310 	bic.w	r3, r3, #16
 8109970:	62d3      	str	r3, [r2, #44]	; 0x2c

    /* Configures PLL2 clock Fractional Part Of The Multiplication Factor */
    __HAL_RCC_PLL2FRACN_CONFIG(pll2->PLL2FRACN);
 8109972:	4b25      	ldr	r3, [pc, #148]	; (8109a08 <RCCEx_PLL2_Config+0x160>)
 8109974:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8109976:	f423 437f 	bic.w	r3, r3, #65280	; 0xff00
 810997a:	f023 03f8 	bic.w	r3, r3, #248	; 0xf8
 810997e:	687a      	ldr	r2, [r7, #4]
 8109980:	69d2      	ldr	r2, [r2, #28]
 8109982:	00d2      	lsls	r2, r2, #3
 8109984:	4920      	ldr	r1, [pc, #128]	; (8109a08 <RCCEx_PLL2_Config+0x160>)
 8109986:	4313      	orrs	r3, r2
 8109988:	63cb      	str	r3, [r1, #60]	; 0x3c

    /* Enable PLL2FRACN . */
    __HAL_RCC_PLL2FRACN_ENABLE();
 810998a:	4b1f      	ldr	r3, [pc, #124]	; (8109a08 <RCCEx_PLL2_Config+0x160>)
 810998c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 810998e:	4a1e      	ldr	r2, [pc, #120]	; (8109a08 <RCCEx_PLL2_Config+0x160>)
 8109990:	f043 0310 	orr.w	r3, r3, #16
 8109994:	62d3      	str	r3, [r2, #44]	; 0x2c

    /* Enable the PLL2 clock output */
    if (Divider == DIVIDER_P_UPDATE)
 8109996:	683b      	ldr	r3, [r7, #0]
 8109998:	2b00      	cmp	r3, #0
 810999a:	d106      	bne.n	81099aa <RCCEx_PLL2_Config+0x102>
    {
      __HAL_RCC_PLL2CLKOUT_ENABLE(RCC_PLL2_DIVP);
 810999c:	4b1a      	ldr	r3, [pc, #104]	; (8109a08 <RCCEx_PLL2_Config+0x160>)
 810999e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 81099a0:	4a19      	ldr	r2, [pc, #100]	; (8109a08 <RCCEx_PLL2_Config+0x160>)
 81099a2:	f443 2300 	orr.w	r3, r3, #524288	; 0x80000
 81099a6:	62d3      	str	r3, [r2, #44]	; 0x2c
 81099a8:	e00f      	b.n	81099ca <RCCEx_PLL2_Config+0x122>
    }
    else if (Divider == DIVIDER_Q_UPDATE)
 81099aa:	683b      	ldr	r3, [r7, #0]
 81099ac:	2b01      	cmp	r3, #1
 81099ae:	d106      	bne.n	81099be <RCCEx_PLL2_Config+0x116>
    {
      __HAL_RCC_PLL2CLKOUT_ENABLE(RCC_PLL2_DIVQ);
 81099b0:	4b15      	ldr	r3, [pc, #84]	; (8109a08 <RCCEx_PLL2_Config+0x160>)
 81099b2:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 81099b4:	4a14      	ldr	r2, [pc, #80]	; (8109a08 <RCCEx_PLL2_Config+0x160>)
 81099b6:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 81099ba:	62d3      	str	r3, [r2, #44]	; 0x2c
 81099bc:	e005      	b.n	81099ca <RCCEx_PLL2_Config+0x122>
    }
    else
    {
      __HAL_RCC_PLL2CLKOUT_ENABLE(RCC_PLL2_DIVR);
 81099be:	4b12      	ldr	r3, [pc, #72]	; (8109a08 <RCCEx_PLL2_Config+0x160>)
 81099c0:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 81099c2:	4a11      	ldr	r2, [pc, #68]	; (8109a08 <RCCEx_PLL2_Config+0x160>)
 81099c4:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
 81099c8:	62d3      	str	r3, [r2, #44]	; 0x2c
    }

    /* Enable  PLL2. */
    __HAL_RCC_PLL2_ENABLE();
 81099ca:	4b0f      	ldr	r3, [pc, #60]	; (8109a08 <RCCEx_PLL2_Config+0x160>)
 81099cc:	681b      	ldr	r3, [r3, #0]
 81099ce:	4a0e      	ldr	r2, [pc, #56]	; (8109a08 <RCCEx_PLL2_Config+0x160>)
 81099d0:	f043 6380 	orr.w	r3, r3, #67108864	; 0x4000000
 81099d4:	6013      	str	r3, [r2, #0]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
 81099d6:	f7f7 fe31 	bl	810163c <HAL_GetTick>
 81099da:	60b8      	str	r0, [r7, #8]

    /* Wait till PLL2 is ready */
    while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLL2RDY) == 0U)
 81099dc:	e008      	b.n	81099f0 <RCCEx_PLL2_Config+0x148>
    {
      if ((HAL_GetTick() - tickstart) > PLL2_TIMEOUT_VALUE)
 81099de:	f7f7 fe2d 	bl	810163c <HAL_GetTick>
 81099e2:	4602      	mov	r2, r0
 81099e4:	68bb      	ldr	r3, [r7, #8]
 81099e6:	1ad3      	subs	r3, r2, r3
 81099e8:	2b02      	cmp	r3, #2
 81099ea:	d901      	bls.n	81099f0 <RCCEx_PLL2_Config+0x148>
      {
        return HAL_TIMEOUT;
 81099ec:	2303      	movs	r3, #3
 81099ee:	e006      	b.n	81099fe <RCCEx_PLL2_Config+0x156>
    while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLL2RDY) == 0U)
 81099f0:	4b05      	ldr	r3, [pc, #20]	; (8109a08 <RCCEx_PLL2_Config+0x160>)
 81099f2:	681b      	ldr	r3, [r3, #0]
 81099f4:	f003 6300 	and.w	r3, r3, #134217728	; 0x8000000
 81099f8:	2b00      	cmp	r3, #0
 81099fa:	d0f0      	beq.n	81099de <RCCEx_PLL2_Config+0x136>
    }

  }


  return status;
 81099fc:	7bfb      	ldrb	r3, [r7, #15]
}
 81099fe:	4618      	mov	r0, r3
 8109a00:	3710      	adds	r7, #16
 8109a02:	46bd      	mov	sp, r7
 8109a04:	bd80      	pop	{r7, pc}
 8109a06:	bf00      	nop
 8109a08:	58024400 	.word	0x58024400

08109a0c <RCCEx_PLL3_Config>:
  * @note   PLL3 is temporary disabled to apply new parameters
  *
  * @retval HAL status
  */
static HAL_StatusTypeDef RCCEx_PLL3_Config(RCC_PLL3InitTypeDef *pll3, uint32_t Divider)
{
 8109a0c:	b580      	push	{r7, lr}
 8109a0e:	b084      	sub	sp, #16
 8109a10:	af00      	add	r7, sp, #0
 8109a12:	6078      	str	r0, [r7, #4]
 8109a14:	6039      	str	r1, [r7, #0]
  uint32_t tickstart;
  HAL_StatusTypeDef status = HAL_OK;
 8109a16:	2300      	movs	r3, #0
 8109a18:	73fb      	strb	r3, [r7, #15]
  assert_param(IS_RCC_PLL3RGE_VALUE(pll3->PLL3RGE));
  assert_param(IS_RCC_PLL3VCO_VALUE(pll3->PLL3VCOSEL));
  assert_param(IS_RCC_PLLFRACN_VALUE(pll3->PLL3FRACN));

  /* Check that PLL3 OSC clock source is already set */
  if (__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_NONE)
 8109a1a:	4b54      	ldr	r3, [pc, #336]	; (8109b6c <RCCEx_PLL3_Config+0x160>)
 8109a1c:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8109a1e:	f003 0303 	and.w	r3, r3, #3
 8109a22:	2b03      	cmp	r3, #3
 8109a24:	d101      	bne.n	8109a2a <RCCEx_PLL3_Config+0x1e>
  {
    return HAL_ERROR;
 8109a26:	2301      	movs	r3, #1
 8109a28:	e09b      	b.n	8109b62 <RCCEx_PLL3_Config+0x156>


  else
  {
    /* Disable  PLL3. */
    __HAL_RCC_PLL3_DISABLE();
 8109a2a:	4b50      	ldr	r3, [pc, #320]	; (8109b6c <RCCEx_PLL3_Config+0x160>)
 8109a2c:	681b      	ldr	r3, [r3, #0]
 8109a2e:	4a4f      	ldr	r2, [pc, #316]	; (8109b6c <RCCEx_PLL3_Config+0x160>)
 8109a30:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
 8109a34:	6013      	str	r3, [r2, #0]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
 8109a36:	f7f7 fe01 	bl	810163c <HAL_GetTick>
 8109a3a:	60b8      	str	r0, [r7, #8]
    /* Wait till PLL3 is ready */
    while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLL3RDY) != 0U)
 8109a3c:	e008      	b.n	8109a50 <RCCEx_PLL3_Config+0x44>
    {
      if ((HAL_GetTick() - tickstart) > PLL3_TIMEOUT_VALUE)
 8109a3e:	f7f7 fdfd 	bl	810163c <HAL_GetTick>
 8109a42:	4602      	mov	r2, r0
 8109a44:	68bb      	ldr	r3, [r7, #8]
 8109a46:	1ad3      	subs	r3, r2, r3
 8109a48:	2b02      	cmp	r3, #2
 8109a4a:	d901      	bls.n	8109a50 <RCCEx_PLL3_Config+0x44>
      {
        return HAL_TIMEOUT;
 8109a4c:	2303      	movs	r3, #3
 8109a4e:	e088      	b.n	8109b62 <RCCEx_PLL3_Config+0x156>
    while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLL3RDY) != 0U)
 8109a50:	4b46      	ldr	r3, [pc, #280]	; (8109b6c <RCCEx_PLL3_Config+0x160>)
 8109a52:	681b      	ldr	r3, [r3, #0]
 8109a54:	f003 5300 	and.w	r3, r3, #536870912	; 0x20000000
 8109a58:	2b00      	cmp	r3, #0
 8109a5a:	d1f0      	bne.n	8109a3e <RCCEx_PLL3_Config+0x32>
      }
    }

    /* Configure the PLL3  multiplication and division factors. */
    __HAL_RCC_PLL3_CONFIG(pll3->PLL3M,
 8109a5c:	4b43      	ldr	r3, [pc, #268]	; (8109b6c <RCCEx_PLL3_Config+0x160>)
 8109a5e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8109a60:	f023 727c 	bic.w	r2, r3, #66060288	; 0x3f00000
 8109a64:	687b      	ldr	r3, [r7, #4]
 8109a66:	681b      	ldr	r3, [r3, #0]
 8109a68:	051b      	lsls	r3, r3, #20
 8109a6a:	4940      	ldr	r1, [pc, #256]	; (8109b6c <RCCEx_PLL3_Config+0x160>)
 8109a6c:	4313      	orrs	r3, r2
 8109a6e:	628b      	str	r3, [r1, #40]	; 0x28
 8109a70:	687b      	ldr	r3, [r7, #4]
 8109a72:	685b      	ldr	r3, [r3, #4]
 8109a74:	3b01      	subs	r3, #1
 8109a76:	f3c3 0208 	ubfx	r2, r3, #0, #9
 8109a7a:	687b      	ldr	r3, [r7, #4]
 8109a7c:	689b      	ldr	r3, [r3, #8]
 8109a7e:	3b01      	subs	r3, #1
 8109a80:	025b      	lsls	r3, r3, #9
 8109a82:	b29b      	uxth	r3, r3
 8109a84:	431a      	orrs	r2, r3
 8109a86:	687b      	ldr	r3, [r7, #4]
 8109a88:	68db      	ldr	r3, [r3, #12]
 8109a8a:	3b01      	subs	r3, #1
 8109a8c:	041b      	lsls	r3, r3, #16
 8109a8e:	f403 03fe 	and.w	r3, r3, #8323072	; 0x7f0000
 8109a92:	431a      	orrs	r2, r3
 8109a94:	687b      	ldr	r3, [r7, #4]
 8109a96:	691b      	ldr	r3, [r3, #16]
 8109a98:	3b01      	subs	r3, #1
 8109a9a:	061b      	lsls	r3, r3, #24
 8109a9c:	f003 43fe 	and.w	r3, r3, #2130706432	; 0x7f000000
 8109aa0:	4932      	ldr	r1, [pc, #200]	; (8109b6c <RCCEx_PLL3_Config+0x160>)
 8109aa2:	4313      	orrs	r3, r2
 8109aa4:	640b      	str	r3, [r1, #64]	; 0x40
                          pll3->PLL3P,
                          pll3->PLL3Q,
                          pll3->PLL3R);

    /* Select PLL3 input reference frequency range: VCI */
    __HAL_RCC_PLL3_VCIRANGE(pll3->PLL3RGE) ;
 8109aa6:	4b31      	ldr	r3, [pc, #196]	; (8109b6c <RCCEx_PLL3_Config+0x160>)
 8109aa8:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8109aaa:	f423 6240 	bic.w	r2, r3, #3072	; 0xc00
 8109aae:	687b      	ldr	r3, [r7, #4]
 8109ab0:	695b      	ldr	r3, [r3, #20]
 8109ab2:	492e      	ldr	r1, [pc, #184]	; (8109b6c <RCCEx_PLL3_Config+0x160>)
 8109ab4:	4313      	orrs	r3, r2
 8109ab6:	62cb      	str	r3, [r1, #44]	; 0x2c

    /* Select PLL3 output frequency range : VCO */
    __HAL_RCC_PLL3_VCORANGE(pll3->PLL3VCOSEL) ;
 8109ab8:	4b2c      	ldr	r3, [pc, #176]	; (8109b6c <RCCEx_PLL3_Config+0x160>)
 8109aba:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8109abc:	f423 7200 	bic.w	r2, r3, #512	; 0x200
 8109ac0:	687b      	ldr	r3, [r7, #4]
 8109ac2:	699b      	ldr	r3, [r3, #24]
 8109ac4:	4929      	ldr	r1, [pc, #164]	; (8109b6c <RCCEx_PLL3_Config+0x160>)
 8109ac6:	4313      	orrs	r3, r2
 8109ac8:	62cb      	str	r3, [r1, #44]	; 0x2c

    /* Disable PLL3FRACN . */
    __HAL_RCC_PLL3FRACN_DISABLE();
 8109aca:	4b28      	ldr	r3, [pc, #160]	; (8109b6c <RCCEx_PLL3_Config+0x160>)
 8109acc:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8109ace:	4a27      	ldr	r2, [pc, #156]	; (8109b6c <RCCEx_PLL3_Config+0x160>)
 8109ad0:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 8109ad4:	62d3      	str	r3, [r2, #44]	; 0x2c

    /* Configures PLL3 clock Fractional Part Of The Multiplication Factor */
    __HAL_RCC_PLL3FRACN_CONFIG(pll3->PLL3FRACN);
 8109ad6:	4b25      	ldr	r3, [pc, #148]	; (8109b6c <RCCEx_PLL3_Config+0x160>)
 8109ad8:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8109ada:	f423 437f 	bic.w	r3, r3, #65280	; 0xff00
 8109ade:	f023 03f8 	bic.w	r3, r3, #248	; 0xf8
 8109ae2:	687a      	ldr	r2, [r7, #4]
 8109ae4:	69d2      	ldr	r2, [r2, #28]
 8109ae6:	00d2      	lsls	r2, r2, #3
 8109ae8:	4920      	ldr	r1, [pc, #128]	; (8109b6c <RCCEx_PLL3_Config+0x160>)
 8109aea:	4313      	orrs	r3, r2
 8109aec:	644b      	str	r3, [r1, #68]	; 0x44

    /* Enable PLL3FRACN . */
    __HAL_RCC_PLL3FRACN_ENABLE();
 8109aee:	4b1f      	ldr	r3, [pc, #124]	; (8109b6c <RCCEx_PLL3_Config+0x160>)
 8109af0:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8109af2:	4a1e      	ldr	r2, [pc, #120]	; (8109b6c <RCCEx_PLL3_Config+0x160>)
 8109af4:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8109af8:	62d3      	str	r3, [r2, #44]	; 0x2c

    /* Enable the PLL3 clock output */
    if (Divider == DIVIDER_P_UPDATE)
 8109afa:	683b      	ldr	r3, [r7, #0]
 8109afc:	2b00      	cmp	r3, #0
 8109afe:	d106      	bne.n	8109b0e <RCCEx_PLL3_Config+0x102>
    {
      __HAL_RCC_PLL3CLKOUT_ENABLE(RCC_PLL3_DIVP);
 8109b00:	4b1a      	ldr	r3, [pc, #104]	; (8109b6c <RCCEx_PLL3_Config+0x160>)
 8109b02:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8109b04:	4a19      	ldr	r2, [pc, #100]	; (8109b6c <RCCEx_PLL3_Config+0x160>)
 8109b06:	f443 0380 	orr.w	r3, r3, #4194304	; 0x400000
 8109b0a:	62d3      	str	r3, [r2, #44]	; 0x2c
 8109b0c:	e00f      	b.n	8109b2e <RCCEx_PLL3_Config+0x122>
    }
    else if (Divider == DIVIDER_Q_UPDATE)
 8109b0e:	683b      	ldr	r3, [r7, #0]
 8109b10:	2b01      	cmp	r3, #1
 8109b12:	d106      	bne.n	8109b22 <RCCEx_PLL3_Config+0x116>
    {
      __HAL_RCC_PLL3CLKOUT_ENABLE(RCC_PLL3_DIVQ);
 8109b14:	4b15      	ldr	r3, [pc, #84]	; (8109b6c <RCCEx_PLL3_Config+0x160>)
 8109b16:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8109b18:	4a14      	ldr	r2, [pc, #80]	; (8109b6c <RCCEx_PLL3_Config+0x160>)
 8109b1a:	f443 0300 	orr.w	r3, r3, #8388608	; 0x800000
 8109b1e:	62d3      	str	r3, [r2, #44]	; 0x2c
 8109b20:	e005      	b.n	8109b2e <RCCEx_PLL3_Config+0x122>
    }
    else
    {
      __HAL_RCC_PLL3CLKOUT_ENABLE(RCC_PLL3_DIVR);
 8109b22:	4b12      	ldr	r3, [pc, #72]	; (8109b6c <RCCEx_PLL3_Config+0x160>)
 8109b24:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8109b26:	4a11      	ldr	r2, [pc, #68]	; (8109b6c <RCCEx_PLL3_Config+0x160>)
 8109b28:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 8109b2c:	62d3      	str	r3, [r2, #44]	; 0x2c
    }

    /* Enable  PLL3. */
    __HAL_RCC_PLL3_ENABLE();
 8109b2e:	4b0f      	ldr	r3, [pc, #60]	; (8109b6c <RCCEx_PLL3_Config+0x160>)
 8109b30:	681b      	ldr	r3, [r3, #0]
 8109b32:	4a0e      	ldr	r2, [pc, #56]	; (8109b6c <RCCEx_PLL3_Config+0x160>)
 8109b34:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 8109b38:	6013      	str	r3, [r2, #0]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
 8109b3a:	f7f7 fd7f 	bl	810163c <HAL_GetTick>
 8109b3e:	60b8      	str	r0, [r7, #8]

    /* Wait till PLL3 is ready */
    while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLL3RDY) == 0U)
 8109b40:	e008      	b.n	8109b54 <RCCEx_PLL3_Config+0x148>
    {
      if ((HAL_GetTick() - tickstart) > PLL3_TIMEOUT_VALUE)
 8109b42:	f7f7 fd7b 	bl	810163c <HAL_GetTick>
 8109b46:	4602      	mov	r2, r0
 8109b48:	68bb      	ldr	r3, [r7, #8]
 8109b4a:	1ad3      	subs	r3, r2, r3
 8109b4c:	2b02      	cmp	r3, #2
 8109b4e:	d901      	bls.n	8109b54 <RCCEx_PLL3_Config+0x148>
      {
        return HAL_TIMEOUT;
 8109b50:	2303      	movs	r3, #3
 8109b52:	e006      	b.n	8109b62 <RCCEx_PLL3_Config+0x156>
    while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLL3RDY) == 0U)
 8109b54:	4b05      	ldr	r3, [pc, #20]	; (8109b6c <RCCEx_PLL3_Config+0x160>)
 8109b56:	681b      	ldr	r3, [r3, #0]
 8109b58:	f003 5300 	and.w	r3, r3, #536870912	; 0x20000000
 8109b5c:	2b00      	cmp	r3, #0
 8109b5e:	d0f0      	beq.n	8109b42 <RCCEx_PLL3_Config+0x136>
    }

  }


  return status;
 8109b60:	7bfb      	ldrb	r3, [r7, #15]
}
 8109b62:	4618      	mov	r0, r3
 8109b64:	3710      	adds	r7, #16
 8109b66:	46bd      	mov	sp, r7
 8109b68:	bd80      	pop	{r7, pc}
 8109b6a:	bf00      	nop
 8109b6c:	58024400 	.word	0x58024400

08109b70 <HAL_UART_Init>:
  *        parameters in the UART_InitTypeDef and initialize the associated handle.
  * @param huart UART handle.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_UART_Init(UART_HandleTypeDef *huart)
{
 8109b70:	b580      	push	{r7, lr}
 8109b72:	b082      	sub	sp, #8
 8109b74:	af00      	add	r7, sp, #0
 8109b76:	6078      	str	r0, [r7, #4]
  /* Check the UART handle allocation */
  if (huart == NULL)
 8109b78:	687b      	ldr	r3, [r7, #4]
 8109b7a:	2b00      	cmp	r3, #0
 8109b7c:	d101      	bne.n	8109b82 <HAL_UART_Init+0x12>
  {
    return HAL_ERROR;
 8109b7e:	2301      	movs	r3, #1
 8109b80:	e042      	b.n	8109c08 <HAL_UART_Init+0x98>
  {
    /* Check the parameters */
    assert_param((IS_UART_INSTANCE(huart->Instance)) || (IS_LPUART_INSTANCE(huart->Instance)));
  }

  if (huart->gState == HAL_UART_STATE_RESET)
 8109b82:	687b      	ldr	r3, [r7, #4]
 8109b84:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 8109b88:	2b00      	cmp	r3, #0
 8109b8a:	d106      	bne.n	8109b9a <HAL_UART_Init+0x2a>
  {
    /* Allocate lock resource and initialize it */
    huart->Lock = HAL_UNLOCKED;
 8109b8c:	687b      	ldr	r3, [r7, #4]
 8109b8e:	2200      	movs	r2, #0
 8109b90:	f883 2084 	strb.w	r2, [r3, #132]	; 0x84

    /* Init the low level hardware */
    huart->MspInitCallback(huart);
#else
    /* Init the low level hardware : GPIO, CLOCK */
    HAL_UART_MspInit(huart);
 8109b94:	6878      	ldr	r0, [r7, #4]
 8109b96:	f000 f83b 	bl	8109c10 <HAL_UART_MspInit>
#endif /* (USE_HAL_UART_REGISTER_CALLBACKS) */
  }

  huart->gState = HAL_UART_STATE_BUSY;
 8109b9a:	687b      	ldr	r3, [r7, #4]
 8109b9c:	2224      	movs	r2, #36	; 0x24
 8109b9e:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88

  __HAL_UART_DISABLE(huart);
 8109ba2:	687b      	ldr	r3, [r7, #4]
 8109ba4:	681b      	ldr	r3, [r3, #0]
 8109ba6:	681a      	ldr	r2, [r3, #0]
 8109ba8:	687b      	ldr	r3, [r7, #4]
 8109baa:	681b      	ldr	r3, [r3, #0]
 8109bac:	f022 0201 	bic.w	r2, r2, #1
 8109bb0:	601a      	str	r2, [r3, #0]

  /* Perform advanced settings configuration */
  /* For some items, configuration requires to be done prior TE and RE bits are set */
  if (huart->AdvancedInit.AdvFeatureInit != UART_ADVFEATURE_NO_INIT)
 8109bb2:	687b      	ldr	r3, [r7, #4]
 8109bb4:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8109bb6:	2b00      	cmp	r3, #0
 8109bb8:	d002      	beq.n	8109bc0 <HAL_UART_Init+0x50>
  {
    UART_AdvFeatureConfig(huart);
 8109bba:	6878      	ldr	r0, [r7, #4]
 8109bbc:	f000 fe28 	bl	810a810 <UART_AdvFeatureConfig>
  }

  /* Set the UART Communication parameters */
  if (UART_SetConfig(huart) == HAL_ERROR)
 8109bc0:	6878      	ldr	r0, [r7, #4]
 8109bc2:	f000 f8bd 	bl	8109d40 <UART_SetConfig>
 8109bc6:	4603      	mov	r3, r0
 8109bc8:	2b01      	cmp	r3, #1
 8109bca:	d101      	bne.n	8109bd0 <HAL_UART_Init+0x60>
  {
    return HAL_ERROR;
 8109bcc:	2301      	movs	r3, #1
 8109bce:	e01b      	b.n	8109c08 <HAL_UART_Init+0x98>
  }

  /* In asynchronous mode, the following bits must be kept cleared:
  - LINEN and CLKEN bits in the USART_CR2 register,
  - SCEN, HDSEL and IREN  bits in the USART_CR3 register.*/
  CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
 8109bd0:	687b      	ldr	r3, [r7, #4]
 8109bd2:	681b      	ldr	r3, [r3, #0]
 8109bd4:	685a      	ldr	r2, [r3, #4]
 8109bd6:	687b      	ldr	r3, [r7, #4]
 8109bd8:	681b      	ldr	r3, [r3, #0]
 8109bda:	f422 4290 	bic.w	r2, r2, #18432	; 0x4800
 8109bde:	605a      	str	r2, [r3, #4]
  CLEAR_BIT(huart->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN));
 8109be0:	687b      	ldr	r3, [r7, #4]
 8109be2:	681b      	ldr	r3, [r3, #0]
 8109be4:	689a      	ldr	r2, [r3, #8]
 8109be6:	687b      	ldr	r3, [r7, #4]
 8109be8:	681b      	ldr	r3, [r3, #0]
 8109bea:	f022 022a 	bic.w	r2, r2, #42	; 0x2a
 8109bee:	609a      	str	r2, [r3, #8]

  __HAL_UART_ENABLE(huart);
 8109bf0:	687b      	ldr	r3, [r7, #4]
 8109bf2:	681b      	ldr	r3, [r3, #0]
 8109bf4:	681a      	ldr	r2, [r3, #0]
 8109bf6:	687b      	ldr	r3, [r7, #4]
 8109bf8:	681b      	ldr	r3, [r3, #0]
 8109bfa:	f042 0201 	orr.w	r2, r2, #1
 8109bfe:	601a      	str	r2, [r3, #0]

  /* TEACK and/or REACK to check before moving huart->gState and huart->RxState to Ready */
  return (UART_CheckIdleState(huart));
 8109c00:	6878      	ldr	r0, [r7, #4]
 8109c02:	f000 fea7 	bl	810a954 <UART_CheckIdleState>
 8109c06:	4603      	mov	r3, r0
}
 8109c08:	4618      	mov	r0, r3
 8109c0a:	3708      	adds	r7, #8
 8109c0c:	46bd      	mov	sp, r7
 8109c0e:	bd80      	pop	{r7, pc}

08109c10 <HAL_UART_MspInit>:
  * @brief Initialize the UART MSP.
  * @param huart UART handle.
  * @retval None
  */
__weak void HAL_UART_MspInit(UART_HandleTypeDef *huart)
{
 8109c10:	b480      	push	{r7}
 8109c12:	b083      	sub	sp, #12
 8109c14:	af00      	add	r7, sp, #0
 8109c16:	6078      	str	r0, [r7, #4]
  UNUSED(huart);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_UART_MspInit can be implemented in the user file
   */
}
 8109c18:	bf00      	nop
 8109c1a:	370c      	adds	r7, #12
 8109c1c:	46bd      	mov	sp, r7
 8109c1e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8109c22:	4770      	bx	lr

08109c24 <HAL_UART_Transmit>:
  * @param Size    Amount of data elements (u8 or u16) to be sent.
  * @param Timeout Timeout duration.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_UART_Transmit(UART_HandleTypeDef *huart, const uint8_t *pData, uint16_t Size, uint32_t Timeout)
{
 8109c24:	b580      	push	{r7, lr}
 8109c26:	b08a      	sub	sp, #40	; 0x28
 8109c28:	af02      	add	r7, sp, #8
 8109c2a:	60f8      	str	r0, [r7, #12]
 8109c2c:	60b9      	str	r1, [r7, #8]
 8109c2e:	603b      	str	r3, [r7, #0]
 8109c30:	4613      	mov	r3, r2
 8109c32:	80fb      	strh	r3, [r7, #6]
  const uint8_t  *pdata8bits;
  const uint16_t *pdata16bits;
  uint32_t tickstart;

  /* Check that a Tx process is not already ongoing */
  if (huart->gState == HAL_UART_STATE_READY)
 8109c34:	68fb      	ldr	r3, [r7, #12]
 8109c36:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 8109c3a:	2b20      	cmp	r3, #32
 8109c3c:	d17b      	bne.n	8109d36 <HAL_UART_Transmit+0x112>
  {
    if ((pData == NULL) || (Size == 0U))
 8109c3e:	68bb      	ldr	r3, [r7, #8]
 8109c40:	2b00      	cmp	r3, #0
 8109c42:	d002      	beq.n	8109c4a <HAL_UART_Transmit+0x26>
 8109c44:	88fb      	ldrh	r3, [r7, #6]
 8109c46:	2b00      	cmp	r3, #0
 8109c48:	d101      	bne.n	8109c4e <HAL_UART_Transmit+0x2a>
    {
      return  HAL_ERROR;
 8109c4a:	2301      	movs	r3, #1
 8109c4c:	e074      	b.n	8109d38 <HAL_UART_Transmit+0x114>
    }

    huart->ErrorCode = HAL_UART_ERROR_NONE;
 8109c4e:	68fb      	ldr	r3, [r7, #12]
 8109c50:	2200      	movs	r2, #0
 8109c52:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
    huart->gState = HAL_UART_STATE_BUSY_TX;
 8109c56:	68fb      	ldr	r3, [r7, #12]
 8109c58:	2221      	movs	r2, #33	; 0x21
 8109c5a:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88

    /* Init tickstart for timeout management */
    tickstart = HAL_GetTick();
 8109c5e:	f7f7 fced 	bl	810163c <HAL_GetTick>
 8109c62:	6178      	str	r0, [r7, #20]

    huart->TxXferSize  = Size;
 8109c64:	68fb      	ldr	r3, [r7, #12]
 8109c66:	88fa      	ldrh	r2, [r7, #6]
 8109c68:	f8a3 2054 	strh.w	r2, [r3, #84]	; 0x54
    huart->TxXferCount = Size;
 8109c6c:	68fb      	ldr	r3, [r7, #12]
 8109c6e:	88fa      	ldrh	r2, [r7, #6]
 8109c70:	f8a3 2056 	strh.w	r2, [r3, #86]	; 0x56

    /* In case of 9bits/No Parity transfer, pData needs to be handled as a uint16_t pointer */
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 8109c74:	68fb      	ldr	r3, [r7, #12]
 8109c76:	689b      	ldr	r3, [r3, #8]
 8109c78:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
 8109c7c:	d108      	bne.n	8109c90 <HAL_UART_Transmit+0x6c>
 8109c7e:	68fb      	ldr	r3, [r7, #12]
 8109c80:	691b      	ldr	r3, [r3, #16]
 8109c82:	2b00      	cmp	r3, #0
 8109c84:	d104      	bne.n	8109c90 <HAL_UART_Transmit+0x6c>
    {
      pdata8bits  = NULL;
 8109c86:	2300      	movs	r3, #0
 8109c88:	61fb      	str	r3, [r7, #28]
      pdata16bits = (const uint16_t *) pData;
 8109c8a:	68bb      	ldr	r3, [r7, #8]
 8109c8c:	61bb      	str	r3, [r7, #24]
 8109c8e:	e003      	b.n	8109c98 <HAL_UART_Transmit+0x74>
    }
    else
    {
      pdata8bits  = pData;
 8109c90:	68bb      	ldr	r3, [r7, #8]
 8109c92:	61fb      	str	r3, [r7, #28]
      pdata16bits = NULL;
 8109c94:	2300      	movs	r3, #0
 8109c96:	61bb      	str	r3, [r7, #24]
    }

    while (huart->TxXferCount > 0U)
 8109c98:	e030      	b.n	8109cfc <HAL_UART_Transmit+0xd8>
    {
      if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TXE, RESET, tickstart, Timeout) != HAL_OK)
 8109c9a:	683b      	ldr	r3, [r7, #0]
 8109c9c:	9300      	str	r3, [sp, #0]
 8109c9e:	697b      	ldr	r3, [r7, #20]
 8109ca0:	2200      	movs	r2, #0
 8109ca2:	2180      	movs	r1, #128	; 0x80
 8109ca4:	68f8      	ldr	r0, [r7, #12]
 8109ca6:	f000 feff 	bl	810aaa8 <UART_WaitOnFlagUntilTimeout>
 8109caa:	4603      	mov	r3, r0
 8109cac:	2b00      	cmp	r3, #0
 8109cae:	d005      	beq.n	8109cbc <HAL_UART_Transmit+0x98>
      {

        huart->gState = HAL_UART_STATE_READY;
 8109cb0:	68fb      	ldr	r3, [r7, #12]
 8109cb2:	2220      	movs	r2, #32
 8109cb4:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88

        return HAL_TIMEOUT;
 8109cb8:	2303      	movs	r3, #3
 8109cba:	e03d      	b.n	8109d38 <HAL_UART_Transmit+0x114>
      }
      if (pdata8bits == NULL)
 8109cbc:	69fb      	ldr	r3, [r7, #28]
 8109cbe:	2b00      	cmp	r3, #0
 8109cc0:	d10b      	bne.n	8109cda <HAL_UART_Transmit+0xb6>
      {
        huart->Instance->TDR = (uint16_t)(*pdata16bits & 0x01FFU);
 8109cc2:	69bb      	ldr	r3, [r7, #24]
 8109cc4:	881b      	ldrh	r3, [r3, #0]
 8109cc6:	461a      	mov	r2, r3
 8109cc8:	68fb      	ldr	r3, [r7, #12]
 8109cca:	681b      	ldr	r3, [r3, #0]
 8109ccc:	f3c2 0208 	ubfx	r2, r2, #0, #9
 8109cd0:	629a      	str	r2, [r3, #40]	; 0x28
        pdata16bits++;
 8109cd2:	69bb      	ldr	r3, [r7, #24]
 8109cd4:	3302      	adds	r3, #2
 8109cd6:	61bb      	str	r3, [r7, #24]
 8109cd8:	e007      	b.n	8109cea <HAL_UART_Transmit+0xc6>
      }
      else
      {
        huart->Instance->TDR = (uint8_t)(*pdata8bits & 0xFFU);
 8109cda:	69fb      	ldr	r3, [r7, #28]
 8109cdc:	781a      	ldrb	r2, [r3, #0]
 8109cde:	68fb      	ldr	r3, [r7, #12]
 8109ce0:	681b      	ldr	r3, [r3, #0]
 8109ce2:	629a      	str	r2, [r3, #40]	; 0x28
        pdata8bits++;
 8109ce4:	69fb      	ldr	r3, [r7, #28]
 8109ce6:	3301      	adds	r3, #1
 8109ce8:	61fb      	str	r3, [r7, #28]
      }
      huart->TxXferCount--;
 8109cea:	68fb      	ldr	r3, [r7, #12]
 8109cec:	f8b3 3056 	ldrh.w	r3, [r3, #86]	; 0x56
 8109cf0:	b29b      	uxth	r3, r3
 8109cf2:	3b01      	subs	r3, #1
 8109cf4:	b29a      	uxth	r2, r3
 8109cf6:	68fb      	ldr	r3, [r7, #12]
 8109cf8:	f8a3 2056 	strh.w	r2, [r3, #86]	; 0x56
    while (huart->TxXferCount > 0U)
 8109cfc:	68fb      	ldr	r3, [r7, #12]
 8109cfe:	f8b3 3056 	ldrh.w	r3, [r3, #86]	; 0x56
 8109d02:	b29b      	uxth	r3, r3
 8109d04:	2b00      	cmp	r3, #0
 8109d06:	d1c8      	bne.n	8109c9a <HAL_UART_Transmit+0x76>
    }

    if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TC, RESET, tickstart, Timeout) != HAL_OK)
 8109d08:	683b      	ldr	r3, [r7, #0]
 8109d0a:	9300      	str	r3, [sp, #0]
 8109d0c:	697b      	ldr	r3, [r7, #20]
 8109d0e:	2200      	movs	r2, #0
 8109d10:	2140      	movs	r1, #64	; 0x40
 8109d12:	68f8      	ldr	r0, [r7, #12]
 8109d14:	f000 fec8 	bl	810aaa8 <UART_WaitOnFlagUntilTimeout>
 8109d18:	4603      	mov	r3, r0
 8109d1a:	2b00      	cmp	r3, #0
 8109d1c:	d005      	beq.n	8109d2a <HAL_UART_Transmit+0x106>
    {
      huart->gState = HAL_UART_STATE_READY;
 8109d1e:	68fb      	ldr	r3, [r7, #12]
 8109d20:	2220      	movs	r2, #32
 8109d22:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88

      return HAL_TIMEOUT;
 8109d26:	2303      	movs	r3, #3
 8109d28:	e006      	b.n	8109d38 <HAL_UART_Transmit+0x114>
    }

    /* At end of Tx process, restore huart->gState to Ready */
    huart->gState = HAL_UART_STATE_READY;
 8109d2a:	68fb      	ldr	r3, [r7, #12]
 8109d2c:	2220      	movs	r2, #32
 8109d2e:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88

    return HAL_OK;
 8109d32:	2300      	movs	r3, #0
 8109d34:	e000      	b.n	8109d38 <HAL_UART_Transmit+0x114>
  }
  else
  {
    return HAL_BUSY;
 8109d36:	2302      	movs	r3, #2
  }
}
 8109d38:	4618      	mov	r0, r3
 8109d3a:	3720      	adds	r7, #32
 8109d3c:	46bd      	mov	sp, r7
 8109d3e:	bd80      	pop	{r7, pc}

08109d40 <UART_SetConfig>:
  * @brief Configure the UART peripheral.
  * @param huart UART handle.
  * @retval HAL status
  */
HAL_StatusTypeDef UART_SetConfig(UART_HandleTypeDef *huart)
{
 8109d40:	e92d 4fb0 	stmdb	sp!, {r4, r5, r7, r8, r9, sl, fp, lr}
 8109d44:	b092      	sub	sp, #72	; 0x48
 8109d46:	af00      	add	r7, sp, #0
 8109d48:	6178      	str	r0, [r7, #20]
  uint32_t tmpreg;
  uint16_t brrtemp;
  UART_ClockSourceTypeDef clocksource;
  uint32_t usartdiv;
  HAL_StatusTypeDef ret               = HAL_OK;
 8109d4a:	2300      	movs	r3, #0
 8109d4c:	f887 3042 	strb.w	r3, [r7, #66]	; 0x42
  *  the UART Word Length, Parity, Mode and oversampling:
  *  set the M bits according to huart->Init.WordLength value
  *  set PCE and PS bits according to huart->Init.Parity value
  *  set TE and RE bits according to huart->Init.Mode value
  *  set OVER8 bit according to huart->Init.OverSampling value */
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
 8109d50:	697b      	ldr	r3, [r7, #20]
 8109d52:	689a      	ldr	r2, [r3, #8]
 8109d54:	697b      	ldr	r3, [r7, #20]
 8109d56:	691b      	ldr	r3, [r3, #16]
 8109d58:	431a      	orrs	r2, r3
 8109d5a:	697b      	ldr	r3, [r7, #20]
 8109d5c:	695b      	ldr	r3, [r3, #20]
 8109d5e:	431a      	orrs	r2, r3
 8109d60:	697b      	ldr	r3, [r7, #20]
 8109d62:	69db      	ldr	r3, [r3, #28]
 8109d64:	4313      	orrs	r3, r2
 8109d66:	647b      	str	r3, [r7, #68]	; 0x44
  MODIFY_REG(huart->Instance->CR1, USART_CR1_FIELDS, tmpreg);
 8109d68:	697b      	ldr	r3, [r7, #20]
 8109d6a:	681b      	ldr	r3, [r3, #0]
 8109d6c:	681a      	ldr	r2, [r3, #0]
 8109d6e:	4bbd      	ldr	r3, [pc, #756]	; (810a064 <UART_SetConfig+0x324>)
 8109d70:	4013      	ands	r3, r2
 8109d72:	697a      	ldr	r2, [r7, #20]
 8109d74:	6812      	ldr	r2, [r2, #0]
 8109d76:	6c79      	ldr	r1, [r7, #68]	; 0x44
 8109d78:	430b      	orrs	r3, r1
 8109d7a:	6013      	str	r3, [r2, #0]

  /*-------------------------- USART CR2 Configuration -----------------------*/
  /* Configure the UART Stop Bits: Set STOP[13:12] bits according
  * to huart->Init.StopBits value */
  MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);
 8109d7c:	697b      	ldr	r3, [r7, #20]
 8109d7e:	681b      	ldr	r3, [r3, #0]
 8109d80:	685b      	ldr	r3, [r3, #4]
 8109d82:	f423 5140 	bic.w	r1, r3, #12288	; 0x3000
 8109d86:	697b      	ldr	r3, [r7, #20]
 8109d88:	68da      	ldr	r2, [r3, #12]
 8109d8a:	697b      	ldr	r3, [r7, #20]
 8109d8c:	681b      	ldr	r3, [r3, #0]
 8109d8e:	430a      	orrs	r2, r1
 8109d90:	605a      	str	r2, [r3, #4]
  /* Configure
  * - UART HardWare Flow Control: set CTSE and RTSE bits according
  *   to huart->Init.HwFlowCtl value
  * - one-bit sampling method versus three samples' majority rule according
  *   to huart->Init.OneBitSampling (not applicable to LPUART) */
  tmpreg = (uint32_t)huart->Init.HwFlowCtl;
 8109d92:	697b      	ldr	r3, [r7, #20]
 8109d94:	699b      	ldr	r3, [r3, #24]
 8109d96:	647b      	str	r3, [r7, #68]	; 0x44

  if (!(UART_INSTANCE_LOWPOWER(huart)))
 8109d98:	697b      	ldr	r3, [r7, #20]
 8109d9a:	681b      	ldr	r3, [r3, #0]
 8109d9c:	4ab2      	ldr	r2, [pc, #712]	; (810a068 <UART_SetConfig+0x328>)
 8109d9e:	4293      	cmp	r3, r2
 8109da0:	d004      	beq.n	8109dac <UART_SetConfig+0x6c>
  {
    tmpreg |= huart->Init.OneBitSampling;
 8109da2:	697b      	ldr	r3, [r7, #20]
 8109da4:	6a1b      	ldr	r3, [r3, #32]
 8109da6:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 8109da8:	4313      	orrs	r3, r2
 8109daa:	647b      	str	r3, [r7, #68]	; 0x44
  }
  MODIFY_REG(huart->Instance->CR3, USART_CR3_FIELDS, tmpreg);
 8109dac:	697b      	ldr	r3, [r7, #20]
 8109dae:	681b      	ldr	r3, [r3, #0]
 8109db0:	689b      	ldr	r3, [r3, #8]
 8109db2:	f023 436e 	bic.w	r3, r3, #3992977408	; 0xee000000
 8109db6:	f423 6330 	bic.w	r3, r3, #2816	; 0xb00
 8109dba:	697a      	ldr	r2, [r7, #20]
 8109dbc:	6812      	ldr	r2, [r2, #0]
 8109dbe:	6c79      	ldr	r1, [r7, #68]	; 0x44
 8109dc0:	430b      	orrs	r3, r1
 8109dc2:	6093      	str	r3, [r2, #8]

  /*-------------------------- USART PRESC Configuration -----------------------*/
  /* Configure
  * - UART Clock Prescaler : set PRESCALER according to huart->Init.ClockPrescaler value */
  MODIFY_REG(huart->Instance->PRESC, USART_PRESC_PRESCALER, huart->Init.ClockPrescaler);
 8109dc4:	697b      	ldr	r3, [r7, #20]
 8109dc6:	681b      	ldr	r3, [r3, #0]
 8109dc8:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8109dca:	f023 010f 	bic.w	r1, r3, #15
 8109dce:	697b      	ldr	r3, [r7, #20]
 8109dd0:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8109dd2:	697b      	ldr	r3, [r7, #20]
 8109dd4:	681b      	ldr	r3, [r3, #0]
 8109dd6:	430a      	orrs	r2, r1
 8109dd8:	62da      	str	r2, [r3, #44]	; 0x2c

  /*-------------------------- USART BRR Configuration -----------------------*/
  UART_GETCLOCKSOURCE(huart, clocksource);
 8109dda:	697b      	ldr	r3, [r7, #20]
 8109ddc:	681b      	ldr	r3, [r3, #0]
 8109dde:	4aa3      	ldr	r2, [pc, #652]	; (810a06c <UART_SetConfig+0x32c>)
 8109de0:	4293      	cmp	r3, r2
 8109de2:	d177      	bne.n	8109ed4 <UART_SetConfig+0x194>
 8109de4:	4ba2      	ldr	r3, [pc, #648]	; (810a070 <UART_SetConfig+0x330>)
 8109de6:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8109de8:	f003 0338 	and.w	r3, r3, #56	; 0x38
 8109dec:	2b28      	cmp	r3, #40	; 0x28
 8109dee:	d86d      	bhi.n	8109ecc <UART_SetConfig+0x18c>
 8109df0:	a201      	add	r2, pc, #4	; (adr r2, 8109df8 <UART_SetConfig+0xb8>)
 8109df2:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8109df6:	bf00      	nop
 8109df8:	08109e9d 	.word	0x08109e9d
 8109dfc:	08109ecd 	.word	0x08109ecd
 8109e00:	08109ecd 	.word	0x08109ecd
 8109e04:	08109ecd 	.word	0x08109ecd
 8109e08:	08109ecd 	.word	0x08109ecd
 8109e0c:	08109ecd 	.word	0x08109ecd
 8109e10:	08109ecd 	.word	0x08109ecd
 8109e14:	08109ecd 	.word	0x08109ecd
 8109e18:	08109ea5 	.word	0x08109ea5
 8109e1c:	08109ecd 	.word	0x08109ecd
 8109e20:	08109ecd 	.word	0x08109ecd
 8109e24:	08109ecd 	.word	0x08109ecd
 8109e28:	08109ecd 	.word	0x08109ecd
 8109e2c:	08109ecd 	.word	0x08109ecd
 8109e30:	08109ecd 	.word	0x08109ecd
 8109e34:	08109ecd 	.word	0x08109ecd
 8109e38:	08109ead 	.word	0x08109ead
 8109e3c:	08109ecd 	.word	0x08109ecd
 8109e40:	08109ecd 	.word	0x08109ecd
 8109e44:	08109ecd 	.word	0x08109ecd
 8109e48:	08109ecd 	.word	0x08109ecd
 8109e4c:	08109ecd 	.word	0x08109ecd
 8109e50:	08109ecd 	.word	0x08109ecd
 8109e54:	08109ecd 	.word	0x08109ecd
 8109e58:	08109eb5 	.word	0x08109eb5
 8109e5c:	08109ecd 	.word	0x08109ecd
 8109e60:	08109ecd 	.word	0x08109ecd
 8109e64:	08109ecd 	.word	0x08109ecd
 8109e68:	08109ecd 	.word	0x08109ecd
 8109e6c:	08109ecd 	.word	0x08109ecd
 8109e70:	08109ecd 	.word	0x08109ecd
 8109e74:	08109ecd 	.word	0x08109ecd
 8109e78:	08109ebd 	.word	0x08109ebd
 8109e7c:	08109ecd 	.word	0x08109ecd
 8109e80:	08109ecd 	.word	0x08109ecd
 8109e84:	08109ecd 	.word	0x08109ecd
 8109e88:	08109ecd 	.word	0x08109ecd
 8109e8c:	08109ecd 	.word	0x08109ecd
 8109e90:	08109ecd 	.word	0x08109ecd
 8109e94:	08109ecd 	.word	0x08109ecd
 8109e98:	08109ec5 	.word	0x08109ec5
 8109e9c:	2301      	movs	r3, #1
 8109e9e:	f887 3043 	strb.w	r3, [r7, #67]	; 0x43
 8109ea2:	e220      	b.n	810a2e6 <UART_SetConfig+0x5a6>
 8109ea4:	2304      	movs	r3, #4
 8109ea6:	f887 3043 	strb.w	r3, [r7, #67]	; 0x43
 8109eaa:	e21c      	b.n	810a2e6 <UART_SetConfig+0x5a6>
 8109eac:	2308      	movs	r3, #8
 8109eae:	f887 3043 	strb.w	r3, [r7, #67]	; 0x43
 8109eb2:	e218      	b.n	810a2e6 <UART_SetConfig+0x5a6>
 8109eb4:	2310      	movs	r3, #16
 8109eb6:	f887 3043 	strb.w	r3, [r7, #67]	; 0x43
 8109eba:	e214      	b.n	810a2e6 <UART_SetConfig+0x5a6>
 8109ebc:	2320      	movs	r3, #32
 8109ebe:	f887 3043 	strb.w	r3, [r7, #67]	; 0x43
 8109ec2:	e210      	b.n	810a2e6 <UART_SetConfig+0x5a6>
 8109ec4:	2340      	movs	r3, #64	; 0x40
 8109ec6:	f887 3043 	strb.w	r3, [r7, #67]	; 0x43
 8109eca:	e20c      	b.n	810a2e6 <UART_SetConfig+0x5a6>
 8109ecc:	2380      	movs	r3, #128	; 0x80
 8109ece:	f887 3043 	strb.w	r3, [r7, #67]	; 0x43
 8109ed2:	e208      	b.n	810a2e6 <UART_SetConfig+0x5a6>
 8109ed4:	697b      	ldr	r3, [r7, #20]
 8109ed6:	681b      	ldr	r3, [r3, #0]
 8109ed8:	4a66      	ldr	r2, [pc, #408]	; (810a074 <UART_SetConfig+0x334>)
 8109eda:	4293      	cmp	r3, r2
 8109edc:	d130      	bne.n	8109f40 <UART_SetConfig+0x200>
 8109ede:	4b64      	ldr	r3, [pc, #400]	; (810a070 <UART_SetConfig+0x330>)
 8109ee0:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8109ee2:	f003 0307 	and.w	r3, r3, #7
 8109ee6:	2b05      	cmp	r3, #5
 8109ee8:	d826      	bhi.n	8109f38 <UART_SetConfig+0x1f8>
 8109eea:	a201      	add	r2, pc, #4	; (adr r2, 8109ef0 <UART_SetConfig+0x1b0>)
 8109eec:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8109ef0:	08109f09 	.word	0x08109f09
 8109ef4:	08109f11 	.word	0x08109f11
 8109ef8:	08109f19 	.word	0x08109f19
 8109efc:	08109f21 	.word	0x08109f21
 8109f00:	08109f29 	.word	0x08109f29
 8109f04:	08109f31 	.word	0x08109f31
 8109f08:	2300      	movs	r3, #0
 8109f0a:	f887 3043 	strb.w	r3, [r7, #67]	; 0x43
 8109f0e:	e1ea      	b.n	810a2e6 <UART_SetConfig+0x5a6>
 8109f10:	2304      	movs	r3, #4
 8109f12:	f887 3043 	strb.w	r3, [r7, #67]	; 0x43
 8109f16:	e1e6      	b.n	810a2e6 <UART_SetConfig+0x5a6>
 8109f18:	2308      	movs	r3, #8
 8109f1a:	f887 3043 	strb.w	r3, [r7, #67]	; 0x43
 8109f1e:	e1e2      	b.n	810a2e6 <UART_SetConfig+0x5a6>
 8109f20:	2310      	movs	r3, #16
 8109f22:	f887 3043 	strb.w	r3, [r7, #67]	; 0x43
 8109f26:	e1de      	b.n	810a2e6 <UART_SetConfig+0x5a6>
 8109f28:	2320      	movs	r3, #32
 8109f2a:	f887 3043 	strb.w	r3, [r7, #67]	; 0x43
 8109f2e:	e1da      	b.n	810a2e6 <UART_SetConfig+0x5a6>
 8109f30:	2340      	movs	r3, #64	; 0x40
 8109f32:	f887 3043 	strb.w	r3, [r7, #67]	; 0x43
 8109f36:	e1d6      	b.n	810a2e6 <UART_SetConfig+0x5a6>
 8109f38:	2380      	movs	r3, #128	; 0x80
 8109f3a:	f887 3043 	strb.w	r3, [r7, #67]	; 0x43
 8109f3e:	e1d2      	b.n	810a2e6 <UART_SetConfig+0x5a6>
 8109f40:	697b      	ldr	r3, [r7, #20]
 8109f42:	681b      	ldr	r3, [r3, #0]
 8109f44:	4a4c      	ldr	r2, [pc, #304]	; (810a078 <UART_SetConfig+0x338>)
 8109f46:	4293      	cmp	r3, r2
 8109f48:	d130      	bne.n	8109fac <UART_SetConfig+0x26c>
 8109f4a:	4b49      	ldr	r3, [pc, #292]	; (810a070 <UART_SetConfig+0x330>)
 8109f4c:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8109f4e:	f003 0307 	and.w	r3, r3, #7
 8109f52:	2b05      	cmp	r3, #5
 8109f54:	d826      	bhi.n	8109fa4 <UART_SetConfig+0x264>
 8109f56:	a201      	add	r2, pc, #4	; (adr r2, 8109f5c <UART_SetConfig+0x21c>)
 8109f58:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8109f5c:	08109f75 	.word	0x08109f75
 8109f60:	08109f7d 	.word	0x08109f7d
 8109f64:	08109f85 	.word	0x08109f85
 8109f68:	08109f8d 	.word	0x08109f8d
 8109f6c:	08109f95 	.word	0x08109f95
 8109f70:	08109f9d 	.word	0x08109f9d
 8109f74:	2300      	movs	r3, #0
 8109f76:	f887 3043 	strb.w	r3, [r7, #67]	; 0x43
 8109f7a:	e1b4      	b.n	810a2e6 <UART_SetConfig+0x5a6>
 8109f7c:	2304      	movs	r3, #4
 8109f7e:	f887 3043 	strb.w	r3, [r7, #67]	; 0x43
 8109f82:	e1b0      	b.n	810a2e6 <UART_SetConfig+0x5a6>
 8109f84:	2308      	movs	r3, #8
 8109f86:	f887 3043 	strb.w	r3, [r7, #67]	; 0x43
 8109f8a:	e1ac      	b.n	810a2e6 <UART_SetConfig+0x5a6>
 8109f8c:	2310      	movs	r3, #16
 8109f8e:	f887 3043 	strb.w	r3, [r7, #67]	; 0x43
 8109f92:	e1a8      	b.n	810a2e6 <UART_SetConfig+0x5a6>
 8109f94:	2320      	movs	r3, #32
 8109f96:	f887 3043 	strb.w	r3, [r7, #67]	; 0x43
 8109f9a:	e1a4      	b.n	810a2e6 <UART_SetConfig+0x5a6>
 8109f9c:	2340      	movs	r3, #64	; 0x40
 8109f9e:	f887 3043 	strb.w	r3, [r7, #67]	; 0x43
 8109fa2:	e1a0      	b.n	810a2e6 <UART_SetConfig+0x5a6>
 8109fa4:	2380      	movs	r3, #128	; 0x80
 8109fa6:	f887 3043 	strb.w	r3, [r7, #67]	; 0x43
 8109faa:	e19c      	b.n	810a2e6 <UART_SetConfig+0x5a6>
 8109fac:	697b      	ldr	r3, [r7, #20]
 8109fae:	681b      	ldr	r3, [r3, #0]
 8109fb0:	4a32      	ldr	r2, [pc, #200]	; (810a07c <UART_SetConfig+0x33c>)
 8109fb2:	4293      	cmp	r3, r2
 8109fb4:	d130      	bne.n	810a018 <UART_SetConfig+0x2d8>
 8109fb6:	4b2e      	ldr	r3, [pc, #184]	; (810a070 <UART_SetConfig+0x330>)
 8109fb8:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8109fba:	f003 0307 	and.w	r3, r3, #7
 8109fbe:	2b05      	cmp	r3, #5
 8109fc0:	d826      	bhi.n	810a010 <UART_SetConfig+0x2d0>
 8109fc2:	a201      	add	r2, pc, #4	; (adr r2, 8109fc8 <UART_SetConfig+0x288>)
 8109fc4:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8109fc8:	08109fe1 	.word	0x08109fe1
 8109fcc:	08109fe9 	.word	0x08109fe9
 8109fd0:	08109ff1 	.word	0x08109ff1
 8109fd4:	08109ff9 	.word	0x08109ff9
 8109fd8:	0810a001 	.word	0x0810a001
 8109fdc:	0810a009 	.word	0x0810a009
 8109fe0:	2300      	movs	r3, #0
 8109fe2:	f887 3043 	strb.w	r3, [r7, #67]	; 0x43
 8109fe6:	e17e      	b.n	810a2e6 <UART_SetConfig+0x5a6>
 8109fe8:	2304      	movs	r3, #4
 8109fea:	f887 3043 	strb.w	r3, [r7, #67]	; 0x43
 8109fee:	e17a      	b.n	810a2e6 <UART_SetConfig+0x5a6>
 8109ff0:	2308      	movs	r3, #8
 8109ff2:	f887 3043 	strb.w	r3, [r7, #67]	; 0x43
 8109ff6:	e176      	b.n	810a2e6 <UART_SetConfig+0x5a6>
 8109ff8:	2310      	movs	r3, #16
 8109ffa:	f887 3043 	strb.w	r3, [r7, #67]	; 0x43
 8109ffe:	e172      	b.n	810a2e6 <UART_SetConfig+0x5a6>
 810a000:	2320      	movs	r3, #32
 810a002:	f887 3043 	strb.w	r3, [r7, #67]	; 0x43
 810a006:	e16e      	b.n	810a2e6 <UART_SetConfig+0x5a6>
 810a008:	2340      	movs	r3, #64	; 0x40
 810a00a:	f887 3043 	strb.w	r3, [r7, #67]	; 0x43
 810a00e:	e16a      	b.n	810a2e6 <UART_SetConfig+0x5a6>
 810a010:	2380      	movs	r3, #128	; 0x80
 810a012:	f887 3043 	strb.w	r3, [r7, #67]	; 0x43
 810a016:	e166      	b.n	810a2e6 <UART_SetConfig+0x5a6>
 810a018:	697b      	ldr	r3, [r7, #20]
 810a01a:	681b      	ldr	r3, [r3, #0]
 810a01c:	4a18      	ldr	r2, [pc, #96]	; (810a080 <UART_SetConfig+0x340>)
 810a01e:	4293      	cmp	r3, r2
 810a020:	d140      	bne.n	810a0a4 <UART_SetConfig+0x364>
 810a022:	4b13      	ldr	r3, [pc, #76]	; (810a070 <UART_SetConfig+0x330>)
 810a024:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 810a026:	f003 0307 	and.w	r3, r3, #7
 810a02a:	2b05      	cmp	r3, #5
 810a02c:	d836      	bhi.n	810a09c <UART_SetConfig+0x35c>
 810a02e:	a201      	add	r2, pc, #4	; (adr r2, 810a034 <UART_SetConfig+0x2f4>)
 810a030:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 810a034:	0810a04d 	.word	0x0810a04d
 810a038:	0810a055 	.word	0x0810a055
 810a03c:	0810a05d 	.word	0x0810a05d
 810a040:	0810a085 	.word	0x0810a085
 810a044:	0810a08d 	.word	0x0810a08d
 810a048:	0810a095 	.word	0x0810a095
 810a04c:	2300      	movs	r3, #0
 810a04e:	f887 3043 	strb.w	r3, [r7, #67]	; 0x43
 810a052:	e148      	b.n	810a2e6 <UART_SetConfig+0x5a6>
 810a054:	2304      	movs	r3, #4
 810a056:	f887 3043 	strb.w	r3, [r7, #67]	; 0x43
 810a05a:	e144      	b.n	810a2e6 <UART_SetConfig+0x5a6>
 810a05c:	2308      	movs	r3, #8
 810a05e:	f887 3043 	strb.w	r3, [r7, #67]	; 0x43
 810a062:	e140      	b.n	810a2e6 <UART_SetConfig+0x5a6>
 810a064:	cfff69f3 	.word	0xcfff69f3
 810a068:	58000c00 	.word	0x58000c00
 810a06c:	40011000 	.word	0x40011000
 810a070:	58024400 	.word	0x58024400
 810a074:	40004400 	.word	0x40004400
 810a078:	40004800 	.word	0x40004800
 810a07c:	40004c00 	.word	0x40004c00
 810a080:	40005000 	.word	0x40005000
 810a084:	2310      	movs	r3, #16
 810a086:	f887 3043 	strb.w	r3, [r7, #67]	; 0x43
 810a08a:	e12c      	b.n	810a2e6 <UART_SetConfig+0x5a6>
 810a08c:	2320      	movs	r3, #32
 810a08e:	f887 3043 	strb.w	r3, [r7, #67]	; 0x43
 810a092:	e128      	b.n	810a2e6 <UART_SetConfig+0x5a6>
 810a094:	2340      	movs	r3, #64	; 0x40
 810a096:	f887 3043 	strb.w	r3, [r7, #67]	; 0x43
 810a09a:	e124      	b.n	810a2e6 <UART_SetConfig+0x5a6>
 810a09c:	2380      	movs	r3, #128	; 0x80
 810a09e:	f887 3043 	strb.w	r3, [r7, #67]	; 0x43
 810a0a2:	e120      	b.n	810a2e6 <UART_SetConfig+0x5a6>
 810a0a4:	697b      	ldr	r3, [r7, #20]
 810a0a6:	681b      	ldr	r3, [r3, #0]
 810a0a8:	4acb      	ldr	r2, [pc, #812]	; (810a3d8 <UART_SetConfig+0x698>)
 810a0aa:	4293      	cmp	r3, r2
 810a0ac:	d176      	bne.n	810a19c <UART_SetConfig+0x45c>
 810a0ae:	4bcb      	ldr	r3, [pc, #812]	; (810a3dc <UART_SetConfig+0x69c>)
 810a0b0:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 810a0b2:	f003 0338 	and.w	r3, r3, #56	; 0x38
 810a0b6:	2b28      	cmp	r3, #40	; 0x28
 810a0b8:	d86c      	bhi.n	810a194 <UART_SetConfig+0x454>
 810a0ba:	a201      	add	r2, pc, #4	; (adr r2, 810a0c0 <UART_SetConfig+0x380>)
 810a0bc:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 810a0c0:	0810a165 	.word	0x0810a165
 810a0c4:	0810a195 	.word	0x0810a195
 810a0c8:	0810a195 	.word	0x0810a195
 810a0cc:	0810a195 	.word	0x0810a195
 810a0d0:	0810a195 	.word	0x0810a195
 810a0d4:	0810a195 	.word	0x0810a195
 810a0d8:	0810a195 	.word	0x0810a195
 810a0dc:	0810a195 	.word	0x0810a195
 810a0e0:	0810a16d 	.word	0x0810a16d
 810a0e4:	0810a195 	.word	0x0810a195
 810a0e8:	0810a195 	.word	0x0810a195
 810a0ec:	0810a195 	.word	0x0810a195
 810a0f0:	0810a195 	.word	0x0810a195
 810a0f4:	0810a195 	.word	0x0810a195
 810a0f8:	0810a195 	.word	0x0810a195
 810a0fc:	0810a195 	.word	0x0810a195
 810a100:	0810a175 	.word	0x0810a175
 810a104:	0810a195 	.word	0x0810a195
 810a108:	0810a195 	.word	0x0810a195
 810a10c:	0810a195 	.word	0x0810a195
 810a110:	0810a195 	.word	0x0810a195
 810a114:	0810a195 	.word	0x0810a195
 810a118:	0810a195 	.word	0x0810a195
 810a11c:	0810a195 	.word	0x0810a195
 810a120:	0810a17d 	.word	0x0810a17d
 810a124:	0810a195 	.word	0x0810a195
 810a128:	0810a195 	.word	0x0810a195
 810a12c:	0810a195 	.word	0x0810a195
 810a130:	0810a195 	.word	0x0810a195
 810a134:	0810a195 	.word	0x0810a195
 810a138:	0810a195 	.word	0x0810a195
 810a13c:	0810a195 	.word	0x0810a195
 810a140:	0810a185 	.word	0x0810a185
 810a144:	0810a195 	.word	0x0810a195
 810a148:	0810a195 	.word	0x0810a195
 810a14c:	0810a195 	.word	0x0810a195
 810a150:	0810a195 	.word	0x0810a195
 810a154:	0810a195 	.word	0x0810a195
 810a158:	0810a195 	.word	0x0810a195
 810a15c:	0810a195 	.word	0x0810a195
 810a160:	0810a18d 	.word	0x0810a18d
 810a164:	2301      	movs	r3, #1
 810a166:	f887 3043 	strb.w	r3, [r7, #67]	; 0x43
 810a16a:	e0bc      	b.n	810a2e6 <UART_SetConfig+0x5a6>
 810a16c:	2304      	movs	r3, #4
 810a16e:	f887 3043 	strb.w	r3, [r7, #67]	; 0x43
 810a172:	e0b8      	b.n	810a2e6 <UART_SetConfig+0x5a6>
 810a174:	2308      	movs	r3, #8
 810a176:	f887 3043 	strb.w	r3, [r7, #67]	; 0x43
 810a17a:	e0b4      	b.n	810a2e6 <UART_SetConfig+0x5a6>
 810a17c:	2310      	movs	r3, #16
 810a17e:	f887 3043 	strb.w	r3, [r7, #67]	; 0x43
 810a182:	e0b0      	b.n	810a2e6 <UART_SetConfig+0x5a6>
 810a184:	2320      	movs	r3, #32
 810a186:	f887 3043 	strb.w	r3, [r7, #67]	; 0x43
 810a18a:	e0ac      	b.n	810a2e6 <UART_SetConfig+0x5a6>
 810a18c:	2340      	movs	r3, #64	; 0x40
 810a18e:	f887 3043 	strb.w	r3, [r7, #67]	; 0x43
 810a192:	e0a8      	b.n	810a2e6 <UART_SetConfig+0x5a6>
 810a194:	2380      	movs	r3, #128	; 0x80
 810a196:	f887 3043 	strb.w	r3, [r7, #67]	; 0x43
 810a19a:	e0a4      	b.n	810a2e6 <UART_SetConfig+0x5a6>
 810a19c:	697b      	ldr	r3, [r7, #20]
 810a19e:	681b      	ldr	r3, [r3, #0]
 810a1a0:	4a8f      	ldr	r2, [pc, #572]	; (810a3e0 <UART_SetConfig+0x6a0>)
 810a1a2:	4293      	cmp	r3, r2
 810a1a4:	d130      	bne.n	810a208 <UART_SetConfig+0x4c8>
 810a1a6:	4b8d      	ldr	r3, [pc, #564]	; (810a3dc <UART_SetConfig+0x69c>)
 810a1a8:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 810a1aa:	f003 0307 	and.w	r3, r3, #7
 810a1ae:	2b05      	cmp	r3, #5
 810a1b0:	d826      	bhi.n	810a200 <UART_SetConfig+0x4c0>
 810a1b2:	a201      	add	r2, pc, #4	; (adr r2, 810a1b8 <UART_SetConfig+0x478>)
 810a1b4:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 810a1b8:	0810a1d1 	.word	0x0810a1d1
 810a1bc:	0810a1d9 	.word	0x0810a1d9
 810a1c0:	0810a1e1 	.word	0x0810a1e1
 810a1c4:	0810a1e9 	.word	0x0810a1e9
 810a1c8:	0810a1f1 	.word	0x0810a1f1
 810a1cc:	0810a1f9 	.word	0x0810a1f9
 810a1d0:	2300      	movs	r3, #0
 810a1d2:	f887 3043 	strb.w	r3, [r7, #67]	; 0x43
 810a1d6:	e086      	b.n	810a2e6 <UART_SetConfig+0x5a6>
 810a1d8:	2304      	movs	r3, #4
 810a1da:	f887 3043 	strb.w	r3, [r7, #67]	; 0x43
 810a1de:	e082      	b.n	810a2e6 <UART_SetConfig+0x5a6>
 810a1e0:	2308      	movs	r3, #8
 810a1e2:	f887 3043 	strb.w	r3, [r7, #67]	; 0x43
 810a1e6:	e07e      	b.n	810a2e6 <UART_SetConfig+0x5a6>
 810a1e8:	2310      	movs	r3, #16
 810a1ea:	f887 3043 	strb.w	r3, [r7, #67]	; 0x43
 810a1ee:	e07a      	b.n	810a2e6 <UART_SetConfig+0x5a6>
 810a1f0:	2320      	movs	r3, #32
 810a1f2:	f887 3043 	strb.w	r3, [r7, #67]	; 0x43
 810a1f6:	e076      	b.n	810a2e6 <UART_SetConfig+0x5a6>
 810a1f8:	2340      	movs	r3, #64	; 0x40
 810a1fa:	f887 3043 	strb.w	r3, [r7, #67]	; 0x43
 810a1fe:	e072      	b.n	810a2e6 <UART_SetConfig+0x5a6>
 810a200:	2380      	movs	r3, #128	; 0x80
 810a202:	f887 3043 	strb.w	r3, [r7, #67]	; 0x43
 810a206:	e06e      	b.n	810a2e6 <UART_SetConfig+0x5a6>
 810a208:	697b      	ldr	r3, [r7, #20]
 810a20a:	681b      	ldr	r3, [r3, #0]
 810a20c:	4a75      	ldr	r2, [pc, #468]	; (810a3e4 <UART_SetConfig+0x6a4>)
 810a20e:	4293      	cmp	r3, r2
 810a210:	d130      	bne.n	810a274 <UART_SetConfig+0x534>
 810a212:	4b72      	ldr	r3, [pc, #456]	; (810a3dc <UART_SetConfig+0x69c>)
 810a214:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 810a216:	f003 0307 	and.w	r3, r3, #7
 810a21a:	2b05      	cmp	r3, #5
 810a21c:	d826      	bhi.n	810a26c <UART_SetConfig+0x52c>
 810a21e:	a201      	add	r2, pc, #4	; (adr r2, 810a224 <UART_SetConfig+0x4e4>)
 810a220:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 810a224:	0810a23d 	.word	0x0810a23d
 810a228:	0810a245 	.word	0x0810a245
 810a22c:	0810a24d 	.word	0x0810a24d
 810a230:	0810a255 	.word	0x0810a255
 810a234:	0810a25d 	.word	0x0810a25d
 810a238:	0810a265 	.word	0x0810a265
 810a23c:	2300      	movs	r3, #0
 810a23e:	f887 3043 	strb.w	r3, [r7, #67]	; 0x43
 810a242:	e050      	b.n	810a2e6 <UART_SetConfig+0x5a6>
 810a244:	2304      	movs	r3, #4
 810a246:	f887 3043 	strb.w	r3, [r7, #67]	; 0x43
 810a24a:	e04c      	b.n	810a2e6 <UART_SetConfig+0x5a6>
 810a24c:	2308      	movs	r3, #8
 810a24e:	f887 3043 	strb.w	r3, [r7, #67]	; 0x43
 810a252:	e048      	b.n	810a2e6 <UART_SetConfig+0x5a6>
 810a254:	2310      	movs	r3, #16
 810a256:	f887 3043 	strb.w	r3, [r7, #67]	; 0x43
 810a25a:	e044      	b.n	810a2e6 <UART_SetConfig+0x5a6>
 810a25c:	2320      	movs	r3, #32
 810a25e:	f887 3043 	strb.w	r3, [r7, #67]	; 0x43
 810a262:	e040      	b.n	810a2e6 <UART_SetConfig+0x5a6>
 810a264:	2340      	movs	r3, #64	; 0x40
 810a266:	f887 3043 	strb.w	r3, [r7, #67]	; 0x43
 810a26a:	e03c      	b.n	810a2e6 <UART_SetConfig+0x5a6>
 810a26c:	2380      	movs	r3, #128	; 0x80
 810a26e:	f887 3043 	strb.w	r3, [r7, #67]	; 0x43
 810a272:	e038      	b.n	810a2e6 <UART_SetConfig+0x5a6>
 810a274:	697b      	ldr	r3, [r7, #20]
 810a276:	681b      	ldr	r3, [r3, #0]
 810a278:	4a5b      	ldr	r2, [pc, #364]	; (810a3e8 <UART_SetConfig+0x6a8>)
 810a27a:	4293      	cmp	r3, r2
 810a27c:	d130      	bne.n	810a2e0 <UART_SetConfig+0x5a0>
 810a27e:	4b57      	ldr	r3, [pc, #348]	; (810a3dc <UART_SetConfig+0x69c>)
 810a280:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 810a282:	f003 0307 	and.w	r3, r3, #7
 810a286:	2b05      	cmp	r3, #5
 810a288:	d826      	bhi.n	810a2d8 <UART_SetConfig+0x598>
 810a28a:	a201      	add	r2, pc, #4	; (adr r2, 810a290 <UART_SetConfig+0x550>)
 810a28c:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 810a290:	0810a2a9 	.word	0x0810a2a9
 810a294:	0810a2b1 	.word	0x0810a2b1
 810a298:	0810a2b9 	.word	0x0810a2b9
 810a29c:	0810a2c1 	.word	0x0810a2c1
 810a2a0:	0810a2c9 	.word	0x0810a2c9
 810a2a4:	0810a2d1 	.word	0x0810a2d1
 810a2a8:	2302      	movs	r3, #2
 810a2aa:	f887 3043 	strb.w	r3, [r7, #67]	; 0x43
 810a2ae:	e01a      	b.n	810a2e6 <UART_SetConfig+0x5a6>
 810a2b0:	2304      	movs	r3, #4
 810a2b2:	f887 3043 	strb.w	r3, [r7, #67]	; 0x43
 810a2b6:	e016      	b.n	810a2e6 <UART_SetConfig+0x5a6>
 810a2b8:	2308      	movs	r3, #8
 810a2ba:	f887 3043 	strb.w	r3, [r7, #67]	; 0x43
 810a2be:	e012      	b.n	810a2e6 <UART_SetConfig+0x5a6>
 810a2c0:	2310      	movs	r3, #16
 810a2c2:	f887 3043 	strb.w	r3, [r7, #67]	; 0x43
 810a2c6:	e00e      	b.n	810a2e6 <UART_SetConfig+0x5a6>
 810a2c8:	2320      	movs	r3, #32
 810a2ca:	f887 3043 	strb.w	r3, [r7, #67]	; 0x43
 810a2ce:	e00a      	b.n	810a2e6 <UART_SetConfig+0x5a6>
 810a2d0:	2340      	movs	r3, #64	; 0x40
 810a2d2:	f887 3043 	strb.w	r3, [r7, #67]	; 0x43
 810a2d6:	e006      	b.n	810a2e6 <UART_SetConfig+0x5a6>
 810a2d8:	2380      	movs	r3, #128	; 0x80
 810a2da:	f887 3043 	strb.w	r3, [r7, #67]	; 0x43
 810a2de:	e002      	b.n	810a2e6 <UART_SetConfig+0x5a6>
 810a2e0:	2380      	movs	r3, #128	; 0x80
 810a2e2:	f887 3043 	strb.w	r3, [r7, #67]	; 0x43

  /* Check LPUART instance */
  if (UART_INSTANCE_LOWPOWER(huart))
 810a2e6:	697b      	ldr	r3, [r7, #20]
 810a2e8:	681b      	ldr	r3, [r3, #0]
 810a2ea:	4a3f      	ldr	r2, [pc, #252]	; (810a3e8 <UART_SetConfig+0x6a8>)
 810a2ec:	4293      	cmp	r3, r2
 810a2ee:	f040 80f8 	bne.w	810a4e2 <UART_SetConfig+0x7a2>
  {
    /* Retrieve frequency clock */
    switch (clocksource)
 810a2f2:	f897 3043 	ldrb.w	r3, [r7, #67]	; 0x43
 810a2f6:	2b20      	cmp	r3, #32
 810a2f8:	dc46      	bgt.n	810a388 <UART_SetConfig+0x648>
 810a2fa:	2b02      	cmp	r3, #2
 810a2fc:	f2c0 8082 	blt.w	810a404 <UART_SetConfig+0x6c4>
 810a300:	3b02      	subs	r3, #2
 810a302:	2b1e      	cmp	r3, #30
 810a304:	d87e      	bhi.n	810a404 <UART_SetConfig+0x6c4>
 810a306:	a201      	add	r2, pc, #4	; (adr r2, 810a30c <UART_SetConfig+0x5cc>)
 810a308:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 810a30c:	0810a38f 	.word	0x0810a38f
 810a310:	0810a405 	.word	0x0810a405
 810a314:	0810a397 	.word	0x0810a397
 810a318:	0810a405 	.word	0x0810a405
 810a31c:	0810a405 	.word	0x0810a405
 810a320:	0810a405 	.word	0x0810a405
 810a324:	0810a3a7 	.word	0x0810a3a7
 810a328:	0810a405 	.word	0x0810a405
 810a32c:	0810a405 	.word	0x0810a405
 810a330:	0810a405 	.word	0x0810a405
 810a334:	0810a405 	.word	0x0810a405
 810a338:	0810a405 	.word	0x0810a405
 810a33c:	0810a405 	.word	0x0810a405
 810a340:	0810a405 	.word	0x0810a405
 810a344:	0810a3b7 	.word	0x0810a3b7
 810a348:	0810a405 	.word	0x0810a405
 810a34c:	0810a405 	.word	0x0810a405
 810a350:	0810a405 	.word	0x0810a405
 810a354:	0810a405 	.word	0x0810a405
 810a358:	0810a405 	.word	0x0810a405
 810a35c:	0810a405 	.word	0x0810a405
 810a360:	0810a405 	.word	0x0810a405
 810a364:	0810a405 	.word	0x0810a405
 810a368:	0810a405 	.word	0x0810a405
 810a36c:	0810a405 	.word	0x0810a405
 810a370:	0810a405 	.word	0x0810a405
 810a374:	0810a405 	.word	0x0810a405
 810a378:	0810a405 	.word	0x0810a405
 810a37c:	0810a405 	.word	0x0810a405
 810a380:	0810a405 	.word	0x0810a405
 810a384:	0810a3f7 	.word	0x0810a3f7
 810a388:	2b40      	cmp	r3, #64	; 0x40
 810a38a:	d037      	beq.n	810a3fc <UART_SetConfig+0x6bc>
 810a38c:	e03a      	b.n	810a404 <UART_SetConfig+0x6c4>
    {
      case UART_CLOCKSOURCE_D3PCLK1:
        pclk = HAL_RCCEx_GetD3PCLK1Freq();
 810a38e:	f7fe fe7b 	bl	8109088 <HAL_RCCEx_GetD3PCLK1Freq>
 810a392:	63f8      	str	r0, [r7, #60]	; 0x3c
        break;
 810a394:	e03c      	b.n	810a410 <UART_SetConfig+0x6d0>
      case UART_CLOCKSOURCE_PLL2:
        HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
 810a396:	f107 0324 	add.w	r3, r7, #36	; 0x24
 810a39a:	4618      	mov	r0, r3
 810a39c:	f7fe fe8a 	bl	81090b4 <HAL_RCCEx_GetPLL2ClockFreq>
        pclk = pll2_clocks.PLL2_Q_Frequency;
 810a3a0:	6abb      	ldr	r3, [r7, #40]	; 0x28
 810a3a2:	63fb      	str	r3, [r7, #60]	; 0x3c
        break;
 810a3a4:	e034      	b.n	810a410 <UART_SetConfig+0x6d0>
      case UART_CLOCKSOURCE_PLL3:
        HAL_RCCEx_GetPLL3ClockFreq(&pll3_clocks);
 810a3a6:	f107 0318 	add.w	r3, r7, #24
 810a3aa:	4618      	mov	r0, r3
 810a3ac:	f7fe ffd6 	bl	810935c <HAL_RCCEx_GetPLL3ClockFreq>
        pclk = pll3_clocks.PLL3_Q_Frequency;
 810a3b0:	69fb      	ldr	r3, [r7, #28]
 810a3b2:	63fb      	str	r3, [r7, #60]	; 0x3c
        break;
 810a3b4:	e02c      	b.n	810a410 <UART_SetConfig+0x6d0>
      case UART_CLOCKSOURCE_HSI:
        if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIV) != 0U)
 810a3b6:	4b09      	ldr	r3, [pc, #36]	; (810a3dc <UART_SetConfig+0x69c>)
 810a3b8:	681b      	ldr	r3, [r3, #0]
 810a3ba:	f003 0320 	and.w	r3, r3, #32
 810a3be:	2b00      	cmp	r3, #0
 810a3c0:	d016      	beq.n	810a3f0 <UART_SetConfig+0x6b0>
        {
          pclk = (uint32_t)(HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> 3U));
 810a3c2:	4b06      	ldr	r3, [pc, #24]	; (810a3dc <UART_SetConfig+0x69c>)
 810a3c4:	681b      	ldr	r3, [r3, #0]
 810a3c6:	08db      	lsrs	r3, r3, #3
 810a3c8:	f003 0303 	and.w	r3, r3, #3
 810a3cc:	4a07      	ldr	r2, [pc, #28]	; (810a3ec <UART_SetConfig+0x6ac>)
 810a3ce:	fa22 f303 	lsr.w	r3, r2, r3
 810a3d2:	63fb      	str	r3, [r7, #60]	; 0x3c
        }
        else
        {
          pclk = (uint32_t) HSI_VALUE;
        }
        break;
 810a3d4:	e01c      	b.n	810a410 <UART_SetConfig+0x6d0>
 810a3d6:	bf00      	nop
 810a3d8:	40011400 	.word	0x40011400
 810a3dc:	58024400 	.word	0x58024400
 810a3e0:	40007800 	.word	0x40007800
 810a3e4:	40007c00 	.word	0x40007c00
 810a3e8:	58000c00 	.word	0x58000c00
 810a3ec:	03d09000 	.word	0x03d09000
          pclk = (uint32_t) HSI_VALUE;
 810a3f0:	4b9d      	ldr	r3, [pc, #628]	; (810a668 <UART_SetConfig+0x928>)
 810a3f2:	63fb      	str	r3, [r7, #60]	; 0x3c
        break;
 810a3f4:	e00c      	b.n	810a410 <UART_SetConfig+0x6d0>
      case UART_CLOCKSOURCE_CSI:
        pclk = (uint32_t) CSI_VALUE;
 810a3f6:	4b9d      	ldr	r3, [pc, #628]	; (810a66c <UART_SetConfig+0x92c>)
 810a3f8:	63fb      	str	r3, [r7, #60]	; 0x3c
        break;
 810a3fa:	e009      	b.n	810a410 <UART_SetConfig+0x6d0>
      case UART_CLOCKSOURCE_LSE:
        pclk = (uint32_t) LSE_VALUE;
 810a3fc:	f44f 4300 	mov.w	r3, #32768	; 0x8000
 810a400:	63fb      	str	r3, [r7, #60]	; 0x3c
        break;
 810a402:	e005      	b.n	810a410 <UART_SetConfig+0x6d0>
      default:
        pclk = 0U;
 810a404:	2300      	movs	r3, #0
 810a406:	63fb      	str	r3, [r7, #60]	; 0x3c
        ret = HAL_ERROR;
 810a408:	2301      	movs	r3, #1
 810a40a:	f887 3042 	strb.w	r3, [r7, #66]	; 0x42
        break;
 810a40e:	bf00      	nop
    }

    /* If proper clock source reported */
    if (pclk != 0U)
 810a410:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 810a412:	2b00      	cmp	r3, #0
 810a414:	f000 81de 	beq.w	810a7d4 <UART_SetConfig+0xa94>
    {
      /* Compute clock after Prescaler */
      lpuart_ker_ck_pres = (pclk / UARTPrescTable[huart->Init.ClockPrescaler]);
 810a418:	697b      	ldr	r3, [r7, #20]
 810a41a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 810a41c:	4a94      	ldr	r2, [pc, #592]	; (810a670 <UART_SetConfig+0x930>)
 810a41e:	f832 3013 	ldrh.w	r3, [r2, r3, lsl #1]
 810a422:	461a      	mov	r2, r3
 810a424:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 810a426:	fbb3 f3f2 	udiv	r3, r3, r2
 810a42a:	633b      	str	r3, [r7, #48]	; 0x30

      /* Ensure that Frequency clock is in the range [3 * baudrate, 4096 * baudrate] */
      if ((lpuart_ker_ck_pres < (3U * huart->Init.BaudRate)) ||
 810a42c:	697b      	ldr	r3, [r7, #20]
 810a42e:	685a      	ldr	r2, [r3, #4]
 810a430:	4613      	mov	r3, r2
 810a432:	005b      	lsls	r3, r3, #1
 810a434:	4413      	add	r3, r2
 810a436:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 810a438:	429a      	cmp	r2, r3
 810a43a:	d305      	bcc.n	810a448 <UART_SetConfig+0x708>
          (lpuart_ker_ck_pres > (4096U * huart->Init.BaudRate)))
 810a43c:	697b      	ldr	r3, [r7, #20]
 810a43e:	685b      	ldr	r3, [r3, #4]
 810a440:	031b      	lsls	r3, r3, #12
      if ((lpuart_ker_ck_pres < (3U * huart->Init.BaudRate)) ||
 810a442:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 810a444:	429a      	cmp	r2, r3
 810a446:	d903      	bls.n	810a450 <UART_SetConfig+0x710>
      {
        ret = HAL_ERROR;
 810a448:	2301      	movs	r3, #1
 810a44a:	f887 3042 	strb.w	r3, [r7, #66]	; 0x42
 810a44e:	e1c1      	b.n	810a7d4 <UART_SetConfig+0xa94>
      }
      else
      {
        /* Check computed UsartDiv value is in allocated range
           (it is forbidden to write values lower than 0x300 in the LPUART_BRR register) */
        usartdiv = (uint32_t)(UART_DIV_LPUART(pclk, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 810a450:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 810a452:	2200      	movs	r2, #0
 810a454:	60bb      	str	r3, [r7, #8]
 810a456:	60fa      	str	r2, [r7, #12]
 810a458:	697b      	ldr	r3, [r7, #20]
 810a45a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 810a45c:	4a84      	ldr	r2, [pc, #528]	; (810a670 <UART_SetConfig+0x930>)
 810a45e:	f832 3013 	ldrh.w	r3, [r2, r3, lsl #1]
 810a462:	b29b      	uxth	r3, r3
 810a464:	2200      	movs	r2, #0
 810a466:	603b      	str	r3, [r7, #0]
 810a468:	607a      	str	r2, [r7, #4]
 810a46a:	e9d7 2300 	ldrd	r2, r3, [r7]
 810a46e:	e9d7 0102 	ldrd	r0, r1, [r7, #8]
 810a472:	f7f5 ff8d 	bl	8100390 <__aeabi_uldivmod>
 810a476:	4602      	mov	r2, r0
 810a478:	460b      	mov	r3, r1
 810a47a:	4610      	mov	r0, r2
 810a47c:	4619      	mov	r1, r3
 810a47e:	f04f 0200 	mov.w	r2, #0
 810a482:	f04f 0300 	mov.w	r3, #0
 810a486:	020b      	lsls	r3, r1, #8
 810a488:	ea43 6310 	orr.w	r3, r3, r0, lsr #24
 810a48c:	0202      	lsls	r2, r0, #8
 810a48e:	6979      	ldr	r1, [r7, #20]
 810a490:	6849      	ldr	r1, [r1, #4]
 810a492:	0849      	lsrs	r1, r1, #1
 810a494:	2000      	movs	r0, #0
 810a496:	460c      	mov	r4, r1
 810a498:	4605      	mov	r5, r0
 810a49a:	eb12 0804 	adds.w	r8, r2, r4
 810a49e:	eb43 0905 	adc.w	r9, r3, r5
 810a4a2:	697b      	ldr	r3, [r7, #20]
 810a4a4:	685b      	ldr	r3, [r3, #4]
 810a4a6:	2200      	movs	r2, #0
 810a4a8:	469a      	mov	sl, r3
 810a4aa:	4693      	mov	fp, r2
 810a4ac:	4652      	mov	r2, sl
 810a4ae:	465b      	mov	r3, fp
 810a4b0:	4640      	mov	r0, r8
 810a4b2:	4649      	mov	r1, r9
 810a4b4:	f7f5 ff6c 	bl	8100390 <__aeabi_uldivmod>
 810a4b8:	4602      	mov	r2, r0
 810a4ba:	460b      	mov	r3, r1
 810a4bc:	4613      	mov	r3, r2
 810a4be:	63bb      	str	r3, [r7, #56]	; 0x38
        if ((usartdiv >= LPUART_BRR_MIN) && (usartdiv <= LPUART_BRR_MAX))
 810a4c0:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 810a4c2:	f5b3 7f40 	cmp.w	r3, #768	; 0x300
 810a4c6:	d308      	bcc.n	810a4da <UART_SetConfig+0x79a>
 810a4c8:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 810a4ca:	f5b3 1f80 	cmp.w	r3, #1048576	; 0x100000
 810a4ce:	d204      	bcs.n	810a4da <UART_SetConfig+0x79a>
        {
          huart->Instance->BRR = usartdiv;
 810a4d0:	697b      	ldr	r3, [r7, #20]
 810a4d2:	681b      	ldr	r3, [r3, #0]
 810a4d4:	6bba      	ldr	r2, [r7, #56]	; 0x38
 810a4d6:	60da      	str	r2, [r3, #12]
 810a4d8:	e17c      	b.n	810a7d4 <UART_SetConfig+0xa94>
        }
        else
        {
          ret = HAL_ERROR;
 810a4da:	2301      	movs	r3, #1
 810a4dc:	f887 3042 	strb.w	r3, [r7, #66]	; 0x42
 810a4e0:	e178      	b.n	810a7d4 <UART_SetConfig+0xa94>
      } /* if ( (lpuart_ker_ck_pres < (3 * huart->Init.BaudRate) ) ||
                (lpuart_ker_ck_pres > (4096 * huart->Init.BaudRate) )) */
    } /* if (pclk != 0) */
  }
  /* Check UART Over Sampling to set Baud Rate Register */
  else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 810a4e2:	697b      	ldr	r3, [r7, #20]
 810a4e4:	69db      	ldr	r3, [r3, #28]
 810a4e6:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
 810a4ea:	f040 80c5 	bne.w	810a678 <UART_SetConfig+0x938>
  {
    switch (clocksource)
 810a4ee:	f897 3043 	ldrb.w	r3, [r7, #67]	; 0x43
 810a4f2:	2b20      	cmp	r3, #32
 810a4f4:	dc48      	bgt.n	810a588 <UART_SetConfig+0x848>
 810a4f6:	2b00      	cmp	r3, #0
 810a4f8:	db7b      	blt.n	810a5f2 <UART_SetConfig+0x8b2>
 810a4fa:	2b20      	cmp	r3, #32
 810a4fc:	d879      	bhi.n	810a5f2 <UART_SetConfig+0x8b2>
 810a4fe:	a201      	add	r2, pc, #4	; (adr r2, 810a504 <UART_SetConfig+0x7c4>)
 810a500:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 810a504:	0810a58f 	.word	0x0810a58f
 810a508:	0810a597 	.word	0x0810a597
 810a50c:	0810a5f3 	.word	0x0810a5f3
 810a510:	0810a5f3 	.word	0x0810a5f3
 810a514:	0810a59f 	.word	0x0810a59f
 810a518:	0810a5f3 	.word	0x0810a5f3
 810a51c:	0810a5f3 	.word	0x0810a5f3
 810a520:	0810a5f3 	.word	0x0810a5f3
 810a524:	0810a5af 	.word	0x0810a5af
 810a528:	0810a5f3 	.word	0x0810a5f3
 810a52c:	0810a5f3 	.word	0x0810a5f3
 810a530:	0810a5f3 	.word	0x0810a5f3
 810a534:	0810a5f3 	.word	0x0810a5f3
 810a538:	0810a5f3 	.word	0x0810a5f3
 810a53c:	0810a5f3 	.word	0x0810a5f3
 810a540:	0810a5f3 	.word	0x0810a5f3
 810a544:	0810a5bf 	.word	0x0810a5bf
 810a548:	0810a5f3 	.word	0x0810a5f3
 810a54c:	0810a5f3 	.word	0x0810a5f3
 810a550:	0810a5f3 	.word	0x0810a5f3
 810a554:	0810a5f3 	.word	0x0810a5f3
 810a558:	0810a5f3 	.word	0x0810a5f3
 810a55c:	0810a5f3 	.word	0x0810a5f3
 810a560:	0810a5f3 	.word	0x0810a5f3
 810a564:	0810a5f3 	.word	0x0810a5f3
 810a568:	0810a5f3 	.word	0x0810a5f3
 810a56c:	0810a5f3 	.word	0x0810a5f3
 810a570:	0810a5f3 	.word	0x0810a5f3
 810a574:	0810a5f3 	.word	0x0810a5f3
 810a578:	0810a5f3 	.word	0x0810a5f3
 810a57c:	0810a5f3 	.word	0x0810a5f3
 810a580:	0810a5f3 	.word	0x0810a5f3
 810a584:	0810a5e5 	.word	0x0810a5e5
 810a588:	2b40      	cmp	r3, #64	; 0x40
 810a58a:	d02e      	beq.n	810a5ea <UART_SetConfig+0x8aa>
 810a58c:	e031      	b.n	810a5f2 <UART_SetConfig+0x8b2>
    {
      case UART_CLOCKSOURCE_D2PCLK1:
        pclk = HAL_RCC_GetPCLK1Freq();
 810a58e:	f7fc fdc5 	bl	810711c <HAL_RCC_GetPCLK1Freq>
 810a592:	63f8      	str	r0, [r7, #60]	; 0x3c
        break;
 810a594:	e033      	b.n	810a5fe <UART_SetConfig+0x8be>
      case UART_CLOCKSOURCE_D2PCLK2:
        pclk = HAL_RCC_GetPCLK2Freq();
 810a596:	f7fc fdd7 	bl	8107148 <HAL_RCC_GetPCLK2Freq>
 810a59a:	63f8      	str	r0, [r7, #60]	; 0x3c
        break;
 810a59c:	e02f      	b.n	810a5fe <UART_SetConfig+0x8be>
      case UART_CLOCKSOURCE_PLL2:
        HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
 810a59e:	f107 0324 	add.w	r3, r7, #36	; 0x24
 810a5a2:	4618      	mov	r0, r3
 810a5a4:	f7fe fd86 	bl	81090b4 <HAL_RCCEx_GetPLL2ClockFreq>
        pclk = pll2_clocks.PLL2_Q_Frequency;
 810a5a8:	6abb      	ldr	r3, [r7, #40]	; 0x28
 810a5aa:	63fb      	str	r3, [r7, #60]	; 0x3c
        break;
 810a5ac:	e027      	b.n	810a5fe <UART_SetConfig+0x8be>
      case UART_CLOCKSOURCE_PLL3:
        HAL_RCCEx_GetPLL3ClockFreq(&pll3_clocks);
 810a5ae:	f107 0318 	add.w	r3, r7, #24
 810a5b2:	4618      	mov	r0, r3
 810a5b4:	f7fe fed2 	bl	810935c <HAL_RCCEx_GetPLL3ClockFreq>
        pclk = pll3_clocks.PLL3_Q_Frequency;
 810a5b8:	69fb      	ldr	r3, [r7, #28]
 810a5ba:	63fb      	str	r3, [r7, #60]	; 0x3c
        break;
 810a5bc:	e01f      	b.n	810a5fe <UART_SetConfig+0x8be>
      case UART_CLOCKSOURCE_HSI:
        if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIV) != 0U)
 810a5be:	4b2d      	ldr	r3, [pc, #180]	; (810a674 <UART_SetConfig+0x934>)
 810a5c0:	681b      	ldr	r3, [r3, #0]
 810a5c2:	f003 0320 	and.w	r3, r3, #32
 810a5c6:	2b00      	cmp	r3, #0
 810a5c8:	d009      	beq.n	810a5de <UART_SetConfig+0x89e>
        {
          pclk = (uint32_t)(HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> 3U));
 810a5ca:	4b2a      	ldr	r3, [pc, #168]	; (810a674 <UART_SetConfig+0x934>)
 810a5cc:	681b      	ldr	r3, [r3, #0]
 810a5ce:	08db      	lsrs	r3, r3, #3
 810a5d0:	f003 0303 	and.w	r3, r3, #3
 810a5d4:	4a24      	ldr	r2, [pc, #144]	; (810a668 <UART_SetConfig+0x928>)
 810a5d6:	fa22 f303 	lsr.w	r3, r2, r3
 810a5da:	63fb      	str	r3, [r7, #60]	; 0x3c
        }
        else
        {
          pclk = (uint32_t) HSI_VALUE;
        }
        break;
 810a5dc:	e00f      	b.n	810a5fe <UART_SetConfig+0x8be>
          pclk = (uint32_t) HSI_VALUE;
 810a5de:	4b22      	ldr	r3, [pc, #136]	; (810a668 <UART_SetConfig+0x928>)
 810a5e0:	63fb      	str	r3, [r7, #60]	; 0x3c
        break;
 810a5e2:	e00c      	b.n	810a5fe <UART_SetConfig+0x8be>
      case UART_CLOCKSOURCE_CSI:
        pclk = (uint32_t) CSI_VALUE;
 810a5e4:	4b21      	ldr	r3, [pc, #132]	; (810a66c <UART_SetConfig+0x92c>)
 810a5e6:	63fb      	str	r3, [r7, #60]	; 0x3c
        break;
 810a5e8:	e009      	b.n	810a5fe <UART_SetConfig+0x8be>
      case UART_CLOCKSOURCE_LSE:
        pclk = (uint32_t) LSE_VALUE;
 810a5ea:	f44f 4300 	mov.w	r3, #32768	; 0x8000
 810a5ee:	63fb      	str	r3, [r7, #60]	; 0x3c
        break;
 810a5f0:	e005      	b.n	810a5fe <UART_SetConfig+0x8be>
      default:
        pclk = 0U;
 810a5f2:	2300      	movs	r3, #0
 810a5f4:	63fb      	str	r3, [r7, #60]	; 0x3c
        ret = HAL_ERROR;
 810a5f6:	2301      	movs	r3, #1
 810a5f8:	f887 3042 	strb.w	r3, [r7, #66]	; 0x42
        break;
 810a5fc:	bf00      	nop
    }

    /* USARTDIV must be greater than or equal to 0d16 */
    if (pclk != 0U)
 810a5fe:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 810a600:	2b00      	cmp	r3, #0
 810a602:	f000 80e7 	beq.w	810a7d4 <UART_SetConfig+0xa94>
    {
      usartdiv = (uint32_t)(UART_DIV_SAMPLING8(pclk, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 810a606:	697b      	ldr	r3, [r7, #20]
 810a608:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 810a60a:	4a19      	ldr	r2, [pc, #100]	; (810a670 <UART_SetConfig+0x930>)
 810a60c:	f832 3013 	ldrh.w	r3, [r2, r3, lsl #1]
 810a610:	461a      	mov	r2, r3
 810a612:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 810a614:	fbb3 f3f2 	udiv	r3, r3, r2
 810a618:	005a      	lsls	r2, r3, #1
 810a61a:	697b      	ldr	r3, [r7, #20]
 810a61c:	685b      	ldr	r3, [r3, #4]
 810a61e:	085b      	lsrs	r3, r3, #1
 810a620:	441a      	add	r2, r3
 810a622:	697b      	ldr	r3, [r7, #20]
 810a624:	685b      	ldr	r3, [r3, #4]
 810a626:	fbb2 f3f3 	udiv	r3, r2, r3
 810a62a:	63bb      	str	r3, [r7, #56]	; 0x38
      if ((usartdiv >= UART_BRR_MIN) && (usartdiv <= UART_BRR_MAX))
 810a62c:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 810a62e:	2b0f      	cmp	r3, #15
 810a630:	d916      	bls.n	810a660 <UART_SetConfig+0x920>
 810a632:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 810a634:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 810a638:	d212      	bcs.n	810a660 <UART_SetConfig+0x920>
      {
        brrtemp = (uint16_t)(usartdiv & 0xFFF0U);
 810a63a:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 810a63c:	b29b      	uxth	r3, r3
 810a63e:	f023 030f 	bic.w	r3, r3, #15
 810a642:	86fb      	strh	r3, [r7, #54]	; 0x36
        brrtemp |= (uint16_t)((usartdiv & (uint16_t)0x000FU) >> 1U);
 810a644:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 810a646:	085b      	lsrs	r3, r3, #1
 810a648:	b29b      	uxth	r3, r3
 810a64a:	f003 0307 	and.w	r3, r3, #7
 810a64e:	b29a      	uxth	r2, r3
 810a650:	8efb      	ldrh	r3, [r7, #54]	; 0x36
 810a652:	4313      	orrs	r3, r2
 810a654:	86fb      	strh	r3, [r7, #54]	; 0x36
        huart->Instance->BRR = brrtemp;
 810a656:	697b      	ldr	r3, [r7, #20]
 810a658:	681b      	ldr	r3, [r3, #0]
 810a65a:	8efa      	ldrh	r2, [r7, #54]	; 0x36
 810a65c:	60da      	str	r2, [r3, #12]
 810a65e:	e0b9      	b.n	810a7d4 <UART_SetConfig+0xa94>
      }
      else
      {
        ret = HAL_ERROR;
 810a660:	2301      	movs	r3, #1
 810a662:	f887 3042 	strb.w	r3, [r7, #66]	; 0x42
 810a666:	e0b5      	b.n	810a7d4 <UART_SetConfig+0xa94>
 810a668:	03d09000 	.word	0x03d09000
 810a66c:	003d0900 	.word	0x003d0900
 810a670:	0811f900 	.word	0x0811f900
 810a674:	58024400 	.word	0x58024400
      }
    }
  }
  else
  {
    switch (clocksource)
 810a678:	f897 3043 	ldrb.w	r3, [r7, #67]	; 0x43
 810a67c:	2b20      	cmp	r3, #32
 810a67e:	dc49      	bgt.n	810a714 <UART_SetConfig+0x9d4>
 810a680:	2b00      	cmp	r3, #0
 810a682:	db7c      	blt.n	810a77e <UART_SetConfig+0xa3e>
 810a684:	2b20      	cmp	r3, #32
 810a686:	d87a      	bhi.n	810a77e <UART_SetConfig+0xa3e>
 810a688:	a201      	add	r2, pc, #4	; (adr r2, 810a690 <UART_SetConfig+0x950>)
 810a68a:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 810a68e:	bf00      	nop
 810a690:	0810a71b 	.word	0x0810a71b
 810a694:	0810a723 	.word	0x0810a723
 810a698:	0810a77f 	.word	0x0810a77f
 810a69c:	0810a77f 	.word	0x0810a77f
 810a6a0:	0810a72b 	.word	0x0810a72b
 810a6a4:	0810a77f 	.word	0x0810a77f
 810a6a8:	0810a77f 	.word	0x0810a77f
 810a6ac:	0810a77f 	.word	0x0810a77f
 810a6b0:	0810a73b 	.word	0x0810a73b
 810a6b4:	0810a77f 	.word	0x0810a77f
 810a6b8:	0810a77f 	.word	0x0810a77f
 810a6bc:	0810a77f 	.word	0x0810a77f
 810a6c0:	0810a77f 	.word	0x0810a77f
 810a6c4:	0810a77f 	.word	0x0810a77f
 810a6c8:	0810a77f 	.word	0x0810a77f
 810a6cc:	0810a77f 	.word	0x0810a77f
 810a6d0:	0810a74b 	.word	0x0810a74b
 810a6d4:	0810a77f 	.word	0x0810a77f
 810a6d8:	0810a77f 	.word	0x0810a77f
 810a6dc:	0810a77f 	.word	0x0810a77f
 810a6e0:	0810a77f 	.word	0x0810a77f
 810a6e4:	0810a77f 	.word	0x0810a77f
 810a6e8:	0810a77f 	.word	0x0810a77f
 810a6ec:	0810a77f 	.word	0x0810a77f
 810a6f0:	0810a77f 	.word	0x0810a77f
 810a6f4:	0810a77f 	.word	0x0810a77f
 810a6f8:	0810a77f 	.word	0x0810a77f
 810a6fc:	0810a77f 	.word	0x0810a77f
 810a700:	0810a77f 	.word	0x0810a77f
 810a704:	0810a77f 	.word	0x0810a77f
 810a708:	0810a77f 	.word	0x0810a77f
 810a70c:	0810a77f 	.word	0x0810a77f
 810a710:	0810a771 	.word	0x0810a771
 810a714:	2b40      	cmp	r3, #64	; 0x40
 810a716:	d02e      	beq.n	810a776 <UART_SetConfig+0xa36>
 810a718:	e031      	b.n	810a77e <UART_SetConfig+0xa3e>
    {
      case UART_CLOCKSOURCE_D2PCLK1:
        pclk = HAL_RCC_GetPCLK1Freq();
 810a71a:	f7fc fcff 	bl	810711c <HAL_RCC_GetPCLK1Freq>
 810a71e:	63f8      	str	r0, [r7, #60]	; 0x3c
        break;
 810a720:	e033      	b.n	810a78a <UART_SetConfig+0xa4a>
      case UART_CLOCKSOURCE_D2PCLK2:
        pclk = HAL_RCC_GetPCLK2Freq();
 810a722:	f7fc fd11 	bl	8107148 <HAL_RCC_GetPCLK2Freq>
 810a726:	63f8      	str	r0, [r7, #60]	; 0x3c
        break;
 810a728:	e02f      	b.n	810a78a <UART_SetConfig+0xa4a>
      case UART_CLOCKSOURCE_PLL2:
        HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
 810a72a:	f107 0324 	add.w	r3, r7, #36	; 0x24
 810a72e:	4618      	mov	r0, r3
 810a730:	f7fe fcc0 	bl	81090b4 <HAL_RCCEx_GetPLL2ClockFreq>
        pclk = pll2_clocks.PLL2_Q_Frequency;
 810a734:	6abb      	ldr	r3, [r7, #40]	; 0x28
 810a736:	63fb      	str	r3, [r7, #60]	; 0x3c
        break;
 810a738:	e027      	b.n	810a78a <UART_SetConfig+0xa4a>
      case UART_CLOCKSOURCE_PLL3:
        HAL_RCCEx_GetPLL3ClockFreq(&pll3_clocks);
 810a73a:	f107 0318 	add.w	r3, r7, #24
 810a73e:	4618      	mov	r0, r3
 810a740:	f7fe fe0c 	bl	810935c <HAL_RCCEx_GetPLL3ClockFreq>
        pclk = pll3_clocks.PLL3_Q_Frequency;
 810a744:	69fb      	ldr	r3, [r7, #28]
 810a746:	63fb      	str	r3, [r7, #60]	; 0x3c
        break;
 810a748:	e01f      	b.n	810a78a <UART_SetConfig+0xa4a>
      case UART_CLOCKSOURCE_HSI:
        if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIV) != 0U)
 810a74a:	4b2d      	ldr	r3, [pc, #180]	; (810a800 <UART_SetConfig+0xac0>)
 810a74c:	681b      	ldr	r3, [r3, #0]
 810a74e:	f003 0320 	and.w	r3, r3, #32
 810a752:	2b00      	cmp	r3, #0
 810a754:	d009      	beq.n	810a76a <UART_SetConfig+0xa2a>
        {
          pclk = (uint32_t)(HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> 3U));
 810a756:	4b2a      	ldr	r3, [pc, #168]	; (810a800 <UART_SetConfig+0xac0>)
 810a758:	681b      	ldr	r3, [r3, #0]
 810a75a:	08db      	lsrs	r3, r3, #3
 810a75c:	f003 0303 	and.w	r3, r3, #3
 810a760:	4a28      	ldr	r2, [pc, #160]	; (810a804 <UART_SetConfig+0xac4>)
 810a762:	fa22 f303 	lsr.w	r3, r2, r3
 810a766:	63fb      	str	r3, [r7, #60]	; 0x3c
        }
        else
        {
          pclk = (uint32_t) HSI_VALUE;
        }
        break;
 810a768:	e00f      	b.n	810a78a <UART_SetConfig+0xa4a>
          pclk = (uint32_t) HSI_VALUE;
 810a76a:	4b26      	ldr	r3, [pc, #152]	; (810a804 <UART_SetConfig+0xac4>)
 810a76c:	63fb      	str	r3, [r7, #60]	; 0x3c
        break;
 810a76e:	e00c      	b.n	810a78a <UART_SetConfig+0xa4a>
      case UART_CLOCKSOURCE_CSI:
        pclk = (uint32_t) CSI_VALUE;
 810a770:	4b25      	ldr	r3, [pc, #148]	; (810a808 <UART_SetConfig+0xac8>)
 810a772:	63fb      	str	r3, [r7, #60]	; 0x3c
        break;
 810a774:	e009      	b.n	810a78a <UART_SetConfig+0xa4a>
      case UART_CLOCKSOURCE_LSE:
        pclk = (uint32_t) LSE_VALUE;
 810a776:	f44f 4300 	mov.w	r3, #32768	; 0x8000
 810a77a:	63fb      	str	r3, [r7, #60]	; 0x3c
        break;
 810a77c:	e005      	b.n	810a78a <UART_SetConfig+0xa4a>
      default:
        pclk = 0U;
 810a77e:	2300      	movs	r3, #0
 810a780:	63fb      	str	r3, [r7, #60]	; 0x3c
        ret = HAL_ERROR;
 810a782:	2301      	movs	r3, #1
 810a784:	f887 3042 	strb.w	r3, [r7, #66]	; 0x42
        break;
 810a788:	bf00      	nop
    }

    if (pclk != 0U)
 810a78a:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 810a78c:	2b00      	cmp	r3, #0
 810a78e:	d021      	beq.n	810a7d4 <UART_SetConfig+0xa94>
    {
      /* USARTDIV must be greater than or equal to 0d16 */
      usartdiv = (uint32_t)(UART_DIV_SAMPLING16(pclk, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 810a790:	697b      	ldr	r3, [r7, #20]
 810a792:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 810a794:	4a1d      	ldr	r2, [pc, #116]	; (810a80c <UART_SetConfig+0xacc>)
 810a796:	f832 3013 	ldrh.w	r3, [r2, r3, lsl #1]
 810a79a:	461a      	mov	r2, r3
 810a79c:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 810a79e:	fbb3 f2f2 	udiv	r2, r3, r2
 810a7a2:	697b      	ldr	r3, [r7, #20]
 810a7a4:	685b      	ldr	r3, [r3, #4]
 810a7a6:	085b      	lsrs	r3, r3, #1
 810a7a8:	441a      	add	r2, r3
 810a7aa:	697b      	ldr	r3, [r7, #20]
 810a7ac:	685b      	ldr	r3, [r3, #4]
 810a7ae:	fbb2 f3f3 	udiv	r3, r2, r3
 810a7b2:	63bb      	str	r3, [r7, #56]	; 0x38
      if ((usartdiv >= UART_BRR_MIN) && (usartdiv <= UART_BRR_MAX))
 810a7b4:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 810a7b6:	2b0f      	cmp	r3, #15
 810a7b8:	d909      	bls.n	810a7ce <UART_SetConfig+0xa8e>
 810a7ba:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 810a7bc:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 810a7c0:	d205      	bcs.n	810a7ce <UART_SetConfig+0xa8e>
      {
        huart->Instance->BRR = (uint16_t)usartdiv;
 810a7c2:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 810a7c4:	b29a      	uxth	r2, r3
 810a7c6:	697b      	ldr	r3, [r7, #20]
 810a7c8:	681b      	ldr	r3, [r3, #0]
 810a7ca:	60da      	str	r2, [r3, #12]
 810a7cc:	e002      	b.n	810a7d4 <UART_SetConfig+0xa94>
      }
      else
      {
        ret = HAL_ERROR;
 810a7ce:	2301      	movs	r3, #1
 810a7d0:	f887 3042 	strb.w	r3, [r7, #66]	; 0x42
      }
    }
  }

  /* Initialize the number of data to process during RX/TX ISR execution */
  huart->NbTxDataToProcess = 1;
 810a7d4:	697b      	ldr	r3, [r7, #20]
 810a7d6:	2201      	movs	r2, #1
 810a7d8:	f8a3 206a 	strh.w	r2, [r3, #106]	; 0x6a
  huart->NbRxDataToProcess = 1;
 810a7dc:	697b      	ldr	r3, [r7, #20]
 810a7de:	2201      	movs	r2, #1
 810a7e0:	f8a3 2068 	strh.w	r2, [r3, #104]	; 0x68

  /* Clear ISR function pointers */
  huart->RxISR = NULL;
 810a7e4:	697b      	ldr	r3, [r7, #20]
 810a7e6:	2200      	movs	r2, #0
 810a7e8:	675a      	str	r2, [r3, #116]	; 0x74
  huart->TxISR = NULL;
 810a7ea:	697b      	ldr	r3, [r7, #20]
 810a7ec:	2200      	movs	r2, #0
 810a7ee:	679a      	str	r2, [r3, #120]	; 0x78

  return ret;
 810a7f0:	f897 3042 	ldrb.w	r3, [r7, #66]	; 0x42
}
 810a7f4:	4618      	mov	r0, r3
 810a7f6:	3748      	adds	r7, #72	; 0x48
 810a7f8:	46bd      	mov	sp, r7
 810a7fa:	e8bd 8fb0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, sl, fp, pc}
 810a7fe:	bf00      	nop
 810a800:	58024400 	.word	0x58024400
 810a804:	03d09000 	.word	0x03d09000
 810a808:	003d0900 	.word	0x003d0900
 810a80c:	0811f900 	.word	0x0811f900

0810a810 <UART_AdvFeatureConfig>:
  * @brief Configure the UART peripheral advanced features.
  * @param huart UART handle.
  * @retval None
  */
void UART_AdvFeatureConfig(UART_HandleTypeDef *huart)
{
 810a810:	b480      	push	{r7}
 810a812:	b083      	sub	sp, #12
 810a814:	af00      	add	r7, sp, #0
 810a816:	6078      	str	r0, [r7, #4]
  /* Check whether the set of advanced features to configure is properly set */
  assert_param(IS_UART_ADVFEATURE_INIT(huart->AdvancedInit.AdvFeatureInit));

  /* if required, configure RX/TX pins swap */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_SWAP_INIT))
 810a818:	687b      	ldr	r3, [r7, #4]
 810a81a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 810a81c:	f003 0308 	and.w	r3, r3, #8
 810a820:	2b00      	cmp	r3, #0
 810a822:	d00a      	beq.n	810a83a <UART_AdvFeatureConfig+0x2a>
  {
    assert_param(IS_UART_ADVFEATURE_SWAP(huart->AdvancedInit.Swap));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_SWAP, huart->AdvancedInit.Swap);
 810a824:	687b      	ldr	r3, [r7, #4]
 810a826:	681b      	ldr	r3, [r3, #0]
 810a828:	685b      	ldr	r3, [r3, #4]
 810a82a:	f423 4100 	bic.w	r1, r3, #32768	; 0x8000
 810a82e:	687b      	ldr	r3, [r7, #4]
 810a830:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 810a832:	687b      	ldr	r3, [r7, #4]
 810a834:	681b      	ldr	r3, [r3, #0]
 810a836:	430a      	orrs	r2, r1
 810a838:	605a      	str	r2, [r3, #4]
  }

  /* if required, configure TX pin active level inversion */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_TXINVERT_INIT))
 810a83a:	687b      	ldr	r3, [r7, #4]
 810a83c:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 810a83e:	f003 0301 	and.w	r3, r3, #1
 810a842:	2b00      	cmp	r3, #0
 810a844:	d00a      	beq.n	810a85c <UART_AdvFeatureConfig+0x4c>
  {
    assert_param(IS_UART_ADVFEATURE_TXINV(huart->AdvancedInit.TxPinLevelInvert));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_TXINV, huart->AdvancedInit.TxPinLevelInvert);
 810a846:	687b      	ldr	r3, [r7, #4]
 810a848:	681b      	ldr	r3, [r3, #0]
 810a84a:	685b      	ldr	r3, [r3, #4]
 810a84c:	f423 3100 	bic.w	r1, r3, #131072	; 0x20000
 810a850:	687b      	ldr	r3, [r7, #4]
 810a852:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 810a854:	687b      	ldr	r3, [r7, #4]
 810a856:	681b      	ldr	r3, [r3, #0]
 810a858:	430a      	orrs	r2, r1
 810a85a:	605a      	str	r2, [r3, #4]
  }

  /* if required, configure RX pin active level inversion */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXINVERT_INIT))
 810a85c:	687b      	ldr	r3, [r7, #4]
 810a85e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 810a860:	f003 0302 	and.w	r3, r3, #2
 810a864:	2b00      	cmp	r3, #0
 810a866:	d00a      	beq.n	810a87e <UART_AdvFeatureConfig+0x6e>
  {
    assert_param(IS_UART_ADVFEATURE_RXINV(huart->AdvancedInit.RxPinLevelInvert));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_RXINV, huart->AdvancedInit.RxPinLevelInvert);
 810a868:	687b      	ldr	r3, [r7, #4]
 810a86a:	681b      	ldr	r3, [r3, #0]
 810a86c:	685b      	ldr	r3, [r3, #4]
 810a86e:	f423 3180 	bic.w	r1, r3, #65536	; 0x10000
 810a872:	687b      	ldr	r3, [r7, #4]
 810a874:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 810a876:	687b      	ldr	r3, [r7, #4]
 810a878:	681b      	ldr	r3, [r3, #0]
 810a87a:	430a      	orrs	r2, r1
 810a87c:	605a      	str	r2, [r3, #4]
  }

  /* if required, configure data inversion */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DATAINVERT_INIT))
 810a87e:	687b      	ldr	r3, [r7, #4]
 810a880:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 810a882:	f003 0304 	and.w	r3, r3, #4
 810a886:	2b00      	cmp	r3, #0
 810a888:	d00a      	beq.n	810a8a0 <UART_AdvFeatureConfig+0x90>
  {
    assert_param(IS_UART_ADVFEATURE_DATAINV(huart->AdvancedInit.DataInvert));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_DATAINV, huart->AdvancedInit.DataInvert);
 810a88a:	687b      	ldr	r3, [r7, #4]
 810a88c:	681b      	ldr	r3, [r3, #0]
 810a88e:	685b      	ldr	r3, [r3, #4]
 810a890:	f423 2180 	bic.w	r1, r3, #262144	; 0x40000
 810a894:	687b      	ldr	r3, [r7, #4]
 810a896:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 810a898:	687b      	ldr	r3, [r7, #4]
 810a89a:	681b      	ldr	r3, [r3, #0]
 810a89c:	430a      	orrs	r2, r1
 810a89e:	605a      	str	r2, [r3, #4]
  }

  /* if required, configure RX overrun detection disabling */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXOVERRUNDISABLE_INIT))
 810a8a0:	687b      	ldr	r3, [r7, #4]
 810a8a2:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 810a8a4:	f003 0310 	and.w	r3, r3, #16
 810a8a8:	2b00      	cmp	r3, #0
 810a8aa:	d00a      	beq.n	810a8c2 <UART_AdvFeatureConfig+0xb2>
  {
    assert_param(IS_UART_OVERRUN(huart->AdvancedInit.OverrunDisable));
    MODIFY_REG(huart->Instance->CR3, USART_CR3_OVRDIS, huart->AdvancedInit.OverrunDisable);
 810a8ac:	687b      	ldr	r3, [r7, #4]
 810a8ae:	681b      	ldr	r3, [r3, #0]
 810a8b0:	689b      	ldr	r3, [r3, #8]
 810a8b2:	f423 5180 	bic.w	r1, r3, #4096	; 0x1000
 810a8b6:	687b      	ldr	r3, [r7, #4]
 810a8b8:	6bda      	ldr	r2, [r3, #60]	; 0x3c
 810a8ba:	687b      	ldr	r3, [r7, #4]
 810a8bc:	681b      	ldr	r3, [r3, #0]
 810a8be:	430a      	orrs	r2, r1
 810a8c0:	609a      	str	r2, [r3, #8]
  }

  /* if required, configure DMA disabling on reception error */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DMADISABLEONERROR_INIT))
 810a8c2:	687b      	ldr	r3, [r7, #4]
 810a8c4:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 810a8c6:	f003 0320 	and.w	r3, r3, #32
 810a8ca:	2b00      	cmp	r3, #0
 810a8cc:	d00a      	beq.n	810a8e4 <UART_AdvFeatureConfig+0xd4>
  {
    assert_param(IS_UART_ADVFEATURE_DMAONRXERROR(huart->AdvancedInit.DMADisableonRxError));
    MODIFY_REG(huart->Instance->CR3, USART_CR3_DDRE, huart->AdvancedInit.DMADisableonRxError);
 810a8ce:	687b      	ldr	r3, [r7, #4]
 810a8d0:	681b      	ldr	r3, [r3, #0]
 810a8d2:	689b      	ldr	r3, [r3, #8]
 810a8d4:	f423 5100 	bic.w	r1, r3, #8192	; 0x2000
 810a8d8:	687b      	ldr	r3, [r7, #4]
 810a8da:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 810a8dc:	687b      	ldr	r3, [r7, #4]
 810a8de:	681b      	ldr	r3, [r3, #0]
 810a8e0:	430a      	orrs	r2, r1
 810a8e2:	609a      	str	r2, [r3, #8]
  }

  /* if required, configure auto Baud rate detection scheme */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_AUTOBAUDRATE_INIT))
 810a8e4:	687b      	ldr	r3, [r7, #4]
 810a8e6:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 810a8e8:	f003 0340 	and.w	r3, r3, #64	; 0x40
 810a8ec:	2b00      	cmp	r3, #0
 810a8ee:	d01a      	beq.n	810a926 <UART_AdvFeatureConfig+0x116>
  {
    assert_param(IS_USART_AUTOBAUDRATE_DETECTION_INSTANCE(huart->Instance));
    assert_param(IS_UART_ADVFEATURE_AUTOBAUDRATE(huart->AdvancedInit.AutoBaudRateEnable));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_ABREN, huart->AdvancedInit.AutoBaudRateEnable);
 810a8f0:	687b      	ldr	r3, [r7, #4]
 810a8f2:	681b      	ldr	r3, [r3, #0]
 810a8f4:	685b      	ldr	r3, [r3, #4]
 810a8f6:	f423 1180 	bic.w	r1, r3, #1048576	; 0x100000
 810a8fa:	687b      	ldr	r3, [r7, #4]
 810a8fc:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 810a8fe:	687b      	ldr	r3, [r7, #4]
 810a900:	681b      	ldr	r3, [r3, #0]
 810a902:	430a      	orrs	r2, r1
 810a904:	605a      	str	r2, [r3, #4]
    /* set auto Baudrate detection parameters if detection is enabled */
    if (huart->AdvancedInit.AutoBaudRateEnable == UART_ADVFEATURE_AUTOBAUDRATE_ENABLE)
 810a906:	687b      	ldr	r3, [r7, #4]
 810a908:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 810a90a:	f5b3 1f80 	cmp.w	r3, #1048576	; 0x100000
 810a90e:	d10a      	bne.n	810a926 <UART_AdvFeatureConfig+0x116>
    {
      assert_param(IS_UART_ADVFEATURE_AUTOBAUDRATEMODE(huart->AdvancedInit.AutoBaudRateMode));
      MODIFY_REG(huart->Instance->CR2, USART_CR2_ABRMODE, huart->AdvancedInit.AutoBaudRateMode);
 810a910:	687b      	ldr	r3, [r7, #4]
 810a912:	681b      	ldr	r3, [r3, #0]
 810a914:	685b      	ldr	r3, [r3, #4]
 810a916:	f423 01c0 	bic.w	r1, r3, #6291456	; 0x600000
 810a91a:	687b      	ldr	r3, [r7, #4]
 810a91c:	6c9a      	ldr	r2, [r3, #72]	; 0x48
 810a91e:	687b      	ldr	r3, [r7, #4]
 810a920:	681b      	ldr	r3, [r3, #0]
 810a922:	430a      	orrs	r2, r1
 810a924:	605a      	str	r2, [r3, #4]
    }
  }

  /* if required, configure MSB first on communication line */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_MSBFIRST_INIT))
 810a926:	687b      	ldr	r3, [r7, #4]
 810a928:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 810a92a:	f003 0380 	and.w	r3, r3, #128	; 0x80
 810a92e:	2b00      	cmp	r3, #0
 810a930:	d00a      	beq.n	810a948 <UART_AdvFeatureConfig+0x138>
  {
    assert_param(IS_UART_ADVFEATURE_MSBFIRST(huart->AdvancedInit.MSBFirst));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_MSBFIRST, huart->AdvancedInit.MSBFirst);
 810a932:	687b      	ldr	r3, [r7, #4]
 810a934:	681b      	ldr	r3, [r3, #0]
 810a936:	685b      	ldr	r3, [r3, #4]
 810a938:	f423 2100 	bic.w	r1, r3, #524288	; 0x80000
 810a93c:	687b      	ldr	r3, [r7, #4]
 810a93e:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 810a940:	687b      	ldr	r3, [r7, #4]
 810a942:	681b      	ldr	r3, [r3, #0]
 810a944:	430a      	orrs	r2, r1
 810a946:	605a      	str	r2, [r3, #4]
  }
}
 810a948:	bf00      	nop
 810a94a:	370c      	adds	r7, #12
 810a94c:	46bd      	mov	sp, r7
 810a94e:	f85d 7b04 	ldr.w	r7, [sp], #4
 810a952:	4770      	bx	lr

0810a954 <UART_CheckIdleState>:
  * @brief Check the UART Idle State.
  * @param huart UART handle.
  * @retval HAL status
  */
HAL_StatusTypeDef UART_CheckIdleState(UART_HandleTypeDef *huart)
{
 810a954:	b580      	push	{r7, lr}
 810a956:	b098      	sub	sp, #96	; 0x60
 810a958:	af02      	add	r7, sp, #8
 810a95a:	6078      	str	r0, [r7, #4]
  uint32_t tickstart;

  /* Initialize the UART ErrorCode */
  huart->ErrorCode = HAL_UART_ERROR_NONE;
 810a95c:	687b      	ldr	r3, [r7, #4]
 810a95e:	2200      	movs	r2, #0
 810a960:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90

  /* Init tickstart for timeout management */
  tickstart = HAL_GetTick();
 810a964:	f7f6 fe6a 	bl	810163c <HAL_GetTick>
 810a968:	6578      	str	r0, [r7, #84]	; 0x54

  /* Check if the Transmitter is enabled */
  if ((huart->Instance->CR1 & USART_CR1_TE) == USART_CR1_TE)
 810a96a:	687b      	ldr	r3, [r7, #4]
 810a96c:	681b      	ldr	r3, [r3, #0]
 810a96e:	681b      	ldr	r3, [r3, #0]
 810a970:	f003 0308 	and.w	r3, r3, #8
 810a974:	2b08      	cmp	r3, #8
 810a976:	d12f      	bne.n	810a9d8 <UART_CheckIdleState+0x84>
  {
    /* Wait until TEACK flag is set */
    if (UART_WaitOnFlagUntilTimeout(huart, USART_ISR_TEACK, RESET, tickstart, HAL_UART_TIMEOUT_VALUE) != HAL_OK)
 810a978:	f06f 437e 	mvn.w	r3, #4261412864	; 0xfe000000
 810a97c:	9300      	str	r3, [sp, #0]
 810a97e:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 810a980:	2200      	movs	r2, #0
 810a982:	f44f 1100 	mov.w	r1, #2097152	; 0x200000
 810a986:	6878      	ldr	r0, [r7, #4]
 810a988:	f000 f88e 	bl	810aaa8 <UART_WaitOnFlagUntilTimeout>
 810a98c:	4603      	mov	r3, r0
 810a98e:	2b00      	cmp	r3, #0
 810a990:	d022      	beq.n	810a9d8 <UART_CheckIdleState+0x84>
    {
      /* Disable TXE interrupt for the interrupt process */
      ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_TXEIE_TXFNFIE));
 810a992:	687b      	ldr	r3, [r7, #4]
 810a994:	681b      	ldr	r3, [r3, #0]
 810a996:	63bb      	str	r3, [r7, #56]	; 0x38
 */
__STATIC_FORCEINLINE uint32_t __LDREXW(volatile uint32_t *addr)
{
    uint32_t result;

   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 810a998:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 810a99a:	e853 3f00 	ldrex	r3, [r3]
 810a99e:	637b      	str	r3, [r7, #52]	; 0x34
   return(result);
 810a9a0:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 810a9a2:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 810a9a6:	653b      	str	r3, [r7, #80]	; 0x50
 810a9a8:	687b      	ldr	r3, [r7, #4]
 810a9aa:	681b      	ldr	r3, [r3, #0]
 810a9ac:	461a      	mov	r2, r3
 810a9ae:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 810a9b0:	647b      	str	r3, [r7, #68]	; 0x44
 810a9b2:	643a      	str	r2, [r7, #64]	; 0x40
 */
__STATIC_FORCEINLINE uint32_t __STREXW(uint32_t value, volatile uint32_t *addr)
{
   uint32_t result;

   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 810a9b4:	6c39      	ldr	r1, [r7, #64]	; 0x40
 810a9b6:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 810a9b8:	e841 2300 	strex	r3, r2, [r1]
 810a9bc:	63fb      	str	r3, [r7, #60]	; 0x3c
   return(result);
 810a9be:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 810a9c0:	2b00      	cmp	r3, #0
 810a9c2:	d1e6      	bne.n	810a992 <UART_CheckIdleState+0x3e>

      huart->gState = HAL_UART_STATE_READY;
 810a9c4:	687b      	ldr	r3, [r7, #4]
 810a9c6:	2220      	movs	r2, #32
 810a9c8:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88

      __HAL_UNLOCK(huart);
 810a9cc:	687b      	ldr	r3, [r7, #4]
 810a9ce:	2200      	movs	r2, #0
 810a9d0:	f883 2084 	strb.w	r2, [r3, #132]	; 0x84

      /* Timeout occurred */
      return HAL_TIMEOUT;
 810a9d4:	2303      	movs	r3, #3
 810a9d6:	e063      	b.n	810aaa0 <UART_CheckIdleState+0x14c>
    }
  }

  /* Check if the Receiver is enabled */
  if ((huart->Instance->CR1 & USART_CR1_RE) == USART_CR1_RE)
 810a9d8:	687b      	ldr	r3, [r7, #4]
 810a9da:	681b      	ldr	r3, [r3, #0]
 810a9dc:	681b      	ldr	r3, [r3, #0]
 810a9de:	f003 0304 	and.w	r3, r3, #4
 810a9e2:	2b04      	cmp	r3, #4
 810a9e4:	d149      	bne.n	810aa7a <UART_CheckIdleState+0x126>
  {
    /* Wait until REACK flag is set */
    if (UART_WaitOnFlagUntilTimeout(huart, USART_ISR_REACK, RESET, tickstart, HAL_UART_TIMEOUT_VALUE) != HAL_OK)
 810a9e6:	f06f 437e 	mvn.w	r3, #4261412864	; 0xfe000000
 810a9ea:	9300      	str	r3, [sp, #0]
 810a9ec:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 810a9ee:	2200      	movs	r2, #0
 810a9f0:	f44f 0180 	mov.w	r1, #4194304	; 0x400000
 810a9f4:	6878      	ldr	r0, [r7, #4]
 810a9f6:	f000 f857 	bl	810aaa8 <UART_WaitOnFlagUntilTimeout>
 810a9fa:	4603      	mov	r3, r0
 810a9fc:	2b00      	cmp	r3, #0
 810a9fe:	d03c      	beq.n	810aa7a <UART_CheckIdleState+0x126>
    {
      /* Disable RXNE, PE and ERR (Frame error, noise error, overrun error)
      interrupts for the interrupt process */
      ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE));
 810aa00:	687b      	ldr	r3, [r7, #4]
 810aa02:	681b      	ldr	r3, [r3, #0]
 810aa04:	627b      	str	r3, [r7, #36]	; 0x24
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 810aa06:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 810aa08:	e853 3f00 	ldrex	r3, [r3]
 810aa0c:	623b      	str	r3, [r7, #32]
   return(result);
 810aa0e:	6a3b      	ldr	r3, [r7, #32]
 810aa10:	f423 7390 	bic.w	r3, r3, #288	; 0x120
 810aa14:	64fb      	str	r3, [r7, #76]	; 0x4c
 810aa16:	687b      	ldr	r3, [r7, #4]
 810aa18:	681b      	ldr	r3, [r3, #0]
 810aa1a:	461a      	mov	r2, r3
 810aa1c:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 810aa1e:	633b      	str	r3, [r7, #48]	; 0x30
 810aa20:	62fa      	str	r2, [r7, #44]	; 0x2c
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 810aa22:	6af9      	ldr	r1, [r7, #44]	; 0x2c
 810aa24:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 810aa26:	e841 2300 	strex	r3, r2, [r1]
 810aa2a:	62bb      	str	r3, [r7, #40]	; 0x28
   return(result);
 810aa2c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 810aa2e:	2b00      	cmp	r3, #0
 810aa30:	d1e6      	bne.n	810aa00 <UART_CheckIdleState+0xac>
      ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 810aa32:	687b      	ldr	r3, [r7, #4]
 810aa34:	681b      	ldr	r3, [r3, #0]
 810aa36:	3308      	adds	r3, #8
 810aa38:	613b      	str	r3, [r7, #16]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 810aa3a:	693b      	ldr	r3, [r7, #16]
 810aa3c:	e853 3f00 	ldrex	r3, [r3]
 810aa40:	60fb      	str	r3, [r7, #12]
   return(result);
 810aa42:	68fb      	ldr	r3, [r7, #12]
 810aa44:	f023 0301 	bic.w	r3, r3, #1
 810aa48:	64bb      	str	r3, [r7, #72]	; 0x48
 810aa4a:	687b      	ldr	r3, [r7, #4]
 810aa4c:	681b      	ldr	r3, [r3, #0]
 810aa4e:	3308      	adds	r3, #8
 810aa50:	6cba      	ldr	r2, [r7, #72]	; 0x48
 810aa52:	61fa      	str	r2, [r7, #28]
 810aa54:	61bb      	str	r3, [r7, #24]
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 810aa56:	69b9      	ldr	r1, [r7, #24]
 810aa58:	69fa      	ldr	r2, [r7, #28]
 810aa5a:	e841 2300 	strex	r3, r2, [r1]
 810aa5e:	617b      	str	r3, [r7, #20]
   return(result);
 810aa60:	697b      	ldr	r3, [r7, #20]
 810aa62:	2b00      	cmp	r3, #0
 810aa64:	d1e5      	bne.n	810aa32 <UART_CheckIdleState+0xde>

      huart->RxState = HAL_UART_STATE_READY;
 810aa66:	687b      	ldr	r3, [r7, #4]
 810aa68:	2220      	movs	r2, #32
 810aa6a:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c

      __HAL_UNLOCK(huart);
 810aa6e:	687b      	ldr	r3, [r7, #4]
 810aa70:	2200      	movs	r2, #0
 810aa72:	f883 2084 	strb.w	r2, [r3, #132]	; 0x84

      /* Timeout occurred */
      return HAL_TIMEOUT;
 810aa76:	2303      	movs	r3, #3
 810aa78:	e012      	b.n	810aaa0 <UART_CheckIdleState+0x14c>
    }
  }

  /* Initialize the UART State */
  huart->gState = HAL_UART_STATE_READY;
 810aa7a:	687b      	ldr	r3, [r7, #4]
 810aa7c:	2220      	movs	r2, #32
 810aa7e:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
  huart->RxState = HAL_UART_STATE_READY;
 810aa82:	687b      	ldr	r3, [r7, #4]
 810aa84:	2220      	movs	r2, #32
 810aa86:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
  huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 810aa8a:	687b      	ldr	r3, [r7, #4]
 810aa8c:	2200      	movs	r2, #0
 810aa8e:	66da      	str	r2, [r3, #108]	; 0x6c
  huart->RxEventType = HAL_UART_RXEVENT_TC;
 810aa90:	687b      	ldr	r3, [r7, #4]
 810aa92:	2200      	movs	r2, #0
 810aa94:	671a      	str	r2, [r3, #112]	; 0x70

  __HAL_UNLOCK(huart);
 810aa96:	687b      	ldr	r3, [r7, #4]
 810aa98:	2200      	movs	r2, #0
 810aa9a:	f883 2084 	strb.w	r2, [r3, #132]	; 0x84

  return HAL_OK;
 810aa9e:	2300      	movs	r3, #0
}
 810aaa0:	4618      	mov	r0, r3
 810aaa2:	3758      	adds	r7, #88	; 0x58
 810aaa4:	46bd      	mov	sp, r7
 810aaa6:	bd80      	pop	{r7, pc}

0810aaa8 <UART_WaitOnFlagUntilTimeout>:
  * @param Timeout   Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef UART_WaitOnFlagUntilTimeout(UART_HandleTypeDef *huart, uint32_t Flag, FlagStatus Status,
                                              uint32_t Tickstart, uint32_t Timeout)
{
 810aaa8:	b580      	push	{r7, lr}
 810aaaa:	b084      	sub	sp, #16
 810aaac:	af00      	add	r7, sp, #0
 810aaae:	60f8      	str	r0, [r7, #12]
 810aab0:	60b9      	str	r1, [r7, #8]
 810aab2:	603b      	str	r3, [r7, #0]
 810aab4:	4613      	mov	r3, r2
 810aab6:	71fb      	strb	r3, [r7, #7]
  /* Wait until flag is set */
  while ((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status)
 810aab8:	e04f      	b.n	810ab5a <UART_WaitOnFlagUntilTimeout+0xb2>
  {
    /* Check for the Timeout */
    if (Timeout != HAL_MAX_DELAY)
 810aaba:	69bb      	ldr	r3, [r7, #24]
 810aabc:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 810aac0:	d04b      	beq.n	810ab5a <UART_WaitOnFlagUntilTimeout+0xb2>
    {
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 810aac2:	f7f6 fdbb 	bl	810163c <HAL_GetTick>
 810aac6:	4602      	mov	r2, r0
 810aac8:	683b      	ldr	r3, [r7, #0]
 810aaca:	1ad3      	subs	r3, r2, r3
 810aacc:	69ba      	ldr	r2, [r7, #24]
 810aace:	429a      	cmp	r2, r3
 810aad0:	d302      	bcc.n	810aad8 <UART_WaitOnFlagUntilTimeout+0x30>
 810aad2:	69bb      	ldr	r3, [r7, #24]
 810aad4:	2b00      	cmp	r3, #0
 810aad6:	d101      	bne.n	810aadc <UART_WaitOnFlagUntilTimeout+0x34>
      {

        return HAL_TIMEOUT;
 810aad8:	2303      	movs	r3, #3
 810aada:	e04e      	b.n	810ab7a <UART_WaitOnFlagUntilTimeout+0xd2>
      }

      if ((READ_BIT(huart->Instance->CR1, USART_CR1_RE) != 0U) && (Flag != UART_FLAG_TXE) && (Flag != UART_FLAG_TC))
 810aadc:	68fb      	ldr	r3, [r7, #12]
 810aade:	681b      	ldr	r3, [r3, #0]
 810aae0:	681b      	ldr	r3, [r3, #0]
 810aae2:	f003 0304 	and.w	r3, r3, #4
 810aae6:	2b00      	cmp	r3, #0
 810aae8:	d037      	beq.n	810ab5a <UART_WaitOnFlagUntilTimeout+0xb2>
 810aaea:	68bb      	ldr	r3, [r7, #8]
 810aaec:	2b80      	cmp	r3, #128	; 0x80
 810aaee:	d034      	beq.n	810ab5a <UART_WaitOnFlagUntilTimeout+0xb2>
 810aaf0:	68bb      	ldr	r3, [r7, #8]
 810aaf2:	2b40      	cmp	r3, #64	; 0x40
 810aaf4:	d031      	beq.n	810ab5a <UART_WaitOnFlagUntilTimeout+0xb2>
      {
        if (__HAL_UART_GET_FLAG(huart, UART_FLAG_ORE) == SET)
 810aaf6:	68fb      	ldr	r3, [r7, #12]
 810aaf8:	681b      	ldr	r3, [r3, #0]
 810aafa:	69db      	ldr	r3, [r3, #28]
 810aafc:	f003 0308 	and.w	r3, r3, #8
 810ab00:	2b08      	cmp	r3, #8
 810ab02:	d110      	bne.n	810ab26 <UART_WaitOnFlagUntilTimeout+0x7e>
        {
          /* Clear Overrun Error flag*/
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_OREF);
 810ab04:	68fb      	ldr	r3, [r7, #12]
 810ab06:	681b      	ldr	r3, [r3, #0]
 810ab08:	2208      	movs	r2, #8
 810ab0a:	621a      	str	r2, [r3, #32]

          /* Blocking error : transfer is aborted
          Set the UART state ready to be able to start again the process,
          Disable Rx Interrupts if ongoing */
          UART_EndRxTransfer(huart);
 810ab0c:	68f8      	ldr	r0, [r7, #12]
 810ab0e:	f000 f838 	bl	810ab82 <UART_EndRxTransfer>

          huart->ErrorCode = HAL_UART_ERROR_ORE;
 810ab12:	68fb      	ldr	r3, [r7, #12]
 810ab14:	2208      	movs	r2, #8
 810ab16:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90

          /* Process Unlocked */
          __HAL_UNLOCK(huart);
 810ab1a:	68fb      	ldr	r3, [r7, #12]
 810ab1c:	2200      	movs	r2, #0
 810ab1e:	f883 2084 	strb.w	r2, [r3, #132]	; 0x84

          return HAL_ERROR;
 810ab22:	2301      	movs	r3, #1
 810ab24:	e029      	b.n	810ab7a <UART_WaitOnFlagUntilTimeout+0xd2>
        }
        if (__HAL_UART_GET_FLAG(huart, UART_FLAG_RTOF) == SET)
 810ab26:	68fb      	ldr	r3, [r7, #12]
 810ab28:	681b      	ldr	r3, [r3, #0]
 810ab2a:	69db      	ldr	r3, [r3, #28]
 810ab2c:	f403 6300 	and.w	r3, r3, #2048	; 0x800
 810ab30:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
 810ab34:	d111      	bne.n	810ab5a <UART_WaitOnFlagUntilTimeout+0xb2>
        {
          /* Clear Receiver Timeout flag*/
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_RTOF);
 810ab36:	68fb      	ldr	r3, [r7, #12]
 810ab38:	681b      	ldr	r3, [r3, #0]
 810ab3a:	f44f 6200 	mov.w	r2, #2048	; 0x800
 810ab3e:	621a      	str	r2, [r3, #32]

          /* Blocking error : transfer is aborted
          Set the UART state ready to be able to start again the process,
          Disable Rx Interrupts if ongoing */
          UART_EndRxTransfer(huart);
 810ab40:	68f8      	ldr	r0, [r7, #12]
 810ab42:	f000 f81e 	bl	810ab82 <UART_EndRxTransfer>

          huart->ErrorCode = HAL_UART_ERROR_RTO;
 810ab46:	68fb      	ldr	r3, [r7, #12]
 810ab48:	2220      	movs	r2, #32
 810ab4a:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90

          /* Process Unlocked */
          __HAL_UNLOCK(huart);
 810ab4e:	68fb      	ldr	r3, [r7, #12]
 810ab50:	2200      	movs	r2, #0
 810ab52:	f883 2084 	strb.w	r2, [r3, #132]	; 0x84

          return HAL_TIMEOUT;
 810ab56:	2303      	movs	r3, #3
 810ab58:	e00f      	b.n	810ab7a <UART_WaitOnFlagUntilTimeout+0xd2>
  while ((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status)
 810ab5a:	68fb      	ldr	r3, [r7, #12]
 810ab5c:	681b      	ldr	r3, [r3, #0]
 810ab5e:	69da      	ldr	r2, [r3, #28]
 810ab60:	68bb      	ldr	r3, [r7, #8]
 810ab62:	4013      	ands	r3, r2
 810ab64:	68ba      	ldr	r2, [r7, #8]
 810ab66:	429a      	cmp	r2, r3
 810ab68:	bf0c      	ite	eq
 810ab6a:	2301      	moveq	r3, #1
 810ab6c:	2300      	movne	r3, #0
 810ab6e:	b2db      	uxtb	r3, r3
 810ab70:	461a      	mov	r2, r3
 810ab72:	79fb      	ldrb	r3, [r7, #7]
 810ab74:	429a      	cmp	r2, r3
 810ab76:	d0a0      	beq.n	810aaba <UART_WaitOnFlagUntilTimeout+0x12>
        }
      }
    }
  }
  return HAL_OK;
 810ab78:	2300      	movs	r3, #0
}
 810ab7a:	4618      	mov	r0, r3
 810ab7c:	3710      	adds	r7, #16
 810ab7e:	46bd      	mov	sp, r7
 810ab80:	bd80      	pop	{r7, pc}

0810ab82 <UART_EndRxTransfer>:
  * @brief  End ongoing Rx transfer on UART peripheral (following error detection or Reception completion).
  * @param  huart UART handle.
  * @retval None
  */
static void UART_EndRxTransfer(UART_HandleTypeDef *huart)
{
 810ab82:	b480      	push	{r7}
 810ab84:	b095      	sub	sp, #84	; 0x54
 810ab86:	af00      	add	r7, sp, #0
 810ab88:	6078      	str	r0, [r7, #4]
  /* Disable RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
  ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE));
 810ab8a:	687b      	ldr	r3, [r7, #4]
 810ab8c:	681b      	ldr	r3, [r3, #0]
 810ab8e:	637b      	str	r3, [r7, #52]	; 0x34
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 810ab90:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 810ab92:	e853 3f00 	ldrex	r3, [r3]
 810ab96:	633b      	str	r3, [r7, #48]	; 0x30
   return(result);
 810ab98:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 810ab9a:	f423 7390 	bic.w	r3, r3, #288	; 0x120
 810ab9e:	64fb      	str	r3, [r7, #76]	; 0x4c
 810aba0:	687b      	ldr	r3, [r7, #4]
 810aba2:	681b      	ldr	r3, [r3, #0]
 810aba4:	461a      	mov	r2, r3
 810aba6:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 810aba8:	643b      	str	r3, [r7, #64]	; 0x40
 810abaa:	63fa      	str	r2, [r7, #60]	; 0x3c
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 810abac:	6bf9      	ldr	r1, [r7, #60]	; 0x3c
 810abae:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 810abb0:	e841 2300 	strex	r3, r2, [r1]
 810abb4:	63bb      	str	r3, [r7, #56]	; 0x38
   return(result);
 810abb6:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 810abb8:	2b00      	cmp	r3, #0
 810abba:	d1e6      	bne.n	810ab8a <UART_EndRxTransfer+0x8>
  ATOMIC_CLEAR_BIT(huart->Instance->CR3, (USART_CR3_EIE | USART_CR3_RXFTIE));
 810abbc:	687b      	ldr	r3, [r7, #4]
 810abbe:	681b      	ldr	r3, [r3, #0]
 810abc0:	3308      	adds	r3, #8
 810abc2:	623b      	str	r3, [r7, #32]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 810abc4:	6a3b      	ldr	r3, [r7, #32]
 810abc6:	e853 3f00 	ldrex	r3, [r3]
 810abca:	61fb      	str	r3, [r7, #28]
   return(result);
 810abcc:	69fb      	ldr	r3, [r7, #28]
 810abce:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
 810abd2:	f023 0301 	bic.w	r3, r3, #1
 810abd6:	64bb      	str	r3, [r7, #72]	; 0x48
 810abd8:	687b      	ldr	r3, [r7, #4]
 810abda:	681b      	ldr	r3, [r3, #0]
 810abdc:	3308      	adds	r3, #8
 810abde:	6cba      	ldr	r2, [r7, #72]	; 0x48
 810abe0:	62fa      	str	r2, [r7, #44]	; 0x2c
 810abe2:	62bb      	str	r3, [r7, #40]	; 0x28
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 810abe4:	6ab9      	ldr	r1, [r7, #40]	; 0x28
 810abe6:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 810abe8:	e841 2300 	strex	r3, r2, [r1]
 810abec:	627b      	str	r3, [r7, #36]	; 0x24
   return(result);
 810abee:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 810abf0:	2b00      	cmp	r3, #0
 810abf2:	d1e3      	bne.n	810abbc <UART_EndRxTransfer+0x3a>

  /* In case of reception waiting for IDLE event, disable also the IDLE IE interrupt source */
  if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
 810abf4:	687b      	ldr	r3, [r7, #4]
 810abf6:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 810abf8:	2b01      	cmp	r3, #1
 810abfa:	d118      	bne.n	810ac2e <UART_EndRxTransfer+0xac>
  {
    ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
 810abfc:	687b      	ldr	r3, [r7, #4]
 810abfe:	681b      	ldr	r3, [r3, #0]
 810ac00:	60fb      	str	r3, [r7, #12]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 810ac02:	68fb      	ldr	r3, [r7, #12]
 810ac04:	e853 3f00 	ldrex	r3, [r3]
 810ac08:	60bb      	str	r3, [r7, #8]
   return(result);
 810ac0a:	68bb      	ldr	r3, [r7, #8]
 810ac0c:	f023 0310 	bic.w	r3, r3, #16
 810ac10:	647b      	str	r3, [r7, #68]	; 0x44
 810ac12:	687b      	ldr	r3, [r7, #4]
 810ac14:	681b      	ldr	r3, [r3, #0]
 810ac16:	461a      	mov	r2, r3
 810ac18:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 810ac1a:	61bb      	str	r3, [r7, #24]
 810ac1c:	617a      	str	r2, [r7, #20]
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 810ac1e:	6979      	ldr	r1, [r7, #20]
 810ac20:	69ba      	ldr	r2, [r7, #24]
 810ac22:	e841 2300 	strex	r3, r2, [r1]
 810ac26:	613b      	str	r3, [r7, #16]
   return(result);
 810ac28:	693b      	ldr	r3, [r7, #16]
 810ac2a:	2b00      	cmp	r3, #0
 810ac2c:	d1e6      	bne.n	810abfc <UART_EndRxTransfer+0x7a>
  }

  /* At end of Rx process, restore huart->RxState to Ready */
  huart->RxState = HAL_UART_STATE_READY;
 810ac2e:	687b      	ldr	r3, [r7, #4]
 810ac30:	2220      	movs	r2, #32
 810ac32:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
  huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 810ac36:	687b      	ldr	r3, [r7, #4]
 810ac38:	2200      	movs	r2, #0
 810ac3a:	66da      	str	r2, [r3, #108]	; 0x6c

  /* Reset RxIsr function pointer */
  huart->RxISR = NULL;
 810ac3c:	687b      	ldr	r3, [r7, #4]
 810ac3e:	2200      	movs	r2, #0
 810ac40:	675a      	str	r2, [r3, #116]	; 0x74
}
 810ac42:	bf00      	nop
 810ac44:	3754      	adds	r7, #84	; 0x54
 810ac46:	46bd      	mov	sp, r7
 810ac48:	f85d 7b04 	ldr.w	r7, [sp], #4
 810ac4c:	4770      	bx	lr

0810ac4e <USB_CoreInit>:
  * @param  cfg pointer to a USB_OTG_CfgTypeDef structure that contains
  *         the configuration information for the specified USBx peripheral.
  * @retval HAL status
  */
HAL_StatusTypeDef USB_CoreInit(USB_OTG_GlobalTypeDef *USBx, USB_OTG_CfgTypeDef cfg)
{
 810ac4e:	b084      	sub	sp, #16
 810ac50:	b580      	push	{r7, lr}
 810ac52:	b084      	sub	sp, #16
 810ac54:	af00      	add	r7, sp, #0
 810ac56:	6078      	str	r0, [r7, #4]
 810ac58:	f107 001c 	add.w	r0, r7, #28
 810ac5c:	e880 000e 	stmia.w	r0, {r1, r2, r3}
  HAL_StatusTypeDef ret;
  if (cfg.phy_itface == USB_OTG_ULPI_PHY)
 810ac60:	f897 3021 	ldrb.w	r3, [r7, #33]	; 0x21
 810ac64:	2b01      	cmp	r3, #1
 810ac66:	d123      	bne.n	810acb0 <USB_CoreInit+0x62>
  {
    USBx->GCCFG &= ~(USB_OTG_GCCFG_PWRDWN);
 810ac68:	687b      	ldr	r3, [r7, #4]
 810ac6a:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 810ac6c:	f423 3280 	bic.w	r2, r3, #65536	; 0x10000
 810ac70:	687b      	ldr	r3, [r7, #4]
 810ac72:	639a      	str	r2, [r3, #56]	; 0x38

    /* Init The ULPI Interface */
    USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_TSDPS | USB_OTG_GUSBCFG_ULPIFSLS | USB_OTG_GUSBCFG_PHYSEL);
 810ac74:	687b      	ldr	r3, [r7, #4]
 810ac76:	68db      	ldr	r3, [r3, #12]
 810ac78:	f423 0384 	bic.w	r3, r3, #4325376	; 0x420000
 810ac7c:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 810ac80:	687a      	ldr	r2, [r7, #4]
 810ac82:	60d3      	str	r3, [r2, #12]

    /* Select vbus source */
    USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_ULPIEVBUSD | USB_OTG_GUSBCFG_ULPIEVBUSI);
 810ac84:	687b      	ldr	r3, [r7, #4]
 810ac86:	68db      	ldr	r3, [r3, #12]
 810ac88:	f423 1240 	bic.w	r2, r3, #3145728	; 0x300000
 810ac8c:	687b      	ldr	r3, [r7, #4]
 810ac8e:	60da      	str	r2, [r3, #12]
    if (cfg.use_external_vbus == 1U)
 810ac90:	f897 3028 	ldrb.w	r3, [r7, #40]	; 0x28
 810ac94:	2b01      	cmp	r3, #1
 810ac96:	d105      	bne.n	810aca4 <USB_CoreInit+0x56>
    {
      USBx->GUSBCFG |= USB_OTG_GUSBCFG_ULPIEVBUSD;
 810ac98:	687b      	ldr	r3, [r7, #4]
 810ac9a:	68db      	ldr	r3, [r3, #12]
 810ac9c:	f443 1280 	orr.w	r2, r3, #1048576	; 0x100000
 810aca0:	687b      	ldr	r3, [r7, #4]
 810aca2:	60da      	str	r2, [r3, #12]
    }

    /* Reset after a PHY select */
    ret = USB_CoreReset(USBx);
 810aca4:	6878      	ldr	r0, [r7, #4]
 810aca6:	f001 fae9 	bl	810c27c <USB_CoreReset>
 810acaa:	4603      	mov	r3, r0
 810acac:	73fb      	strb	r3, [r7, #15]
 810acae:	e01b      	b.n	810ace8 <USB_CoreInit+0x9a>
  }
  else /* FS interface (embedded Phy) */
  {
    /* Select FS Embedded PHY */
    USBx->GUSBCFG |= USB_OTG_GUSBCFG_PHYSEL;
 810acb0:	687b      	ldr	r3, [r7, #4]
 810acb2:	68db      	ldr	r3, [r3, #12]
 810acb4:	f043 0240 	orr.w	r2, r3, #64	; 0x40
 810acb8:	687b      	ldr	r3, [r7, #4]
 810acba:	60da      	str	r2, [r3, #12]

    /* Reset after a PHY select */
    ret = USB_CoreReset(USBx);
 810acbc:	6878      	ldr	r0, [r7, #4]
 810acbe:	f001 fadd 	bl	810c27c <USB_CoreReset>
 810acc2:	4603      	mov	r3, r0
 810acc4:	73fb      	strb	r3, [r7, #15]

    if (cfg.battery_charging_enable == 0U)
 810acc6:	f897 3025 	ldrb.w	r3, [r7, #37]	; 0x25
 810acca:	2b00      	cmp	r3, #0
 810accc:	d106      	bne.n	810acdc <USB_CoreInit+0x8e>
    {
      /* Activate the USB Transceiver */
      USBx->GCCFG |= USB_OTG_GCCFG_PWRDWN;
 810acce:	687b      	ldr	r3, [r7, #4]
 810acd0:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 810acd2:	f443 3280 	orr.w	r2, r3, #65536	; 0x10000
 810acd6:	687b      	ldr	r3, [r7, #4]
 810acd8:	639a      	str	r2, [r3, #56]	; 0x38
 810acda:	e005      	b.n	810ace8 <USB_CoreInit+0x9a>
    }
    else
    {
      /* Deactivate the USB Transceiver */
      USBx->GCCFG &= ~(USB_OTG_GCCFG_PWRDWN);
 810acdc:	687b      	ldr	r3, [r7, #4]
 810acde:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 810ace0:	f423 3280 	bic.w	r2, r3, #65536	; 0x10000
 810ace4:	687b      	ldr	r3, [r7, #4]
 810ace6:	639a      	str	r2, [r3, #56]	; 0x38
    }
  }

  if (cfg.dma_enable == 1U)
 810ace8:	7fbb      	ldrb	r3, [r7, #30]
 810acea:	2b01      	cmp	r3, #1
 810acec:	d118      	bne.n	810ad20 <USB_CoreInit+0xd2>
  {
    /* make sure to reserve 18 fifo Locations for DMA buffers */
    USBx->GDFIFOCFG &= ~(0xFFFFU << 16);
 810acee:	687b      	ldr	r3, [r7, #4]
 810acf0:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 810acf2:	b29a      	uxth	r2, r3
 810acf4:	687b      	ldr	r3, [r7, #4]
 810acf6:	65da      	str	r2, [r3, #92]	; 0x5c
    USBx->GDFIFOCFG |= 0x3EEU << 16;
 810acf8:	687b      	ldr	r3, [r7, #4]
 810acfa:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 810acfc:	f043 737b 	orr.w	r3, r3, #65798144	; 0x3ec0000
 810ad00:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 810ad04:	687a      	ldr	r2, [r7, #4]
 810ad06:	65d3      	str	r3, [r2, #92]	; 0x5c

    USBx->GAHBCFG |= USB_OTG_GAHBCFG_HBSTLEN_2;
 810ad08:	687b      	ldr	r3, [r7, #4]
 810ad0a:	689b      	ldr	r3, [r3, #8]
 810ad0c:	f043 0206 	orr.w	r2, r3, #6
 810ad10:	687b      	ldr	r3, [r7, #4]
 810ad12:	609a      	str	r2, [r3, #8]
    USBx->GAHBCFG |= USB_OTG_GAHBCFG_DMAEN;
 810ad14:	687b      	ldr	r3, [r7, #4]
 810ad16:	689b      	ldr	r3, [r3, #8]
 810ad18:	f043 0220 	orr.w	r2, r3, #32
 810ad1c:	687b      	ldr	r3, [r7, #4]
 810ad1e:	609a      	str	r2, [r3, #8]
  }

  return ret;
 810ad20:	7bfb      	ldrb	r3, [r7, #15]
}
 810ad22:	4618      	mov	r0, r3
 810ad24:	3710      	adds	r7, #16
 810ad26:	46bd      	mov	sp, r7
 810ad28:	e8bd 4080 	ldmia.w	sp!, {r7, lr}
 810ad2c:	b004      	add	sp, #16
 810ad2e:	4770      	bx	lr

0810ad30 <USB_SetTurnaroundTime>:
  * @param  hclk: AHB clock frequency
  * @retval USB turnaround time In PHY Clocks number
  */
HAL_StatusTypeDef USB_SetTurnaroundTime(USB_OTG_GlobalTypeDef *USBx,
                                        uint32_t hclk, uint8_t speed)
{
 810ad30:	b480      	push	{r7}
 810ad32:	b087      	sub	sp, #28
 810ad34:	af00      	add	r7, sp, #0
 810ad36:	60f8      	str	r0, [r7, #12]
 810ad38:	60b9      	str	r1, [r7, #8]
 810ad3a:	4613      	mov	r3, r2
 810ad3c:	71fb      	strb	r3, [r7, #7]

  /* The USBTRD is configured according to the tables below, depending on AHB frequency
  used by application. In the low AHB frequency range it is used to stretch enough the USB response
  time to IN tokens, the USB turnaround time, so to compensate for the longer AHB read access
  latency to the Data FIFO */
  if (speed == USBD_FS_SPEED)
 810ad3e:	79fb      	ldrb	r3, [r7, #7]
 810ad40:	2b02      	cmp	r3, #2
 810ad42:	d165      	bne.n	810ae10 <USB_SetTurnaroundTime+0xe0>
  {
    if ((hclk >= 14200000U) && (hclk < 15000000U))
 810ad44:	68bb      	ldr	r3, [r7, #8]
 810ad46:	4a41      	ldr	r2, [pc, #260]	; (810ae4c <USB_SetTurnaroundTime+0x11c>)
 810ad48:	4293      	cmp	r3, r2
 810ad4a:	d906      	bls.n	810ad5a <USB_SetTurnaroundTime+0x2a>
 810ad4c:	68bb      	ldr	r3, [r7, #8]
 810ad4e:	4a40      	ldr	r2, [pc, #256]	; (810ae50 <USB_SetTurnaroundTime+0x120>)
 810ad50:	4293      	cmp	r3, r2
 810ad52:	d202      	bcs.n	810ad5a <USB_SetTurnaroundTime+0x2a>
    {
      /* hclk Clock Range between 14.2-15 MHz */
      UsbTrd = 0xFU;
 810ad54:	230f      	movs	r3, #15
 810ad56:	617b      	str	r3, [r7, #20]
 810ad58:	e062      	b.n	810ae20 <USB_SetTurnaroundTime+0xf0>
    }
    else if ((hclk >= 15000000U) && (hclk < 16000000U))
 810ad5a:	68bb      	ldr	r3, [r7, #8]
 810ad5c:	4a3c      	ldr	r2, [pc, #240]	; (810ae50 <USB_SetTurnaroundTime+0x120>)
 810ad5e:	4293      	cmp	r3, r2
 810ad60:	d306      	bcc.n	810ad70 <USB_SetTurnaroundTime+0x40>
 810ad62:	68bb      	ldr	r3, [r7, #8]
 810ad64:	4a3b      	ldr	r2, [pc, #236]	; (810ae54 <USB_SetTurnaroundTime+0x124>)
 810ad66:	4293      	cmp	r3, r2
 810ad68:	d202      	bcs.n	810ad70 <USB_SetTurnaroundTime+0x40>
    {
      /* hclk Clock Range between 15-16 MHz */
      UsbTrd = 0xEU;
 810ad6a:	230e      	movs	r3, #14
 810ad6c:	617b      	str	r3, [r7, #20]
 810ad6e:	e057      	b.n	810ae20 <USB_SetTurnaroundTime+0xf0>
    }
    else if ((hclk >= 16000000U) && (hclk < 17200000U))
 810ad70:	68bb      	ldr	r3, [r7, #8]
 810ad72:	4a38      	ldr	r2, [pc, #224]	; (810ae54 <USB_SetTurnaroundTime+0x124>)
 810ad74:	4293      	cmp	r3, r2
 810ad76:	d306      	bcc.n	810ad86 <USB_SetTurnaroundTime+0x56>
 810ad78:	68bb      	ldr	r3, [r7, #8]
 810ad7a:	4a37      	ldr	r2, [pc, #220]	; (810ae58 <USB_SetTurnaroundTime+0x128>)
 810ad7c:	4293      	cmp	r3, r2
 810ad7e:	d202      	bcs.n	810ad86 <USB_SetTurnaroundTime+0x56>
    {
      /* hclk Clock Range between 16-17.2 MHz */
      UsbTrd = 0xDU;
 810ad80:	230d      	movs	r3, #13
 810ad82:	617b      	str	r3, [r7, #20]
 810ad84:	e04c      	b.n	810ae20 <USB_SetTurnaroundTime+0xf0>
    }
    else if ((hclk >= 17200000U) && (hclk < 18500000U))
 810ad86:	68bb      	ldr	r3, [r7, #8]
 810ad88:	4a33      	ldr	r2, [pc, #204]	; (810ae58 <USB_SetTurnaroundTime+0x128>)
 810ad8a:	4293      	cmp	r3, r2
 810ad8c:	d306      	bcc.n	810ad9c <USB_SetTurnaroundTime+0x6c>
 810ad8e:	68bb      	ldr	r3, [r7, #8]
 810ad90:	4a32      	ldr	r2, [pc, #200]	; (810ae5c <USB_SetTurnaroundTime+0x12c>)
 810ad92:	4293      	cmp	r3, r2
 810ad94:	d802      	bhi.n	810ad9c <USB_SetTurnaroundTime+0x6c>
    {
      /* hclk Clock Range between 17.2-18.5 MHz */
      UsbTrd = 0xCU;
 810ad96:	230c      	movs	r3, #12
 810ad98:	617b      	str	r3, [r7, #20]
 810ad9a:	e041      	b.n	810ae20 <USB_SetTurnaroundTime+0xf0>
    }
    else if ((hclk >= 18500000U) && (hclk < 20000000U))
 810ad9c:	68bb      	ldr	r3, [r7, #8]
 810ad9e:	4a2f      	ldr	r2, [pc, #188]	; (810ae5c <USB_SetTurnaroundTime+0x12c>)
 810ada0:	4293      	cmp	r3, r2
 810ada2:	d906      	bls.n	810adb2 <USB_SetTurnaroundTime+0x82>
 810ada4:	68bb      	ldr	r3, [r7, #8]
 810ada6:	4a2e      	ldr	r2, [pc, #184]	; (810ae60 <USB_SetTurnaroundTime+0x130>)
 810ada8:	4293      	cmp	r3, r2
 810adaa:	d802      	bhi.n	810adb2 <USB_SetTurnaroundTime+0x82>
    {
      /* hclk Clock Range between 18.5-20 MHz */
      UsbTrd = 0xBU;
 810adac:	230b      	movs	r3, #11
 810adae:	617b      	str	r3, [r7, #20]
 810adb0:	e036      	b.n	810ae20 <USB_SetTurnaroundTime+0xf0>
    }
    else if ((hclk >= 20000000U) && (hclk < 21800000U))
 810adb2:	68bb      	ldr	r3, [r7, #8]
 810adb4:	4a2a      	ldr	r2, [pc, #168]	; (810ae60 <USB_SetTurnaroundTime+0x130>)
 810adb6:	4293      	cmp	r3, r2
 810adb8:	d906      	bls.n	810adc8 <USB_SetTurnaroundTime+0x98>
 810adba:	68bb      	ldr	r3, [r7, #8]
 810adbc:	4a29      	ldr	r2, [pc, #164]	; (810ae64 <USB_SetTurnaroundTime+0x134>)
 810adbe:	4293      	cmp	r3, r2
 810adc0:	d802      	bhi.n	810adc8 <USB_SetTurnaroundTime+0x98>
    {
      /* hclk Clock Range between 20-21.8 MHz */
      UsbTrd = 0xAU;
 810adc2:	230a      	movs	r3, #10
 810adc4:	617b      	str	r3, [r7, #20]
 810adc6:	e02b      	b.n	810ae20 <USB_SetTurnaroundTime+0xf0>
    }
    else if ((hclk >= 21800000U) && (hclk < 24000000U))
 810adc8:	68bb      	ldr	r3, [r7, #8]
 810adca:	4a26      	ldr	r2, [pc, #152]	; (810ae64 <USB_SetTurnaroundTime+0x134>)
 810adcc:	4293      	cmp	r3, r2
 810adce:	d906      	bls.n	810adde <USB_SetTurnaroundTime+0xae>
 810add0:	68bb      	ldr	r3, [r7, #8]
 810add2:	4a25      	ldr	r2, [pc, #148]	; (810ae68 <USB_SetTurnaroundTime+0x138>)
 810add4:	4293      	cmp	r3, r2
 810add6:	d202      	bcs.n	810adde <USB_SetTurnaroundTime+0xae>
    {
      /* hclk Clock Range between 21.8-24 MHz */
      UsbTrd = 0x9U;
 810add8:	2309      	movs	r3, #9
 810adda:	617b      	str	r3, [r7, #20]
 810addc:	e020      	b.n	810ae20 <USB_SetTurnaroundTime+0xf0>
    }
    else if ((hclk >= 24000000U) && (hclk < 27700000U))
 810adde:	68bb      	ldr	r3, [r7, #8]
 810ade0:	4a21      	ldr	r2, [pc, #132]	; (810ae68 <USB_SetTurnaroundTime+0x138>)
 810ade2:	4293      	cmp	r3, r2
 810ade4:	d306      	bcc.n	810adf4 <USB_SetTurnaroundTime+0xc4>
 810ade6:	68bb      	ldr	r3, [r7, #8]
 810ade8:	4a20      	ldr	r2, [pc, #128]	; (810ae6c <USB_SetTurnaroundTime+0x13c>)
 810adea:	4293      	cmp	r3, r2
 810adec:	d802      	bhi.n	810adf4 <USB_SetTurnaroundTime+0xc4>
    {
      /* hclk Clock Range between 24-27.7 MHz */
      UsbTrd = 0x8U;
 810adee:	2308      	movs	r3, #8
 810adf0:	617b      	str	r3, [r7, #20]
 810adf2:	e015      	b.n	810ae20 <USB_SetTurnaroundTime+0xf0>
    }
    else if ((hclk >= 27700000U) && (hclk < 32000000U))
 810adf4:	68bb      	ldr	r3, [r7, #8]
 810adf6:	4a1d      	ldr	r2, [pc, #116]	; (810ae6c <USB_SetTurnaroundTime+0x13c>)
 810adf8:	4293      	cmp	r3, r2
 810adfa:	d906      	bls.n	810ae0a <USB_SetTurnaroundTime+0xda>
 810adfc:	68bb      	ldr	r3, [r7, #8]
 810adfe:	4a1c      	ldr	r2, [pc, #112]	; (810ae70 <USB_SetTurnaroundTime+0x140>)
 810ae00:	4293      	cmp	r3, r2
 810ae02:	d202      	bcs.n	810ae0a <USB_SetTurnaroundTime+0xda>
    {
      /* hclk Clock Range between 27.7-32 MHz */
      UsbTrd = 0x7U;
 810ae04:	2307      	movs	r3, #7
 810ae06:	617b      	str	r3, [r7, #20]
 810ae08:	e00a      	b.n	810ae20 <USB_SetTurnaroundTime+0xf0>
    }
    else /* if(hclk >= 32000000) */
    {
      /* hclk Clock Range between 32-200 MHz */
      UsbTrd = 0x6U;
 810ae0a:	2306      	movs	r3, #6
 810ae0c:	617b      	str	r3, [r7, #20]
 810ae0e:	e007      	b.n	810ae20 <USB_SetTurnaroundTime+0xf0>
    }
  }
  else if (speed == USBD_HS_SPEED)
 810ae10:	79fb      	ldrb	r3, [r7, #7]
 810ae12:	2b00      	cmp	r3, #0
 810ae14:	d102      	bne.n	810ae1c <USB_SetTurnaroundTime+0xec>
  {
    UsbTrd = USBD_HS_TRDT_VALUE;
 810ae16:	2309      	movs	r3, #9
 810ae18:	617b      	str	r3, [r7, #20]
 810ae1a:	e001      	b.n	810ae20 <USB_SetTurnaroundTime+0xf0>
  }
  else
  {
    UsbTrd = USBD_DEFAULT_TRDT_VALUE;
 810ae1c:	2309      	movs	r3, #9
 810ae1e:	617b      	str	r3, [r7, #20]
  }

  USBx->GUSBCFG &= ~USB_OTG_GUSBCFG_TRDT;
 810ae20:	68fb      	ldr	r3, [r7, #12]
 810ae22:	68db      	ldr	r3, [r3, #12]
 810ae24:	f423 5270 	bic.w	r2, r3, #15360	; 0x3c00
 810ae28:	68fb      	ldr	r3, [r7, #12]
 810ae2a:	60da      	str	r2, [r3, #12]
  USBx->GUSBCFG |= (uint32_t)((UsbTrd << 10) & USB_OTG_GUSBCFG_TRDT);
 810ae2c:	68fb      	ldr	r3, [r7, #12]
 810ae2e:	68da      	ldr	r2, [r3, #12]
 810ae30:	697b      	ldr	r3, [r7, #20]
 810ae32:	029b      	lsls	r3, r3, #10
 810ae34:	f403 5370 	and.w	r3, r3, #15360	; 0x3c00
 810ae38:	431a      	orrs	r2, r3
 810ae3a:	68fb      	ldr	r3, [r7, #12]
 810ae3c:	60da      	str	r2, [r3, #12]

  return HAL_OK;
 810ae3e:	2300      	movs	r3, #0
}
 810ae40:	4618      	mov	r0, r3
 810ae42:	371c      	adds	r7, #28
 810ae44:	46bd      	mov	sp, r7
 810ae46:	f85d 7b04 	ldr.w	r7, [sp], #4
 810ae4a:	4770      	bx	lr
 810ae4c:	00d8acbf 	.word	0x00d8acbf
 810ae50:	00e4e1c0 	.word	0x00e4e1c0
 810ae54:	00f42400 	.word	0x00f42400
 810ae58:	01067380 	.word	0x01067380
 810ae5c:	011a499f 	.word	0x011a499f
 810ae60:	01312cff 	.word	0x01312cff
 810ae64:	014ca43f 	.word	0x014ca43f
 810ae68:	016e3600 	.word	0x016e3600
 810ae6c:	01a6ab1f 	.word	0x01a6ab1f
 810ae70:	01e84800 	.word	0x01e84800

0810ae74 <USB_EnableGlobalInt>:
  *         Enables the controller's Global Int in the AHB Config reg
  * @param  USBx  Selected device
  * @retval HAL status
  */
HAL_StatusTypeDef USB_EnableGlobalInt(USB_OTG_GlobalTypeDef *USBx)
{
 810ae74:	b480      	push	{r7}
 810ae76:	b083      	sub	sp, #12
 810ae78:	af00      	add	r7, sp, #0
 810ae7a:	6078      	str	r0, [r7, #4]
  USBx->GAHBCFG |= USB_OTG_GAHBCFG_GINT;
 810ae7c:	687b      	ldr	r3, [r7, #4]
 810ae7e:	689b      	ldr	r3, [r3, #8]
 810ae80:	f043 0201 	orr.w	r2, r3, #1
 810ae84:	687b      	ldr	r3, [r7, #4]
 810ae86:	609a      	str	r2, [r3, #8]
  return HAL_OK;
 810ae88:	2300      	movs	r3, #0
}
 810ae8a:	4618      	mov	r0, r3
 810ae8c:	370c      	adds	r7, #12
 810ae8e:	46bd      	mov	sp, r7
 810ae90:	f85d 7b04 	ldr.w	r7, [sp], #4
 810ae94:	4770      	bx	lr

0810ae96 <USB_DisableGlobalInt>:
  *         Disable the controller's Global Int in the AHB Config reg
  * @param  USBx  Selected device
  * @retval HAL status
  */
HAL_StatusTypeDef USB_DisableGlobalInt(USB_OTG_GlobalTypeDef *USBx)
{
 810ae96:	b480      	push	{r7}
 810ae98:	b083      	sub	sp, #12
 810ae9a:	af00      	add	r7, sp, #0
 810ae9c:	6078      	str	r0, [r7, #4]
  USBx->GAHBCFG &= ~USB_OTG_GAHBCFG_GINT;
 810ae9e:	687b      	ldr	r3, [r7, #4]
 810aea0:	689b      	ldr	r3, [r3, #8]
 810aea2:	f023 0201 	bic.w	r2, r3, #1
 810aea6:	687b      	ldr	r3, [r7, #4]
 810aea8:	609a      	str	r2, [r3, #8]
  return HAL_OK;
 810aeaa:	2300      	movs	r3, #0
}
 810aeac:	4618      	mov	r0, r3
 810aeae:	370c      	adds	r7, #12
 810aeb0:	46bd      	mov	sp, r7
 810aeb2:	f85d 7b04 	ldr.w	r7, [sp], #4
 810aeb6:	4770      	bx	lr

0810aeb8 <USB_SetCurrentMode>:
  *            @arg USB_DEVICE_MODE Peripheral mode
  *            @arg USB_HOST_MODE Host mode
  * @retval HAL status
  */
HAL_StatusTypeDef USB_SetCurrentMode(USB_OTG_GlobalTypeDef *USBx, USB_OTG_ModeTypeDef mode)
{
 810aeb8:	b580      	push	{r7, lr}
 810aeba:	b084      	sub	sp, #16
 810aebc:	af00      	add	r7, sp, #0
 810aebe:	6078      	str	r0, [r7, #4]
 810aec0:	460b      	mov	r3, r1
 810aec2:	70fb      	strb	r3, [r7, #3]
  uint32_t ms = 0U;
 810aec4:	2300      	movs	r3, #0
 810aec6:	60fb      	str	r3, [r7, #12]

  USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_FHMOD | USB_OTG_GUSBCFG_FDMOD);
 810aec8:	687b      	ldr	r3, [r7, #4]
 810aeca:	68db      	ldr	r3, [r3, #12]
 810aecc:	f023 42c0 	bic.w	r2, r3, #1610612736	; 0x60000000
 810aed0:	687b      	ldr	r3, [r7, #4]
 810aed2:	60da      	str	r2, [r3, #12]

  if (mode == USB_HOST_MODE)
 810aed4:	78fb      	ldrb	r3, [r7, #3]
 810aed6:	2b01      	cmp	r3, #1
 810aed8:	d115      	bne.n	810af06 <USB_SetCurrentMode+0x4e>
  {
    USBx->GUSBCFG |= USB_OTG_GUSBCFG_FHMOD;
 810aeda:	687b      	ldr	r3, [r7, #4]
 810aedc:	68db      	ldr	r3, [r3, #12]
 810aede:	f043 5200 	orr.w	r2, r3, #536870912	; 0x20000000
 810aee2:	687b      	ldr	r3, [r7, #4]
 810aee4:	60da      	str	r2, [r3, #12]

    do
    {
      HAL_Delay(10U);
 810aee6:	200a      	movs	r0, #10
 810aee8:	f7f6 fbb4 	bl	8101654 <HAL_Delay>
      ms += 10U;
 810aeec:	68fb      	ldr	r3, [r7, #12]
 810aeee:	330a      	adds	r3, #10
 810aef0:	60fb      	str	r3, [r7, #12]
    } while ((USB_GetMode(USBx) != (uint32_t)USB_HOST_MODE) && (ms < HAL_USB_CURRENT_MODE_MAX_DELAY_MS));
 810aef2:	6878      	ldr	r0, [r7, #4]
 810aef4:	f001 f933 	bl	810c15e <USB_GetMode>
 810aef8:	4603      	mov	r3, r0
 810aefa:	2b01      	cmp	r3, #1
 810aefc:	d01e      	beq.n	810af3c <USB_SetCurrentMode+0x84>
 810aefe:	68fb      	ldr	r3, [r7, #12]
 810af00:	2bc7      	cmp	r3, #199	; 0xc7
 810af02:	d9f0      	bls.n	810aee6 <USB_SetCurrentMode+0x2e>
 810af04:	e01a      	b.n	810af3c <USB_SetCurrentMode+0x84>
  }
  else if (mode == USB_DEVICE_MODE)
 810af06:	78fb      	ldrb	r3, [r7, #3]
 810af08:	2b00      	cmp	r3, #0
 810af0a:	d115      	bne.n	810af38 <USB_SetCurrentMode+0x80>
  {
    USBx->GUSBCFG |= USB_OTG_GUSBCFG_FDMOD;
 810af0c:	687b      	ldr	r3, [r7, #4]
 810af0e:	68db      	ldr	r3, [r3, #12]
 810af10:	f043 4280 	orr.w	r2, r3, #1073741824	; 0x40000000
 810af14:	687b      	ldr	r3, [r7, #4]
 810af16:	60da      	str	r2, [r3, #12]

    do
    {
      HAL_Delay(10U);
 810af18:	200a      	movs	r0, #10
 810af1a:	f7f6 fb9b 	bl	8101654 <HAL_Delay>
      ms += 10U;
 810af1e:	68fb      	ldr	r3, [r7, #12]
 810af20:	330a      	adds	r3, #10
 810af22:	60fb      	str	r3, [r7, #12]
    } while ((USB_GetMode(USBx) != (uint32_t)USB_DEVICE_MODE) && (ms < HAL_USB_CURRENT_MODE_MAX_DELAY_MS));
 810af24:	6878      	ldr	r0, [r7, #4]
 810af26:	f001 f91a 	bl	810c15e <USB_GetMode>
 810af2a:	4603      	mov	r3, r0
 810af2c:	2b00      	cmp	r3, #0
 810af2e:	d005      	beq.n	810af3c <USB_SetCurrentMode+0x84>
 810af30:	68fb      	ldr	r3, [r7, #12]
 810af32:	2bc7      	cmp	r3, #199	; 0xc7
 810af34:	d9f0      	bls.n	810af18 <USB_SetCurrentMode+0x60>
 810af36:	e001      	b.n	810af3c <USB_SetCurrentMode+0x84>
  }
  else
  {
    return HAL_ERROR;
 810af38:	2301      	movs	r3, #1
 810af3a:	e005      	b.n	810af48 <USB_SetCurrentMode+0x90>
  }

  if (ms == HAL_USB_CURRENT_MODE_MAX_DELAY_MS)
 810af3c:	68fb      	ldr	r3, [r7, #12]
 810af3e:	2bc8      	cmp	r3, #200	; 0xc8
 810af40:	d101      	bne.n	810af46 <USB_SetCurrentMode+0x8e>
  {
    return HAL_ERROR;
 810af42:	2301      	movs	r3, #1
 810af44:	e000      	b.n	810af48 <USB_SetCurrentMode+0x90>
  }

  return HAL_OK;
 810af46:	2300      	movs	r3, #0
}
 810af48:	4618      	mov	r0, r3
 810af4a:	3710      	adds	r7, #16
 810af4c:	46bd      	mov	sp, r7
 810af4e:	bd80      	pop	{r7, pc}

0810af50 <USB_DevInit>:
  * @param  cfg   pointer to a USB_OTG_CfgTypeDef structure that contains
  *         the configuration information for the specified USBx peripheral.
  * @retval HAL status
  */
HAL_StatusTypeDef USB_DevInit(USB_OTG_GlobalTypeDef *USBx, USB_OTG_CfgTypeDef cfg)
{
 810af50:	b084      	sub	sp, #16
 810af52:	b580      	push	{r7, lr}
 810af54:	b086      	sub	sp, #24
 810af56:	af00      	add	r7, sp, #0
 810af58:	6078      	str	r0, [r7, #4]
 810af5a:	f107 0024 	add.w	r0, r7, #36	; 0x24
 810af5e:	e880 000e 	stmia.w	r0, {r1, r2, r3}
  HAL_StatusTypeDef ret = HAL_OK;
 810af62:	2300      	movs	r3, #0
 810af64:	75fb      	strb	r3, [r7, #23]
  uint32_t USBx_BASE = (uint32_t)USBx;
 810af66:	687b      	ldr	r3, [r7, #4]
 810af68:	60fb      	str	r3, [r7, #12]
  uint32_t i;

  for (i = 0U; i < 15U; i++)
 810af6a:	2300      	movs	r3, #0
 810af6c:	613b      	str	r3, [r7, #16]
 810af6e:	e009      	b.n	810af84 <USB_DevInit+0x34>
  {
    USBx->DIEPTXF[i] = 0U;
 810af70:	687a      	ldr	r2, [r7, #4]
 810af72:	693b      	ldr	r3, [r7, #16]
 810af74:	3340      	adds	r3, #64	; 0x40
 810af76:	009b      	lsls	r3, r3, #2
 810af78:	4413      	add	r3, r2
 810af7a:	2200      	movs	r2, #0
 810af7c:	605a      	str	r2, [r3, #4]
  for (i = 0U; i < 15U; i++)
 810af7e:	693b      	ldr	r3, [r7, #16]
 810af80:	3301      	adds	r3, #1
 810af82:	613b      	str	r3, [r7, #16]
 810af84:	693b      	ldr	r3, [r7, #16]
 810af86:	2b0e      	cmp	r3, #14
 810af88:	d9f2      	bls.n	810af70 <USB_DevInit+0x20>
  }

  /* VBUS Sensing setup */
  if (cfg.vbus_sensing_enable == 0U)
 810af8a:	f897 302e 	ldrb.w	r3, [r7, #46]	; 0x2e
 810af8e:	2b00      	cmp	r3, #0
 810af90:	d11c      	bne.n	810afcc <USB_DevInit+0x7c>
  {
    USBx_DEVICE->DCTL |= USB_OTG_DCTL_SDIS;
 810af92:	68fb      	ldr	r3, [r7, #12]
 810af94:	f503 6300 	add.w	r3, r3, #2048	; 0x800
 810af98:	685b      	ldr	r3, [r3, #4]
 810af9a:	68fa      	ldr	r2, [r7, #12]
 810af9c:	f502 6200 	add.w	r2, r2, #2048	; 0x800
 810afa0:	f043 0302 	orr.w	r3, r3, #2
 810afa4:	6053      	str	r3, [r2, #4]

    /* Deactivate VBUS Sensing B */
    USBx->GCCFG &= ~USB_OTG_GCCFG_VBDEN;
 810afa6:	687b      	ldr	r3, [r7, #4]
 810afa8:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 810afaa:	f423 1200 	bic.w	r2, r3, #2097152	; 0x200000
 810afae:	687b      	ldr	r3, [r7, #4]
 810afb0:	639a      	str	r2, [r3, #56]	; 0x38

    /* B-peripheral session valid override enable */
    USBx->GOTGCTL |= USB_OTG_GOTGCTL_BVALOEN;
 810afb2:	687b      	ldr	r3, [r7, #4]
 810afb4:	681b      	ldr	r3, [r3, #0]
 810afb6:	f043 0240 	orr.w	r2, r3, #64	; 0x40
 810afba:	687b      	ldr	r3, [r7, #4]
 810afbc:	601a      	str	r2, [r3, #0]
    USBx->GOTGCTL |= USB_OTG_GOTGCTL_BVALOVAL;
 810afbe:	687b      	ldr	r3, [r7, #4]
 810afc0:	681b      	ldr	r3, [r3, #0]
 810afc2:	f043 0280 	orr.w	r2, r3, #128	; 0x80
 810afc6:	687b      	ldr	r3, [r7, #4]
 810afc8:	601a      	str	r2, [r3, #0]
 810afca:	e005      	b.n	810afd8 <USB_DevInit+0x88>
  }
  else
  {
    /* Enable HW VBUS sensing */
    USBx->GCCFG |= USB_OTG_GCCFG_VBDEN;
 810afcc:	687b      	ldr	r3, [r7, #4]
 810afce:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 810afd0:	f443 1200 	orr.w	r2, r3, #2097152	; 0x200000
 810afd4:	687b      	ldr	r3, [r7, #4]
 810afd6:	639a      	str	r2, [r3, #56]	; 0x38
  }

  /* Restart the Phy Clock */
  USBx_PCGCCTL = 0U;
 810afd8:	68fb      	ldr	r3, [r7, #12]
 810afda:	f503 6360 	add.w	r3, r3, #3584	; 0xe00
 810afde:	461a      	mov	r2, r3
 810afe0:	2300      	movs	r3, #0
 810afe2:	6013      	str	r3, [r2, #0]

  if (cfg.phy_itface == USB_OTG_ULPI_PHY)
 810afe4:	f897 3029 	ldrb.w	r3, [r7, #41]	; 0x29
 810afe8:	2b01      	cmp	r3, #1
 810afea:	d10d      	bne.n	810b008 <USB_DevInit+0xb8>
  {
    if (cfg.speed == USBD_HS_SPEED)
 810afec:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 810aff0:	2b00      	cmp	r3, #0
 810aff2:	d104      	bne.n	810affe <USB_DevInit+0xae>
    {
      /* Set Core speed to High speed mode */
      (void)USB_SetDevSpeed(USBx, USB_OTG_SPEED_HIGH);
 810aff4:	2100      	movs	r1, #0
 810aff6:	6878      	ldr	r0, [r7, #4]
 810aff8:	f000 f968 	bl	810b2cc <USB_SetDevSpeed>
 810affc:	e008      	b.n	810b010 <USB_DevInit+0xc0>
    }
    else
    {
      /* Set Core speed to Full speed mode */
      (void)USB_SetDevSpeed(USBx, USB_OTG_SPEED_HIGH_IN_FULL);
 810affe:	2101      	movs	r1, #1
 810b000:	6878      	ldr	r0, [r7, #4]
 810b002:	f000 f963 	bl	810b2cc <USB_SetDevSpeed>
 810b006:	e003      	b.n	810b010 <USB_DevInit+0xc0>
    }
  }
  else
  {
    /* Set Core speed to Full speed mode */
    (void)USB_SetDevSpeed(USBx, USB_OTG_SPEED_FULL);
 810b008:	2103      	movs	r1, #3
 810b00a:	6878      	ldr	r0, [r7, #4]
 810b00c:	f000 f95e 	bl	810b2cc <USB_SetDevSpeed>
  }

  /* Flush the FIFOs */
  if (USB_FlushTxFifo(USBx, 0x10U) != HAL_OK) /* all Tx FIFOs */
 810b010:	2110      	movs	r1, #16
 810b012:	6878      	ldr	r0, [r7, #4]
 810b014:	f000 f8fa 	bl	810b20c <USB_FlushTxFifo>
 810b018:	4603      	mov	r3, r0
 810b01a:	2b00      	cmp	r3, #0
 810b01c:	d001      	beq.n	810b022 <USB_DevInit+0xd2>
  {
    ret = HAL_ERROR;
 810b01e:	2301      	movs	r3, #1
 810b020:	75fb      	strb	r3, [r7, #23]
  }

  if (USB_FlushRxFifo(USBx) != HAL_OK)
 810b022:	6878      	ldr	r0, [r7, #4]
 810b024:	f000 f924 	bl	810b270 <USB_FlushRxFifo>
 810b028:	4603      	mov	r3, r0
 810b02a:	2b00      	cmp	r3, #0
 810b02c:	d001      	beq.n	810b032 <USB_DevInit+0xe2>
  {
    ret = HAL_ERROR;
 810b02e:	2301      	movs	r3, #1
 810b030:	75fb      	strb	r3, [r7, #23]
  }

  /* Clear all pending Device Interrupts */
  USBx_DEVICE->DIEPMSK = 0U;
 810b032:	68fb      	ldr	r3, [r7, #12]
 810b034:	f503 6300 	add.w	r3, r3, #2048	; 0x800
 810b038:	461a      	mov	r2, r3
 810b03a:	2300      	movs	r3, #0
 810b03c:	6113      	str	r3, [r2, #16]
  USBx_DEVICE->DOEPMSK = 0U;
 810b03e:	68fb      	ldr	r3, [r7, #12]
 810b040:	f503 6300 	add.w	r3, r3, #2048	; 0x800
 810b044:	461a      	mov	r2, r3
 810b046:	2300      	movs	r3, #0
 810b048:	6153      	str	r3, [r2, #20]
  USBx_DEVICE->DAINTMSK = 0U;
 810b04a:	68fb      	ldr	r3, [r7, #12]
 810b04c:	f503 6300 	add.w	r3, r3, #2048	; 0x800
 810b050:	461a      	mov	r2, r3
 810b052:	2300      	movs	r3, #0
 810b054:	61d3      	str	r3, [r2, #28]

  for (i = 0U; i < cfg.dev_endpoints; i++)
 810b056:	2300      	movs	r3, #0
 810b058:	613b      	str	r3, [r7, #16]
 810b05a:	e043      	b.n	810b0e4 <USB_DevInit+0x194>
  {
    if ((USBx_INEP(i)->DIEPCTL & USB_OTG_DIEPCTL_EPENA) == USB_OTG_DIEPCTL_EPENA)
 810b05c:	693b      	ldr	r3, [r7, #16]
 810b05e:	015a      	lsls	r2, r3, #5
 810b060:	68fb      	ldr	r3, [r7, #12]
 810b062:	4413      	add	r3, r2
 810b064:	f503 6310 	add.w	r3, r3, #2304	; 0x900
 810b068:	681b      	ldr	r3, [r3, #0]
 810b06a:	f003 4300 	and.w	r3, r3, #2147483648	; 0x80000000
 810b06e:	f1b3 4f00 	cmp.w	r3, #2147483648	; 0x80000000
 810b072:	d118      	bne.n	810b0a6 <USB_DevInit+0x156>
    {
      if (i == 0U)
 810b074:	693b      	ldr	r3, [r7, #16]
 810b076:	2b00      	cmp	r3, #0
 810b078:	d10a      	bne.n	810b090 <USB_DevInit+0x140>
      {
        USBx_INEP(i)->DIEPCTL = USB_OTG_DIEPCTL_SNAK;
 810b07a:	693b      	ldr	r3, [r7, #16]
 810b07c:	015a      	lsls	r2, r3, #5
 810b07e:	68fb      	ldr	r3, [r7, #12]
 810b080:	4413      	add	r3, r2
 810b082:	f503 6310 	add.w	r3, r3, #2304	; 0x900
 810b086:	461a      	mov	r2, r3
 810b088:	f04f 6300 	mov.w	r3, #134217728	; 0x8000000
 810b08c:	6013      	str	r3, [r2, #0]
 810b08e:	e013      	b.n	810b0b8 <USB_DevInit+0x168>
      }
      else
      {
        USBx_INEP(i)->DIEPCTL = USB_OTG_DIEPCTL_EPDIS | USB_OTG_DIEPCTL_SNAK;
 810b090:	693b      	ldr	r3, [r7, #16]
 810b092:	015a      	lsls	r2, r3, #5
 810b094:	68fb      	ldr	r3, [r7, #12]
 810b096:	4413      	add	r3, r2
 810b098:	f503 6310 	add.w	r3, r3, #2304	; 0x900
 810b09c:	461a      	mov	r2, r3
 810b09e:	f04f 4390 	mov.w	r3, #1207959552	; 0x48000000
 810b0a2:	6013      	str	r3, [r2, #0]
 810b0a4:	e008      	b.n	810b0b8 <USB_DevInit+0x168>
      }
    }
    else
    {
      USBx_INEP(i)->DIEPCTL = 0U;
 810b0a6:	693b      	ldr	r3, [r7, #16]
 810b0a8:	015a      	lsls	r2, r3, #5
 810b0aa:	68fb      	ldr	r3, [r7, #12]
 810b0ac:	4413      	add	r3, r2
 810b0ae:	f503 6310 	add.w	r3, r3, #2304	; 0x900
 810b0b2:	461a      	mov	r2, r3
 810b0b4:	2300      	movs	r3, #0
 810b0b6:	6013      	str	r3, [r2, #0]
    }

    USBx_INEP(i)->DIEPTSIZ = 0U;
 810b0b8:	693b      	ldr	r3, [r7, #16]
 810b0ba:	015a      	lsls	r2, r3, #5
 810b0bc:	68fb      	ldr	r3, [r7, #12]
 810b0be:	4413      	add	r3, r2
 810b0c0:	f503 6310 	add.w	r3, r3, #2304	; 0x900
 810b0c4:	461a      	mov	r2, r3
 810b0c6:	2300      	movs	r3, #0
 810b0c8:	6113      	str	r3, [r2, #16]
    USBx_INEP(i)->DIEPINT  = 0xFB7FU;
 810b0ca:	693b      	ldr	r3, [r7, #16]
 810b0cc:	015a      	lsls	r2, r3, #5
 810b0ce:	68fb      	ldr	r3, [r7, #12]
 810b0d0:	4413      	add	r3, r2
 810b0d2:	f503 6310 	add.w	r3, r3, #2304	; 0x900
 810b0d6:	461a      	mov	r2, r3
 810b0d8:	f64f 337f 	movw	r3, #64383	; 0xfb7f
 810b0dc:	6093      	str	r3, [r2, #8]
  for (i = 0U; i < cfg.dev_endpoints; i++)
 810b0de:	693b      	ldr	r3, [r7, #16]
 810b0e0:	3301      	adds	r3, #1
 810b0e2:	613b      	str	r3, [r7, #16]
 810b0e4:	f897 3024 	ldrb.w	r3, [r7, #36]	; 0x24
 810b0e8:	461a      	mov	r2, r3
 810b0ea:	693b      	ldr	r3, [r7, #16]
 810b0ec:	4293      	cmp	r3, r2
 810b0ee:	d3b5      	bcc.n	810b05c <USB_DevInit+0x10c>
  }

  for (i = 0U; i < cfg.dev_endpoints; i++)
 810b0f0:	2300      	movs	r3, #0
 810b0f2:	613b      	str	r3, [r7, #16]
 810b0f4:	e043      	b.n	810b17e <USB_DevInit+0x22e>
  {
    if ((USBx_OUTEP(i)->DOEPCTL & USB_OTG_DOEPCTL_EPENA) == USB_OTG_DOEPCTL_EPENA)
 810b0f6:	693b      	ldr	r3, [r7, #16]
 810b0f8:	015a      	lsls	r2, r3, #5
 810b0fa:	68fb      	ldr	r3, [r7, #12]
 810b0fc:	4413      	add	r3, r2
 810b0fe:	f503 6330 	add.w	r3, r3, #2816	; 0xb00
 810b102:	681b      	ldr	r3, [r3, #0]
 810b104:	f003 4300 	and.w	r3, r3, #2147483648	; 0x80000000
 810b108:	f1b3 4f00 	cmp.w	r3, #2147483648	; 0x80000000
 810b10c:	d118      	bne.n	810b140 <USB_DevInit+0x1f0>
    {
      if (i == 0U)
 810b10e:	693b      	ldr	r3, [r7, #16]
 810b110:	2b00      	cmp	r3, #0
 810b112:	d10a      	bne.n	810b12a <USB_DevInit+0x1da>
      {
        USBx_OUTEP(i)->DOEPCTL = USB_OTG_DOEPCTL_SNAK;
 810b114:	693b      	ldr	r3, [r7, #16]
 810b116:	015a      	lsls	r2, r3, #5
 810b118:	68fb      	ldr	r3, [r7, #12]
 810b11a:	4413      	add	r3, r2
 810b11c:	f503 6330 	add.w	r3, r3, #2816	; 0xb00
 810b120:	461a      	mov	r2, r3
 810b122:	f04f 6300 	mov.w	r3, #134217728	; 0x8000000
 810b126:	6013      	str	r3, [r2, #0]
 810b128:	e013      	b.n	810b152 <USB_DevInit+0x202>
      }
      else
      {
        USBx_OUTEP(i)->DOEPCTL = USB_OTG_DOEPCTL_EPDIS | USB_OTG_DOEPCTL_SNAK;
 810b12a:	693b      	ldr	r3, [r7, #16]
 810b12c:	015a      	lsls	r2, r3, #5
 810b12e:	68fb      	ldr	r3, [r7, #12]
 810b130:	4413      	add	r3, r2
 810b132:	f503 6330 	add.w	r3, r3, #2816	; 0xb00
 810b136:	461a      	mov	r2, r3
 810b138:	f04f 4390 	mov.w	r3, #1207959552	; 0x48000000
 810b13c:	6013      	str	r3, [r2, #0]
 810b13e:	e008      	b.n	810b152 <USB_DevInit+0x202>
      }
    }
    else
    {
      USBx_OUTEP(i)->DOEPCTL = 0U;
 810b140:	693b      	ldr	r3, [r7, #16]
 810b142:	015a      	lsls	r2, r3, #5
 810b144:	68fb      	ldr	r3, [r7, #12]
 810b146:	4413      	add	r3, r2
 810b148:	f503 6330 	add.w	r3, r3, #2816	; 0xb00
 810b14c:	461a      	mov	r2, r3
 810b14e:	2300      	movs	r3, #0
 810b150:	6013      	str	r3, [r2, #0]
    }

    USBx_OUTEP(i)->DOEPTSIZ = 0U;
 810b152:	693b      	ldr	r3, [r7, #16]
 810b154:	015a      	lsls	r2, r3, #5
 810b156:	68fb      	ldr	r3, [r7, #12]
 810b158:	4413      	add	r3, r2
 810b15a:	f503 6330 	add.w	r3, r3, #2816	; 0xb00
 810b15e:	461a      	mov	r2, r3
 810b160:	2300      	movs	r3, #0
 810b162:	6113      	str	r3, [r2, #16]
    USBx_OUTEP(i)->DOEPINT  = 0xFB7FU;
 810b164:	693b      	ldr	r3, [r7, #16]
 810b166:	015a      	lsls	r2, r3, #5
 810b168:	68fb      	ldr	r3, [r7, #12]
 810b16a:	4413      	add	r3, r2
 810b16c:	f503 6330 	add.w	r3, r3, #2816	; 0xb00
 810b170:	461a      	mov	r2, r3
 810b172:	f64f 337f 	movw	r3, #64383	; 0xfb7f
 810b176:	6093      	str	r3, [r2, #8]
  for (i = 0U; i < cfg.dev_endpoints; i++)
 810b178:	693b      	ldr	r3, [r7, #16]
 810b17a:	3301      	adds	r3, #1
 810b17c:	613b      	str	r3, [r7, #16]
 810b17e:	f897 3024 	ldrb.w	r3, [r7, #36]	; 0x24
 810b182:	461a      	mov	r2, r3
 810b184:	693b      	ldr	r3, [r7, #16]
 810b186:	4293      	cmp	r3, r2
 810b188:	d3b5      	bcc.n	810b0f6 <USB_DevInit+0x1a6>
  }

  USBx_DEVICE->DIEPMSK &= ~(USB_OTG_DIEPMSK_TXFURM);
 810b18a:	68fb      	ldr	r3, [r7, #12]
 810b18c:	f503 6300 	add.w	r3, r3, #2048	; 0x800
 810b190:	691b      	ldr	r3, [r3, #16]
 810b192:	68fa      	ldr	r2, [r7, #12]
 810b194:	f502 6200 	add.w	r2, r2, #2048	; 0x800
 810b198:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 810b19c:	6113      	str	r3, [r2, #16]

  /* Disable all interrupts. */
  USBx->GINTMSK = 0U;
 810b19e:	687b      	ldr	r3, [r7, #4]
 810b1a0:	2200      	movs	r2, #0
 810b1a2:	619a      	str	r2, [r3, #24]

  /* Clear any pending interrupts */
  USBx->GINTSTS = 0xBFFFFFFFU;
 810b1a4:	687b      	ldr	r3, [r7, #4]
 810b1a6:	f06f 4280 	mvn.w	r2, #1073741824	; 0x40000000
 810b1aa:	615a      	str	r2, [r3, #20]

  /* Enable the common interrupts */
  if (cfg.dma_enable == 0U)
 810b1ac:	f897 3026 	ldrb.w	r3, [r7, #38]	; 0x26
 810b1b0:	2b00      	cmp	r3, #0
 810b1b2:	d105      	bne.n	810b1c0 <USB_DevInit+0x270>
  {
    USBx->GINTMSK |= USB_OTG_GINTMSK_RXFLVLM;
 810b1b4:	687b      	ldr	r3, [r7, #4]
 810b1b6:	699b      	ldr	r3, [r3, #24]
 810b1b8:	f043 0210 	orr.w	r2, r3, #16
 810b1bc:	687b      	ldr	r3, [r7, #4]
 810b1be:	619a      	str	r2, [r3, #24]
  }

  /* Enable interrupts matching to the Device mode ONLY */
  USBx->GINTMSK |= USB_OTG_GINTMSK_USBSUSPM | USB_OTG_GINTMSK_USBRST |
 810b1c0:	687b      	ldr	r3, [r7, #4]
 810b1c2:	699a      	ldr	r2, [r3, #24]
 810b1c4:	4b10      	ldr	r3, [pc, #64]	; (810b208 <USB_DevInit+0x2b8>)
 810b1c6:	4313      	orrs	r3, r2
 810b1c8:	687a      	ldr	r2, [r7, #4]
 810b1ca:	6193      	str	r3, [r2, #24]
                   USB_OTG_GINTMSK_ENUMDNEM | USB_OTG_GINTMSK_IEPINT |
                   USB_OTG_GINTMSK_OEPINT   | USB_OTG_GINTMSK_IISOIXFRM |
                   USB_OTG_GINTMSK_PXFRM_IISOOXFRM | USB_OTG_GINTMSK_WUIM;

  if (cfg.Sof_enable != 0U)
 810b1cc:	f897 302a 	ldrb.w	r3, [r7, #42]	; 0x2a
 810b1d0:	2b00      	cmp	r3, #0
 810b1d2:	d005      	beq.n	810b1e0 <USB_DevInit+0x290>
  {
    USBx->GINTMSK |= USB_OTG_GINTMSK_SOFM;
 810b1d4:	687b      	ldr	r3, [r7, #4]
 810b1d6:	699b      	ldr	r3, [r3, #24]
 810b1d8:	f043 0208 	orr.w	r2, r3, #8
 810b1dc:	687b      	ldr	r3, [r7, #4]
 810b1de:	619a      	str	r2, [r3, #24]
  }

  if (cfg.vbus_sensing_enable == 1U)
 810b1e0:	f897 302e 	ldrb.w	r3, [r7, #46]	; 0x2e
 810b1e4:	2b01      	cmp	r3, #1
 810b1e6:	d107      	bne.n	810b1f8 <USB_DevInit+0x2a8>
  {
    USBx->GINTMSK |= (USB_OTG_GINTMSK_SRQIM | USB_OTG_GINTMSK_OTGINT);
 810b1e8:	687b      	ldr	r3, [r7, #4]
 810b1ea:	699b      	ldr	r3, [r3, #24]
 810b1ec:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
 810b1f0:	f043 0304 	orr.w	r3, r3, #4
 810b1f4:	687a      	ldr	r2, [r7, #4]
 810b1f6:	6193      	str	r3, [r2, #24]
  }

  return ret;
 810b1f8:	7dfb      	ldrb	r3, [r7, #23]
}
 810b1fa:	4618      	mov	r0, r3
 810b1fc:	3718      	adds	r7, #24
 810b1fe:	46bd      	mov	sp, r7
 810b200:	e8bd 4080 	ldmia.w	sp!, {r7, lr}
 810b204:	b004      	add	sp, #16
 810b206:	4770      	bx	lr
 810b208:	803c3800 	.word	0x803c3800

0810b20c <USB_FlushTxFifo>:
  *         This parameter can be a value from 1 to 15
            15 means Flush all Tx FIFOs
  * @retval HAL status
  */
HAL_StatusTypeDef USB_FlushTxFifo(USB_OTG_GlobalTypeDef *USBx, uint32_t num)
{
 810b20c:	b480      	push	{r7}
 810b20e:	b085      	sub	sp, #20
 810b210:	af00      	add	r7, sp, #0
 810b212:	6078      	str	r0, [r7, #4]
 810b214:	6039      	str	r1, [r7, #0]
  __IO uint32_t count = 0U;
 810b216:	2300      	movs	r3, #0
 810b218:	60fb      	str	r3, [r7, #12]

  /* Wait for AHB master IDLE state. */
  do
  {
    count++;
 810b21a:	68fb      	ldr	r3, [r7, #12]
 810b21c:	3301      	adds	r3, #1
 810b21e:	60fb      	str	r3, [r7, #12]

    if (count > HAL_USB_TIMEOUT)
 810b220:	68fb      	ldr	r3, [r7, #12]
 810b222:	f1b3 6f70 	cmp.w	r3, #251658240	; 0xf000000
 810b226:	d901      	bls.n	810b22c <USB_FlushTxFifo+0x20>
    {
      return HAL_TIMEOUT;
 810b228:	2303      	movs	r3, #3
 810b22a:	e01b      	b.n	810b264 <USB_FlushTxFifo+0x58>
    }
  } while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_AHBIDL) == 0U);
 810b22c:	687b      	ldr	r3, [r7, #4]
 810b22e:	691b      	ldr	r3, [r3, #16]
 810b230:	2b00      	cmp	r3, #0
 810b232:	daf2      	bge.n	810b21a <USB_FlushTxFifo+0xe>

  /* Flush TX Fifo */
  count = 0U;
 810b234:	2300      	movs	r3, #0
 810b236:	60fb      	str	r3, [r7, #12]
  USBx->GRSTCTL = (USB_OTG_GRSTCTL_TXFFLSH | (num << 6));
 810b238:	683b      	ldr	r3, [r7, #0]
 810b23a:	019b      	lsls	r3, r3, #6
 810b23c:	f043 0220 	orr.w	r2, r3, #32
 810b240:	687b      	ldr	r3, [r7, #4]
 810b242:	611a      	str	r2, [r3, #16]

  do
  {
    count++;
 810b244:	68fb      	ldr	r3, [r7, #12]
 810b246:	3301      	adds	r3, #1
 810b248:	60fb      	str	r3, [r7, #12]

    if (count > HAL_USB_TIMEOUT)
 810b24a:	68fb      	ldr	r3, [r7, #12]
 810b24c:	f1b3 6f70 	cmp.w	r3, #251658240	; 0xf000000
 810b250:	d901      	bls.n	810b256 <USB_FlushTxFifo+0x4a>
    {
      return HAL_TIMEOUT;
 810b252:	2303      	movs	r3, #3
 810b254:	e006      	b.n	810b264 <USB_FlushTxFifo+0x58>
    }
  } while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_TXFFLSH) == USB_OTG_GRSTCTL_TXFFLSH);
 810b256:	687b      	ldr	r3, [r7, #4]
 810b258:	691b      	ldr	r3, [r3, #16]
 810b25a:	f003 0320 	and.w	r3, r3, #32
 810b25e:	2b20      	cmp	r3, #32
 810b260:	d0f0      	beq.n	810b244 <USB_FlushTxFifo+0x38>

  return HAL_OK;
 810b262:	2300      	movs	r3, #0
}
 810b264:	4618      	mov	r0, r3
 810b266:	3714      	adds	r7, #20
 810b268:	46bd      	mov	sp, r7
 810b26a:	f85d 7b04 	ldr.w	r7, [sp], #4
 810b26e:	4770      	bx	lr

0810b270 <USB_FlushRxFifo>:
  * @brief  USB_FlushRxFifo  Flush Rx FIFO
  * @param  USBx  Selected device
  * @retval HAL status
  */
HAL_StatusTypeDef USB_FlushRxFifo(USB_OTG_GlobalTypeDef *USBx)
{
 810b270:	b480      	push	{r7}
 810b272:	b085      	sub	sp, #20
 810b274:	af00      	add	r7, sp, #0
 810b276:	6078      	str	r0, [r7, #4]
  __IO uint32_t count = 0U;
 810b278:	2300      	movs	r3, #0
 810b27a:	60fb      	str	r3, [r7, #12]

  /* Wait for AHB master IDLE state. */
  do
  {
    count++;
 810b27c:	68fb      	ldr	r3, [r7, #12]
 810b27e:	3301      	adds	r3, #1
 810b280:	60fb      	str	r3, [r7, #12]

    if (count > HAL_USB_TIMEOUT)
 810b282:	68fb      	ldr	r3, [r7, #12]
 810b284:	f1b3 6f70 	cmp.w	r3, #251658240	; 0xf000000
 810b288:	d901      	bls.n	810b28e <USB_FlushRxFifo+0x1e>
    {
      return HAL_TIMEOUT;
 810b28a:	2303      	movs	r3, #3
 810b28c:	e018      	b.n	810b2c0 <USB_FlushRxFifo+0x50>
    }
  } while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_AHBIDL) == 0U);
 810b28e:	687b      	ldr	r3, [r7, #4]
 810b290:	691b      	ldr	r3, [r3, #16]
 810b292:	2b00      	cmp	r3, #0
 810b294:	daf2      	bge.n	810b27c <USB_FlushRxFifo+0xc>

  /* Flush RX Fifo */
  count = 0U;
 810b296:	2300      	movs	r3, #0
 810b298:	60fb      	str	r3, [r7, #12]
  USBx->GRSTCTL = USB_OTG_GRSTCTL_RXFFLSH;
 810b29a:	687b      	ldr	r3, [r7, #4]
 810b29c:	2210      	movs	r2, #16
 810b29e:	611a      	str	r2, [r3, #16]

  do
  {
    count++;
 810b2a0:	68fb      	ldr	r3, [r7, #12]
 810b2a2:	3301      	adds	r3, #1
 810b2a4:	60fb      	str	r3, [r7, #12]

    if (count > HAL_USB_TIMEOUT)
 810b2a6:	68fb      	ldr	r3, [r7, #12]
 810b2a8:	f1b3 6f70 	cmp.w	r3, #251658240	; 0xf000000
 810b2ac:	d901      	bls.n	810b2b2 <USB_FlushRxFifo+0x42>
    {
      return HAL_TIMEOUT;
 810b2ae:	2303      	movs	r3, #3
 810b2b0:	e006      	b.n	810b2c0 <USB_FlushRxFifo+0x50>
    }
  } while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_RXFFLSH) == USB_OTG_GRSTCTL_RXFFLSH);
 810b2b2:	687b      	ldr	r3, [r7, #4]
 810b2b4:	691b      	ldr	r3, [r3, #16]
 810b2b6:	f003 0310 	and.w	r3, r3, #16
 810b2ba:	2b10      	cmp	r3, #16
 810b2bc:	d0f0      	beq.n	810b2a0 <USB_FlushRxFifo+0x30>

  return HAL_OK;
 810b2be:	2300      	movs	r3, #0
}
 810b2c0:	4618      	mov	r0, r3
 810b2c2:	3714      	adds	r7, #20
 810b2c4:	46bd      	mov	sp, r7
 810b2c6:	f85d 7b04 	ldr.w	r7, [sp], #4
 810b2ca:	4770      	bx	lr

0810b2cc <USB_SetDevSpeed>:
  *            @arg USB_OTG_SPEED_HIGH_IN_FULL: High speed core in Full Speed mode
  *            @arg USB_OTG_SPEED_FULL: Full speed mode
  * @retval  Hal status
  */
HAL_StatusTypeDef USB_SetDevSpeed(const USB_OTG_GlobalTypeDef *USBx, uint8_t speed)
{
 810b2cc:	b480      	push	{r7}
 810b2ce:	b085      	sub	sp, #20
 810b2d0:	af00      	add	r7, sp, #0
 810b2d2:	6078      	str	r0, [r7, #4]
 810b2d4:	460b      	mov	r3, r1
 810b2d6:	70fb      	strb	r3, [r7, #3]
  uint32_t USBx_BASE = (uint32_t)USBx;
 810b2d8:	687b      	ldr	r3, [r7, #4]
 810b2da:	60fb      	str	r3, [r7, #12]

  USBx_DEVICE->DCFG |= speed;
 810b2dc:	68fb      	ldr	r3, [r7, #12]
 810b2de:	f503 6300 	add.w	r3, r3, #2048	; 0x800
 810b2e2:	681a      	ldr	r2, [r3, #0]
 810b2e4:	78fb      	ldrb	r3, [r7, #3]
 810b2e6:	68f9      	ldr	r1, [r7, #12]
 810b2e8:	f501 6100 	add.w	r1, r1, #2048	; 0x800
 810b2ec:	4313      	orrs	r3, r2
 810b2ee:	600b      	str	r3, [r1, #0]
  return HAL_OK;
 810b2f0:	2300      	movs	r3, #0
}
 810b2f2:	4618      	mov	r0, r3
 810b2f4:	3714      	adds	r7, #20
 810b2f6:	46bd      	mov	sp, r7
 810b2f8:	f85d 7b04 	ldr.w	r7, [sp], #4
 810b2fc:	4770      	bx	lr

0810b2fe <USB_GetDevSpeed>:
  *          This parameter can be one of these values:
  *            @arg USBD_HS_SPEED: High speed mode
  *            @arg USBD_FS_SPEED: Full speed mode
  */
uint8_t USB_GetDevSpeed(const USB_OTG_GlobalTypeDef *USBx)
{
 810b2fe:	b480      	push	{r7}
 810b300:	b087      	sub	sp, #28
 810b302:	af00      	add	r7, sp, #0
 810b304:	6078      	str	r0, [r7, #4]
  uint32_t USBx_BASE = (uint32_t)USBx;
 810b306:	687b      	ldr	r3, [r7, #4]
 810b308:	613b      	str	r3, [r7, #16]
  uint8_t speed;
  uint32_t DevEnumSpeed = USBx_DEVICE->DSTS & USB_OTG_DSTS_ENUMSPD;
 810b30a:	693b      	ldr	r3, [r7, #16]
 810b30c:	f503 6300 	add.w	r3, r3, #2048	; 0x800
 810b310:	689b      	ldr	r3, [r3, #8]
 810b312:	f003 0306 	and.w	r3, r3, #6
 810b316:	60fb      	str	r3, [r7, #12]

  if (DevEnumSpeed == DSTS_ENUMSPD_HS_PHY_30MHZ_OR_60MHZ)
 810b318:	68fb      	ldr	r3, [r7, #12]
 810b31a:	2b00      	cmp	r3, #0
 810b31c:	d102      	bne.n	810b324 <USB_GetDevSpeed+0x26>
  {
    speed = USBD_HS_SPEED;
 810b31e:	2300      	movs	r3, #0
 810b320:	75fb      	strb	r3, [r7, #23]
 810b322:	e00a      	b.n	810b33a <USB_GetDevSpeed+0x3c>
  }
  else if ((DevEnumSpeed == DSTS_ENUMSPD_FS_PHY_30MHZ_OR_60MHZ) ||
 810b324:	68fb      	ldr	r3, [r7, #12]
 810b326:	2b02      	cmp	r3, #2
 810b328:	d002      	beq.n	810b330 <USB_GetDevSpeed+0x32>
 810b32a:	68fb      	ldr	r3, [r7, #12]
 810b32c:	2b06      	cmp	r3, #6
 810b32e:	d102      	bne.n	810b336 <USB_GetDevSpeed+0x38>
           (DevEnumSpeed == DSTS_ENUMSPD_FS_PHY_48MHZ))
  {
    speed = USBD_FS_SPEED;
 810b330:	2302      	movs	r3, #2
 810b332:	75fb      	strb	r3, [r7, #23]
 810b334:	e001      	b.n	810b33a <USB_GetDevSpeed+0x3c>
  }
  else
  {
    speed = 0xFU;
 810b336:	230f      	movs	r3, #15
 810b338:	75fb      	strb	r3, [r7, #23]
  }

  return speed;
 810b33a:	7dfb      	ldrb	r3, [r7, #23]
}
 810b33c:	4618      	mov	r0, r3
 810b33e:	371c      	adds	r7, #28
 810b340:	46bd      	mov	sp, r7
 810b342:	f85d 7b04 	ldr.w	r7, [sp], #4
 810b346:	4770      	bx	lr

0810b348 <USB_ActivateEndpoint>:
  * @param  USBx  Selected device
  * @param  ep pointer to endpoint structure
  * @retval HAL status
  */
HAL_StatusTypeDef USB_ActivateEndpoint(const USB_OTG_GlobalTypeDef *USBx, const USB_OTG_EPTypeDef *ep)
{
 810b348:	b480      	push	{r7}
 810b34a:	b085      	sub	sp, #20
 810b34c:	af00      	add	r7, sp, #0
 810b34e:	6078      	str	r0, [r7, #4]
 810b350:	6039      	str	r1, [r7, #0]
  uint32_t USBx_BASE = (uint32_t)USBx;
 810b352:	687b      	ldr	r3, [r7, #4]
 810b354:	60fb      	str	r3, [r7, #12]
  uint32_t epnum = (uint32_t)ep->num;
 810b356:	683b      	ldr	r3, [r7, #0]
 810b358:	781b      	ldrb	r3, [r3, #0]
 810b35a:	60bb      	str	r3, [r7, #8]

  if (ep->is_in == 1U)
 810b35c:	683b      	ldr	r3, [r7, #0]
 810b35e:	785b      	ldrb	r3, [r3, #1]
 810b360:	2b01      	cmp	r3, #1
 810b362:	d13a      	bne.n	810b3da <USB_ActivateEndpoint+0x92>
  {
    USBx_DEVICE->DAINTMSK |= USB_OTG_DAINTMSK_IEPM & (uint32_t)(1UL << (ep->num & EP_ADDR_MSK));
 810b364:	68fb      	ldr	r3, [r7, #12]
 810b366:	f503 6300 	add.w	r3, r3, #2048	; 0x800
 810b36a:	69da      	ldr	r2, [r3, #28]
 810b36c:	683b      	ldr	r3, [r7, #0]
 810b36e:	781b      	ldrb	r3, [r3, #0]
 810b370:	f003 030f 	and.w	r3, r3, #15
 810b374:	2101      	movs	r1, #1
 810b376:	fa01 f303 	lsl.w	r3, r1, r3
 810b37a:	b29b      	uxth	r3, r3
 810b37c:	68f9      	ldr	r1, [r7, #12]
 810b37e:	f501 6100 	add.w	r1, r1, #2048	; 0x800
 810b382:	4313      	orrs	r3, r2
 810b384:	61cb      	str	r3, [r1, #28]

    if ((USBx_INEP(epnum)->DIEPCTL & USB_OTG_DIEPCTL_USBAEP) == 0U)
 810b386:	68bb      	ldr	r3, [r7, #8]
 810b388:	015a      	lsls	r2, r3, #5
 810b38a:	68fb      	ldr	r3, [r7, #12]
 810b38c:	4413      	add	r3, r2
 810b38e:	f503 6310 	add.w	r3, r3, #2304	; 0x900
 810b392:	681b      	ldr	r3, [r3, #0]
 810b394:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
 810b398:	2b00      	cmp	r3, #0
 810b39a:	d155      	bne.n	810b448 <USB_ActivateEndpoint+0x100>
    {
      USBx_INEP(epnum)->DIEPCTL |= (ep->maxpacket & USB_OTG_DIEPCTL_MPSIZ) |
 810b39c:	68bb      	ldr	r3, [r7, #8]
 810b39e:	015a      	lsls	r2, r3, #5
 810b3a0:	68fb      	ldr	r3, [r7, #12]
 810b3a2:	4413      	add	r3, r2
 810b3a4:	f503 6310 	add.w	r3, r3, #2304	; 0x900
 810b3a8:	681a      	ldr	r2, [r3, #0]
 810b3aa:	683b      	ldr	r3, [r7, #0]
 810b3ac:	689b      	ldr	r3, [r3, #8]
 810b3ae:	f3c3 010a 	ubfx	r1, r3, #0, #11
                                   ((uint32_t)ep->type << 18) | (epnum << 22) |
 810b3b2:	683b      	ldr	r3, [r7, #0]
 810b3b4:	791b      	ldrb	r3, [r3, #4]
 810b3b6:	049b      	lsls	r3, r3, #18
      USBx_INEP(epnum)->DIEPCTL |= (ep->maxpacket & USB_OTG_DIEPCTL_MPSIZ) |
 810b3b8:	4319      	orrs	r1, r3
                                   ((uint32_t)ep->type << 18) | (epnum << 22) |
 810b3ba:	68bb      	ldr	r3, [r7, #8]
 810b3bc:	059b      	lsls	r3, r3, #22
 810b3be:	430b      	orrs	r3, r1
      USBx_INEP(epnum)->DIEPCTL |= (ep->maxpacket & USB_OTG_DIEPCTL_MPSIZ) |
 810b3c0:	4313      	orrs	r3, r2
 810b3c2:	68ba      	ldr	r2, [r7, #8]
 810b3c4:	0151      	lsls	r1, r2, #5
 810b3c6:	68fa      	ldr	r2, [r7, #12]
 810b3c8:	440a      	add	r2, r1
 810b3ca:	f502 6210 	add.w	r2, r2, #2304	; 0x900
 810b3ce:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 810b3d2:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 810b3d6:	6013      	str	r3, [r2, #0]
 810b3d8:	e036      	b.n	810b448 <USB_ActivateEndpoint+0x100>
                                   USB_OTG_DIEPCTL_USBAEP;
    }
  }
  else
  {
    USBx_DEVICE->DAINTMSK |= USB_OTG_DAINTMSK_OEPM & ((uint32_t)(1UL << (ep->num & EP_ADDR_MSK)) << 16);
 810b3da:	68fb      	ldr	r3, [r7, #12]
 810b3dc:	f503 6300 	add.w	r3, r3, #2048	; 0x800
 810b3e0:	69da      	ldr	r2, [r3, #28]
 810b3e2:	683b      	ldr	r3, [r7, #0]
 810b3e4:	781b      	ldrb	r3, [r3, #0]
 810b3e6:	f003 030f 	and.w	r3, r3, #15
 810b3ea:	2101      	movs	r1, #1
 810b3ec:	fa01 f303 	lsl.w	r3, r1, r3
 810b3f0:	041b      	lsls	r3, r3, #16
 810b3f2:	68f9      	ldr	r1, [r7, #12]
 810b3f4:	f501 6100 	add.w	r1, r1, #2048	; 0x800
 810b3f8:	4313      	orrs	r3, r2
 810b3fa:	61cb      	str	r3, [r1, #28]

    if (((USBx_OUTEP(epnum)->DOEPCTL) & USB_OTG_DOEPCTL_USBAEP) == 0U)
 810b3fc:	68bb      	ldr	r3, [r7, #8]
 810b3fe:	015a      	lsls	r2, r3, #5
 810b400:	68fb      	ldr	r3, [r7, #12]
 810b402:	4413      	add	r3, r2
 810b404:	f503 6330 	add.w	r3, r3, #2816	; 0xb00
 810b408:	681b      	ldr	r3, [r3, #0]
 810b40a:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
 810b40e:	2b00      	cmp	r3, #0
 810b410:	d11a      	bne.n	810b448 <USB_ActivateEndpoint+0x100>
    {
      USBx_OUTEP(epnum)->DOEPCTL |= (ep->maxpacket & USB_OTG_DOEPCTL_MPSIZ) |
 810b412:	68bb      	ldr	r3, [r7, #8]
 810b414:	015a      	lsls	r2, r3, #5
 810b416:	68fb      	ldr	r3, [r7, #12]
 810b418:	4413      	add	r3, r2
 810b41a:	f503 6330 	add.w	r3, r3, #2816	; 0xb00
 810b41e:	681a      	ldr	r2, [r3, #0]
 810b420:	683b      	ldr	r3, [r7, #0]
 810b422:	689b      	ldr	r3, [r3, #8]
 810b424:	f3c3 010a 	ubfx	r1, r3, #0, #11
                                    ((uint32_t)ep->type << 18) |
 810b428:	683b      	ldr	r3, [r7, #0]
 810b42a:	791b      	ldrb	r3, [r3, #4]
 810b42c:	049b      	lsls	r3, r3, #18
      USBx_OUTEP(epnum)->DOEPCTL |= (ep->maxpacket & USB_OTG_DOEPCTL_MPSIZ) |
 810b42e:	430b      	orrs	r3, r1
 810b430:	4313      	orrs	r3, r2
 810b432:	68ba      	ldr	r2, [r7, #8]
 810b434:	0151      	lsls	r1, r2, #5
 810b436:	68fa      	ldr	r2, [r7, #12]
 810b438:	440a      	add	r2, r1
 810b43a:	f502 6230 	add.w	r2, r2, #2816	; 0xb00
 810b43e:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 810b442:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 810b446:	6013      	str	r3, [r2, #0]
                                    USB_OTG_DIEPCTL_SD0PID_SEVNFRM |
                                    USB_OTG_DOEPCTL_USBAEP;
    }
  }
  return HAL_OK;
 810b448:	2300      	movs	r3, #0
}
 810b44a:	4618      	mov	r0, r3
 810b44c:	3714      	adds	r7, #20
 810b44e:	46bd      	mov	sp, r7
 810b450:	f85d 7b04 	ldr.w	r7, [sp], #4
 810b454:	4770      	bx	lr
	...

0810b458 <USB_DeactivateEndpoint>:
  * @param  USBx  Selected device
  * @param  ep pointer to endpoint structure
  * @retval HAL status
  */
HAL_StatusTypeDef USB_DeactivateEndpoint(const USB_OTG_GlobalTypeDef *USBx, const USB_OTG_EPTypeDef *ep)
{
 810b458:	b480      	push	{r7}
 810b45a:	b085      	sub	sp, #20
 810b45c:	af00      	add	r7, sp, #0
 810b45e:	6078      	str	r0, [r7, #4]
 810b460:	6039      	str	r1, [r7, #0]
  uint32_t USBx_BASE = (uint32_t)USBx;
 810b462:	687b      	ldr	r3, [r7, #4]
 810b464:	60fb      	str	r3, [r7, #12]
  uint32_t epnum = (uint32_t)ep->num;
 810b466:	683b      	ldr	r3, [r7, #0]
 810b468:	781b      	ldrb	r3, [r3, #0]
 810b46a:	60bb      	str	r3, [r7, #8]

  /* Read DEPCTLn register */
  if (ep->is_in == 1U)
 810b46c:	683b      	ldr	r3, [r7, #0]
 810b46e:	785b      	ldrb	r3, [r3, #1]
 810b470:	2b01      	cmp	r3, #1
 810b472:	d161      	bne.n	810b538 <USB_DeactivateEndpoint+0xe0>
  {
    if ((USBx_INEP(epnum)->DIEPCTL & USB_OTG_DIEPCTL_EPENA) == USB_OTG_DIEPCTL_EPENA)
 810b474:	68bb      	ldr	r3, [r7, #8]
 810b476:	015a      	lsls	r2, r3, #5
 810b478:	68fb      	ldr	r3, [r7, #12]
 810b47a:	4413      	add	r3, r2
 810b47c:	f503 6310 	add.w	r3, r3, #2304	; 0x900
 810b480:	681b      	ldr	r3, [r3, #0]
 810b482:	f003 4300 	and.w	r3, r3, #2147483648	; 0x80000000
 810b486:	f1b3 4f00 	cmp.w	r3, #2147483648	; 0x80000000
 810b48a:	d11f      	bne.n	810b4cc <USB_DeactivateEndpoint+0x74>
    {
      USBx_INEP(epnum)->DIEPCTL |= USB_OTG_DIEPCTL_SNAK;
 810b48c:	68bb      	ldr	r3, [r7, #8]
 810b48e:	015a      	lsls	r2, r3, #5
 810b490:	68fb      	ldr	r3, [r7, #12]
 810b492:	4413      	add	r3, r2
 810b494:	f503 6310 	add.w	r3, r3, #2304	; 0x900
 810b498:	681b      	ldr	r3, [r3, #0]
 810b49a:	68ba      	ldr	r2, [r7, #8]
 810b49c:	0151      	lsls	r1, r2, #5
 810b49e:	68fa      	ldr	r2, [r7, #12]
 810b4a0:	440a      	add	r2, r1
 810b4a2:	f502 6210 	add.w	r2, r2, #2304	; 0x900
 810b4a6:	f043 6300 	orr.w	r3, r3, #134217728	; 0x8000000
 810b4aa:	6013      	str	r3, [r2, #0]
      USBx_INEP(epnum)->DIEPCTL |= USB_OTG_DIEPCTL_EPDIS;
 810b4ac:	68bb      	ldr	r3, [r7, #8]
 810b4ae:	015a      	lsls	r2, r3, #5
 810b4b0:	68fb      	ldr	r3, [r7, #12]
 810b4b2:	4413      	add	r3, r2
 810b4b4:	f503 6310 	add.w	r3, r3, #2304	; 0x900
 810b4b8:	681b      	ldr	r3, [r3, #0]
 810b4ba:	68ba      	ldr	r2, [r7, #8]
 810b4bc:	0151      	lsls	r1, r2, #5
 810b4be:	68fa      	ldr	r2, [r7, #12]
 810b4c0:	440a      	add	r2, r1
 810b4c2:	f502 6210 	add.w	r2, r2, #2304	; 0x900
 810b4c6:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
 810b4ca:	6013      	str	r3, [r2, #0]
    }

    USBx_DEVICE->DEACHMSK &= ~(USB_OTG_DAINTMSK_IEPM & (uint32_t)(1UL << (ep->num & EP_ADDR_MSK)));
 810b4cc:	68fb      	ldr	r3, [r7, #12]
 810b4ce:	f503 6300 	add.w	r3, r3, #2048	; 0x800
 810b4d2:	6bda      	ldr	r2, [r3, #60]	; 0x3c
 810b4d4:	683b      	ldr	r3, [r7, #0]
 810b4d6:	781b      	ldrb	r3, [r3, #0]
 810b4d8:	f003 030f 	and.w	r3, r3, #15
 810b4dc:	2101      	movs	r1, #1
 810b4de:	fa01 f303 	lsl.w	r3, r1, r3
 810b4e2:	b29b      	uxth	r3, r3
 810b4e4:	43db      	mvns	r3, r3
 810b4e6:	68f9      	ldr	r1, [r7, #12]
 810b4e8:	f501 6100 	add.w	r1, r1, #2048	; 0x800
 810b4ec:	4013      	ands	r3, r2
 810b4ee:	63cb      	str	r3, [r1, #60]	; 0x3c
    USBx_DEVICE->DAINTMSK &= ~(USB_OTG_DAINTMSK_IEPM & (uint32_t)(1UL << (ep->num & EP_ADDR_MSK)));
 810b4f0:	68fb      	ldr	r3, [r7, #12]
 810b4f2:	f503 6300 	add.w	r3, r3, #2048	; 0x800
 810b4f6:	69da      	ldr	r2, [r3, #28]
 810b4f8:	683b      	ldr	r3, [r7, #0]
 810b4fa:	781b      	ldrb	r3, [r3, #0]
 810b4fc:	f003 030f 	and.w	r3, r3, #15
 810b500:	2101      	movs	r1, #1
 810b502:	fa01 f303 	lsl.w	r3, r1, r3
 810b506:	b29b      	uxth	r3, r3
 810b508:	43db      	mvns	r3, r3
 810b50a:	68f9      	ldr	r1, [r7, #12]
 810b50c:	f501 6100 	add.w	r1, r1, #2048	; 0x800
 810b510:	4013      	ands	r3, r2
 810b512:	61cb      	str	r3, [r1, #28]
    USBx_INEP(epnum)->DIEPCTL &= ~(USB_OTG_DIEPCTL_USBAEP |
 810b514:	68bb      	ldr	r3, [r7, #8]
 810b516:	015a      	lsls	r2, r3, #5
 810b518:	68fb      	ldr	r3, [r7, #12]
 810b51a:	4413      	add	r3, r2
 810b51c:	f503 6310 	add.w	r3, r3, #2304	; 0x900
 810b520:	681a      	ldr	r2, [r3, #0]
 810b522:	68bb      	ldr	r3, [r7, #8]
 810b524:	0159      	lsls	r1, r3, #5
 810b526:	68fb      	ldr	r3, [r7, #12]
 810b528:	440b      	add	r3, r1
 810b52a:	f503 6310 	add.w	r3, r3, #2304	; 0x900
 810b52e:	4619      	mov	r1, r3
 810b530:	4b35      	ldr	r3, [pc, #212]	; (810b608 <USB_DeactivateEndpoint+0x1b0>)
 810b532:	4013      	ands	r3, r2
 810b534:	600b      	str	r3, [r1, #0]
 810b536:	e060      	b.n	810b5fa <USB_DeactivateEndpoint+0x1a2>
                                   USB_OTG_DIEPCTL_SD0PID_SEVNFRM |
                                   USB_OTG_DIEPCTL_EPTYP);
  }
  else
  {
    if ((USBx_OUTEP(epnum)->DOEPCTL & USB_OTG_DOEPCTL_EPENA) == USB_OTG_DOEPCTL_EPENA)
 810b538:	68bb      	ldr	r3, [r7, #8]
 810b53a:	015a      	lsls	r2, r3, #5
 810b53c:	68fb      	ldr	r3, [r7, #12]
 810b53e:	4413      	add	r3, r2
 810b540:	f503 6330 	add.w	r3, r3, #2816	; 0xb00
 810b544:	681b      	ldr	r3, [r3, #0]
 810b546:	f003 4300 	and.w	r3, r3, #2147483648	; 0x80000000
 810b54a:	f1b3 4f00 	cmp.w	r3, #2147483648	; 0x80000000
 810b54e:	d11f      	bne.n	810b590 <USB_DeactivateEndpoint+0x138>
    {
      USBx_OUTEP(epnum)->DOEPCTL |= USB_OTG_DOEPCTL_SNAK;
 810b550:	68bb      	ldr	r3, [r7, #8]
 810b552:	015a      	lsls	r2, r3, #5
 810b554:	68fb      	ldr	r3, [r7, #12]
 810b556:	4413      	add	r3, r2
 810b558:	f503 6330 	add.w	r3, r3, #2816	; 0xb00
 810b55c:	681b      	ldr	r3, [r3, #0]
 810b55e:	68ba      	ldr	r2, [r7, #8]
 810b560:	0151      	lsls	r1, r2, #5
 810b562:	68fa      	ldr	r2, [r7, #12]
 810b564:	440a      	add	r2, r1
 810b566:	f502 6230 	add.w	r2, r2, #2816	; 0xb00
 810b56a:	f043 6300 	orr.w	r3, r3, #134217728	; 0x8000000
 810b56e:	6013      	str	r3, [r2, #0]
      USBx_OUTEP(epnum)->DOEPCTL |= USB_OTG_DOEPCTL_EPDIS;
 810b570:	68bb      	ldr	r3, [r7, #8]
 810b572:	015a      	lsls	r2, r3, #5
 810b574:	68fb      	ldr	r3, [r7, #12]
 810b576:	4413      	add	r3, r2
 810b578:	f503 6330 	add.w	r3, r3, #2816	; 0xb00
 810b57c:	681b      	ldr	r3, [r3, #0]
 810b57e:	68ba      	ldr	r2, [r7, #8]
 810b580:	0151      	lsls	r1, r2, #5
 810b582:	68fa      	ldr	r2, [r7, #12]
 810b584:	440a      	add	r2, r1
 810b586:	f502 6230 	add.w	r2, r2, #2816	; 0xb00
 810b58a:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
 810b58e:	6013      	str	r3, [r2, #0]
    }

    USBx_DEVICE->DEACHMSK &= ~(USB_OTG_DAINTMSK_OEPM & ((uint32_t)(1UL << (ep->num & EP_ADDR_MSK)) << 16));
 810b590:	68fb      	ldr	r3, [r7, #12]
 810b592:	f503 6300 	add.w	r3, r3, #2048	; 0x800
 810b596:	6bda      	ldr	r2, [r3, #60]	; 0x3c
 810b598:	683b      	ldr	r3, [r7, #0]
 810b59a:	781b      	ldrb	r3, [r3, #0]
 810b59c:	f003 030f 	and.w	r3, r3, #15
 810b5a0:	2101      	movs	r1, #1
 810b5a2:	fa01 f303 	lsl.w	r3, r1, r3
 810b5a6:	041b      	lsls	r3, r3, #16
 810b5a8:	43db      	mvns	r3, r3
 810b5aa:	68f9      	ldr	r1, [r7, #12]
 810b5ac:	f501 6100 	add.w	r1, r1, #2048	; 0x800
 810b5b0:	4013      	ands	r3, r2
 810b5b2:	63cb      	str	r3, [r1, #60]	; 0x3c
    USBx_DEVICE->DAINTMSK &= ~(USB_OTG_DAINTMSK_OEPM & ((uint32_t)(1UL << (ep->num & EP_ADDR_MSK)) << 16));
 810b5b4:	68fb      	ldr	r3, [r7, #12]
 810b5b6:	f503 6300 	add.w	r3, r3, #2048	; 0x800
 810b5ba:	69da      	ldr	r2, [r3, #28]
 810b5bc:	683b      	ldr	r3, [r7, #0]
 810b5be:	781b      	ldrb	r3, [r3, #0]
 810b5c0:	f003 030f 	and.w	r3, r3, #15
 810b5c4:	2101      	movs	r1, #1
 810b5c6:	fa01 f303 	lsl.w	r3, r1, r3
 810b5ca:	041b      	lsls	r3, r3, #16
 810b5cc:	43db      	mvns	r3, r3
 810b5ce:	68f9      	ldr	r1, [r7, #12]
 810b5d0:	f501 6100 	add.w	r1, r1, #2048	; 0x800
 810b5d4:	4013      	ands	r3, r2
 810b5d6:	61cb      	str	r3, [r1, #28]
    USBx_OUTEP(epnum)->DOEPCTL &= ~(USB_OTG_DOEPCTL_USBAEP |
 810b5d8:	68bb      	ldr	r3, [r7, #8]
 810b5da:	015a      	lsls	r2, r3, #5
 810b5dc:	68fb      	ldr	r3, [r7, #12]
 810b5de:	4413      	add	r3, r2
 810b5e0:	f503 6330 	add.w	r3, r3, #2816	; 0xb00
 810b5e4:	681a      	ldr	r2, [r3, #0]
 810b5e6:	68bb      	ldr	r3, [r7, #8]
 810b5e8:	0159      	lsls	r1, r3, #5
 810b5ea:	68fb      	ldr	r3, [r7, #12]
 810b5ec:	440b      	add	r3, r1
 810b5ee:	f503 6330 	add.w	r3, r3, #2816	; 0xb00
 810b5f2:	4619      	mov	r1, r3
 810b5f4:	4b05      	ldr	r3, [pc, #20]	; (810b60c <USB_DeactivateEndpoint+0x1b4>)
 810b5f6:	4013      	ands	r3, r2
 810b5f8:	600b      	str	r3, [r1, #0]
                                    USB_OTG_DOEPCTL_MPSIZ |
                                    USB_OTG_DOEPCTL_SD0PID_SEVNFRM |
                                    USB_OTG_DOEPCTL_EPTYP);
  }

  return HAL_OK;
 810b5fa:	2300      	movs	r3, #0
}
 810b5fc:	4618      	mov	r0, r3
 810b5fe:	3714      	adds	r7, #20
 810b600:	46bd      	mov	sp, r7
 810b602:	f85d 7b04 	ldr.w	r7, [sp], #4
 810b606:	4770      	bx	lr
 810b608:	ec337800 	.word	0xec337800
 810b60c:	eff37800 	.word	0xeff37800

0810b610 <USB_EPStartXfer>:
  *           0 : DMA feature not used
  *           1 : DMA feature used
  * @retval HAL status
  */
HAL_StatusTypeDef USB_EPStartXfer(USB_OTG_GlobalTypeDef *USBx, USB_OTG_EPTypeDef *ep, uint8_t dma)
{
 810b610:	b580      	push	{r7, lr}
 810b612:	b08a      	sub	sp, #40	; 0x28
 810b614:	af02      	add	r7, sp, #8
 810b616:	60f8      	str	r0, [r7, #12]
 810b618:	60b9      	str	r1, [r7, #8]
 810b61a:	4613      	mov	r3, r2
 810b61c:	71fb      	strb	r3, [r7, #7]
  uint32_t USBx_BASE = (uint32_t)USBx;
 810b61e:	68fb      	ldr	r3, [r7, #12]
 810b620:	61fb      	str	r3, [r7, #28]
  uint32_t epnum = (uint32_t)ep->num;
 810b622:	68bb      	ldr	r3, [r7, #8]
 810b624:	781b      	ldrb	r3, [r3, #0]
 810b626:	61bb      	str	r3, [r7, #24]
  uint16_t pktcnt;

  /* IN endpoint */
  if (ep->is_in == 1U)
 810b628:	68bb      	ldr	r3, [r7, #8]
 810b62a:	785b      	ldrb	r3, [r3, #1]
 810b62c:	2b01      	cmp	r3, #1
 810b62e:	f040 817a 	bne.w	810b926 <USB_EPStartXfer+0x316>
  {
    /* Zero Length Packet? */
    if (ep->xfer_len == 0U)
 810b632:	68bb      	ldr	r3, [r7, #8]
 810b634:	691b      	ldr	r3, [r3, #16]
 810b636:	2b00      	cmp	r3, #0
 810b638:	d132      	bne.n	810b6a0 <USB_EPStartXfer+0x90>
    {
      USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_PKTCNT);
 810b63a:	69bb      	ldr	r3, [r7, #24]
 810b63c:	015a      	lsls	r2, r3, #5
 810b63e:	69fb      	ldr	r3, [r7, #28]
 810b640:	4413      	add	r3, r2
 810b642:	f503 6310 	add.w	r3, r3, #2304	; 0x900
 810b646:	691b      	ldr	r3, [r3, #16]
 810b648:	69ba      	ldr	r2, [r7, #24]
 810b64a:	0151      	lsls	r1, r2, #5
 810b64c:	69fa      	ldr	r2, [r7, #28]
 810b64e:	440a      	add	r2, r1
 810b650:	f502 6210 	add.w	r2, r2, #2304	; 0x900
 810b654:	f023 53ff 	bic.w	r3, r3, #534773760	; 0x1fe00000
 810b658:	f423 13c0 	bic.w	r3, r3, #1572864	; 0x180000
 810b65c:	6113      	str	r3, [r2, #16]
      USBx_INEP(epnum)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_PKTCNT & (1U << 19));
 810b65e:	69bb      	ldr	r3, [r7, #24]
 810b660:	015a      	lsls	r2, r3, #5
 810b662:	69fb      	ldr	r3, [r7, #28]
 810b664:	4413      	add	r3, r2
 810b666:	f503 6310 	add.w	r3, r3, #2304	; 0x900
 810b66a:	691b      	ldr	r3, [r3, #16]
 810b66c:	69ba      	ldr	r2, [r7, #24]
 810b66e:	0151      	lsls	r1, r2, #5
 810b670:	69fa      	ldr	r2, [r7, #28]
 810b672:	440a      	add	r2, r1
 810b674:	f502 6210 	add.w	r2, r2, #2304	; 0x900
 810b678:	f443 2300 	orr.w	r3, r3, #524288	; 0x80000
 810b67c:	6113      	str	r3, [r2, #16]
      USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_XFRSIZ);
 810b67e:	69bb      	ldr	r3, [r7, #24]
 810b680:	015a      	lsls	r2, r3, #5
 810b682:	69fb      	ldr	r3, [r7, #28]
 810b684:	4413      	add	r3, r2
 810b686:	f503 6310 	add.w	r3, r3, #2304	; 0x900
 810b68a:	691b      	ldr	r3, [r3, #16]
 810b68c:	69ba      	ldr	r2, [r7, #24]
 810b68e:	0151      	lsls	r1, r2, #5
 810b690:	69fa      	ldr	r2, [r7, #28]
 810b692:	440a      	add	r2, r1
 810b694:	f502 6210 	add.w	r2, r2, #2304	; 0x900
 810b698:	0cdb      	lsrs	r3, r3, #19
 810b69a:	04db      	lsls	r3, r3, #19
 810b69c:	6113      	str	r3, [r2, #16]
 810b69e:	e092      	b.n	810b7c6 <USB_EPStartXfer+0x1b6>
      /* Program the transfer size and packet count
      * as follows: xfersize = N * maxpacket +
      * short_packet pktcnt = N + (short_packet
      * exist ? 1 : 0)
      */
      USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_XFRSIZ);
 810b6a0:	69bb      	ldr	r3, [r7, #24]
 810b6a2:	015a      	lsls	r2, r3, #5
 810b6a4:	69fb      	ldr	r3, [r7, #28]
 810b6a6:	4413      	add	r3, r2
 810b6a8:	f503 6310 	add.w	r3, r3, #2304	; 0x900
 810b6ac:	691b      	ldr	r3, [r3, #16]
 810b6ae:	69ba      	ldr	r2, [r7, #24]
 810b6b0:	0151      	lsls	r1, r2, #5
 810b6b2:	69fa      	ldr	r2, [r7, #28]
 810b6b4:	440a      	add	r2, r1
 810b6b6:	f502 6210 	add.w	r2, r2, #2304	; 0x900
 810b6ba:	0cdb      	lsrs	r3, r3, #19
 810b6bc:	04db      	lsls	r3, r3, #19
 810b6be:	6113      	str	r3, [r2, #16]
      USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_PKTCNT);
 810b6c0:	69bb      	ldr	r3, [r7, #24]
 810b6c2:	015a      	lsls	r2, r3, #5
 810b6c4:	69fb      	ldr	r3, [r7, #28]
 810b6c6:	4413      	add	r3, r2
 810b6c8:	f503 6310 	add.w	r3, r3, #2304	; 0x900
 810b6cc:	691b      	ldr	r3, [r3, #16]
 810b6ce:	69ba      	ldr	r2, [r7, #24]
 810b6d0:	0151      	lsls	r1, r2, #5
 810b6d2:	69fa      	ldr	r2, [r7, #28]
 810b6d4:	440a      	add	r2, r1
 810b6d6:	f502 6210 	add.w	r2, r2, #2304	; 0x900
 810b6da:	f023 53ff 	bic.w	r3, r3, #534773760	; 0x1fe00000
 810b6de:	f423 13c0 	bic.w	r3, r3, #1572864	; 0x180000
 810b6e2:	6113      	str	r3, [r2, #16]

      if (epnum == 0U)
 810b6e4:	69bb      	ldr	r3, [r7, #24]
 810b6e6:	2b00      	cmp	r3, #0
 810b6e8:	d11a      	bne.n	810b720 <USB_EPStartXfer+0x110>
      {
        if (ep->xfer_len > ep->maxpacket)
 810b6ea:	68bb      	ldr	r3, [r7, #8]
 810b6ec:	691a      	ldr	r2, [r3, #16]
 810b6ee:	68bb      	ldr	r3, [r7, #8]
 810b6f0:	689b      	ldr	r3, [r3, #8]
 810b6f2:	429a      	cmp	r2, r3
 810b6f4:	d903      	bls.n	810b6fe <USB_EPStartXfer+0xee>
        {
          ep->xfer_len = ep->maxpacket;
 810b6f6:	68bb      	ldr	r3, [r7, #8]
 810b6f8:	689a      	ldr	r2, [r3, #8]
 810b6fa:	68bb      	ldr	r3, [r7, #8]
 810b6fc:	611a      	str	r2, [r3, #16]
        }

        USBx_INEP(epnum)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_PKTCNT & (1U << 19));
 810b6fe:	69bb      	ldr	r3, [r7, #24]
 810b700:	015a      	lsls	r2, r3, #5
 810b702:	69fb      	ldr	r3, [r7, #28]
 810b704:	4413      	add	r3, r2
 810b706:	f503 6310 	add.w	r3, r3, #2304	; 0x900
 810b70a:	691b      	ldr	r3, [r3, #16]
 810b70c:	69ba      	ldr	r2, [r7, #24]
 810b70e:	0151      	lsls	r1, r2, #5
 810b710:	69fa      	ldr	r2, [r7, #28]
 810b712:	440a      	add	r2, r1
 810b714:	f502 6210 	add.w	r2, r2, #2304	; 0x900
 810b718:	f443 2300 	orr.w	r3, r3, #524288	; 0x80000
 810b71c:	6113      	str	r3, [r2, #16]
 810b71e:	e01b      	b.n	810b758 <USB_EPStartXfer+0x148>
      }
      else
      {
        USBx_INEP(epnum)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_PKTCNT &
 810b720:	69bb      	ldr	r3, [r7, #24]
 810b722:	015a      	lsls	r2, r3, #5
 810b724:	69fb      	ldr	r3, [r7, #28]
 810b726:	4413      	add	r3, r2
 810b728:	f503 6310 	add.w	r3, r3, #2304	; 0x900
 810b72c:	691a      	ldr	r2, [r3, #16]
                                       (((ep->xfer_len + ep->maxpacket - 1U) / ep->maxpacket) << 19));
 810b72e:	68bb      	ldr	r3, [r7, #8]
 810b730:	6919      	ldr	r1, [r3, #16]
 810b732:	68bb      	ldr	r3, [r7, #8]
 810b734:	689b      	ldr	r3, [r3, #8]
 810b736:	440b      	add	r3, r1
 810b738:	1e59      	subs	r1, r3, #1
 810b73a:	68bb      	ldr	r3, [r7, #8]
 810b73c:	689b      	ldr	r3, [r3, #8]
 810b73e:	fbb1 f3f3 	udiv	r3, r1, r3
 810b742:	04d9      	lsls	r1, r3, #19
        USBx_INEP(epnum)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_PKTCNT &
 810b744:	4ba2      	ldr	r3, [pc, #648]	; (810b9d0 <USB_EPStartXfer+0x3c0>)
 810b746:	400b      	ands	r3, r1
 810b748:	69b9      	ldr	r1, [r7, #24]
 810b74a:	0148      	lsls	r0, r1, #5
 810b74c:	69f9      	ldr	r1, [r7, #28]
 810b74e:	4401      	add	r1, r0
 810b750:	f501 6110 	add.w	r1, r1, #2304	; 0x900
 810b754:	4313      	orrs	r3, r2
 810b756:	610b      	str	r3, [r1, #16]
      }

      USBx_INEP(epnum)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_XFRSIZ & ep->xfer_len);
 810b758:	69bb      	ldr	r3, [r7, #24]
 810b75a:	015a      	lsls	r2, r3, #5
 810b75c:	69fb      	ldr	r3, [r7, #28]
 810b75e:	4413      	add	r3, r2
 810b760:	f503 6310 	add.w	r3, r3, #2304	; 0x900
 810b764:	691a      	ldr	r2, [r3, #16]
 810b766:	68bb      	ldr	r3, [r7, #8]
 810b768:	691b      	ldr	r3, [r3, #16]
 810b76a:	f3c3 0312 	ubfx	r3, r3, #0, #19
 810b76e:	69b9      	ldr	r1, [r7, #24]
 810b770:	0148      	lsls	r0, r1, #5
 810b772:	69f9      	ldr	r1, [r7, #28]
 810b774:	4401      	add	r1, r0
 810b776:	f501 6110 	add.w	r1, r1, #2304	; 0x900
 810b77a:	4313      	orrs	r3, r2
 810b77c:	610b      	str	r3, [r1, #16]

      if (ep->type == EP_TYPE_ISOC)
 810b77e:	68bb      	ldr	r3, [r7, #8]
 810b780:	791b      	ldrb	r3, [r3, #4]
 810b782:	2b01      	cmp	r3, #1
 810b784:	d11f      	bne.n	810b7c6 <USB_EPStartXfer+0x1b6>
      {
        USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_MULCNT);
 810b786:	69bb      	ldr	r3, [r7, #24]
 810b788:	015a      	lsls	r2, r3, #5
 810b78a:	69fb      	ldr	r3, [r7, #28]
 810b78c:	4413      	add	r3, r2
 810b78e:	f503 6310 	add.w	r3, r3, #2304	; 0x900
 810b792:	691b      	ldr	r3, [r3, #16]
 810b794:	69ba      	ldr	r2, [r7, #24]
 810b796:	0151      	lsls	r1, r2, #5
 810b798:	69fa      	ldr	r2, [r7, #28]
 810b79a:	440a      	add	r2, r1
 810b79c:	f502 6210 	add.w	r2, r2, #2304	; 0x900
 810b7a0:	f023 43c0 	bic.w	r3, r3, #1610612736	; 0x60000000
 810b7a4:	6113      	str	r3, [r2, #16]
        USBx_INEP(epnum)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_MULCNT & (1U << 29));
 810b7a6:	69bb      	ldr	r3, [r7, #24]
 810b7a8:	015a      	lsls	r2, r3, #5
 810b7aa:	69fb      	ldr	r3, [r7, #28]
 810b7ac:	4413      	add	r3, r2
 810b7ae:	f503 6310 	add.w	r3, r3, #2304	; 0x900
 810b7b2:	691b      	ldr	r3, [r3, #16]
 810b7b4:	69ba      	ldr	r2, [r7, #24]
 810b7b6:	0151      	lsls	r1, r2, #5
 810b7b8:	69fa      	ldr	r2, [r7, #28]
 810b7ba:	440a      	add	r2, r1
 810b7bc:	f502 6210 	add.w	r2, r2, #2304	; 0x900
 810b7c0:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
 810b7c4:	6113      	str	r3, [r2, #16]
      }
    }

    if (dma == 1U)
 810b7c6:	79fb      	ldrb	r3, [r7, #7]
 810b7c8:	2b01      	cmp	r3, #1
 810b7ca:	d14b      	bne.n	810b864 <USB_EPStartXfer+0x254>
    {
      if ((uint32_t)ep->dma_addr != 0U)
 810b7cc:	68bb      	ldr	r3, [r7, #8]
 810b7ce:	69db      	ldr	r3, [r3, #28]
 810b7d0:	2b00      	cmp	r3, #0
 810b7d2:	d009      	beq.n	810b7e8 <USB_EPStartXfer+0x1d8>
      {
        USBx_INEP(epnum)->DIEPDMA = (uint32_t)(ep->dma_addr);
 810b7d4:	69bb      	ldr	r3, [r7, #24]
 810b7d6:	015a      	lsls	r2, r3, #5
 810b7d8:	69fb      	ldr	r3, [r7, #28]
 810b7da:	4413      	add	r3, r2
 810b7dc:	f503 6310 	add.w	r3, r3, #2304	; 0x900
 810b7e0:	461a      	mov	r2, r3
 810b7e2:	68bb      	ldr	r3, [r7, #8]
 810b7e4:	69db      	ldr	r3, [r3, #28]
 810b7e6:	6153      	str	r3, [r2, #20]
      }

      if (ep->type == EP_TYPE_ISOC)
 810b7e8:	68bb      	ldr	r3, [r7, #8]
 810b7ea:	791b      	ldrb	r3, [r3, #4]
 810b7ec:	2b01      	cmp	r3, #1
 810b7ee:	d128      	bne.n	810b842 <USB_EPStartXfer+0x232>
      {
        if ((USBx_DEVICE->DSTS & (1U << 8)) == 0U)
 810b7f0:	69fb      	ldr	r3, [r7, #28]
 810b7f2:	f503 6300 	add.w	r3, r3, #2048	; 0x800
 810b7f6:	689b      	ldr	r3, [r3, #8]
 810b7f8:	f403 7380 	and.w	r3, r3, #256	; 0x100
 810b7fc:	2b00      	cmp	r3, #0
 810b7fe:	d110      	bne.n	810b822 <USB_EPStartXfer+0x212>
        {
          USBx_INEP(epnum)->DIEPCTL |= USB_OTG_DIEPCTL_SODDFRM;
 810b800:	69bb      	ldr	r3, [r7, #24]
 810b802:	015a      	lsls	r2, r3, #5
 810b804:	69fb      	ldr	r3, [r7, #28]
 810b806:	4413      	add	r3, r2
 810b808:	f503 6310 	add.w	r3, r3, #2304	; 0x900
 810b80c:	681b      	ldr	r3, [r3, #0]
 810b80e:	69ba      	ldr	r2, [r7, #24]
 810b810:	0151      	lsls	r1, r2, #5
 810b812:	69fa      	ldr	r2, [r7, #28]
 810b814:	440a      	add	r2, r1
 810b816:	f502 6210 	add.w	r2, r2, #2304	; 0x900
 810b81a:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
 810b81e:	6013      	str	r3, [r2, #0]
 810b820:	e00f      	b.n	810b842 <USB_EPStartXfer+0x232>
        }
        else
        {
          USBx_INEP(epnum)->DIEPCTL |= USB_OTG_DIEPCTL_SD0PID_SEVNFRM;
 810b822:	69bb      	ldr	r3, [r7, #24]
 810b824:	015a      	lsls	r2, r3, #5
 810b826:	69fb      	ldr	r3, [r7, #28]
 810b828:	4413      	add	r3, r2
 810b82a:	f503 6310 	add.w	r3, r3, #2304	; 0x900
 810b82e:	681b      	ldr	r3, [r3, #0]
 810b830:	69ba      	ldr	r2, [r7, #24]
 810b832:	0151      	lsls	r1, r2, #5
 810b834:	69fa      	ldr	r2, [r7, #28]
 810b836:	440a      	add	r2, r1
 810b838:	f502 6210 	add.w	r2, r2, #2304	; 0x900
 810b83c:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 810b840:	6013      	str	r3, [r2, #0]
        }
      }

      /* EP enable, IN data in FIFO */
      USBx_INEP(epnum)->DIEPCTL |= (USB_OTG_DIEPCTL_CNAK | USB_OTG_DIEPCTL_EPENA);
 810b842:	69bb      	ldr	r3, [r7, #24]
 810b844:	015a      	lsls	r2, r3, #5
 810b846:	69fb      	ldr	r3, [r7, #28]
 810b848:	4413      	add	r3, r2
 810b84a:	f503 6310 	add.w	r3, r3, #2304	; 0x900
 810b84e:	681b      	ldr	r3, [r3, #0]
 810b850:	69ba      	ldr	r2, [r7, #24]
 810b852:	0151      	lsls	r1, r2, #5
 810b854:	69fa      	ldr	r2, [r7, #28]
 810b856:	440a      	add	r2, r1
 810b858:	f502 6210 	add.w	r2, r2, #2304	; 0x900
 810b85c:	f043 4304 	orr.w	r3, r3, #2214592512	; 0x84000000
 810b860:	6013      	str	r3, [r2, #0]
 810b862:	e165      	b.n	810bb30 <USB_EPStartXfer+0x520>
    }
    else
    {
      /* EP enable, IN data in FIFO */
      USBx_INEP(epnum)->DIEPCTL |= (USB_OTG_DIEPCTL_CNAK | USB_OTG_DIEPCTL_EPENA);
 810b864:	69bb      	ldr	r3, [r7, #24]
 810b866:	015a      	lsls	r2, r3, #5
 810b868:	69fb      	ldr	r3, [r7, #28]
 810b86a:	4413      	add	r3, r2
 810b86c:	f503 6310 	add.w	r3, r3, #2304	; 0x900
 810b870:	681b      	ldr	r3, [r3, #0]
 810b872:	69ba      	ldr	r2, [r7, #24]
 810b874:	0151      	lsls	r1, r2, #5
 810b876:	69fa      	ldr	r2, [r7, #28]
 810b878:	440a      	add	r2, r1
 810b87a:	f502 6210 	add.w	r2, r2, #2304	; 0x900
 810b87e:	f043 4304 	orr.w	r3, r3, #2214592512	; 0x84000000
 810b882:	6013      	str	r3, [r2, #0]

      if (ep->type != EP_TYPE_ISOC)
 810b884:	68bb      	ldr	r3, [r7, #8]
 810b886:	791b      	ldrb	r3, [r3, #4]
 810b888:	2b01      	cmp	r3, #1
 810b88a:	d015      	beq.n	810b8b8 <USB_EPStartXfer+0x2a8>
      {
        /* Enable the Tx FIFO Empty Interrupt for this EP */
        if (ep->xfer_len > 0U)
 810b88c:	68bb      	ldr	r3, [r7, #8]
 810b88e:	691b      	ldr	r3, [r3, #16]
 810b890:	2b00      	cmp	r3, #0
 810b892:	f000 814d 	beq.w	810bb30 <USB_EPStartXfer+0x520>
        {
          USBx_DEVICE->DIEPEMPMSK |= 1UL << (ep->num & EP_ADDR_MSK);
 810b896:	69fb      	ldr	r3, [r7, #28]
 810b898:	f503 6300 	add.w	r3, r3, #2048	; 0x800
 810b89c:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 810b89e:	68bb      	ldr	r3, [r7, #8]
 810b8a0:	781b      	ldrb	r3, [r3, #0]
 810b8a2:	f003 030f 	and.w	r3, r3, #15
 810b8a6:	2101      	movs	r1, #1
 810b8a8:	fa01 f303 	lsl.w	r3, r1, r3
 810b8ac:	69f9      	ldr	r1, [r7, #28]
 810b8ae:	f501 6100 	add.w	r1, r1, #2048	; 0x800
 810b8b2:	4313      	orrs	r3, r2
 810b8b4:	634b      	str	r3, [r1, #52]	; 0x34
 810b8b6:	e13b      	b.n	810bb30 <USB_EPStartXfer+0x520>
        }
      }
      else
      {
        if ((USBx_DEVICE->DSTS & (1U << 8)) == 0U)
 810b8b8:	69fb      	ldr	r3, [r7, #28]
 810b8ba:	f503 6300 	add.w	r3, r3, #2048	; 0x800
 810b8be:	689b      	ldr	r3, [r3, #8]
 810b8c0:	f403 7380 	and.w	r3, r3, #256	; 0x100
 810b8c4:	2b00      	cmp	r3, #0
 810b8c6:	d110      	bne.n	810b8ea <USB_EPStartXfer+0x2da>
        {
          USBx_INEP(epnum)->DIEPCTL |= USB_OTG_DIEPCTL_SODDFRM;
 810b8c8:	69bb      	ldr	r3, [r7, #24]
 810b8ca:	015a      	lsls	r2, r3, #5
 810b8cc:	69fb      	ldr	r3, [r7, #28]
 810b8ce:	4413      	add	r3, r2
 810b8d0:	f503 6310 	add.w	r3, r3, #2304	; 0x900
 810b8d4:	681b      	ldr	r3, [r3, #0]
 810b8d6:	69ba      	ldr	r2, [r7, #24]
 810b8d8:	0151      	lsls	r1, r2, #5
 810b8da:	69fa      	ldr	r2, [r7, #28]
 810b8dc:	440a      	add	r2, r1
 810b8de:	f502 6210 	add.w	r2, r2, #2304	; 0x900
 810b8e2:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
 810b8e6:	6013      	str	r3, [r2, #0]
 810b8e8:	e00f      	b.n	810b90a <USB_EPStartXfer+0x2fa>
        }
        else
        {
          USBx_INEP(epnum)->DIEPCTL |= USB_OTG_DIEPCTL_SD0PID_SEVNFRM;
 810b8ea:	69bb      	ldr	r3, [r7, #24]
 810b8ec:	015a      	lsls	r2, r3, #5
 810b8ee:	69fb      	ldr	r3, [r7, #28]
 810b8f0:	4413      	add	r3, r2
 810b8f2:	f503 6310 	add.w	r3, r3, #2304	; 0x900
 810b8f6:	681b      	ldr	r3, [r3, #0]
 810b8f8:	69ba      	ldr	r2, [r7, #24]
 810b8fa:	0151      	lsls	r1, r2, #5
 810b8fc:	69fa      	ldr	r2, [r7, #28]
 810b8fe:	440a      	add	r2, r1
 810b900:	f502 6210 	add.w	r2, r2, #2304	; 0x900
 810b904:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 810b908:	6013      	str	r3, [r2, #0]
        }

        (void)USB_WritePacket(USBx, ep->xfer_buff, ep->num, (uint16_t)ep->xfer_len, dma);
 810b90a:	68bb      	ldr	r3, [r7, #8]
 810b90c:	68d9      	ldr	r1, [r3, #12]
 810b90e:	68bb      	ldr	r3, [r7, #8]
 810b910:	781a      	ldrb	r2, [r3, #0]
 810b912:	68bb      	ldr	r3, [r7, #8]
 810b914:	691b      	ldr	r3, [r3, #16]
 810b916:	b298      	uxth	r0, r3
 810b918:	79fb      	ldrb	r3, [r7, #7]
 810b91a:	9300      	str	r3, [sp, #0]
 810b91c:	4603      	mov	r3, r0
 810b91e:	68f8      	ldr	r0, [r7, #12]
 810b920:	f000 f9b8 	bl	810bc94 <USB_WritePacket>
 810b924:	e104      	b.n	810bb30 <USB_EPStartXfer+0x520>
  {
    /* Program the transfer size and packet count as follows:
    * pktcnt = N
    * xfersize = N * maxpacket
    */
    USBx_OUTEP(epnum)->DOEPTSIZ &= ~(USB_OTG_DOEPTSIZ_XFRSIZ);
 810b926:	69bb      	ldr	r3, [r7, #24]
 810b928:	015a      	lsls	r2, r3, #5
 810b92a:	69fb      	ldr	r3, [r7, #28]
 810b92c:	4413      	add	r3, r2
 810b92e:	f503 6330 	add.w	r3, r3, #2816	; 0xb00
 810b932:	691b      	ldr	r3, [r3, #16]
 810b934:	69ba      	ldr	r2, [r7, #24]
 810b936:	0151      	lsls	r1, r2, #5
 810b938:	69fa      	ldr	r2, [r7, #28]
 810b93a:	440a      	add	r2, r1
 810b93c:	f502 6230 	add.w	r2, r2, #2816	; 0xb00
 810b940:	0cdb      	lsrs	r3, r3, #19
 810b942:	04db      	lsls	r3, r3, #19
 810b944:	6113      	str	r3, [r2, #16]
    USBx_OUTEP(epnum)->DOEPTSIZ &= ~(USB_OTG_DOEPTSIZ_PKTCNT);
 810b946:	69bb      	ldr	r3, [r7, #24]
 810b948:	015a      	lsls	r2, r3, #5
 810b94a:	69fb      	ldr	r3, [r7, #28]
 810b94c:	4413      	add	r3, r2
 810b94e:	f503 6330 	add.w	r3, r3, #2816	; 0xb00
 810b952:	691b      	ldr	r3, [r3, #16]
 810b954:	69ba      	ldr	r2, [r7, #24]
 810b956:	0151      	lsls	r1, r2, #5
 810b958:	69fa      	ldr	r2, [r7, #28]
 810b95a:	440a      	add	r2, r1
 810b95c:	f502 6230 	add.w	r2, r2, #2816	; 0xb00
 810b960:	f023 53ff 	bic.w	r3, r3, #534773760	; 0x1fe00000
 810b964:	f423 13c0 	bic.w	r3, r3, #1572864	; 0x180000
 810b968:	6113      	str	r3, [r2, #16]

    if (epnum == 0U)
 810b96a:	69bb      	ldr	r3, [r7, #24]
 810b96c:	2b00      	cmp	r3, #0
 810b96e:	d131      	bne.n	810b9d4 <USB_EPStartXfer+0x3c4>
    {
      if (ep->xfer_len > 0U)
 810b970:	68bb      	ldr	r3, [r7, #8]
 810b972:	691b      	ldr	r3, [r3, #16]
 810b974:	2b00      	cmp	r3, #0
 810b976:	d003      	beq.n	810b980 <USB_EPStartXfer+0x370>
      {
        ep->xfer_len = ep->maxpacket;
 810b978:	68bb      	ldr	r3, [r7, #8]
 810b97a:	689a      	ldr	r2, [r3, #8]
 810b97c:	68bb      	ldr	r3, [r7, #8]
 810b97e:	611a      	str	r2, [r3, #16]
      }

      /* Store transfer size, for EP0 this is equal to endpoint max packet size */
      ep->xfer_size = ep->maxpacket;
 810b980:	68bb      	ldr	r3, [r7, #8]
 810b982:	689a      	ldr	r2, [r3, #8]
 810b984:	68bb      	ldr	r3, [r7, #8]
 810b986:	621a      	str	r2, [r3, #32]

      USBx_OUTEP(epnum)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_XFRSIZ & ep->xfer_size);
 810b988:	69bb      	ldr	r3, [r7, #24]
 810b98a:	015a      	lsls	r2, r3, #5
 810b98c:	69fb      	ldr	r3, [r7, #28]
 810b98e:	4413      	add	r3, r2
 810b990:	f503 6330 	add.w	r3, r3, #2816	; 0xb00
 810b994:	691a      	ldr	r2, [r3, #16]
 810b996:	68bb      	ldr	r3, [r7, #8]
 810b998:	6a1b      	ldr	r3, [r3, #32]
 810b99a:	f3c3 0312 	ubfx	r3, r3, #0, #19
 810b99e:	69b9      	ldr	r1, [r7, #24]
 810b9a0:	0148      	lsls	r0, r1, #5
 810b9a2:	69f9      	ldr	r1, [r7, #28]
 810b9a4:	4401      	add	r1, r0
 810b9a6:	f501 6130 	add.w	r1, r1, #2816	; 0xb00
 810b9aa:	4313      	orrs	r3, r2
 810b9ac:	610b      	str	r3, [r1, #16]
      USBx_OUTEP(epnum)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_PKTCNT & (1U << 19));
 810b9ae:	69bb      	ldr	r3, [r7, #24]
 810b9b0:	015a      	lsls	r2, r3, #5
 810b9b2:	69fb      	ldr	r3, [r7, #28]
 810b9b4:	4413      	add	r3, r2
 810b9b6:	f503 6330 	add.w	r3, r3, #2816	; 0xb00
 810b9ba:	691b      	ldr	r3, [r3, #16]
 810b9bc:	69ba      	ldr	r2, [r7, #24]
 810b9be:	0151      	lsls	r1, r2, #5
 810b9c0:	69fa      	ldr	r2, [r7, #28]
 810b9c2:	440a      	add	r2, r1
 810b9c4:	f502 6230 	add.w	r2, r2, #2816	; 0xb00
 810b9c8:	f443 2300 	orr.w	r3, r3, #524288	; 0x80000
 810b9cc:	6113      	str	r3, [r2, #16]
 810b9ce:	e061      	b.n	810ba94 <USB_EPStartXfer+0x484>
 810b9d0:	1ff80000 	.word	0x1ff80000
    }
    else
    {
      if (ep->xfer_len == 0U)
 810b9d4:	68bb      	ldr	r3, [r7, #8]
 810b9d6:	691b      	ldr	r3, [r3, #16]
 810b9d8:	2b00      	cmp	r3, #0
 810b9da:	d123      	bne.n	810ba24 <USB_EPStartXfer+0x414>
      {
        USBx_OUTEP(epnum)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_XFRSIZ & ep->maxpacket);
 810b9dc:	69bb      	ldr	r3, [r7, #24]
 810b9de:	015a      	lsls	r2, r3, #5
 810b9e0:	69fb      	ldr	r3, [r7, #28]
 810b9e2:	4413      	add	r3, r2
 810b9e4:	f503 6330 	add.w	r3, r3, #2816	; 0xb00
 810b9e8:	691a      	ldr	r2, [r3, #16]
 810b9ea:	68bb      	ldr	r3, [r7, #8]
 810b9ec:	689b      	ldr	r3, [r3, #8]
 810b9ee:	f3c3 0312 	ubfx	r3, r3, #0, #19
 810b9f2:	69b9      	ldr	r1, [r7, #24]
 810b9f4:	0148      	lsls	r0, r1, #5
 810b9f6:	69f9      	ldr	r1, [r7, #28]
 810b9f8:	4401      	add	r1, r0
 810b9fa:	f501 6130 	add.w	r1, r1, #2816	; 0xb00
 810b9fe:	4313      	orrs	r3, r2
 810ba00:	610b      	str	r3, [r1, #16]
        USBx_OUTEP(epnum)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_PKTCNT & (1U << 19));
 810ba02:	69bb      	ldr	r3, [r7, #24]
 810ba04:	015a      	lsls	r2, r3, #5
 810ba06:	69fb      	ldr	r3, [r7, #28]
 810ba08:	4413      	add	r3, r2
 810ba0a:	f503 6330 	add.w	r3, r3, #2816	; 0xb00
 810ba0e:	691b      	ldr	r3, [r3, #16]
 810ba10:	69ba      	ldr	r2, [r7, #24]
 810ba12:	0151      	lsls	r1, r2, #5
 810ba14:	69fa      	ldr	r2, [r7, #28]
 810ba16:	440a      	add	r2, r1
 810ba18:	f502 6230 	add.w	r2, r2, #2816	; 0xb00
 810ba1c:	f443 2300 	orr.w	r3, r3, #524288	; 0x80000
 810ba20:	6113      	str	r3, [r2, #16]
 810ba22:	e037      	b.n	810ba94 <USB_EPStartXfer+0x484>
      }
      else
      {
        pktcnt = (uint16_t)((ep->xfer_len + ep->maxpacket - 1U) / ep->maxpacket);
 810ba24:	68bb      	ldr	r3, [r7, #8]
 810ba26:	691a      	ldr	r2, [r3, #16]
 810ba28:	68bb      	ldr	r3, [r7, #8]
 810ba2a:	689b      	ldr	r3, [r3, #8]
 810ba2c:	4413      	add	r3, r2
 810ba2e:	1e5a      	subs	r2, r3, #1
 810ba30:	68bb      	ldr	r3, [r7, #8]
 810ba32:	689b      	ldr	r3, [r3, #8]
 810ba34:	fbb2 f3f3 	udiv	r3, r2, r3
 810ba38:	82fb      	strh	r3, [r7, #22]
        ep->xfer_size = ep->maxpacket * pktcnt;
 810ba3a:	68bb      	ldr	r3, [r7, #8]
 810ba3c:	689b      	ldr	r3, [r3, #8]
 810ba3e:	8afa      	ldrh	r2, [r7, #22]
 810ba40:	fb03 f202 	mul.w	r2, r3, r2
 810ba44:	68bb      	ldr	r3, [r7, #8]
 810ba46:	621a      	str	r2, [r3, #32]

        USBx_OUTEP(epnum)->DOEPTSIZ |= USB_OTG_DOEPTSIZ_PKTCNT & ((uint32_t)pktcnt << 19);
 810ba48:	69bb      	ldr	r3, [r7, #24]
 810ba4a:	015a      	lsls	r2, r3, #5
 810ba4c:	69fb      	ldr	r3, [r7, #28]
 810ba4e:	4413      	add	r3, r2
 810ba50:	f503 6330 	add.w	r3, r3, #2816	; 0xb00
 810ba54:	691a      	ldr	r2, [r3, #16]
 810ba56:	8afb      	ldrh	r3, [r7, #22]
 810ba58:	04d9      	lsls	r1, r3, #19
 810ba5a:	4b38      	ldr	r3, [pc, #224]	; (810bb3c <USB_EPStartXfer+0x52c>)
 810ba5c:	400b      	ands	r3, r1
 810ba5e:	69b9      	ldr	r1, [r7, #24]
 810ba60:	0148      	lsls	r0, r1, #5
 810ba62:	69f9      	ldr	r1, [r7, #28]
 810ba64:	4401      	add	r1, r0
 810ba66:	f501 6130 	add.w	r1, r1, #2816	; 0xb00
 810ba6a:	4313      	orrs	r3, r2
 810ba6c:	610b      	str	r3, [r1, #16]
        USBx_OUTEP(epnum)->DOEPTSIZ |= USB_OTG_DOEPTSIZ_XFRSIZ & ep->xfer_size;
 810ba6e:	69bb      	ldr	r3, [r7, #24]
 810ba70:	015a      	lsls	r2, r3, #5
 810ba72:	69fb      	ldr	r3, [r7, #28]
 810ba74:	4413      	add	r3, r2
 810ba76:	f503 6330 	add.w	r3, r3, #2816	; 0xb00
 810ba7a:	691a      	ldr	r2, [r3, #16]
 810ba7c:	68bb      	ldr	r3, [r7, #8]
 810ba7e:	6a1b      	ldr	r3, [r3, #32]
 810ba80:	f3c3 0312 	ubfx	r3, r3, #0, #19
 810ba84:	69b9      	ldr	r1, [r7, #24]
 810ba86:	0148      	lsls	r0, r1, #5
 810ba88:	69f9      	ldr	r1, [r7, #28]
 810ba8a:	4401      	add	r1, r0
 810ba8c:	f501 6130 	add.w	r1, r1, #2816	; 0xb00
 810ba90:	4313      	orrs	r3, r2
 810ba92:	610b      	str	r3, [r1, #16]
      }
    }

    if (dma == 1U)
 810ba94:	79fb      	ldrb	r3, [r7, #7]
 810ba96:	2b01      	cmp	r3, #1
 810ba98:	d10d      	bne.n	810bab6 <USB_EPStartXfer+0x4a6>
    {
      if ((uint32_t)ep->xfer_buff != 0U)
 810ba9a:	68bb      	ldr	r3, [r7, #8]
 810ba9c:	68db      	ldr	r3, [r3, #12]
 810ba9e:	2b00      	cmp	r3, #0
 810baa0:	d009      	beq.n	810bab6 <USB_EPStartXfer+0x4a6>
      {
        USBx_OUTEP(epnum)->DOEPDMA = (uint32_t)(ep->xfer_buff);
 810baa2:	68bb      	ldr	r3, [r7, #8]
 810baa4:	68d9      	ldr	r1, [r3, #12]
 810baa6:	69bb      	ldr	r3, [r7, #24]
 810baa8:	015a      	lsls	r2, r3, #5
 810baaa:	69fb      	ldr	r3, [r7, #28]
 810baac:	4413      	add	r3, r2
 810baae:	f503 6330 	add.w	r3, r3, #2816	; 0xb00
 810bab2:	460a      	mov	r2, r1
 810bab4:	615a      	str	r2, [r3, #20]
      }
    }

    if (ep->type == EP_TYPE_ISOC)
 810bab6:	68bb      	ldr	r3, [r7, #8]
 810bab8:	791b      	ldrb	r3, [r3, #4]
 810baba:	2b01      	cmp	r3, #1
 810babc:	d128      	bne.n	810bb10 <USB_EPStartXfer+0x500>
    {
      if ((USBx_DEVICE->DSTS & (1U << 8)) == 0U)
 810babe:	69fb      	ldr	r3, [r7, #28]
 810bac0:	f503 6300 	add.w	r3, r3, #2048	; 0x800
 810bac4:	689b      	ldr	r3, [r3, #8]
 810bac6:	f403 7380 	and.w	r3, r3, #256	; 0x100
 810baca:	2b00      	cmp	r3, #0
 810bacc:	d110      	bne.n	810baf0 <USB_EPStartXfer+0x4e0>
      {
        USBx_OUTEP(epnum)->DOEPCTL |= USB_OTG_DOEPCTL_SODDFRM;
 810bace:	69bb      	ldr	r3, [r7, #24]
 810bad0:	015a      	lsls	r2, r3, #5
 810bad2:	69fb      	ldr	r3, [r7, #28]
 810bad4:	4413      	add	r3, r2
 810bad6:	f503 6330 	add.w	r3, r3, #2816	; 0xb00
 810bada:	681b      	ldr	r3, [r3, #0]
 810badc:	69ba      	ldr	r2, [r7, #24]
 810bade:	0151      	lsls	r1, r2, #5
 810bae0:	69fa      	ldr	r2, [r7, #28]
 810bae2:	440a      	add	r2, r1
 810bae4:	f502 6230 	add.w	r2, r2, #2816	; 0xb00
 810bae8:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
 810baec:	6013      	str	r3, [r2, #0]
 810baee:	e00f      	b.n	810bb10 <USB_EPStartXfer+0x500>
      }
      else
      {
        USBx_OUTEP(epnum)->DOEPCTL |= USB_OTG_DOEPCTL_SD0PID_SEVNFRM;
 810baf0:	69bb      	ldr	r3, [r7, #24]
 810baf2:	015a      	lsls	r2, r3, #5
 810baf4:	69fb      	ldr	r3, [r7, #28]
 810baf6:	4413      	add	r3, r2
 810baf8:	f503 6330 	add.w	r3, r3, #2816	; 0xb00
 810bafc:	681b      	ldr	r3, [r3, #0]
 810bafe:	69ba      	ldr	r2, [r7, #24]
 810bb00:	0151      	lsls	r1, r2, #5
 810bb02:	69fa      	ldr	r2, [r7, #28]
 810bb04:	440a      	add	r2, r1
 810bb06:	f502 6230 	add.w	r2, r2, #2816	; 0xb00
 810bb0a:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 810bb0e:	6013      	str	r3, [r2, #0]
      }
    }
    /* EP enable */
    USBx_OUTEP(epnum)->DOEPCTL |= (USB_OTG_DOEPCTL_CNAK | USB_OTG_DOEPCTL_EPENA);
 810bb10:	69bb      	ldr	r3, [r7, #24]
 810bb12:	015a      	lsls	r2, r3, #5
 810bb14:	69fb      	ldr	r3, [r7, #28]
 810bb16:	4413      	add	r3, r2
 810bb18:	f503 6330 	add.w	r3, r3, #2816	; 0xb00
 810bb1c:	681b      	ldr	r3, [r3, #0]
 810bb1e:	69ba      	ldr	r2, [r7, #24]
 810bb20:	0151      	lsls	r1, r2, #5
 810bb22:	69fa      	ldr	r2, [r7, #28]
 810bb24:	440a      	add	r2, r1
 810bb26:	f502 6230 	add.w	r2, r2, #2816	; 0xb00
 810bb2a:	f043 4304 	orr.w	r3, r3, #2214592512	; 0x84000000
 810bb2e:	6013      	str	r3, [r2, #0]
  }

  return HAL_OK;
 810bb30:	2300      	movs	r3, #0
}
 810bb32:	4618      	mov	r0, r3
 810bb34:	3720      	adds	r7, #32
 810bb36:	46bd      	mov	sp, r7
 810bb38:	bd80      	pop	{r7, pc}
 810bb3a:	bf00      	nop
 810bb3c:	1ff80000 	.word	0x1ff80000

0810bb40 <USB_EPStopXfer>:
   * @param  USBx  usb device instance
   * @param  ep pointer to endpoint structure
   * @retval HAL status
   */
HAL_StatusTypeDef USB_EPStopXfer(const USB_OTG_GlobalTypeDef *USBx, USB_OTG_EPTypeDef *ep)
{
 810bb40:	b480      	push	{r7}
 810bb42:	b087      	sub	sp, #28
 810bb44:	af00      	add	r7, sp, #0
 810bb46:	6078      	str	r0, [r7, #4]
 810bb48:	6039      	str	r1, [r7, #0]
  __IO uint32_t count = 0U;
 810bb4a:	2300      	movs	r3, #0
 810bb4c:	60fb      	str	r3, [r7, #12]
  HAL_StatusTypeDef ret = HAL_OK;
 810bb4e:	2300      	movs	r3, #0
 810bb50:	75fb      	strb	r3, [r7, #23]
  uint32_t USBx_BASE = (uint32_t)USBx;
 810bb52:	687b      	ldr	r3, [r7, #4]
 810bb54:	613b      	str	r3, [r7, #16]

  /* IN endpoint */
  if (ep->is_in == 1U)
 810bb56:	683b      	ldr	r3, [r7, #0]
 810bb58:	785b      	ldrb	r3, [r3, #1]
 810bb5a:	2b01      	cmp	r3, #1
 810bb5c:	d14a      	bne.n	810bbf4 <USB_EPStopXfer+0xb4>
  {
    /* EP enable, IN data in FIFO */
    if (((USBx_INEP(ep->num)->DIEPCTL) & USB_OTG_DIEPCTL_EPENA) == USB_OTG_DIEPCTL_EPENA)
 810bb5e:	683b      	ldr	r3, [r7, #0]
 810bb60:	781b      	ldrb	r3, [r3, #0]
 810bb62:	015a      	lsls	r2, r3, #5
 810bb64:	693b      	ldr	r3, [r7, #16]
 810bb66:	4413      	add	r3, r2
 810bb68:	f503 6310 	add.w	r3, r3, #2304	; 0x900
 810bb6c:	681b      	ldr	r3, [r3, #0]
 810bb6e:	f003 4300 	and.w	r3, r3, #2147483648	; 0x80000000
 810bb72:	f1b3 4f00 	cmp.w	r3, #2147483648	; 0x80000000
 810bb76:	f040 8086 	bne.w	810bc86 <USB_EPStopXfer+0x146>
    {
      USBx_INEP(ep->num)->DIEPCTL |= (USB_OTG_DIEPCTL_SNAK);
 810bb7a:	683b      	ldr	r3, [r7, #0]
 810bb7c:	781b      	ldrb	r3, [r3, #0]
 810bb7e:	015a      	lsls	r2, r3, #5
 810bb80:	693b      	ldr	r3, [r7, #16]
 810bb82:	4413      	add	r3, r2
 810bb84:	f503 6310 	add.w	r3, r3, #2304	; 0x900
 810bb88:	681b      	ldr	r3, [r3, #0]
 810bb8a:	683a      	ldr	r2, [r7, #0]
 810bb8c:	7812      	ldrb	r2, [r2, #0]
 810bb8e:	0151      	lsls	r1, r2, #5
 810bb90:	693a      	ldr	r2, [r7, #16]
 810bb92:	440a      	add	r2, r1
 810bb94:	f502 6210 	add.w	r2, r2, #2304	; 0x900
 810bb98:	f043 6300 	orr.w	r3, r3, #134217728	; 0x8000000
 810bb9c:	6013      	str	r3, [r2, #0]
      USBx_INEP(ep->num)->DIEPCTL |= (USB_OTG_DIEPCTL_EPDIS);
 810bb9e:	683b      	ldr	r3, [r7, #0]
 810bba0:	781b      	ldrb	r3, [r3, #0]
 810bba2:	015a      	lsls	r2, r3, #5
 810bba4:	693b      	ldr	r3, [r7, #16]
 810bba6:	4413      	add	r3, r2
 810bba8:	f503 6310 	add.w	r3, r3, #2304	; 0x900
 810bbac:	681b      	ldr	r3, [r3, #0]
 810bbae:	683a      	ldr	r2, [r7, #0]
 810bbb0:	7812      	ldrb	r2, [r2, #0]
 810bbb2:	0151      	lsls	r1, r2, #5
 810bbb4:	693a      	ldr	r2, [r7, #16]
 810bbb6:	440a      	add	r2, r1
 810bbb8:	f502 6210 	add.w	r2, r2, #2304	; 0x900
 810bbbc:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
 810bbc0:	6013      	str	r3, [r2, #0]

      do
      {
        count++;
 810bbc2:	68fb      	ldr	r3, [r7, #12]
 810bbc4:	3301      	adds	r3, #1
 810bbc6:	60fb      	str	r3, [r7, #12]

        if (count > 10000U)
 810bbc8:	68fb      	ldr	r3, [r7, #12]
 810bbca:	f242 7210 	movw	r2, #10000	; 0x2710
 810bbce:	4293      	cmp	r3, r2
 810bbd0:	d902      	bls.n	810bbd8 <USB_EPStopXfer+0x98>
        {
          ret = HAL_ERROR;
 810bbd2:	2301      	movs	r3, #1
 810bbd4:	75fb      	strb	r3, [r7, #23]
          break;
 810bbd6:	e056      	b.n	810bc86 <USB_EPStopXfer+0x146>
        }
      } while (((USBx_INEP(ep->num)->DIEPCTL) & USB_OTG_DIEPCTL_EPENA) ==  USB_OTG_DIEPCTL_EPENA);
 810bbd8:	683b      	ldr	r3, [r7, #0]
 810bbda:	781b      	ldrb	r3, [r3, #0]
 810bbdc:	015a      	lsls	r2, r3, #5
 810bbde:	693b      	ldr	r3, [r7, #16]
 810bbe0:	4413      	add	r3, r2
 810bbe2:	f503 6310 	add.w	r3, r3, #2304	; 0x900
 810bbe6:	681b      	ldr	r3, [r3, #0]
 810bbe8:	f003 4300 	and.w	r3, r3, #2147483648	; 0x80000000
 810bbec:	f1b3 4f00 	cmp.w	r3, #2147483648	; 0x80000000
 810bbf0:	d0e7      	beq.n	810bbc2 <USB_EPStopXfer+0x82>
 810bbf2:	e048      	b.n	810bc86 <USB_EPStopXfer+0x146>
    }
  }
  else /* OUT endpoint */
  {
    if (((USBx_OUTEP(ep->num)->DOEPCTL) & USB_OTG_DOEPCTL_EPENA) == USB_OTG_DOEPCTL_EPENA)
 810bbf4:	683b      	ldr	r3, [r7, #0]
 810bbf6:	781b      	ldrb	r3, [r3, #0]
 810bbf8:	015a      	lsls	r2, r3, #5
 810bbfa:	693b      	ldr	r3, [r7, #16]
 810bbfc:	4413      	add	r3, r2
 810bbfe:	f503 6330 	add.w	r3, r3, #2816	; 0xb00
 810bc02:	681b      	ldr	r3, [r3, #0]
 810bc04:	f003 4300 	and.w	r3, r3, #2147483648	; 0x80000000
 810bc08:	f1b3 4f00 	cmp.w	r3, #2147483648	; 0x80000000
 810bc0c:	d13b      	bne.n	810bc86 <USB_EPStopXfer+0x146>
    {
      USBx_OUTEP(ep->num)->DOEPCTL |= (USB_OTG_DOEPCTL_SNAK);
 810bc0e:	683b      	ldr	r3, [r7, #0]
 810bc10:	781b      	ldrb	r3, [r3, #0]
 810bc12:	015a      	lsls	r2, r3, #5
 810bc14:	693b      	ldr	r3, [r7, #16]
 810bc16:	4413      	add	r3, r2
 810bc18:	f503 6330 	add.w	r3, r3, #2816	; 0xb00
 810bc1c:	681b      	ldr	r3, [r3, #0]
 810bc1e:	683a      	ldr	r2, [r7, #0]
 810bc20:	7812      	ldrb	r2, [r2, #0]
 810bc22:	0151      	lsls	r1, r2, #5
 810bc24:	693a      	ldr	r2, [r7, #16]
 810bc26:	440a      	add	r2, r1
 810bc28:	f502 6230 	add.w	r2, r2, #2816	; 0xb00
 810bc2c:	f043 6300 	orr.w	r3, r3, #134217728	; 0x8000000
 810bc30:	6013      	str	r3, [r2, #0]
      USBx_OUTEP(ep->num)->DOEPCTL |= (USB_OTG_DOEPCTL_EPDIS);
 810bc32:	683b      	ldr	r3, [r7, #0]
 810bc34:	781b      	ldrb	r3, [r3, #0]
 810bc36:	015a      	lsls	r2, r3, #5
 810bc38:	693b      	ldr	r3, [r7, #16]
 810bc3a:	4413      	add	r3, r2
 810bc3c:	f503 6330 	add.w	r3, r3, #2816	; 0xb00
 810bc40:	681b      	ldr	r3, [r3, #0]
 810bc42:	683a      	ldr	r2, [r7, #0]
 810bc44:	7812      	ldrb	r2, [r2, #0]
 810bc46:	0151      	lsls	r1, r2, #5
 810bc48:	693a      	ldr	r2, [r7, #16]
 810bc4a:	440a      	add	r2, r1
 810bc4c:	f502 6230 	add.w	r2, r2, #2816	; 0xb00
 810bc50:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
 810bc54:	6013      	str	r3, [r2, #0]

      do
      {
        count++;
 810bc56:	68fb      	ldr	r3, [r7, #12]
 810bc58:	3301      	adds	r3, #1
 810bc5a:	60fb      	str	r3, [r7, #12]

        if (count > 10000U)
 810bc5c:	68fb      	ldr	r3, [r7, #12]
 810bc5e:	f242 7210 	movw	r2, #10000	; 0x2710
 810bc62:	4293      	cmp	r3, r2
 810bc64:	d902      	bls.n	810bc6c <USB_EPStopXfer+0x12c>
        {
          ret = HAL_ERROR;
 810bc66:	2301      	movs	r3, #1
 810bc68:	75fb      	strb	r3, [r7, #23]
          break;
 810bc6a:	e00c      	b.n	810bc86 <USB_EPStopXfer+0x146>
        }
      } while (((USBx_OUTEP(ep->num)->DOEPCTL) & USB_OTG_DOEPCTL_EPENA) ==  USB_OTG_DOEPCTL_EPENA);
 810bc6c:	683b      	ldr	r3, [r7, #0]
 810bc6e:	781b      	ldrb	r3, [r3, #0]
 810bc70:	015a      	lsls	r2, r3, #5
 810bc72:	693b      	ldr	r3, [r7, #16]
 810bc74:	4413      	add	r3, r2
 810bc76:	f503 6330 	add.w	r3, r3, #2816	; 0xb00
 810bc7a:	681b      	ldr	r3, [r3, #0]
 810bc7c:	f003 4300 	and.w	r3, r3, #2147483648	; 0x80000000
 810bc80:	f1b3 4f00 	cmp.w	r3, #2147483648	; 0x80000000
 810bc84:	d0e7      	beq.n	810bc56 <USB_EPStopXfer+0x116>
    }
  }

  return ret;
 810bc86:	7dfb      	ldrb	r3, [r7, #23]
}
 810bc88:	4618      	mov	r0, r3
 810bc8a:	371c      	adds	r7, #28
 810bc8c:	46bd      	mov	sp, r7
 810bc8e:	f85d 7b04 	ldr.w	r7, [sp], #4
 810bc92:	4770      	bx	lr

0810bc94 <USB_WritePacket>:
  *           1 : DMA feature used
  * @retval HAL status
  */
HAL_StatusTypeDef USB_WritePacket(const USB_OTG_GlobalTypeDef *USBx, uint8_t *src,
                                  uint8_t ch_ep_num, uint16_t len, uint8_t dma)
{
 810bc94:	b480      	push	{r7}
 810bc96:	b089      	sub	sp, #36	; 0x24
 810bc98:	af00      	add	r7, sp, #0
 810bc9a:	60f8      	str	r0, [r7, #12]
 810bc9c:	60b9      	str	r1, [r7, #8]
 810bc9e:	4611      	mov	r1, r2
 810bca0:	461a      	mov	r2, r3
 810bca2:	460b      	mov	r3, r1
 810bca4:	71fb      	strb	r3, [r7, #7]
 810bca6:	4613      	mov	r3, r2
 810bca8:	80bb      	strh	r3, [r7, #4]
  uint32_t USBx_BASE = (uint32_t)USBx;
 810bcaa:	68fb      	ldr	r3, [r7, #12]
 810bcac:	617b      	str	r3, [r7, #20]
  uint8_t *pSrc = src;
 810bcae:	68bb      	ldr	r3, [r7, #8]
 810bcb0:	61fb      	str	r3, [r7, #28]
  uint32_t count32b;
  uint32_t i;

  if (dma == 0U)
 810bcb2:	f897 3028 	ldrb.w	r3, [r7, #40]	; 0x28
 810bcb6:	2b00      	cmp	r3, #0
 810bcb8:	d123      	bne.n	810bd02 <USB_WritePacket+0x6e>
  {
    count32b = ((uint32_t)len + 3U) / 4U;
 810bcba:	88bb      	ldrh	r3, [r7, #4]
 810bcbc:	3303      	adds	r3, #3
 810bcbe:	089b      	lsrs	r3, r3, #2
 810bcc0:	613b      	str	r3, [r7, #16]
    for (i = 0U; i < count32b; i++)
 810bcc2:	2300      	movs	r3, #0
 810bcc4:	61bb      	str	r3, [r7, #24]
 810bcc6:	e018      	b.n	810bcfa <USB_WritePacket+0x66>
    {
      USBx_DFIFO((uint32_t)ch_ep_num) = __UNALIGNED_UINT32_READ(pSrc);
 810bcc8:	79fb      	ldrb	r3, [r7, #7]
 810bcca:	031a      	lsls	r2, r3, #12
 810bccc:	697b      	ldr	r3, [r7, #20]
 810bcce:	4413      	add	r3, r2
 810bcd0:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 810bcd4:	461a      	mov	r2, r3
 810bcd6:	69fb      	ldr	r3, [r7, #28]
 810bcd8:	681b      	ldr	r3, [r3, #0]
 810bcda:	6013      	str	r3, [r2, #0]
      pSrc++;
 810bcdc:	69fb      	ldr	r3, [r7, #28]
 810bcde:	3301      	adds	r3, #1
 810bce0:	61fb      	str	r3, [r7, #28]
      pSrc++;
 810bce2:	69fb      	ldr	r3, [r7, #28]
 810bce4:	3301      	adds	r3, #1
 810bce6:	61fb      	str	r3, [r7, #28]
      pSrc++;
 810bce8:	69fb      	ldr	r3, [r7, #28]
 810bcea:	3301      	adds	r3, #1
 810bcec:	61fb      	str	r3, [r7, #28]
      pSrc++;
 810bcee:	69fb      	ldr	r3, [r7, #28]
 810bcf0:	3301      	adds	r3, #1
 810bcf2:	61fb      	str	r3, [r7, #28]
    for (i = 0U; i < count32b; i++)
 810bcf4:	69bb      	ldr	r3, [r7, #24]
 810bcf6:	3301      	adds	r3, #1
 810bcf8:	61bb      	str	r3, [r7, #24]
 810bcfa:	69ba      	ldr	r2, [r7, #24]
 810bcfc:	693b      	ldr	r3, [r7, #16]
 810bcfe:	429a      	cmp	r2, r3
 810bd00:	d3e2      	bcc.n	810bcc8 <USB_WritePacket+0x34>
    }
  }

  return HAL_OK;
 810bd02:	2300      	movs	r3, #0
}
 810bd04:	4618      	mov	r0, r3
 810bd06:	3724      	adds	r7, #36	; 0x24
 810bd08:	46bd      	mov	sp, r7
 810bd0a:	f85d 7b04 	ldr.w	r7, [sp], #4
 810bd0e:	4770      	bx	lr

0810bd10 <USB_ReadPacket>:
  * @param  dest  source pointer
  * @param  len  Number of bytes to read
  * @retval pointer to destination buffer
  */
void *USB_ReadPacket(const USB_OTG_GlobalTypeDef *USBx, uint8_t *dest, uint16_t len)
{
 810bd10:	b480      	push	{r7}
 810bd12:	b08b      	sub	sp, #44	; 0x2c
 810bd14:	af00      	add	r7, sp, #0
 810bd16:	60f8      	str	r0, [r7, #12]
 810bd18:	60b9      	str	r1, [r7, #8]
 810bd1a:	4613      	mov	r3, r2
 810bd1c:	80fb      	strh	r3, [r7, #6]
  uint32_t USBx_BASE = (uint32_t)USBx;
 810bd1e:	68fb      	ldr	r3, [r7, #12]
 810bd20:	61bb      	str	r3, [r7, #24]
  uint8_t *pDest = dest;
 810bd22:	68bb      	ldr	r3, [r7, #8]
 810bd24:	627b      	str	r3, [r7, #36]	; 0x24
  uint32_t pData;
  uint32_t i;
  uint32_t count32b = (uint32_t)len >> 2U;
 810bd26:	88fb      	ldrh	r3, [r7, #6]
 810bd28:	089b      	lsrs	r3, r3, #2
 810bd2a:	b29b      	uxth	r3, r3
 810bd2c:	617b      	str	r3, [r7, #20]
  uint16_t remaining_bytes = len % 4U;
 810bd2e:	88fb      	ldrh	r3, [r7, #6]
 810bd30:	f003 0303 	and.w	r3, r3, #3
 810bd34:	83fb      	strh	r3, [r7, #30]

  for (i = 0U; i < count32b; i++)
 810bd36:	2300      	movs	r3, #0
 810bd38:	623b      	str	r3, [r7, #32]
 810bd3a:	e014      	b.n	810bd66 <USB_ReadPacket+0x56>
  {
    __UNALIGNED_UINT32_WRITE(pDest, USBx_DFIFO(0U));
 810bd3c:	69bb      	ldr	r3, [r7, #24]
 810bd3e:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 810bd42:	681a      	ldr	r2, [r3, #0]
 810bd44:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 810bd46:	601a      	str	r2, [r3, #0]
    pDest++;
 810bd48:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 810bd4a:	3301      	adds	r3, #1
 810bd4c:	627b      	str	r3, [r7, #36]	; 0x24
    pDest++;
 810bd4e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 810bd50:	3301      	adds	r3, #1
 810bd52:	627b      	str	r3, [r7, #36]	; 0x24
    pDest++;
 810bd54:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 810bd56:	3301      	adds	r3, #1
 810bd58:	627b      	str	r3, [r7, #36]	; 0x24
    pDest++;
 810bd5a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 810bd5c:	3301      	adds	r3, #1
 810bd5e:	627b      	str	r3, [r7, #36]	; 0x24
  for (i = 0U; i < count32b; i++)
 810bd60:	6a3b      	ldr	r3, [r7, #32]
 810bd62:	3301      	adds	r3, #1
 810bd64:	623b      	str	r3, [r7, #32]
 810bd66:	6a3a      	ldr	r2, [r7, #32]
 810bd68:	697b      	ldr	r3, [r7, #20]
 810bd6a:	429a      	cmp	r2, r3
 810bd6c:	d3e6      	bcc.n	810bd3c <USB_ReadPacket+0x2c>
  }

  /* When Number of data is not word aligned, read the remaining byte */
  if (remaining_bytes != 0U)
 810bd6e:	8bfb      	ldrh	r3, [r7, #30]
 810bd70:	2b00      	cmp	r3, #0
 810bd72:	d01e      	beq.n	810bdb2 <USB_ReadPacket+0xa2>
  {
    i = 0U;
 810bd74:	2300      	movs	r3, #0
 810bd76:	623b      	str	r3, [r7, #32]
    __UNALIGNED_UINT32_WRITE(&pData, USBx_DFIFO(0U));
 810bd78:	69bb      	ldr	r3, [r7, #24]
 810bd7a:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 810bd7e:	461a      	mov	r2, r3
 810bd80:	f107 0310 	add.w	r3, r7, #16
 810bd84:	6812      	ldr	r2, [r2, #0]
 810bd86:	601a      	str	r2, [r3, #0]

    do
    {
      *(uint8_t *)pDest = (uint8_t)(pData >> (8U * (uint8_t)(i)));
 810bd88:	693a      	ldr	r2, [r7, #16]
 810bd8a:	6a3b      	ldr	r3, [r7, #32]
 810bd8c:	b2db      	uxtb	r3, r3
 810bd8e:	00db      	lsls	r3, r3, #3
 810bd90:	fa22 f303 	lsr.w	r3, r2, r3
 810bd94:	b2da      	uxtb	r2, r3
 810bd96:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 810bd98:	701a      	strb	r2, [r3, #0]
      i++;
 810bd9a:	6a3b      	ldr	r3, [r7, #32]
 810bd9c:	3301      	adds	r3, #1
 810bd9e:	623b      	str	r3, [r7, #32]
      pDest++;
 810bda0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 810bda2:	3301      	adds	r3, #1
 810bda4:	627b      	str	r3, [r7, #36]	; 0x24
      remaining_bytes--;
 810bda6:	8bfb      	ldrh	r3, [r7, #30]
 810bda8:	3b01      	subs	r3, #1
 810bdaa:	83fb      	strh	r3, [r7, #30]
    } while (remaining_bytes != 0U);
 810bdac:	8bfb      	ldrh	r3, [r7, #30]
 810bdae:	2b00      	cmp	r3, #0
 810bdb0:	d1ea      	bne.n	810bd88 <USB_ReadPacket+0x78>
  }

  return ((void *)pDest);
 810bdb2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
}
 810bdb4:	4618      	mov	r0, r3
 810bdb6:	372c      	adds	r7, #44	; 0x2c
 810bdb8:	46bd      	mov	sp, r7
 810bdba:	f85d 7b04 	ldr.w	r7, [sp], #4
 810bdbe:	4770      	bx	lr

0810bdc0 <USB_EPSetStall>:
  * @param  USBx  Selected device
  * @param  ep pointer to endpoint structure
  * @retval HAL status
  */
HAL_StatusTypeDef USB_EPSetStall(const USB_OTG_GlobalTypeDef *USBx, const USB_OTG_EPTypeDef *ep)
{
 810bdc0:	b480      	push	{r7}
 810bdc2:	b085      	sub	sp, #20
 810bdc4:	af00      	add	r7, sp, #0
 810bdc6:	6078      	str	r0, [r7, #4]
 810bdc8:	6039      	str	r1, [r7, #0]
  uint32_t USBx_BASE = (uint32_t)USBx;
 810bdca:	687b      	ldr	r3, [r7, #4]
 810bdcc:	60fb      	str	r3, [r7, #12]
  uint32_t epnum = (uint32_t)ep->num;
 810bdce:	683b      	ldr	r3, [r7, #0]
 810bdd0:	781b      	ldrb	r3, [r3, #0]
 810bdd2:	60bb      	str	r3, [r7, #8]

  if (ep->is_in == 1U)
 810bdd4:	683b      	ldr	r3, [r7, #0]
 810bdd6:	785b      	ldrb	r3, [r3, #1]
 810bdd8:	2b01      	cmp	r3, #1
 810bdda:	d12c      	bne.n	810be36 <USB_EPSetStall+0x76>
  {
    if (((USBx_INEP(epnum)->DIEPCTL & USB_OTG_DIEPCTL_EPENA) == 0U) && (epnum != 0U))
 810bddc:	68bb      	ldr	r3, [r7, #8]
 810bdde:	015a      	lsls	r2, r3, #5
 810bde0:	68fb      	ldr	r3, [r7, #12]
 810bde2:	4413      	add	r3, r2
 810bde4:	f503 6310 	add.w	r3, r3, #2304	; 0x900
 810bde8:	681b      	ldr	r3, [r3, #0]
 810bdea:	2b00      	cmp	r3, #0
 810bdec:	db12      	blt.n	810be14 <USB_EPSetStall+0x54>
 810bdee:	68bb      	ldr	r3, [r7, #8]
 810bdf0:	2b00      	cmp	r3, #0
 810bdf2:	d00f      	beq.n	810be14 <USB_EPSetStall+0x54>
    {
      USBx_INEP(epnum)->DIEPCTL &= ~(USB_OTG_DIEPCTL_EPDIS);
 810bdf4:	68bb      	ldr	r3, [r7, #8]
 810bdf6:	015a      	lsls	r2, r3, #5
 810bdf8:	68fb      	ldr	r3, [r7, #12]
 810bdfa:	4413      	add	r3, r2
 810bdfc:	f503 6310 	add.w	r3, r3, #2304	; 0x900
 810be00:	681b      	ldr	r3, [r3, #0]
 810be02:	68ba      	ldr	r2, [r7, #8]
 810be04:	0151      	lsls	r1, r2, #5
 810be06:	68fa      	ldr	r2, [r7, #12]
 810be08:	440a      	add	r2, r1
 810be0a:	f502 6210 	add.w	r2, r2, #2304	; 0x900
 810be0e:	f023 4380 	bic.w	r3, r3, #1073741824	; 0x40000000
 810be12:	6013      	str	r3, [r2, #0]
    }
    USBx_INEP(epnum)->DIEPCTL |= USB_OTG_DIEPCTL_STALL;
 810be14:	68bb      	ldr	r3, [r7, #8]
 810be16:	015a      	lsls	r2, r3, #5
 810be18:	68fb      	ldr	r3, [r7, #12]
 810be1a:	4413      	add	r3, r2
 810be1c:	f503 6310 	add.w	r3, r3, #2304	; 0x900
 810be20:	681b      	ldr	r3, [r3, #0]
 810be22:	68ba      	ldr	r2, [r7, #8]
 810be24:	0151      	lsls	r1, r2, #5
 810be26:	68fa      	ldr	r2, [r7, #12]
 810be28:	440a      	add	r2, r1
 810be2a:	f502 6210 	add.w	r2, r2, #2304	; 0x900
 810be2e:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
 810be32:	6013      	str	r3, [r2, #0]
 810be34:	e02b      	b.n	810be8e <USB_EPSetStall+0xce>
  }
  else
  {
    if (((USBx_OUTEP(epnum)->DOEPCTL & USB_OTG_DOEPCTL_EPENA) == 0U) && (epnum != 0U))
 810be36:	68bb      	ldr	r3, [r7, #8]
 810be38:	015a      	lsls	r2, r3, #5
 810be3a:	68fb      	ldr	r3, [r7, #12]
 810be3c:	4413      	add	r3, r2
 810be3e:	f503 6330 	add.w	r3, r3, #2816	; 0xb00
 810be42:	681b      	ldr	r3, [r3, #0]
 810be44:	2b00      	cmp	r3, #0
 810be46:	db12      	blt.n	810be6e <USB_EPSetStall+0xae>
 810be48:	68bb      	ldr	r3, [r7, #8]
 810be4a:	2b00      	cmp	r3, #0
 810be4c:	d00f      	beq.n	810be6e <USB_EPSetStall+0xae>
    {
      USBx_OUTEP(epnum)->DOEPCTL &= ~(USB_OTG_DOEPCTL_EPDIS);
 810be4e:	68bb      	ldr	r3, [r7, #8]
 810be50:	015a      	lsls	r2, r3, #5
 810be52:	68fb      	ldr	r3, [r7, #12]
 810be54:	4413      	add	r3, r2
 810be56:	f503 6330 	add.w	r3, r3, #2816	; 0xb00
 810be5a:	681b      	ldr	r3, [r3, #0]
 810be5c:	68ba      	ldr	r2, [r7, #8]
 810be5e:	0151      	lsls	r1, r2, #5
 810be60:	68fa      	ldr	r2, [r7, #12]
 810be62:	440a      	add	r2, r1
 810be64:	f502 6230 	add.w	r2, r2, #2816	; 0xb00
 810be68:	f023 4380 	bic.w	r3, r3, #1073741824	; 0x40000000
 810be6c:	6013      	str	r3, [r2, #0]
    }
    USBx_OUTEP(epnum)->DOEPCTL |= USB_OTG_DOEPCTL_STALL;
 810be6e:	68bb      	ldr	r3, [r7, #8]
 810be70:	015a      	lsls	r2, r3, #5
 810be72:	68fb      	ldr	r3, [r7, #12]
 810be74:	4413      	add	r3, r2
 810be76:	f503 6330 	add.w	r3, r3, #2816	; 0xb00
 810be7a:	681b      	ldr	r3, [r3, #0]
 810be7c:	68ba      	ldr	r2, [r7, #8]
 810be7e:	0151      	lsls	r1, r2, #5
 810be80:	68fa      	ldr	r2, [r7, #12]
 810be82:	440a      	add	r2, r1
 810be84:	f502 6230 	add.w	r2, r2, #2816	; 0xb00
 810be88:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
 810be8c:	6013      	str	r3, [r2, #0]
  }

  return HAL_OK;
 810be8e:	2300      	movs	r3, #0
}
 810be90:	4618      	mov	r0, r3
 810be92:	3714      	adds	r7, #20
 810be94:	46bd      	mov	sp, r7
 810be96:	f85d 7b04 	ldr.w	r7, [sp], #4
 810be9a:	4770      	bx	lr

0810be9c <USB_EPClearStall>:
  * @param  USBx  Selected device
  * @param  ep pointer to endpoint structure
  * @retval HAL status
  */
HAL_StatusTypeDef USB_EPClearStall(const USB_OTG_GlobalTypeDef *USBx, const USB_OTG_EPTypeDef *ep)
{
 810be9c:	b480      	push	{r7}
 810be9e:	b085      	sub	sp, #20
 810bea0:	af00      	add	r7, sp, #0
 810bea2:	6078      	str	r0, [r7, #4]
 810bea4:	6039      	str	r1, [r7, #0]
  uint32_t USBx_BASE = (uint32_t)USBx;
 810bea6:	687b      	ldr	r3, [r7, #4]
 810bea8:	60fb      	str	r3, [r7, #12]
  uint32_t epnum = (uint32_t)ep->num;
 810beaa:	683b      	ldr	r3, [r7, #0]
 810beac:	781b      	ldrb	r3, [r3, #0]
 810beae:	60bb      	str	r3, [r7, #8]

  if (ep->is_in == 1U)
 810beb0:	683b      	ldr	r3, [r7, #0]
 810beb2:	785b      	ldrb	r3, [r3, #1]
 810beb4:	2b01      	cmp	r3, #1
 810beb6:	d128      	bne.n	810bf0a <USB_EPClearStall+0x6e>
  {
    USBx_INEP(epnum)->DIEPCTL &= ~USB_OTG_DIEPCTL_STALL;
 810beb8:	68bb      	ldr	r3, [r7, #8]
 810beba:	015a      	lsls	r2, r3, #5
 810bebc:	68fb      	ldr	r3, [r7, #12]
 810bebe:	4413      	add	r3, r2
 810bec0:	f503 6310 	add.w	r3, r3, #2304	; 0x900
 810bec4:	681b      	ldr	r3, [r3, #0]
 810bec6:	68ba      	ldr	r2, [r7, #8]
 810bec8:	0151      	lsls	r1, r2, #5
 810beca:	68fa      	ldr	r2, [r7, #12]
 810becc:	440a      	add	r2, r1
 810bece:	f502 6210 	add.w	r2, r2, #2304	; 0x900
 810bed2:	f423 1300 	bic.w	r3, r3, #2097152	; 0x200000
 810bed6:	6013      	str	r3, [r2, #0]
    if ((ep->type == EP_TYPE_INTR) || (ep->type == EP_TYPE_BULK))
 810bed8:	683b      	ldr	r3, [r7, #0]
 810beda:	791b      	ldrb	r3, [r3, #4]
 810bedc:	2b03      	cmp	r3, #3
 810bede:	d003      	beq.n	810bee8 <USB_EPClearStall+0x4c>
 810bee0:	683b      	ldr	r3, [r7, #0]
 810bee2:	791b      	ldrb	r3, [r3, #4]
 810bee4:	2b02      	cmp	r3, #2
 810bee6:	d138      	bne.n	810bf5a <USB_EPClearStall+0xbe>
    {
      USBx_INEP(epnum)->DIEPCTL |= USB_OTG_DIEPCTL_SD0PID_SEVNFRM; /* DATA0 */
 810bee8:	68bb      	ldr	r3, [r7, #8]
 810beea:	015a      	lsls	r2, r3, #5
 810beec:	68fb      	ldr	r3, [r7, #12]
 810beee:	4413      	add	r3, r2
 810bef0:	f503 6310 	add.w	r3, r3, #2304	; 0x900
 810bef4:	681b      	ldr	r3, [r3, #0]
 810bef6:	68ba      	ldr	r2, [r7, #8]
 810bef8:	0151      	lsls	r1, r2, #5
 810befa:	68fa      	ldr	r2, [r7, #12]
 810befc:	440a      	add	r2, r1
 810befe:	f502 6210 	add.w	r2, r2, #2304	; 0x900
 810bf02:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 810bf06:	6013      	str	r3, [r2, #0]
 810bf08:	e027      	b.n	810bf5a <USB_EPClearStall+0xbe>
    }
  }
  else
  {
    USBx_OUTEP(epnum)->DOEPCTL &= ~USB_OTG_DOEPCTL_STALL;
 810bf0a:	68bb      	ldr	r3, [r7, #8]
 810bf0c:	015a      	lsls	r2, r3, #5
 810bf0e:	68fb      	ldr	r3, [r7, #12]
 810bf10:	4413      	add	r3, r2
 810bf12:	f503 6330 	add.w	r3, r3, #2816	; 0xb00
 810bf16:	681b      	ldr	r3, [r3, #0]
 810bf18:	68ba      	ldr	r2, [r7, #8]
 810bf1a:	0151      	lsls	r1, r2, #5
 810bf1c:	68fa      	ldr	r2, [r7, #12]
 810bf1e:	440a      	add	r2, r1
 810bf20:	f502 6230 	add.w	r2, r2, #2816	; 0xb00
 810bf24:	f423 1300 	bic.w	r3, r3, #2097152	; 0x200000
 810bf28:	6013      	str	r3, [r2, #0]
    if ((ep->type == EP_TYPE_INTR) || (ep->type == EP_TYPE_BULK))
 810bf2a:	683b      	ldr	r3, [r7, #0]
 810bf2c:	791b      	ldrb	r3, [r3, #4]
 810bf2e:	2b03      	cmp	r3, #3
 810bf30:	d003      	beq.n	810bf3a <USB_EPClearStall+0x9e>
 810bf32:	683b      	ldr	r3, [r7, #0]
 810bf34:	791b      	ldrb	r3, [r3, #4]
 810bf36:	2b02      	cmp	r3, #2
 810bf38:	d10f      	bne.n	810bf5a <USB_EPClearStall+0xbe>
    {
      USBx_OUTEP(epnum)->DOEPCTL |= USB_OTG_DOEPCTL_SD0PID_SEVNFRM; /* DATA0 */
 810bf3a:	68bb      	ldr	r3, [r7, #8]
 810bf3c:	015a      	lsls	r2, r3, #5
 810bf3e:	68fb      	ldr	r3, [r7, #12]
 810bf40:	4413      	add	r3, r2
 810bf42:	f503 6330 	add.w	r3, r3, #2816	; 0xb00
 810bf46:	681b      	ldr	r3, [r3, #0]
 810bf48:	68ba      	ldr	r2, [r7, #8]
 810bf4a:	0151      	lsls	r1, r2, #5
 810bf4c:	68fa      	ldr	r2, [r7, #12]
 810bf4e:	440a      	add	r2, r1
 810bf50:	f502 6230 	add.w	r2, r2, #2816	; 0xb00
 810bf54:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 810bf58:	6013      	str	r3, [r2, #0]
    }
  }
  return HAL_OK;
 810bf5a:	2300      	movs	r3, #0
}
 810bf5c:	4618      	mov	r0, r3
 810bf5e:	3714      	adds	r7, #20
 810bf60:	46bd      	mov	sp, r7
 810bf62:	f85d 7b04 	ldr.w	r7, [sp], #4
 810bf66:	4770      	bx	lr

0810bf68 <USB_SetDevAddress>:
  * @param  address  new device address to be assigned
  *          This parameter can be a value from 0 to 255
  * @retval HAL status
  */
HAL_StatusTypeDef USB_SetDevAddress(const USB_OTG_GlobalTypeDef *USBx, uint8_t address)
{
 810bf68:	b480      	push	{r7}
 810bf6a:	b085      	sub	sp, #20
 810bf6c:	af00      	add	r7, sp, #0
 810bf6e:	6078      	str	r0, [r7, #4]
 810bf70:	460b      	mov	r3, r1
 810bf72:	70fb      	strb	r3, [r7, #3]
  uint32_t USBx_BASE = (uint32_t)USBx;
 810bf74:	687b      	ldr	r3, [r7, #4]
 810bf76:	60fb      	str	r3, [r7, #12]

  USBx_DEVICE->DCFG &= ~(USB_OTG_DCFG_DAD);
 810bf78:	68fb      	ldr	r3, [r7, #12]
 810bf7a:	f503 6300 	add.w	r3, r3, #2048	; 0x800
 810bf7e:	681b      	ldr	r3, [r3, #0]
 810bf80:	68fa      	ldr	r2, [r7, #12]
 810bf82:	f502 6200 	add.w	r2, r2, #2048	; 0x800
 810bf86:	f423 63fe 	bic.w	r3, r3, #2032	; 0x7f0
 810bf8a:	6013      	str	r3, [r2, #0]
  USBx_DEVICE->DCFG |= ((uint32_t)address << 4) & USB_OTG_DCFG_DAD;
 810bf8c:	68fb      	ldr	r3, [r7, #12]
 810bf8e:	f503 6300 	add.w	r3, r3, #2048	; 0x800
 810bf92:	681a      	ldr	r2, [r3, #0]
 810bf94:	78fb      	ldrb	r3, [r7, #3]
 810bf96:	011b      	lsls	r3, r3, #4
 810bf98:	f403 63fe 	and.w	r3, r3, #2032	; 0x7f0
 810bf9c:	68f9      	ldr	r1, [r7, #12]
 810bf9e:	f501 6100 	add.w	r1, r1, #2048	; 0x800
 810bfa2:	4313      	orrs	r3, r2
 810bfa4:	600b      	str	r3, [r1, #0]

  return HAL_OK;
 810bfa6:	2300      	movs	r3, #0
}
 810bfa8:	4618      	mov	r0, r3
 810bfaa:	3714      	adds	r7, #20
 810bfac:	46bd      	mov	sp, r7
 810bfae:	f85d 7b04 	ldr.w	r7, [sp], #4
 810bfb2:	4770      	bx	lr

0810bfb4 <USB_DevConnect>:
  * @brief  USB_DevConnect : Connect the USB device by enabling Rpu
  * @param  USBx  Selected device
  * @retval HAL status
  */
HAL_StatusTypeDef USB_DevConnect(const USB_OTG_GlobalTypeDef *USBx)
{
 810bfb4:	b480      	push	{r7}
 810bfb6:	b085      	sub	sp, #20
 810bfb8:	af00      	add	r7, sp, #0
 810bfba:	6078      	str	r0, [r7, #4]
  uint32_t USBx_BASE = (uint32_t)USBx;
 810bfbc:	687b      	ldr	r3, [r7, #4]
 810bfbe:	60fb      	str	r3, [r7, #12]

  /* In case phy is stopped, ensure to ungate and restore the phy CLK */
  USBx_PCGCCTL &= ~(USB_OTG_PCGCCTL_STOPCLK | USB_OTG_PCGCCTL_GATECLK);
 810bfc0:	68fb      	ldr	r3, [r7, #12]
 810bfc2:	f503 6360 	add.w	r3, r3, #3584	; 0xe00
 810bfc6:	681b      	ldr	r3, [r3, #0]
 810bfc8:	68fa      	ldr	r2, [r7, #12]
 810bfca:	f502 6260 	add.w	r2, r2, #3584	; 0xe00
 810bfce:	f023 0303 	bic.w	r3, r3, #3
 810bfd2:	6013      	str	r3, [r2, #0]

  USBx_DEVICE->DCTL &= ~USB_OTG_DCTL_SDIS;
 810bfd4:	68fb      	ldr	r3, [r7, #12]
 810bfd6:	f503 6300 	add.w	r3, r3, #2048	; 0x800
 810bfda:	685b      	ldr	r3, [r3, #4]
 810bfdc:	68fa      	ldr	r2, [r7, #12]
 810bfde:	f502 6200 	add.w	r2, r2, #2048	; 0x800
 810bfe2:	f023 0302 	bic.w	r3, r3, #2
 810bfe6:	6053      	str	r3, [r2, #4]

  return HAL_OK;
 810bfe8:	2300      	movs	r3, #0
}
 810bfea:	4618      	mov	r0, r3
 810bfec:	3714      	adds	r7, #20
 810bfee:	46bd      	mov	sp, r7
 810bff0:	f85d 7b04 	ldr.w	r7, [sp], #4
 810bff4:	4770      	bx	lr

0810bff6 <USB_DevDisconnect>:
  * @brief  USB_DevDisconnect : Disconnect the USB device by disabling Rpu
  * @param  USBx  Selected device
  * @retval HAL status
  */
HAL_StatusTypeDef USB_DevDisconnect(const USB_OTG_GlobalTypeDef *USBx)
{
 810bff6:	b480      	push	{r7}
 810bff8:	b085      	sub	sp, #20
 810bffa:	af00      	add	r7, sp, #0
 810bffc:	6078      	str	r0, [r7, #4]
  uint32_t USBx_BASE = (uint32_t)USBx;
 810bffe:	687b      	ldr	r3, [r7, #4]
 810c000:	60fb      	str	r3, [r7, #12]

  /* In case phy is stopped, ensure to ungate and restore the phy CLK */
  USBx_PCGCCTL &= ~(USB_OTG_PCGCCTL_STOPCLK | USB_OTG_PCGCCTL_GATECLK);
 810c002:	68fb      	ldr	r3, [r7, #12]
 810c004:	f503 6360 	add.w	r3, r3, #3584	; 0xe00
 810c008:	681b      	ldr	r3, [r3, #0]
 810c00a:	68fa      	ldr	r2, [r7, #12]
 810c00c:	f502 6260 	add.w	r2, r2, #3584	; 0xe00
 810c010:	f023 0303 	bic.w	r3, r3, #3
 810c014:	6013      	str	r3, [r2, #0]

  USBx_DEVICE->DCTL |= USB_OTG_DCTL_SDIS;
 810c016:	68fb      	ldr	r3, [r7, #12]
 810c018:	f503 6300 	add.w	r3, r3, #2048	; 0x800
 810c01c:	685b      	ldr	r3, [r3, #4]
 810c01e:	68fa      	ldr	r2, [r7, #12]
 810c020:	f502 6200 	add.w	r2, r2, #2048	; 0x800
 810c024:	f043 0302 	orr.w	r3, r3, #2
 810c028:	6053      	str	r3, [r2, #4]

  return HAL_OK;
 810c02a:	2300      	movs	r3, #0
}
 810c02c:	4618      	mov	r0, r3
 810c02e:	3714      	adds	r7, #20
 810c030:	46bd      	mov	sp, r7
 810c032:	f85d 7b04 	ldr.w	r7, [sp], #4
 810c036:	4770      	bx	lr

0810c038 <USB_ReadInterrupts>:
  * @brief  USB_ReadInterrupts: return the global USB interrupt status
  * @param  USBx  Selected device
  * @retval USB Global Interrupt status
  */
uint32_t USB_ReadInterrupts(USB_OTG_GlobalTypeDef const *USBx)
{
 810c038:	b480      	push	{r7}
 810c03a:	b085      	sub	sp, #20
 810c03c:	af00      	add	r7, sp, #0
 810c03e:	6078      	str	r0, [r7, #4]
  uint32_t tmpreg;

  tmpreg = USBx->GINTSTS;
 810c040:	687b      	ldr	r3, [r7, #4]
 810c042:	695b      	ldr	r3, [r3, #20]
 810c044:	60fb      	str	r3, [r7, #12]
  tmpreg &= USBx->GINTMSK;
 810c046:	687b      	ldr	r3, [r7, #4]
 810c048:	699b      	ldr	r3, [r3, #24]
 810c04a:	68fa      	ldr	r2, [r7, #12]
 810c04c:	4013      	ands	r3, r2
 810c04e:	60fb      	str	r3, [r7, #12]

  return tmpreg;
 810c050:	68fb      	ldr	r3, [r7, #12]
}
 810c052:	4618      	mov	r0, r3
 810c054:	3714      	adds	r7, #20
 810c056:	46bd      	mov	sp, r7
 810c058:	f85d 7b04 	ldr.w	r7, [sp], #4
 810c05c:	4770      	bx	lr

0810c05e <USB_ReadDevAllOutEpInterrupt>:
  * @brief  USB_ReadDevAllOutEpInterrupt: return the USB device OUT endpoints interrupt status
  * @param  USBx  Selected device
  * @retval USB Device OUT EP interrupt status
  */
uint32_t USB_ReadDevAllOutEpInterrupt(const USB_OTG_GlobalTypeDef *USBx)
{
 810c05e:	b480      	push	{r7}
 810c060:	b085      	sub	sp, #20
 810c062:	af00      	add	r7, sp, #0
 810c064:	6078      	str	r0, [r7, #4]
  uint32_t USBx_BASE = (uint32_t)USBx;
 810c066:	687b      	ldr	r3, [r7, #4]
 810c068:	60fb      	str	r3, [r7, #12]
  uint32_t tmpreg;

  tmpreg  = USBx_DEVICE->DAINT;
 810c06a:	68fb      	ldr	r3, [r7, #12]
 810c06c:	f503 6300 	add.w	r3, r3, #2048	; 0x800
 810c070:	699b      	ldr	r3, [r3, #24]
 810c072:	60bb      	str	r3, [r7, #8]
  tmpreg &= USBx_DEVICE->DAINTMSK;
 810c074:	68fb      	ldr	r3, [r7, #12]
 810c076:	f503 6300 	add.w	r3, r3, #2048	; 0x800
 810c07a:	69db      	ldr	r3, [r3, #28]
 810c07c:	68ba      	ldr	r2, [r7, #8]
 810c07e:	4013      	ands	r3, r2
 810c080:	60bb      	str	r3, [r7, #8]

  return ((tmpreg & 0xffff0000U) >> 16);
 810c082:	68bb      	ldr	r3, [r7, #8]
 810c084:	0c1b      	lsrs	r3, r3, #16
}
 810c086:	4618      	mov	r0, r3
 810c088:	3714      	adds	r7, #20
 810c08a:	46bd      	mov	sp, r7
 810c08c:	f85d 7b04 	ldr.w	r7, [sp], #4
 810c090:	4770      	bx	lr

0810c092 <USB_ReadDevAllInEpInterrupt>:
  * @brief  USB_ReadDevAllInEpInterrupt: return the USB device IN endpoints interrupt status
  * @param  USBx  Selected device
  * @retval USB Device IN EP interrupt status
  */
uint32_t USB_ReadDevAllInEpInterrupt(const USB_OTG_GlobalTypeDef *USBx)
{
 810c092:	b480      	push	{r7}
 810c094:	b085      	sub	sp, #20
 810c096:	af00      	add	r7, sp, #0
 810c098:	6078      	str	r0, [r7, #4]
  uint32_t USBx_BASE = (uint32_t)USBx;
 810c09a:	687b      	ldr	r3, [r7, #4]
 810c09c:	60fb      	str	r3, [r7, #12]
  uint32_t tmpreg;

  tmpreg  = USBx_DEVICE->DAINT;
 810c09e:	68fb      	ldr	r3, [r7, #12]
 810c0a0:	f503 6300 	add.w	r3, r3, #2048	; 0x800
 810c0a4:	699b      	ldr	r3, [r3, #24]
 810c0a6:	60bb      	str	r3, [r7, #8]
  tmpreg &= USBx_DEVICE->DAINTMSK;
 810c0a8:	68fb      	ldr	r3, [r7, #12]
 810c0aa:	f503 6300 	add.w	r3, r3, #2048	; 0x800
 810c0ae:	69db      	ldr	r3, [r3, #28]
 810c0b0:	68ba      	ldr	r2, [r7, #8]
 810c0b2:	4013      	ands	r3, r2
 810c0b4:	60bb      	str	r3, [r7, #8]

  return ((tmpreg & 0xFFFFU));
 810c0b6:	68bb      	ldr	r3, [r7, #8]
 810c0b8:	b29b      	uxth	r3, r3
}
 810c0ba:	4618      	mov	r0, r3
 810c0bc:	3714      	adds	r7, #20
 810c0be:	46bd      	mov	sp, r7
 810c0c0:	f85d 7b04 	ldr.w	r7, [sp], #4
 810c0c4:	4770      	bx	lr

0810c0c6 <USB_ReadDevOutEPInterrupt>:
  * @param  epnum  endpoint number
  *          This parameter can be a value from 0 to 15
  * @retval Device OUT EP Interrupt register
  */
uint32_t USB_ReadDevOutEPInterrupt(const USB_OTG_GlobalTypeDef *USBx, uint8_t epnum)
{
 810c0c6:	b480      	push	{r7}
 810c0c8:	b085      	sub	sp, #20
 810c0ca:	af00      	add	r7, sp, #0
 810c0cc:	6078      	str	r0, [r7, #4]
 810c0ce:	460b      	mov	r3, r1
 810c0d0:	70fb      	strb	r3, [r7, #3]
  uint32_t USBx_BASE = (uint32_t)USBx;
 810c0d2:	687b      	ldr	r3, [r7, #4]
 810c0d4:	60fb      	str	r3, [r7, #12]
  uint32_t tmpreg;

  tmpreg  = USBx_OUTEP((uint32_t)epnum)->DOEPINT;
 810c0d6:	78fb      	ldrb	r3, [r7, #3]
 810c0d8:	015a      	lsls	r2, r3, #5
 810c0da:	68fb      	ldr	r3, [r7, #12]
 810c0dc:	4413      	add	r3, r2
 810c0de:	f503 6330 	add.w	r3, r3, #2816	; 0xb00
 810c0e2:	689b      	ldr	r3, [r3, #8]
 810c0e4:	60bb      	str	r3, [r7, #8]
  tmpreg &= USBx_DEVICE->DOEPMSK;
 810c0e6:	68fb      	ldr	r3, [r7, #12]
 810c0e8:	f503 6300 	add.w	r3, r3, #2048	; 0x800
 810c0ec:	695b      	ldr	r3, [r3, #20]
 810c0ee:	68ba      	ldr	r2, [r7, #8]
 810c0f0:	4013      	ands	r3, r2
 810c0f2:	60bb      	str	r3, [r7, #8]

  return tmpreg;
 810c0f4:	68bb      	ldr	r3, [r7, #8]
}
 810c0f6:	4618      	mov	r0, r3
 810c0f8:	3714      	adds	r7, #20
 810c0fa:	46bd      	mov	sp, r7
 810c0fc:	f85d 7b04 	ldr.w	r7, [sp], #4
 810c100:	4770      	bx	lr

0810c102 <USB_ReadDevInEPInterrupt>:
  * @param  epnum  endpoint number
  *          This parameter can be a value from 0 to 15
  * @retval Device IN EP Interrupt register
  */
uint32_t USB_ReadDevInEPInterrupt(const USB_OTG_GlobalTypeDef *USBx, uint8_t epnum)
{
 810c102:	b480      	push	{r7}
 810c104:	b087      	sub	sp, #28
 810c106:	af00      	add	r7, sp, #0
 810c108:	6078      	str	r0, [r7, #4]
 810c10a:	460b      	mov	r3, r1
 810c10c:	70fb      	strb	r3, [r7, #3]
  uint32_t USBx_BASE = (uint32_t)USBx;
 810c10e:	687b      	ldr	r3, [r7, #4]
 810c110:	617b      	str	r3, [r7, #20]
  uint32_t tmpreg;
  uint32_t msk;
  uint32_t emp;

  msk = USBx_DEVICE->DIEPMSK;
 810c112:	697b      	ldr	r3, [r7, #20]
 810c114:	f503 6300 	add.w	r3, r3, #2048	; 0x800
 810c118:	691b      	ldr	r3, [r3, #16]
 810c11a:	613b      	str	r3, [r7, #16]
  emp = USBx_DEVICE->DIEPEMPMSK;
 810c11c:	697b      	ldr	r3, [r7, #20]
 810c11e:	f503 6300 	add.w	r3, r3, #2048	; 0x800
 810c122:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 810c124:	60fb      	str	r3, [r7, #12]
  msk |= ((emp >> (epnum & EP_ADDR_MSK)) & 0x1U) << 7;
 810c126:	78fb      	ldrb	r3, [r7, #3]
 810c128:	f003 030f 	and.w	r3, r3, #15
 810c12c:	68fa      	ldr	r2, [r7, #12]
 810c12e:	fa22 f303 	lsr.w	r3, r2, r3
 810c132:	01db      	lsls	r3, r3, #7
 810c134:	b2db      	uxtb	r3, r3
 810c136:	693a      	ldr	r2, [r7, #16]
 810c138:	4313      	orrs	r3, r2
 810c13a:	613b      	str	r3, [r7, #16]
  tmpreg = USBx_INEP((uint32_t)epnum)->DIEPINT & msk;
 810c13c:	78fb      	ldrb	r3, [r7, #3]
 810c13e:	015a      	lsls	r2, r3, #5
 810c140:	697b      	ldr	r3, [r7, #20]
 810c142:	4413      	add	r3, r2
 810c144:	f503 6310 	add.w	r3, r3, #2304	; 0x900
 810c148:	689b      	ldr	r3, [r3, #8]
 810c14a:	693a      	ldr	r2, [r7, #16]
 810c14c:	4013      	ands	r3, r2
 810c14e:	60bb      	str	r3, [r7, #8]

  return tmpreg;
 810c150:	68bb      	ldr	r3, [r7, #8]
}
 810c152:	4618      	mov	r0, r3
 810c154:	371c      	adds	r7, #28
 810c156:	46bd      	mov	sp, r7
 810c158:	f85d 7b04 	ldr.w	r7, [sp], #4
 810c15c:	4770      	bx	lr

0810c15e <USB_GetMode>:
  *          This parameter can be one of these values:
  *           0 : Host
  *           1 : Device
  */
uint32_t USB_GetMode(const USB_OTG_GlobalTypeDef *USBx)
{
 810c15e:	b480      	push	{r7}
 810c160:	b083      	sub	sp, #12
 810c162:	af00      	add	r7, sp, #0
 810c164:	6078      	str	r0, [r7, #4]
  return ((USBx->GINTSTS) & 0x1U);
 810c166:	687b      	ldr	r3, [r7, #4]
 810c168:	695b      	ldr	r3, [r3, #20]
 810c16a:	f003 0301 	and.w	r3, r3, #1
}
 810c16e:	4618      	mov	r0, r3
 810c170:	370c      	adds	r7, #12
 810c172:	46bd      	mov	sp, r7
 810c174:	f85d 7b04 	ldr.w	r7, [sp], #4
 810c178:	4770      	bx	lr

0810c17a <USB_ActivateSetup>:
  * @brief  Activate EP0 for Setup transactions
  * @param  USBx  Selected device
  * @retval HAL status
  */
HAL_StatusTypeDef USB_ActivateSetup(const USB_OTG_GlobalTypeDef *USBx)
{
 810c17a:	b480      	push	{r7}
 810c17c:	b085      	sub	sp, #20
 810c17e:	af00      	add	r7, sp, #0
 810c180:	6078      	str	r0, [r7, #4]
  uint32_t USBx_BASE = (uint32_t)USBx;
 810c182:	687b      	ldr	r3, [r7, #4]
 810c184:	60fb      	str	r3, [r7, #12]

  /* Set the MPS of the IN EP0 to 64 bytes */
  USBx_INEP(0U)->DIEPCTL &= ~USB_OTG_DIEPCTL_MPSIZ;
 810c186:	68fb      	ldr	r3, [r7, #12]
 810c188:	f503 6310 	add.w	r3, r3, #2304	; 0x900
 810c18c:	681b      	ldr	r3, [r3, #0]
 810c18e:	68fa      	ldr	r2, [r7, #12]
 810c190:	f502 6210 	add.w	r2, r2, #2304	; 0x900
 810c194:	f423 63ff 	bic.w	r3, r3, #2040	; 0x7f8
 810c198:	f023 0307 	bic.w	r3, r3, #7
 810c19c:	6013      	str	r3, [r2, #0]

  USBx_DEVICE->DCTL |= USB_OTG_DCTL_CGINAK;
 810c19e:	68fb      	ldr	r3, [r7, #12]
 810c1a0:	f503 6300 	add.w	r3, r3, #2048	; 0x800
 810c1a4:	685b      	ldr	r3, [r3, #4]
 810c1a6:	68fa      	ldr	r2, [r7, #12]
 810c1a8:	f502 6200 	add.w	r2, r2, #2048	; 0x800
 810c1ac:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 810c1b0:	6053      	str	r3, [r2, #4]

  return HAL_OK;
 810c1b2:	2300      	movs	r3, #0
}
 810c1b4:	4618      	mov	r0, r3
 810c1b6:	3714      	adds	r7, #20
 810c1b8:	46bd      	mov	sp, r7
 810c1ba:	f85d 7b04 	ldr.w	r7, [sp], #4
 810c1be:	4770      	bx	lr

0810c1c0 <USB_EP0_OutStart>:
  *           1 : DMA feature used
  * @param  psetup  pointer to setup packet
  * @retval HAL status
  */
HAL_StatusTypeDef USB_EP0_OutStart(const USB_OTG_GlobalTypeDef *USBx, uint8_t dma, const uint8_t *psetup)
{
 810c1c0:	b480      	push	{r7}
 810c1c2:	b087      	sub	sp, #28
 810c1c4:	af00      	add	r7, sp, #0
 810c1c6:	60f8      	str	r0, [r7, #12]
 810c1c8:	460b      	mov	r3, r1
 810c1ca:	607a      	str	r2, [r7, #4]
 810c1cc:	72fb      	strb	r3, [r7, #11]
  uint32_t USBx_BASE = (uint32_t)USBx;
 810c1ce:	68fb      	ldr	r3, [r7, #12]
 810c1d0:	617b      	str	r3, [r7, #20]
  uint32_t gSNPSiD = *(__IO const uint32_t *)(&USBx->CID + 0x1U);
 810c1d2:	68fb      	ldr	r3, [r7, #12]
 810c1d4:	333c      	adds	r3, #60	; 0x3c
 810c1d6:	3304      	adds	r3, #4
 810c1d8:	681b      	ldr	r3, [r3, #0]
 810c1da:	613b      	str	r3, [r7, #16]

  if (gSNPSiD > USB_OTG_CORE_ID_300A)
 810c1dc:	693b      	ldr	r3, [r7, #16]
 810c1de:	4a26      	ldr	r2, [pc, #152]	; (810c278 <USB_EP0_OutStart+0xb8>)
 810c1e0:	4293      	cmp	r3, r2
 810c1e2:	d90a      	bls.n	810c1fa <USB_EP0_OutStart+0x3a>
  {
    if ((USBx_OUTEP(0U)->DOEPCTL & USB_OTG_DOEPCTL_EPENA) == USB_OTG_DOEPCTL_EPENA)
 810c1e4:	697b      	ldr	r3, [r7, #20]
 810c1e6:	f503 6330 	add.w	r3, r3, #2816	; 0xb00
 810c1ea:	681b      	ldr	r3, [r3, #0]
 810c1ec:	f003 4300 	and.w	r3, r3, #2147483648	; 0x80000000
 810c1f0:	f1b3 4f00 	cmp.w	r3, #2147483648	; 0x80000000
 810c1f4:	d101      	bne.n	810c1fa <USB_EP0_OutStart+0x3a>
    {
      return HAL_OK;
 810c1f6:	2300      	movs	r3, #0
 810c1f8:	e037      	b.n	810c26a <USB_EP0_OutStart+0xaa>
    }
  }

  USBx_OUTEP(0U)->DOEPTSIZ = 0U;
 810c1fa:	697b      	ldr	r3, [r7, #20]
 810c1fc:	f503 6330 	add.w	r3, r3, #2816	; 0xb00
 810c200:	461a      	mov	r2, r3
 810c202:	2300      	movs	r3, #0
 810c204:	6113      	str	r3, [r2, #16]
  USBx_OUTEP(0U)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_PKTCNT & (1U << 19));
 810c206:	697b      	ldr	r3, [r7, #20]
 810c208:	f503 6330 	add.w	r3, r3, #2816	; 0xb00
 810c20c:	691b      	ldr	r3, [r3, #16]
 810c20e:	697a      	ldr	r2, [r7, #20]
 810c210:	f502 6230 	add.w	r2, r2, #2816	; 0xb00
 810c214:	f443 2300 	orr.w	r3, r3, #524288	; 0x80000
 810c218:	6113      	str	r3, [r2, #16]
  USBx_OUTEP(0U)->DOEPTSIZ |= (3U * 8U);
 810c21a:	697b      	ldr	r3, [r7, #20]
 810c21c:	f503 6330 	add.w	r3, r3, #2816	; 0xb00
 810c220:	691b      	ldr	r3, [r3, #16]
 810c222:	697a      	ldr	r2, [r7, #20]
 810c224:	f502 6230 	add.w	r2, r2, #2816	; 0xb00
 810c228:	f043 0318 	orr.w	r3, r3, #24
 810c22c:	6113      	str	r3, [r2, #16]
  USBx_OUTEP(0U)->DOEPTSIZ |=  USB_OTG_DOEPTSIZ_STUPCNT;
 810c22e:	697b      	ldr	r3, [r7, #20]
 810c230:	f503 6330 	add.w	r3, r3, #2816	; 0xb00
 810c234:	691b      	ldr	r3, [r3, #16]
 810c236:	697a      	ldr	r2, [r7, #20]
 810c238:	f502 6230 	add.w	r2, r2, #2816	; 0xb00
 810c23c:	f043 43c0 	orr.w	r3, r3, #1610612736	; 0x60000000
 810c240:	6113      	str	r3, [r2, #16]

  if (dma == 1U)
 810c242:	7afb      	ldrb	r3, [r7, #11]
 810c244:	2b01      	cmp	r3, #1
 810c246:	d10f      	bne.n	810c268 <USB_EP0_OutStart+0xa8>
  {
    USBx_OUTEP(0U)->DOEPDMA = (uint32_t)psetup;
 810c248:	697b      	ldr	r3, [r7, #20]
 810c24a:	f503 6330 	add.w	r3, r3, #2816	; 0xb00
 810c24e:	461a      	mov	r2, r3
 810c250:	687b      	ldr	r3, [r7, #4]
 810c252:	6153      	str	r3, [r2, #20]
    /* EP enable */
    USBx_OUTEP(0U)->DOEPCTL |= USB_OTG_DOEPCTL_EPENA | USB_OTG_DOEPCTL_USBAEP;
 810c254:	697b      	ldr	r3, [r7, #20]
 810c256:	f503 6330 	add.w	r3, r3, #2816	; 0xb00
 810c25a:	681b      	ldr	r3, [r3, #0]
 810c25c:	697a      	ldr	r2, [r7, #20]
 810c25e:	f502 6230 	add.w	r2, r2, #2816	; 0xb00
 810c262:	f043 2380 	orr.w	r3, r3, #2147516416	; 0x80008000
 810c266:	6013      	str	r3, [r2, #0]
  }

  return HAL_OK;
 810c268:	2300      	movs	r3, #0
}
 810c26a:	4618      	mov	r0, r3
 810c26c:	371c      	adds	r7, #28
 810c26e:	46bd      	mov	sp, r7
 810c270:	f85d 7b04 	ldr.w	r7, [sp], #4
 810c274:	4770      	bx	lr
 810c276:	bf00      	nop
 810c278:	4f54300a 	.word	0x4f54300a

0810c27c <USB_CoreReset>:
  * @brief  Reset the USB Core (needed after USB clock settings change)
  * @param  USBx  Selected device
  * @retval HAL status
  */
static HAL_StatusTypeDef USB_CoreReset(USB_OTG_GlobalTypeDef *USBx)
{
 810c27c:	b480      	push	{r7}
 810c27e:	b085      	sub	sp, #20
 810c280:	af00      	add	r7, sp, #0
 810c282:	6078      	str	r0, [r7, #4]
  __IO uint32_t count = 0U;
 810c284:	2300      	movs	r3, #0
 810c286:	60fb      	str	r3, [r7, #12]

  /* Wait for AHB master IDLE state. */
  do
  {
    count++;
 810c288:	68fb      	ldr	r3, [r7, #12]
 810c28a:	3301      	adds	r3, #1
 810c28c:	60fb      	str	r3, [r7, #12]

    if (count > HAL_USB_TIMEOUT)
 810c28e:	68fb      	ldr	r3, [r7, #12]
 810c290:	f1b3 6f70 	cmp.w	r3, #251658240	; 0xf000000
 810c294:	d901      	bls.n	810c29a <USB_CoreReset+0x1e>
    {
      return HAL_TIMEOUT;
 810c296:	2303      	movs	r3, #3
 810c298:	e01b      	b.n	810c2d2 <USB_CoreReset+0x56>
    }
  } while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_AHBIDL) == 0U);
 810c29a:	687b      	ldr	r3, [r7, #4]
 810c29c:	691b      	ldr	r3, [r3, #16]
 810c29e:	2b00      	cmp	r3, #0
 810c2a0:	daf2      	bge.n	810c288 <USB_CoreReset+0xc>

  /* Core Soft Reset */
  count = 0U;
 810c2a2:	2300      	movs	r3, #0
 810c2a4:	60fb      	str	r3, [r7, #12]
  USBx->GRSTCTL |= USB_OTG_GRSTCTL_CSRST;
 810c2a6:	687b      	ldr	r3, [r7, #4]
 810c2a8:	691b      	ldr	r3, [r3, #16]
 810c2aa:	f043 0201 	orr.w	r2, r3, #1
 810c2ae:	687b      	ldr	r3, [r7, #4]
 810c2b0:	611a      	str	r2, [r3, #16]

  do
  {
    count++;
 810c2b2:	68fb      	ldr	r3, [r7, #12]
 810c2b4:	3301      	adds	r3, #1
 810c2b6:	60fb      	str	r3, [r7, #12]

    if (count > HAL_USB_TIMEOUT)
 810c2b8:	68fb      	ldr	r3, [r7, #12]
 810c2ba:	f1b3 6f70 	cmp.w	r3, #251658240	; 0xf000000
 810c2be:	d901      	bls.n	810c2c4 <USB_CoreReset+0x48>
    {
      return HAL_TIMEOUT;
 810c2c0:	2303      	movs	r3, #3
 810c2c2:	e006      	b.n	810c2d2 <USB_CoreReset+0x56>
    }
  } while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_CSRST) == USB_OTG_GRSTCTL_CSRST);
 810c2c4:	687b      	ldr	r3, [r7, #4]
 810c2c6:	691b      	ldr	r3, [r3, #16]
 810c2c8:	f003 0301 	and.w	r3, r3, #1
 810c2cc:	2b01      	cmp	r3, #1
 810c2ce:	d0f0      	beq.n	810c2b2 <USB_CoreReset+0x36>

  return HAL_OK;
 810c2d0:	2300      	movs	r3, #0
}
 810c2d2:	4618      	mov	r0, r3
 810c2d4:	3714      	adds	r7, #20
 810c2d6:	46bd      	mov	sp, r7
 810c2d8:	f85d 7b04 	ldr.w	r7, [sp], #4
 810c2dc:	4770      	bx	lr
	...

0810c2e0 <MX_LWIP_Init>:

/**
  * LwIP initialization function
  */
void MX_LWIP_Init(void)
{
 810c2e0:	b580      	push	{r7, lr}
 810c2e2:	b084      	sub	sp, #16
 810c2e4:	af04      	add	r7, sp, #16
  /* Initialize the LwIP stack without RTOS */
  lwip_init();
 810c2e6:	f005 fd69 	bl	8111dbc <lwip_init>

  /* IP addresses initialization with DHCP (IPv4) */
  ipaddr.addr = 0;
 810c2ea:	4b12      	ldr	r3, [pc, #72]	; (810c334 <MX_LWIP_Init+0x54>)
 810c2ec:	2200      	movs	r2, #0
 810c2ee:	601a      	str	r2, [r3, #0]
  netmask.addr = 0;
 810c2f0:	4b11      	ldr	r3, [pc, #68]	; (810c338 <MX_LWIP_Init+0x58>)
 810c2f2:	2200      	movs	r2, #0
 810c2f4:	601a      	str	r2, [r3, #0]
  gw.addr = 0;
 810c2f6:	4b11      	ldr	r3, [pc, #68]	; (810c33c <MX_LWIP_Init+0x5c>)
 810c2f8:	2200      	movs	r2, #0
 810c2fa:	601a      	str	r2, [r3, #0]

  /* add the network interface (IPv4/IPv6) without RTOS */
  netif_add(&gnetif, &ipaddr, &netmask, &gw, NULL, &ethernetif_init, &ethernet_input);
 810c2fc:	4b10      	ldr	r3, [pc, #64]	; (810c340 <MX_LWIP_Init+0x60>)
 810c2fe:	9302      	str	r3, [sp, #8]
 810c300:	4b10      	ldr	r3, [pc, #64]	; (810c344 <MX_LWIP_Init+0x64>)
 810c302:	9301      	str	r3, [sp, #4]
 810c304:	2300      	movs	r3, #0
 810c306:	9300      	str	r3, [sp, #0]
 810c308:	4b0c      	ldr	r3, [pc, #48]	; (810c33c <MX_LWIP_Init+0x5c>)
 810c30a:	4a0b      	ldr	r2, [pc, #44]	; (810c338 <MX_LWIP_Init+0x58>)
 810c30c:	4909      	ldr	r1, [pc, #36]	; (810c334 <MX_LWIP_Init+0x54>)
 810c30e:	480e      	ldr	r0, [pc, #56]	; (810c348 <MX_LWIP_Init+0x68>)
 810c310:	f007 fb72 	bl	81139f8 <netif_add>

  /* Registers the default network interface */
  netif_set_default(&gnetif);
 810c314:	480c      	ldr	r0, [pc, #48]	; (810c348 <MX_LWIP_Init+0x68>)
 810c316:	f007 fd29 	bl	8113d6c <netif_set_default>

  /* We must always bring the network interface up connection or not... */
  netif_set_up(&gnetif);
 810c31a:	480b      	ldr	r0, [pc, #44]	; (810c348 <MX_LWIP_Init+0x68>)
 810c31c:	f007 fd36 	bl	8113d8c <netif_set_up>

  /* Set the link callback function, this function is called on change of link status*/
  netif_set_link_callback(&gnetif, ethernet_link_status_updated);
 810c320:	490a      	ldr	r1, [pc, #40]	; (810c34c <MX_LWIP_Init+0x6c>)
 810c322:	4809      	ldr	r0, [pc, #36]	; (810c348 <MX_LWIP_Init+0x68>)
 810c324:	f007 fe38 	bl	8113f98 <netif_set_link_callback>

  /* Start DHCP negotiation for a network interface (IPv4) */
  dhcp_start(&gnetif);
 810c328:	4807      	ldr	r0, [pc, #28]	; (810c348 <MX_LWIP_Init+0x68>)
 810c32a:	f002 fc7d 	bl	810ec28 <dhcp_start>

/* USER CODE BEGIN 3 */

/* USER CODE END 3 */
}
 810c32e:	bf00      	nop
 810c330:	46bd      	mov	sp, r7
 810c332:	bd80      	pop	{r7, pc}
 810c334:	10000490 	.word	0x10000490
 810c338:	10000494 	.word	0x10000494
 810c33c:	10000498 	.word	0x10000498
 810c340:	08111731 	.word	0x08111731
 810c344:	0810c595 	.word	0x0810c595
 810c348:	10000458 	.word	0x10000458
 810c34c:	0810c351 	.word	0x0810c351

0810c350 <ethernet_link_status_updated>:
  * @brief  Notify the User about the network interface config status
  * @param  netif: the network interface
  * @retval None
  */
static void ethernet_link_status_updated(struct netif *netif)
{
 810c350:	b480      	push	{r7}
 810c352:	b083      	sub	sp, #12
 810c354:	af00      	add	r7, sp, #0
 810c356:	6078      	str	r0, [r7, #4]
  else /* netif is down */
  {
/* USER CODE BEGIN 6 */
/* USER CODE END 6 */
  }
}
 810c358:	bf00      	nop
 810c35a:	370c      	adds	r7, #12
 810c35c:	46bd      	mov	sp, r7
 810c35e:	f85d 7b04 	ldr.w	r7, [sp], #4
 810c362:	4770      	bx	lr

0810c364 <low_level_init>:
 *
 * @param netif the already initialized lwip network interface structure
 *        for this ethernetif
 */
static void low_level_init(struct netif *netif)
{
 810c364:	b580      	push	{r7, lr}
 810c366:	b084      	sub	sp, #16
 810c368:	af00      	add	r7, sp, #0
 810c36a:	6078      	str	r0, [r7, #4]
  HAL_StatusTypeDef hal_eth_init_status = HAL_OK;
 810c36c:	2300      	movs	r3, #0
 810c36e:	73fb      	strb	r3, [r7, #15]
  /* Start ETH HAL Init */

   uint8_t MACAddr[6] ;
  heth.Instance = ETH;
 810c370:	4b3f      	ldr	r3, [pc, #252]	; (810c470 <low_level_init+0x10c>)
 810c372:	4a40      	ldr	r2, [pc, #256]	; (810c474 <low_level_init+0x110>)
 810c374:	601a      	str	r2, [r3, #0]
  MACAddr[0] = 0x00;
 810c376:	2300      	movs	r3, #0
 810c378:	723b      	strb	r3, [r7, #8]
  MACAddr[1] = 0x80;
 810c37a:	2380      	movs	r3, #128	; 0x80
 810c37c:	727b      	strb	r3, [r7, #9]
  MACAddr[2] = 0xE1;
 810c37e:	23e1      	movs	r3, #225	; 0xe1
 810c380:	72bb      	strb	r3, [r7, #10]
  MACAddr[3] = 0x00;
 810c382:	2300      	movs	r3, #0
 810c384:	72fb      	strb	r3, [r7, #11]
  MACAddr[4] = 0x00;
 810c386:	2300      	movs	r3, #0
 810c388:	733b      	strb	r3, [r7, #12]
  MACAddr[5] = 0x00;
 810c38a:	2300      	movs	r3, #0
 810c38c:	737b      	strb	r3, [r7, #13]
  heth.Init.MACAddr = &MACAddr[0];
 810c38e:	4a38      	ldr	r2, [pc, #224]	; (810c470 <low_level_init+0x10c>)
 810c390:	f107 0308 	add.w	r3, r7, #8
 810c394:	6053      	str	r3, [r2, #4]
  heth.Init.MediaInterface = HAL_ETH_RMII_MODE;
 810c396:	4b36      	ldr	r3, [pc, #216]	; (810c470 <low_level_init+0x10c>)
 810c398:	2201      	movs	r2, #1
 810c39a:	721a      	strb	r2, [r3, #8]
  heth.Init.TxDesc = DMATxDscrTab;
 810c39c:	4b34      	ldr	r3, [pc, #208]	; (810c470 <low_level_init+0x10c>)
 810c39e:	4a36      	ldr	r2, [pc, #216]	; (810c478 <low_level_init+0x114>)
 810c3a0:	60da      	str	r2, [r3, #12]
  heth.Init.RxDesc = DMARxDscrTab;
 810c3a2:	4b33      	ldr	r3, [pc, #204]	; (810c470 <low_level_init+0x10c>)
 810c3a4:	4a35      	ldr	r2, [pc, #212]	; (810c47c <low_level_init+0x118>)
 810c3a6:	611a      	str	r2, [r3, #16]
  heth.Init.RxBuffLen = 1536;
 810c3a8:	4b31      	ldr	r3, [pc, #196]	; (810c470 <low_level_init+0x10c>)
 810c3aa:	f44f 62c0 	mov.w	r2, #1536	; 0x600
 810c3ae:	615a      	str	r2, [r3, #20]

  /* USER CODE BEGIN MACADDRESS */

  /* USER CODE END MACADDRESS */

  hal_eth_init_status = HAL_ETH_Init(&heth);
 810c3b0:	482f      	ldr	r0, [pc, #188]	; (810c470 <low_level_init+0x10c>)
 810c3b2:	f7f7 f90d 	bl	81035d0 <HAL_ETH_Init>
 810c3b6:	4603      	mov	r3, r0
 810c3b8:	73fb      	strb	r3, [r7, #15]

  memset(&TxConfig, 0 , sizeof(ETH_TxPacketConfig));
 810c3ba:	2238      	movs	r2, #56	; 0x38
 810c3bc:	2100      	movs	r1, #0
 810c3be:	4830      	ldr	r0, [pc, #192]	; (810c480 <low_level_init+0x11c>)
 810c3c0:	f00f fa48 	bl	811b854 <memset>
  TxConfig.Attributes = ETH_TX_PACKETS_FEATURES_CSUM | ETH_TX_PACKETS_FEATURES_CRCPAD;
 810c3c4:	4b2e      	ldr	r3, [pc, #184]	; (810c480 <low_level_init+0x11c>)
 810c3c6:	2221      	movs	r2, #33	; 0x21
 810c3c8:	601a      	str	r2, [r3, #0]
  TxConfig.ChecksumCtrl = ETH_CHECKSUM_IPHDR_PAYLOAD_INSERT_PHDR_CALC;
 810c3ca:	4b2d      	ldr	r3, [pc, #180]	; (810c480 <low_level_init+0x11c>)
 810c3cc:	f44f 3240 	mov.w	r2, #196608	; 0x30000
 810c3d0:	615a      	str	r2, [r3, #20]
  TxConfig.CRCPadCtrl = ETH_CRC_PAD_INSERT;
 810c3d2:	4b2b      	ldr	r3, [pc, #172]	; (810c480 <low_level_init+0x11c>)
 810c3d4:	2200      	movs	r2, #0
 810c3d6:	611a      	str	r2, [r3, #16]

  /* End ETH HAL Init */

  /* Initialize the RX POOL */
  LWIP_MEMPOOL_INIT(RX_POOL);
 810c3d8:	482a      	ldr	r0, [pc, #168]	; (810c484 <low_level_init+0x120>)
 810c3da:	f007 f9d5 	bl	8113788 <memp_init_pool>

#if LWIP_ARP || LWIP_ETHERNET

  /* set MAC hardware address length */
  netif->hwaddr_len = ETH_HWADDR_LEN;
 810c3de:	687b      	ldr	r3, [r7, #4]
 810c3e0:	2206      	movs	r2, #6
 810c3e2:	f883 2030 	strb.w	r2, [r3, #48]	; 0x30

  /* set MAC hardware address */
  netif->hwaddr[0] =  heth.Init.MACAddr[0];
 810c3e6:	4b22      	ldr	r3, [pc, #136]	; (810c470 <low_level_init+0x10c>)
 810c3e8:	685b      	ldr	r3, [r3, #4]
 810c3ea:	781a      	ldrb	r2, [r3, #0]
 810c3ec:	687b      	ldr	r3, [r7, #4]
 810c3ee:	f883 202a 	strb.w	r2, [r3, #42]	; 0x2a
  netif->hwaddr[1] =  heth.Init.MACAddr[1];
 810c3f2:	4b1f      	ldr	r3, [pc, #124]	; (810c470 <low_level_init+0x10c>)
 810c3f4:	685b      	ldr	r3, [r3, #4]
 810c3f6:	785a      	ldrb	r2, [r3, #1]
 810c3f8:	687b      	ldr	r3, [r7, #4]
 810c3fa:	f883 202b 	strb.w	r2, [r3, #43]	; 0x2b
  netif->hwaddr[2] =  heth.Init.MACAddr[2];
 810c3fe:	4b1c      	ldr	r3, [pc, #112]	; (810c470 <low_level_init+0x10c>)
 810c400:	685b      	ldr	r3, [r3, #4]
 810c402:	789a      	ldrb	r2, [r3, #2]
 810c404:	687b      	ldr	r3, [r7, #4]
 810c406:	f883 202c 	strb.w	r2, [r3, #44]	; 0x2c
  netif->hwaddr[3] =  heth.Init.MACAddr[3];
 810c40a:	4b19      	ldr	r3, [pc, #100]	; (810c470 <low_level_init+0x10c>)
 810c40c:	685b      	ldr	r3, [r3, #4]
 810c40e:	78da      	ldrb	r2, [r3, #3]
 810c410:	687b      	ldr	r3, [r7, #4]
 810c412:	f883 202d 	strb.w	r2, [r3, #45]	; 0x2d
  netif->hwaddr[4] =  heth.Init.MACAddr[4];
 810c416:	4b16      	ldr	r3, [pc, #88]	; (810c470 <low_level_init+0x10c>)
 810c418:	685b      	ldr	r3, [r3, #4]
 810c41a:	791a      	ldrb	r2, [r3, #4]
 810c41c:	687b      	ldr	r3, [r7, #4]
 810c41e:	f883 202e 	strb.w	r2, [r3, #46]	; 0x2e
  netif->hwaddr[5] =  heth.Init.MACAddr[5];
 810c422:	4b13      	ldr	r3, [pc, #76]	; (810c470 <low_level_init+0x10c>)
 810c424:	685b      	ldr	r3, [r3, #4]
 810c426:	795a      	ldrb	r2, [r3, #5]
 810c428:	687b      	ldr	r3, [r7, #4]
 810c42a:	f883 202f 	strb.w	r2, [r3, #47]	; 0x2f

  /* maximum transfer unit */
  netif->mtu = ETH_MAX_PAYLOAD;
 810c42e:	687b      	ldr	r3, [r7, #4]
 810c430:	f240 52dc 	movw	r2, #1500	; 0x5dc
 810c434:	851a      	strh	r2, [r3, #40]	; 0x28

  /* Accept broadcast address and ARP traffic */
  /* don't set NETIF_FLAG_ETHARP if this device is not an ethernet one */
  #if LWIP_ARP
    netif->flags |= NETIF_FLAG_BROADCAST | NETIF_FLAG_ETHARP;
 810c436:	687b      	ldr	r3, [r7, #4]
 810c438:	f893 3031 	ldrb.w	r3, [r3, #49]	; 0x31
 810c43c:	f043 030a 	orr.w	r3, r3, #10
 810c440:	b2da      	uxtb	r2, r3
 810c442:	687b      	ldr	r3, [r7, #4]
 810c444:	f883 2031 	strb.w	r2, [r3, #49]	; 0x31

/* USER CODE BEGIN PHY_PRE_CONFIG */

/* USER CODE END PHY_PRE_CONFIG */
  /* Set PHY IO functions */
  LAN8742_RegisterBusIO(&LAN8742, &LAN8742_IOCtx);
 810c448:	490f      	ldr	r1, [pc, #60]	; (810c488 <low_level_init+0x124>)
 810c44a:	4810      	ldr	r0, [pc, #64]	; (810c48c <low_level_init+0x128>)
 810c44c:	f7f4 fd63 	bl	8100f16 <LAN8742_RegisterBusIO>

  /* Initialize the LAN8742 ETH PHY */
  LAN8742_Init(&LAN8742);
 810c450:	480e      	ldr	r0, [pc, #56]	; (810c48c <low_level_init+0x128>)
 810c452:	f7f4 fd92 	bl	8100f7a <LAN8742_Init>

  if (hal_eth_init_status == HAL_OK)
 810c456:	7bfb      	ldrb	r3, [r7, #15]
 810c458:	2b00      	cmp	r3, #0
 810c45a:	d103      	bne.n	810c464 <low_level_init+0x100>
  {
  /* Get link state */
  ethernet_link_check_state(netif);
 810c45c:	6878      	ldr	r0, [r7, #4]
 810c45e:	f000 fa05 	bl	810c86c <ethernet_link_check_state>
#endif /* LWIP_ARP || LWIP_ETHERNET */

/* USER CODE BEGIN LOW_LEVEL_INIT */

/* USER CODE END LOW_LEVEL_INIT */
}
 810c462:	e001      	b.n	810c468 <low_level_init+0x104>
    Error_Handler();
 810c464:	f7f4 fb00 	bl	8100a68 <Error_Handler>
}
 810c468:	bf00      	nop
 810c46a:	3710      	adds	r7, #16
 810c46c:	46bd      	mov	sp, r7
 810c46e:	bd80      	pop	{r7, pc}
 810c470:	10004e28 	.word	0x10004e28
 810c474:	40028000 	.word	0x40028000
 810c478:	10000220 	.word	0x10000220
 810c47c:	100001c0 	.word	0x100001c0
 810c480:	10004ed8 	.word	0x10004ed8
 810c484:	0811f918 	.word	0x0811f918
 810c488:	1000002c 	.word	0x1000002c
 810c48c:	10004f10 	.word	0x10004f10

0810c490 <low_level_output>:
 *       to become available since the stack doesn't retry to send a packet
 *       dropped because of memory failure (except for the TCP timers).
 */

static err_t low_level_output(struct netif *netif, struct pbuf *p)
{
 810c490:	b580      	push	{r7, lr}
 810c492:	b092      	sub	sp, #72	; 0x48
 810c494:	af00      	add	r7, sp, #0
 810c496:	6078      	str	r0, [r7, #4]
 810c498:	6039      	str	r1, [r7, #0]
  uint32_t i = 0U;
 810c49a:	2300      	movs	r3, #0
 810c49c:	647b      	str	r3, [r7, #68]	; 0x44
  struct pbuf *q = NULL;
 810c49e:	2300      	movs	r3, #0
 810c4a0:	643b      	str	r3, [r7, #64]	; 0x40
  err_t errval = ERR_OK;
 810c4a2:	2300      	movs	r3, #0
 810c4a4:	f887 303f 	strb.w	r3, [r7, #63]	; 0x3f
  ETH_BufferTypeDef Txbuffer[ETH_TX_DESC_CNT] = {0};
 810c4a8:	f107 030c 	add.w	r3, r7, #12
 810c4ac:	2230      	movs	r2, #48	; 0x30
 810c4ae:	2100      	movs	r1, #0
 810c4b0:	4618      	mov	r0, r3
 810c4b2:	f00f f9cf 	bl	811b854 <memset>

  memset(Txbuffer, 0 , ETH_TX_DESC_CNT*sizeof(ETH_BufferTypeDef));
 810c4b6:	f107 030c 	add.w	r3, r7, #12
 810c4ba:	2230      	movs	r2, #48	; 0x30
 810c4bc:	2100      	movs	r1, #0
 810c4be:	4618      	mov	r0, r3
 810c4c0:	f00f f9c8 	bl	811b854 <memset>

  for(q = p; q != NULL; q = q->next)
 810c4c4:	683b      	ldr	r3, [r7, #0]
 810c4c6:	643b      	str	r3, [r7, #64]	; 0x40
 810c4c8:	e045      	b.n	810c556 <low_level_output+0xc6>
  {
    if(i >= ETH_TX_DESC_CNT)
 810c4ca:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 810c4cc:	2b03      	cmp	r3, #3
 810c4ce:	d902      	bls.n	810c4d6 <low_level_output+0x46>
      return ERR_IF;
 810c4d0:	f06f 030b 	mvn.w	r3, #11
 810c4d4:	e055      	b.n	810c582 <low_level_output+0xf2>

    Txbuffer[i].buffer = q->payload;
 810c4d6:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 810c4d8:	6859      	ldr	r1, [r3, #4]
 810c4da:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 810c4dc:	4613      	mov	r3, r2
 810c4de:	005b      	lsls	r3, r3, #1
 810c4e0:	4413      	add	r3, r2
 810c4e2:	009b      	lsls	r3, r3, #2
 810c4e4:	3348      	adds	r3, #72	; 0x48
 810c4e6:	443b      	add	r3, r7
 810c4e8:	3b3c      	subs	r3, #60	; 0x3c
 810c4ea:	6019      	str	r1, [r3, #0]
    Txbuffer[i].len = q->len;
 810c4ec:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 810c4ee:	895b      	ldrh	r3, [r3, #10]
 810c4f0:	4619      	mov	r1, r3
 810c4f2:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 810c4f4:	4613      	mov	r3, r2
 810c4f6:	005b      	lsls	r3, r3, #1
 810c4f8:	4413      	add	r3, r2
 810c4fa:	009b      	lsls	r3, r3, #2
 810c4fc:	3348      	adds	r3, #72	; 0x48
 810c4fe:	443b      	add	r3, r7
 810c500:	3b38      	subs	r3, #56	; 0x38
 810c502:	6019      	str	r1, [r3, #0]

    if(i>0)
 810c504:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 810c506:	2b00      	cmp	r3, #0
 810c508:	d011      	beq.n	810c52e <low_level_output+0x9e>
    {
      Txbuffer[i-1].next = &Txbuffer[i];
 810c50a:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 810c50c:	1e5a      	subs	r2, r3, #1
 810c50e:	f107 000c 	add.w	r0, r7, #12
 810c512:	6c79      	ldr	r1, [r7, #68]	; 0x44
 810c514:	460b      	mov	r3, r1
 810c516:	005b      	lsls	r3, r3, #1
 810c518:	440b      	add	r3, r1
 810c51a:	009b      	lsls	r3, r3, #2
 810c51c:	18c1      	adds	r1, r0, r3
 810c51e:	4613      	mov	r3, r2
 810c520:	005b      	lsls	r3, r3, #1
 810c522:	4413      	add	r3, r2
 810c524:	009b      	lsls	r3, r3, #2
 810c526:	3348      	adds	r3, #72	; 0x48
 810c528:	443b      	add	r3, r7
 810c52a:	3b34      	subs	r3, #52	; 0x34
 810c52c:	6019      	str	r1, [r3, #0]
    }

    if(q->next == NULL)
 810c52e:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 810c530:	681b      	ldr	r3, [r3, #0]
 810c532:	2b00      	cmp	r3, #0
 810c534:	d109      	bne.n	810c54a <low_level_output+0xba>
    {
      Txbuffer[i].next = NULL;
 810c536:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 810c538:	4613      	mov	r3, r2
 810c53a:	005b      	lsls	r3, r3, #1
 810c53c:	4413      	add	r3, r2
 810c53e:	009b      	lsls	r3, r3, #2
 810c540:	3348      	adds	r3, #72	; 0x48
 810c542:	443b      	add	r3, r7
 810c544:	3b34      	subs	r3, #52	; 0x34
 810c546:	2200      	movs	r2, #0
 810c548:	601a      	str	r2, [r3, #0]
    }

    i++;
 810c54a:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 810c54c:	3301      	adds	r3, #1
 810c54e:	647b      	str	r3, [r7, #68]	; 0x44
  for(q = p; q != NULL; q = q->next)
 810c550:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 810c552:	681b      	ldr	r3, [r3, #0]
 810c554:	643b      	str	r3, [r7, #64]	; 0x40
 810c556:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 810c558:	2b00      	cmp	r3, #0
 810c55a:	d1b6      	bne.n	810c4ca <low_level_output+0x3a>
  }

  TxConfig.Length = p->tot_len;
 810c55c:	683b      	ldr	r3, [r7, #0]
 810c55e:	891b      	ldrh	r3, [r3, #8]
 810c560:	461a      	mov	r2, r3
 810c562:	4b0a      	ldr	r3, [pc, #40]	; (810c58c <low_level_output+0xfc>)
 810c564:	605a      	str	r2, [r3, #4]
  TxConfig.TxBuffer = Txbuffer;
 810c566:	4a09      	ldr	r2, [pc, #36]	; (810c58c <low_level_output+0xfc>)
 810c568:	f107 030c 	add.w	r3, r7, #12
 810c56c:	6093      	str	r3, [r2, #8]
  TxConfig.pData = p;
 810c56e:	4a07      	ldr	r2, [pc, #28]	; (810c58c <low_level_output+0xfc>)
 810c570:	683b      	ldr	r3, [r7, #0]
 810c572:	6353      	str	r3, [r2, #52]	; 0x34

  HAL_ETH_Transmit(&heth, &TxConfig, ETH_DMA_TRANSMIT_TIMEOUT);
 810c574:	2214      	movs	r2, #20
 810c576:	4905      	ldr	r1, [pc, #20]	; (810c58c <low_level_output+0xfc>)
 810c578:	4805      	ldr	r0, [pc, #20]	; (810c590 <low_level_output+0x100>)
 810c57a:	f7f7 f9d9 	bl	8103930 <HAL_ETH_Transmit>

  return errval;
 810c57e:	f997 303f 	ldrsb.w	r3, [r7, #63]	; 0x3f
}
 810c582:	4618      	mov	r0, r3
 810c584:	3748      	adds	r7, #72	; 0x48
 810c586:	46bd      	mov	sp, r7
 810c588:	bd80      	pop	{r7, pc}
 810c58a:	bf00      	nop
 810c58c:	10004ed8 	.word	0x10004ed8
 810c590:	10004e28 	.word	0x10004e28

0810c594 <ethernetif_init>:
 * @return ERR_OK if the loopif is initialized
 *         ERR_MEM if private data couldn't be allocated
 *         any other err_t on error
 */
err_t ethernetif_init(struct netif *netif)
{
 810c594:	b580      	push	{r7, lr}
 810c596:	b082      	sub	sp, #8
 810c598:	af00      	add	r7, sp, #0
 810c59a:	6078      	str	r0, [r7, #4]
  LWIP_ASSERT("netif != NULL", (netif != NULL));
 810c59c:	687b      	ldr	r3, [r7, #4]
 810c59e:	2b00      	cmp	r3, #0
 810c5a0:	d106      	bne.n	810c5b0 <ethernetif_init+0x1c>
 810c5a2:	4b0e      	ldr	r3, [pc, #56]	; (810c5dc <ethernetif_init+0x48>)
 810c5a4:	f240 127b 	movw	r2, #379	; 0x17b
 810c5a8:	490d      	ldr	r1, [pc, #52]	; (810c5e0 <ethernetif_init+0x4c>)
 810c5aa:	480e      	ldr	r0, [pc, #56]	; (810c5e4 <ethernetif_init+0x50>)
 810c5ac:	f00f f928 	bl	811b800 <iprintf>
   * The last argument should be replaced with your link speed, in units
   * of bits per second.
   */
  // MIB2_INIT_NETIF(netif, snmp_ifType_ethernet_csmacd, LINK_SPEED_OF_YOUR_NETIF_IN_BPS);

  netif->name[0] = IFNAME0;
 810c5b0:	687b      	ldr	r3, [r7, #4]
 810c5b2:	2273      	movs	r2, #115	; 0x73
 810c5b4:	f883 2032 	strb.w	r2, [r3, #50]	; 0x32
  netif->name[1] = IFNAME1;
 810c5b8:	687b      	ldr	r3, [r7, #4]
 810c5ba:	2274      	movs	r2, #116	; 0x74
 810c5bc:	f883 2033 	strb.w	r2, [r3, #51]	; 0x33
   * is available...) */

#if LWIP_IPV4
#if LWIP_ARP || LWIP_ETHERNET
#if LWIP_ARP
  netif->output = etharp_output;
 810c5c0:	687b      	ldr	r3, [r7, #4]
 810c5c2:	4a09      	ldr	r2, [pc, #36]	; (810c5e8 <ethernetif_init+0x54>)
 810c5c4:	615a      	str	r2, [r3, #20]

#if LWIP_IPV6
  netif->output_ip6 = ethip6_output;
#endif /* LWIP_IPV6 */

  netif->linkoutput = low_level_output;
 810c5c6:	687b      	ldr	r3, [r7, #4]
 810c5c8:	4a08      	ldr	r2, [pc, #32]	; (810c5ec <ethernetif_init+0x58>)
 810c5ca:	619a      	str	r2, [r3, #24]

  /* initialize the hardware */
  low_level_init(netif);
 810c5cc:	6878      	ldr	r0, [r7, #4]
 810c5ce:	f7ff fec9 	bl	810c364 <low_level_init>

  return ERR_OK;
 810c5d2:	2300      	movs	r3, #0
}
 810c5d4:	4618      	mov	r0, r3
 810c5d6:	3708      	adds	r7, #8
 810c5d8:	46bd      	mov	sp, r7
 810c5da:	bd80      	pop	{r7, pc}
 810c5dc:	0811c6fc 	.word	0x0811c6fc
 810c5e0:	0811c718 	.word	0x0811c718
 810c5e4:	0811c728 	.word	0x0811c728
 810c5e8:	08111131 	.word	0x08111131
 810c5ec:	0810c491 	.word	0x0810c491

0810c5f0 <pbuf_free_custom>:
  * @brief  Custom Rx pbuf free callback
  * @param  pbuf: pbuf to be freed
  * @retval None
  */
void pbuf_free_custom(struct pbuf *p)
{
 810c5f0:	b580      	push	{r7, lr}
 810c5f2:	b084      	sub	sp, #16
 810c5f4:	af00      	add	r7, sp, #0
 810c5f6:	6078      	str	r0, [r7, #4]
  struct pbuf_custom* custom_pbuf = (struct pbuf_custom*)p;
 810c5f8:	687b      	ldr	r3, [r7, #4]
 810c5fa:	60fb      	str	r3, [r7, #12]
  LWIP_MEMPOOL_FREE(RX_POOL, custom_pbuf);
 810c5fc:	68f9      	ldr	r1, [r7, #12]
 810c5fe:	4807      	ldr	r0, [pc, #28]	; (810c61c <pbuf_free_custom+0x2c>)
 810c600:	f007 f9a4 	bl	811394c <memp_free_pool>

  /* If the Rx Buffer Pool was exhausted, signal the ethernetif_input task to
   * call HAL_ETH_GetRxDataBuffer to rebuild the Rx descriptors. */

  if (RxAllocStatus == RX_ALLOC_ERROR)
 810c604:	4b06      	ldr	r3, [pc, #24]	; (810c620 <pbuf_free_custom+0x30>)
 810c606:	781b      	ldrb	r3, [r3, #0]
 810c608:	2b01      	cmp	r3, #1
 810c60a:	d102      	bne.n	810c612 <pbuf_free_custom+0x22>
  {
    RxAllocStatus = RX_ALLOC_OK;
 810c60c:	4b04      	ldr	r3, [pc, #16]	; (810c620 <pbuf_free_custom+0x30>)
 810c60e:	2200      	movs	r2, #0
 810c610:	701a      	strb	r2, [r3, #0]
  }
}
 810c612:	bf00      	nop
 810c614:	3710      	adds	r7, #16
 810c616:	46bd      	mov	sp, r7
 810c618:	bd80      	pop	{r7, pc}
 810c61a:	bf00      	nop
 810c61c:	0811f918 	.word	0x0811f918
 810c620:	10004e24 	.word	0x10004e24

0810c624 <sys_now>:
*         when LWIP_TIMERS == 1 and NO_SYS == 1
* @param  None
* @retval Current Time value
*/
u32_t sys_now(void)
{
 810c624:	b580      	push	{r7, lr}
 810c626:	af00      	add	r7, sp, #0
  return HAL_GetTick();
 810c628:	f7f5 f808 	bl	810163c <HAL_GetTick>
 810c62c:	4603      	mov	r3, r0
}
 810c62e:	4618      	mov	r0, r3
 810c630:	bd80      	pop	{r7, pc}
	...

0810c634 <HAL_ETH_MspInit>:
  * @param  ethHandle: ETH handle
  * @retval None
  */

void HAL_ETH_MspInit(ETH_HandleTypeDef* ethHandle)
{
 810c634:	b580      	push	{r7, lr}
 810c636:	b08e      	sub	sp, #56	; 0x38
 810c638:	af00      	add	r7, sp, #0
 810c63a:	6078      	str	r0, [r7, #4]
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 810c63c:	f107 0324 	add.w	r3, r7, #36	; 0x24
 810c640:	2200      	movs	r2, #0
 810c642:	601a      	str	r2, [r3, #0]
 810c644:	605a      	str	r2, [r3, #4]
 810c646:	609a      	str	r2, [r3, #8]
 810c648:	60da      	str	r2, [r3, #12]
 810c64a:	611a      	str	r2, [r3, #16]
  if(ethHandle->Instance==ETH)
 810c64c:	687b      	ldr	r3, [r7, #4]
 810c64e:	681b      	ldr	r3, [r3, #0]
 810c650:	4a59      	ldr	r2, [pc, #356]	; (810c7b8 <HAL_ETH_MspInit+0x184>)
 810c652:	4293      	cmp	r3, r2
 810c654:	f040 80ab 	bne.w	810c7ae <HAL_ETH_MspInit+0x17a>
  {
  /* USER CODE BEGIN ETH_MspInit 0 */

  /* USER CODE END ETH_MspInit 0 */
    /* Enable Peripheral clock */
    __HAL_RCC_ETH1MAC_CLK_ENABLE();
 810c658:	4b58      	ldr	r3, [pc, #352]	; (810c7bc <HAL_ETH_MspInit+0x188>)
 810c65a:	f8d3 30d8 	ldr.w	r3, [r3, #216]	; 0xd8
 810c65e:	4a57      	ldr	r2, [pc, #348]	; (810c7bc <HAL_ETH_MspInit+0x188>)
 810c660:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 810c664:	f8c2 30d8 	str.w	r3, [r2, #216]	; 0xd8
 810c668:	4b54      	ldr	r3, [pc, #336]	; (810c7bc <HAL_ETH_MspInit+0x188>)
 810c66a:	f8d3 30d8 	ldr.w	r3, [r3, #216]	; 0xd8
 810c66e:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
 810c672:	623b      	str	r3, [r7, #32]
 810c674:	6a3b      	ldr	r3, [r7, #32]
    __HAL_RCC_ETH1TX_CLK_ENABLE();
 810c676:	4b51      	ldr	r3, [pc, #324]	; (810c7bc <HAL_ETH_MspInit+0x188>)
 810c678:	f8d3 30d8 	ldr.w	r3, [r3, #216]	; 0xd8
 810c67c:	4a4f      	ldr	r2, [pc, #316]	; (810c7bc <HAL_ETH_MspInit+0x188>)
 810c67e:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 810c682:	f8c2 30d8 	str.w	r3, [r2, #216]	; 0xd8
 810c686:	4b4d      	ldr	r3, [pc, #308]	; (810c7bc <HAL_ETH_MspInit+0x188>)
 810c688:	f8d3 30d8 	ldr.w	r3, [r3, #216]	; 0xd8
 810c68c:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
 810c690:	61fb      	str	r3, [r7, #28]
 810c692:	69fb      	ldr	r3, [r7, #28]
    __HAL_RCC_ETH1RX_CLK_ENABLE();
 810c694:	4b49      	ldr	r3, [pc, #292]	; (810c7bc <HAL_ETH_MspInit+0x188>)
 810c696:	f8d3 30d8 	ldr.w	r3, [r3, #216]	; 0xd8
 810c69a:	4a48      	ldr	r2, [pc, #288]	; (810c7bc <HAL_ETH_MspInit+0x188>)
 810c69c:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 810c6a0:	f8c2 30d8 	str.w	r3, [r2, #216]	; 0xd8
 810c6a4:	4b45      	ldr	r3, [pc, #276]	; (810c7bc <HAL_ETH_MspInit+0x188>)
 810c6a6:	f8d3 30d8 	ldr.w	r3, [r3, #216]	; 0xd8
 810c6aa:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 810c6ae:	61bb      	str	r3, [r7, #24]
 810c6b0:	69bb      	ldr	r3, [r7, #24]

    __HAL_RCC_GPIOC_CLK_ENABLE();
 810c6b2:	4b42      	ldr	r3, [pc, #264]	; (810c7bc <HAL_ETH_MspInit+0x188>)
 810c6b4:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
 810c6b8:	4a40      	ldr	r2, [pc, #256]	; (810c7bc <HAL_ETH_MspInit+0x188>)
 810c6ba:	f043 0304 	orr.w	r3, r3, #4
 810c6be:	f8c2 30e0 	str.w	r3, [r2, #224]	; 0xe0
 810c6c2:	4b3e      	ldr	r3, [pc, #248]	; (810c7bc <HAL_ETH_MspInit+0x188>)
 810c6c4:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
 810c6c8:	f003 0304 	and.w	r3, r3, #4
 810c6cc:	617b      	str	r3, [r7, #20]
 810c6ce:	697b      	ldr	r3, [r7, #20]
    __HAL_RCC_GPIOA_CLK_ENABLE();
 810c6d0:	4b3a      	ldr	r3, [pc, #232]	; (810c7bc <HAL_ETH_MspInit+0x188>)
 810c6d2:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
 810c6d6:	4a39      	ldr	r2, [pc, #228]	; (810c7bc <HAL_ETH_MspInit+0x188>)
 810c6d8:	f043 0301 	orr.w	r3, r3, #1
 810c6dc:	f8c2 30e0 	str.w	r3, [r2, #224]	; 0xe0
 810c6e0:	4b36      	ldr	r3, [pc, #216]	; (810c7bc <HAL_ETH_MspInit+0x188>)
 810c6e2:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
 810c6e6:	f003 0301 	and.w	r3, r3, #1
 810c6ea:	613b      	str	r3, [r7, #16]
 810c6ec:	693b      	ldr	r3, [r7, #16]
    __HAL_RCC_GPIOB_CLK_ENABLE();
 810c6ee:	4b33      	ldr	r3, [pc, #204]	; (810c7bc <HAL_ETH_MspInit+0x188>)
 810c6f0:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
 810c6f4:	4a31      	ldr	r2, [pc, #196]	; (810c7bc <HAL_ETH_MspInit+0x188>)
 810c6f6:	f043 0302 	orr.w	r3, r3, #2
 810c6fa:	f8c2 30e0 	str.w	r3, [r2, #224]	; 0xe0
 810c6fe:	4b2f      	ldr	r3, [pc, #188]	; (810c7bc <HAL_ETH_MspInit+0x188>)
 810c700:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
 810c704:	f003 0302 	and.w	r3, r3, #2
 810c708:	60fb      	str	r3, [r7, #12]
 810c70a:	68fb      	ldr	r3, [r7, #12]
    __HAL_RCC_GPIOG_CLK_ENABLE();
 810c70c:	4b2b      	ldr	r3, [pc, #172]	; (810c7bc <HAL_ETH_MspInit+0x188>)
 810c70e:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
 810c712:	4a2a      	ldr	r2, [pc, #168]	; (810c7bc <HAL_ETH_MspInit+0x188>)
 810c714:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 810c718:	f8c2 30e0 	str.w	r3, [r2, #224]	; 0xe0
 810c71c:	4b27      	ldr	r3, [pc, #156]	; (810c7bc <HAL_ETH_MspInit+0x188>)
 810c71e:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
 810c722:	f003 0340 	and.w	r3, r3, #64	; 0x40
 810c726:	60bb      	str	r3, [r7, #8]
 810c728:	68bb      	ldr	r3, [r7, #8]
    PC5     ------> ETH_RXD1
    PB13     ------> ETH_TXD1
    PG11     ------> ETH_TX_EN
    PG13     ------> ETH_TXD0
    */
    GPIO_InitStruct.Pin = GPIO_PIN_1|GPIO_PIN_4|GPIO_PIN_5;
 810c72a:	2332      	movs	r3, #50	; 0x32
 810c72c:	627b      	str	r3, [r7, #36]	; 0x24
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 810c72e:	2302      	movs	r3, #2
 810c730:	62bb      	str	r3, [r7, #40]	; 0x28
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 810c732:	2300      	movs	r3, #0
 810c734:	62fb      	str	r3, [r7, #44]	; 0x2c
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 810c736:	2300      	movs	r3, #0
 810c738:	633b      	str	r3, [r7, #48]	; 0x30
    GPIO_InitStruct.Alternate = GPIO_AF11_ETH;
 810c73a:	230b      	movs	r3, #11
 810c73c:	637b      	str	r3, [r7, #52]	; 0x34
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 810c73e:	f107 0324 	add.w	r3, r7, #36	; 0x24
 810c742:	4619      	mov	r1, r3
 810c744:	481e      	ldr	r0, [pc, #120]	; (810c7c0 <HAL_ETH_MspInit+0x18c>)
 810c746:	f7f8 fe43 	bl	81053d0 <HAL_GPIO_Init>

    GPIO_InitStruct.Pin = GPIO_PIN_1|GPIO_PIN_2|GPIO_PIN_7;
 810c74a:	2386      	movs	r3, #134	; 0x86
 810c74c:	627b      	str	r3, [r7, #36]	; 0x24
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 810c74e:	2302      	movs	r3, #2
 810c750:	62bb      	str	r3, [r7, #40]	; 0x28
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 810c752:	2300      	movs	r3, #0
 810c754:	62fb      	str	r3, [r7, #44]	; 0x2c
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 810c756:	2300      	movs	r3, #0
 810c758:	633b      	str	r3, [r7, #48]	; 0x30
    GPIO_InitStruct.Alternate = GPIO_AF11_ETH;
 810c75a:	230b      	movs	r3, #11
 810c75c:	637b      	str	r3, [r7, #52]	; 0x34
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 810c75e:	f107 0324 	add.w	r3, r7, #36	; 0x24
 810c762:	4619      	mov	r1, r3
 810c764:	4817      	ldr	r0, [pc, #92]	; (810c7c4 <HAL_ETH_MspInit+0x190>)
 810c766:	f7f8 fe33 	bl	81053d0 <HAL_GPIO_Init>

    GPIO_InitStruct.Pin = GPIO_PIN_13;
 810c76a:	f44f 5300 	mov.w	r3, #8192	; 0x2000
 810c76e:	627b      	str	r3, [r7, #36]	; 0x24
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 810c770:	2302      	movs	r3, #2
 810c772:	62bb      	str	r3, [r7, #40]	; 0x28
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 810c774:	2300      	movs	r3, #0
 810c776:	62fb      	str	r3, [r7, #44]	; 0x2c
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 810c778:	2300      	movs	r3, #0
 810c77a:	633b      	str	r3, [r7, #48]	; 0x30
    GPIO_InitStruct.Alternate = GPIO_AF11_ETH;
 810c77c:	230b      	movs	r3, #11
 810c77e:	637b      	str	r3, [r7, #52]	; 0x34
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 810c780:	f107 0324 	add.w	r3, r7, #36	; 0x24
 810c784:	4619      	mov	r1, r3
 810c786:	4810      	ldr	r0, [pc, #64]	; (810c7c8 <HAL_ETH_MspInit+0x194>)
 810c788:	f7f8 fe22 	bl	81053d0 <HAL_GPIO_Init>

    GPIO_InitStruct.Pin = GPIO_PIN_11|GPIO_PIN_13;
 810c78c:	f44f 5320 	mov.w	r3, #10240	; 0x2800
 810c790:	627b      	str	r3, [r7, #36]	; 0x24
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 810c792:	2302      	movs	r3, #2
 810c794:	62bb      	str	r3, [r7, #40]	; 0x28
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 810c796:	2300      	movs	r3, #0
 810c798:	62fb      	str	r3, [r7, #44]	; 0x2c
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 810c79a:	2300      	movs	r3, #0
 810c79c:	633b      	str	r3, [r7, #48]	; 0x30
    GPIO_InitStruct.Alternate = GPIO_AF11_ETH;
 810c79e:	230b      	movs	r3, #11
 810c7a0:	637b      	str	r3, [r7, #52]	; 0x34
    HAL_GPIO_Init(GPIOG, &GPIO_InitStruct);
 810c7a2:	f107 0324 	add.w	r3, r7, #36	; 0x24
 810c7a6:	4619      	mov	r1, r3
 810c7a8:	4808      	ldr	r0, [pc, #32]	; (810c7cc <HAL_ETH_MspInit+0x198>)
 810c7aa:	f7f8 fe11 	bl	81053d0 <HAL_GPIO_Init>

  /* USER CODE BEGIN ETH_MspInit 1 */

  /* USER CODE END ETH_MspInit 1 */
  }
}
 810c7ae:	bf00      	nop
 810c7b0:	3738      	adds	r7, #56	; 0x38
 810c7b2:	46bd      	mov	sp, r7
 810c7b4:	bd80      	pop	{r7, pc}
 810c7b6:	bf00      	nop
 810c7b8:	40028000 	.word	0x40028000
 810c7bc:	58024400 	.word	0x58024400
 810c7c0:	58020800 	.word	0x58020800
 810c7c4:	58020000 	.word	0x58020000
 810c7c8:	58020400 	.word	0x58020400
 810c7cc:	58021800 	.word	0x58021800

0810c7d0 <ETH_PHY_IO_Init>:
  * @brief  Initializes the MDIO interface GPIO and clocks.
  * @param  None
  * @retval 0 if OK, -1 if ERROR
  */
int32_t ETH_PHY_IO_Init(void)
{
 810c7d0:	b580      	push	{r7, lr}
 810c7d2:	af00      	add	r7, sp, #0
  /* We assume that MDIO GPIO configuration is already done
     in the ETH_MspInit() else it should be done here
  */

  /* Configure the MDIO Clock */
  HAL_ETH_SetMDIOClockRange(&heth);
 810c7d4:	4802      	ldr	r0, [pc, #8]	; (810c7e0 <ETH_PHY_IO_Init+0x10>)
 810c7d6:	f7f7 fc51 	bl	810407c <HAL_ETH_SetMDIOClockRange>

  return 0;
 810c7da:	2300      	movs	r3, #0
}
 810c7dc:	4618      	mov	r0, r3
 810c7de:	bd80      	pop	{r7, pc}
 810c7e0:	10004e28 	.word	0x10004e28

0810c7e4 <ETH_PHY_IO_DeInit>:
  * @brief  De-Initializes the MDIO interface .
  * @param  None
  * @retval 0 if OK, -1 if ERROR
  */
int32_t ETH_PHY_IO_DeInit (void)
{
 810c7e4:	b480      	push	{r7}
 810c7e6:	af00      	add	r7, sp, #0
  return 0;
 810c7e8:	2300      	movs	r3, #0
}
 810c7ea:	4618      	mov	r0, r3
 810c7ec:	46bd      	mov	sp, r7
 810c7ee:	f85d 7b04 	ldr.w	r7, [sp], #4
 810c7f2:	4770      	bx	lr

0810c7f4 <ETH_PHY_IO_ReadReg>:
  * @param  RegAddr: PHY register address
  * @param  pRegVal: pointer to hold the register value
  * @retval 0 if OK -1 if Error
  */
int32_t ETH_PHY_IO_ReadReg(uint32_t DevAddr, uint32_t RegAddr, uint32_t *pRegVal)
{
 810c7f4:	b580      	push	{r7, lr}
 810c7f6:	b084      	sub	sp, #16
 810c7f8:	af00      	add	r7, sp, #0
 810c7fa:	60f8      	str	r0, [r7, #12]
 810c7fc:	60b9      	str	r1, [r7, #8]
 810c7fe:	607a      	str	r2, [r7, #4]
  if(HAL_ETH_ReadPHYRegister(&heth, DevAddr, RegAddr, pRegVal) != HAL_OK)
 810c800:	687b      	ldr	r3, [r7, #4]
 810c802:	68ba      	ldr	r2, [r7, #8]
 810c804:	68f9      	ldr	r1, [r7, #12]
 810c806:	4807      	ldr	r0, [pc, #28]	; (810c824 <ETH_PHY_IO_ReadReg+0x30>)
 810c808:	f7f7 f9a2 	bl	8103b50 <HAL_ETH_ReadPHYRegister>
 810c80c:	4603      	mov	r3, r0
 810c80e:	2b00      	cmp	r3, #0
 810c810:	d002      	beq.n	810c818 <ETH_PHY_IO_ReadReg+0x24>
  {
    return -1;
 810c812:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 810c816:	e000      	b.n	810c81a <ETH_PHY_IO_ReadReg+0x26>
  }

  return 0;
 810c818:	2300      	movs	r3, #0
}
 810c81a:	4618      	mov	r0, r3
 810c81c:	3710      	adds	r7, #16
 810c81e:	46bd      	mov	sp, r7
 810c820:	bd80      	pop	{r7, pc}
 810c822:	bf00      	nop
 810c824:	10004e28 	.word	0x10004e28

0810c828 <ETH_PHY_IO_WriteReg>:
  * @param  RegAddr: PHY register address
  * @param  RegVal: Value to be written
  * @retval 0 if OK -1 if Error
  */
int32_t ETH_PHY_IO_WriteReg(uint32_t DevAddr, uint32_t RegAddr, uint32_t RegVal)
{
 810c828:	b580      	push	{r7, lr}
 810c82a:	b084      	sub	sp, #16
 810c82c:	af00      	add	r7, sp, #0
 810c82e:	60f8      	str	r0, [r7, #12]
 810c830:	60b9      	str	r1, [r7, #8]
 810c832:	607a      	str	r2, [r7, #4]
  if(HAL_ETH_WritePHYRegister(&heth, DevAddr, RegAddr, RegVal) != HAL_OK)
 810c834:	687b      	ldr	r3, [r7, #4]
 810c836:	68ba      	ldr	r2, [r7, #8]
 810c838:	68f9      	ldr	r1, [r7, #12]
 810c83a:	4807      	ldr	r0, [pc, #28]	; (810c858 <ETH_PHY_IO_WriteReg+0x30>)
 810c83c:	f7f7 f9dc 	bl	8103bf8 <HAL_ETH_WritePHYRegister>
 810c840:	4603      	mov	r3, r0
 810c842:	2b00      	cmp	r3, #0
 810c844:	d002      	beq.n	810c84c <ETH_PHY_IO_WriteReg+0x24>
  {
    return -1;
 810c846:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 810c84a:	e000      	b.n	810c84e <ETH_PHY_IO_WriteReg+0x26>
  }

  return 0;
 810c84c:	2300      	movs	r3, #0
}
 810c84e:	4618      	mov	r0, r3
 810c850:	3710      	adds	r7, #16
 810c852:	46bd      	mov	sp, r7
 810c854:	bd80      	pop	{r7, pc}
 810c856:	bf00      	nop
 810c858:	10004e28 	.word	0x10004e28

0810c85c <ETH_PHY_IO_GetTick>:
/**
  * @brief  Get the time in millisecons used for internal PHY driver process.
  * @retval Time value
  */
int32_t ETH_PHY_IO_GetTick(void)
{
 810c85c:	b580      	push	{r7, lr}
 810c85e:	af00      	add	r7, sp, #0
  return HAL_GetTick();
 810c860:	f7f4 feec 	bl	810163c <HAL_GetTick>
 810c864:	4603      	mov	r3, r0
}
 810c866:	4618      	mov	r0, r3
 810c868:	bd80      	pop	{r7, pc}
	...

0810c86c <ethernet_link_check_state>:
/**
  * @brief  Check the ETH link state then update ETH driver and netif link accordingly.
  * @retval None
  */
void ethernet_link_check_state(struct netif *netif)
{
 810c86c:	b580      	push	{r7, lr}
 810c86e:	b0a0      	sub	sp, #128	; 0x80
 810c870:	af00      	add	r7, sp, #0
 810c872:	6078      	str	r0, [r7, #4]
  ETH_MACConfigTypeDef MACConf = {0};
 810c874:	f107 030c 	add.w	r3, r7, #12
 810c878:	2264      	movs	r2, #100	; 0x64
 810c87a:	2100      	movs	r1, #0
 810c87c:	4618      	mov	r0, r3
 810c87e:	f00e ffe9 	bl	811b854 <memset>
  int32_t PHYLinkState = 0;
 810c882:	2300      	movs	r3, #0
 810c884:	673b      	str	r3, [r7, #112]	; 0x70
  uint32_t linkchanged = 0U, speed = 0U, duplex = 0U;
 810c886:	2300      	movs	r3, #0
 810c888:	67fb      	str	r3, [r7, #124]	; 0x7c
 810c88a:	2300      	movs	r3, #0
 810c88c:	67bb      	str	r3, [r7, #120]	; 0x78
 810c88e:	2300      	movs	r3, #0
 810c890:	677b      	str	r3, [r7, #116]	; 0x74

  PHYLinkState = LAN8742_GetLinkState(&LAN8742);
 810c892:	483a      	ldr	r0, [pc, #232]	; (810c97c <ethernet_link_check_state+0x110>)
 810c894:	f7f4 fbbe 	bl	8101014 <LAN8742_GetLinkState>
 810c898:	6738      	str	r0, [r7, #112]	; 0x70

  if(netif_is_link_up(netif) && (PHYLinkState <= LAN8742_STATUS_LINK_DOWN))
 810c89a:	687b      	ldr	r3, [r7, #4]
 810c89c:	f893 3031 	ldrb.w	r3, [r3, #49]	; 0x31
 810c8a0:	089b      	lsrs	r3, r3, #2
 810c8a2:	f003 0301 	and.w	r3, r3, #1
 810c8a6:	b2db      	uxtb	r3, r3
 810c8a8:	2b00      	cmp	r3, #0
 810c8aa:	d00c      	beq.n	810c8c6 <ethernet_link_check_state+0x5a>
 810c8ac:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 810c8ae:	2b01      	cmp	r3, #1
 810c8b0:	dc09      	bgt.n	810c8c6 <ethernet_link_check_state+0x5a>
  {
    HAL_ETH_Stop(&heth);
 810c8b2:	4833      	ldr	r0, [pc, #204]	; (810c980 <ethernet_link_check_state+0x114>)
 810c8b4:	f7f6 ffec 	bl	8103890 <HAL_ETH_Stop>
    netif_set_down(netif);
 810c8b8:	6878      	ldr	r0, [r7, #4]
 810c8ba:	f007 fad3 	bl	8113e64 <netif_set_down>
    netif_set_link_down(netif);
 810c8be:	6878      	ldr	r0, [r7, #4]
 810c8c0:	f007 fb3a 	bl	8113f38 <netif_set_link_down>
      netif_set_up(netif);
      netif_set_link_up(netif);
    }
  }

}
 810c8c4:	e055      	b.n	810c972 <ethernet_link_check_state+0x106>
  else if(!netif_is_link_up(netif) && (PHYLinkState > LAN8742_STATUS_LINK_DOWN))
 810c8c6:	687b      	ldr	r3, [r7, #4]
 810c8c8:	f893 3031 	ldrb.w	r3, [r3, #49]	; 0x31
 810c8cc:	f003 0304 	and.w	r3, r3, #4
 810c8d0:	2b00      	cmp	r3, #0
 810c8d2:	d14e      	bne.n	810c972 <ethernet_link_check_state+0x106>
 810c8d4:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 810c8d6:	2b01      	cmp	r3, #1
 810c8d8:	dd4b      	ble.n	810c972 <ethernet_link_check_state+0x106>
    switch (PHYLinkState)
 810c8da:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 810c8dc:	3b02      	subs	r3, #2
 810c8de:	2b03      	cmp	r3, #3
 810c8e0:	d82a      	bhi.n	810c938 <ethernet_link_check_state+0xcc>
 810c8e2:	a201      	add	r2, pc, #4	; (adr r2, 810c8e8 <ethernet_link_check_state+0x7c>)
 810c8e4:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 810c8e8:	0810c8f9 	.word	0x0810c8f9
 810c8ec:	0810c90b 	.word	0x0810c90b
 810c8f0:	0810c91b 	.word	0x0810c91b
 810c8f4:	0810c92b 	.word	0x0810c92b
      duplex = ETH_FULLDUPLEX_MODE;
 810c8f8:	f44f 5300 	mov.w	r3, #8192	; 0x2000
 810c8fc:	677b      	str	r3, [r7, #116]	; 0x74
      speed = ETH_SPEED_100M;
 810c8fe:	f44f 4380 	mov.w	r3, #16384	; 0x4000
 810c902:	67bb      	str	r3, [r7, #120]	; 0x78
      linkchanged = 1;
 810c904:	2301      	movs	r3, #1
 810c906:	67fb      	str	r3, [r7, #124]	; 0x7c
      break;
 810c908:	e017      	b.n	810c93a <ethernet_link_check_state+0xce>
      duplex = ETH_HALFDUPLEX_MODE;
 810c90a:	2300      	movs	r3, #0
 810c90c:	677b      	str	r3, [r7, #116]	; 0x74
      speed = ETH_SPEED_100M;
 810c90e:	f44f 4380 	mov.w	r3, #16384	; 0x4000
 810c912:	67bb      	str	r3, [r7, #120]	; 0x78
      linkchanged = 1;
 810c914:	2301      	movs	r3, #1
 810c916:	67fb      	str	r3, [r7, #124]	; 0x7c
      break;
 810c918:	e00f      	b.n	810c93a <ethernet_link_check_state+0xce>
      duplex = ETH_FULLDUPLEX_MODE;
 810c91a:	f44f 5300 	mov.w	r3, #8192	; 0x2000
 810c91e:	677b      	str	r3, [r7, #116]	; 0x74
      speed = ETH_SPEED_10M;
 810c920:	2300      	movs	r3, #0
 810c922:	67bb      	str	r3, [r7, #120]	; 0x78
      linkchanged = 1;
 810c924:	2301      	movs	r3, #1
 810c926:	67fb      	str	r3, [r7, #124]	; 0x7c
      break;
 810c928:	e007      	b.n	810c93a <ethernet_link_check_state+0xce>
      duplex = ETH_HALFDUPLEX_MODE;
 810c92a:	2300      	movs	r3, #0
 810c92c:	677b      	str	r3, [r7, #116]	; 0x74
      speed = ETH_SPEED_10M;
 810c92e:	2300      	movs	r3, #0
 810c930:	67bb      	str	r3, [r7, #120]	; 0x78
      linkchanged = 1;
 810c932:	2301      	movs	r3, #1
 810c934:	67fb      	str	r3, [r7, #124]	; 0x7c
      break;
 810c936:	e000      	b.n	810c93a <ethernet_link_check_state+0xce>
      break;
 810c938:	bf00      	nop
    if(linkchanged)
 810c93a:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 810c93c:	2b00      	cmp	r3, #0
 810c93e:	d018      	beq.n	810c972 <ethernet_link_check_state+0x106>
      HAL_ETH_GetMACConfig(&heth, &MACConf);
 810c940:	f107 030c 	add.w	r3, r7, #12
 810c944:	4619      	mov	r1, r3
 810c946:	480e      	ldr	r0, [pc, #56]	; (810c980 <ethernet_link_check_state+0x114>)
 810c948:	f7f7 f9aa 	bl	8103ca0 <HAL_ETH_GetMACConfig>
      MACConf.DuplexMode = duplex;
 810c94c:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 810c94e:	627b      	str	r3, [r7, #36]	; 0x24
      MACConf.Speed = speed;
 810c950:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 810c952:	623b      	str	r3, [r7, #32]
      HAL_ETH_SetMACConfig(&heth, &MACConf);
 810c954:	f107 030c 	add.w	r3, r7, #12
 810c958:	4619      	mov	r1, r3
 810c95a:	4809      	ldr	r0, [pc, #36]	; (810c980 <ethernet_link_check_state+0x114>)
 810c95c:	f7f7 fb74 	bl	8104048 <HAL_ETH_SetMACConfig>
      HAL_ETH_Start(&heth);
 810c960:	4807      	ldr	r0, [pc, #28]	; (810c980 <ethernet_link_check_state+0x114>)
 810c962:	f7f6 ff33 	bl	81037cc <HAL_ETH_Start>
      netif_set_up(netif);
 810c966:	6878      	ldr	r0, [r7, #4]
 810c968:	f007 fa10 	bl	8113d8c <netif_set_up>
      netif_set_link_up(netif);
 810c96c:	6878      	ldr	r0, [r7, #4]
 810c96e:	f007 faab 	bl	8113ec8 <netif_set_link_up>
}
 810c972:	bf00      	nop
 810c974:	3780      	adds	r7, #128	; 0x80
 810c976:	46bd      	mov	sp, r7
 810c978:	bd80      	pop	{r7, pc}
 810c97a:	bf00      	nop
 810c97c:	10004f10 	.word	0x10004f10
 810c980:	10004e28 	.word	0x10004e28

0810c984 <HAL_ETH_RxAllocateCallback>:

void HAL_ETH_RxAllocateCallback(uint8_t **buff)
{
 810c984:	b580      	push	{r7, lr}
 810c986:	b086      	sub	sp, #24
 810c988:	af02      	add	r7, sp, #8
 810c98a:	6078      	str	r0, [r7, #4]
/* USER CODE BEGIN HAL ETH RxAllocateCallback */
  struct pbuf_custom *p = LWIP_MEMPOOL_ALLOC(RX_POOL);
 810c98c:	4812      	ldr	r0, [pc, #72]	; (810c9d8 <HAL_ETH_RxAllocateCallback+0x54>)
 810c98e:	f006 ff6f 	bl	8113870 <memp_malloc_pool>
 810c992:	60f8      	str	r0, [r7, #12]
  if (p)
 810c994:	68fb      	ldr	r3, [r7, #12]
 810c996:	2b00      	cmp	r3, #0
 810c998:	d014      	beq.n	810c9c4 <HAL_ETH_RxAllocateCallback+0x40>
  {
    /* Get the buff from the struct pbuf address. */
    *buff = (uint8_t *)p + offsetof(RxBuff_t, buff);
 810c99a:	68fb      	ldr	r3, [r7, #12]
 810c99c:	f103 0220 	add.w	r2, r3, #32
 810c9a0:	687b      	ldr	r3, [r7, #4]
 810c9a2:	601a      	str	r2, [r3, #0]
    p->custom_free_function = pbuf_free_custom;
 810c9a4:	68fb      	ldr	r3, [r7, #12]
 810c9a6:	4a0d      	ldr	r2, [pc, #52]	; (810c9dc <HAL_ETH_RxAllocateCallback+0x58>)
 810c9a8:	611a      	str	r2, [r3, #16]
    /* Initialize the struct pbuf.
    * This must be performed whenever a buffer's allocated because it may be
    * changed by lwIP or the app, e.g., pbuf_free decrements ref. */
    pbuf_alloced_custom(PBUF_RAW, 0, PBUF_REF, p, *buff, ETH_RX_BUFFER_SIZE);
 810c9aa:	687b      	ldr	r3, [r7, #4]
 810c9ac:	681b      	ldr	r3, [r3, #0]
 810c9ae:	f44f 62c0 	mov.w	r2, #1536	; 0x600
 810c9b2:	9201      	str	r2, [sp, #4]
 810c9b4:	9300      	str	r3, [sp, #0]
 810c9b6:	68fb      	ldr	r3, [r7, #12]
 810c9b8:	2241      	movs	r2, #65	; 0x41
 810c9ba:	2100      	movs	r1, #0
 810c9bc:	2000      	movs	r0, #0
 810c9be:	f007 fc91 	bl	81142e4 <pbuf_alloced_custom>
  {
    RxAllocStatus = RX_ALLOC_ERROR;
    *buff = NULL;
  }
/* USER CODE END HAL ETH RxAllocateCallback */
}
 810c9c2:	e005      	b.n	810c9d0 <HAL_ETH_RxAllocateCallback+0x4c>
    RxAllocStatus = RX_ALLOC_ERROR;
 810c9c4:	4b06      	ldr	r3, [pc, #24]	; (810c9e0 <HAL_ETH_RxAllocateCallback+0x5c>)
 810c9c6:	2201      	movs	r2, #1
 810c9c8:	701a      	strb	r2, [r3, #0]
    *buff = NULL;
 810c9ca:	687b      	ldr	r3, [r7, #4]
 810c9cc:	2200      	movs	r2, #0
 810c9ce:	601a      	str	r2, [r3, #0]
}
 810c9d0:	bf00      	nop
 810c9d2:	3710      	adds	r7, #16
 810c9d4:	46bd      	mov	sp, r7
 810c9d6:	bd80      	pop	{r7, pc}
 810c9d8:	0811f918 	.word	0x0811f918
 810c9dc:	0810c5f1 	.word	0x0810c5f1
 810c9e0:	10004e24 	.word	0x10004e24

0810c9e4 <USBD_Init>:
  * @param  id: Low level core index
  * @retval status: USBD Status
  */
USBD_StatusTypeDef USBD_Init(USBD_HandleTypeDef *pdev,
                             USBD_DescriptorsTypeDef *pdesc, uint8_t id)
{
 810c9e4:	b580      	push	{r7, lr}
 810c9e6:	b086      	sub	sp, #24
 810c9e8:	af00      	add	r7, sp, #0
 810c9ea:	60f8      	str	r0, [r7, #12]
 810c9ec:	60b9      	str	r1, [r7, #8]
 810c9ee:	4613      	mov	r3, r2
 810c9f0:	71fb      	strb	r3, [r7, #7]
  USBD_StatusTypeDef ret;

  /* Check whether the USB Host handle is valid */
  if (pdev == NULL)
 810c9f2:	68fb      	ldr	r3, [r7, #12]
 810c9f4:	2b00      	cmp	r3, #0
 810c9f6:	d10a      	bne.n	810ca0e <USBD_Init+0x2a>
  {
#if (USBD_DEBUG_LEVEL > 1U)
    USBD_ErrLog("Invalid Device handle");
 810c9f8:	4817      	ldr	r0, [pc, #92]	; (810ca58 <USBD_Init+0x74>)
 810c9fa:	f00e ff01 	bl	811b800 <iprintf>
 810c9fe:	4817      	ldr	r0, [pc, #92]	; (810ca5c <USBD_Init+0x78>)
 810ca00:	f00e fefe 	bl	811b800 <iprintf>
 810ca04:	200a      	movs	r0, #10
 810ca06:	f00e ff0d 	bl	811b824 <putchar>
#endif /* (USBD_DEBUG_LEVEL > 1U) */
    return USBD_FAIL;
 810ca0a:	2303      	movs	r3, #3
 810ca0c:	e01f      	b.n	810ca4e <USBD_Init+0x6a>
    pdev->NumClasses = 0;
    pdev->classId = 0;
  }
#else
  /* Unlink previous class*/
  pdev->pClass[0] = NULL;
 810ca0e:	68fb      	ldr	r3, [r7, #12]
 810ca10:	2200      	movs	r2, #0
 810ca12:	f8c3 22b8 	str.w	r2, [r3, #696]	; 0x2b8
  pdev->pUserData[0] = NULL;
 810ca16:	68fb      	ldr	r3, [r7, #12]
 810ca18:	2200      	movs	r2, #0
 810ca1a:	f8c3 22c4 	str.w	r2, [r3, #708]	; 0x2c4
#endif /* USE_USBD_COMPOSITE */

  pdev->pConfDesc = NULL;
 810ca1e:	68fb      	ldr	r3, [r7, #12]
 810ca20:	2200      	movs	r2, #0
 810ca22:	f8c3 22d0 	str.w	r2, [r3, #720]	; 0x2d0

  /* Assign USBD Descriptors */
  if (pdesc != NULL)
 810ca26:	68bb      	ldr	r3, [r7, #8]
 810ca28:	2b00      	cmp	r3, #0
 810ca2a:	d003      	beq.n	810ca34 <USBD_Init+0x50>
  {
    pdev->pDesc = pdesc;
 810ca2c:	68fb      	ldr	r3, [r7, #12]
 810ca2e:	68ba      	ldr	r2, [r7, #8]
 810ca30:	f8c3 22b4 	str.w	r2, [r3, #692]	; 0x2b4
  }

  /* Set Device initial State */
  pdev->dev_state = USBD_STATE_DEFAULT;
 810ca34:	68fb      	ldr	r3, [r7, #12]
 810ca36:	2201      	movs	r2, #1
 810ca38:	f883 229c 	strb.w	r2, [r3, #668]	; 0x29c
  pdev->id = id;
 810ca3c:	68fb      	ldr	r3, [r7, #12]
 810ca3e:	79fa      	ldrb	r2, [r7, #7]
 810ca40:	701a      	strb	r2, [r3, #0]

  /* Initialize low level driver */
  ret = USBD_LL_Init(pdev);
 810ca42:	68f8      	ldr	r0, [r7, #12]
 810ca44:	f00e fc2e 	bl	811b2a4 <USBD_LL_Init>
 810ca48:	4603      	mov	r3, r0
 810ca4a:	75fb      	strb	r3, [r7, #23]

  return ret;
 810ca4c:	7dfb      	ldrb	r3, [r7, #23]
}
 810ca4e:	4618      	mov	r0, r3
 810ca50:	3718      	adds	r7, #24
 810ca52:	46bd      	mov	sp, r7
 810ca54:	bd80      	pop	{r7, pc}
 810ca56:	bf00      	nop
 810ca58:	0811c750 	.word	0x0811c750
 810ca5c:	0811c758 	.word	0x0811c758

0810ca60 <USBD_RegisterClass>:
  * @param  pdev: Device Handle
  * @param  pclass: Class handle
  * @retval USBD Status
  */
USBD_StatusTypeDef USBD_RegisterClass(USBD_HandleTypeDef *pdev, USBD_ClassTypeDef *pclass)
{
 810ca60:	b580      	push	{r7, lr}
 810ca62:	b084      	sub	sp, #16
 810ca64:	af00      	add	r7, sp, #0
 810ca66:	6078      	str	r0, [r7, #4]
 810ca68:	6039      	str	r1, [r7, #0]
  uint16_t len = 0U;
 810ca6a:	2300      	movs	r3, #0
 810ca6c:	81fb      	strh	r3, [r7, #14]

  if (pclass == NULL)
 810ca6e:	683b      	ldr	r3, [r7, #0]
 810ca70:	2b00      	cmp	r3, #0
 810ca72:	d10a      	bne.n	810ca8a <USBD_RegisterClass+0x2a>
  {
#if (USBD_DEBUG_LEVEL > 1U)
    USBD_ErrLog("Invalid Class handle");
 810ca74:	481a      	ldr	r0, [pc, #104]	; (810cae0 <USBD_RegisterClass+0x80>)
 810ca76:	f00e fec3 	bl	811b800 <iprintf>
 810ca7a:	481a      	ldr	r0, [pc, #104]	; (810cae4 <USBD_RegisterClass+0x84>)
 810ca7c:	f00e fec0 	bl	811b800 <iprintf>
 810ca80:	200a      	movs	r0, #10
 810ca82:	f00e fecf 	bl	811b824 <putchar>
#endif /* (USBD_DEBUG_LEVEL > 1U) */
    return USBD_FAIL;
 810ca86:	2303      	movs	r3, #3
 810ca88:	e025      	b.n	810cad6 <USBD_RegisterClass+0x76>
  }

  /* link the class to the USB Device handle */
  pdev->pClass[0] = pclass;
 810ca8a:	687b      	ldr	r3, [r7, #4]
 810ca8c:	683a      	ldr	r2, [r7, #0]
 810ca8e:	f8c3 22b8 	str.w	r2, [r3, #696]	; 0x2b8
  if (pdev->pClass[pdev->classId]->GetHSConfigDescriptor != NULL)
  {
    pdev->pConfDesc = (void *)pdev->pClass[pdev->classId]->GetHSConfigDescriptor(&len);
  }
#else /* Default USE_USB_FS */
  if (pdev->pClass[pdev->classId]->GetFSConfigDescriptor != NULL)
 810ca92:	687b      	ldr	r3, [r7, #4]
 810ca94:	f8d3 22d4 	ldr.w	r2, [r3, #724]	; 0x2d4
 810ca98:	687b      	ldr	r3, [r7, #4]
 810ca9a:	32ae      	adds	r2, #174	; 0xae
 810ca9c:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 810caa0:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 810caa2:	2b00      	cmp	r3, #0
 810caa4:	d00f      	beq.n	810cac6 <USBD_RegisterClass+0x66>
  {
    pdev->pConfDesc = (void *)pdev->pClass[pdev->classId]->GetFSConfigDescriptor(&len);
 810caa6:	687b      	ldr	r3, [r7, #4]
 810caa8:	f8d3 22d4 	ldr.w	r2, [r3, #724]	; 0x2d4
 810caac:	687b      	ldr	r3, [r7, #4]
 810caae:	32ae      	adds	r2, #174	; 0xae
 810cab0:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 810cab4:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 810cab6:	f107 020e 	add.w	r2, r7, #14
 810caba:	4610      	mov	r0, r2
 810cabc:	4798      	blx	r3
 810cabe:	4602      	mov	r2, r0
 810cac0:	687b      	ldr	r3, [r7, #4]
 810cac2:	f8c3 22d0 	str.w	r2, [r3, #720]	; 0x2d0
  }
#endif /* USE_USB_FS */

  /* Increment the NumClasses */
  pdev->NumClasses++;
 810cac6:	687b      	ldr	r3, [r7, #4]
 810cac8:	f8d3 32d8 	ldr.w	r3, [r3, #728]	; 0x2d8
 810cacc:	1c5a      	adds	r2, r3, #1
 810cace:	687b      	ldr	r3, [r7, #4]
 810cad0:	f8c3 22d8 	str.w	r2, [r3, #728]	; 0x2d8

  return USBD_OK;
 810cad4:	2300      	movs	r3, #0
}
 810cad6:	4618      	mov	r0, r3
 810cad8:	3710      	adds	r7, #16
 810cada:	46bd      	mov	sp, r7
 810cadc:	bd80      	pop	{r7, pc}
 810cade:	bf00      	nop
 810cae0:	0811c750 	.word	0x0811c750
 810cae4:	0811c770 	.word	0x0811c770

0810cae8 <USBD_Start>:
  *         Start the USB Device Core.
  * @param  pdev: Device Handle
  * @retval USBD Status
  */
USBD_StatusTypeDef USBD_Start(USBD_HandleTypeDef *pdev)
{
 810cae8:	b580      	push	{r7, lr}
 810caea:	b082      	sub	sp, #8
 810caec:	af00      	add	r7, sp, #0
 810caee:	6078      	str	r0, [r7, #4]
#ifdef USE_USBD_COMPOSITE
  pdev->classId = 0U;
#endif /* USE_USBD_COMPOSITE */

  /* Start the low level driver  */
  return USBD_LL_Start(pdev);
 810caf0:	6878      	ldr	r0, [r7, #4]
 810caf2:	f00e fc27 	bl	811b344 <USBD_LL_Start>
 810caf6:	4603      	mov	r3, r0
}
 810caf8:	4618      	mov	r0, r3
 810cafa:	3708      	adds	r7, #8
 810cafc:	46bd      	mov	sp, r7
 810cafe:	bd80      	pop	{r7, pc}

0810cb00 <USBD_RunTestMode>:
  *         Launch test mode process
  * @param  pdev: device instance
  * @retval status
  */
USBD_StatusTypeDef USBD_RunTestMode(USBD_HandleTypeDef *pdev)
{
 810cb00:	b480      	push	{r7}
 810cb02:	b083      	sub	sp, #12
 810cb04:	af00      	add	r7, sp, #0
 810cb06:	6078      	str	r0, [r7, #4]
  return ret;
#else
  /* Prevent unused argument compilation warning */
  UNUSED(pdev);

  return USBD_OK;
 810cb08:	2300      	movs	r3, #0
#endif /* USBD_HS_TESTMODE_ENABLE */
}
 810cb0a:	4618      	mov	r0, r3
 810cb0c:	370c      	adds	r7, #12
 810cb0e:	46bd      	mov	sp, r7
 810cb10:	f85d 7b04 	ldr.w	r7, [sp], #4
 810cb14:	4770      	bx	lr

0810cb16 <USBD_SetClassConfig>:
  * @param  cfgidx: configuration index
  * @retval status
  */

USBD_StatusTypeDef USBD_SetClassConfig(USBD_HandleTypeDef *pdev, uint8_t cfgidx)
{
 810cb16:	b580      	push	{r7, lr}
 810cb18:	b084      	sub	sp, #16
 810cb1a:	af00      	add	r7, sp, #0
 810cb1c:	6078      	str	r0, [r7, #4]
 810cb1e:	460b      	mov	r3, r1
 810cb20:	70fb      	strb	r3, [r7, #3]
  USBD_StatusTypeDef ret = USBD_OK;
 810cb22:	2300      	movs	r3, #0
 810cb24:	73fb      	strb	r3, [r7, #15]
        }
      }
    }
  }
#else
  if (pdev->pClass[0] != NULL)
 810cb26:	687b      	ldr	r3, [r7, #4]
 810cb28:	f8d3 32b8 	ldr.w	r3, [r3, #696]	; 0x2b8
 810cb2c:	2b00      	cmp	r3, #0
 810cb2e:	d009      	beq.n	810cb44 <USBD_SetClassConfig+0x2e>
  {
    /* Set configuration and Start the Class */
    ret = (USBD_StatusTypeDef)pdev->pClass[0]->Init(pdev, cfgidx);
 810cb30:	687b      	ldr	r3, [r7, #4]
 810cb32:	f8d3 32b8 	ldr.w	r3, [r3, #696]	; 0x2b8
 810cb36:	681b      	ldr	r3, [r3, #0]
 810cb38:	78fa      	ldrb	r2, [r7, #3]
 810cb3a:	4611      	mov	r1, r2
 810cb3c:	6878      	ldr	r0, [r7, #4]
 810cb3e:	4798      	blx	r3
 810cb40:	4603      	mov	r3, r0
 810cb42:	73fb      	strb	r3, [r7, #15]
  }
#endif /* USE_USBD_COMPOSITE */

  return ret;
 810cb44:	7bfb      	ldrb	r3, [r7, #15]
}
 810cb46:	4618      	mov	r0, r3
 810cb48:	3710      	adds	r7, #16
 810cb4a:	46bd      	mov	sp, r7
 810cb4c:	bd80      	pop	{r7, pc}

0810cb4e <USBD_ClrClassConfig>:
  * @param  pdev: device instance
  * @param  cfgidx: configuration index
  * @retval status
  */
USBD_StatusTypeDef USBD_ClrClassConfig(USBD_HandleTypeDef *pdev, uint8_t cfgidx)
{
 810cb4e:	b580      	push	{r7, lr}
 810cb50:	b084      	sub	sp, #16
 810cb52:	af00      	add	r7, sp, #0
 810cb54:	6078      	str	r0, [r7, #4]
 810cb56:	460b      	mov	r3, r1
 810cb58:	70fb      	strb	r3, [r7, #3]
  USBD_StatusTypeDef ret = USBD_OK;
 810cb5a:	2300      	movs	r3, #0
 810cb5c:	73fb      	strb	r3, [r7, #15]
      }
    }
  }
#else
  /* Clear configuration  and De-initialize the Class process */
  if (pdev->pClass[0]->DeInit(pdev, cfgidx) != 0U)
 810cb5e:	687b      	ldr	r3, [r7, #4]
 810cb60:	f8d3 32b8 	ldr.w	r3, [r3, #696]	; 0x2b8
 810cb64:	685b      	ldr	r3, [r3, #4]
 810cb66:	78fa      	ldrb	r2, [r7, #3]
 810cb68:	4611      	mov	r1, r2
 810cb6a:	6878      	ldr	r0, [r7, #4]
 810cb6c:	4798      	blx	r3
 810cb6e:	4603      	mov	r3, r0
 810cb70:	2b00      	cmp	r3, #0
 810cb72:	d001      	beq.n	810cb78 <USBD_ClrClassConfig+0x2a>
  {
    ret = USBD_FAIL;
 810cb74:	2303      	movs	r3, #3
 810cb76:	73fb      	strb	r3, [r7, #15]
  }
#endif /* USE_USBD_COMPOSITE */

  return ret;
 810cb78:	7bfb      	ldrb	r3, [r7, #15]
}
 810cb7a:	4618      	mov	r0, r3
 810cb7c:	3710      	adds	r7, #16
 810cb7e:	46bd      	mov	sp, r7
 810cb80:	bd80      	pop	{r7, pc}

0810cb82 <USBD_LL_SetupStage>:
  * @param  pdev: device instance
  * @param  psetup: setup packet buffer pointer
  * @retval status
  */
USBD_StatusTypeDef USBD_LL_SetupStage(USBD_HandleTypeDef *pdev, uint8_t *psetup)
{
 810cb82:	b580      	push	{r7, lr}
 810cb84:	b084      	sub	sp, #16
 810cb86:	af00      	add	r7, sp, #0
 810cb88:	6078      	str	r0, [r7, #4]
 810cb8a:	6039      	str	r1, [r7, #0]
  USBD_StatusTypeDef ret;

  USBD_ParseSetupRequest(&pdev->request, psetup);
 810cb8c:	687b      	ldr	r3, [r7, #4]
 810cb8e:	f203 23aa 	addw	r3, r3, #682	; 0x2aa
 810cb92:	6839      	ldr	r1, [r7, #0]
 810cb94:	4618      	mov	r0, r3
 810cb96:	f001 f938 	bl	810de0a <USBD_ParseSetupRequest>

  pdev->ep0_state = USBD_EP0_SETUP;
 810cb9a:	687b      	ldr	r3, [r7, #4]
 810cb9c:	2201      	movs	r2, #1
 810cb9e:	f8c3 2294 	str.w	r2, [r3, #660]	; 0x294

  pdev->ep0_data_len = pdev->request.wLength;
 810cba2:	687b      	ldr	r3, [r7, #4]
 810cba4:	f8b3 32b0 	ldrh.w	r3, [r3, #688]	; 0x2b0
 810cba8:	461a      	mov	r2, r3
 810cbaa:	687b      	ldr	r3, [r7, #4]
 810cbac:	f8c3 2298 	str.w	r2, [r3, #664]	; 0x298

  switch (pdev->request.bmRequest & 0x1FU)
 810cbb0:	687b      	ldr	r3, [r7, #4]
 810cbb2:	f893 32aa 	ldrb.w	r3, [r3, #682]	; 0x2aa
 810cbb6:	f003 031f 	and.w	r3, r3, #31
 810cbba:	2b02      	cmp	r3, #2
 810cbbc:	d01a      	beq.n	810cbf4 <USBD_LL_SetupStage+0x72>
 810cbbe:	2b02      	cmp	r3, #2
 810cbc0:	d822      	bhi.n	810cc08 <USBD_LL_SetupStage+0x86>
 810cbc2:	2b00      	cmp	r3, #0
 810cbc4:	d002      	beq.n	810cbcc <USBD_LL_SetupStage+0x4a>
 810cbc6:	2b01      	cmp	r3, #1
 810cbc8:	d00a      	beq.n	810cbe0 <USBD_LL_SetupStage+0x5e>
 810cbca:	e01d      	b.n	810cc08 <USBD_LL_SetupStage+0x86>
  {
    case USB_REQ_RECIPIENT_DEVICE:
      ret = USBD_StdDevReq(pdev, &pdev->request);
 810cbcc:	687b      	ldr	r3, [r7, #4]
 810cbce:	f203 23aa 	addw	r3, r3, #682	; 0x2aa
 810cbd2:	4619      	mov	r1, r3
 810cbd4:	6878      	ldr	r0, [r7, #4]
 810cbd6:	f000 fb65 	bl	810d2a4 <USBD_StdDevReq>
 810cbda:	4603      	mov	r3, r0
 810cbdc:	73fb      	strb	r3, [r7, #15]
      break;
 810cbde:	e020      	b.n	810cc22 <USBD_LL_SetupStage+0xa0>

    case USB_REQ_RECIPIENT_INTERFACE:
      ret = USBD_StdItfReq(pdev, &pdev->request);
 810cbe0:	687b      	ldr	r3, [r7, #4]
 810cbe2:	f203 23aa 	addw	r3, r3, #682	; 0x2aa
 810cbe6:	4619      	mov	r1, r3
 810cbe8:	6878      	ldr	r0, [r7, #4]
 810cbea:	f000 fbcd 	bl	810d388 <USBD_StdItfReq>
 810cbee:	4603      	mov	r3, r0
 810cbf0:	73fb      	strb	r3, [r7, #15]
      break;
 810cbf2:	e016      	b.n	810cc22 <USBD_LL_SetupStage+0xa0>

    case USB_REQ_RECIPIENT_ENDPOINT:
      ret = USBD_StdEPReq(pdev, &pdev->request);
 810cbf4:	687b      	ldr	r3, [r7, #4]
 810cbf6:	f203 23aa 	addw	r3, r3, #682	; 0x2aa
 810cbfa:	4619      	mov	r1, r3
 810cbfc:	6878      	ldr	r0, [r7, #4]
 810cbfe:	f000 fc2f 	bl	810d460 <USBD_StdEPReq>
 810cc02:	4603      	mov	r3, r0
 810cc04:	73fb      	strb	r3, [r7, #15]
      break;
 810cc06:	e00c      	b.n	810cc22 <USBD_LL_SetupStage+0xa0>

    default:
      ret = USBD_LL_StallEP(pdev, (pdev->request.bmRequest & 0x80U));
 810cc08:	687b      	ldr	r3, [r7, #4]
 810cc0a:	f893 32aa 	ldrb.w	r3, [r3, #682]	; 0x2aa
 810cc0e:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
 810cc12:	b2db      	uxtb	r3, r3
 810cc14:	4619      	mov	r1, r3
 810cc16:	6878      	ldr	r0, [r7, #4]
 810cc18:	f00e fbf4 	bl	811b404 <USBD_LL_StallEP>
 810cc1c:	4603      	mov	r3, r0
 810cc1e:	73fb      	strb	r3, [r7, #15]
      break;
 810cc20:	bf00      	nop
  }

  return ret;
 810cc22:	7bfb      	ldrb	r3, [r7, #15]
}
 810cc24:	4618      	mov	r0, r3
 810cc26:	3710      	adds	r7, #16
 810cc28:	46bd      	mov	sp, r7
 810cc2a:	bd80      	pop	{r7, pc}

0810cc2c <USBD_LL_DataOutStage>:
  * @param  pdata: data pointer
  * @retval status
  */
USBD_StatusTypeDef USBD_LL_DataOutStage(USBD_HandleTypeDef *pdev,
                                        uint8_t epnum, uint8_t *pdata)
{
 810cc2c:	b580      	push	{r7, lr}
 810cc2e:	b086      	sub	sp, #24
 810cc30:	af00      	add	r7, sp, #0
 810cc32:	60f8      	str	r0, [r7, #12]
 810cc34:	460b      	mov	r3, r1
 810cc36:	607a      	str	r2, [r7, #4]
 810cc38:	72fb      	strb	r3, [r7, #11]
  USBD_EndpointTypeDef *pep;
  USBD_StatusTypeDef ret = USBD_OK;
 810cc3a:	2300      	movs	r3, #0
 810cc3c:	75fb      	strb	r3, [r7, #23]
  uint8_t idx;

  if (epnum == 0U)
 810cc3e:	7afb      	ldrb	r3, [r7, #11]
 810cc40:	2b00      	cmp	r3, #0
 810cc42:	d16e      	bne.n	810cd22 <USBD_LL_DataOutStage+0xf6>
  {
    pep = &pdev->ep_out[0];
 810cc44:	68fb      	ldr	r3, [r7, #12]
 810cc46:	f503 73aa 	add.w	r3, r3, #340	; 0x154
 810cc4a:	613b      	str	r3, [r7, #16]

    if (pdev->ep0_state == USBD_EP0_DATA_OUT)
 810cc4c:	68fb      	ldr	r3, [r7, #12]
 810cc4e:	f8d3 3294 	ldr.w	r3, [r3, #660]	; 0x294
 810cc52:	2b03      	cmp	r3, #3
 810cc54:	f040 8098 	bne.w	810cd88 <USBD_LL_DataOutStage+0x15c>
    {
      if (pep->rem_length > pep->maxpacket)
 810cc58:	693b      	ldr	r3, [r7, #16]
 810cc5a:	689a      	ldr	r2, [r3, #8]
 810cc5c:	693b      	ldr	r3, [r7, #16]
 810cc5e:	68db      	ldr	r3, [r3, #12]
 810cc60:	429a      	cmp	r2, r3
 810cc62:	d913      	bls.n	810cc8c <USBD_LL_DataOutStage+0x60>
      {
        pep->rem_length -= pep->maxpacket;
 810cc64:	693b      	ldr	r3, [r7, #16]
 810cc66:	689a      	ldr	r2, [r3, #8]
 810cc68:	693b      	ldr	r3, [r7, #16]
 810cc6a:	68db      	ldr	r3, [r3, #12]
 810cc6c:	1ad2      	subs	r2, r2, r3
 810cc6e:	693b      	ldr	r3, [r7, #16]
 810cc70:	609a      	str	r2, [r3, #8]

        (void)USBD_CtlContinueRx(pdev, pdata, MIN(pep->rem_length, pep->maxpacket));
 810cc72:	693b      	ldr	r3, [r7, #16]
 810cc74:	68da      	ldr	r2, [r3, #12]
 810cc76:	693b      	ldr	r3, [r7, #16]
 810cc78:	689b      	ldr	r3, [r3, #8]
 810cc7a:	4293      	cmp	r3, r2
 810cc7c:	bf28      	it	cs
 810cc7e:	4613      	movcs	r3, r2
 810cc80:	461a      	mov	r2, r3
 810cc82:	6879      	ldr	r1, [r7, #4]
 810cc84:	68f8      	ldr	r0, [r7, #12]
 810cc86:	f001 fbcd 	bl	810e424 <USBD_CtlContinueRx>
 810cc8a:	e07d      	b.n	810cd88 <USBD_LL_DataOutStage+0x15c>
      }
      else
      {
        /* Find the class ID relative to the current request */
        switch (pdev->request.bmRequest & 0x1FU)
 810cc8c:	68fb      	ldr	r3, [r7, #12]
 810cc8e:	f893 32aa 	ldrb.w	r3, [r3, #682]	; 0x2aa
 810cc92:	f003 031f 	and.w	r3, r3, #31
 810cc96:	2b02      	cmp	r3, #2
 810cc98:	d014      	beq.n	810ccc4 <USBD_LL_DataOutStage+0x98>
 810cc9a:	2b02      	cmp	r3, #2
 810cc9c:	d81d      	bhi.n	810ccda <USBD_LL_DataOutStage+0xae>
 810cc9e:	2b00      	cmp	r3, #0
 810cca0:	d002      	beq.n	810cca8 <USBD_LL_DataOutStage+0x7c>
 810cca2:	2b01      	cmp	r3, #1
 810cca4:	d003      	beq.n	810ccae <USBD_LL_DataOutStage+0x82>
 810cca6:	e018      	b.n	810ccda <USBD_LL_DataOutStage+0xae>
        {
          case USB_REQ_RECIPIENT_DEVICE:
            /* Device requests must be managed by the first instantiated class
               (or duplicated by all classes for simplicity) */
            idx = 0U;
 810cca8:	2300      	movs	r3, #0
 810ccaa:	75bb      	strb	r3, [r7, #22]
            break;
 810ccac:	e018      	b.n	810cce0 <USBD_LL_DataOutStage+0xb4>

          case USB_REQ_RECIPIENT_INTERFACE:
            idx = USBD_CoreFindIF(pdev, LOBYTE(pdev->request.wIndex));
 810ccae:	68fb      	ldr	r3, [r7, #12]
 810ccb0:	f8b3 32ae 	ldrh.w	r3, [r3, #686]	; 0x2ae
 810ccb4:	b2db      	uxtb	r3, r3
 810ccb6:	4619      	mov	r1, r3
 810ccb8:	68f8      	ldr	r0, [r7, #12]
 810ccba:	f000 fa64 	bl	810d186 <USBD_CoreFindIF>
 810ccbe:	4603      	mov	r3, r0
 810ccc0:	75bb      	strb	r3, [r7, #22]
            break;
 810ccc2:	e00d      	b.n	810cce0 <USBD_LL_DataOutStage+0xb4>

          case USB_REQ_RECIPIENT_ENDPOINT:
            idx = USBD_CoreFindEP(pdev, LOBYTE(pdev->request.wIndex));
 810ccc4:	68fb      	ldr	r3, [r7, #12]
 810ccc6:	f8b3 32ae 	ldrh.w	r3, [r3, #686]	; 0x2ae
 810ccca:	b2db      	uxtb	r3, r3
 810cccc:	4619      	mov	r1, r3
 810ccce:	68f8      	ldr	r0, [r7, #12]
 810ccd0:	f000 fa66 	bl	810d1a0 <USBD_CoreFindEP>
 810ccd4:	4603      	mov	r3, r0
 810ccd6:	75bb      	strb	r3, [r7, #22]
            break;
 810ccd8:	e002      	b.n	810cce0 <USBD_LL_DataOutStage+0xb4>

          default:
            /* Back to the first class in case of doubt */
            idx = 0U;
 810ccda:	2300      	movs	r3, #0
 810ccdc:	75bb      	strb	r3, [r7, #22]
            break;
 810ccde:	bf00      	nop
        }

        if (idx < USBD_MAX_SUPPORTED_CLASS)
 810cce0:	7dbb      	ldrb	r3, [r7, #22]
 810cce2:	2b00      	cmp	r3, #0
 810cce4:	d119      	bne.n	810cd1a <USBD_LL_DataOutStage+0xee>
        {
          /* Setup the class ID and route the request to the relative class function */
          if (pdev->dev_state == USBD_STATE_CONFIGURED)
 810cce6:	68fb      	ldr	r3, [r7, #12]
 810cce8:	f893 329c 	ldrb.w	r3, [r3, #668]	; 0x29c
 810ccec:	b2db      	uxtb	r3, r3
 810ccee:	2b03      	cmp	r3, #3
 810ccf0:	d113      	bne.n	810cd1a <USBD_LL_DataOutStage+0xee>
          {
            if (pdev->pClass[idx]->EP0_RxReady != NULL)
 810ccf2:	7dba      	ldrb	r2, [r7, #22]
 810ccf4:	68fb      	ldr	r3, [r7, #12]
 810ccf6:	32ae      	adds	r2, #174	; 0xae
 810ccf8:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 810ccfc:	691b      	ldr	r3, [r3, #16]
 810ccfe:	2b00      	cmp	r3, #0
 810cd00:	d00b      	beq.n	810cd1a <USBD_LL_DataOutStage+0xee>
            {
              pdev->classId = idx;
 810cd02:	7dba      	ldrb	r2, [r7, #22]
 810cd04:	68fb      	ldr	r3, [r7, #12]
 810cd06:	f8c3 22d4 	str.w	r2, [r3, #724]	; 0x2d4
              pdev->pClass[idx]->EP0_RxReady(pdev);
 810cd0a:	7dba      	ldrb	r2, [r7, #22]
 810cd0c:	68fb      	ldr	r3, [r7, #12]
 810cd0e:	32ae      	adds	r2, #174	; 0xae
 810cd10:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 810cd14:	691b      	ldr	r3, [r3, #16]
 810cd16:	68f8      	ldr	r0, [r7, #12]
 810cd18:	4798      	blx	r3
            }
          }
        }

        (void)USBD_CtlSendStatus(pdev);
 810cd1a:	68f8      	ldr	r0, [r7, #12]
 810cd1c:	f001 fb93 	bl	810e446 <USBD_CtlSendStatus>
 810cd20:	e032      	b.n	810cd88 <USBD_LL_DataOutStage+0x15c>
    }
  }
  else
  {
    /* Get the class index relative to this interface */
    idx = USBD_CoreFindEP(pdev, (epnum & 0x7FU));
 810cd22:	7afb      	ldrb	r3, [r7, #11]
 810cd24:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 810cd28:	b2db      	uxtb	r3, r3
 810cd2a:	4619      	mov	r1, r3
 810cd2c:	68f8      	ldr	r0, [r7, #12]
 810cd2e:	f000 fa37 	bl	810d1a0 <USBD_CoreFindEP>
 810cd32:	4603      	mov	r3, r0
 810cd34:	75bb      	strb	r3, [r7, #22]

    if (((uint16_t)idx != 0xFFU) && (idx < USBD_MAX_SUPPORTED_CLASS))
 810cd36:	7dbb      	ldrb	r3, [r7, #22]
 810cd38:	2bff      	cmp	r3, #255	; 0xff
 810cd3a:	d025      	beq.n	810cd88 <USBD_LL_DataOutStage+0x15c>
 810cd3c:	7dbb      	ldrb	r3, [r7, #22]
 810cd3e:	2b00      	cmp	r3, #0
 810cd40:	d122      	bne.n	810cd88 <USBD_LL_DataOutStage+0x15c>
    {
      /* Call the class data out function to manage the request */
      if (pdev->dev_state == USBD_STATE_CONFIGURED)
 810cd42:	68fb      	ldr	r3, [r7, #12]
 810cd44:	f893 329c 	ldrb.w	r3, [r3, #668]	; 0x29c
 810cd48:	b2db      	uxtb	r3, r3
 810cd4a:	2b03      	cmp	r3, #3
 810cd4c:	d117      	bne.n	810cd7e <USBD_LL_DataOutStage+0x152>
      {
        if (pdev->pClass[idx]->DataOut != NULL)
 810cd4e:	7dba      	ldrb	r2, [r7, #22]
 810cd50:	68fb      	ldr	r3, [r7, #12]
 810cd52:	32ae      	adds	r2, #174	; 0xae
 810cd54:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 810cd58:	699b      	ldr	r3, [r3, #24]
 810cd5a:	2b00      	cmp	r3, #0
 810cd5c:	d00f      	beq.n	810cd7e <USBD_LL_DataOutStage+0x152>
        {
          pdev->classId = idx;
 810cd5e:	7dba      	ldrb	r2, [r7, #22]
 810cd60:	68fb      	ldr	r3, [r7, #12]
 810cd62:	f8c3 22d4 	str.w	r2, [r3, #724]	; 0x2d4
          ret = (USBD_StatusTypeDef)pdev->pClass[idx]->DataOut(pdev, epnum);
 810cd66:	7dba      	ldrb	r2, [r7, #22]
 810cd68:	68fb      	ldr	r3, [r7, #12]
 810cd6a:	32ae      	adds	r2, #174	; 0xae
 810cd6c:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 810cd70:	699b      	ldr	r3, [r3, #24]
 810cd72:	7afa      	ldrb	r2, [r7, #11]
 810cd74:	4611      	mov	r1, r2
 810cd76:	68f8      	ldr	r0, [r7, #12]
 810cd78:	4798      	blx	r3
 810cd7a:	4603      	mov	r3, r0
 810cd7c:	75fb      	strb	r3, [r7, #23]
        }
      }
      if (ret != USBD_OK)
 810cd7e:	7dfb      	ldrb	r3, [r7, #23]
 810cd80:	2b00      	cmp	r3, #0
 810cd82:	d001      	beq.n	810cd88 <USBD_LL_DataOutStage+0x15c>
      {
        return ret;
 810cd84:	7dfb      	ldrb	r3, [r7, #23]
 810cd86:	e000      	b.n	810cd8a <USBD_LL_DataOutStage+0x15e>
      }
    }
  }

  return USBD_OK;
 810cd88:	2300      	movs	r3, #0
}
 810cd8a:	4618      	mov	r0, r3
 810cd8c:	3718      	adds	r7, #24
 810cd8e:	46bd      	mov	sp, r7
 810cd90:	bd80      	pop	{r7, pc}

0810cd92 <USBD_LL_DataInStage>:
  * @param  pdata: data pointer
  * @retval status
  */
USBD_StatusTypeDef USBD_LL_DataInStage(USBD_HandleTypeDef *pdev,
                                       uint8_t epnum, uint8_t *pdata)
{
 810cd92:	b580      	push	{r7, lr}
 810cd94:	b086      	sub	sp, #24
 810cd96:	af00      	add	r7, sp, #0
 810cd98:	60f8      	str	r0, [r7, #12]
 810cd9a:	460b      	mov	r3, r1
 810cd9c:	607a      	str	r2, [r7, #4]
 810cd9e:	72fb      	strb	r3, [r7, #11]
  USBD_EndpointTypeDef *pep;
  USBD_StatusTypeDef ret;
  uint8_t idx;

  if (epnum == 0U)
 810cda0:	7afb      	ldrb	r3, [r7, #11]
 810cda2:	2b00      	cmp	r3, #0
 810cda4:	d16f      	bne.n	810ce86 <USBD_LL_DataInStage+0xf4>
  {
    pep = &pdev->ep_in[0];
 810cda6:	68fb      	ldr	r3, [r7, #12]
 810cda8:	3314      	adds	r3, #20
 810cdaa:	613b      	str	r3, [r7, #16]

    if (pdev->ep0_state == USBD_EP0_DATA_IN)
 810cdac:	68fb      	ldr	r3, [r7, #12]
 810cdae:	f8d3 3294 	ldr.w	r3, [r3, #660]	; 0x294
 810cdb2:	2b02      	cmp	r3, #2
 810cdb4:	d15a      	bne.n	810ce6c <USBD_LL_DataInStage+0xda>
    {
      if (pep->rem_length > pep->maxpacket)
 810cdb6:	693b      	ldr	r3, [r7, #16]
 810cdb8:	689a      	ldr	r2, [r3, #8]
 810cdba:	693b      	ldr	r3, [r7, #16]
 810cdbc:	68db      	ldr	r3, [r3, #12]
 810cdbe:	429a      	cmp	r2, r3
 810cdc0:	d914      	bls.n	810cdec <USBD_LL_DataInStage+0x5a>
      {
        pep->rem_length -= pep->maxpacket;
 810cdc2:	693b      	ldr	r3, [r7, #16]
 810cdc4:	689a      	ldr	r2, [r3, #8]
 810cdc6:	693b      	ldr	r3, [r7, #16]
 810cdc8:	68db      	ldr	r3, [r3, #12]
 810cdca:	1ad2      	subs	r2, r2, r3
 810cdcc:	693b      	ldr	r3, [r7, #16]
 810cdce:	609a      	str	r2, [r3, #8]

        (void)USBD_CtlContinueSendData(pdev, pdata, pep->rem_length);
 810cdd0:	693b      	ldr	r3, [r7, #16]
 810cdd2:	689b      	ldr	r3, [r3, #8]
 810cdd4:	461a      	mov	r2, r3
 810cdd6:	6879      	ldr	r1, [r7, #4]
 810cdd8:	68f8      	ldr	r0, [r7, #12]
 810cdda:	f001 fb12 	bl	810e402 <USBD_CtlContinueSendData>

        /* Prepare endpoint for premature end of transfer */
        (void)USBD_LL_PrepareReceive(pdev, 0U, NULL, 0U);
 810cdde:	2300      	movs	r3, #0
 810cde0:	2200      	movs	r2, #0
 810cde2:	2100      	movs	r1, #0
 810cde4:	68f8      	ldr	r0, [r7, #12]
 810cde6:	f00e fbb7 	bl	811b558 <USBD_LL_PrepareReceive>
 810cdea:	e03f      	b.n	810ce6c <USBD_LL_DataInStage+0xda>
      }
      else
      {
        /* last packet is MPS multiple, so send ZLP packet */
        if ((pep->maxpacket == pep->rem_length) &&
 810cdec:	693b      	ldr	r3, [r7, #16]
 810cdee:	68da      	ldr	r2, [r3, #12]
 810cdf0:	693b      	ldr	r3, [r7, #16]
 810cdf2:	689b      	ldr	r3, [r3, #8]
 810cdf4:	429a      	cmp	r2, r3
 810cdf6:	d11c      	bne.n	810ce32 <USBD_LL_DataInStage+0xa0>
            (pep->total_length >= pep->maxpacket) &&
 810cdf8:	693b      	ldr	r3, [r7, #16]
 810cdfa:	685a      	ldr	r2, [r3, #4]
 810cdfc:	693b      	ldr	r3, [r7, #16]
 810cdfe:	68db      	ldr	r3, [r3, #12]
        if ((pep->maxpacket == pep->rem_length) &&
 810ce00:	429a      	cmp	r2, r3
 810ce02:	d316      	bcc.n	810ce32 <USBD_LL_DataInStage+0xa0>
            (pep->total_length < pdev->ep0_data_len))
 810ce04:	693b      	ldr	r3, [r7, #16]
 810ce06:	685a      	ldr	r2, [r3, #4]
 810ce08:	68fb      	ldr	r3, [r7, #12]
 810ce0a:	f8d3 3298 	ldr.w	r3, [r3, #664]	; 0x298
            (pep->total_length >= pep->maxpacket) &&
 810ce0e:	429a      	cmp	r2, r3
 810ce10:	d20f      	bcs.n	810ce32 <USBD_LL_DataInStage+0xa0>
        {
          (void)USBD_CtlContinueSendData(pdev, NULL, 0U);
 810ce12:	2200      	movs	r2, #0
 810ce14:	2100      	movs	r1, #0
 810ce16:	68f8      	ldr	r0, [r7, #12]
 810ce18:	f001 faf3 	bl	810e402 <USBD_CtlContinueSendData>
          pdev->ep0_data_len = 0U;
 810ce1c:	68fb      	ldr	r3, [r7, #12]
 810ce1e:	2200      	movs	r2, #0
 810ce20:	f8c3 2298 	str.w	r2, [r3, #664]	; 0x298

          /* Prepare endpoint for premature end of transfer */
          (void)USBD_LL_PrepareReceive(pdev, 0U, NULL, 0U);
 810ce24:	2300      	movs	r3, #0
 810ce26:	2200      	movs	r2, #0
 810ce28:	2100      	movs	r1, #0
 810ce2a:	68f8      	ldr	r0, [r7, #12]
 810ce2c:	f00e fb94 	bl	811b558 <USBD_LL_PrepareReceive>
 810ce30:	e01c      	b.n	810ce6c <USBD_LL_DataInStage+0xda>
        }
        else
        {
          if (pdev->dev_state == USBD_STATE_CONFIGURED)
 810ce32:	68fb      	ldr	r3, [r7, #12]
 810ce34:	f893 329c 	ldrb.w	r3, [r3, #668]	; 0x29c
 810ce38:	b2db      	uxtb	r3, r3
 810ce3a:	2b03      	cmp	r3, #3
 810ce3c:	d10f      	bne.n	810ce5e <USBD_LL_DataInStage+0xcc>
          {
            if (pdev->pClass[0]->EP0_TxSent != NULL)
 810ce3e:	68fb      	ldr	r3, [r7, #12]
 810ce40:	f8d3 32b8 	ldr.w	r3, [r3, #696]	; 0x2b8
 810ce44:	68db      	ldr	r3, [r3, #12]
 810ce46:	2b00      	cmp	r3, #0
 810ce48:	d009      	beq.n	810ce5e <USBD_LL_DataInStage+0xcc>
            {
              pdev->classId = 0U;
 810ce4a:	68fb      	ldr	r3, [r7, #12]
 810ce4c:	2200      	movs	r2, #0
 810ce4e:	f8c3 22d4 	str.w	r2, [r3, #724]	; 0x2d4
              pdev->pClass[0]->EP0_TxSent(pdev);
 810ce52:	68fb      	ldr	r3, [r7, #12]
 810ce54:	f8d3 32b8 	ldr.w	r3, [r3, #696]	; 0x2b8
 810ce58:	68db      	ldr	r3, [r3, #12]
 810ce5a:	68f8      	ldr	r0, [r7, #12]
 810ce5c:	4798      	blx	r3
            }
          }
          (void)USBD_LL_StallEP(pdev, 0x80U);
 810ce5e:	2180      	movs	r1, #128	; 0x80
 810ce60:	68f8      	ldr	r0, [r7, #12]
 810ce62:	f00e facf 	bl	811b404 <USBD_LL_StallEP>
          (void)USBD_CtlReceiveStatus(pdev);
 810ce66:	68f8      	ldr	r0, [r7, #12]
 810ce68:	f001 fb00 	bl	810e46c <USBD_CtlReceiveStatus>
        }
      }
    }

    if (pdev->dev_test_mode != 0U)
 810ce6c:	68fb      	ldr	r3, [r7, #12]
 810ce6e:	f893 32a0 	ldrb.w	r3, [r3, #672]	; 0x2a0
 810ce72:	2b00      	cmp	r3, #0
 810ce74:	d03a      	beq.n	810ceec <USBD_LL_DataInStage+0x15a>
    {
      (void)USBD_RunTestMode(pdev);
 810ce76:	68f8      	ldr	r0, [r7, #12]
 810ce78:	f7ff fe42 	bl	810cb00 <USBD_RunTestMode>
      pdev->dev_test_mode = 0U;
 810ce7c:	68fb      	ldr	r3, [r7, #12]
 810ce7e:	2200      	movs	r2, #0
 810ce80:	f883 22a0 	strb.w	r2, [r3, #672]	; 0x2a0
 810ce84:	e032      	b.n	810ceec <USBD_LL_DataInStage+0x15a>
    }
  }
  else
  {
    /* Get the class index relative to this interface */
    idx = USBD_CoreFindEP(pdev, ((uint8_t)epnum | 0x80U));
 810ce86:	7afb      	ldrb	r3, [r7, #11]
 810ce88:	f063 037f 	orn	r3, r3, #127	; 0x7f
 810ce8c:	b2db      	uxtb	r3, r3
 810ce8e:	4619      	mov	r1, r3
 810ce90:	68f8      	ldr	r0, [r7, #12]
 810ce92:	f000 f985 	bl	810d1a0 <USBD_CoreFindEP>
 810ce96:	4603      	mov	r3, r0
 810ce98:	75fb      	strb	r3, [r7, #23]

    if (((uint16_t)idx != 0xFFU) && (idx < USBD_MAX_SUPPORTED_CLASS))
 810ce9a:	7dfb      	ldrb	r3, [r7, #23]
 810ce9c:	2bff      	cmp	r3, #255	; 0xff
 810ce9e:	d025      	beq.n	810ceec <USBD_LL_DataInStage+0x15a>
 810cea0:	7dfb      	ldrb	r3, [r7, #23]
 810cea2:	2b00      	cmp	r3, #0
 810cea4:	d122      	bne.n	810ceec <USBD_LL_DataInStage+0x15a>
    {
      /* Call the class data out function to manage the request */
      if (pdev->dev_state == USBD_STATE_CONFIGURED)
 810cea6:	68fb      	ldr	r3, [r7, #12]
 810cea8:	f893 329c 	ldrb.w	r3, [r3, #668]	; 0x29c
 810ceac:	b2db      	uxtb	r3, r3
 810ceae:	2b03      	cmp	r3, #3
 810ceb0:	d11c      	bne.n	810ceec <USBD_LL_DataInStage+0x15a>
      {
        if (pdev->pClass[idx]->DataIn != NULL)
 810ceb2:	7dfa      	ldrb	r2, [r7, #23]
 810ceb4:	68fb      	ldr	r3, [r7, #12]
 810ceb6:	32ae      	adds	r2, #174	; 0xae
 810ceb8:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 810cebc:	695b      	ldr	r3, [r3, #20]
 810cebe:	2b00      	cmp	r3, #0
 810cec0:	d014      	beq.n	810ceec <USBD_LL_DataInStage+0x15a>
        {
          pdev->classId = idx;
 810cec2:	7dfa      	ldrb	r2, [r7, #23]
 810cec4:	68fb      	ldr	r3, [r7, #12]
 810cec6:	f8c3 22d4 	str.w	r2, [r3, #724]	; 0x2d4
          ret = (USBD_StatusTypeDef)pdev->pClass[idx]->DataIn(pdev, epnum);
 810ceca:	7dfa      	ldrb	r2, [r7, #23]
 810cecc:	68fb      	ldr	r3, [r7, #12]
 810cece:	32ae      	adds	r2, #174	; 0xae
 810ced0:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 810ced4:	695b      	ldr	r3, [r3, #20]
 810ced6:	7afa      	ldrb	r2, [r7, #11]
 810ced8:	4611      	mov	r1, r2
 810ceda:	68f8      	ldr	r0, [r7, #12]
 810cedc:	4798      	blx	r3
 810cede:	4603      	mov	r3, r0
 810cee0:	75bb      	strb	r3, [r7, #22]

          if (ret != USBD_OK)
 810cee2:	7dbb      	ldrb	r3, [r7, #22]
 810cee4:	2b00      	cmp	r3, #0
 810cee6:	d001      	beq.n	810ceec <USBD_LL_DataInStage+0x15a>
          {
            return ret;
 810cee8:	7dbb      	ldrb	r3, [r7, #22]
 810ceea:	e000      	b.n	810ceee <USBD_LL_DataInStage+0x15c>
        }
      }
    }
  }

  return USBD_OK;
 810ceec:	2300      	movs	r3, #0
}
 810ceee:	4618      	mov	r0, r3
 810cef0:	3718      	adds	r7, #24
 810cef2:	46bd      	mov	sp, r7
 810cef4:	bd80      	pop	{r7, pc}

0810cef6 <USBD_LL_Reset>:
  *         Handle Reset event
  * @param  pdev: device instance
  * @retval status
  */
USBD_StatusTypeDef USBD_LL_Reset(USBD_HandleTypeDef *pdev)
{
 810cef6:	b580      	push	{r7, lr}
 810cef8:	b084      	sub	sp, #16
 810cefa:	af00      	add	r7, sp, #0
 810cefc:	6078      	str	r0, [r7, #4]
  USBD_StatusTypeDef ret = USBD_OK;
 810cefe:	2300      	movs	r3, #0
 810cf00:	73fb      	strb	r3, [r7, #15]

  /* Upon Reset call user call back */
  pdev->dev_state = USBD_STATE_DEFAULT;
 810cf02:	687b      	ldr	r3, [r7, #4]
 810cf04:	2201      	movs	r2, #1
 810cf06:	f883 229c 	strb.w	r2, [r3, #668]	; 0x29c
  pdev->ep0_state = USBD_EP0_IDLE;
 810cf0a:	687b      	ldr	r3, [r7, #4]
 810cf0c:	2200      	movs	r2, #0
 810cf0e:	f8c3 2294 	str.w	r2, [r3, #660]	; 0x294
  pdev->dev_config = 0U;
 810cf12:	687b      	ldr	r3, [r7, #4]
 810cf14:	2200      	movs	r2, #0
 810cf16:	605a      	str	r2, [r3, #4]
  pdev->dev_remote_wakeup = 0U;
 810cf18:	687b      	ldr	r3, [r7, #4]
 810cf1a:	2200      	movs	r2, #0
 810cf1c:	f8c3 22a4 	str.w	r2, [r3, #676]	; 0x2a4
  pdev->dev_test_mode = 0U;
 810cf20:	687b      	ldr	r3, [r7, #4]
 810cf22:	2200      	movs	r2, #0
 810cf24:	f883 22a0 	strb.w	r2, [r3, #672]	; 0x2a0
      }
    }
  }
#else

  if (pdev->pClass[0] != NULL)
 810cf28:	687b      	ldr	r3, [r7, #4]
 810cf2a:	f8d3 32b8 	ldr.w	r3, [r3, #696]	; 0x2b8
 810cf2e:	2b00      	cmp	r3, #0
 810cf30:	d014      	beq.n	810cf5c <USBD_LL_Reset+0x66>
  {
    if (pdev->pClass[0]->DeInit != NULL)
 810cf32:	687b      	ldr	r3, [r7, #4]
 810cf34:	f8d3 32b8 	ldr.w	r3, [r3, #696]	; 0x2b8
 810cf38:	685b      	ldr	r3, [r3, #4]
 810cf3a:	2b00      	cmp	r3, #0
 810cf3c:	d00e      	beq.n	810cf5c <USBD_LL_Reset+0x66>
    {
      if (pdev->pClass[0]->DeInit(pdev, (uint8_t)pdev->dev_config) != USBD_OK)
 810cf3e:	687b      	ldr	r3, [r7, #4]
 810cf40:	f8d3 32b8 	ldr.w	r3, [r3, #696]	; 0x2b8
 810cf44:	685b      	ldr	r3, [r3, #4]
 810cf46:	687a      	ldr	r2, [r7, #4]
 810cf48:	6852      	ldr	r2, [r2, #4]
 810cf4a:	b2d2      	uxtb	r2, r2
 810cf4c:	4611      	mov	r1, r2
 810cf4e:	6878      	ldr	r0, [r7, #4]
 810cf50:	4798      	blx	r3
 810cf52:	4603      	mov	r3, r0
 810cf54:	2b00      	cmp	r3, #0
 810cf56:	d001      	beq.n	810cf5c <USBD_LL_Reset+0x66>
      {
        ret = USBD_FAIL;
 810cf58:	2303      	movs	r3, #3
 810cf5a:	73fb      	strb	r3, [r7, #15]
    }
  }
#endif /* USE_USBD_COMPOSITE */

  /* Open EP0 OUT */
  (void)USBD_LL_OpenEP(pdev, 0x00U, USBD_EP_TYPE_CTRL, USB_MAX_EP0_SIZE);
 810cf5c:	2340      	movs	r3, #64	; 0x40
 810cf5e:	2200      	movs	r2, #0
 810cf60:	2100      	movs	r1, #0
 810cf62:	6878      	ldr	r0, [r7, #4]
 810cf64:	f00e fa09 	bl	811b37a <USBD_LL_OpenEP>
  pdev->ep_out[0x00U & 0xFU].is_used = 1U;
 810cf68:	687b      	ldr	r3, [r7, #4]
 810cf6a:	2201      	movs	r2, #1
 810cf6c:	f8a3 2164 	strh.w	r2, [r3, #356]	; 0x164

  pdev->ep_out[0].maxpacket = USB_MAX_EP0_SIZE;
 810cf70:	687b      	ldr	r3, [r7, #4]
 810cf72:	2240      	movs	r2, #64	; 0x40
 810cf74:	f8c3 2160 	str.w	r2, [r3, #352]	; 0x160

  /* Open EP0 IN */
  (void)USBD_LL_OpenEP(pdev, 0x80U, USBD_EP_TYPE_CTRL, USB_MAX_EP0_SIZE);
 810cf78:	2340      	movs	r3, #64	; 0x40
 810cf7a:	2200      	movs	r2, #0
 810cf7c:	2180      	movs	r1, #128	; 0x80
 810cf7e:	6878      	ldr	r0, [r7, #4]
 810cf80:	f00e f9fb 	bl	811b37a <USBD_LL_OpenEP>
  pdev->ep_in[0x80U & 0xFU].is_used = 1U;
 810cf84:	687b      	ldr	r3, [r7, #4]
 810cf86:	2201      	movs	r2, #1
 810cf88:	849a      	strh	r2, [r3, #36]	; 0x24

  pdev->ep_in[0].maxpacket = USB_MAX_EP0_SIZE;
 810cf8a:	687b      	ldr	r3, [r7, #4]
 810cf8c:	2240      	movs	r2, #64	; 0x40
 810cf8e:	621a      	str	r2, [r3, #32]

  return ret;
 810cf90:	7bfb      	ldrb	r3, [r7, #15]
}
 810cf92:	4618      	mov	r0, r3
 810cf94:	3710      	adds	r7, #16
 810cf96:	46bd      	mov	sp, r7
 810cf98:	bd80      	pop	{r7, pc}

0810cf9a <USBD_LL_SetSpeed>:
  * @param  pdev: device instance
  * @retval status
  */
USBD_StatusTypeDef USBD_LL_SetSpeed(USBD_HandleTypeDef *pdev,
                                    USBD_SpeedTypeDef speed)
{
 810cf9a:	b480      	push	{r7}
 810cf9c:	b083      	sub	sp, #12
 810cf9e:	af00      	add	r7, sp, #0
 810cfa0:	6078      	str	r0, [r7, #4]
 810cfa2:	460b      	mov	r3, r1
 810cfa4:	70fb      	strb	r3, [r7, #3]
  pdev->dev_speed = speed;
 810cfa6:	687b      	ldr	r3, [r7, #4]
 810cfa8:	78fa      	ldrb	r2, [r7, #3]
 810cfaa:	741a      	strb	r2, [r3, #16]

  return USBD_OK;
 810cfac:	2300      	movs	r3, #0
}
 810cfae:	4618      	mov	r0, r3
 810cfb0:	370c      	adds	r7, #12
 810cfb2:	46bd      	mov	sp, r7
 810cfb4:	f85d 7b04 	ldr.w	r7, [sp], #4
 810cfb8:	4770      	bx	lr

0810cfba <USBD_LL_Suspend>:
  *         Handle Suspend event
  * @param  pdev: device instance
  * @retval status
  */
USBD_StatusTypeDef USBD_LL_Suspend(USBD_HandleTypeDef *pdev)
{
 810cfba:	b480      	push	{r7}
 810cfbc:	b083      	sub	sp, #12
 810cfbe:	af00      	add	r7, sp, #0
 810cfc0:	6078      	str	r0, [r7, #4]
  if (pdev->dev_state != USBD_STATE_SUSPENDED)
 810cfc2:	687b      	ldr	r3, [r7, #4]
 810cfc4:	f893 329c 	ldrb.w	r3, [r3, #668]	; 0x29c
 810cfc8:	b2db      	uxtb	r3, r3
 810cfca:	2b04      	cmp	r3, #4
 810cfcc:	d006      	beq.n	810cfdc <USBD_LL_Suspend+0x22>
  {
    pdev->dev_old_state = pdev->dev_state;
 810cfce:	687b      	ldr	r3, [r7, #4]
 810cfd0:	f893 329c 	ldrb.w	r3, [r3, #668]	; 0x29c
 810cfd4:	b2da      	uxtb	r2, r3
 810cfd6:	687b      	ldr	r3, [r7, #4]
 810cfd8:	f883 229d 	strb.w	r2, [r3, #669]	; 0x29d
  }

  pdev->dev_state = USBD_STATE_SUSPENDED;
 810cfdc:	687b      	ldr	r3, [r7, #4]
 810cfde:	2204      	movs	r2, #4
 810cfe0:	f883 229c 	strb.w	r2, [r3, #668]	; 0x29c

  return USBD_OK;
 810cfe4:	2300      	movs	r3, #0
}
 810cfe6:	4618      	mov	r0, r3
 810cfe8:	370c      	adds	r7, #12
 810cfea:	46bd      	mov	sp, r7
 810cfec:	f85d 7b04 	ldr.w	r7, [sp], #4
 810cff0:	4770      	bx	lr

0810cff2 <USBD_LL_Resume>:
  *         Handle Resume event
  * @param  pdev: device instance
  * @retval status
  */
USBD_StatusTypeDef USBD_LL_Resume(USBD_HandleTypeDef *pdev)
{
 810cff2:	b480      	push	{r7}
 810cff4:	b083      	sub	sp, #12
 810cff6:	af00      	add	r7, sp, #0
 810cff8:	6078      	str	r0, [r7, #4]
  if (pdev->dev_state == USBD_STATE_SUSPENDED)
 810cffa:	687b      	ldr	r3, [r7, #4]
 810cffc:	f893 329c 	ldrb.w	r3, [r3, #668]	; 0x29c
 810d000:	b2db      	uxtb	r3, r3
 810d002:	2b04      	cmp	r3, #4
 810d004:	d106      	bne.n	810d014 <USBD_LL_Resume+0x22>
  {
    pdev->dev_state = pdev->dev_old_state;
 810d006:	687b      	ldr	r3, [r7, #4]
 810d008:	f893 329d 	ldrb.w	r3, [r3, #669]	; 0x29d
 810d00c:	b2da      	uxtb	r2, r3
 810d00e:	687b      	ldr	r3, [r7, #4]
 810d010:	f883 229c 	strb.w	r2, [r3, #668]	; 0x29c
  }

  return USBD_OK;
 810d014:	2300      	movs	r3, #0
}
 810d016:	4618      	mov	r0, r3
 810d018:	370c      	adds	r7, #12
 810d01a:	46bd      	mov	sp, r7
 810d01c:	f85d 7b04 	ldr.w	r7, [sp], #4
 810d020:	4770      	bx	lr

0810d022 <USBD_LL_SOF>:
  *         Handle SOF event
  * @param  pdev: device instance
  * @retval status
  */
USBD_StatusTypeDef USBD_LL_SOF(USBD_HandleTypeDef *pdev)
{
 810d022:	b580      	push	{r7, lr}
 810d024:	b082      	sub	sp, #8
 810d026:	af00      	add	r7, sp, #0
 810d028:	6078      	str	r0, [r7, #4]
  /* The SOF event can be distributed for all classes that support it */
  if (pdev->dev_state == USBD_STATE_CONFIGURED)
 810d02a:	687b      	ldr	r3, [r7, #4]
 810d02c:	f893 329c 	ldrb.w	r3, [r3, #668]	; 0x29c
 810d030:	b2db      	uxtb	r3, r3
 810d032:	2b03      	cmp	r3, #3
 810d034:	d110      	bne.n	810d058 <USBD_LL_SOF+0x36>
          }
        }
      }
    }
#else
    if (pdev->pClass[0] != NULL)
 810d036:	687b      	ldr	r3, [r7, #4]
 810d038:	f8d3 32b8 	ldr.w	r3, [r3, #696]	; 0x2b8
 810d03c:	2b00      	cmp	r3, #0
 810d03e:	d00b      	beq.n	810d058 <USBD_LL_SOF+0x36>
    {
      if (pdev->pClass[0]->SOF != NULL)
 810d040:	687b      	ldr	r3, [r7, #4]
 810d042:	f8d3 32b8 	ldr.w	r3, [r3, #696]	; 0x2b8
 810d046:	69db      	ldr	r3, [r3, #28]
 810d048:	2b00      	cmp	r3, #0
 810d04a:	d005      	beq.n	810d058 <USBD_LL_SOF+0x36>
      {
        (void)pdev->pClass[0]->SOF(pdev);
 810d04c:	687b      	ldr	r3, [r7, #4]
 810d04e:	f8d3 32b8 	ldr.w	r3, [r3, #696]	; 0x2b8
 810d052:	69db      	ldr	r3, [r3, #28]
 810d054:	6878      	ldr	r0, [r7, #4]
 810d056:	4798      	blx	r3
      }
    }
#endif /* USE_USBD_COMPOSITE */
  }

  return USBD_OK;
 810d058:	2300      	movs	r3, #0
}
 810d05a:	4618      	mov	r0, r3
 810d05c:	3708      	adds	r7, #8
 810d05e:	46bd      	mov	sp, r7
 810d060:	bd80      	pop	{r7, pc}

0810d062 <USBD_LL_IsoINIncomplete>:
  * @param  epnum: Endpoint number
  * @retval status
  */
USBD_StatusTypeDef USBD_LL_IsoINIncomplete(USBD_HandleTypeDef *pdev,
                                           uint8_t epnum)
{
 810d062:	b580      	push	{r7, lr}
 810d064:	b082      	sub	sp, #8
 810d066:	af00      	add	r7, sp, #0
 810d068:	6078      	str	r0, [r7, #4]
 810d06a:	460b      	mov	r3, r1
 810d06c:	70fb      	strb	r3, [r7, #3]
  if (pdev->pClass[pdev->classId] == NULL)
 810d06e:	687b      	ldr	r3, [r7, #4]
 810d070:	f8d3 22d4 	ldr.w	r2, [r3, #724]	; 0x2d4
 810d074:	687b      	ldr	r3, [r7, #4]
 810d076:	32ae      	adds	r2, #174	; 0xae
 810d078:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 810d07c:	2b00      	cmp	r3, #0
 810d07e:	d101      	bne.n	810d084 <USBD_LL_IsoINIncomplete+0x22>
  {
    return USBD_FAIL;
 810d080:	2303      	movs	r3, #3
 810d082:	e01c      	b.n	810d0be <USBD_LL_IsoINIncomplete+0x5c>
  }

  if (pdev->dev_state == USBD_STATE_CONFIGURED)
 810d084:	687b      	ldr	r3, [r7, #4]
 810d086:	f893 329c 	ldrb.w	r3, [r3, #668]	; 0x29c
 810d08a:	b2db      	uxtb	r3, r3
 810d08c:	2b03      	cmp	r3, #3
 810d08e:	d115      	bne.n	810d0bc <USBD_LL_IsoINIncomplete+0x5a>
  {
    if (pdev->pClass[pdev->classId]->IsoINIncomplete != NULL)
 810d090:	687b      	ldr	r3, [r7, #4]
 810d092:	f8d3 22d4 	ldr.w	r2, [r3, #724]	; 0x2d4
 810d096:	687b      	ldr	r3, [r7, #4]
 810d098:	32ae      	adds	r2, #174	; 0xae
 810d09a:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 810d09e:	6a1b      	ldr	r3, [r3, #32]
 810d0a0:	2b00      	cmp	r3, #0
 810d0a2:	d00b      	beq.n	810d0bc <USBD_LL_IsoINIncomplete+0x5a>
    {
      (void)pdev->pClass[pdev->classId]->IsoINIncomplete(pdev, epnum);
 810d0a4:	687b      	ldr	r3, [r7, #4]
 810d0a6:	f8d3 22d4 	ldr.w	r2, [r3, #724]	; 0x2d4
 810d0aa:	687b      	ldr	r3, [r7, #4]
 810d0ac:	32ae      	adds	r2, #174	; 0xae
 810d0ae:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 810d0b2:	6a1b      	ldr	r3, [r3, #32]
 810d0b4:	78fa      	ldrb	r2, [r7, #3]
 810d0b6:	4611      	mov	r1, r2
 810d0b8:	6878      	ldr	r0, [r7, #4]
 810d0ba:	4798      	blx	r3
    }
  }

  return USBD_OK;
 810d0bc:	2300      	movs	r3, #0
}
 810d0be:	4618      	mov	r0, r3
 810d0c0:	3708      	adds	r7, #8
 810d0c2:	46bd      	mov	sp, r7
 810d0c4:	bd80      	pop	{r7, pc}

0810d0c6 <USBD_LL_IsoOUTIncomplete>:
  * @param  epnum: Endpoint number
  * @retval status
  */
USBD_StatusTypeDef USBD_LL_IsoOUTIncomplete(USBD_HandleTypeDef *pdev,
                                            uint8_t epnum)
{
 810d0c6:	b580      	push	{r7, lr}
 810d0c8:	b082      	sub	sp, #8
 810d0ca:	af00      	add	r7, sp, #0
 810d0cc:	6078      	str	r0, [r7, #4]
 810d0ce:	460b      	mov	r3, r1
 810d0d0:	70fb      	strb	r3, [r7, #3]
  if (pdev->pClass[pdev->classId] == NULL)
 810d0d2:	687b      	ldr	r3, [r7, #4]
 810d0d4:	f8d3 22d4 	ldr.w	r2, [r3, #724]	; 0x2d4
 810d0d8:	687b      	ldr	r3, [r7, #4]
 810d0da:	32ae      	adds	r2, #174	; 0xae
 810d0dc:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 810d0e0:	2b00      	cmp	r3, #0
 810d0e2:	d101      	bne.n	810d0e8 <USBD_LL_IsoOUTIncomplete+0x22>
  {
    return USBD_FAIL;
 810d0e4:	2303      	movs	r3, #3
 810d0e6:	e01c      	b.n	810d122 <USBD_LL_IsoOUTIncomplete+0x5c>
  }

  if (pdev->dev_state == USBD_STATE_CONFIGURED)
 810d0e8:	687b      	ldr	r3, [r7, #4]
 810d0ea:	f893 329c 	ldrb.w	r3, [r3, #668]	; 0x29c
 810d0ee:	b2db      	uxtb	r3, r3
 810d0f0:	2b03      	cmp	r3, #3
 810d0f2:	d115      	bne.n	810d120 <USBD_LL_IsoOUTIncomplete+0x5a>
  {
    if (pdev->pClass[pdev->classId]->IsoOUTIncomplete != NULL)
 810d0f4:	687b      	ldr	r3, [r7, #4]
 810d0f6:	f8d3 22d4 	ldr.w	r2, [r3, #724]	; 0x2d4
 810d0fa:	687b      	ldr	r3, [r7, #4]
 810d0fc:	32ae      	adds	r2, #174	; 0xae
 810d0fe:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 810d102:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 810d104:	2b00      	cmp	r3, #0
 810d106:	d00b      	beq.n	810d120 <USBD_LL_IsoOUTIncomplete+0x5a>
    {
      (void)pdev->pClass[pdev->classId]->IsoOUTIncomplete(pdev, epnum);
 810d108:	687b      	ldr	r3, [r7, #4]
 810d10a:	f8d3 22d4 	ldr.w	r2, [r3, #724]	; 0x2d4
 810d10e:	687b      	ldr	r3, [r7, #4]
 810d110:	32ae      	adds	r2, #174	; 0xae
 810d112:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 810d116:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 810d118:	78fa      	ldrb	r2, [r7, #3]
 810d11a:	4611      	mov	r1, r2
 810d11c:	6878      	ldr	r0, [r7, #4]
 810d11e:	4798      	blx	r3
    }
  }

  return USBD_OK;
 810d120:	2300      	movs	r3, #0
}
 810d122:	4618      	mov	r0, r3
 810d124:	3708      	adds	r7, #8
 810d126:	46bd      	mov	sp, r7
 810d128:	bd80      	pop	{r7, pc}

0810d12a <USBD_LL_DevConnected>:
  *         Handle device connection event
  * @param  pdev: device instance
  * @retval status
  */
USBD_StatusTypeDef USBD_LL_DevConnected(USBD_HandleTypeDef *pdev)
{
 810d12a:	b480      	push	{r7}
 810d12c:	b083      	sub	sp, #12
 810d12e:	af00      	add	r7, sp, #0
 810d130:	6078      	str	r0, [r7, #4]
  /* Prevent unused argument compilation warning */
  UNUSED(pdev);

  return USBD_OK;
 810d132:	2300      	movs	r3, #0
}
 810d134:	4618      	mov	r0, r3
 810d136:	370c      	adds	r7, #12
 810d138:	46bd      	mov	sp, r7
 810d13a:	f85d 7b04 	ldr.w	r7, [sp], #4
 810d13e:	4770      	bx	lr

0810d140 <USBD_LL_DevDisconnected>:
  *         Handle device disconnection event
  * @param  pdev: device instance
  * @retval status
  */
USBD_StatusTypeDef USBD_LL_DevDisconnected(USBD_HandleTypeDef *pdev)
{
 810d140:	b580      	push	{r7, lr}
 810d142:	b084      	sub	sp, #16
 810d144:	af00      	add	r7, sp, #0
 810d146:	6078      	str	r0, [r7, #4]
  USBD_StatusTypeDef   ret = USBD_OK;
 810d148:	2300      	movs	r3, #0
 810d14a:	73fb      	strb	r3, [r7, #15]

  /* Free Class Resources */
  pdev->dev_state = USBD_STATE_DEFAULT;
 810d14c:	687b      	ldr	r3, [r7, #4]
 810d14e:	2201      	movs	r2, #1
 810d150:	f883 229c 	strb.w	r2, [r3, #668]	; 0x29c
        }
      }
    }
  }
#else
  if (pdev->pClass[0] != NULL)
 810d154:	687b      	ldr	r3, [r7, #4]
 810d156:	f8d3 32b8 	ldr.w	r3, [r3, #696]	; 0x2b8
 810d15a:	2b00      	cmp	r3, #0
 810d15c:	d00e      	beq.n	810d17c <USBD_LL_DevDisconnected+0x3c>
  {
    if (pdev->pClass[0]->DeInit(pdev, (uint8_t)pdev->dev_config) != 0U)
 810d15e:	687b      	ldr	r3, [r7, #4]
 810d160:	f8d3 32b8 	ldr.w	r3, [r3, #696]	; 0x2b8
 810d164:	685b      	ldr	r3, [r3, #4]
 810d166:	687a      	ldr	r2, [r7, #4]
 810d168:	6852      	ldr	r2, [r2, #4]
 810d16a:	b2d2      	uxtb	r2, r2
 810d16c:	4611      	mov	r1, r2
 810d16e:	6878      	ldr	r0, [r7, #4]
 810d170:	4798      	blx	r3
 810d172:	4603      	mov	r3, r0
 810d174:	2b00      	cmp	r3, #0
 810d176:	d001      	beq.n	810d17c <USBD_LL_DevDisconnected+0x3c>
    {
      ret = USBD_FAIL;
 810d178:	2303      	movs	r3, #3
 810d17a:	73fb      	strb	r3, [r7, #15]
    }
  }
#endif /* USE_USBD_COMPOSITE */

  return ret;
 810d17c:	7bfb      	ldrb	r3, [r7, #15]
}
 810d17e:	4618      	mov	r0, r3
 810d180:	3710      	adds	r7, #16
 810d182:	46bd      	mov	sp, r7
 810d184:	bd80      	pop	{r7, pc}

0810d186 <USBD_CoreFindIF>:
  * @param  pdev: device instance
  * @param  index : selected interface number
  * @retval index of the class using the selected interface number. OxFF if no class found.
  */
uint8_t USBD_CoreFindIF(USBD_HandleTypeDef *pdev, uint8_t index)
{
 810d186:	b480      	push	{r7}
 810d188:	b083      	sub	sp, #12
 810d18a:	af00      	add	r7, sp, #0
 810d18c:	6078      	str	r0, [r7, #4]
 810d18e:	460b      	mov	r3, r1
 810d190:	70fb      	strb	r3, [r7, #3]
  return 0xFFU;
#else
  UNUSED(pdev);
  UNUSED(index);

  return 0x00U;
 810d192:	2300      	movs	r3, #0
#endif /* USE_USBD_COMPOSITE */
}
 810d194:	4618      	mov	r0, r3
 810d196:	370c      	adds	r7, #12
 810d198:	46bd      	mov	sp, r7
 810d19a:	f85d 7b04 	ldr.w	r7, [sp], #4
 810d19e:	4770      	bx	lr

0810d1a0 <USBD_CoreFindEP>:
  * @param  pdev: device instance
  * @param  index : selected endpoint number
  * @retval index of the class using the selected endpoint number. 0xFF if no class found.
  */
uint8_t USBD_CoreFindEP(USBD_HandleTypeDef *pdev, uint8_t index)
{
 810d1a0:	b480      	push	{r7}
 810d1a2:	b083      	sub	sp, #12
 810d1a4:	af00      	add	r7, sp, #0
 810d1a6:	6078      	str	r0, [r7, #4]
 810d1a8:	460b      	mov	r3, r1
 810d1aa:	70fb      	strb	r3, [r7, #3]
  return 0xFFU;
#else
  UNUSED(pdev);
  UNUSED(index);

  return 0x00U;
 810d1ac:	2300      	movs	r3, #0
#endif /* USE_USBD_COMPOSITE */
}
 810d1ae:	4618      	mov	r0, r3
 810d1b0:	370c      	adds	r7, #12
 810d1b2:	46bd      	mov	sp, r7
 810d1b4:	f85d 7b04 	ldr.w	r7, [sp], #4
 810d1b8:	4770      	bx	lr

0810d1ba <USBD_GetEpDesc>:
  * @param  pConfDesc:  pointer to Bos descriptor
  * @param  EpAddr:  endpoint address
  * @retval pointer to video endpoint descriptor
  */
void *USBD_GetEpDesc(uint8_t *pConfDesc, uint8_t EpAddr)
{
 810d1ba:	b580      	push	{r7, lr}
 810d1bc:	b086      	sub	sp, #24
 810d1be:	af00      	add	r7, sp, #0
 810d1c0:	6078      	str	r0, [r7, #4]
 810d1c2:	460b      	mov	r3, r1
 810d1c4:	70fb      	strb	r3, [r7, #3]
  USBD_DescHeaderTypeDef *pdesc = (USBD_DescHeaderTypeDef *)(void *)pConfDesc;
 810d1c6:	687b      	ldr	r3, [r7, #4]
 810d1c8:	617b      	str	r3, [r7, #20]
  USBD_ConfigDescTypeDef *desc = (USBD_ConfigDescTypeDef *)(void *)pConfDesc;
 810d1ca:	687b      	ldr	r3, [r7, #4]
 810d1cc:	60fb      	str	r3, [r7, #12]
  USBD_EpDescTypeDef *pEpDesc = NULL;
 810d1ce:	2300      	movs	r3, #0
 810d1d0:	613b      	str	r3, [r7, #16]
  uint16_t ptr;

  if (desc->wTotalLength > desc->bLength)
 810d1d2:	68fb      	ldr	r3, [r7, #12]
 810d1d4:	885b      	ldrh	r3, [r3, #2]
 810d1d6:	b29a      	uxth	r2, r3
 810d1d8:	68fb      	ldr	r3, [r7, #12]
 810d1da:	781b      	ldrb	r3, [r3, #0]
 810d1dc:	b29b      	uxth	r3, r3
 810d1de:	429a      	cmp	r2, r3
 810d1e0:	d920      	bls.n	810d224 <USBD_GetEpDesc+0x6a>
  {
    ptr = desc->bLength;
 810d1e2:	68fb      	ldr	r3, [r7, #12]
 810d1e4:	781b      	ldrb	r3, [r3, #0]
 810d1e6:	b29b      	uxth	r3, r3
 810d1e8:	817b      	strh	r3, [r7, #10]

    while (ptr < desc->wTotalLength)
 810d1ea:	e013      	b.n	810d214 <USBD_GetEpDesc+0x5a>
    {
      pdesc = USBD_GetNextDesc((uint8_t *)pdesc, &ptr);
 810d1ec:	f107 030a 	add.w	r3, r7, #10
 810d1f0:	4619      	mov	r1, r3
 810d1f2:	6978      	ldr	r0, [r7, #20]
 810d1f4:	f000 f81b 	bl	810d22e <USBD_GetNextDesc>
 810d1f8:	6178      	str	r0, [r7, #20]

      if (pdesc->bDescriptorType == USB_DESC_TYPE_ENDPOINT)
 810d1fa:	697b      	ldr	r3, [r7, #20]
 810d1fc:	785b      	ldrb	r3, [r3, #1]
 810d1fe:	2b05      	cmp	r3, #5
 810d200:	d108      	bne.n	810d214 <USBD_GetEpDesc+0x5a>
      {
        pEpDesc = (USBD_EpDescTypeDef *)(void *)pdesc;
 810d202:	697b      	ldr	r3, [r7, #20]
 810d204:	613b      	str	r3, [r7, #16]

        if (pEpDesc->bEndpointAddress == EpAddr)
 810d206:	693b      	ldr	r3, [r7, #16]
 810d208:	789b      	ldrb	r3, [r3, #2]
 810d20a:	78fa      	ldrb	r2, [r7, #3]
 810d20c:	429a      	cmp	r2, r3
 810d20e:	d008      	beq.n	810d222 <USBD_GetEpDesc+0x68>
        {
          break;
        }
        else
        {
          pEpDesc = NULL;
 810d210:	2300      	movs	r3, #0
 810d212:	613b      	str	r3, [r7, #16]
    while (ptr < desc->wTotalLength)
 810d214:	68fb      	ldr	r3, [r7, #12]
 810d216:	885b      	ldrh	r3, [r3, #2]
 810d218:	b29a      	uxth	r2, r3
 810d21a:	897b      	ldrh	r3, [r7, #10]
 810d21c:	429a      	cmp	r2, r3
 810d21e:	d8e5      	bhi.n	810d1ec <USBD_GetEpDesc+0x32>
 810d220:	e000      	b.n	810d224 <USBD_GetEpDesc+0x6a>
          break;
 810d222:	bf00      	nop
        }
      }
    }
  }

  return (void *)pEpDesc;
 810d224:	693b      	ldr	r3, [r7, #16]
}
 810d226:	4618      	mov	r0, r3
 810d228:	3718      	adds	r7, #24
 810d22a:	46bd      	mov	sp, r7
 810d22c:	bd80      	pop	{r7, pc}

0810d22e <USBD_GetNextDesc>:
  * @param  buf: Buffer where the descriptor is available
  * @param  ptr: data pointer inside the descriptor
  * @retval next header
  */
USBD_DescHeaderTypeDef *USBD_GetNextDesc(uint8_t *pbuf, uint16_t *ptr)
{
 810d22e:	b480      	push	{r7}
 810d230:	b085      	sub	sp, #20
 810d232:	af00      	add	r7, sp, #0
 810d234:	6078      	str	r0, [r7, #4]
 810d236:	6039      	str	r1, [r7, #0]
  USBD_DescHeaderTypeDef *pnext = (USBD_DescHeaderTypeDef *)(void *)pbuf;
 810d238:	687b      	ldr	r3, [r7, #4]
 810d23a:	60fb      	str	r3, [r7, #12]

  *ptr += pnext->bLength;
 810d23c:	683b      	ldr	r3, [r7, #0]
 810d23e:	881a      	ldrh	r2, [r3, #0]
 810d240:	68fb      	ldr	r3, [r7, #12]
 810d242:	781b      	ldrb	r3, [r3, #0]
 810d244:	b29b      	uxth	r3, r3
 810d246:	4413      	add	r3, r2
 810d248:	b29a      	uxth	r2, r3
 810d24a:	683b      	ldr	r3, [r7, #0]
 810d24c:	801a      	strh	r2, [r3, #0]
  pnext = (USBD_DescHeaderTypeDef *)(void *)(pbuf + pnext->bLength);
 810d24e:	68fb      	ldr	r3, [r7, #12]
 810d250:	781b      	ldrb	r3, [r3, #0]
 810d252:	461a      	mov	r2, r3
 810d254:	687b      	ldr	r3, [r7, #4]
 810d256:	4413      	add	r3, r2
 810d258:	60fb      	str	r3, [r7, #12]

  return (pnext);
 810d25a:	68fb      	ldr	r3, [r7, #12]
}
 810d25c:	4618      	mov	r0, r3
 810d25e:	3714      	adds	r7, #20
 810d260:	46bd      	mov	sp, r7
 810d262:	f85d 7b04 	ldr.w	r7, [sp], #4
 810d266:	4770      	bx	lr

0810d268 <SWAPBYTE>:

/** @defgroup USBD_DEF_Exported_Macros
  * @{
  */
__STATIC_INLINE uint16_t SWAPBYTE(uint8_t *addr)
{
 810d268:	b480      	push	{r7}
 810d26a:	b087      	sub	sp, #28
 810d26c:	af00      	add	r7, sp, #0
 810d26e:	6078      	str	r0, [r7, #4]
  uint16_t _SwapVal;
  uint16_t _Byte1;
  uint16_t _Byte2;
  uint8_t *_pbuff = addr;
 810d270:	687b      	ldr	r3, [r7, #4]
 810d272:	617b      	str	r3, [r7, #20]

  _Byte1 = *(uint8_t *)_pbuff;
 810d274:	697b      	ldr	r3, [r7, #20]
 810d276:	781b      	ldrb	r3, [r3, #0]
 810d278:	827b      	strh	r3, [r7, #18]
  _pbuff++;
 810d27a:	697b      	ldr	r3, [r7, #20]
 810d27c:	3301      	adds	r3, #1
 810d27e:	617b      	str	r3, [r7, #20]
  _Byte2 = *(uint8_t *)_pbuff;
 810d280:	697b      	ldr	r3, [r7, #20]
 810d282:	781b      	ldrb	r3, [r3, #0]
 810d284:	823b      	strh	r3, [r7, #16]

  _SwapVal = (_Byte2 << 8) | _Byte1;
 810d286:	8a3b      	ldrh	r3, [r7, #16]
 810d288:	021b      	lsls	r3, r3, #8
 810d28a:	b21a      	sxth	r2, r3
 810d28c:	f9b7 3012 	ldrsh.w	r3, [r7, #18]
 810d290:	4313      	orrs	r3, r2
 810d292:	b21b      	sxth	r3, r3
 810d294:	81fb      	strh	r3, [r7, #14]

  return _SwapVal;
 810d296:	89fb      	ldrh	r3, [r7, #14]
}
 810d298:	4618      	mov	r0, r3
 810d29a:	371c      	adds	r7, #28
 810d29c:	46bd      	mov	sp, r7
 810d29e:	f85d 7b04 	ldr.w	r7, [sp], #4
 810d2a2:	4770      	bx	lr

0810d2a4 <USBD_StdDevReq>:
  * @param  pdev: device instance
  * @param  req: usb request
  * @retval status
  */
USBD_StatusTypeDef USBD_StdDevReq(USBD_HandleTypeDef *pdev, USBD_SetupReqTypedef *req)
{
 810d2a4:	b580      	push	{r7, lr}
 810d2a6:	b084      	sub	sp, #16
 810d2a8:	af00      	add	r7, sp, #0
 810d2aa:	6078      	str	r0, [r7, #4]
 810d2ac:	6039      	str	r1, [r7, #0]
  USBD_StatusTypeDef ret = USBD_OK;
 810d2ae:	2300      	movs	r3, #0
 810d2b0:	73fb      	strb	r3, [r7, #15]

  switch (req->bmRequest & USB_REQ_TYPE_MASK)
 810d2b2:	683b      	ldr	r3, [r7, #0]
 810d2b4:	781b      	ldrb	r3, [r3, #0]
 810d2b6:	f003 0360 	and.w	r3, r3, #96	; 0x60
 810d2ba:	2b40      	cmp	r3, #64	; 0x40
 810d2bc:	d005      	beq.n	810d2ca <USBD_StdDevReq+0x26>
 810d2be:	2b40      	cmp	r3, #64	; 0x40
 810d2c0:	d857      	bhi.n	810d372 <USBD_StdDevReq+0xce>
 810d2c2:	2b00      	cmp	r3, #0
 810d2c4:	d00f      	beq.n	810d2e6 <USBD_StdDevReq+0x42>
 810d2c6:	2b20      	cmp	r3, #32
 810d2c8:	d153      	bne.n	810d372 <USBD_StdDevReq+0xce>
  {
    case USB_REQ_TYPE_CLASS:
    case USB_REQ_TYPE_VENDOR:
      ret = (USBD_StatusTypeDef)pdev->pClass[pdev->classId]->Setup(pdev, req);
 810d2ca:	687b      	ldr	r3, [r7, #4]
 810d2cc:	f8d3 22d4 	ldr.w	r2, [r3, #724]	; 0x2d4
 810d2d0:	687b      	ldr	r3, [r7, #4]
 810d2d2:	32ae      	adds	r2, #174	; 0xae
 810d2d4:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 810d2d8:	689b      	ldr	r3, [r3, #8]
 810d2da:	6839      	ldr	r1, [r7, #0]
 810d2dc:	6878      	ldr	r0, [r7, #4]
 810d2de:	4798      	blx	r3
 810d2e0:	4603      	mov	r3, r0
 810d2e2:	73fb      	strb	r3, [r7, #15]
      break;
 810d2e4:	e04a      	b.n	810d37c <USBD_StdDevReq+0xd8>

    case USB_REQ_TYPE_STANDARD:
      switch (req->bRequest)
 810d2e6:	683b      	ldr	r3, [r7, #0]
 810d2e8:	785b      	ldrb	r3, [r3, #1]
 810d2ea:	2b09      	cmp	r3, #9
 810d2ec:	d83b      	bhi.n	810d366 <USBD_StdDevReq+0xc2>
 810d2ee:	a201      	add	r2, pc, #4	; (adr r2, 810d2f4 <USBD_StdDevReq+0x50>)
 810d2f0:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 810d2f4:	0810d349 	.word	0x0810d349
 810d2f8:	0810d35d 	.word	0x0810d35d
 810d2fc:	0810d367 	.word	0x0810d367
 810d300:	0810d353 	.word	0x0810d353
 810d304:	0810d367 	.word	0x0810d367
 810d308:	0810d327 	.word	0x0810d327
 810d30c:	0810d31d 	.word	0x0810d31d
 810d310:	0810d367 	.word	0x0810d367
 810d314:	0810d33f 	.word	0x0810d33f
 810d318:	0810d331 	.word	0x0810d331
      {
        case USB_REQ_GET_DESCRIPTOR:
          USBD_GetDescriptor(pdev, req);
 810d31c:	6839      	ldr	r1, [r7, #0]
 810d31e:	6878      	ldr	r0, [r7, #4]
 810d320:	f000 fa3c 	bl	810d79c <USBD_GetDescriptor>
          break;
 810d324:	e024      	b.n	810d370 <USBD_StdDevReq+0xcc>

        case USB_REQ_SET_ADDRESS:
          USBD_SetAddress(pdev, req);
 810d326:	6839      	ldr	r1, [r7, #0]
 810d328:	6878      	ldr	r0, [r7, #4]
 810d32a:	f000 fbcb 	bl	810dac4 <USBD_SetAddress>
          break;
 810d32e:	e01f      	b.n	810d370 <USBD_StdDevReq+0xcc>

        case USB_REQ_SET_CONFIGURATION:
          ret = USBD_SetConfig(pdev, req);
 810d330:	6839      	ldr	r1, [r7, #0]
 810d332:	6878      	ldr	r0, [r7, #4]
 810d334:	f000 fc0a 	bl	810db4c <USBD_SetConfig>
 810d338:	4603      	mov	r3, r0
 810d33a:	73fb      	strb	r3, [r7, #15]
          break;
 810d33c:	e018      	b.n	810d370 <USBD_StdDevReq+0xcc>

        case USB_REQ_GET_CONFIGURATION:
          USBD_GetConfig(pdev, req);
 810d33e:	6839      	ldr	r1, [r7, #0]
 810d340:	6878      	ldr	r0, [r7, #4]
 810d342:	f000 fcad 	bl	810dca0 <USBD_GetConfig>
          break;
 810d346:	e013      	b.n	810d370 <USBD_StdDevReq+0xcc>

        case USB_REQ_GET_STATUS:
          USBD_GetStatus(pdev, req);
 810d348:	6839      	ldr	r1, [r7, #0]
 810d34a:	6878      	ldr	r0, [r7, #4]
 810d34c:	f000 fcde 	bl	810dd0c <USBD_GetStatus>
          break;
 810d350:	e00e      	b.n	810d370 <USBD_StdDevReq+0xcc>

        case USB_REQ_SET_FEATURE:
          USBD_SetFeature(pdev, req);
 810d352:	6839      	ldr	r1, [r7, #0]
 810d354:	6878      	ldr	r0, [r7, #4]
 810d356:	f000 fd0d 	bl	810dd74 <USBD_SetFeature>
          break;
 810d35a:	e009      	b.n	810d370 <USBD_StdDevReq+0xcc>

        case USB_REQ_CLEAR_FEATURE:
          USBD_ClrFeature(pdev, req);
 810d35c:	6839      	ldr	r1, [r7, #0]
 810d35e:	6878      	ldr	r0, [r7, #4]
 810d360:	f000 fd31 	bl	810ddc6 <USBD_ClrFeature>
          break;
 810d364:	e004      	b.n	810d370 <USBD_StdDevReq+0xcc>

        default:
          USBD_CtlError(pdev, req);
 810d366:	6839      	ldr	r1, [r7, #0]
 810d368:	6878      	ldr	r0, [r7, #4]
 810d36a:	f000 fd88 	bl	810de7e <USBD_CtlError>
          break;
 810d36e:	bf00      	nop
      }
      break;
 810d370:	e004      	b.n	810d37c <USBD_StdDevReq+0xd8>

    default:
      USBD_CtlError(pdev, req);
 810d372:	6839      	ldr	r1, [r7, #0]
 810d374:	6878      	ldr	r0, [r7, #4]
 810d376:	f000 fd82 	bl	810de7e <USBD_CtlError>
      break;
 810d37a:	bf00      	nop
  }

  return ret;
 810d37c:	7bfb      	ldrb	r3, [r7, #15]
}
 810d37e:	4618      	mov	r0, r3
 810d380:	3710      	adds	r7, #16
 810d382:	46bd      	mov	sp, r7
 810d384:	bd80      	pop	{r7, pc}
 810d386:	bf00      	nop

0810d388 <USBD_StdItfReq>:
  * @param  pdev: device instance
  * @param  req: usb request
  * @retval status
  */
USBD_StatusTypeDef USBD_StdItfReq(USBD_HandleTypeDef *pdev, USBD_SetupReqTypedef *req)
{
 810d388:	b580      	push	{r7, lr}
 810d38a:	b084      	sub	sp, #16
 810d38c:	af00      	add	r7, sp, #0
 810d38e:	6078      	str	r0, [r7, #4]
 810d390:	6039      	str	r1, [r7, #0]
  USBD_StatusTypeDef ret = USBD_OK;
 810d392:	2300      	movs	r3, #0
 810d394:	73fb      	strb	r3, [r7, #15]
  uint8_t idx;

  switch (req->bmRequest & USB_REQ_TYPE_MASK)
 810d396:	683b      	ldr	r3, [r7, #0]
 810d398:	781b      	ldrb	r3, [r3, #0]
 810d39a:	f003 0360 	and.w	r3, r3, #96	; 0x60
 810d39e:	2b40      	cmp	r3, #64	; 0x40
 810d3a0:	d005      	beq.n	810d3ae <USBD_StdItfReq+0x26>
 810d3a2:	2b40      	cmp	r3, #64	; 0x40
 810d3a4:	d852      	bhi.n	810d44c <USBD_StdItfReq+0xc4>
 810d3a6:	2b00      	cmp	r3, #0
 810d3a8:	d001      	beq.n	810d3ae <USBD_StdItfReq+0x26>
 810d3aa:	2b20      	cmp	r3, #32
 810d3ac:	d14e      	bne.n	810d44c <USBD_StdItfReq+0xc4>
  {
    case USB_REQ_TYPE_CLASS:
    case USB_REQ_TYPE_VENDOR:
    case USB_REQ_TYPE_STANDARD:
      switch (pdev->dev_state)
 810d3ae:	687b      	ldr	r3, [r7, #4]
 810d3b0:	f893 329c 	ldrb.w	r3, [r3, #668]	; 0x29c
 810d3b4:	b2db      	uxtb	r3, r3
 810d3b6:	3b01      	subs	r3, #1
 810d3b8:	2b02      	cmp	r3, #2
 810d3ba:	d840      	bhi.n	810d43e <USBD_StdItfReq+0xb6>
      {
        case USBD_STATE_DEFAULT:
        case USBD_STATE_ADDRESSED:
        case USBD_STATE_CONFIGURED:

          if (LOBYTE(req->wIndex) <= USBD_MAX_NUM_INTERFACES)
 810d3bc:	683b      	ldr	r3, [r7, #0]
 810d3be:	889b      	ldrh	r3, [r3, #4]
 810d3c0:	b2db      	uxtb	r3, r3
 810d3c2:	2b01      	cmp	r3, #1
 810d3c4:	d836      	bhi.n	810d434 <USBD_StdItfReq+0xac>
          {
            /* Get the class index relative to this interface */
            idx = USBD_CoreFindIF(pdev, LOBYTE(req->wIndex));
 810d3c6:	683b      	ldr	r3, [r7, #0]
 810d3c8:	889b      	ldrh	r3, [r3, #4]
 810d3ca:	b2db      	uxtb	r3, r3
 810d3cc:	4619      	mov	r1, r3
 810d3ce:	6878      	ldr	r0, [r7, #4]
 810d3d0:	f7ff fed9 	bl	810d186 <USBD_CoreFindIF>
 810d3d4:	4603      	mov	r3, r0
 810d3d6:	73bb      	strb	r3, [r7, #14]
            if (((uint8_t)idx != 0xFFU) && (idx < USBD_MAX_SUPPORTED_CLASS))
 810d3d8:	7bbb      	ldrb	r3, [r7, #14]
 810d3da:	2bff      	cmp	r3, #255	; 0xff
 810d3dc:	d01d      	beq.n	810d41a <USBD_StdItfReq+0x92>
 810d3de:	7bbb      	ldrb	r3, [r7, #14]
 810d3e0:	2b00      	cmp	r3, #0
 810d3e2:	d11a      	bne.n	810d41a <USBD_StdItfReq+0x92>
            {
              /* Call the class data out function to manage the request */
              if (pdev->pClass[idx]->Setup != NULL)
 810d3e4:	7bba      	ldrb	r2, [r7, #14]
 810d3e6:	687b      	ldr	r3, [r7, #4]
 810d3e8:	32ae      	adds	r2, #174	; 0xae
 810d3ea:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 810d3ee:	689b      	ldr	r3, [r3, #8]
 810d3f0:	2b00      	cmp	r3, #0
 810d3f2:	d00f      	beq.n	810d414 <USBD_StdItfReq+0x8c>
              {
                pdev->classId = idx;
 810d3f4:	7bba      	ldrb	r2, [r7, #14]
 810d3f6:	687b      	ldr	r3, [r7, #4]
 810d3f8:	f8c3 22d4 	str.w	r2, [r3, #724]	; 0x2d4
                ret = (USBD_StatusTypeDef)(pdev->pClass[idx]->Setup(pdev, req));
 810d3fc:	7bba      	ldrb	r2, [r7, #14]
 810d3fe:	687b      	ldr	r3, [r7, #4]
 810d400:	32ae      	adds	r2, #174	; 0xae
 810d402:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 810d406:	689b      	ldr	r3, [r3, #8]
 810d408:	6839      	ldr	r1, [r7, #0]
 810d40a:	6878      	ldr	r0, [r7, #4]
 810d40c:	4798      	blx	r3
 810d40e:	4603      	mov	r3, r0
 810d410:	73fb      	strb	r3, [r7, #15]
              if (pdev->pClass[idx]->Setup != NULL)
 810d412:	e004      	b.n	810d41e <USBD_StdItfReq+0x96>
              }
              else
              {
                /* should never reach this condition */
                ret = USBD_FAIL;
 810d414:	2303      	movs	r3, #3
 810d416:	73fb      	strb	r3, [r7, #15]
              if (pdev->pClass[idx]->Setup != NULL)
 810d418:	e001      	b.n	810d41e <USBD_StdItfReq+0x96>
              }
            }
            else
            {
              /* No relative interface found */
              ret = USBD_FAIL;
 810d41a:	2303      	movs	r3, #3
 810d41c:	73fb      	strb	r3, [r7, #15]
            }

            if ((req->wLength == 0U) && (ret == USBD_OK))
 810d41e:	683b      	ldr	r3, [r7, #0]
 810d420:	88db      	ldrh	r3, [r3, #6]
 810d422:	2b00      	cmp	r3, #0
 810d424:	d110      	bne.n	810d448 <USBD_StdItfReq+0xc0>
 810d426:	7bfb      	ldrb	r3, [r7, #15]
 810d428:	2b00      	cmp	r3, #0
 810d42a:	d10d      	bne.n	810d448 <USBD_StdItfReq+0xc0>
            {
              (void)USBD_CtlSendStatus(pdev);
 810d42c:	6878      	ldr	r0, [r7, #4]
 810d42e:	f001 f80a 	bl	810e446 <USBD_CtlSendStatus>
          }
          else
          {
            USBD_CtlError(pdev, req);
          }
          break;
 810d432:	e009      	b.n	810d448 <USBD_StdItfReq+0xc0>
            USBD_CtlError(pdev, req);
 810d434:	6839      	ldr	r1, [r7, #0]
 810d436:	6878      	ldr	r0, [r7, #4]
 810d438:	f000 fd21 	bl	810de7e <USBD_CtlError>
          break;
 810d43c:	e004      	b.n	810d448 <USBD_StdItfReq+0xc0>

        default:
          USBD_CtlError(pdev, req);
 810d43e:	6839      	ldr	r1, [r7, #0]
 810d440:	6878      	ldr	r0, [r7, #4]
 810d442:	f000 fd1c 	bl	810de7e <USBD_CtlError>
          break;
 810d446:	e000      	b.n	810d44a <USBD_StdItfReq+0xc2>
          break;
 810d448:	bf00      	nop
      }
      break;
 810d44a:	e004      	b.n	810d456 <USBD_StdItfReq+0xce>

    default:
      USBD_CtlError(pdev, req);
 810d44c:	6839      	ldr	r1, [r7, #0]
 810d44e:	6878      	ldr	r0, [r7, #4]
 810d450:	f000 fd15 	bl	810de7e <USBD_CtlError>
      break;
 810d454:	bf00      	nop
  }

  return ret;
 810d456:	7bfb      	ldrb	r3, [r7, #15]
}
 810d458:	4618      	mov	r0, r3
 810d45a:	3710      	adds	r7, #16
 810d45c:	46bd      	mov	sp, r7
 810d45e:	bd80      	pop	{r7, pc}

0810d460 <USBD_StdEPReq>:
  * @param  pdev: device instance
  * @param  req: usb request
  * @retval status
  */
USBD_StatusTypeDef USBD_StdEPReq(USBD_HandleTypeDef *pdev, USBD_SetupReqTypedef *req)
{
 810d460:	b580      	push	{r7, lr}
 810d462:	b084      	sub	sp, #16
 810d464:	af00      	add	r7, sp, #0
 810d466:	6078      	str	r0, [r7, #4]
 810d468:	6039      	str	r1, [r7, #0]
  USBD_EndpointTypeDef *pep;
  uint8_t ep_addr;
  uint8_t idx;
  USBD_StatusTypeDef ret = USBD_OK;
 810d46a:	2300      	movs	r3, #0
 810d46c:	73fb      	strb	r3, [r7, #15]

  ep_addr = LOBYTE(req->wIndex);
 810d46e:	683b      	ldr	r3, [r7, #0]
 810d470:	889b      	ldrh	r3, [r3, #4]
 810d472:	73bb      	strb	r3, [r7, #14]

  switch (req->bmRequest & USB_REQ_TYPE_MASK)
 810d474:	683b      	ldr	r3, [r7, #0]
 810d476:	781b      	ldrb	r3, [r3, #0]
 810d478:	f003 0360 	and.w	r3, r3, #96	; 0x60
 810d47c:	2b40      	cmp	r3, #64	; 0x40
 810d47e:	d007      	beq.n	810d490 <USBD_StdEPReq+0x30>
 810d480:	2b40      	cmp	r3, #64	; 0x40
 810d482:	f200 817f 	bhi.w	810d784 <USBD_StdEPReq+0x324>
 810d486:	2b00      	cmp	r3, #0
 810d488:	d02a      	beq.n	810d4e0 <USBD_StdEPReq+0x80>
 810d48a:	2b20      	cmp	r3, #32
 810d48c:	f040 817a 	bne.w	810d784 <USBD_StdEPReq+0x324>
  {
    case USB_REQ_TYPE_CLASS:
    case USB_REQ_TYPE_VENDOR:
      /* Get the class index relative to this endpoint */
      idx = USBD_CoreFindEP(pdev, ep_addr);
 810d490:	7bbb      	ldrb	r3, [r7, #14]
 810d492:	4619      	mov	r1, r3
 810d494:	6878      	ldr	r0, [r7, #4]
 810d496:	f7ff fe83 	bl	810d1a0 <USBD_CoreFindEP>
 810d49a:	4603      	mov	r3, r0
 810d49c:	737b      	strb	r3, [r7, #13]
      if (((uint8_t)idx != 0xFFU) && (idx < USBD_MAX_SUPPORTED_CLASS))
 810d49e:	7b7b      	ldrb	r3, [r7, #13]
 810d4a0:	2bff      	cmp	r3, #255	; 0xff
 810d4a2:	f000 8174 	beq.w	810d78e <USBD_StdEPReq+0x32e>
 810d4a6:	7b7b      	ldrb	r3, [r7, #13]
 810d4a8:	2b00      	cmp	r3, #0
 810d4aa:	f040 8170 	bne.w	810d78e <USBD_StdEPReq+0x32e>
      {
        pdev->classId = idx;
 810d4ae:	7b7a      	ldrb	r2, [r7, #13]
 810d4b0:	687b      	ldr	r3, [r7, #4]
 810d4b2:	f8c3 22d4 	str.w	r2, [r3, #724]	; 0x2d4
        /* Call the class data out function to manage the request */
        if (pdev->pClass[idx]->Setup != NULL)
 810d4b6:	7b7a      	ldrb	r2, [r7, #13]
 810d4b8:	687b      	ldr	r3, [r7, #4]
 810d4ba:	32ae      	adds	r2, #174	; 0xae
 810d4bc:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 810d4c0:	689b      	ldr	r3, [r3, #8]
 810d4c2:	2b00      	cmp	r3, #0
 810d4c4:	f000 8163 	beq.w	810d78e <USBD_StdEPReq+0x32e>
        {
          ret = (USBD_StatusTypeDef)pdev->pClass[idx]->Setup(pdev, req);
 810d4c8:	7b7a      	ldrb	r2, [r7, #13]
 810d4ca:	687b      	ldr	r3, [r7, #4]
 810d4cc:	32ae      	adds	r2, #174	; 0xae
 810d4ce:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 810d4d2:	689b      	ldr	r3, [r3, #8]
 810d4d4:	6839      	ldr	r1, [r7, #0]
 810d4d6:	6878      	ldr	r0, [r7, #4]
 810d4d8:	4798      	blx	r3
 810d4da:	4603      	mov	r3, r0
 810d4dc:	73fb      	strb	r3, [r7, #15]
        }
      }
      break;
 810d4de:	e156      	b.n	810d78e <USBD_StdEPReq+0x32e>

    case USB_REQ_TYPE_STANDARD:
      switch (req->bRequest)
 810d4e0:	683b      	ldr	r3, [r7, #0]
 810d4e2:	785b      	ldrb	r3, [r3, #1]
 810d4e4:	2b03      	cmp	r3, #3
 810d4e6:	d008      	beq.n	810d4fa <USBD_StdEPReq+0x9a>
 810d4e8:	2b03      	cmp	r3, #3
 810d4ea:	f300 8145 	bgt.w	810d778 <USBD_StdEPReq+0x318>
 810d4ee:	2b00      	cmp	r3, #0
 810d4f0:	f000 809b 	beq.w	810d62a <USBD_StdEPReq+0x1ca>
 810d4f4:	2b01      	cmp	r3, #1
 810d4f6:	d03c      	beq.n	810d572 <USBD_StdEPReq+0x112>
 810d4f8:	e13e      	b.n	810d778 <USBD_StdEPReq+0x318>
      {
        case USB_REQ_SET_FEATURE:
          switch (pdev->dev_state)
 810d4fa:	687b      	ldr	r3, [r7, #4]
 810d4fc:	f893 329c 	ldrb.w	r3, [r3, #668]	; 0x29c
 810d500:	b2db      	uxtb	r3, r3
 810d502:	2b02      	cmp	r3, #2
 810d504:	d002      	beq.n	810d50c <USBD_StdEPReq+0xac>
 810d506:	2b03      	cmp	r3, #3
 810d508:	d016      	beq.n	810d538 <USBD_StdEPReq+0xd8>
 810d50a:	e02c      	b.n	810d566 <USBD_StdEPReq+0x106>
          {
            case USBD_STATE_ADDRESSED:
              if ((ep_addr != 0x00U) && (ep_addr != 0x80U))
 810d50c:	7bbb      	ldrb	r3, [r7, #14]
 810d50e:	2b00      	cmp	r3, #0
 810d510:	d00d      	beq.n	810d52e <USBD_StdEPReq+0xce>
 810d512:	7bbb      	ldrb	r3, [r7, #14]
 810d514:	2b80      	cmp	r3, #128	; 0x80
 810d516:	d00a      	beq.n	810d52e <USBD_StdEPReq+0xce>
              {
                (void)USBD_LL_StallEP(pdev, ep_addr);
 810d518:	7bbb      	ldrb	r3, [r7, #14]
 810d51a:	4619      	mov	r1, r3
 810d51c:	6878      	ldr	r0, [r7, #4]
 810d51e:	f00d ff71 	bl	811b404 <USBD_LL_StallEP>
                (void)USBD_LL_StallEP(pdev, 0x80U);
 810d522:	2180      	movs	r1, #128	; 0x80
 810d524:	6878      	ldr	r0, [r7, #4]
 810d526:	f00d ff6d 	bl	811b404 <USBD_LL_StallEP>
 810d52a:	bf00      	nop
              }
              else
              {
                USBD_CtlError(pdev, req);
              }
              break;
 810d52c:	e020      	b.n	810d570 <USBD_StdEPReq+0x110>
                USBD_CtlError(pdev, req);
 810d52e:	6839      	ldr	r1, [r7, #0]
 810d530:	6878      	ldr	r0, [r7, #4]
 810d532:	f000 fca4 	bl	810de7e <USBD_CtlError>
              break;
 810d536:	e01b      	b.n	810d570 <USBD_StdEPReq+0x110>

            case USBD_STATE_CONFIGURED:
              if (req->wValue == USB_FEATURE_EP_HALT)
 810d538:	683b      	ldr	r3, [r7, #0]
 810d53a:	885b      	ldrh	r3, [r3, #2]
 810d53c:	2b00      	cmp	r3, #0
 810d53e:	d10e      	bne.n	810d55e <USBD_StdEPReq+0xfe>
              {
                if ((ep_addr != 0x00U) && (ep_addr != 0x80U) && (req->wLength == 0x00U))
 810d540:	7bbb      	ldrb	r3, [r7, #14]
 810d542:	2b00      	cmp	r3, #0
 810d544:	d00b      	beq.n	810d55e <USBD_StdEPReq+0xfe>
 810d546:	7bbb      	ldrb	r3, [r7, #14]
 810d548:	2b80      	cmp	r3, #128	; 0x80
 810d54a:	d008      	beq.n	810d55e <USBD_StdEPReq+0xfe>
 810d54c:	683b      	ldr	r3, [r7, #0]
 810d54e:	88db      	ldrh	r3, [r3, #6]
 810d550:	2b00      	cmp	r3, #0
 810d552:	d104      	bne.n	810d55e <USBD_StdEPReq+0xfe>
                {
                  (void)USBD_LL_StallEP(pdev, ep_addr);
 810d554:	7bbb      	ldrb	r3, [r7, #14]
 810d556:	4619      	mov	r1, r3
 810d558:	6878      	ldr	r0, [r7, #4]
 810d55a:	f00d ff53 	bl	811b404 <USBD_LL_StallEP>
                }
              }
              (void)USBD_CtlSendStatus(pdev);
 810d55e:	6878      	ldr	r0, [r7, #4]
 810d560:	f000 ff71 	bl	810e446 <USBD_CtlSendStatus>

              break;
 810d564:	e004      	b.n	810d570 <USBD_StdEPReq+0x110>

            default:
              USBD_CtlError(pdev, req);
 810d566:	6839      	ldr	r1, [r7, #0]
 810d568:	6878      	ldr	r0, [r7, #4]
 810d56a:	f000 fc88 	bl	810de7e <USBD_CtlError>
              break;
 810d56e:	bf00      	nop
          }
          break;
 810d570:	e107      	b.n	810d782 <USBD_StdEPReq+0x322>

        case USB_REQ_CLEAR_FEATURE:

          switch (pdev->dev_state)
 810d572:	687b      	ldr	r3, [r7, #4]
 810d574:	f893 329c 	ldrb.w	r3, [r3, #668]	; 0x29c
 810d578:	b2db      	uxtb	r3, r3
 810d57a:	2b02      	cmp	r3, #2
 810d57c:	d002      	beq.n	810d584 <USBD_StdEPReq+0x124>
 810d57e:	2b03      	cmp	r3, #3
 810d580:	d016      	beq.n	810d5b0 <USBD_StdEPReq+0x150>
 810d582:	e04b      	b.n	810d61c <USBD_StdEPReq+0x1bc>
          {
            case USBD_STATE_ADDRESSED:
              if ((ep_addr != 0x00U) && (ep_addr != 0x80U))
 810d584:	7bbb      	ldrb	r3, [r7, #14]
 810d586:	2b00      	cmp	r3, #0
 810d588:	d00d      	beq.n	810d5a6 <USBD_StdEPReq+0x146>
 810d58a:	7bbb      	ldrb	r3, [r7, #14]
 810d58c:	2b80      	cmp	r3, #128	; 0x80
 810d58e:	d00a      	beq.n	810d5a6 <USBD_StdEPReq+0x146>
              {
                (void)USBD_LL_StallEP(pdev, ep_addr);
 810d590:	7bbb      	ldrb	r3, [r7, #14]
 810d592:	4619      	mov	r1, r3
 810d594:	6878      	ldr	r0, [r7, #4]
 810d596:	f00d ff35 	bl	811b404 <USBD_LL_StallEP>
                (void)USBD_LL_StallEP(pdev, 0x80U);
 810d59a:	2180      	movs	r1, #128	; 0x80
 810d59c:	6878      	ldr	r0, [r7, #4]
 810d59e:	f00d ff31 	bl	811b404 <USBD_LL_StallEP>
 810d5a2:	bf00      	nop
              }
              else
              {
                USBD_CtlError(pdev, req);
              }
              break;
 810d5a4:	e040      	b.n	810d628 <USBD_StdEPReq+0x1c8>
                USBD_CtlError(pdev, req);
 810d5a6:	6839      	ldr	r1, [r7, #0]
 810d5a8:	6878      	ldr	r0, [r7, #4]
 810d5aa:	f000 fc68 	bl	810de7e <USBD_CtlError>
              break;
 810d5ae:	e03b      	b.n	810d628 <USBD_StdEPReq+0x1c8>

            case USBD_STATE_CONFIGURED:
              if (req->wValue == USB_FEATURE_EP_HALT)
 810d5b0:	683b      	ldr	r3, [r7, #0]
 810d5b2:	885b      	ldrh	r3, [r3, #2]
 810d5b4:	2b00      	cmp	r3, #0
 810d5b6:	d136      	bne.n	810d626 <USBD_StdEPReq+0x1c6>
              {
                if ((ep_addr & 0x7FU) != 0x00U)
 810d5b8:	7bbb      	ldrb	r3, [r7, #14]
 810d5ba:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 810d5be:	2b00      	cmp	r3, #0
 810d5c0:	d004      	beq.n	810d5cc <USBD_StdEPReq+0x16c>
                {
                  (void)USBD_LL_ClearStallEP(pdev, ep_addr);
 810d5c2:	7bbb      	ldrb	r3, [r7, #14]
 810d5c4:	4619      	mov	r1, r3
 810d5c6:	6878      	ldr	r0, [r7, #4]
 810d5c8:	f00d ff3b 	bl	811b442 <USBD_LL_ClearStallEP>
                }
                (void)USBD_CtlSendStatus(pdev);
 810d5cc:	6878      	ldr	r0, [r7, #4]
 810d5ce:	f000 ff3a 	bl	810e446 <USBD_CtlSendStatus>

                /* Get the class index relative to this interface */
                idx = USBD_CoreFindEP(pdev, ep_addr);
 810d5d2:	7bbb      	ldrb	r3, [r7, #14]
 810d5d4:	4619      	mov	r1, r3
 810d5d6:	6878      	ldr	r0, [r7, #4]
 810d5d8:	f7ff fde2 	bl	810d1a0 <USBD_CoreFindEP>
 810d5dc:	4603      	mov	r3, r0
 810d5de:	737b      	strb	r3, [r7, #13]
                if (((uint8_t)idx != 0xFFU) && (idx < USBD_MAX_SUPPORTED_CLASS))
 810d5e0:	7b7b      	ldrb	r3, [r7, #13]
 810d5e2:	2bff      	cmp	r3, #255	; 0xff
 810d5e4:	d01f      	beq.n	810d626 <USBD_StdEPReq+0x1c6>
 810d5e6:	7b7b      	ldrb	r3, [r7, #13]
 810d5e8:	2b00      	cmp	r3, #0
 810d5ea:	d11c      	bne.n	810d626 <USBD_StdEPReq+0x1c6>
                {
                  pdev->classId = idx;
 810d5ec:	7b7a      	ldrb	r2, [r7, #13]
 810d5ee:	687b      	ldr	r3, [r7, #4]
 810d5f0:	f8c3 22d4 	str.w	r2, [r3, #724]	; 0x2d4
                  /* Call the class data out function to manage the request */
                  if (pdev->pClass[idx]->Setup != NULL)
 810d5f4:	7b7a      	ldrb	r2, [r7, #13]
 810d5f6:	687b      	ldr	r3, [r7, #4]
 810d5f8:	32ae      	adds	r2, #174	; 0xae
 810d5fa:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 810d5fe:	689b      	ldr	r3, [r3, #8]
 810d600:	2b00      	cmp	r3, #0
 810d602:	d010      	beq.n	810d626 <USBD_StdEPReq+0x1c6>
                  {
                    ret = (USBD_StatusTypeDef)(pdev->pClass[idx]->Setup(pdev, req));
 810d604:	7b7a      	ldrb	r2, [r7, #13]
 810d606:	687b      	ldr	r3, [r7, #4]
 810d608:	32ae      	adds	r2, #174	; 0xae
 810d60a:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 810d60e:	689b      	ldr	r3, [r3, #8]
 810d610:	6839      	ldr	r1, [r7, #0]
 810d612:	6878      	ldr	r0, [r7, #4]
 810d614:	4798      	blx	r3
 810d616:	4603      	mov	r3, r0
 810d618:	73fb      	strb	r3, [r7, #15]
                  }
                }
              }
              break;
 810d61a:	e004      	b.n	810d626 <USBD_StdEPReq+0x1c6>

            default:
              USBD_CtlError(pdev, req);
 810d61c:	6839      	ldr	r1, [r7, #0]
 810d61e:	6878      	ldr	r0, [r7, #4]
 810d620:	f000 fc2d 	bl	810de7e <USBD_CtlError>
              break;
 810d624:	e000      	b.n	810d628 <USBD_StdEPReq+0x1c8>
              break;
 810d626:	bf00      	nop
          }
          break;
 810d628:	e0ab      	b.n	810d782 <USBD_StdEPReq+0x322>

        case USB_REQ_GET_STATUS:
          switch (pdev->dev_state)
 810d62a:	687b      	ldr	r3, [r7, #4]
 810d62c:	f893 329c 	ldrb.w	r3, [r3, #668]	; 0x29c
 810d630:	b2db      	uxtb	r3, r3
 810d632:	2b02      	cmp	r3, #2
 810d634:	d002      	beq.n	810d63c <USBD_StdEPReq+0x1dc>
 810d636:	2b03      	cmp	r3, #3
 810d638:	d032      	beq.n	810d6a0 <USBD_StdEPReq+0x240>
 810d63a:	e097      	b.n	810d76c <USBD_StdEPReq+0x30c>
          {
            case USBD_STATE_ADDRESSED:
              if ((ep_addr != 0x00U) && (ep_addr != 0x80U))
 810d63c:	7bbb      	ldrb	r3, [r7, #14]
 810d63e:	2b00      	cmp	r3, #0
 810d640:	d007      	beq.n	810d652 <USBD_StdEPReq+0x1f2>
 810d642:	7bbb      	ldrb	r3, [r7, #14]
 810d644:	2b80      	cmp	r3, #128	; 0x80
 810d646:	d004      	beq.n	810d652 <USBD_StdEPReq+0x1f2>
              {
                USBD_CtlError(pdev, req);
 810d648:	6839      	ldr	r1, [r7, #0]
 810d64a:	6878      	ldr	r0, [r7, #4]
 810d64c:	f000 fc17 	bl	810de7e <USBD_CtlError>
                break;
 810d650:	e091      	b.n	810d776 <USBD_StdEPReq+0x316>
              }
              pep = ((ep_addr & 0x80U) == 0x80U) ? &pdev->ep_in[ep_addr & 0x7FU] : \
 810d652:	f997 300e 	ldrsb.w	r3, [r7, #14]
 810d656:	2b00      	cmp	r3, #0
 810d658:	da0b      	bge.n	810d672 <USBD_StdEPReq+0x212>
 810d65a:	7bbb      	ldrb	r3, [r7, #14]
 810d65c:	f003 027f 	and.w	r2, r3, #127	; 0x7f
 810d660:	4613      	mov	r3, r2
 810d662:	009b      	lsls	r3, r3, #2
 810d664:	4413      	add	r3, r2
 810d666:	009b      	lsls	r3, r3, #2
 810d668:	3310      	adds	r3, #16
 810d66a:	687a      	ldr	r2, [r7, #4]
 810d66c:	4413      	add	r3, r2
 810d66e:	3304      	adds	r3, #4
 810d670:	e00b      	b.n	810d68a <USBD_StdEPReq+0x22a>
                    &pdev->ep_out[ep_addr & 0x7FU];
 810d672:	7bbb      	ldrb	r3, [r7, #14]
 810d674:	f003 027f 	and.w	r2, r3, #127	; 0x7f
              pep = ((ep_addr & 0x80U) == 0x80U) ? &pdev->ep_in[ep_addr & 0x7FU] : \
 810d678:	4613      	mov	r3, r2
 810d67a:	009b      	lsls	r3, r3, #2
 810d67c:	4413      	add	r3, r2
 810d67e:	009b      	lsls	r3, r3, #2
 810d680:	f503 73a8 	add.w	r3, r3, #336	; 0x150
 810d684:	687a      	ldr	r2, [r7, #4]
 810d686:	4413      	add	r3, r2
 810d688:	3304      	adds	r3, #4
 810d68a:	60bb      	str	r3, [r7, #8]

              pep->status = 0x0000U;
 810d68c:	68bb      	ldr	r3, [r7, #8]
 810d68e:	2200      	movs	r2, #0
 810d690:	601a      	str	r2, [r3, #0]

              (void)USBD_CtlSendData(pdev, (uint8_t *)&pep->status, 2U);
 810d692:	68bb      	ldr	r3, [r7, #8]
 810d694:	2202      	movs	r2, #2
 810d696:	4619      	mov	r1, r3
 810d698:	6878      	ldr	r0, [r7, #4]
 810d69a:	f000 fe97 	bl	810e3cc <USBD_CtlSendData>
              break;
 810d69e:	e06a      	b.n	810d776 <USBD_StdEPReq+0x316>

            case USBD_STATE_CONFIGURED:
              if ((ep_addr & 0x80U) == 0x80U)
 810d6a0:	f997 300e 	ldrsb.w	r3, [r7, #14]
 810d6a4:	2b00      	cmp	r3, #0
 810d6a6:	da11      	bge.n	810d6cc <USBD_StdEPReq+0x26c>
              {
                if (pdev->ep_in[ep_addr & 0xFU].is_used == 0U)
 810d6a8:	7bbb      	ldrb	r3, [r7, #14]
 810d6aa:	f003 020f 	and.w	r2, r3, #15
 810d6ae:	6879      	ldr	r1, [r7, #4]
 810d6b0:	4613      	mov	r3, r2
 810d6b2:	009b      	lsls	r3, r3, #2
 810d6b4:	4413      	add	r3, r2
 810d6b6:	009b      	lsls	r3, r3, #2
 810d6b8:	440b      	add	r3, r1
 810d6ba:	3324      	adds	r3, #36	; 0x24
 810d6bc:	881b      	ldrh	r3, [r3, #0]
 810d6be:	2b00      	cmp	r3, #0
 810d6c0:	d117      	bne.n	810d6f2 <USBD_StdEPReq+0x292>
                {
                  USBD_CtlError(pdev, req);
 810d6c2:	6839      	ldr	r1, [r7, #0]
 810d6c4:	6878      	ldr	r0, [r7, #4]
 810d6c6:	f000 fbda 	bl	810de7e <USBD_CtlError>
                  break;
 810d6ca:	e054      	b.n	810d776 <USBD_StdEPReq+0x316>
                }
              }
              else
              {
                if (pdev->ep_out[ep_addr & 0xFU].is_used == 0U)
 810d6cc:	7bbb      	ldrb	r3, [r7, #14]
 810d6ce:	f003 020f 	and.w	r2, r3, #15
 810d6d2:	6879      	ldr	r1, [r7, #4]
 810d6d4:	4613      	mov	r3, r2
 810d6d6:	009b      	lsls	r3, r3, #2
 810d6d8:	4413      	add	r3, r2
 810d6da:	009b      	lsls	r3, r3, #2
 810d6dc:	440b      	add	r3, r1
 810d6de:	f503 73b2 	add.w	r3, r3, #356	; 0x164
 810d6e2:	881b      	ldrh	r3, [r3, #0]
 810d6e4:	2b00      	cmp	r3, #0
 810d6e6:	d104      	bne.n	810d6f2 <USBD_StdEPReq+0x292>
                {
                  USBD_CtlError(pdev, req);
 810d6e8:	6839      	ldr	r1, [r7, #0]
 810d6ea:	6878      	ldr	r0, [r7, #4]
 810d6ec:	f000 fbc7 	bl	810de7e <USBD_CtlError>
                  break;
 810d6f0:	e041      	b.n	810d776 <USBD_StdEPReq+0x316>
                }
              }

              pep = ((ep_addr & 0x80U) == 0x80U) ? &pdev->ep_in[ep_addr & 0x7FU] : \
 810d6f2:	f997 300e 	ldrsb.w	r3, [r7, #14]
 810d6f6:	2b00      	cmp	r3, #0
 810d6f8:	da0b      	bge.n	810d712 <USBD_StdEPReq+0x2b2>
 810d6fa:	7bbb      	ldrb	r3, [r7, #14]
 810d6fc:	f003 027f 	and.w	r2, r3, #127	; 0x7f
 810d700:	4613      	mov	r3, r2
 810d702:	009b      	lsls	r3, r3, #2
 810d704:	4413      	add	r3, r2
 810d706:	009b      	lsls	r3, r3, #2
 810d708:	3310      	adds	r3, #16
 810d70a:	687a      	ldr	r2, [r7, #4]
 810d70c:	4413      	add	r3, r2
 810d70e:	3304      	adds	r3, #4
 810d710:	e00b      	b.n	810d72a <USBD_StdEPReq+0x2ca>
                    &pdev->ep_out[ep_addr & 0x7FU];
 810d712:	7bbb      	ldrb	r3, [r7, #14]
 810d714:	f003 027f 	and.w	r2, r3, #127	; 0x7f
              pep = ((ep_addr & 0x80U) == 0x80U) ? &pdev->ep_in[ep_addr & 0x7FU] : \
 810d718:	4613      	mov	r3, r2
 810d71a:	009b      	lsls	r3, r3, #2
 810d71c:	4413      	add	r3, r2
 810d71e:	009b      	lsls	r3, r3, #2
 810d720:	f503 73a8 	add.w	r3, r3, #336	; 0x150
 810d724:	687a      	ldr	r2, [r7, #4]
 810d726:	4413      	add	r3, r2
 810d728:	3304      	adds	r3, #4
 810d72a:	60bb      	str	r3, [r7, #8]

              if ((ep_addr == 0x00U) || (ep_addr == 0x80U))
 810d72c:	7bbb      	ldrb	r3, [r7, #14]
 810d72e:	2b00      	cmp	r3, #0
 810d730:	d002      	beq.n	810d738 <USBD_StdEPReq+0x2d8>
 810d732:	7bbb      	ldrb	r3, [r7, #14]
 810d734:	2b80      	cmp	r3, #128	; 0x80
 810d736:	d103      	bne.n	810d740 <USBD_StdEPReq+0x2e0>
              {
                pep->status = 0x0000U;
 810d738:	68bb      	ldr	r3, [r7, #8]
 810d73a:	2200      	movs	r2, #0
 810d73c:	601a      	str	r2, [r3, #0]
 810d73e:	e00e      	b.n	810d75e <USBD_StdEPReq+0x2fe>
              }
              else if (USBD_LL_IsStallEP(pdev, ep_addr) != 0U)
 810d740:	7bbb      	ldrb	r3, [r7, #14]
 810d742:	4619      	mov	r1, r3
 810d744:	6878      	ldr	r0, [r7, #4]
 810d746:	f00d fe9b 	bl	811b480 <USBD_LL_IsStallEP>
 810d74a:	4603      	mov	r3, r0
 810d74c:	2b00      	cmp	r3, #0
 810d74e:	d003      	beq.n	810d758 <USBD_StdEPReq+0x2f8>
              {
                pep->status = 0x0001U;
 810d750:	68bb      	ldr	r3, [r7, #8]
 810d752:	2201      	movs	r2, #1
 810d754:	601a      	str	r2, [r3, #0]
 810d756:	e002      	b.n	810d75e <USBD_StdEPReq+0x2fe>
              }
              else
              {
                pep->status = 0x0000U;
 810d758:	68bb      	ldr	r3, [r7, #8]
 810d75a:	2200      	movs	r2, #0
 810d75c:	601a      	str	r2, [r3, #0]
              }

              (void)USBD_CtlSendData(pdev, (uint8_t *)&pep->status, 2U);
 810d75e:	68bb      	ldr	r3, [r7, #8]
 810d760:	2202      	movs	r2, #2
 810d762:	4619      	mov	r1, r3
 810d764:	6878      	ldr	r0, [r7, #4]
 810d766:	f000 fe31 	bl	810e3cc <USBD_CtlSendData>
              break;
 810d76a:	e004      	b.n	810d776 <USBD_StdEPReq+0x316>

            default:
              USBD_CtlError(pdev, req);
 810d76c:	6839      	ldr	r1, [r7, #0]
 810d76e:	6878      	ldr	r0, [r7, #4]
 810d770:	f000 fb85 	bl	810de7e <USBD_CtlError>
              break;
 810d774:	bf00      	nop
          }
          break;
 810d776:	e004      	b.n	810d782 <USBD_StdEPReq+0x322>

        default:
          USBD_CtlError(pdev, req);
 810d778:	6839      	ldr	r1, [r7, #0]
 810d77a:	6878      	ldr	r0, [r7, #4]
 810d77c:	f000 fb7f 	bl	810de7e <USBD_CtlError>
          break;
 810d780:	bf00      	nop
      }
      break;
 810d782:	e005      	b.n	810d790 <USBD_StdEPReq+0x330>

    default:
      USBD_CtlError(pdev, req);
 810d784:	6839      	ldr	r1, [r7, #0]
 810d786:	6878      	ldr	r0, [r7, #4]
 810d788:	f000 fb79 	bl	810de7e <USBD_CtlError>
      break;
 810d78c:	e000      	b.n	810d790 <USBD_StdEPReq+0x330>
      break;
 810d78e:	bf00      	nop
  }

  return ret;
 810d790:	7bfb      	ldrb	r3, [r7, #15]
}
 810d792:	4618      	mov	r0, r3
 810d794:	3710      	adds	r7, #16
 810d796:	46bd      	mov	sp, r7
 810d798:	bd80      	pop	{r7, pc}
	...

0810d79c <USBD_GetDescriptor>:
  * @param  pdev: device instance
  * @param  req: usb request
  * @retval None
  */
static void USBD_GetDescriptor(USBD_HandleTypeDef *pdev, USBD_SetupReqTypedef *req)
{
 810d79c:	b580      	push	{r7, lr}
 810d79e:	b084      	sub	sp, #16
 810d7a0:	af00      	add	r7, sp, #0
 810d7a2:	6078      	str	r0, [r7, #4]
 810d7a4:	6039      	str	r1, [r7, #0]
  uint16_t len = 0U;
 810d7a6:	2300      	movs	r3, #0
 810d7a8:	813b      	strh	r3, [r7, #8]
  uint8_t *pbuf = NULL;
 810d7aa:	2300      	movs	r3, #0
 810d7ac:	60fb      	str	r3, [r7, #12]
  uint8_t err = 0U;
 810d7ae:	2300      	movs	r3, #0
 810d7b0:	72fb      	strb	r3, [r7, #11]

  switch (req->wValue >> 8)
 810d7b2:	683b      	ldr	r3, [r7, #0]
 810d7b4:	885b      	ldrh	r3, [r3, #2]
 810d7b6:	0a1b      	lsrs	r3, r3, #8
 810d7b8:	b29b      	uxth	r3, r3
 810d7ba:	3b01      	subs	r3, #1
 810d7bc:	2b0e      	cmp	r3, #14
 810d7be:	f200 8152 	bhi.w	810da66 <USBD_GetDescriptor+0x2ca>
 810d7c2:	a201      	add	r2, pc, #4	; (adr r2, 810d7c8 <USBD_GetDescriptor+0x2c>)
 810d7c4:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 810d7c8:	0810d839 	.word	0x0810d839
 810d7cc:	0810d851 	.word	0x0810d851
 810d7d0:	0810d891 	.word	0x0810d891
 810d7d4:	0810da67 	.word	0x0810da67
 810d7d8:	0810da67 	.word	0x0810da67
 810d7dc:	0810da07 	.word	0x0810da07
 810d7e0:	0810da33 	.word	0x0810da33
 810d7e4:	0810da67 	.word	0x0810da67
 810d7e8:	0810da67 	.word	0x0810da67
 810d7ec:	0810da67 	.word	0x0810da67
 810d7f0:	0810da67 	.word	0x0810da67
 810d7f4:	0810da67 	.word	0x0810da67
 810d7f8:	0810da67 	.word	0x0810da67
 810d7fc:	0810da67 	.word	0x0810da67
 810d800:	0810d805 	.word	0x0810d805
  {
#if ((USBD_LPM_ENABLED == 1U) || (USBD_CLASS_BOS_ENABLED == 1U))
    case USB_DESC_TYPE_BOS:
      if (pdev->pDesc->GetBOSDescriptor != NULL)
 810d804:	687b      	ldr	r3, [r7, #4]
 810d806:	f8d3 32b4 	ldr.w	r3, [r3, #692]	; 0x2b4
 810d80a:	69db      	ldr	r3, [r3, #28]
 810d80c:	2b00      	cmp	r3, #0
 810d80e:	d00b      	beq.n	810d828 <USBD_GetDescriptor+0x8c>
      {
        pbuf = pdev->pDesc->GetBOSDescriptor(pdev->dev_speed, &len);
 810d810:	687b      	ldr	r3, [r7, #4]
 810d812:	f8d3 32b4 	ldr.w	r3, [r3, #692]	; 0x2b4
 810d816:	69db      	ldr	r3, [r3, #28]
 810d818:	687a      	ldr	r2, [r7, #4]
 810d81a:	7c12      	ldrb	r2, [r2, #16]
 810d81c:	f107 0108 	add.w	r1, r7, #8
 810d820:	4610      	mov	r0, r2
 810d822:	4798      	blx	r3
 810d824:	60f8      	str	r0, [r7, #12]
      else
      {
        USBD_CtlError(pdev, req);
        err++;
      }
      break;
 810d826:	e126      	b.n	810da76 <USBD_GetDescriptor+0x2da>
        USBD_CtlError(pdev, req);
 810d828:	6839      	ldr	r1, [r7, #0]
 810d82a:	6878      	ldr	r0, [r7, #4]
 810d82c:	f000 fb27 	bl	810de7e <USBD_CtlError>
        err++;
 810d830:	7afb      	ldrb	r3, [r7, #11]
 810d832:	3301      	adds	r3, #1
 810d834:	72fb      	strb	r3, [r7, #11]
      break;
 810d836:	e11e      	b.n	810da76 <USBD_GetDescriptor+0x2da>
#endif /* (USBD_LPM_ENABLED == 1U) || (USBD_CLASS_BOS_ENABLED == 1U) */
    case USB_DESC_TYPE_DEVICE:
      pbuf = pdev->pDesc->GetDeviceDescriptor(pdev->dev_speed, &len);
 810d838:	687b      	ldr	r3, [r7, #4]
 810d83a:	f8d3 32b4 	ldr.w	r3, [r3, #692]	; 0x2b4
 810d83e:	681b      	ldr	r3, [r3, #0]
 810d840:	687a      	ldr	r2, [r7, #4]
 810d842:	7c12      	ldrb	r2, [r2, #16]
 810d844:	f107 0108 	add.w	r1, r7, #8
 810d848:	4610      	mov	r0, r2
 810d84a:	4798      	blx	r3
 810d84c:	60f8      	str	r0, [r7, #12]
      break;
 810d84e:	e112      	b.n	810da76 <USBD_GetDescriptor+0x2da>

    case USB_DESC_TYPE_CONFIGURATION:
      if (pdev->dev_speed == USBD_SPEED_HIGH)
 810d850:	687b      	ldr	r3, [r7, #4]
 810d852:	7c1b      	ldrb	r3, [r3, #16]
 810d854:	2b00      	cmp	r3, #0
 810d856:	d10d      	bne.n	810d874 <USBD_GetDescriptor+0xd8>
          pbuf = (uint8_t *)USBD_CMPSIT.GetHSConfigDescriptor(&len);
        }
        else
#endif /* USE_USBD_COMPOSITE */
        {
          pbuf = (uint8_t *)pdev->pClass[0]->GetHSConfigDescriptor(&len);
 810d858:	687b      	ldr	r3, [r7, #4]
 810d85a:	f8d3 32b8 	ldr.w	r3, [r3, #696]	; 0x2b8
 810d85e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 810d860:	f107 0208 	add.w	r2, r7, #8
 810d864:	4610      	mov	r0, r2
 810d866:	4798      	blx	r3
 810d868:	60f8      	str	r0, [r7, #12]
        }
        pbuf[1] = USB_DESC_TYPE_CONFIGURATION;
 810d86a:	68fb      	ldr	r3, [r7, #12]
 810d86c:	3301      	adds	r3, #1
 810d86e:	2202      	movs	r2, #2
 810d870:	701a      	strb	r2, [r3, #0]
        {
          pbuf = (uint8_t *)pdev->pClass[0]->GetFSConfigDescriptor(&len);
        }
        pbuf[1] = USB_DESC_TYPE_CONFIGURATION;
      }
      break;
 810d872:	e100      	b.n	810da76 <USBD_GetDescriptor+0x2da>
          pbuf = (uint8_t *)pdev->pClass[0]->GetFSConfigDescriptor(&len);
 810d874:	687b      	ldr	r3, [r7, #4]
 810d876:	f8d3 32b8 	ldr.w	r3, [r3, #696]	; 0x2b8
 810d87a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 810d87c:	f107 0208 	add.w	r2, r7, #8
 810d880:	4610      	mov	r0, r2
 810d882:	4798      	blx	r3
 810d884:	60f8      	str	r0, [r7, #12]
        pbuf[1] = USB_DESC_TYPE_CONFIGURATION;
 810d886:	68fb      	ldr	r3, [r7, #12]
 810d888:	3301      	adds	r3, #1
 810d88a:	2202      	movs	r2, #2
 810d88c:	701a      	strb	r2, [r3, #0]
      break;
 810d88e:	e0f2      	b.n	810da76 <USBD_GetDescriptor+0x2da>

    case USB_DESC_TYPE_STRING:
      switch ((uint8_t)(req->wValue))
 810d890:	683b      	ldr	r3, [r7, #0]
 810d892:	885b      	ldrh	r3, [r3, #2]
 810d894:	b2db      	uxtb	r3, r3
 810d896:	2b05      	cmp	r3, #5
 810d898:	f200 80ac 	bhi.w	810d9f4 <USBD_GetDescriptor+0x258>
 810d89c:	a201      	add	r2, pc, #4	; (adr r2, 810d8a4 <USBD_GetDescriptor+0x108>)
 810d89e:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 810d8a2:	bf00      	nop
 810d8a4:	0810d8bd 	.word	0x0810d8bd
 810d8a8:	0810d8f1 	.word	0x0810d8f1
 810d8ac:	0810d925 	.word	0x0810d925
 810d8b0:	0810d959 	.word	0x0810d959
 810d8b4:	0810d98d 	.word	0x0810d98d
 810d8b8:	0810d9c1 	.word	0x0810d9c1
      {
        case USBD_IDX_LANGID_STR:
          if (pdev->pDesc->GetLangIDStrDescriptor != NULL)
 810d8bc:	687b      	ldr	r3, [r7, #4]
 810d8be:	f8d3 32b4 	ldr.w	r3, [r3, #692]	; 0x2b4
 810d8c2:	685b      	ldr	r3, [r3, #4]
 810d8c4:	2b00      	cmp	r3, #0
 810d8c6:	d00b      	beq.n	810d8e0 <USBD_GetDescriptor+0x144>
          {
            pbuf = pdev->pDesc->GetLangIDStrDescriptor(pdev->dev_speed, &len);
 810d8c8:	687b      	ldr	r3, [r7, #4]
 810d8ca:	f8d3 32b4 	ldr.w	r3, [r3, #692]	; 0x2b4
 810d8ce:	685b      	ldr	r3, [r3, #4]
 810d8d0:	687a      	ldr	r2, [r7, #4]
 810d8d2:	7c12      	ldrb	r2, [r2, #16]
 810d8d4:	f107 0108 	add.w	r1, r7, #8
 810d8d8:	4610      	mov	r0, r2
 810d8da:	4798      	blx	r3
 810d8dc:	60f8      	str	r0, [r7, #12]
          else
          {
            USBD_CtlError(pdev, req);
            err++;
          }
          break;
 810d8de:	e091      	b.n	810da04 <USBD_GetDescriptor+0x268>
            USBD_CtlError(pdev, req);
 810d8e0:	6839      	ldr	r1, [r7, #0]
 810d8e2:	6878      	ldr	r0, [r7, #4]
 810d8e4:	f000 facb 	bl	810de7e <USBD_CtlError>
            err++;
 810d8e8:	7afb      	ldrb	r3, [r7, #11]
 810d8ea:	3301      	adds	r3, #1
 810d8ec:	72fb      	strb	r3, [r7, #11]
          break;
 810d8ee:	e089      	b.n	810da04 <USBD_GetDescriptor+0x268>

        case USBD_IDX_MFC_STR:
          if (pdev->pDesc->GetManufacturerStrDescriptor != NULL)
 810d8f0:	687b      	ldr	r3, [r7, #4]
 810d8f2:	f8d3 32b4 	ldr.w	r3, [r3, #692]	; 0x2b4
 810d8f6:	689b      	ldr	r3, [r3, #8]
 810d8f8:	2b00      	cmp	r3, #0
 810d8fa:	d00b      	beq.n	810d914 <USBD_GetDescriptor+0x178>
          {
            pbuf = pdev->pDesc->GetManufacturerStrDescriptor(pdev->dev_speed, &len);
 810d8fc:	687b      	ldr	r3, [r7, #4]
 810d8fe:	f8d3 32b4 	ldr.w	r3, [r3, #692]	; 0x2b4
 810d902:	689b      	ldr	r3, [r3, #8]
 810d904:	687a      	ldr	r2, [r7, #4]
 810d906:	7c12      	ldrb	r2, [r2, #16]
 810d908:	f107 0108 	add.w	r1, r7, #8
 810d90c:	4610      	mov	r0, r2
 810d90e:	4798      	blx	r3
 810d910:	60f8      	str	r0, [r7, #12]
          else
          {
            USBD_CtlError(pdev, req);
            err++;
          }
          break;
 810d912:	e077      	b.n	810da04 <USBD_GetDescriptor+0x268>
            USBD_CtlError(pdev, req);
 810d914:	6839      	ldr	r1, [r7, #0]
 810d916:	6878      	ldr	r0, [r7, #4]
 810d918:	f000 fab1 	bl	810de7e <USBD_CtlError>
            err++;
 810d91c:	7afb      	ldrb	r3, [r7, #11]
 810d91e:	3301      	adds	r3, #1
 810d920:	72fb      	strb	r3, [r7, #11]
          break;
 810d922:	e06f      	b.n	810da04 <USBD_GetDescriptor+0x268>

        case USBD_IDX_PRODUCT_STR:
          if (pdev->pDesc->GetProductStrDescriptor != NULL)
 810d924:	687b      	ldr	r3, [r7, #4]
 810d926:	f8d3 32b4 	ldr.w	r3, [r3, #692]	; 0x2b4
 810d92a:	68db      	ldr	r3, [r3, #12]
 810d92c:	2b00      	cmp	r3, #0
 810d92e:	d00b      	beq.n	810d948 <USBD_GetDescriptor+0x1ac>
          {
            pbuf = pdev->pDesc->GetProductStrDescriptor(pdev->dev_speed, &len);
 810d930:	687b      	ldr	r3, [r7, #4]
 810d932:	f8d3 32b4 	ldr.w	r3, [r3, #692]	; 0x2b4
 810d936:	68db      	ldr	r3, [r3, #12]
 810d938:	687a      	ldr	r2, [r7, #4]
 810d93a:	7c12      	ldrb	r2, [r2, #16]
 810d93c:	f107 0108 	add.w	r1, r7, #8
 810d940:	4610      	mov	r0, r2
 810d942:	4798      	blx	r3
 810d944:	60f8      	str	r0, [r7, #12]
          else
          {
            USBD_CtlError(pdev, req);
            err++;
          }
          break;
 810d946:	e05d      	b.n	810da04 <USBD_GetDescriptor+0x268>
            USBD_CtlError(pdev, req);
 810d948:	6839      	ldr	r1, [r7, #0]
 810d94a:	6878      	ldr	r0, [r7, #4]
 810d94c:	f000 fa97 	bl	810de7e <USBD_CtlError>
            err++;
 810d950:	7afb      	ldrb	r3, [r7, #11]
 810d952:	3301      	adds	r3, #1
 810d954:	72fb      	strb	r3, [r7, #11]
          break;
 810d956:	e055      	b.n	810da04 <USBD_GetDescriptor+0x268>

        case USBD_IDX_SERIAL_STR:
          if (pdev->pDesc->GetSerialStrDescriptor != NULL)
 810d958:	687b      	ldr	r3, [r7, #4]
 810d95a:	f8d3 32b4 	ldr.w	r3, [r3, #692]	; 0x2b4
 810d95e:	691b      	ldr	r3, [r3, #16]
 810d960:	2b00      	cmp	r3, #0
 810d962:	d00b      	beq.n	810d97c <USBD_GetDescriptor+0x1e0>
          {
            pbuf = pdev->pDesc->GetSerialStrDescriptor(pdev->dev_speed, &len);
 810d964:	687b      	ldr	r3, [r7, #4]
 810d966:	f8d3 32b4 	ldr.w	r3, [r3, #692]	; 0x2b4
 810d96a:	691b      	ldr	r3, [r3, #16]
 810d96c:	687a      	ldr	r2, [r7, #4]
 810d96e:	7c12      	ldrb	r2, [r2, #16]
 810d970:	f107 0108 	add.w	r1, r7, #8
 810d974:	4610      	mov	r0, r2
 810d976:	4798      	blx	r3
 810d978:	60f8      	str	r0, [r7, #12]
          else
          {
            USBD_CtlError(pdev, req);
            err++;
          }
          break;
 810d97a:	e043      	b.n	810da04 <USBD_GetDescriptor+0x268>
            USBD_CtlError(pdev, req);
 810d97c:	6839      	ldr	r1, [r7, #0]
 810d97e:	6878      	ldr	r0, [r7, #4]
 810d980:	f000 fa7d 	bl	810de7e <USBD_CtlError>
            err++;
 810d984:	7afb      	ldrb	r3, [r7, #11]
 810d986:	3301      	adds	r3, #1
 810d988:	72fb      	strb	r3, [r7, #11]
          break;
 810d98a:	e03b      	b.n	810da04 <USBD_GetDescriptor+0x268>

        case USBD_IDX_CONFIG_STR:
          if (pdev->pDesc->GetConfigurationStrDescriptor != NULL)
 810d98c:	687b      	ldr	r3, [r7, #4]
 810d98e:	f8d3 32b4 	ldr.w	r3, [r3, #692]	; 0x2b4
 810d992:	695b      	ldr	r3, [r3, #20]
 810d994:	2b00      	cmp	r3, #0
 810d996:	d00b      	beq.n	810d9b0 <USBD_GetDescriptor+0x214>
          {
            pbuf = pdev->pDesc->GetConfigurationStrDescriptor(pdev->dev_speed, &len);
 810d998:	687b      	ldr	r3, [r7, #4]
 810d99a:	f8d3 32b4 	ldr.w	r3, [r3, #692]	; 0x2b4
 810d99e:	695b      	ldr	r3, [r3, #20]
 810d9a0:	687a      	ldr	r2, [r7, #4]
 810d9a2:	7c12      	ldrb	r2, [r2, #16]
 810d9a4:	f107 0108 	add.w	r1, r7, #8
 810d9a8:	4610      	mov	r0, r2
 810d9aa:	4798      	blx	r3
 810d9ac:	60f8      	str	r0, [r7, #12]
          else
          {
            USBD_CtlError(pdev, req);
            err++;
          }
          break;
 810d9ae:	e029      	b.n	810da04 <USBD_GetDescriptor+0x268>
            USBD_CtlError(pdev, req);
 810d9b0:	6839      	ldr	r1, [r7, #0]
 810d9b2:	6878      	ldr	r0, [r7, #4]
 810d9b4:	f000 fa63 	bl	810de7e <USBD_CtlError>
            err++;
 810d9b8:	7afb      	ldrb	r3, [r7, #11]
 810d9ba:	3301      	adds	r3, #1
 810d9bc:	72fb      	strb	r3, [r7, #11]
          break;
 810d9be:	e021      	b.n	810da04 <USBD_GetDescriptor+0x268>

        case USBD_IDX_INTERFACE_STR:
          if (pdev->pDesc->GetInterfaceStrDescriptor != NULL)
 810d9c0:	687b      	ldr	r3, [r7, #4]
 810d9c2:	f8d3 32b4 	ldr.w	r3, [r3, #692]	; 0x2b4
 810d9c6:	699b      	ldr	r3, [r3, #24]
 810d9c8:	2b00      	cmp	r3, #0
 810d9ca:	d00b      	beq.n	810d9e4 <USBD_GetDescriptor+0x248>
          {
            pbuf = pdev->pDesc->GetInterfaceStrDescriptor(pdev->dev_speed, &len);
 810d9cc:	687b      	ldr	r3, [r7, #4]
 810d9ce:	f8d3 32b4 	ldr.w	r3, [r3, #692]	; 0x2b4
 810d9d2:	699b      	ldr	r3, [r3, #24]
 810d9d4:	687a      	ldr	r2, [r7, #4]
 810d9d6:	7c12      	ldrb	r2, [r2, #16]
 810d9d8:	f107 0108 	add.w	r1, r7, #8
 810d9dc:	4610      	mov	r0, r2
 810d9de:	4798      	blx	r3
 810d9e0:	60f8      	str	r0, [r7, #12]
          else
          {
            USBD_CtlError(pdev, req);
            err++;
          }
          break;
 810d9e2:	e00f      	b.n	810da04 <USBD_GetDescriptor+0x268>
            USBD_CtlError(pdev, req);
 810d9e4:	6839      	ldr	r1, [r7, #0]
 810d9e6:	6878      	ldr	r0, [r7, #4]
 810d9e8:	f000 fa49 	bl	810de7e <USBD_CtlError>
            err++;
 810d9ec:	7afb      	ldrb	r3, [r7, #11]
 810d9ee:	3301      	adds	r3, #1
 810d9f0:	72fb      	strb	r3, [r7, #11]
          break;
 810d9f2:	e007      	b.n	810da04 <USBD_GetDescriptor+0x268>
            err++;
          }
#endif /* USBD_SUPPORT_USER_STRING_DESC  */

#if ((USBD_CLASS_USER_STRING_DESC == 0U) && (USBD_SUPPORT_USER_STRING_DESC == 0U))
          USBD_CtlError(pdev, req);
 810d9f4:	6839      	ldr	r1, [r7, #0]
 810d9f6:	6878      	ldr	r0, [r7, #4]
 810d9f8:	f000 fa41 	bl	810de7e <USBD_CtlError>
          err++;
 810d9fc:	7afb      	ldrb	r3, [r7, #11]
 810d9fe:	3301      	adds	r3, #1
 810da00:	72fb      	strb	r3, [r7, #11]
#endif /* (USBD_CLASS_USER_STRING_DESC == 0U) && (USBD_SUPPORT_USER_STRING_DESC == 0U) */
          break;
 810da02:	bf00      	nop
      }
      break;
 810da04:	e037      	b.n	810da76 <USBD_GetDescriptor+0x2da>

    case USB_DESC_TYPE_DEVICE_QUALIFIER:
      if (pdev->dev_speed == USBD_SPEED_HIGH)
 810da06:	687b      	ldr	r3, [r7, #4]
 810da08:	7c1b      	ldrb	r3, [r3, #16]
 810da0a:	2b00      	cmp	r3, #0
 810da0c:	d109      	bne.n	810da22 <USBD_GetDescriptor+0x286>
          pbuf = (uint8_t *)USBD_CMPSIT.GetDeviceQualifierDescriptor(&len);
        }
        else
#endif /* USE_USBD_COMPOSITE */
        {
          pbuf = (uint8_t *)pdev->pClass[0]->GetDeviceQualifierDescriptor(&len);
 810da0e:	687b      	ldr	r3, [r7, #4]
 810da10:	f8d3 32b8 	ldr.w	r3, [r3, #696]	; 0x2b8
 810da14:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 810da16:	f107 0208 	add.w	r2, r7, #8
 810da1a:	4610      	mov	r0, r2
 810da1c:	4798      	blx	r3
 810da1e:	60f8      	str	r0, [r7, #12]
      else
      {
        USBD_CtlError(pdev, req);
        err++;
      }
      break;
 810da20:	e029      	b.n	810da76 <USBD_GetDescriptor+0x2da>
        USBD_CtlError(pdev, req);
 810da22:	6839      	ldr	r1, [r7, #0]
 810da24:	6878      	ldr	r0, [r7, #4]
 810da26:	f000 fa2a 	bl	810de7e <USBD_CtlError>
        err++;
 810da2a:	7afb      	ldrb	r3, [r7, #11]
 810da2c:	3301      	adds	r3, #1
 810da2e:	72fb      	strb	r3, [r7, #11]
      break;
 810da30:	e021      	b.n	810da76 <USBD_GetDescriptor+0x2da>

    case USB_DESC_TYPE_OTHER_SPEED_CONFIGURATION:
      if (pdev->dev_speed == USBD_SPEED_HIGH)
 810da32:	687b      	ldr	r3, [r7, #4]
 810da34:	7c1b      	ldrb	r3, [r3, #16]
 810da36:	2b00      	cmp	r3, #0
 810da38:	d10d      	bne.n	810da56 <USBD_GetDescriptor+0x2ba>
          pbuf = (uint8_t *)USBD_CMPSIT.GetOtherSpeedConfigDescriptor(&len);
        }
        else
#endif /* USE_USBD_COMPOSITE */
        {
          pbuf = (uint8_t *)pdev->pClass[0]->GetOtherSpeedConfigDescriptor(&len);
 810da3a:	687b      	ldr	r3, [r7, #4]
 810da3c:	f8d3 32b8 	ldr.w	r3, [r3, #696]	; 0x2b8
 810da40:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 810da42:	f107 0208 	add.w	r2, r7, #8
 810da46:	4610      	mov	r0, r2
 810da48:	4798      	blx	r3
 810da4a:	60f8      	str	r0, [r7, #12]
        }
        pbuf[1] = USB_DESC_TYPE_OTHER_SPEED_CONFIGURATION;
 810da4c:	68fb      	ldr	r3, [r7, #12]
 810da4e:	3301      	adds	r3, #1
 810da50:	2207      	movs	r2, #7
 810da52:	701a      	strb	r2, [r3, #0]
      else
      {
        USBD_CtlError(pdev, req);
        err++;
      }
      break;
 810da54:	e00f      	b.n	810da76 <USBD_GetDescriptor+0x2da>
        USBD_CtlError(pdev, req);
 810da56:	6839      	ldr	r1, [r7, #0]
 810da58:	6878      	ldr	r0, [r7, #4]
 810da5a:	f000 fa10 	bl	810de7e <USBD_CtlError>
        err++;
 810da5e:	7afb      	ldrb	r3, [r7, #11]
 810da60:	3301      	adds	r3, #1
 810da62:	72fb      	strb	r3, [r7, #11]
      break;
 810da64:	e007      	b.n	810da76 <USBD_GetDescriptor+0x2da>

    default:
      USBD_CtlError(pdev, req);
 810da66:	6839      	ldr	r1, [r7, #0]
 810da68:	6878      	ldr	r0, [r7, #4]
 810da6a:	f000 fa08 	bl	810de7e <USBD_CtlError>
      err++;
 810da6e:	7afb      	ldrb	r3, [r7, #11]
 810da70:	3301      	adds	r3, #1
 810da72:	72fb      	strb	r3, [r7, #11]
      break;
 810da74:	bf00      	nop
  }

  if (err != 0U)
 810da76:	7afb      	ldrb	r3, [r7, #11]
 810da78:	2b00      	cmp	r3, #0
 810da7a:	d11e      	bne.n	810daba <USBD_GetDescriptor+0x31e>
  {
    return;
  }

  if (req->wLength != 0U)
 810da7c:	683b      	ldr	r3, [r7, #0]
 810da7e:	88db      	ldrh	r3, [r3, #6]
 810da80:	2b00      	cmp	r3, #0
 810da82:	d016      	beq.n	810dab2 <USBD_GetDescriptor+0x316>
  {
    if (len != 0U)
 810da84:	893b      	ldrh	r3, [r7, #8]
 810da86:	2b00      	cmp	r3, #0
 810da88:	d00e      	beq.n	810daa8 <USBD_GetDescriptor+0x30c>
    {
      len = MIN(len, req->wLength);
 810da8a:	683b      	ldr	r3, [r7, #0]
 810da8c:	88da      	ldrh	r2, [r3, #6]
 810da8e:	893b      	ldrh	r3, [r7, #8]
 810da90:	4293      	cmp	r3, r2
 810da92:	bf28      	it	cs
 810da94:	4613      	movcs	r3, r2
 810da96:	b29b      	uxth	r3, r3
 810da98:	813b      	strh	r3, [r7, #8]
      (void)USBD_CtlSendData(pdev, pbuf, len);
 810da9a:	893b      	ldrh	r3, [r7, #8]
 810da9c:	461a      	mov	r2, r3
 810da9e:	68f9      	ldr	r1, [r7, #12]
 810daa0:	6878      	ldr	r0, [r7, #4]
 810daa2:	f000 fc93 	bl	810e3cc <USBD_CtlSendData>
 810daa6:	e009      	b.n	810dabc <USBD_GetDescriptor+0x320>
    }
    else
    {
      USBD_CtlError(pdev, req);
 810daa8:	6839      	ldr	r1, [r7, #0]
 810daaa:	6878      	ldr	r0, [r7, #4]
 810daac:	f000 f9e7 	bl	810de7e <USBD_CtlError>
 810dab0:	e004      	b.n	810dabc <USBD_GetDescriptor+0x320>
    }
  }
  else
  {
    (void)USBD_CtlSendStatus(pdev);
 810dab2:	6878      	ldr	r0, [r7, #4]
 810dab4:	f000 fcc7 	bl	810e446 <USBD_CtlSendStatus>
 810dab8:	e000      	b.n	810dabc <USBD_GetDescriptor+0x320>
    return;
 810daba:	bf00      	nop
  }
}
 810dabc:	3710      	adds	r7, #16
 810dabe:	46bd      	mov	sp, r7
 810dac0:	bd80      	pop	{r7, pc}
 810dac2:	bf00      	nop

0810dac4 <USBD_SetAddress>:
  * @param  pdev: device instance
  * @param  req: usb request
  * @retval None
  */
static void USBD_SetAddress(USBD_HandleTypeDef *pdev, USBD_SetupReqTypedef *req)
{
 810dac4:	b580      	push	{r7, lr}
 810dac6:	b084      	sub	sp, #16
 810dac8:	af00      	add	r7, sp, #0
 810daca:	6078      	str	r0, [r7, #4]
 810dacc:	6039      	str	r1, [r7, #0]
  uint8_t  dev_addr;

  if ((req->wIndex == 0U) && (req->wLength == 0U) && (req->wValue < 128U))
 810dace:	683b      	ldr	r3, [r7, #0]
 810dad0:	889b      	ldrh	r3, [r3, #4]
 810dad2:	2b00      	cmp	r3, #0
 810dad4:	d131      	bne.n	810db3a <USBD_SetAddress+0x76>
 810dad6:	683b      	ldr	r3, [r7, #0]
 810dad8:	88db      	ldrh	r3, [r3, #6]
 810dada:	2b00      	cmp	r3, #0
 810dadc:	d12d      	bne.n	810db3a <USBD_SetAddress+0x76>
 810dade:	683b      	ldr	r3, [r7, #0]
 810dae0:	885b      	ldrh	r3, [r3, #2]
 810dae2:	2b7f      	cmp	r3, #127	; 0x7f
 810dae4:	d829      	bhi.n	810db3a <USBD_SetAddress+0x76>
  {
    dev_addr = (uint8_t)(req->wValue) & 0x7FU;
 810dae6:	683b      	ldr	r3, [r7, #0]
 810dae8:	885b      	ldrh	r3, [r3, #2]
 810daea:	b2db      	uxtb	r3, r3
 810daec:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 810daf0:	73fb      	strb	r3, [r7, #15]

    if (pdev->dev_state == USBD_STATE_CONFIGURED)
 810daf2:	687b      	ldr	r3, [r7, #4]
 810daf4:	f893 329c 	ldrb.w	r3, [r3, #668]	; 0x29c
 810daf8:	b2db      	uxtb	r3, r3
 810dafa:	2b03      	cmp	r3, #3
 810dafc:	d104      	bne.n	810db08 <USBD_SetAddress+0x44>
    {
      USBD_CtlError(pdev, req);
 810dafe:	6839      	ldr	r1, [r7, #0]
 810db00:	6878      	ldr	r0, [r7, #4]
 810db02:	f000 f9bc 	bl	810de7e <USBD_CtlError>
    if (pdev->dev_state == USBD_STATE_CONFIGURED)
 810db06:	e01d      	b.n	810db44 <USBD_SetAddress+0x80>
    }
    else
    {
      pdev->dev_address = dev_addr;
 810db08:	687b      	ldr	r3, [r7, #4]
 810db0a:	7bfa      	ldrb	r2, [r7, #15]
 810db0c:	f883 229e 	strb.w	r2, [r3, #670]	; 0x29e
      (void)USBD_LL_SetUSBAddress(pdev, dev_addr);
 810db10:	7bfb      	ldrb	r3, [r7, #15]
 810db12:	4619      	mov	r1, r3
 810db14:	6878      	ldr	r0, [r7, #4]
 810db16:	f00d fcdf 	bl	811b4d8 <USBD_LL_SetUSBAddress>
      (void)USBD_CtlSendStatus(pdev);
 810db1a:	6878      	ldr	r0, [r7, #4]
 810db1c:	f000 fc93 	bl	810e446 <USBD_CtlSendStatus>

      if (dev_addr != 0U)
 810db20:	7bfb      	ldrb	r3, [r7, #15]
 810db22:	2b00      	cmp	r3, #0
 810db24:	d004      	beq.n	810db30 <USBD_SetAddress+0x6c>
      {
        pdev->dev_state = USBD_STATE_ADDRESSED;
 810db26:	687b      	ldr	r3, [r7, #4]
 810db28:	2202      	movs	r2, #2
 810db2a:	f883 229c 	strb.w	r2, [r3, #668]	; 0x29c
    if (pdev->dev_state == USBD_STATE_CONFIGURED)
 810db2e:	e009      	b.n	810db44 <USBD_SetAddress+0x80>
      }
      else
      {
        pdev->dev_state = USBD_STATE_DEFAULT;
 810db30:	687b      	ldr	r3, [r7, #4]
 810db32:	2201      	movs	r2, #1
 810db34:	f883 229c 	strb.w	r2, [r3, #668]	; 0x29c
    if (pdev->dev_state == USBD_STATE_CONFIGURED)
 810db38:	e004      	b.n	810db44 <USBD_SetAddress+0x80>
      }
    }
  }
  else
  {
    USBD_CtlError(pdev, req);
 810db3a:	6839      	ldr	r1, [r7, #0]
 810db3c:	6878      	ldr	r0, [r7, #4]
 810db3e:	f000 f99e 	bl	810de7e <USBD_CtlError>
  }
}
 810db42:	bf00      	nop
 810db44:	bf00      	nop
 810db46:	3710      	adds	r7, #16
 810db48:	46bd      	mov	sp, r7
 810db4a:	bd80      	pop	{r7, pc}

0810db4c <USBD_SetConfig>:
  * @param  pdev: device instance
  * @param  req: usb request
  * @retval status
  */
static USBD_StatusTypeDef USBD_SetConfig(USBD_HandleTypeDef *pdev, USBD_SetupReqTypedef *req)
{
 810db4c:	b580      	push	{r7, lr}
 810db4e:	b084      	sub	sp, #16
 810db50:	af00      	add	r7, sp, #0
 810db52:	6078      	str	r0, [r7, #4]
 810db54:	6039      	str	r1, [r7, #0]
  USBD_StatusTypeDef ret = USBD_OK;
 810db56:	2300      	movs	r3, #0
 810db58:	73fb      	strb	r3, [r7, #15]
  static uint8_t cfgidx;

  cfgidx = (uint8_t)(req->wValue);
 810db5a:	683b      	ldr	r3, [r7, #0]
 810db5c:	885b      	ldrh	r3, [r3, #2]
 810db5e:	b2da      	uxtb	r2, r3
 810db60:	4b4e      	ldr	r3, [pc, #312]	; (810dc9c <USBD_SetConfig+0x150>)
 810db62:	701a      	strb	r2, [r3, #0]

  if (cfgidx > USBD_MAX_NUM_CONFIGURATION)
 810db64:	4b4d      	ldr	r3, [pc, #308]	; (810dc9c <USBD_SetConfig+0x150>)
 810db66:	781b      	ldrb	r3, [r3, #0]
 810db68:	2b01      	cmp	r3, #1
 810db6a:	d905      	bls.n	810db78 <USBD_SetConfig+0x2c>
  {
    USBD_CtlError(pdev, req);
 810db6c:	6839      	ldr	r1, [r7, #0]
 810db6e:	6878      	ldr	r0, [r7, #4]
 810db70:	f000 f985 	bl	810de7e <USBD_CtlError>
    return USBD_FAIL;
 810db74:	2303      	movs	r3, #3
 810db76:	e08c      	b.n	810dc92 <USBD_SetConfig+0x146>
  }

  switch (pdev->dev_state)
 810db78:	687b      	ldr	r3, [r7, #4]
 810db7a:	f893 329c 	ldrb.w	r3, [r3, #668]	; 0x29c
 810db7e:	b2db      	uxtb	r3, r3
 810db80:	2b02      	cmp	r3, #2
 810db82:	d002      	beq.n	810db8a <USBD_SetConfig+0x3e>
 810db84:	2b03      	cmp	r3, #3
 810db86:	d029      	beq.n	810dbdc <USBD_SetConfig+0x90>
 810db88:	e075      	b.n	810dc76 <USBD_SetConfig+0x12a>
  {
    case USBD_STATE_ADDRESSED:
      if (cfgidx != 0U)
 810db8a:	4b44      	ldr	r3, [pc, #272]	; (810dc9c <USBD_SetConfig+0x150>)
 810db8c:	781b      	ldrb	r3, [r3, #0]
 810db8e:	2b00      	cmp	r3, #0
 810db90:	d020      	beq.n	810dbd4 <USBD_SetConfig+0x88>
      {
        pdev->dev_config = cfgidx;
 810db92:	4b42      	ldr	r3, [pc, #264]	; (810dc9c <USBD_SetConfig+0x150>)
 810db94:	781b      	ldrb	r3, [r3, #0]
 810db96:	461a      	mov	r2, r3
 810db98:	687b      	ldr	r3, [r7, #4]
 810db9a:	605a      	str	r2, [r3, #4]

        ret = USBD_SetClassConfig(pdev, cfgidx);
 810db9c:	4b3f      	ldr	r3, [pc, #252]	; (810dc9c <USBD_SetConfig+0x150>)
 810db9e:	781b      	ldrb	r3, [r3, #0]
 810dba0:	4619      	mov	r1, r3
 810dba2:	6878      	ldr	r0, [r7, #4]
 810dba4:	f7fe ffb7 	bl	810cb16 <USBD_SetClassConfig>
 810dba8:	4603      	mov	r3, r0
 810dbaa:	73fb      	strb	r3, [r7, #15]

        if (ret != USBD_OK)
 810dbac:	7bfb      	ldrb	r3, [r7, #15]
 810dbae:	2b00      	cmp	r3, #0
 810dbb0:	d008      	beq.n	810dbc4 <USBD_SetConfig+0x78>
        {
          USBD_CtlError(pdev, req);
 810dbb2:	6839      	ldr	r1, [r7, #0]
 810dbb4:	6878      	ldr	r0, [r7, #4]
 810dbb6:	f000 f962 	bl	810de7e <USBD_CtlError>
          pdev->dev_state = USBD_STATE_ADDRESSED;
 810dbba:	687b      	ldr	r3, [r7, #4]
 810dbbc:	2202      	movs	r2, #2
 810dbbe:	f883 229c 	strb.w	r2, [r3, #668]	; 0x29c
      }
      else
      {
        (void)USBD_CtlSendStatus(pdev);
      }
      break;
 810dbc2:	e065      	b.n	810dc90 <USBD_SetConfig+0x144>
          (void)USBD_CtlSendStatus(pdev);
 810dbc4:	6878      	ldr	r0, [r7, #4]
 810dbc6:	f000 fc3e 	bl	810e446 <USBD_CtlSendStatus>
          pdev->dev_state = USBD_STATE_CONFIGURED;
 810dbca:	687b      	ldr	r3, [r7, #4]
 810dbcc:	2203      	movs	r2, #3
 810dbce:	f883 229c 	strb.w	r2, [r3, #668]	; 0x29c
      break;
 810dbd2:	e05d      	b.n	810dc90 <USBD_SetConfig+0x144>
        (void)USBD_CtlSendStatus(pdev);
 810dbd4:	6878      	ldr	r0, [r7, #4]
 810dbd6:	f000 fc36 	bl	810e446 <USBD_CtlSendStatus>
      break;
 810dbda:	e059      	b.n	810dc90 <USBD_SetConfig+0x144>

    case USBD_STATE_CONFIGURED:
      if (cfgidx == 0U)
 810dbdc:	4b2f      	ldr	r3, [pc, #188]	; (810dc9c <USBD_SetConfig+0x150>)
 810dbde:	781b      	ldrb	r3, [r3, #0]
 810dbe0:	2b00      	cmp	r3, #0
 810dbe2:	d112      	bne.n	810dc0a <USBD_SetConfig+0xbe>
      {
        pdev->dev_state = USBD_STATE_ADDRESSED;
 810dbe4:	687b      	ldr	r3, [r7, #4]
 810dbe6:	2202      	movs	r2, #2
 810dbe8:	f883 229c 	strb.w	r2, [r3, #668]	; 0x29c
        pdev->dev_config = cfgidx;
 810dbec:	4b2b      	ldr	r3, [pc, #172]	; (810dc9c <USBD_SetConfig+0x150>)
 810dbee:	781b      	ldrb	r3, [r3, #0]
 810dbf0:	461a      	mov	r2, r3
 810dbf2:	687b      	ldr	r3, [r7, #4]
 810dbf4:	605a      	str	r2, [r3, #4]
        (void)USBD_ClrClassConfig(pdev, cfgidx);
 810dbf6:	4b29      	ldr	r3, [pc, #164]	; (810dc9c <USBD_SetConfig+0x150>)
 810dbf8:	781b      	ldrb	r3, [r3, #0]
 810dbfa:	4619      	mov	r1, r3
 810dbfc:	6878      	ldr	r0, [r7, #4]
 810dbfe:	f7fe ffa6 	bl	810cb4e <USBD_ClrClassConfig>
        (void)USBD_CtlSendStatus(pdev);
 810dc02:	6878      	ldr	r0, [r7, #4]
 810dc04:	f000 fc1f 	bl	810e446 <USBD_CtlSendStatus>
      }
      else
      {
        (void)USBD_CtlSendStatus(pdev);
      }
      break;
 810dc08:	e042      	b.n	810dc90 <USBD_SetConfig+0x144>
      else if (cfgidx != pdev->dev_config)
 810dc0a:	4b24      	ldr	r3, [pc, #144]	; (810dc9c <USBD_SetConfig+0x150>)
 810dc0c:	781b      	ldrb	r3, [r3, #0]
 810dc0e:	461a      	mov	r2, r3
 810dc10:	687b      	ldr	r3, [r7, #4]
 810dc12:	685b      	ldr	r3, [r3, #4]
 810dc14:	429a      	cmp	r2, r3
 810dc16:	d02a      	beq.n	810dc6e <USBD_SetConfig+0x122>
        (void)USBD_ClrClassConfig(pdev, (uint8_t)pdev->dev_config);
 810dc18:	687b      	ldr	r3, [r7, #4]
 810dc1a:	685b      	ldr	r3, [r3, #4]
 810dc1c:	b2db      	uxtb	r3, r3
 810dc1e:	4619      	mov	r1, r3
 810dc20:	6878      	ldr	r0, [r7, #4]
 810dc22:	f7fe ff94 	bl	810cb4e <USBD_ClrClassConfig>
        pdev->dev_config = cfgidx;
 810dc26:	4b1d      	ldr	r3, [pc, #116]	; (810dc9c <USBD_SetConfig+0x150>)
 810dc28:	781b      	ldrb	r3, [r3, #0]
 810dc2a:	461a      	mov	r2, r3
 810dc2c:	687b      	ldr	r3, [r7, #4]
 810dc2e:	605a      	str	r2, [r3, #4]
        ret = USBD_SetClassConfig(pdev, cfgidx);
 810dc30:	4b1a      	ldr	r3, [pc, #104]	; (810dc9c <USBD_SetConfig+0x150>)
 810dc32:	781b      	ldrb	r3, [r3, #0]
 810dc34:	4619      	mov	r1, r3
 810dc36:	6878      	ldr	r0, [r7, #4]
 810dc38:	f7fe ff6d 	bl	810cb16 <USBD_SetClassConfig>
 810dc3c:	4603      	mov	r3, r0
 810dc3e:	73fb      	strb	r3, [r7, #15]
        if (ret != USBD_OK)
 810dc40:	7bfb      	ldrb	r3, [r7, #15]
 810dc42:	2b00      	cmp	r3, #0
 810dc44:	d00f      	beq.n	810dc66 <USBD_SetConfig+0x11a>
          USBD_CtlError(pdev, req);
 810dc46:	6839      	ldr	r1, [r7, #0]
 810dc48:	6878      	ldr	r0, [r7, #4]
 810dc4a:	f000 f918 	bl	810de7e <USBD_CtlError>
          (void)USBD_ClrClassConfig(pdev, (uint8_t)pdev->dev_config);
 810dc4e:	687b      	ldr	r3, [r7, #4]
 810dc50:	685b      	ldr	r3, [r3, #4]
 810dc52:	b2db      	uxtb	r3, r3
 810dc54:	4619      	mov	r1, r3
 810dc56:	6878      	ldr	r0, [r7, #4]
 810dc58:	f7fe ff79 	bl	810cb4e <USBD_ClrClassConfig>
          pdev->dev_state = USBD_STATE_ADDRESSED;
 810dc5c:	687b      	ldr	r3, [r7, #4]
 810dc5e:	2202      	movs	r2, #2
 810dc60:	f883 229c 	strb.w	r2, [r3, #668]	; 0x29c
      break;
 810dc64:	e014      	b.n	810dc90 <USBD_SetConfig+0x144>
          (void)USBD_CtlSendStatus(pdev);
 810dc66:	6878      	ldr	r0, [r7, #4]
 810dc68:	f000 fbed 	bl	810e446 <USBD_CtlSendStatus>
      break;
 810dc6c:	e010      	b.n	810dc90 <USBD_SetConfig+0x144>
        (void)USBD_CtlSendStatus(pdev);
 810dc6e:	6878      	ldr	r0, [r7, #4]
 810dc70:	f000 fbe9 	bl	810e446 <USBD_CtlSendStatus>
      break;
 810dc74:	e00c      	b.n	810dc90 <USBD_SetConfig+0x144>

    default:
      USBD_CtlError(pdev, req);
 810dc76:	6839      	ldr	r1, [r7, #0]
 810dc78:	6878      	ldr	r0, [r7, #4]
 810dc7a:	f000 f900 	bl	810de7e <USBD_CtlError>
      (void)USBD_ClrClassConfig(pdev, cfgidx);
 810dc7e:	4b07      	ldr	r3, [pc, #28]	; (810dc9c <USBD_SetConfig+0x150>)
 810dc80:	781b      	ldrb	r3, [r3, #0]
 810dc82:	4619      	mov	r1, r3
 810dc84:	6878      	ldr	r0, [r7, #4]
 810dc86:	f7fe ff62 	bl	810cb4e <USBD_ClrClassConfig>
      ret = USBD_FAIL;
 810dc8a:	2303      	movs	r3, #3
 810dc8c:	73fb      	strb	r3, [r7, #15]
      break;
 810dc8e:	bf00      	nop
  }

  return ret;
 810dc90:	7bfb      	ldrb	r3, [r7, #15]
}
 810dc92:	4618      	mov	r0, r3
 810dc94:	3710      	adds	r7, #16
 810dc96:	46bd      	mov	sp, r7
 810dc98:	bd80      	pop	{r7, pc}
 810dc9a:	bf00      	nop
 810dc9c:	10004f30 	.word	0x10004f30

0810dca0 <USBD_GetConfig>:
  * @param  pdev: device instance
  * @param  req: usb request
  * @retval None
  */
static void USBD_GetConfig(USBD_HandleTypeDef *pdev, USBD_SetupReqTypedef *req)
{
 810dca0:	b580      	push	{r7, lr}
 810dca2:	b082      	sub	sp, #8
 810dca4:	af00      	add	r7, sp, #0
 810dca6:	6078      	str	r0, [r7, #4]
 810dca8:	6039      	str	r1, [r7, #0]
  if (req->wLength != 1U)
 810dcaa:	683b      	ldr	r3, [r7, #0]
 810dcac:	88db      	ldrh	r3, [r3, #6]
 810dcae:	2b01      	cmp	r3, #1
 810dcb0:	d004      	beq.n	810dcbc <USBD_GetConfig+0x1c>
  {
    USBD_CtlError(pdev, req);
 810dcb2:	6839      	ldr	r1, [r7, #0]
 810dcb4:	6878      	ldr	r0, [r7, #4]
 810dcb6:	f000 f8e2 	bl	810de7e <USBD_CtlError>
      default:
        USBD_CtlError(pdev, req);
        break;
    }
  }
}
 810dcba:	e023      	b.n	810dd04 <USBD_GetConfig+0x64>
    switch (pdev->dev_state)
 810dcbc:	687b      	ldr	r3, [r7, #4]
 810dcbe:	f893 329c 	ldrb.w	r3, [r3, #668]	; 0x29c
 810dcc2:	b2db      	uxtb	r3, r3
 810dcc4:	2b02      	cmp	r3, #2
 810dcc6:	dc02      	bgt.n	810dcce <USBD_GetConfig+0x2e>
 810dcc8:	2b00      	cmp	r3, #0
 810dcca:	dc03      	bgt.n	810dcd4 <USBD_GetConfig+0x34>
 810dccc:	e015      	b.n	810dcfa <USBD_GetConfig+0x5a>
 810dcce:	2b03      	cmp	r3, #3
 810dcd0:	d00b      	beq.n	810dcea <USBD_GetConfig+0x4a>
 810dcd2:	e012      	b.n	810dcfa <USBD_GetConfig+0x5a>
        pdev->dev_default_config = 0U;
 810dcd4:	687b      	ldr	r3, [r7, #4]
 810dcd6:	2200      	movs	r2, #0
 810dcd8:	609a      	str	r2, [r3, #8]
        (void)USBD_CtlSendData(pdev, (uint8_t *)&pdev->dev_default_config, 1U);
 810dcda:	687b      	ldr	r3, [r7, #4]
 810dcdc:	3308      	adds	r3, #8
 810dcde:	2201      	movs	r2, #1
 810dce0:	4619      	mov	r1, r3
 810dce2:	6878      	ldr	r0, [r7, #4]
 810dce4:	f000 fb72 	bl	810e3cc <USBD_CtlSendData>
        break;
 810dce8:	e00c      	b.n	810dd04 <USBD_GetConfig+0x64>
        (void)USBD_CtlSendData(pdev, (uint8_t *)&pdev->dev_config, 1U);
 810dcea:	687b      	ldr	r3, [r7, #4]
 810dcec:	3304      	adds	r3, #4
 810dcee:	2201      	movs	r2, #1
 810dcf0:	4619      	mov	r1, r3
 810dcf2:	6878      	ldr	r0, [r7, #4]
 810dcf4:	f000 fb6a 	bl	810e3cc <USBD_CtlSendData>
        break;
 810dcf8:	e004      	b.n	810dd04 <USBD_GetConfig+0x64>
        USBD_CtlError(pdev, req);
 810dcfa:	6839      	ldr	r1, [r7, #0]
 810dcfc:	6878      	ldr	r0, [r7, #4]
 810dcfe:	f000 f8be 	bl	810de7e <USBD_CtlError>
        break;
 810dd02:	bf00      	nop
}
 810dd04:	bf00      	nop
 810dd06:	3708      	adds	r7, #8
 810dd08:	46bd      	mov	sp, r7
 810dd0a:	bd80      	pop	{r7, pc}

0810dd0c <USBD_GetStatus>:
  * @param  pdev: device instance
  * @param  req: usb request
  * @retval None
  */
static void USBD_GetStatus(USBD_HandleTypeDef *pdev, USBD_SetupReqTypedef *req)
{
 810dd0c:	b580      	push	{r7, lr}
 810dd0e:	b082      	sub	sp, #8
 810dd10:	af00      	add	r7, sp, #0
 810dd12:	6078      	str	r0, [r7, #4]
 810dd14:	6039      	str	r1, [r7, #0]
  switch (pdev->dev_state)
 810dd16:	687b      	ldr	r3, [r7, #4]
 810dd18:	f893 329c 	ldrb.w	r3, [r3, #668]	; 0x29c
 810dd1c:	b2db      	uxtb	r3, r3
 810dd1e:	3b01      	subs	r3, #1
 810dd20:	2b02      	cmp	r3, #2
 810dd22:	d81e      	bhi.n	810dd62 <USBD_GetStatus+0x56>
  {
    case USBD_STATE_DEFAULT:
    case USBD_STATE_ADDRESSED:
    case USBD_STATE_CONFIGURED:
      if (req->wLength != 0x2U)
 810dd24:	683b      	ldr	r3, [r7, #0]
 810dd26:	88db      	ldrh	r3, [r3, #6]
 810dd28:	2b02      	cmp	r3, #2
 810dd2a:	d004      	beq.n	810dd36 <USBD_GetStatus+0x2a>
      {
        USBD_CtlError(pdev, req);
 810dd2c:	6839      	ldr	r1, [r7, #0]
 810dd2e:	6878      	ldr	r0, [r7, #4]
 810dd30:	f000 f8a5 	bl	810de7e <USBD_CtlError>
        break;
 810dd34:	e01a      	b.n	810dd6c <USBD_GetStatus+0x60>
      }

#if (USBD_SELF_POWERED == 1U)
      pdev->dev_config_status = USB_CONFIG_SELF_POWERED;
#else
      pdev->dev_config_status = 0U;
 810dd36:	687b      	ldr	r3, [r7, #4]
 810dd38:	2200      	movs	r2, #0
 810dd3a:	60da      	str	r2, [r3, #12]
#endif /* USBD_SELF_POWERED */

      if (pdev->dev_remote_wakeup != 0U)
 810dd3c:	687b      	ldr	r3, [r7, #4]
 810dd3e:	f8d3 32a4 	ldr.w	r3, [r3, #676]	; 0x2a4
 810dd42:	2b00      	cmp	r3, #0
 810dd44:	d005      	beq.n	810dd52 <USBD_GetStatus+0x46>
      {
        pdev->dev_config_status |= USB_CONFIG_REMOTE_WAKEUP;
 810dd46:	687b      	ldr	r3, [r7, #4]
 810dd48:	68db      	ldr	r3, [r3, #12]
 810dd4a:	f043 0202 	orr.w	r2, r3, #2
 810dd4e:	687b      	ldr	r3, [r7, #4]
 810dd50:	60da      	str	r2, [r3, #12]
      }

      (void)USBD_CtlSendData(pdev, (uint8_t *)&pdev->dev_config_status, 2U);
 810dd52:	687b      	ldr	r3, [r7, #4]
 810dd54:	330c      	adds	r3, #12
 810dd56:	2202      	movs	r2, #2
 810dd58:	4619      	mov	r1, r3
 810dd5a:	6878      	ldr	r0, [r7, #4]
 810dd5c:	f000 fb36 	bl	810e3cc <USBD_CtlSendData>
      break;
 810dd60:	e004      	b.n	810dd6c <USBD_GetStatus+0x60>

    default:
      USBD_CtlError(pdev, req);
 810dd62:	6839      	ldr	r1, [r7, #0]
 810dd64:	6878      	ldr	r0, [r7, #4]
 810dd66:	f000 f88a 	bl	810de7e <USBD_CtlError>
      break;
 810dd6a:	bf00      	nop
  }
}
 810dd6c:	bf00      	nop
 810dd6e:	3708      	adds	r7, #8
 810dd70:	46bd      	mov	sp, r7
 810dd72:	bd80      	pop	{r7, pc}

0810dd74 <USBD_SetFeature>:
  * @param  pdev: device instance
  * @param  req: usb request
  * @retval None
  */
static void USBD_SetFeature(USBD_HandleTypeDef *pdev, USBD_SetupReqTypedef *req)
{
 810dd74:	b580      	push	{r7, lr}
 810dd76:	b082      	sub	sp, #8
 810dd78:	af00      	add	r7, sp, #0
 810dd7a:	6078      	str	r0, [r7, #4]
 810dd7c:	6039      	str	r1, [r7, #0]
  if (req->wValue == USB_FEATURE_REMOTE_WAKEUP)
 810dd7e:	683b      	ldr	r3, [r7, #0]
 810dd80:	885b      	ldrh	r3, [r3, #2]
 810dd82:	2b01      	cmp	r3, #1
 810dd84:	d107      	bne.n	810dd96 <USBD_SetFeature+0x22>
  {
    pdev->dev_remote_wakeup = 1U;
 810dd86:	687b      	ldr	r3, [r7, #4]
 810dd88:	2201      	movs	r2, #1
 810dd8a:	f8c3 22a4 	str.w	r2, [r3, #676]	; 0x2a4
    (void)USBD_CtlSendStatus(pdev);
 810dd8e:	6878      	ldr	r0, [r7, #4]
 810dd90:	f000 fb59 	bl	810e446 <USBD_CtlSendStatus>
  }
  else
  {
    USBD_CtlError(pdev, req);
  }
}
 810dd94:	e013      	b.n	810ddbe <USBD_SetFeature+0x4a>
  else if (req->wValue == USB_FEATURE_TEST_MODE)
 810dd96:	683b      	ldr	r3, [r7, #0]
 810dd98:	885b      	ldrh	r3, [r3, #2]
 810dd9a:	2b02      	cmp	r3, #2
 810dd9c:	d10b      	bne.n	810ddb6 <USBD_SetFeature+0x42>
    pdev->dev_test_mode = (uint8_t)(req->wIndex >> 8);
 810dd9e:	683b      	ldr	r3, [r7, #0]
 810dda0:	889b      	ldrh	r3, [r3, #4]
 810dda2:	0a1b      	lsrs	r3, r3, #8
 810dda4:	b29b      	uxth	r3, r3
 810dda6:	b2da      	uxtb	r2, r3
 810dda8:	687b      	ldr	r3, [r7, #4]
 810ddaa:	f883 22a0 	strb.w	r2, [r3, #672]	; 0x2a0
    (void)USBD_CtlSendStatus(pdev);
 810ddae:	6878      	ldr	r0, [r7, #4]
 810ddb0:	f000 fb49 	bl	810e446 <USBD_CtlSendStatus>
}
 810ddb4:	e003      	b.n	810ddbe <USBD_SetFeature+0x4a>
    USBD_CtlError(pdev, req);
 810ddb6:	6839      	ldr	r1, [r7, #0]
 810ddb8:	6878      	ldr	r0, [r7, #4]
 810ddba:	f000 f860 	bl	810de7e <USBD_CtlError>
}
 810ddbe:	bf00      	nop
 810ddc0:	3708      	adds	r7, #8
 810ddc2:	46bd      	mov	sp, r7
 810ddc4:	bd80      	pop	{r7, pc}

0810ddc6 <USBD_ClrFeature>:
  * @param  pdev: device instance
  * @param  req: usb request
  * @retval None
  */
static void USBD_ClrFeature(USBD_HandleTypeDef *pdev, USBD_SetupReqTypedef *req)
{
 810ddc6:	b580      	push	{r7, lr}
 810ddc8:	b082      	sub	sp, #8
 810ddca:	af00      	add	r7, sp, #0
 810ddcc:	6078      	str	r0, [r7, #4]
 810ddce:	6039      	str	r1, [r7, #0]
  switch (pdev->dev_state)
 810ddd0:	687b      	ldr	r3, [r7, #4]
 810ddd2:	f893 329c 	ldrb.w	r3, [r3, #668]	; 0x29c
 810ddd6:	b2db      	uxtb	r3, r3
 810ddd8:	3b01      	subs	r3, #1
 810ddda:	2b02      	cmp	r3, #2
 810dddc:	d80b      	bhi.n	810ddf6 <USBD_ClrFeature+0x30>
  {
    case USBD_STATE_DEFAULT:
    case USBD_STATE_ADDRESSED:
    case USBD_STATE_CONFIGURED:
      if (req->wValue == USB_FEATURE_REMOTE_WAKEUP)
 810ddde:	683b      	ldr	r3, [r7, #0]
 810dde0:	885b      	ldrh	r3, [r3, #2]
 810dde2:	2b01      	cmp	r3, #1
 810dde4:	d10c      	bne.n	810de00 <USBD_ClrFeature+0x3a>
      {
        pdev->dev_remote_wakeup = 0U;
 810dde6:	687b      	ldr	r3, [r7, #4]
 810dde8:	2200      	movs	r2, #0
 810ddea:	f8c3 22a4 	str.w	r2, [r3, #676]	; 0x2a4
        (void)USBD_CtlSendStatus(pdev);
 810ddee:	6878      	ldr	r0, [r7, #4]
 810ddf0:	f000 fb29 	bl	810e446 <USBD_CtlSendStatus>
      }
      break;
 810ddf4:	e004      	b.n	810de00 <USBD_ClrFeature+0x3a>

    default:
      USBD_CtlError(pdev, req);
 810ddf6:	6839      	ldr	r1, [r7, #0]
 810ddf8:	6878      	ldr	r0, [r7, #4]
 810ddfa:	f000 f840 	bl	810de7e <USBD_CtlError>
      break;
 810ddfe:	e000      	b.n	810de02 <USBD_ClrFeature+0x3c>
      break;
 810de00:	bf00      	nop
  }
}
 810de02:	bf00      	nop
 810de04:	3708      	adds	r7, #8
 810de06:	46bd      	mov	sp, r7
 810de08:	bd80      	pop	{r7, pc}

0810de0a <USBD_ParseSetupRequest>:
  * @param  req: usb request
  * @param  pdata: setup data pointer
  * @retval None
  */
void USBD_ParseSetupRequest(USBD_SetupReqTypedef *req, uint8_t *pdata)
{
 810de0a:	b580      	push	{r7, lr}
 810de0c:	b084      	sub	sp, #16
 810de0e:	af00      	add	r7, sp, #0
 810de10:	6078      	str	r0, [r7, #4]
 810de12:	6039      	str	r1, [r7, #0]
  uint8_t *pbuff = pdata;
 810de14:	683b      	ldr	r3, [r7, #0]
 810de16:	60fb      	str	r3, [r7, #12]

  req->bmRequest = *(uint8_t *)(pbuff);
 810de18:	68fb      	ldr	r3, [r7, #12]
 810de1a:	781a      	ldrb	r2, [r3, #0]
 810de1c:	687b      	ldr	r3, [r7, #4]
 810de1e:	701a      	strb	r2, [r3, #0]

  pbuff++;
 810de20:	68fb      	ldr	r3, [r7, #12]
 810de22:	3301      	adds	r3, #1
 810de24:	60fb      	str	r3, [r7, #12]
  req->bRequest = *(uint8_t *)(pbuff);
 810de26:	68fb      	ldr	r3, [r7, #12]
 810de28:	781a      	ldrb	r2, [r3, #0]
 810de2a:	687b      	ldr	r3, [r7, #4]
 810de2c:	705a      	strb	r2, [r3, #1]

  pbuff++;
 810de2e:	68fb      	ldr	r3, [r7, #12]
 810de30:	3301      	adds	r3, #1
 810de32:	60fb      	str	r3, [r7, #12]
  req->wValue = SWAPBYTE(pbuff);
 810de34:	68f8      	ldr	r0, [r7, #12]
 810de36:	f7ff fa17 	bl	810d268 <SWAPBYTE>
 810de3a:	4603      	mov	r3, r0
 810de3c:	461a      	mov	r2, r3
 810de3e:	687b      	ldr	r3, [r7, #4]
 810de40:	805a      	strh	r2, [r3, #2]

  pbuff++;
 810de42:	68fb      	ldr	r3, [r7, #12]
 810de44:	3301      	adds	r3, #1
 810de46:	60fb      	str	r3, [r7, #12]
  pbuff++;
 810de48:	68fb      	ldr	r3, [r7, #12]
 810de4a:	3301      	adds	r3, #1
 810de4c:	60fb      	str	r3, [r7, #12]
  req->wIndex = SWAPBYTE(pbuff);
 810de4e:	68f8      	ldr	r0, [r7, #12]
 810de50:	f7ff fa0a 	bl	810d268 <SWAPBYTE>
 810de54:	4603      	mov	r3, r0
 810de56:	461a      	mov	r2, r3
 810de58:	687b      	ldr	r3, [r7, #4]
 810de5a:	809a      	strh	r2, [r3, #4]

  pbuff++;
 810de5c:	68fb      	ldr	r3, [r7, #12]
 810de5e:	3301      	adds	r3, #1
 810de60:	60fb      	str	r3, [r7, #12]
  pbuff++;
 810de62:	68fb      	ldr	r3, [r7, #12]
 810de64:	3301      	adds	r3, #1
 810de66:	60fb      	str	r3, [r7, #12]
  req->wLength = SWAPBYTE(pbuff);
 810de68:	68f8      	ldr	r0, [r7, #12]
 810de6a:	f7ff f9fd 	bl	810d268 <SWAPBYTE>
 810de6e:	4603      	mov	r3, r0
 810de70:	461a      	mov	r2, r3
 810de72:	687b      	ldr	r3, [r7, #4]
 810de74:	80da      	strh	r2, [r3, #6]
}
 810de76:	bf00      	nop
 810de78:	3710      	adds	r7, #16
 810de7a:	46bd      	mov	sp, r7
 810de7c:	bd80      	pop	{r7, pc}

0810de7e <USBD_CtlError>:
  * @param  pdev: device instance
  * @param  req: usb request
  * @retval None
  */
void USBD_CtlError(USBD_HandleTypeDef *pdev, USBD_SetupReqTypedef *req)
{
 810de7e:	b580      	push	{r7, lr}
 810de80:	b082      	sub	sp, #8
 810de82:	af00      	add	r7, sp, #0
 810de84:	6078      	str	r0, [r7, #4]
 810de86:	6039      	str	r1, [r7, #0]
  UNUSED(req);

  (void)USBD_LL_StallEP(pdev, 0x80U);
 810de88:	2180      	movs	r1, #128	; 0x80
 810de8a:	6878      	ldr	r0, [r7, #4]
 810de8c:	f00d faba 	bl	811b404 <USBD_LL_StallEP>
  (void)USBD_LL_StallEP(pdev, 0U);
 810de90:	2100      	movs	r1, #0
 810de92:	6878      	ldr	r0, [r7, #4]
 810de94:	f00d fab6 	bl	811b404 <USBD_LL_StallEP>
}
 810de98:	bf00      	nop
 810de9a:	3708      	adds	r7, #8
 810de9c:	46bd      	mov	sp, r7
 810de9e:	bd80      	pop	{r7, pc}

0810dea0 <USBD_GetString>:
  * @param  unicode : Formatted string buffer (unicode)
  * @param  len : descriptor length
  * @retval None
  */
void USBD_GetString(uint8_t *desc, uint8_t *unicode, uint16_t *len)
{
 810dea0:	b580      	push	{r7, lr}
 810dea2:	b086      	sub	sp, #24
 810dea4:	af00      	add	r7, sp, #0
 810dea6:	60f8      	str	r0, [r7, #12]
 810dea8:	60b9      	str	r1, [r7, #8]
 810deaa:	607a      	str	r2, [r7, #4]
  uint8_t idx = 0U;
 810deac:	2300      	movs	r3, #0
 810deae:	75fb      	strb	r3, [r7, #23]
  uint8_t *pdesc;

  if (desc == NULL)
 810deb0:	68fb      	ldr	r3, [r7, #12]
 810deb2:	2b00      	cmp	r3, #0
 810deb4:	d042      	beq.n	810df3c <USBD_GetString+0x9c>
  {
    return;
  }

  pdesc = desc;
 810deb6:	68fb      	ldr	r3, [r7, #12]
 810deb8:	613b      	str	r3, [r7, #16]
  *len = MIN(USBD_MAX_STR_DESC_SIZ, ((uint16_t)USBD_GetLen(pdesc) * 2U) + 2U);
 810deba:	6938      	ldr	r0, [r7, #16]
 810debc:	f000 f842 	bl	810df44 <USBD_GetLen>
 810dec0:	4603      	mov	r3, r0
 810dec2:	3301      	adds	r3, #1
 810dec4:	005b      	lsls	r3, r3, #1
 810dec6:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 810deca:	d808      	bhi.n	810dede <USBD_GetString+0x3e>
 810decc:	6938      	ldr	r0, [r7, #16]
 810dece:	f000 f839 	bl	810df44 <USBD_GetLen>
 810ded2:	4603      	mov	r3, r0
 810ded4:	3301      	adds	r3, #1
 810ded6:	b29b      	uxth	r3, r3
 810ded8:	005b      	lsls	r3, r3, #1
 810deda:	b29a      	uxth	r2, r3
 810dedc:	e001      	b.n	810dee2 <USBD_GetString+0x42>
 810dede:	f44f 7200 	mov.w	r2, #512	; 0x200
 810dee2:	687b      	ldr	r3, [r7, #4]
 810dee4:	801a      	strh	r2, [r3, #0]

  unicode[idx] = *(uint8_t *)len;
 810dee6:	7dfb      	ldrb	r3, [r7, #23]
 810dee8:	68ba      	ldr	r2, [r7, #8]
 810deea:	4413      	add	r3, r2
 810deec:	687a      	ldr	r2, [r7, #4]
 810deee:	7812      	ldrb	r2, [r2, #0]
 810def0:	701a      	strb	r2, [r3, #0]
  idx++;
 810def2:	7dfb      	ldrb	r3, [r7, #23]
 810def4:	3301      	adds	r3, #1
 810def6:	75fb      	strb	r3, [r7, #23]
  unicode[idx] = USB_DESC_TYPE_STRING;
 810def8:	7dfb      	ldrb	r3, [r7, #23]
 810defa:	68ba      	ldr	r2, [r7, #8]
 810defc:	4413      	add	r3, r2
 810defe:	2203      	movs	r2, #3
 810df00:	701a      	strb	r2, [r3, #0]
  idx++;
 810df02:	7dfb      	ldrb	r3, [r7, #23]
 810df04:	3301      	adds	r3, #1
 810df06:	75fb      	strb	r3, [r7, #23]

  while (*pdesc != (uint8_t)'\0')
 810df08:	e013      	b.n	810df32 <USBD_GetString+0x92>
  {
    unicode[idx] = *pdesc;
 810df0a:	7dfb      	ldrb	r3, [r7, #23]
 810df0c:	68ba      	ldr	r2, [r7, #8]
 810df0e:	4413      	add	r3, r2
 810df10:	693a      	ldr	r2, [r7, #16]
 810df12:	7812      	ldrb	r2, [r2, #0]
 810df14:	701a      	strb	r2, [r3, #0]
    pdesc++;
 810df16:	693b      	ldr	r3, [r7, #16]
 810df18:	3301      	adds	r3, #1
 810df1a:	613b      	str	r3, [r7, #16]
    idx++;
 810df1c:	7dfb      	ldrb	r3, [r7, #23]
 810df1e:	3301      	adds	r3, #1
 810df20:	75fb      	strb	r3, [r7, #23]

    unicode[idx] = 0U;
 810df22:	7dfb      	ldrb	r3, [r7, #23]
 810df24:	68ba      	ldr	r2, [r7, #8]
 810df26:	4413      	add	r3, r2
 810df28:	2200      	movs	r2, #0
 810df2a:	701a      	strb	r2, [r3, #0]
    idx++;
 810df2c:	7dfb      	ldrb	r3, [r7, #23]
 810df2e:	3301      	adds	r3, #1
 810df30:	75fb      	strb	r3, [r7, #23]
  while (*pdesc != (uint8_t)'\0')
 810df32:	693b      	ldr	r3, [r7, #16]
 810df34:	781b      	ldrb	r3, [r3, #0]
 810df36:	2b00      	cmp	r3, #0
 810df38:	d1e7      	bne.n	810df0a <USBD_GetString+0x6a>
 810df3a:	e000      	b.n	810df3e <USBD_GetString+0x9e>
    return;
 810df3c:	bf00      	nop
  }
}
 810df3e:	3718      	adds	r7, #24
 810df40:	46bd      	mov	sp, r7
 810df42:	bd80      	pop	{r7, pc}

0810df44 <USBD_GetLen>:
  *         return the string length
   * @param  buf : pointer to the ascii string buffer
  * @retval string length
  */
static uint8_t USBD_GetLen(uint8_t *buf)
{
 810df44:	b480      	push	{r7}
 810df46:	b085      	sub	sp, #20
 810df48:	af00      	add	r7, sp, #0
 810df4a:	6078      	str	r0, [r7, #4]
  uint8_t  len = 0U;
 810df4c:	2300      	movs	r3, #0
 810df4e:	73fb      	strb	r3, [r7, #15]
  uint8_t *pbuff = buf;
 810df50:	687b      	ldr	r3, [r7, #4]
 810df52:	60bb      	str	r3, [r7, #8]

  while (*pbuff != (uint8_t)'\0')
 810df54:	e005      	b.n	810df62 <USBD_GetLen+0x1e>
  {
    len++;
 810df56:	7bfb      	ldrb	r3, [r7, #15]
 810df58:	3301      	adds	r3, #1
 810df5a:	73fb      	strb	r3, [r7, #15]
    pbuff++;
 810df5c:	68bb      	ldr	r3, [r7, #8]
 810df5e:	3301      	adds	r3, #1
 810df60:	60bb      	str	r3, [r7, #8]
  while (*pbuff != (uint8_t)'\0')
 810df62:	68bb      	ldr	r3, [r7, #8]
 810df64:	781b      	ldrb	r3, [r3, #0]
 810df66:	2b00      	cmp	r3, #0
 810df68:	d1f5      	bne.n	810df56 <USBD_GetLen+0x12>
  }

  return len;
 810df6a:	7bfb      	ldrb	r3, [r7, #15]
}
 810df6c:	4618      	mov	r0, r3
 810df6e:	3714      	adds	r7, #20
 810df70:	46bd      	mov	sp, r7
 810df72:	f85d 7b04 	ldr.w	r7, [sp], #4
 810df76:	4770      	bx	lr

0810df78 <USBD_HID_Init>:
  * @param  pdev: device instance
  * @param  cfgidx: Configuration index
  * @retval status
  */
static uint8_t USBD_HID_Init(USBD_HandleTypeDef *pdev, uint8_t cfgidx)
{
 810df78:	b580      	push	{r7, lr}
 810df7a:	b084      	sub	sp, #16
 810df7c:	af00      	add	r7, sp, #0
 810df7e:	6078      	str	r0, [r7, #4]
 810df80:	460b      	mov	r3, r1
 810df82:	70fb      	strb	r3, [r7, #3]
  UNUSED(cfgidx);

  USBD_HID_HandleTypeDef *hhid;

  hhid = (USBD_HID_HandleTypeDef *)USBD_malloc(sizeof(USBD_HID_HandleTypeDef));
 810df84:	2010      	movs	r0, #16
 810df86:	f00d fb09 	bl	811b59c <USBD_static_malloc>
 810df8a:	60f8      	str	r0, [r7, #12]

  if (hhid == NULL)
 810df8c:	68fb      	ldr	r3, [r7, #12]
 810df8e:	2b00      	cmp	r3, #0
 810df90:	d109      	bne.n	810dfa6 <USBD_HID_Init+0x2e>
  {
    pdev->pClassDataCmsit[pdev->classId] = NULL;
 810df92:	687b      	ldr	r3, [r7, #4]
 810df94:	f8d3 22d4 	ldr.w	r2, [r3, #724]	; 0x2d4
 810df98:	687b      	ldr	r3, [r7, #4]
 810df9a:	32b0      	adds	r2, #176	; 0xb0
 810df9c:	2100      	movs	r1, #0
 810df9e:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
    return (uint8_t)USBD_EMEM;
 810dfa2:	2302      	movs	r3, #2
 810dfa4:	e048      	b.n	810e038 <USBD_HID_Init+0xc0>
  }

  pdev->pClassDataCmsit[pdev->classId] = (void *)hhid;
 810dfa6:	687b      	ldr	r3, [r7, #4]
 810dfa8:	f8d3 22d4 	ldr.w	r2, [r3, #724]	; 0x2d4
 810dfac:	687b      	ldr	r3, [r7, #4]
 810dfae:	32b0      	adds	r2, #176	; 0xb0
 810dfb0:	68f9      	ldr	r1, [r7, #12]
 810dfb2:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
  pdev->pClassData = pdev->pClassDataCmsit[pdev->classId];
 810dfb6:	687b      	ldr	r3, [r7, #4]
 810dfb8:	f8d3 22d4 	ldr.w	r2, [r3, #724]	; 0x2d4
 810dfbc:	687b      	ldr	r3, [r7, #4]
 810dfbe:	32b0      	adds	r2, #176	; 0xb0
 810dfc0:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 810dfc4:	687b      	ldr	r3, [r7, #4]
 810dfc6:	f8c3 22bc 	str.w	r2, [r3, #700]	; 0x2bc
#ifdef USE_USBD_COMPOSITE
  /* Get the Endpoints addresses allocated for this class instance */
  HIDInEpAdd  = USBD_CoreGetEPAdd(pdev, USBD_EP_IN, USBD_EP_TYPE_INTR, (uint8_t)pdev->classId);
#endif /* USE_USBD_COMPOSITE */

  if (pdev->dev_speed == USBD_SPEED_HIGH)
 810dfca:	687b      	ldr	r3, [r7, #4]
 810dfcc:	7c1b      	ldrb	r3, [r3, #16]
 810dfce:	2b00      	cmp	r3, #0
 810dfd0:	d10d      	bne.n	810dfee <USBD_HID_Init+0x76>
  {
    pdev->ep_in[HIDInEpAdd & 0xFU].bInterval = HID_HS_BINTERVAL;
 810dfd2:	4b1b      	ldr	r3, [pc, #108]	; (810e040 <USBD_HID_Init+0xc8>)
 810dfd4:	781b      	ldrb	r3, [r3, #0]
 810dfd6:	f003 020f 	and.w	r2, r3, #15
 810dfda:	6879      	ldr	r1, [r7, #4]
 810dfdc:	4613      	mov	r3, r2
 810dfde:	009b      	lsls	r3, r3, #2
 810dfe0:	4413      	add	r3, r2
 810dfe2:	009b      	lsls	r3, r3, #2
 810dfe4:	440b      	add	r3, r1
 810dfe6:	3326      	adds	r3, #38	; 0x26
 810dfe8:	2207      	movs	r2, #7
 810dfea:	801a      	strh	r2, [r3, #0]
 810dfec:	e00c      	b.n	810e008 <USBD_HID_Init+0x90>
  }
  else   /* LOW and FULL-speed endpoints */
  {
    pdev->ep_in[HIDInEpAdd & 0xFU].bInterval = HID_FS_BINTERVAL;
 810dfee:	4b14      	ldr	r3, [pc, #80]	; (810e040 <USBD_HID_Init+0xc8>)
 810dff0:	781b      	ldrb	r3, [r3, #0]
 810dff2:	f003 020f 	and.w	r2, r3, #15
 810dff6:	6879      	ldr	r1, [r7, #4]
 810dff8:	4613      	mov	r3, r2
 810dffa:	009b      	lsls	r3, r3, #2
 810dffc:	4413      	add	r3, r2
 810dffe:	009b      	lsls	r3, r3, #2
 810e000:	440b      	add	r3, r1
 810e002:	3326      	adds	r3, #38	; 0x26
 810e004:	220a      	movs	r2, #10
 810e006:	801a      	strh	r2, [r3, #0]
  }

  /* Open EP IN */
  (void)USBD_LL_OpenEP(pdev, HIDInEpAdd, USBD_EP_TYPE_INTR, HID_EPIN_SIZE);
 810e008:	4b0d      	ldr	r3, [pc, #52]	; (810e040 <USBD_HID_Init+0xc8>)
 810e00a:	7819      	ldrb	r1, [r3, #0]
 810e00c:	2304      	movs	r3, #4
 810e00e:	2203      	movs	r2, #3
 810e010:	6878      	ldr	r0, [r7, #4]
 810e012:	f00d f9b2 	bl	811b37a <USBD_LL_OpenEP>
  pdev->ep_in[HIDInEpAdd & 0xFU].is_used = 1U;
 810e016:	4b0a      	ldr	r3, [pc, #40]	; (810e040 <USBD_HID_Init+0xc8>)
 810e018:	781b      	ldrb	r3, [r3, #0]
 810e01a:	f003 020f 	and.w	r2, r3, #15
 810e01e:	6879      	ldr	r1, [r7, #4]
 810e020:	4613      	mov	r3, r2
 810e022:	009b      	lsls	r3, r3, #2
 810e024:	4413      	add	r3, r2
 810e026:	009b      	lsls	r3, r3, #2
 810e028:	440b      	add	r3, r1
 810e02a:	3324      	adds	r3, #36	; 0x24
 810e02c:	2201      	movs	r2, #1
 810e02e:	801a      	strh	r2, [r3, #0]

  hhid->state = USBD_HID_IDLE;
 810e030:	68fb      	ldr	r3, [r7, #12]
 810e032:	2200      	movs	r2, #0
 810e034:	731a      	strb	r2, [r3, #12]

  return (uint8_t)USBD_OK;
 810e036:	2300      	movs	r3, #0
}
 810e038:	4618      	mov	r0, r3
 810e03a:	3710      	adds	r7, #16
 810e03c:	46bd      	mov	sp, r7
 810e03e:	bd80      	pop	{r7, pc}
 810e040:	100000fe 	.word	0x100000fe

0810e044 <USBD_HID_DeInit>:
  * @param  pdev: device instance
  * @param  cfgidx: Configuration index
  * @retval status
  */
static uint8_t USBD_HID_DeInit(USBD_HandleTypeDef *pdev, uint8_t cfgidx)
{
 810e044:	b580      	push	{r7, lr}
 810e046:	b082      	sub	sp, #8
 810e048:	af00      	add	r7, sp, #0
 810e04a:	6078      	str	r0, [r7, #4]
 810e04c:	460b      	mov	r3, r1
 810e04e:	70fb      	strb	r3, [r7, #3]
  /* Get the Endpoints addresses allocated for this class instance */
  HIDInEpAdd  = USBD_CoreGetEPAdd(pdev, USBD_EP_IN, USBD_EP_TYPE_INTR, (uint8_t)pdev->classId);
#endif /* USE_USBD_COMPOSITE */

  /* Close HID EPs */
  (void)USBD_LL_CloseEP(pdev, HIDInEpAdd);
 810e050:	4b1f      	ldr	r3, [pc, #124]	; (810e0d0 <USBD_HID_DeInit+0x8c>)
 810e052:	781b      	ldrb	r3, [r3, #0]
 810e054:	4619      	mov	r1, r3
 810e056:	6878      	ldr	r0, [r7, #4]
 810e058:	f00d f9b5 	bl	811b3c6 <USBD_LL_CloseEP>
  pdev->ep_in[HIDInEpAdd & 0xFU].is_used = 0U;
 810e05c:	4b1c      	ldr	r3, [pc, #112]	; (810e0d0 <USBD_HID_DeInit+0x8c>)
 810e05e:	781b      	ldrb	r3, [r3, #0]
 810e060:	f003 020f 	and.w	r2, r3, #15
 810e064:	6879      	ldr	r1, [r7, #4]
 810e066:	4613      	mov	r3, r2
 810e068:	009b      	lsls	r3, r3, #2
 810e06a:	4413      	add	r3, r2
 810e06c:	009b      	lsls	r3, r3, #2
 810e06e:	440b      	add	r3, r1
 810e070:	3324      	adds	r3, #36	; 0x24
 810e072:	2200      	movs	r2, #0
 810e074:	801a      	strh	r2, [r3, #0]
  pdev->ep_in[HIDInEpAdd & 0xFU].bInterval = 0U;
 810e076:	4b16      	ldr	r3, [pc, #88]	; (810e0d0 <USBD_HID_DeInit+0x8c>)
 810e078:	781b      	ldrb	r3, [r3, #0]
 810e07a:	f003 020f 	and.w	r2, r3, #15
 810e07e:	6879      	ldr	r1, [r7, #4]
 810e080:	4613      	mov	r3, r2
 810e082:	009b      	lsls	r3, r3, #2
 810e084:	4413      	add	r3, r2
 810e086:	009b      	lsls	r3, r3, #2
 810e088:	440b      	add	r3, r1
 810e08a:	3326      	adds	r3, #38	; 0x26
 810e08c:	2200      	movs	r2, #0
 810e08e:	801a      	strh	r2, [r3, #0]

  /* Free allocated memory */
  if (pdev->pClassDataCmsit[pdev->classId] != NULL)
 810e090:	687b      	ldr	r3, [r7, #4]
 810e092:	f8d3 22d4 	ldr.w	r2, [r3, #724]	; 0x2d4
 810e096:	687b      	ldr	r3, [r7, #4]
 810e098:	32b0      	adds	r2, #176	; 0xb0
 810e09a:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 810e09e:	2b00      	cmp	r3, #0
 810e0a0:	d011      	beq.n	810e0c6 <USBD_HID_DeInit+0x82>
  {
    (void)USBD_free(pdev->pClassDataCmsit[pdev->classId]);
 810e0a2:	687b      	ldr	r3, [r7, #4]
 810e0a4:	f8d3 22d4 	ldr.w	r2, [r3, #724]	; 0x2d4
 810e0a8:	687b      	ldr	r3, [r7, #4]
 810e0aa:	32b0      	adds	r2, #176	; 0xb0
 810e0ac:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 810e0b0:	4618      	mov	r0, r3
 810e0b2:	f00d fa81 	bl	811b5b8 <USBD_static_free>
    pdev->pClassDataCmsit[pdev->classId] = NULL;
 810e0b6:	687b      	ldr	r3, [r7, #4]
 810e0b8:	f8d3 22d4 	ldr.w	r2, [r3, #724]	; 0x2d4
 810e0bc:	687b      	ldr	r3, [r7, #4]
 810e0be:	32b0      	adds	r2, #176	; 0xb0
 810e0c0:	2100      	movs	r1, #0
 810e0c2:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
  }

  return (uint8_t)USBD_OK;
 810e0c6:	2300      	movs	r3, #0
}
 810e0c8:	4618      	mov	r0, r3
 810e0ca:	3708      	adds	r7, #8
 810e0cc:	46bd      	mov	sp, r7
 810e0ce:	bd80      	pop	{r7, pc}
 810e0d0:	100000fe 	.word	0x100000fe

0810e0d4 <USBD_HID_Setup>:
  * @param  pdev: instance
  * @param  req: usb requests
  * @retval status
  */
static uint8_t USBD_HID_Setup(USBD_HandleTypeDef *pdev, USBD_SetupReqTypedef *req)
{
 810e0d4:	b580      	push	{r7, lr}
 810e0d6:	b086      	sub	sp, #24
 810e0d8:	af00      	add	r7, sp, #0
 810e0da:	6078      	str	r0, [r7, #4]
 810e0dc:	6039      	str	r1, [r7, #0]
  USBD_HID_HandleTypeDef *hhid = (USBD_HID_HandleTypeDef *)pdev->pClassDataCmsit[pdev->classId];
 810e0de:	687b      	ldr	r3, [r7, #4]
 810e0e0:	f8d3 22d4 	ldr.w	r2, [r3, #724]	; 0x2d4
 810e0e4:	687b      	ldr	r3, [r7, #4]
 810e0e6:	32b0      	adds	r2, #176	; 0xb0
 810e0e8:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 810e0ec:	60fb      	str	r3, [r7, #12]
  USBD_StatusTypeDef ret = USBD_OK;
 810e0ee:	2300      	movs	r3, #0
 810e0f0:	75fb      	strb	r3, [r7, #23]
  uint16_t len;
  uint8_t *pbuf;
  uint16_t status_info = 0U;
 810e0f2:	2300      	movs	r3, #0
 810e0f4:	817b      	strh	r3, [r7, #10]

  if (hhid == NULL)
 810e0f6:	68fb      	ldr	r3, [r7, #12]
 810e0f8:	2b00      	cmp	r3, #0
 810e0fa:	d101      	bne.n	810e100 <USBD_HID_Setup+0x2c>
  {
    return (uint8_t)USBD_FAIL;
 810e0fc:	2303      	movs	r3, #3
 810e0fe:	e0e8      	b.n	810e2d2 <USBD_HID_Setup+0x1fe>
  }

  switch (req->bmRequest & USB_REQ_TYPE_MASK)
 810e100:	683b      	ldr	r3, [r7, #0]
 810e102:	781b      	ldrb	r3, [r3, #0]
 810e104:	f003 0360 	and.w	r3, r3, #96	; 0x60
 810e108:	2b00      	cmp	r3, #0
 810e10a:	d046      	beq.n	810e19a <USBD_HID_Setup+0xc6>
 810e10c:	2b20      	cmp	r3, #32
 810e10e:	f040 80d8 	bne.w	810e2c2 <USBD_HID_Setup+0x1ee>
  {
    case USB_REQ_TYPE_CLASS :
      switch (req->bRequest)
 810e112:	683b      	ldr	r3, [r7, #0]
 810e114:	785b      	ldrb	r3, [r3, #1]
 810e116:	3b02      	subs	r3, #2
 810e118:	2b09      	cmp	r3, #9
 810e11a:	d836      	bhi.n	810e18a <USBD_HID_Setup+0xb6>
 810e11c:	a201      	add	r2, pc, #4	; (adr r2, 810e124 <USBD_HID_Setup+0x50>)
 810e11e:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 810e122:	bf00      	nop
 810e124:	0810e17b 	.word	0x0810e17b
 810e128:	0810e15b 	.word	0x0810e15b
 810e12c:	0810e18b 	.word	0x0810e18b
 810e130:	0810e18b 	.word	0x0810e18b
 810e134:	0810e18b 	.word	0x0810e18b
 810e138:	0810e18b 	.word	0x0810e18b
 810e13c:	0810e18b 	.word	0x0810e18b
 810e140:	0810e18b 	.word	0x0810e18b
 810e144:	0810e169 	.word	0x0810e169
 810e148:	0810e14d 	.word	0x0810e14d
      {
        case USBD_HID_REQ_SET_PROTOCOL:
          hhid->Protocol = (uint8_t)(req->wValue);
 810e14c:	683b      	ldr	r3, [r7, #0]
 810e14e:	885b      	ldrh	r3, [r3, #2]
 810e150:	b2db      	uxtb	r3, r3
 810e152:	461a      	mov	r2, r3
 810e154:	68fb      	ldr	r3, [r7, #12]
 810e156:	601a      	str	r2, [r3, #0]
          break;
 810e158:	e01e      	b.n	810e198 <USBD_HID_Setup+0xc4>

        case USBD_HID_REQ_GET_PROTOCOL:
          (void)USBD_CtlSendData(pdev, (uint8_t *)&hhid->Protocol, 1U);
 810e15a:	68fb      	ldr	r3, [r7, #12]
 810e15c:	2201      	movs	r2, #1
 810e15e:	4619      	mov	r1, r3
 810e160:	6878      	ldr	r0, [r7, #4]
 810e162:	f000 f933 	bl	810e3cc <USBD_CtlSendData>
          break;
 810e166:	e017      	b.n	810e198 <USBD_HID_Setup+0xc4>

        case USBD_HID_REQ_SET_IDLE:
          hhid->IdleState = (uint8_t)(req->wValue >> 8);
 810e168:	683b      	ldr	r3, [r7, #0]
 810e16a:	885b      	ldrh	r3, [r3, #2]
 810e16c:	0a1b      	lsrs	r3, r3, #8
 810e16e:	b29b      	uxth	r3, r3
 810e170:	b2db      	uxtb	r3, r3
 810e172:	461a      	mov	r2, r3
 810e174:	68fb      	ldr	r3, [r7, #12]
 810e176:	605a      	str	r2, [r3, #4]
          break;
 810e178:	e00e      	b.n	810e198 <USBD_HID_Setup+0xc4>

        case USBD_HID_REQ_GET_IDLE:
          (void)USBD_CtlSendData(pdev, (uint8_t *)&hhid->IdleState, 1U);
 810e17a:	68fb      	ldr	r3, [r7, #12]
 810e17c:	3304      	adds	r3, #4
 810e17e:	2201      	movs	r2, #1
 810e180:	4619      	mov	r1, r3
 810e182:	6878      	ldr	r0, [r7, #4]
 810e184:	f000 f922 	bl	810e3cc <USBD_CtlSendData>
          break;
 810e188:	e006      	b.n	810e198 <USBD_HID_Setup+0xc4>

        default:
          USBD_CtlError(pdev, req);
 810e18a:	6839      	ldr	r1, [r7, #0]
 810e18c:	6878      	ldr	r0, [r7, #4]
 810e18e:	f7ff fe76 	bl	810de7e <USBD_CtlError>
          ret = USBD_FAIL;
 810e192:	2303      	movs	r3, #3
 810e194:	75fb      	strb	r3, [r7, #23]
          break;
 810e196:	bf00      	nop
      }
      break;
 810e198:	e09a      	b.n	810e2d0 <USBD_HID_Setup+0x1fc>
    case USB_REQ_TYPE_STANDARD:
      switch (req->bRequest)
 810e19a:	683b      	ldr	r3, [r7, #0]
 810e19c:	785b      	ldrb	r3, [r3, #1]
 810e19e:	2b0b      	cmp	r3, #11
 810e1a0:	f200 8086 	bhi.w	810e2b0 <USBD_HID_Setup+0x1dc>
 810e1a4:	a201      	add	r2, pc, #4	; (adr r2, 810e1ac <USBD_HID_Setup+0xd8>)
 810e1a6:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 810e1aa:	bf00      	nop
 810e1ac:	0810e1dd 	.word	0x0810e1dd
 810e1b0:	0810e2bf 	.word	0x0810e2bf
 810e1b4:	0810e2b1 	.word	0x0810e2b1
 810e1b8:	0810e2b1 	.word	0x0810e2b1
 810e1bc:	0810e2b1 	.word	0x0810e2b1
 810e1c0:	0810e2b1 	.word	0x0810e2b1
 810e1c4:	0810e207 	.word	0x0810e207
 810e1c8:	0810e2b1 	.word	0x0810e2b1
 810e1cc:	0810e2b1 	.word	0x0810e2b1
 810e1d0:	0810e2b1 	.word	0x0810e2b1
 810e1d4:	0810e25f 	.word	0x0810e25f
 810e1d8:	0810e289 	.word	0x0810e289
      {
        case USB_REQ_GET_STATUS:
          if (pdev->dev_state == USBD_STATE_CONFIGURED)
 810e1dc:	687b      	ldr	r3, [r7, #4]
 810e1de:	f893 329c 	ldrb.w	r3, [r3, #668]	; 0x29c
 810e1e2:	b2db      	uxtb	r3, r3
 810e1e4:	2b03      	cmp	r3, #3
 810e1e6:	d107      	bne.n	810e1f8 <USBD_HID_Setup+0x124>
          {
            (void)USBD_CtlSendData(pdev, (uint8_t *)&status_info, 2U);
 810e1e8:	f107 030a 	add.w	r3, r7, #10
 810e1ec:	2202      	movs	r2, #2
 810e1ee:	4619      	mov	r1, r3
 810e1f0:	6878      	ldr	r0, [r7, #4]
 810e1f2:	f000 f8eb 	bl	810e3cc <USBD_CtlSendData>
          else
          {
            USBD_CtlError(pdev, req);
            ret = USBD_FAIL;
          }
          break;
 810e1f6:	e063      	b.n	810e2c0 <USBD_HID_Setup+0x1ec>
            USBD_CtlError(pdev, req);
 810e1f8:	6839      	ldr	r1, [r7, #0]
 810e1fa:	6878      	ldr	r0, [r7, #4]
 810e1fc:	f7ff fe3f 	bl	810de7e <USBD_CtlError>
            ret = USBD_FAIL;
 810e200:	2303      	movs	r3, #3
 810e202:	75fb      	strb	r3, [r7, #23]
          break;
 810e204:	e05c      	b.n	810e2c0 <USBD_HID_Setup+0x1ec>

        case USB_REQ_GET_DESCRIPTOR:
          if ((req->wValue >> 8) == HID_REPORT_DESC)
 810e206:	683b      	ldr	r3, [r7, #0]
 810e208:	885b      	ldrh	r3, [r3, #2]
 810e20a:	0a1b      	lsrs	r3, r3, #8
 810e20c:	b29b      	uxth	r3, r3
 810e20e:	2b22      	cmp	r3, #34	; 0x22
 810e210:	d108      	bne.n	810e224 <USBD_HID_Setup+0x150>
          {
            len = MIN(HID_MOUSE_REPORT_DESC_SIZE, req->wLength);
 810e212:	683b      	ldr	r3, [r7, #0]
 810e214:	88db      	ldrh	r3, [r3, #6]
 810e216:	2b4a      	cmp	r3, #74	; 0x4a
 810e218:	bf28      	it	cs
 810e21a:	234a      	movcs	r3, #74	; 0x4a
 810e21c:	82bb      	strh	r3, [r7, #20]
            pbuf = HID_MOUSE_ReportDesc;
 810e21e:	4b2f      	ldr	r3, [pc, #188]	; (810e2dc <USBD_HID_Setup+0x208>)
 810e220:	613b      	str	r3, [r7, #16]
 810e222:	e015      	b.n	810e250 <USBD_HID_Setup+0x17c>
          }
          else if ((req->wValue >> 8) == HID_DESCRIPTOR_TYPE)
 810e224:	683b      	ldr	r3, [r7, #0]
 810e226:	885b      	ldrh	r3, [r3, #2]
 810e228:	0a1b      	lsrs	r3, r3, #8
 810e22a:	b29b      	uxth	r3, r3
 810e22c:	2b21      	cmp	r3, #33	; 0x21
 810e22e:	d108      	bne.n	810e242 <USBD_HID_Setup+0x16e>
          {
            pbuf = USBD_HID_Desc;
 810e230:	4b2b      	ldr	r3, [pc, #172]	; (810e2e0 <USBD_HID_Setup+0x20c>)
 810e232:	613b      	str	r3, [r7, #16]
            len = MIN(USB_HID_DESC_SIZ, req->wLength);
 810e234:	683b      	ldr	r3, [r7, #0]
 810e236:	88db      	ldrh	r3, [r3, #6]
 810e238:	2b09      	cmp	r3, #9
 810e23a:	bf28      	it	cs
 810e23c:	2309      	movcs	r3, #9
 810e23e:	82bb      	strh	r3, [r7, #20]
 810e240:	e006      	b.n	810e250 <USBD_HID_Setup+0x17c>
          }
          else
          {
            USBD_CtlError(pdev, req);
 810e242:	6839      	ldr	r1, [r7, #0]
 810e244:	6878      	ldr	r0, [r7, #4]
 810e246:	f7ff fe1a 	bl	810de7e <USBD_CtlError>
            ret = USBD_FAIL;
 810e24a:	2303      	movs	r3, #3
 810e24c:	75fb      	strb	r3, [r7, #23]
            break;
 810e24e:	e037      	b.n	810e2c0 <USBD_HID_Setup+0x1ec>
          }
          (void)USBD_CtlSendData(pdev, pbuf, len);
 810e250:	8abb      	ldrh	r3, [r7, #20]
 810e252:	461a      	mov	r2, r3
 810e254:	6939      	ldr	r1, [r7, #16]
 810e256:	6878      	ldr	r0, [r7, #4]
 810e258:	f000 f8b8 	bl	810e3cc <USBD_CtlSendData>
          break;
 810e25c:	e030      	b.n	810e2c0 <USBD_HID_Setup+0x1ec>

        case USB_REQ_GET_INTERFACE :
          if (pdev->dev_state == USBD_STATE_CONFIGURED)
 810e25e:	687b      	ldr	r3, [r7, #4]
 810e260:	f893 329c 	ldrb.w	r3, [r3, #668]	; 0x29c
 810e264:	b2db      	uxtb	r3, r3
 810e266:	2b03      	cmp	r3, #3
 810e268:	d107      	bne.n	810e27a <USBD_HID_Setup+0x1a6>
          {
            (void)USBD_CtlSendData(pdev, (uint8_t *)&hhid->AltSetting, 1U);
 810e26a:	68fb      	ldr	r3, [r7, #12]
 810e26c:	3308      	adds	r3, #8
 810e26e:	2201      	movs	r2, #1
 810e270:	4619      	mov	r1, r3
 810e272:	6878      	ldr	r0, [r7, #4]
 810e274:	f000 f8aa 	bl	810e3cc <USBD_CtlSendData>
          else
          {
            USBD_CtlError(pdev, req);
            ret = USBD_FAIL;
          }
          break;
 810e278:	e022      	b.n	810e2c0 <USBD_HID_Setup+0x1ec>
            USBD_CtlError(pdev, req);
 810e27a:	6839      	ldr	r1, [r7, #0]
 810e27c:	6878      	ldr	r0, [r7, #4]
 810e27e:	f7ff fdfe 	bl	810de7e <USBD_CtlError>
            ret = USBD_FAIL;
 810e282:	2303      	movs	r3, #3
 810e284:	75fb      	strb	r3, [r7, #23]
          break;
 810e286:	e01b      	b.n	810e2c0 <USBD_HID_Setup+0x1ec>

        case USB_REQ_SET_INTERFACE:
          if (pdev->dev_state == USBD_STATE_CONFIGURED)
 810e288:	687b      	ldr	r3, [r7, #4]
 810e28a:	f893 329c 	ldrb.w	r3, [r3, #668]	; 0x29c
 810e28e:	b2db      	uxtb	r3, r3
 810e290:	2b03      	cmp	r3, #3
 810e292:	d106      	bne.n	810e2a2 <USBD_HID_Setup+0x1ce>
          {
            hhid->AltSetting = (uint8_t)(req->wValue);
 810e294:	683b      	ldr	r3, [r7, #0]
 810e296:	885b      	ldrh	r3, [r3, #2]
 810e298:	b2db      	uxtb	r3, r3
 810e29a:	461a      	mov	r2, r3
 810e29c:	68fb      	ldr	r3, [r7, #12]
 810e29e:	609a      	str	r2, [r3, #8]
          else
          {
            USBD_CtlError(pdev, req);
            ret = USBD_FAIL;
          }
          break;
 810e2a0:	e00e      	b.n	810e2c0 <USBD_HID_Setup+0x1ec>
            USBD_CtlError(pdev, req);
 810e2a2:	6839      	ldr	r1, [r7, #0]
 810e2a4:	6878      	ldr	r0, [r7, #4]
 810e2a6:	f7ff fdea 	bl	810de7e <USBD_CtlError>
            ret = USBD_FAIL;
 810e2aa:	2303      	movs	r3, #3
 810e2ac:	75fb      	strb	r3, [r7, #23]
          break;
 810e2ae:	e007      	b.n	810e2c0 <USBD_HID_Setup+0x1ec>

        case USB_REQ_CLEAR_FEATURE:
          break;

        default:
          USBD_CtlError(pdev, req);
 810e2b0:	6839      	ldr	r1, [r7, #0]
 810e2b2:	6878      	ldr	r0, [r7, #4]
 810e2b4:	f7ff fde3 	bl	810de7e <USBD_CtlError>
          ret = USBD_FAIL;
 810e2b8:	2303      	movs	r3, #3
 810e2ba:	75fb      	strb	r3, [r7, #23]
          break;
 810e2bc:	e000      	b.n	810e2c0 <USBD_HID_Setup+0x1ec>
          break;
 810e2be:	bf00      	nop
      }
      break;
 810e2c0:	e006      	b.n	810e2d0 <USBD_HID_Setup+0x1fc>

    default:
      USBD_CtlError(pdev, req);
 810e2c2:	6839      	ldr	r1, [r7, #0]
 810e2c4:	6878      	ldr	r0, [r7, #4]
 810e2c6:	f7ff fdda 	bl	810de7e <USBD_CtlError>
      ret = USBD_FAIL;
 810e2ca:	2303      	movs	r3, #3
 810e2cc:	75fb      	strb	r3, [r7, #23]
      break;
 810e2ce:	bf00      	nop
  }

  return (uint8_t)ret;
 810e2d0:	7dfb      	ldrb	r3, [r7, #23]
}
 810e2d2:	4618      	mov	r0, r3
 810e2d4:	3718      	adds	r7, #24
 810e2d6:	46bd      	mov	sp, r7
 810e2d8:	bd80      	pop	{r7, pc}
 810e2da:	bf00      	nop
 810e2dc:	100000b4 	.word	0x100000b4
 810e2e0:	1000009c 	.word	0x1000009c

0810e2e4 <USBD_HID_GetFSCfgDesc>:
  * @param  speed : current device speed
  * @param  length : pointer data length
  * @retval pointer to descriptor buffer
  */
static uint8_t *USBD_HID_GetFSCfgDesc(uint16_t *length)
{
 810e2e4:	b580      	push	{r7, lr}
 810e2e6:	b084      	sub	sp, #16
 810e2e8:	af00      	add	r7, sp, #0
 810e2ea:	6078      	str	r0, [r7, #4]
  USBD_EpDescTypeDef *pEpDesc = USBD_GetEpDesc(USBD_HID_CfgDesc, HID_EPIN_ADDR);
 810e2ec:	2181      	movs	r1, #129	; 0x81
 810e2ee:	4809      	ldr	r0, [pc, #36]	; (810e314 <USBD_HID_GetFSCfgDesc+0x30>)
 810e2f0:	f7fe ff63 	bl	810d1ba <USBD_GetEpDesc>
 810e2f4:	60f8      	str	r0, [r7, #12]

  if (pEpDesc != NULL)
 810e2f6:	68fb      	ldr	r3, [r7, #12]
 810e2f8:	2b00      	cmp	r3, #0
 810e2fa:	d002      	beq.n	810e302 <USBD_HID_GetFSCfgDesc+0x1e>
  {
    pEpDesc->bInterval = HID_FS_BINTERVAL;
 810e2fc:	68fb      	ldr	r3, [r7, #12]
 810e2fe:	220a      	movs	r2, #10
 810e300:	719a      	strb	r2, [r3, #6]
  }

  *length = (uint16_t)sizeof(USBD_HID_CfgDesc);
 810e302:	687b      	ldr	r3, [r7, #4]
 810e304:	2222      	movs	r2, #34	; 0x22
 810e306:	801a      	strh	r2, [r3, #0]
  return USBD_HID_CfgDesc;
 810e308:	4b02      	ldr	r3, [pc, #8]	; (810e314 <USBD_HID_GetFSCfgDesc+0x30>)
}
 810e30a:	4618      	mov	r0, r3
 810e30c:	3710      	adds	r7, #16
 810e30e:	46bd      	mov	sp, r7
 810e310:	bd80      	pop	{r7, pc}
 810e312:	bf00      	nop
 810e314:	10000078 	.word	0x10000078

0810e318 <USBD_HID_GetHSCfgDesc>:
  * @param  speed : current device speed
  * @param  length : pointer data length
  * @retval pointer to descriptor buffer
  */
static uint8_t *USBD_HID_GetHSCfgDesc(uint16_t *length)
{
 810e318:	b580      	push	{r7, lr}
 810e31a:	b084      	sub	sp, #16
 810e31c:	af00      	add	r7, sp, #0
 810e31e:	6078      	str	r0, [r7, #4]
  USBD_EpDescTypeDef *pEpDesc = USBD_GetEpDesc(USBD_HID_CfgDesc, HID_EPIN_ADDR);
 810e320:	2181      	movs	r1, #129	; 0x81
 810e322:	4809      	ldr	r0, [pc, #36]	; (810e348 <USBD_HID_GetHSCfgDesc+0x30>)
 810e324:	f7fe ff49 	bl	810d1ba <USBD_GetEpDesc>
 810e328:	60f8      	str	r0, [r7, #12]

  if (pEpDesc != NULL)
 810e32a:	68fb      	ldr	r3, [r7, #12]
 810e32c:	2b00      	cmp	r3, #0
 810e32e:	d002      	beq.n	810e336 <USBD_HID_GetHSCfgDesc+0x1e>
  {
    pEpDesc->bInterval = HID_HS_BINTERVAL;
 810e330:	68fb      	ldr	r3, [r7, #12]
 810e332:	2207      	movs	r2, #7
 810e334:	719a      	strb	r2, [r3, #6]
  }

  *length = (uint16_t)sizeof(USBD_HID_CfgDesc);
 810e336:	687b      	ldr	r3, [r7, #4]
 810e338:	2222      	movs	r2, #34	; 0x22
 810e33a:	801a      	strh	r2, [r3, #0]
  return USBD_HID_CfgDesc;
 810e33c:	4b02      	ldr	r3, [pc, #8]	; (810e348 <USBD_HID_GetHSCfgDesc+0x30>)
}
 810e33e:	4618      	mov	r0, r3
 810e340:	3710      	adds	r7, #16
 810e342:	46bd      	mov	sp, r7
 810e344:	bd80      	pop	{r7, pc}
 810e346:	bf00      	nop
 810e348:	10000078 	.word	0x10000078

0810e34c <USBD_HID_GetOtherSpeedCfgDesc>:
  * @param  speed : current device speed
  * @param  length : pointer data length
  * @retval pointer to descriptor buffer
  */
static uint8_t *USBD_HID_GetOtherSpeedCfgDesc(uint16_t *length)
{
 810e34c:	b580      	push	{r7, lr}
 810e34e:	b084      	sub	sp, #16
 810e350:	af00      	add	r7, sp, #0
 810e352:	6078      	str	r0, [r7, #4]
  USBD_EpDescTypeDef *pEpDesc = USBD_GetEpDesc(USBD_HID_CfgDesc, HID_EPIN_ADDR);
 810e354:	2181      	movs	r1, #129	; 0x81
 810e356:	4809      	ldr	r0, [pc, #36]	; (810e37c <USBD_HID_GetOtherSpeedCfgDesc+0x30>)
 810e358:	f7fe ff2f 	bl	810d1ba <USBD_GetEpDesc>
 810e35c:	60f8      	str	r0, [r7, #12]

  if (pEpDesc != NULL)
 810e35e:	68fb      	ldr	r3, [r7, #12]
 810e360:	2b00      	cmp	r3, #0
 810e362:	d002      	beq.n	810e36a <USBD_HID_GetOtherSpeedCfgDesc+0x1e>
  {
    pEpDesc->bInterval = HID_FS_BINTERVAL;
 810e364:	68fb      	ldr	r3, [r7, #12]
 810e366:	220a      	movs	r2, #10
 810e368:	719a      	strb	r2, [r3, #6]
  }

  *length = (uint16_t)sizeof(USBD_HID_CfgDesc);
 810e36a:	687b      	ldr	r3, [r7, #4]
 810e36c:	2222      	movs	r2, #34	; 0x22
 810e36e:	801a      	strh	r2, [r3, #0]
  return USBD_HID_CfgDesc;
 810e370:	4b02      	ldr	r3, [pc, #8]	; (810e37c <USBD_HID_GetOtherSpeedCfgDesc+0x30>)
}
 810e372:	4618      	mov	r0, r3
 810e374:	3710      	adds	r7, #16
 810e376:	46bd      	mov	sp, r7
 810e378:	bd80      	pop	{r7, pc}
 810e37a:	bf00      	nop
 810e37c:	10000078 	.word	0x10000078

0810e380 <USBD_HID_DataIn>:
  * @param  pdev: device instance
  * @param  epnum: endpoint index
  * @retval status
  */
static uint8_t USBD_HID_DataIn(USBD_HandleTypeDef *pdev, uint8_t epnum)
{
 810e380:	b480      	push	{r7}
 810e382:	b083      	sub	sp, #12
 810e384:	af00      	add	r7, sp, #0
 810e386:	6078      	str	r0, [r7, #4]
 810e388:	460b      	mov	r3, r1
 810e38a:	70fb      	strb	r3, [r7, #3]
  UNUSED(epnum);
  /* Ensure that the FIFO is empty before a new transfer, this condition could
  be caused by  a new transfer before the end of the previous transfer */
  ((USBD_HID_HandleTypeDef *)pdev->pClassDataCmsit[pdev->classId])->state = USBD_HID_IDLE;
 810e38c:	687b      	ldr	r3, [r7, #4]
 810e38e:	f8d3 22d4 	ldr.w	r2, [r3, #724]	; 0x2d4
 810e392:	687b      	ldr	r3, [r7, #4]
 810e394:	32b0      	adds	r2, #176	; 0xb0
 810e396:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 810e39a:	2200      	movs	r2, #0
 810e39c:	731a      	strb	r2, [r3, #12]

  return (uint8_t)USBD_OK;
 810e39e:	2300      	movs	r3, #0
}
 810e3a0:	4618      	mov	r0, r3
 810e3a2:	370c      	adds	r7, #12
 810e3a4:	46bd      	mov	sp, r7
 810e3a6:	f85d 7b04 	ldr.w	r7, [sp], #4
 810e3aa:	4770      	bx	lr

0810e3ac <USBD_HID_GetDeviceQualifierDesc>:
  *         return Device Qualifier descriptor
  * @param  length : pointer data length
  * @retval pointer to descriptor buffer
  */
static uint8_t *USBD_HID_GetDeviceQualifierDesc(uint16_t *length)
{
 810e3ac:	b480      	push	{r7}
 810e3ae:	b083      	sub	sp, #12
 810e3b0:	af00      	add	r7, sp, #0
 810e3b2:	6078      	str	r0, [r7, #4]
  *length = (uint16_t)sizeof(USBD_HID_DeviceQualifierDesc);
 810e3b4:	687b      	ldr	r3, [r7, #4]
 810e3b6:	220a      	movs	r2, #10
 810e3b8:	801a      	strh	r2, [r3, #0]

  return USBD_HID_DeviceQualifierDesc;
 810e3ba:	4b03      	ldr	r3, [pc, #12]	; (810e3c8 <USBD_HID_GetDeviceQualifierDesc+0x1c>)
}
 810e3bc:	4618      	mov	r0, r3
 810e3be:	370c      	adds	r7, #12
 810e3c0:	46bd      	mov	sp, r7
 810e3c2:	f85d 7b04 	ldr.w	r7, [sp], #4
 810e3c6:	4770      	bx	lr
 810e3c8:	100000a8 	.word	0x100000a8

0810e3cc <USBD_CtlSendData>:
  * @param  len: length of data to be sent
  * @retval status
  */
USBD_StatusTypeDef USBD_CtlSendData(USBD_HandleTypeDef *pdev,
                                    uint8_t *pbuf, uint32_t len)
{
 810e3cc:	b580      	push	{r7, lr}
 810e3ce:	b084      	sub	sp, #16
 810e3d0:	af00      	add	r7, sp, #0
 810e3d2:	60f8      	str	r0, [r7, #12]
 810e3d4:	60b9      	str	r1, [r7, #8]
 810e3d6:	607a      	str	r2, [r7, #4]
  /* Set EP0 State */
  pdev->ep0_state = USBD_EP0_DATA_IN;
 810e3d8:	68fb      	ldr	r3, [r7, #12]
 810e3da:	2202      	movs	r2, #2
 810e3dc:	f8c3 2294 	str.w	r2, [r3, #660]	; 0x294
  pdev->ep_in[0].total_length = len;
 810e3e0:	68fb      	ldr	r3, [r7, #12]
 810e3e2:	687a      	ldr	r2, [r7, #4]
 810e3e4:	619a      	str	r2, [r3, #24]

#ifdef USBD_AVOID_PACKET_SPLIT_MPS
  pdev->ep_in[0].rem_length = 0U;
#else
  pdev->ep_in[0].rem_length = len;
 810e3e6:	68fb      	ldr	r3, [r7, #12]
 810e3e8:	687a      	ldr	r2, [r7, #4]
 810e3ea:	61da      	str	r2, [r3, #28]
#endif /* USBD_AVOID_PACKET_SPLIT_MPS */

  /* Start the transfer */
  (void)USBD_LL_Transmit(pdev, 0x00U, pbuf, len);
 810e3ec:	687b      	ldr	r3, [r7, #4]
 810e3ee:	68ba      	ldr	r2, [r7, #8]
 810e3f0:	2100      	movs	r1, #0
 810e3f2:	68f8      	ldr	r0, [r7, #12]
 810e3f4:	f00d f88f 	bl	811b516 <USBD_LL_Transmit>

  return USBD_OK;
 810e3f8:	2300      	movs	r3, #0
}
 810e3fa:	4618      	mov	r0, r3
 810e3fc:	3710      	adds	r7, #16
 810e3fe:	46bd      	mov	sp, r7
 810e400:	bd80      	pop	{r7, pc}

0810e402 <USBD_CtlContinueSendData>:
  * @param  len: length of data to be sent
  * @retval status
  */
USBD_StatusTypeDef USBD_CtlContinueSendData(USBD_HandleTypeDef *pdev,
                                            uint8_t *pbuf, uint32_t len)
{
 810e402:	b580      	push	{r7, lr}
 810e404:	b084      	sub	sp, #16
 810e406:	af00      	add	r7, sp, #0
 810e408:	60f8      	str	r0, [r7, #12]
 810e40a:	60b9      	str	r1, [r7, #8]
 810e40c:	607a      	str	r2, [r7, #4]
  /* Start the next transfer */
  (void)USBD_LL_Transmit(pdev, 0x00U, pbuf, len);
 810e40e:	687b      	ldr	r3, [r7, #4]
 810e410:	68ba      	ldr	r2, [r7, #8]
 810e412:	2100      	movs	r1, #0
 810e414:	68f8      	ldr	r0, [r7, #12]
 810e416:	f00d f87e 	bl	811b516 <USBD_LL_Transmit>

  return USBD_OK;
 810e41a:	2300      	movs	r3, #0
}
 810e41c:	4618      	mov	r0, r3
 810e41e:	3710      	adds	r7, #16
 810e420:	46bd      	mov	sp, r7
 810e422:	bd80      	pop	{r7, pc}

0810e424 <USBD_CtlContinueRx>:
  * @param  len: length of data to be received
  * @retval status
  */
USBD_StatusTypeDef USBD_CtlContinueRx(USBD_HandleTypeDef *pdev,
                                      uint8_t *pbuf, uint32_t len)
{
 810e424:	b580      	push	{r7, lr}
 810e426:	b084      	sub	sp, #16
 810e428:	af00      	add	r7, sp, #0
 810e42a:	60f8      	str	r0, [r7, #12]
 810e42c:	60b9      	str	r1, [r7, #8]
 810e42e:	607a      	str	r2, [r7, #4]
  (void)USBD_LL_PrepareReceive(pdev, 0U, pbuf, len);
 810e430:	687b      	ldr	r3, [r7, #4]
 810e432:	68ba      	ldr	r2, [r7, #8]
 810e434:	2100      	movs	r1, #0
 810e436:	68f8      	ldr	r0, [r7, #12]
 810e438:	f00d f88e 	bl	811b558 <USBD_LL_PrepareReceive>

  return USBD_OK;
 810e43c:	2300      	movs	r3, #0
}
 810e43e:	4618      	mov	r0, r3
 810e440:	3710      	adds	r7, #16
 810e442:	46bd      	mov	sp, r7
 810e444:	bd80      	pop	{r7, pc}

0810e446 <USBD_CtlSendStatus>:
  *         send zero lzngth packet on the ctl pipe
  * @param  pdev: device instance
  * @retval status
  */
USBD_StatusTypeDef USBD_CtlSendStatus(USBD_HandleTypeDef *pdev)
{
 810e446:	b580      	push	{r7, lr}
 810e448:	b082      	sub	sp, #8
 810e44a:	af00      	add	r7, sp, #0
 810e44c:	6078      	str	r0, [r7, #4]
  /* Set EP0 State */
  pdev->ep0_state = USBD_EP0_STATUS_IN;
 810e44e:	687b      	ldr	r3, [r7, #4]
 810e450:	2204      	movs	r2, #4
 810e452:	f8c3 2294 	str.w	r2, [r3, #660]	; 0x294

  /* Start the transfer */
  (void)USBD_LL_Transmit(pdev, 0x00U, NULL, 0U);
 810e456:	2300      	movs	r3, #0
 810e458:	2200      	movs	r2, #0
 810e45a:	2100      	movs	r1, #0
 810e45c:	6878      	ldr	r0, [r7, #4]
 810e45e:	f00d f85a 	bl	811b516 <USBD_LL_Transmit>

  return USBD_OK;
 810e462:	2300      	movs	r3, #0
}
 810e464:	4618      	mov	r0, r3
 810e466:	3708      	adds	r7, #8
 810e468:	46bd      	mov	sp, r7
 810e46a:	bd80      	pop	{r7, pc}

0810e46c <USBD_CtlReceiveStatus>:
  *         receive zero lzngth packet on the ctl pipe
  * @param  pdev: device instance
  * @retval status
  */
USBD_StatusTypeDef USBD_CtlReceiveStatus(USBD_HandleTypeDef *pdev)
{
 810e46c:	b580      	push	{r7, lr}
 810e46e:	b082      	sub	sp, #8
 810e470:	af00      	add	r7, sp, #0
 810e472:	6078      	str	r0, [r7, #4]
  /* Set EP0 State */
  pdev->ep0_state = USBD_EP0_STATUS_OUT;
 810e474:	687b      	ldr	r3, [r7, #4]
 810e476:	2205      	movs	r2, #5
 810e478:	f8c3 2294 	str.w	r2, [r3, #660]	; 0x294

  /* Start the transfer */
  (void)USBD_LL_PrepareReceive(pdev, 0U, NULL, 0U);
 810e47c:	2300      	movs	r3, #0
 810e47e:	2200      	movs	r2, #0
 810e480:	2100      	movs	r1, #0
 810e482:	6878      	ldr	r0, [r7, #4]
 810e484:	f00d f868 	bl	811b558 <USBD_LL_PrepareReceive>

  return USBD_OK;
 810e488:	2300      	movs	r3, #0
}
 810e48a:	4618      	mov	r0, r3
 810e48c:	3708      	adds	r7, #8
 810e48e:	46bd      	mov	sp, r7
 810e490:	bd80      	pop	{r7, pc}

0810e492 <lwip_htons>:
 * @param n u16_t in host byte order
 * @return n in network byte order
 */
u16_t
lwip_htons(u16_t n)
{
 810e492:	b480      	push	{r7}
 810e494:	b083      	sub	sp, #12
 810e496:	af00      	add	r7, sp, #0
 810e498:	4603      	mov	r3, r0
 810e49a:	80fb      	strh	r3, [r7, #6]
  return PP_HTONS(n);
 810e49c:	88fb      	ldrh	r3, [r7, #6]
 810e49e:	021b      	lsls	r3, r3, #8
 810e4a0:	b21a      	sxth	r2, r3
 810e4a2:	88fb      	ldrh	r3, [r7, #6]
 810e4a4:	0a1b      	lsrs	r3, r3, #8
 810e4a6:	b29b      	uxth	r3, r3
 810e4a8:	b21b      	sxth	r3, r3
 810e4aa:	4313      	orrs	r3, r2
 810e4ac:	b21b      	sxth	r3, r3
 810e4ae:	b29b      	uxth	r3, r3
}
 810e4b0:	4618      	mov	r0, r3
 810e4b2:	370c      	adds	r7, #12
 810e4b4:	46bd      	mov	sp, r7
 810e4b6:	f85d 7b04 	ldr.w	r7, [sp], #4
 810e4ba:	4770      	bx	lr

0810e4bc <lwip_htonl>:
 * @param n u32_t in host byte order
 * @return n in network byte order
 */
u32_t
lwip_htonl(u32_t n)
{
 810e4bc:	b480      	push	{r7}
 810e4be:	b083      	sub	sp, #12
 810e4c0:	af00      	add	r7, sp, #0
 810e4c2:	6078      	str	r0, [r7, #4]
  return PP_HTONL(n);
 810e4c4:	687b      	ldr	r3, [r7, #4]
 810e4c6:	061a      	lsls	r2, r3, #24
 810e4c8:	687b      	ldr	r3, [r7, #4]
 810e4ca:	021b      	lsls	r3, r3, #8
 810e4cc:	f403 037f 	and.w	r3, r3, #16711680	; 0xff0000
 810e4d0:	431a      	orrs	r2, r3
 810e4d2:	687b      	ldr	r3, [r7, #4]
 810e4d4:	0a1b      	lsrs	r3, r3, #8
 810e4d6:	f403 437f 	and.w	r3, r3, #65280	; 0xff00
 810e4da:	431a      	orrs	r2, r3
 810e4dc:	687b      	ldr	r3, [r7, #4]
 810e4de:	0e1b      	lsrs	r3, r3, #24
 810e4e0:	4313      	orrs	r3, r2
}
 810e4e2:	4618      	mov	r0, r3
 810e4e4:	370c      	adds	r7, #12
 810e4e6:	46bd      	mov	sp, r7
 810e4e8:	f85d 7b04 	ldr.w	r7, [sp], #4
 810e4ec:	4770      	bx	lr
	...

0810e4f0 <dhcp_inc_pcb_refcount>:
static void dhcp_option_trailer(u16_t options_out_len, u8_t *options, struct pbuf *p_out);

/** Ensure DHCP PCB is allocated and bound */
static err_t
dhcp_inc_pcb_refcount(void)
{
 810e4f0:	b580      	push	{r7, lr}
 810e4f2:	af00      	add	r7, sp, #0
  if (dhcp_pcb_refcount == 0) {
 810e4f4:	4b20      	ldr	r3, [pc, #128]	; (810e578 <dhcp_inc_pcb_refcount+0x88>)
 810e4f6:	781b      	ldrb	r3, [r3, #0]
 810e4f8:	2b00      	cmp	r3, #0
 810e4fa:	d133      	bne.n	810e564 <dhcp_inc_pcb_refcount+0x74>
    LWIP_ASSERT("dhcp_inc_pcb_refcount(): memory leak", dhcp_pcb == NULL);
 810e4fc:	4b1f      	ldr	r3, [pc, #124]	; (810e57c <dhcp_inc_pcb_refcount+0x8c>)
 810e4fe:	681b      	ldr	r3, [r3, #0]
 810e500:	2b00      	cmp	r3, #0
 810e502:	d005      	beq.n	810e510 <dhcp_inc_pcb_refcount+0x20>
 810e504:	4b1e      	ldr	r3, [pc, #120]	; (810e580 <dhcp_inc_pcb_refcount+0x90>)
 810e506:	22e5      	movs	r2, #229	; 0xe5
 810e508:	491e      	ldr	r1, [pc, #120]	; (810e584 <dhcp_inc_pcb_refcount+0x94>)
 810e50a:	481f      	ldr	r0, [pc, #124]	; (810e588 <dhcp_inc_pcb_refcount+0x98>)
 810e50c:	f00d f978 	bl	811b800 <iprintf>

    /* allocate UDP PCB */
    dhcp_pcb = udp_new();
 810e510:	f00c fbce 	bl	811acb0 <udp_new>
 810e514:	4603      	mov	r3, r0
 810e516:	4a19      	ldr	r2, [pc, #100]	; (810e57c <dhcp_inc_pcb_refcount+0x8c>)
 810e518:	6013      	str	r3, [r2, #0]

    if (dhcp_pcb == NULL) {
 810e51a:	4b18      	ldr	r3, [pc, #96]	; (810e57c <dhcp_inc_pcb_refcount+0x8c>)
 810e51c:	681b      	ldr	r3, [r3, #0]
 810e51e:	2b00      	cmp	r3, #0
 810e520:	d102      	bne.n	810e528 <dhcp_inc_pcb_refcount+0x38>
      return ERR_MEM;
 810e522:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 810e526:	e024      	b.n	810e572 <dhcp_inc_pcb_refcount+0x82>
    }

    ip_set_option(dhcp_pcb, SOF_BROADCAST);
 810e528:	4b14      	ldr	r3, [pc, #80]	; (810e57c <dhcp_inc_pcb_refcount+0x8c>)
 810e52a:	681b      	ldr	r3, [r3, #0]
 810e52c:	7a5a      	ldrb	r2, [r3, #9]
 810e52e:	4b13      	ldr	r3, [pc, #76]	; (810e57c <dhcp_inc_pcb_refcount+0x8c>)
 810e530:	681b      	ldr	r3, [r3, #0]
 810e532:	f042 0220 	orr.w	r2, r2, #32
 810e536:	b2d2      	uxtb	r2, r2
 810e538:	725a      	strb	r2, [r3, #9]

    /* set up local and remote port for the pcb -> listen on all interfaces on all src/dest IPs */
    udp_bind(dhcp_pcb, IP4_ADDR_ANY, LWIP_IANA_PORT_DHCP_CLIENT);
 810e53a:	4b10      	ldr	r3, [pc, #64]	; (810e57c <dhcp_inc_pcb_refcount+0x8c>)
 810e53c:	681b      	ldr	r3, [r3, #0]
 810e53e:	2244      	movs	r2, #68	; 0x44
 810e540:	4912      	ldr	r1, [pc, #72]	; (810e58c <dhcp_inc_pcb_refcount+0x9c>)
 810e542:	4618      	mov	r0, r3
 810e544:	f00c fa5c 	bl	811aa00 <udp_bind>
    udp_connect(dhcp_pcb, IP4_ADDR_ANY, LWIP_IANA_PORT_DHCP_SERVER);
 810e548:	4b0c      	ldr	r3, [pc, #48]	; (810e57c <dhcp_inc_pcb_refcount+0x8c>)
 810e54a:	681b      	ldr	r3, [r3, #0]
 810e54c:	2243      	movs	r2, #67	; 0x43
 810e54e:	490f      	ldr	r1, [pc, #60]	; (810e58c <dhcp_inc_pcb_refcount+0x9c>)
 810e550:	4618      	mov	r0, r3
 810e552:	f00c fadd 	bl	811ab10 <udp_connect>
    udp_recv(dhcp_pcb, dhcp_recv, NULL);
 810e556:	4b09      	ldr	r3, [pc, #36]	; (810e57c <dhcp_inc_pcb_refcount+0x8c>)
 810e558:	681b      	ldr	r3, [r3, #0]
 810e55a:	2200      	movs	r2, #0
 810e55c:	490c      	ldr	r1, [pc, #48]	; (810e590 <dhcp_inc_pcb_refcount+0xa0>)
 810e55e:	4618      	mov	r0, r3
 810e560:	f00c fb44 	bl	811abec <udp_recv>
  }

  dhcp_pcb_refcount++;
 810e564:	4b04      	ldr	r3, [pc, #16]	; (810e578 <dhcp_inc_pcb_refcount+0x88>)
 810e566:	781b      	ldrb	r3, [r3, #0]
 810e568:	3301      	adds	r3, #1
 810e56a:	b2da      	uxtb	r2, r3
 810e56c:	4b02      	ldr	r3, [pc, #8]	; (810e578 <dhcp_inc_pcb_refcount+0x88>)
 810e56e:	701a      	strb	r2, [r3, #0]

  return ERR_OK;
 810e570:	2300      	movs	r3, #0
}
 810e572:	4618      	mov	r0, r3
 810e574:	bd80      	pop	{r7, pc}
 810e576:	bf00      	nop
 810e578:	10004f6c 	.word	0x10004f6c
 810e57c:	10004f68 	.word	0x10004f68
 810e580:	0811c788 	.word	0x0811c788
 810e584:	0811c7f0 	.word	0x0811c7f0
 810e588:	0811c818 	.word	0x0811c818
 810e58c:	0811f934 	.word	0x0811f934
 810e590:	0810fec5 	.word	0x0810fec5

0810e594 <dhcp_dec_pcb_refcount>:

/** Free DHCP PCB if the last netif stops using it */
static void
dhcp_dec_pcb_refcount(void)
{
 810e594:	b580      	push	{r7, lr}
 810e596:	af00      	add	r7, sp, #0
  LWIP_ASSERT("dhcp_pcb_refcount(): refcount error", (dhcp_pcb_refcount > 0));
 810e598:	4b0e      	ldr	r3, [pc, #56]	; (810e5d4 <dhcp_dec_pcb_refcount+0x40>)
 810e59a:	781b      	ldrb	r3, [r3, #0]
 810e59c:	2b00      	cmp	r3, #0
 810e59e:	d105      	bne.n	810e5ac <dhcp_dec_pcb_refcount+0x18>
 810e5a0:	4b0d      	ldr	r3, [pc, #52]	; (810e5d8 <dhcp_dec_pcb_refcount+0x44>)
 810e5a2:	22ff      	movs	r2, #255	; 0xff
 810e5a4:	490d      	ldr	r1, [pc, #52]	; (810e5dc <dhcp_dec_pcb_refcount+0x48>)
 810e5a6:	480e      	ldr	r0, [pc, #56]	; (810e5e0 <dhcp_dec_pcb_refcount+0x4c>)
 810e5a8:	f00d f92a 	bl	811b800 <iprintf>
  dhcp_pcb_refcount--;
 810e5ac:	4b09      	ldr	r3, [pc, #36]	; (810e5d4 <dhcp_dec_pcb_refcount+0x40>)
 810e5ae:	781b      	ldrb	r3, [r3, #0]
 810e5b0:	3b01      	subs	r3, #1
 810e5b2:	b2da      	uxtb	r2, r3
 810e5b4:	4b07      	ldr	r3, [pc, #28]	; (810e5d4 <dhcp_dec_pcb_refcount+0x40>)
 810e5b6:	701a      	strb	r2, [r3, #0]

  if (dhcp_pcb_refcount == 0) {
 810e5b8:	4b06      	ldr	r3, [pc, #24]	; (810e5d4 <dhcp_dec_pcb_refcount+0x40>)
 810e5ba:	781b      	ldrb	r3, [r3, #0]
 810e5bc:	2b00      	cmp	r3, #0
 810e5be:	d107      	bne.n	810e5d0 <dhcp_dec_pcb_refcount+0x3c>
    udp_remove(dhcp_pcb);
 810e5c0:	4b08      	ldr	r3, [pc, #32]	; (810e5e4 <dhcp_dec_pcb_refcount+0x50>)
 810e5c2:	681b      	ldr	r3, [r3, #0]
 810e5c4:	4618      	mov	r0, r3
 810e5c6:	f00c fb31 	bl	811ac2c <udp_remove>
    dhcp_pcb = NULL;
 810e5ca:	4b06      	ldr	r3, [pc, #24]	; (810e5e4 <dhcp_dec_pcb_refcount+0x50>)
 810e5cc:	2200      	movs	r2, #0
 810e5ce:	601a      	str	r2, [r3, #0]
  }
}
 810e5d0:	bf00      	nop
 810e5d2:	bd80      	pop	{r7, pc}
 810e5d4:	10004f6c 	.word	0x10004f6c
 810e5d8:	0811c788 	.word	0x0811c788
 810e5dc:	0811c840 	.word	0x0811c840
 810e5e0:	0811c818 	.word	0x0811c818
 810e5e4:	10004f68 	.word	0x10004f68

0810e5e8 <dhcp_handle_nak>:
 *
 * @param netif the netif under DHCP control
 */
static void
dhcp_handle_nak(struct netif *netif)
{
 810e5e8:	b580      	push	{r7, lr}
 810e5ea:	b084      	sub	sp, #16
 810e5ec:	af00      	add	r7, sp, #0
 810e5ee:	6078      	str	r0, [r7, #4]
  struct dhcp *dhcp = netif_dhcp_data(netif);
 810e5f0:	687b      	ldr	r3, [r7, #4]
 810e5f2:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 810e5f4:	60fb      	str	r3, [r7, #12]

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_handle_nak(netif=%p) %c%c%"U16_F"\n",
              (void *)netif, netif->name[0], netif->name[1], (u16_t)netif->num));
  /* Change to a defined state - set this before assigning the address
     to ensure the callback can use dhcp_supplied_address() */
  dhcp_set_state(dhcp, DHCP_STATE_BACKING_OFF);
 810e5f6:	210c      	movs	r1, #12
 810e5f8:	68f8      	ldr	r0, [r7, #12]
 810e5fa:	f001 f875 	bl	810f6e8 <dhcp_set_state>
  /* remove IP address from interface (must no longer be used, as per RFC2131) */
  netif_set_addr(netif, IP4_ADDR_ANY4, IP4_ADDR_ANY4, IP4_ADDR_ANY4);
 810e5fe:	4b06      	ldr	r3, [pc, #24]	; (810e618 <dhcp_handle_nak+0x30>)
 810e600:	4a05      	ldr	r2, [pc, #20]	; (810e618 <dhcp_handle_nak+0x30>)
 810e602:	4905      	ldr	r1, [pc, #20]	; (810e618 <dhcp_handle_nak+0x30>)
 810e604:	6878      	ldr	r0, [r7, #4]
 810e606:	f005 fb67 	bl	8113cd8 <netif_set_addr>
  /* We can immediately restart discovery */
  dhcp_discover(netif);
 810e60a:	6878      	ldr	r0, [r7, #4]
 810e60c:	f000 fc68 	bl	810eee0 <dhcp_discover>
}
 810e610:	bf00      	nop
 810e612:	3710      	adds	r7, #16
 810e614:	46bd      	mov	sp, r7
 810e616:	bd80      	pop	{r7, pc}
 810e618:	0811f934 	.word	0x0811f934

0810e61c <dhcp_check>:
 *
 * @param netif the netif under DHCP control
 */
static void
dhcp_check(struct netif *netif)
{
 810e61c:	b580      	push	{r7, lr}
 810e61e:	b084      	sub	sp, #16
 810e620:	af00      	add	r7, sp, #0
 810e622:	6078      	str	r0, [r7, #4]
  struct dhcp *dhcp = netif_dhcp_data(netif);
 810e624:	687b      	ldr	r3, [r7, #4]
 810e626:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 810e628:	60fb      	str	r3, [r7, #12]
  err_t result;
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_check(netif=%p) %c%c\n", (void *)netif, (s16_t)netif->name[0],
              (s16_t)netif->name[1]));
  dhcp_set_state(dhcp, DHCP_STATE_CHECKING);
 810e62a:	2108      	movs	r1, #8
 810e62c:	68f8      	ldr	r0, [r7, #12]
 810e62e:	f001 f85b 	bl	810f6e8 <dhcp_set_state>
  /* create an ARP query for the offered IP address, expecting that no host
     responds, as the IP address should not be in use. */
  result = etharp_query(netif, &dhcp->offered_ip_addr, NULL);
 810e632:	68fb      	ldr	r3, [r7, #12]
 810e634:	331c      	adds	r3, #28
 810e636:	2200      	movs	r2, #0
 810e638:	4619      	mov	r1, r3
 810e63a:	6878      	ldr	r0, [r7, #4]
 810e63c:	f002 fe7a 	bl	8111334 <etharp_query>
 810e640:	4603      	mov	r3, r0
 810e642:	72fb      	strb	r3, [r7, #11]
  if (result != ERR_OK) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING, ("dhcp_check: could not perform ARP query\n"));
  }
  if (dhcp->tries < 255) {
 810e644:	68fb      	ldr	r3, [r7, #12]
 810e646:	799b      	ldrb	r3, [r3, #6]
 810e648:	2bff      	cmp	r3, #255	; 0xff
 810e64a:	d005      	beq.n	810e658 <dhcp_check+0x3c>
    dhcp->tries++;
 810e64c:	68fb      	ldr	r3, [r7, #12]
 810e64e:	799b      	ldrb	r3, [r3, #6]
 810e650:	3301      	adds	r3, #1
 810e652:	b2da      	uxtb	r2, r3
 810e654:	68fb      	ldr	r3, [r7, #12]
 810e656:	719a      	strb	r2, [r3, #6]
  }
  msecs = 500;
 810e658:	f44f 73fa 	mov.w	r3, #500	; 0x1f4
 810e65c:	813b      	strh	r3, [r7, #8]
  dhcp->request_timeout = (u16_t)((msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS);
 810e65e:	893b      	ldrh	r3, [r7, #8]
 810e660:	f203 13f3 	addw	r3, r3, #499	; 0x1f3
 810e664:	4a06      	ldr	r2, [pc, #24]	; (810e680 <dhcp_check+0x64>)
 810e666:	fb82 1203 	smull	r1, r2, r2, r3
 810e66a:	1152      	asrs	r2, r2, #5
 810e66c:	17db      	asrs	r3, r3, #31
 810e66e:	1ad3      	subs	r3, r2, r3
 810e670:	b29a      	uxth	r2, r3
 810e672:	68fb      	ldr	r3, [r7, #12]
 810e674:	811a      	strh	r2, [r3, #8]
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_check(): set request timeout %"U16_F" msecs\n", msecs));
}
 810e676:	bf00      	nop
 810e678:	3710      	adds	r7, #16
 810e67a:	46bd      	mov	sp, r7
 810e67c:	bd80      	pop	{r7, pc}
 810e67e:	bf00      	nop
 810e680:	10624dd3 	.word	0x10624dd3

0810e684 <dhcp_handle_offer>:
 *
 * @param netif the netif under DHCP control
 */
static void
dhcp_handle_offer(struct netif *netif, struct dhcp_msg *msg_in)
{
 810e684:	b580      	push	{r7, lr}
 810e686:	b084      	sub	sp, #16
 810e688:	af00      	add	r7, sp, #0
 810e68a:	6078      	str	r0, [r7, #4]
 810e68c:	6039      	str	r1, [r7, #0]
  struct dhcp *dhcp = netif_dhcp_data(netif);
 810e68e:	687b      	ldr	r3, [r7, #4]
 810e690:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 810e692:	60fb      	str	r3, [r7, #12]

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_handle_offer(netif=%p) %c%c%"U16_F"\n",
              (void *)netif, netif->name[0], netif->name[1], (u16_t)netif->num));
  /* obtain the server address */
  if (dhcp_option_given(dhcp, DHCP_OPTION_IDX_SERVER_ID)) {
 810e694:	4b0c      	ldr	r3, [pc, #48]	; (810e6c8 <dhcp_handle_offer+0x44>)
 810e696:	789b      	ldrb	r3, [r3, #2]
 810e698:	2b00      	cmp	r3, #0
 810e69a:	d011      	beq.n	810e6c0 <dhcp_handle_offer+0x3c>
    dhcp->request_timeout = 0; /* stop timer */
 810e69c:	68fb      	ldr	r3, [r7, #12]
 810e69e:	2200      	movs	r2, #0
 810e6a0:	811a      	strh	r2, [r3, #8]

    ip_addr_set_ip4_u32(&dhcp->server_ip_addr, lwip_htonl(dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_SERVER_ID)));
 810e6a2:	4b0a      	ldr	r3, [pc, #40]	; (810e6cc <dhcp_handle_offer+0x48>)
 810e6a4:	689b      	ldr	r3, [r3, #8]
 810e6a6:	4618      	mov	r0, r3
 810e6a8:	f7ff ff08 	bl	810e4bc <lwip_htonl>
 810e6ac:	4602      	mov	r2, r0
 810e6ae:	68fb      	ldr	r3, [r7, #12]
 810e6b0:	619a      	str	r2, [r3, #24]
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_handle_offer(): server 0x%08"X32_F"\n",
                ip4_addr_get_u32(ip_2_ip4(&dhcp->server_ip_addr))));
    /* remember offered address */
    ip4_addr_copy(dhcp->offered_ip_addr, msg_in->yiaddr);
 810e6b2:	683b      	ldr	r3, [r7, #0]
 810e6b4:	691a      	ldr	r2, [r3, #16]
 810e6b6:	68fb      	ldr	r3, [r7, #12]
 810e6b8:	61da      	str	r2, [r3, #28]
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_handle_offer(): offer for 0x%08"X32_F"\n",
                ip4_addr_get_u32(&dhcp->offered_ip_addr)));

    dhcp_select(netif);
 810e6ba:	6878      	ldr	r0, [r7, #4]
 810e6bc:	f000 f808 	bl	810e6d0 <dhcp_select>
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS,
                ("dhcp_handle_offer(netif=%p) did not get server ID!\n", (void *)netif));
  }
}
 810e6c0:	bf00      	nop
 810e6c2:	3710      	adds	r7, #16
 810e6c4:	46bd      	mov	sp, r7
 810e6c6:	bd80      	pop	{r7, pc}
 810e6c8:	10004f5c 	.word	0x10004f5c
 810e6cc:	10004f34 	.word	0x10004f34

0810e6d0 <dhcp_select>:
 * @param netif the netif under DHCP control
 * @return lwIP specific error (see error.h)
 */
static err_t
dhcp_select(struct netif *netif)
{
 810e6d0:	b5b0      	push	{r4, r5, r7, lr}
 810e6d2:	b08a      	sub	sp, #40	; 0x28
 810e6d4:	af02      	add	r7, sp, #8
 810e6d6:	6078      	str	r0, [r7, #4]
  u16_t msecs;
  u8_t i;
  struct pbuf *p_out;
  u16_t options_out_len;

  LWIP_ERROR("dhcp_select: netif != NULL", (netif != NULL), return ERR_ARG;);
 810e6d8:	687b      	ldr	r3, [r7, #4]
 810e6da:	2b00      	cmp	r3, #0
 810e6dc:	d109      	bne.n	810e6f2 <dhcp_select+0x22>
 810e6de:	4b71      	ldr	r3, [pc, #452]	; (810e8a4 <dhcp_select+0x1d4>)
 810e6e0:	f240 1277 	movw	r2, #375	; 0x177
 810e6e4:	4970      	ldr	r1, [pc, #448]	; (810e8a8 <dhcp_select+0x1d8>)
 810e6e6:	4871      	ldr	r0, [pc, #452]	; (810e8ac <dhcp_select+0x1dc>)
 810e6e8:	f00d f88a 	bl	811b800 <iprintf>
 810e6ec:	f06f 030f 	mvn.w	r3, #15
 810e6f0:	e0d3      	b.n	810e89a <dhcp_select+0x1ca>
  dhcp = netif_dhcp_data(netif);
 810e6f2:	687b      	ldr	r3, [r7, #4]
 810e6f4:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 810e6f6:	61bb      	str	r3, [r7, #24]
  LWIP_ERROR("dhcp_select: dhcp != NULL", (dhcp != NULL), return ERR_VAL;);
 810e6f8:	69bb      	ldr	r3, [r7, #24]
 810e6fa:	2b00      	cmp	r3, #0
 810e6fc:	d109      	bne.n	810e712 <dhcp_select+0x42>
 810e6fe:	4b69      	ldr	r3, [pc, #420]	; (810e8a4 <dhcp_select+0x1d4>)
 810e700:	f240 1279 	movw	r2, #377	; 0x179
 810e704:	496a      	ldr	r1, [pc, #424]	; (810e8b0 <dhcp_select+0x1e0>)
 810e706:	4869      	ldr	r0, [pc, #420]	; (810e8ac <dhcp_select+0x1dc>)
 810e708:	f00d f87a 	bl	811b800 <iprintf>
 810e70c:	f06f 0305 	mvn.w	r3, #5
 810e710:	e0c3      	b.n	810e89a <dhcp_select+0x1ca>

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_select(netif=%p) %c%c%"U16_F"\n", (void *)netif, netif->name[0], netif->name[1], (u16_t)netif->num));
  dhcp_set_state(dhcp, DHCP_STATE_REQUESTING);
 810e712:	2101      	movs	r1, #1
 810e714:	69b8      	ldr	r0, [r7, #24]
 810e716:	f000 ffe7 	bl	810f6e8 <dhcp_set_state>

  /* create and initialize the DHCP message header */
  p_out = dhcp_create_msg(netif, dhcp, DHCP_REQUEST, &options_out_len);
 810e71a:	f107 030c 	add.w	r3, r7, #12
 810e71e:	2203      	movs	r2, #3
 810e720:	69b9      	ldr	r1, [r7, #24]
 810e722:	6878      	ldr	r0, [r7, #4]
 810e724:	f001 fc9c 	bl	8110060 <dhcp_create_msg>
 810e728:	6178      	str	r0, [r7, #20]
  if (p_out != NULL) {
 810e72a:	697b      	ldr	r3, [r7, #20]
 810e72c:	2b00      	cmp	r3, #0
 810e72e:	f000 8085 	beq.w	810e83c <dhcp_select+0x16c>
    struct dhcp_msg *msg_out = (struct dhcp_msg *)p_out->payload;
 810e732:	697b      	ldr	r3, [r7, #20]
 810e734:	685b      	ldr	r3, [r3, #4]
 810e736:	613b      	str	r3, [r7, #16]
    options_out_len = dhcp_option(options_out_len, msg_out->options, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
 810e738:	89b8      	ldrh	r0, [r7, #12]
 810e73a:	693b      	ldr	r3, [r7, #16]
 810e73c:	f103 01f0 	add.w	r1, r3, #240	; 0xf0
 810e740:	2302      	movs	r3, #2
 810e742:	2239      	movs	r2, #57	; 0x39
 810e744:	f000 ffea 	bl	810f71c <dhcp_option>
 810e748:	4603      	mov	r3, r0
 810e74a:	81bb      	strh	r3, [r7, #12]
    options_out_len = dhcp_option_short(options_out_len, msg_out->options, DHCP_MAX_MSG_LEN(netif));
 810e74c:	89b8      	ldrh	r0, [r7, #12]
 810e74e:	693b      	ldr	r3, [r7, #16]
 810e750:	f103 01f0 	add.w	r1, r3, #240	; 0xf0
 810e754:	687b      	ldr	r3, [r7, #4]
 810e756:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
 810e758:	461a      	mov	r2, r3
 810e75a:	f001 f839 	bl	810f7d0 <dhcp_option_short>
 810e75e:	4603      	mov	r3, r0
 810e760:	81bb      	strh	r3, [r7, #12]

    /* MUST request the offered IP address */
    options_out_len = dhcp_option(options_out_len, msg_out->options, DHCP_OPTION_REQUESTED_IP, 4);
 810e762:	89b8      	ldrh	r0, [r7, #12]
 810e764:	693b      	ldr	r3, [r7, #16]
 810e766:	f103 01f0 	add.w	r1, r3, #240	; 0xf0
 810e76a:	2304      	movs	r3, #4
 810e76c:	2232      	movs	r2, #50	; 0x32
 810e76e:	f000 ffd5 	bl	810f71c <dhcp_option>
 810e772:	4603      	mov	r3, r0
 810e774:	81bb      	strh	r3, [r7, #12]
    options_out_len = dhcp_option_long(options_out_len, msg_out->options, lwip_ntohl(ip4_addr_get_u32(&dhcp->offered_ip_addr)));
 810e776:	89bc      	ldrh	r4, [r7, #12]
 810e778:	693b      	ldr	r3, [r7, #16]
 810e77a:	f103 05f0 	add.w	r5, r3, #240	; 0xf0
 810e77e:	69bb      	ldr	r3, [r7, #24]
 810e780:	69db      	ldr	r3, [r3, #28]
 810e782:	4618      	mov	r0, r3
 810e784:	f7ff fe9a 	bl	810e4bc <lwip_htonl>
 810e788:	4603      	mov	r3, r0
 810e78a:	461a      	mov	r2, r3
 810e78c:	4629      	mov	r1, r5
 810e78e:	4620      	mov	r0, r4
 810e790:	f001 f850 	bl	810f834 <dhcp_option_long>
 810e794:	4603      	mov	r3, r0
 810e796:	81bb      	strh	r3, [r7, #12]

    options_out_len = dhcp_option(options_out_len, msg_out->options, DHCP_OPTION_SERVER_ID, 4);
 810e798:	89b8      	ldrh	r0, [r7, #12]
 810e79a:	693b      	ldr	r3, [r7, #16]
 810e79c:	f103 01f0 	add.w	r1, r3, #240	; 0xf0
 810e7a0:	2304      	movs	r3, #4
 810e7a2:	2236      	movs	r2, #54	; 0x36
 810e7a4:	f000 ffba 	bl	810f71c <dhcp_option>
 810e7a8:	4603      	mov	r3, r0
 810e7aa:	81bb      	strh	r3, [r7, #12]
    options_out_len = dhcp_option_long(options_out_len, msg_out->options, lwip_ntohl(ip4_addr_get_u32(ip_2_ip4(&dhcp->server_ip_addr))));
 810e7ac:	89bc      	ldrh	r4, [r7, #12]
 810e7ae:	693b      	ldr	r3, [r7, #16]
 810e7b0:	f103 05f0 	add.w	r5, r3, #240	; 0xf0
 810e7b4:	69bb      	ldr	r3, [r7, #24]
 810e7b6:	699b      	ldr	r3, [r3, #24]
 810e7b8:	4618      	mov	r0, r3
 810e7ba:	f7ff fe7f 	bl	810e4bc <lwip_htonl>
 810e7be:	4603      	mov	r3, r0
 810e7c0:	461a      	mov	r2, r3
 810e7c2:	4629      	mov	r1, r5
 810e7c4:	4620      	mov	r0, r4
 810e7c6:	f001 f835 	bl	810f834 <dhcp_option_long>
 810e7ca:	4603      	mov	r3, r0
 810e7cc:	81bb      	strh	r3, [r7, #12]

    options_out_len = dhcp_option(options_out_len, msg_out->options, DHCP_OPTION_PARAMETER_REQUEST_LIST, LWIP_ARRAYSIZE(dhcp_discover_request_options));
 810e7ce:	89b8      	ldrh	r0, [r7, #12]
 810e7d0:	693b      	ldr	r3, [r7, #16]
 810e7d2:	f103 01f0 	add.w	r1, r3, #240	; 0xf0
 810e7d6:	2304      	movs	r3, #4
 810e7d8:	2237      	movs	r2, #55	; 0x37
 810e7da:	f000 ff9f 	bl	810f71c <dhcp_option>
 810e7de:	4603      	mov	r3, r0
 810e7e0:	81bb      	strh	r3, [r7, #12]
    for (i = 0; i < LWIP_ARRAYSIZE(dhcp_discover_request_options); i++) {
 810e7e2:	2300      	movs	r3, #0
 810e7e4:	77bb      	strb	r3, [r7, #30]
 810e7e6:	e00e      	b.n	810e806 <dhcp_select+0x136>
      options_out_len = dhcp_option_byte(options_out_len, msg_out->options, dhcp_discover_request_options[i]);
 810e7e8:	89b8      	ldrh	r0, [r7, #12]
 810e7ea:	693b      	ldr	r3, [r7, #16]
 810e7ec:	f103 01f0 	add.w	r1, r3, #240	; 0xf0
 810e7f0:	7fbb      	ldrb	r3, [r7, #30]
 810e7f2:	4a30      	ldr	r2, [pc, #192]	; (810e8b4 <dhcp_select+0x1e4>)
 810e7f4:	5cd3      	ldrb	r3, [r2, r3]
 810e7f6:	461a      	mov	r2, r3
 810e7f8:	f000 ffc4 	bl	810f784 <dhcp_option_byte>
 810e7fc:	4603      	mov	r3, r0
 810e7fe:	81bb      	strh	r3, [r7, #12]
    for (i = 0; i < LWIP_ARRAYSIZE(dhcp_discover_request_options); i++) {
 810e800:	7fbb      	ldrb	r3, [r7, #30]
 810e802:	3301      	adds	r3, #1
 810e804:	77bb      	strb	r3, [r7, #30]
 810e806:	7fbb      	ldrb	r3, [r7, #30]
 810e808:	2b03      	cmp	r3, #3
 810e80a:	d9ed      	bls.n	810e7e8 <dhcp_select+0x118>
#if LWIP_NETIF_HOSTNAME
    options_out_len = dhcp_option_hostname(options_out_len, msg_out->options, netif);
#endif /* LWIP_NETIF_HOSTNAME */

    LWIP_HOOK_DHCP_APPEND_OPTIONS(netif, dhcp, DHCP_STATE_REQUESTING, msg_out, DHCP_REQUEST, &options_out_len);
    dhcp_option_trailer(options_out_len, msg_out->options, p_out);
 810e80c:	89b8      	ldrh	r0, [r7, #12]
 810e80e:	693b      	ldr	r3, [r7, #16]
 810e810:	33f0      	adds	r3, #240	; 0xf0
 810e812:	697a      	ldr	r2, [r7, #20]
 810e814:	4619      	mov	r1, r3
 810e816:	f001 fcf9 	bl	811020c <dhcp_option_trailer>

    /* send broadcast to any DHCP server */
    result = udp_sendto_if_src(dhcp_pcb, p_out, IP_ADDR_BROADCAST, LWIP_IANA_PORT_DHCP_SERVER, netif, IP4_ADDR_ANY);
 810e81a:	4b27      	ldr	r3, [pc, #156]	; (810e8b8 <dhcp_select+0x1e8>)
 810e81c:	6818      	ldr	r0, [r3, #0]
 810e81e:	4b27      	ldr	r3, [pc, #156]	; (810e8bc <dhcp_select+0x1ec>)
 810e820:	9301      	str	r3, [sp, #4]
 810e822:	687b      	ldr	r3, [r7, #4]
 810e824:	9300      	str	r3, [sp, #0]
 810e826:	2343      	movs	r3, #67	; 0x43
 810e828:	4a25      	ldr	r2, [pc, #148]	; (810e8c0 <dhcp_select+0x1f0>)
 810e82a:	6979      	ldr	r1, [r7, #20]
 810e82c:	f00c f802 	bl	811a834 <udp_sendto_if_src>
 810e830:	4603      	mov	r3, r0
 810e832:	77fb      	strb	r3, [r7, #31]
    pbuf_free(p_out);
 810e834:	6978      	ldr	r0, [r7, #20]
 810e836:	f005 ff0f 	bl	8114658 <pbuf_free>
 810e83a:	e001      	b.n	810e840 <dhcp_select+0x170>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_select: REQUESTING\n"));
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING, ("dhcp_select: could not allocate DHCP request\n"));
    result = ERR_MEM;
 810e83c:	23ff      	movs	r3, #255	; 0xff
 810e83e:	77fb      	strb	r3, [r7, #31]
  }
  if (dhcp->tries < 255) {
 810e840:	69bb      	ldr	r3, [r7, #24]
 810e842:	799b      	ldrb	r3, [r3, #6]
 810e844:	2bff      	cmp	r3, #255	; 0xff
 810e846:	d005      	beq.n	810e854 <dhcp_select+0x184>
    dhcp->tries++;
 810e848:	69bb      	ldr	r3, [r7, #24]
 810e84a:	799b      	ldrb	r3, [r3, #6]
 810e84c:	3301      	adds	r3, #1
 810e84e:	b2da      	uxtb	r2, r3
 810e850:	69bb      	ldr	r3, [r7, #24]
 810e852:	719a      	strb	r2, [r3, #6]
  }
  msecs = (u16_t)((dhcp->tries < 6 ? 1 << dhcp->tries : 60) * 1000);
 810e854:	69bb      	ldr	r3, [r7, #24]
 810e856:	799b      	ldrb	r3, [r3, #6]
 810e858:	2b05      	cmp	r3, #5
 810e85a:	d80d      	bhi.n	810e878 <dhcp_select+0x1a8>
 810e85c:	69bb      	ldr	r3, [r7, #24]
 810e85e:	799b      	ldrb	r3, [r3, #6]
 810e860:	461a      	mov	r2, r3
 810e862:	2301      	movs	r3, #1
 810e864:	4093      	lsls	r3, r2
 810e866:	b29b      	uxth	r3, r3
 810e868:	461a      	mov	r2, r3
 810e86a:	0152      	lsls	r2, r2, #5
 810e86c:	1ad2      	subs	r2, r2, r3
 810e86e:	0092      	lsls	r2, r2, #2
 810e870:	4413      	add	r3, r2
 810e872:	00db      	lsls	r3, r3, #3
 810e874:	b29b      	uxth	r3, r3
 810e876:	e001      	b.n	810e87c <dhcp_select+0x1ac>
 810e878:	f64e 2360 	movw	r3, #60000	; 0xea60
 810e87c:	81fb      	strh	r3, [r7, #14]
  dhcp->request_timeout = (u16_t)((msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS);
 810e87e:	89fb      	ldrh	r3, [r7, #14]
 810e880:	f203 13f3 	addw	r3, r3, #499	; 0x1f3
 810e884:	4a0f      	ldr	r2, [pc, #60]	; (810e8c4 <dhcp_select+0x1f4>)
 810e886:	fb82 1203 	smull	r1, r2, r2, r3
 810e88a:	1152      	asrs	r2, r2, #5
 810e88c:	17db      	asrs	r3, r3, #31
 810e88e:	1ad3      	subs	r3, r2, r3
 810e890:	b29a      	uxth	r2, r3
 810e892:	69bb      	ldr	r3, [r7, #24]
 810e894:	811a      	strh	r2, [r3, #8]
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_select(): set request timeout %"U16_F" msecs\n", msecs));
  return result;
 810e896:	f997 301f 	ldrsb.w	r3, [r7, #31]
}
 810e89a:	4618      	mov	r0, r3
 810e89c:	3720      	adds	r7, #32
 810e89e:	46bd      	mov	sp, r7
 810e8a0:	bdb0      	pop	{r4, r5, r7, pc}
 810e8a2:	bf00      	nop
 810e8a4:	0811c788 	.word	0x0811c788
 810e8a8:	0811c864 	.word	0x0811c864
 810e8ac:	0811c818 	.word	0x0811c818
 810e8b0:	0811c880 	.word	0x0811c880
 810e8b4:	10000100 	.word	0x10000100
 810e8b8:	10004f68 	.word	0x10004f68
 810e8bc:	0811f934 	.word	0x0811f934
 810e8c0:	0811f938 	.word	0x0811f938
 810e8c4:	10624dd3 	.word	0x10624dd3

0810e8c8 <dhcp_coarse_tmr>:
 * The DHCP timer that checks for lease renewal/rebind timeouts.
 * Must be called once a minute (see @ref DHCP_COARSE_TIMER_SECS).
 */
void
dhcp_coarse_tmr(void)
{
 810e8c8:	b580      	push	{r7, lr}
 810e8ca:	b082      	sub	sp, #8
 810e8cc:	af00      	add	r7, sp, #0
  struct netif *netif;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_coarse_tmr()\n"));
  /* iterate through all network interfaces */
  NETIF_FOREACH(netif) {
 810e8ce:	4b27      	ldr	r3, [pc, #156]	; (810e96c <dhcp_coarse_tmr+0xa4>)
 810e8d0:	681b      	ldr	r3, [r3, #0]
 810e8d2:	607b      	str	r3, [r7, #4]
 810e8d4:	e042      	b.n	810e95c <dhcp_coarse_tmr+0x94>
    /* only act on DHCP configured interfaces */
    struct dhcp *dhcp = netif_dhcp_data(netif);
 810e8d6:	687b      	ldr	r3, [r7, #4]
 810e8d8:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 810e8da:	603b      	str	r3, [r7, #0]
    if ((dhcp != NULL) && (dhcp->state != DHCP_STATE_OFF)) {
 810e8dc:	683b      	ldr	r3, [r7, #0]
 810e8de:	2b00      	cmp	r3, #0
 810e8e0:	d039      	beq.n	810e956 <dhcp_coarse_tmr+0x8e>
 810e8e2:	683b      	ldr	r3, [r7, #0]
 810e8e4:	795b      	ldrb	r3, [r3, #5]
 810e8e6:	2b00      	cmp	r3, #0
 810e8e8:	d035      	beq.n	810e956 <dhcp_coarse_tmr+0x8e>
      /* compare lease time to expire timeout */
      if (dhcp->t0_timeout && (++dhcp->lease_used == dhcp->t0_timeout)) {
 810e8ea:	683b      	ldr	r3, [r7, #0]
 810e8ec:	8a9b      	ldrh	r3, [r3, #20]
 810e8ee:	2b00      	cmp	r3, #0
 810e8f0:	d012      	beq.n	810e918 <dhcp_coarse_tmr+0x50>
 810e8f2:	683b      	ldr	r3, [r7, #0]
 810e8f4:	8a5b      	ldrh	r3, [r3, #18]
 810e8f6:	3301      	adds	r3, #1
 810e8f8:	b29a      	uxth	r2, r3
 810e8fa:	683b      	ldr	r3, [r7, #0]
 810e8fc:	825a      	strh	r2, [r3, #18]
 810e8fe:	683b      	ldr	r3, [r7, #0]
 810e900:	8a5a      	ldrh	r2, [r3, #18]
 810e902:	683b      	ldr	r3, [r7, #0]
 810e904:	8a9b      	ldrh	r3, [r3, #20]
 810e906:	429a      	cmp	r2, r3
 810e908:	d106      	bne.n	810e918 <dhcp_coarse_tmr+0x50>
        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_coarse_tmr(): t0 timeout\n"));
        /* this clients' lease time has expired */
        dhcp_release_and_stop(netif);
 810e90a:	6878      	ldr	r0, [r7, #4]
 810e90c:	f000 fe52 	bl	810f5b4 <dhcp_release_and_stop>
        dhcp_start(netif);
 810e910:	6878      	ldr	r0, [r7, #4]
 810e912:	f000 f989 	bl	810ec28 <dhcp_start>
 810e916:	e01e      	b.n	810e956 <dhcp_coarse_tmr+0x8e>
        /* timer is active (non zero), and triggers (zeroes) now? */
      } else if (dhcp->t2_rebind_time && (dhcp->t2_rebind_time-- == 1)) {
 810e918:	683b      	ldr	r3, [r7, #0]
 810e91a:	8a1b      	ldrh	r3, [r3, #16]
 810e91c:	2b00      	cmp	r3, #0
 810e91e:	d00b      	beq.n	810e938 <dhcp_coarse_tmr+0x70>
 810e920:	683b      	ldr	r3, [r7, #0]
 810e922:	8a1b      	ldrh	r3, [r3, #16]
 810e924:	1e5a      	subs	r2, r3, #1
 810e926:	b291      	uxth	r1, r2
 810e928:	683a      	ldr	r2, [r7, #0]
 810e92a:	8211      	strh	r1, [r2, #16]
 810e92c:	2b01      	cmp	r3, #1
 810e92e:	d103      	bne.n	810e938 <dhcp_coarse_tmr+0x70>
        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_coarse_tmr(): t2 timeout\n"));
        /* this clients' rebind timeout triggered */
        dhcp_t2_timeout(netif);
 810e930:	6878      	ldr	r0, [r7, #4]
 810e932:	f000 f8c6 	bl	810eac2 <dhcp_t2_timeout>
 810e936:	e00e      	b.n	810e956 <dhcp_coarse_tmr+0x8e>
        /* timer is active (non zero), and triggers (zeroes) now */
      } else if (dhcp->t1_renew_time && (dhcp->t1_renew_time-- == 1)) {
 810e938:	683b      	ldr	r3, [r7, #0]
 810e93a:	89db      	ldrh	r3, [r3, #14]
 810e93c:	2b00      	cmp	r3, #0
 810e93e:	d00a      	beq.n	810e956 <dhcp_coarse_tmr+0x8e>
 810e940:	683b      	ldr	r3, [r7, #0]
 810e942:	89db      	ldrh	r3, [r3, #14]
 810e944:	1e5a      	subs	r2, r3, #1
 810e946:	b291      	uxth	r1, r2
 810e948:	683a      	ldr	r2, [r7, #0]
 810e94a:	81d1      	strh	r1, [r2, #14]
 810e94c:	2b01      	cmp	r3, #1
 810e94e:	d102      	bne.n	810e956 <dhcp_coarse_tmr+0x8e>
        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_coarse_tmr(): t1 timeout\n"));
        /* this clients' renewal timeout triggered */
        dhcp_t1_timeout(netif);
 810e950:	6878      	ldr	r0, [r7, #4]
 810e952:	f000 f888 	bl	810ea66 <dhcp_t1_timeout>
  NETIF_FOREACH(netif) {
 810e956:	687b      	ldr	r3, [r7, #4]
 810e958:	681b      	ldr	r3, [r3, #0]
 810e95a:	607b      	str	r3, [r7, #4]
 810e95c:	687b      	ldr	r3, [r7, #4]
 810e95e:	2b00      	cmp	r3, #0
 810e960:	d1b9      	bne.n	810e8d6 <dhcp_coarse_tmr+0xe>
      }
    }
  }
}
 810e962:	bf00      	nop
 810e964:	bf00      	nop
 810e966:	3708      	adds	r7, #8
 810e968:	46bd      	mov	sp, r7
 810e96a:	bd80      	pop	{r7, pc}
 810e96c:	1000843c 	.word	0x1000843c

0810e970 <dhcp_fine_tmr>:
 * A DHCP server is expected to respond within a short period of time.
 * This timer checks whether an outstanding DHCP request is timed out.
 */
void
dhcp_fine_tmr(void)
{
 810e970:	b580      	push	{r7, lr}
 810e972:	b082      	sub	sp, #8
 810e974:	af00      	add	r7, sp, #0
  struct netif *netif;
  /* loop through netif's */
  NETIF_FOREACH(netif) {
 810e976:	4b16      	ldr	r3, [pc, #88]	; (810e9d0 <dhcp_fine_tmr+0x60>)
 810e978:	681b      	ldr	r3, [r3, #0]
 810e97a:	607b      	str	r3, [r7, #4]
 810e97c:	e020      	b.n	810e9c0 <dhcp_fine_tmr+0x50>
    struct dhcp *dhcp = netif_dhcp_data(netif);
 810e97e:	687b      	ldr	r3, [r7, #4]
 810e980:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 810e982:	603b      	str	r3, [r7, #0]
    /* only act on DHCP configured interfaces */
    if (dhcp != NULL) {
 810e984:	683b      	ldr	r3, [r7, #0]
 810e986:	2b00      	cmp	r3, #0
 810e988:	d017      	beq.n	810e9ba <dhcp_fine_tmr+0x4a>
      /* timer is active (non zero), and is about to trigger now */
      if (dhcp->request_timeout > 1) {
 810e98a:	683b      	ldr	r3, [r7, #0]
 810e98c:	891b      	ldrh	r3, [r3, #8]
 810e98e:	2b01      	cmp	r3, #1
 810e990:	d906      	bls.n	810e9a0 <dhcp_fine_tmr+0x30>
        dhcp->request_timeout--;
 810e992:	683b      	ldr	r3, [r7, #0]
 810e994:	891b      	ldrh	r3, [r3, #8]
 810e996:	3b01      	subs	r3, #1
 810e998:	b29a      	uxth	r2, r3
 810e99a:	683b      	ldr	r3, [r7, #0]
 810e99c:	811a      	strh	r2, [r3, #8]
 810e99e:	e00c      	b.n	810e9ba <dhcp_fine_tmr+0x4a>
      } else if (dhcp->request_timeout == 1) {
 810e9a0:	683b      	ldr	r3, [r7, #0]
 810e9a2:	891b      	ldrh	r3, [r3, #8]
 810e9a4:	2b01      	cmp	r3, #1
 810e9a6:	d108      	bne.n	810e9ba <dhcp_fine_tmr+0x4a>
        dhcp->request_timeout--;
 810e9a8:	683b      	ldr	r3, [r7, #0]
 810e9aa:	891b      	ldrh	r3, [r3, #8]
 810e9ac:	3b01      	subs	r3, #1
 810e9ae:	b29a      	uxth	r2, r3
 810e9b0:	683b      	ldr	r3, [r7, #0]
 810e9b2:	811a      	strh	r2, [r3, #8]
        /* { dhcp->request_timeout == 0 } */
        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_fine_tmr(): request timeout\n"));
        /* this client's request timeout triggered */
        dhcp_timeout(netif);
 810e9b4:	6878      	ldr	r0, [r7, #4]
 810e9b6:	f000 f80d 	bl	810e9d4 <dhcp_timeout>
  NETIF_FOREACH(netif) {
 810e9ba:	687b      	ldr	r3, [r7, #4]
 810e9bc:	681b      	ldr	r3, [r3, #0]
 810e9be:	607b      	str	r3, [r7, #4]
 810e9c0:	687b      	ldr	r3, [r7, #4]
 810e9c2:	2b00      	cmp	r3, #0
 810e9c4:	d1db      	bne.n	810e97e <dhcp_fine_tmr+0xe>
      }
    }
  }
}
 810e9c6:	bf00      	nop
 810e9c8:	bf00      	nop
 810e9ca:	3708      	adds	r7, #8
 810e9cc:	46bd      	mov	sp, r7
 810e9ce:	bd80      	pop	{r7, pc}
 810e9d0:	1000843c 	.word	0x1000843c

0810e9d4 <dhcp_timeout>:
 *
 * @param netif the netif under DHCP control
 */
static void
dhcp_timeout(struct netif *netif)
{
 810e9d4:	b580      	push	{r7, lr}
 810e9d6:	b084      	sub	sp, #16
 810e9d8:	af00      	add	r7, sp, #0
 810e9da:	6078      	str	r0, [r7, #4]
  struct dhcp *dhcp = netif_dhcp_data(netif);
 810e9dc:	687b      	ldr	r3, [r7, #4]
 810e9de:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 810e9e0:	60fb      	str	r3, [r7, #12]

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_timeout()\n"));
  /* back-off period has passed, or server selection timed out */
  if ((dhcp->state == DHCP_STATE_BACKING_OFF) || (dhcp->state == DHCP_STATE_SELECTING)) {
 810e9e2:	68fb      	ldr	r3, [r7, #12]
 810e9e4:	795b      	ldrb	r3, [r3, #5]
 810e9e6:	2b0c      	cmp	r3, #12
 810e9e8:	d003      	beq.n	810e9f2 <dhcp_timeout+0x1e>
 810e9ea:	68fb      	ldr	r3, [r7, #12]
 810e9ec:	795b      	ldrb	r3, [r3, #5]
 810e9ee:	2b06      	cmp	r3, #6
 810e9f0:	d103      	bne.n	810e9fa <dhcp_timeout+0x26>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_timeout(): restarting discovery\n"));
    dhcp_discover(netif);
 810e9f2:	6878      	ldr	r0, [r7, #4]
 810e9f4:	f000 fa74 	bl	810eee0 <dhcp_discover>
      dhcp_reboot(netif);
    } else {
      dhcp_discover(netif);
    }
  }
}
 810e9f8:	e031      	b.n	810ea5e <dhcp_timeout+0x8a>
  } else if (dhcp->state == DHCP_STATE_REQUESTING) {
 810e9fa:	68fb      	ldr	r3, [r7, #12]
 810e9fc:	795b      	ldrb	r3, [r3, #5]
 810e9fe:	2b01      	cmp	r3, #1
 810ea00:	d10e      	bne.n	810ea20 <dhcp_timeout+0x4c>
    if (dhcp->tries <= 5) {
 810ea02:	68fb      	ldr	r3, [r7, #12]
 810ea04:	799b      	ldrb	r3, [r3, #6]
 810ea06:	2b05      	cmp	r3, #5
 810ea08:	d803      	bhi.n	810ea12 <dhcp_timeout+0x3e>
      dhcp_select(netif);
 810ea0a:	6878      	ldr	r0, [r7, #4]
 810ea0c:	f7ff fe60 	bl	810e6d0 <dhcp_select>
}
 810ea10:	e025      	b.n	810ea5e <dhcp_timeout+0x8a>
      dhcp_release_and_stop(netif);
 810ea12:	6878      	ldr	r0, [r7, #4]
 810ea14:	f000 fdce 	bl	810f5b4 <dhcp_release_and_stop>
      dhcp_start(netif);
 810ea18:	6878      	ldr	r0, [r7, #4]
 810ea1a:	f000 f905 	bl	810ec28 <dhcp_start>
}
 810ea1e:	e01e      	b.n	810ea5e <dhcp_timeout+0x8a>
  } else if (dhcp->state == DHCP_STATE_CHECKING) {
 810ea20:	68fb      	ldr	r3, [r7, #12]
 810ea22:	795b      	ldrb	r3, [r3, #5]
 810ea24:	2b08      	cmp	r3, #8
 810ea26:	d10b      	bne.n	810ea40 <dhcp_timeout+0x6c>
    if (dhcp->tries <= 1) {
 810ea28:	68fb      	ldr	r3, [r7, #12]
 810ea2a:	799b      	ldrb	r3, [r3, #6]
 810ea2c:	2b01      	cmp	r3, #1
 810ea2e:	d803      	bhi.n	810ea38 <dhcp_timeout+0x64>
      dhcp_check(netif);
 810ea30:	6878      	ldr	r0, [r7, #4]
 810ea32:	f7ff fdf3 	bl	810e61c <dhcp_check>
}
 810ea36:	e012      	b.n	810ea5e <dhcp_timeout+0x8a>
      dhcp_bind(netif);
 810ea38:	6878      	ldr	r0, [r7, #4]
 810ea3a:	f000 faf3 	bl	810f024 <dhcp_bind>
}
 810ea3e:	e00e      	b.n	810ea5e <dhcp_timeout+0x8a>
  } else if (dhcp->state == DHCP_STATE_REBOOTING) {
 810ea40:	68fb      	ldr	r3, [r7, #12]
 810ea42:	795b      	ldrb	r3, [r3, #5]
 810ea44:	2b03      	cmp	r3, #3
 810ea46:	d10a      	bne.n	810ea5e <dhcp_timeout+0x8a>
    if (dhcp->tries < REBOOT_TRIES) {
 810ea48:	68fb      	ldr	r3, [r7, #12]
 810ea4a:	799b      	ldrb	r3, [r3, #6]
 810ea4c:	2b01      	cmp	r3, #1
 810ea4e:	d803      	bhi.n	810ea58 <dhcp_timeout+0x84>
      dhcp_reboot(netif);
 810ea50:	6878      	ldr	r0, [r7, #4]
 810ea52:	f000 fcf9 	bl	810f448 <dhcp_reboot>
}
 810ea56:	e002      	b.n	810ea5e <dhcp_timeout+0x8a>
      dhcp_discover(netif);
 810ea58:	6878      	ldr	r0, [r7, #4]
 810ea5a:	f000 fa41 	bl	810eee0 <dhcp_discover>
}
 810ea5e:	bf00      	nop
 810ea60:	3710      	adds	r7, #16
 810ea62:	46bd      	mov	sp, r7
 810ea64:	bd80      	pop	{r7, pc}

0810ea66 <dhcp_t1_timeout>:
 *
 * @param netif the netif under DHCP control
 */
static void
dhcp_t1_timeout(struct netif *netif)
{
 810ea66:	b580      	push	{r7, lr}
 810ea68:	b084      	sub	sp, #16
 810ea6a:	af00      	add	r7, sp, #0
 810ea6c:	6078      	str	r0, [r7, #4]
  struct dhcp *dhcp = netif_dhcp_data(netif);
 810ea6e:	687b      	ldr	r3, [r7, #4]
 810ea70:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 810ea72:	60fb      	str	r3, [r7, #12]

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_t1_timeout()\n"));
  if ((dhcp->state == DHCP_STATE_REQUESTING) || (dhcp->state == DHCP_STATE_BOUND) ||
 810ea74:	68fb      	ldr	r3, [r7, #12]
 810ea76:	795b      	ldrb	r3, [r3, #5]
 810ea78:	2b01      	cmp	r3, #1
 810ea7a:	d007      	beq.n	810ea8c <dhcp_t1_timeout+0x26>
 810ea7c:	68fb      	ldr	r3, [r7, #12]
 810ea7e:	795b      	ldrb	r3, [r3, #5]
 810ea80:	2b0a      	cmp	r3, #10
 810ea82:	d003      	beq.n	810ea8c <dhcp_t1_timeout+0x26>
      (dhcp->state == DHCP_STATE_RENEWING)) {
 810ea84:	68fb      	ldr	r3, [r7, #12]
 810ea86:	795b      	ldrb	r3, [r3, #5]
  if ((dhcp->state == DHCP_STATE_REQUESTING) || (dhcp->state == DHCP_STATE_BOUND) ||
 810ea88:	2b05      	cmp	r3, #5
 810ea8a:	d116      	bne.n	810eaba <dhcp_t1_timeout+0x54>
     * eventually time-out if renew tries fail. */
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE,
                ("dhcp_t1_timeout(): must renew\n"));
    /* This slightly different to RFC2131: DHCPREQUEST will be sent from state
       DHCP_STATE_RENEWING, not DHCP_STATE_BOUND */
    dhcp_renew(netif);
 810ea8c:	6878      	ldr	r0, [r7, #4]
 810ea8e:	f000 fba3 	bl	810f1d8 <dhcp_renew>
    /* Calculate next timeout */
    if (((dhcp->t2_timeout - dhcp->lease_used) / 2) >= ((60 + DHCP_COARSE_TIMER_SECS / 2) / DHCP_COARSE_TIMER_SECS)) {
 810ea92:	68fb      	ldr	r3, [r7, #12]
 810ea94:	899b      	ldrh	r3, [r3, #12]
 810ea96:	461a      	mov	r2, r3
 810ea98:	68fb      	ldr	r3, [r7, #12]
 810ea9a:	8a5b      	ldrh	r3, [r3, #18]
 810ea9c:	1ad3      	subs	r3, r2, r3
 810ea9e:	2b01      	cmp	r3, #1
 810eaa0:	dd0b      	ble.n	810eaba <dhcp_t1_timeout+0x54>
      dhcp->t1_renew_time = (u16_t)((dhcp->t2_timeout - dhcp->lease_used) / 2);
 810eaa2:	68fb      	ldr	r3, [r7, #12]
 810eaa4:	899b      	ldrh	r3, [r3, #12]
 810eaa6:	461a      	mov	r2, r3
 810eaa8:	68fb      	ldr	r3, [r7, #12]
 810eaaa:	8a5b      	ldrh	r3, [r3, #18]
 810eaac:	1ad3      	subs	r3, r2, r3
 810eaae:	0fda      	lsrs	r2, r3, #31
 810eab0:	4413      	add	r3, r2
 810eab2:	105b      	asrs	r3, r3, #1
 810eab4:	b29a      	uxth	r2, r3
 810eab6:	68fb      	ldr	r3, [r7, #12]
 810eab8:	81da      	strh	r2, [r3, #14]
    }
  }
}
 810eaba:	bf00      	nop
 810eabc:	3710      	adds	r7, #16
 810eabe:	46bd      	mov	sp, r7
 810eac0:	bd80      	pop	{r7, pc}

0810eac2 <dhcp_t2_timeout>:
 *
 * @param netif the netif under DHCP control
 */
static void
dhcp_t2_timeout(struct netif *netif)
{
 810eac2:	b580      	push	{r7, lr}
 810eac4:	b084      	sub	sp, #16
 810eac6:	af00      	add	r7, sp, #0
 810eac8:	6078      	str	r0, [r7, #4]
  struct dhcp *dhcp = netif_dhcp_data(netif);
 810eaca:	687b      	ldr	r3, [r7, #4]
 810eacc:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 810eace:	60fb      	str	r3, [r7, #12]

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_t2_timeout()\n"));
  if ((dhcp->state == DHCP_STATE_REQUESTING) || (dhcp->state == DHCP_STATE_BOUND) ||
 810ead0:	68fb      	ldr	r3, [r7, #12]
 810ead2:	795b      	ldrb	r3, [r3, #5]
 810ead4:	2b01      	cmp	r3, #1
 810ead6:	d00b      	beq.n	810eaf0 <dhcp_t2_timeout+0x2e>
 810ead8:	68fb      	ldr	r3, [r7, #12]
 810eada:	795b      	ldrb	r3, [r3, #5]
 810eadc:	2b0a      	cmp	r3, #10
 810eade:	d007      	beq.n	810eaf0 <dhcp_t2_timeout+0x2e>
      (dhcp->state == DHCP_STATE_RENEWING) || (dhcp->state == DHCP_STATE_REBINDING)) {
 810eae0:	68fb      	ldr	r3, [r7, #12]
 810eae2:	795b      	ldrb	r3, [r3, #5]
  if ((dhcp->state == DHCP_STATE_REQUESTING) || (dhcp->state == DHCP_STATE_BOUND) ||
 810eae4:	2b05      	cmp	r3, #5
 810eae6:	d003      	beq.n	810eaf0 <dhcp_t2_timeout+0x2e>
      (dhcp->state == DHCP_STATE_RENEWING) || (dhcp->state == DHCP_STATE_REBINDING)) {
 810eae8:	68fb      	ldr	r3, [r7, #12]
 810eaea:	795b      	ldrb	r3, [r3, #5]
 810eaec:	2b04      	cmp	r3, #4
 810eaee:	d116      	bne.n	810eb1e <dhcp_t2_timeout+0x5c>
    /* just retry to rebind */
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE,
                ("dhcp_t2_timeout(): must rebind\n"));
    /* This slightly different to RFC2131: DHCPREQUEST will be sent from state
       DHCP_STATE_REBINDING, not DHCP_STATE_BOUND */
    dhcp_rebind(netif);
 810eaf0:	6878      	ldr	r0, [r7, #4]
 810eaf2:	f000 fc0d 	bl	810f310 <dhcp_rebind>
    /* Calculate next timeout */
    if (((dhcp->t0_timeout - dhcp->lease_used) / 2) >= ((60 + DHCP_COARSE_TIMER_SECS / 2) / DHCP_COARSE_TIMER_SECS)) {
 810eaf6:	68fb      	ldr	r3, [r7, #12]
 810eaf8:	8a9b      	ldrh	r3, [r3, #20]
 810eafa:	461a      	mov	r2, r3
 810eafc:	68fb      	ldr	r3, [r7, #12]
 810eafe:	8a5b      	ldrh	r3, [r3, #18]
 810eb00:	1ad3      	subs	r3, r2, r3
 810eb02:	2b01      	cmp	r3, #1
 810eb04:	dd0b      	ble.n	810eb1e <dhcp_t2_timeout+0x5c>
      dhcp->t2_rebind_time = (u16_t)((dhcp->t0_timeout - dhcp->lease_used) / 2);
 810eb06:	68fb      	ldr	r3, [r7, #12]
 810eb08:	8a9b      	ldrh	r3, [r3, #20]
 810eb0a:	461a      	mov	r2, r3
 810eb0c:	68fb      	ldr	r3, [r7, #12]
 810eb0e:	8a5b      	ldrh	r3, [r3, #18]
 810eb10:	1ad3      	subs	r3, r2, r3
 810eb12:	0fda      	lsrs	r2, r3, #31
 810eb14:	4413      	add	r3, r2
 810eb16:	105b      	asrs	r3, r3, #1
 810eb18:	b29a      	uxth	r2, r3
 810eb1a:	68fb      	ldr	r3, [r7, #12]
 810eb1c:	821a      	strh	r2, [r3, #16]
    }
  }
}
 810eb1e:	bf00      	nop
 810eb20:	3710      	adds	r7, #16
 810eb22:	46bd      	mov	sp, r7
 810eb24:	bd80      	pop	{r7, pc}
	...

0810eb28 <dhcp_handle_ack>:
 *
 * @param netif the netif under DHCP control
 */
static void
dhcp_handle_ack(struct netif *netif, struct dhcp_msg *msg_in)
{
 810eb28:	b580      	push	{r7, lr}
 810eb2a:	b086      	sub	sp, #24
 810eb2c:	af00      	add	r7, sp, #0
 810eb2e:	6078      	str	r0, [r7, #4]
 810eb30:	6039      	str	r1, [r7, #0]
  struct dhcp *dhcp = netif_dhcp_data(netif);
 810eb32:	687b      	ldr	r3, [r7, #4]
 810eb34:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 810eb36:	613b      	str	r3, [r7, #16]
#if LWIP_DHCP_GET_NTP_SRV
  ip4_addr_t ntp_server_addrs[LWIP_DHCP_MAX_NTP_SERVERS];
#endif

  /* clear options we might not get from the ACK */
  ip4_addr_set_zero(&dhcp->offered_sn_mask);
 810eb38:	693b      	ldr	r3, [r7, #16]
 810eb3a:	2200      	movs	r2, #0
 810eb3c:	621a      	str	r2, [r3, #32]
  ip4_addr_set_zero(&dhcp->offered_gw_addr);
 810eb3e:	693b      	ldr	r3, [r7, #16]
 810eb40:	2200      	movs	r2, #0
 810eb42:	625a      	str	r2, [r3, #36]	; 0x24
#if LWIP_DHCP_BOOTP_FILE
  ip4_addr_set_zero(&dhcp->offered_si_addr);
#endif /* LWIP_DHCP_BOOTP_FILE */

  /* lease time given? */
  if (dhcp_option_given(dhcp, DHCP_OPTION_IDX_LEASE_TIME)) {
 810eb44:	4b36      	ldr	r3, [pc, #216]	; (810ec20 <dhcp_handle_ack+0xf8>)
 810eb46:	78db      	ldrb	r3, [r3, #3]
 810eb48:	2b00      	cmp	r3, #0
 810eb4a:	d003      	beq.n	810eb54 <dhcp_handle_ack+0x2c>
    /* remember offered lease time */
    dhcp->offered_t0_lease = dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_LEASE_TIME);
 810eb4c:	4b35      	ldr	r3, [pc, #212]	; (810ec24 <dhcp_handle_ack+0xfc>)
 810eb4e:	68da      	ldr	r2, [r3, #12]
 810eb50:	693b      	ldr	r3, [r7, #16]
 810eb52:	629a      	str	r2, [r3, #40]	; 0x28
  }
  /* renewal period given? */
  if (dhcp_option_given(dhcp, DHCP_OPTION_IDX_T1)) {
 810eb54:	4b32      	ldr	r3, [pc, #200]	; (810ec20 <dhcp_handle_ack+0xf8>)
 810eb56:	791b      	ldrb	r3, [r3, #4]
 810eb58:	2b00      	cmp	r3, #0
 810eb5a:	d004      	beq.n	810eb66 <dhcp_handle_ack+0x3e>
    /* remember given renewal period */
    dhcp->offered_t1_renew = dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_T1);
 810eb5c:	4b31      	ldr	r3, [pc, #196]	; (810ec24 <dhcp_handle_ack+0xfc>)
 810eb5e:	691a      	ldr	r2, [r3, #16]
 810eb60:	693b      	ldr	r3, [r7, #16]
 810eb62:	62da      	str	r2, [r3, #44]	; 0x2c
 810eb64:	e004      	b.n	810eb70 <dhcp_handle_ack+0x48>
  } else {
    /* calculate safe periods for renewal */
    dhcp->offered_t1_renew = dhcp->offered_t0_lease / 2;
 810eb66:	693b      	ldr	r3, [r7, #16]
 810eb68:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 810eb6a:	085a      	lsrs	r2, r3, #1
 810eb6c:	693b      	ldr	r3, [r7, #16]
 810eb6e:	62da      	str	r2, [r3, #44]	; 0x2c
  }

  /* renewal period given? */
  if (dhcp_option_given(dhcp, DHCP_OPTION_IDX_T2)) {
 810eb70:	4b2b      	ldr	r3, [pc, #172]	; (810ec20 <dhcp_handle_ack+0xf8>)
 810eb72:	795b      	ldrb	r3, [r3, #5]
 810eb74:	2b00      	cmp	r3, #0
 810eb76:	d004      	beq.n	810eb82 <dhcp_handle_ack+0x5a>
    /* remember given rebind period */
    dhcp->offered_t2_rebind = dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_T2);
 810eb78:	4b2a      	ldr	r3, [pc, #168]	; (810ec24 <dhcp_handle_ack+0xfc>)
 810eb7a:	695a      	ldr	r2, [r3, #20]
 810eb7c:	693b      	ldr	r3, [r7, #16]
 810eb7e:	631a      	str	r2, [r3, #48]	; 0x30
 810eb80:	e007      	b.n	810eb92 <dhcp_handle_ack+0x6a>
  } else {
    /* calculate safe periods for rebinding (offered_t0_lease * 0.875 -> 87.5%)*/
    dhcp->offered_t2_rebind = (dhcp->offered_t0_lease * 7U) / 8U;
 810eb82:	693b      	ldr	r3, [r7, #16]
 810eb84:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 810eb86:	4613      	mov	r3, r2
 810eb88:	00db      	lsls	r3, r3, #3
 810eb8a:	1a9b      	subs	r3, r3, r2
 810eb8c:	08da      	lsrs	r2, r3, #3
 810eb8e:	693b      	ldr	r3, [r7, #16]
 810eb90:	631a      	str	r2, [r3, #48]	; 0x30
  }

  /* (y)our internet address */
  ip4_addr_copy(dhcp->offered_ip_addr, msg_in->yiaddr);
 810eb92:	683b      	ldr	r3, [r7, #0]
 810eb94:	691a      	ldr	r2, [r3, #16]
 810eb96:	693b      	ldr	r3, [r7, #16]
 810eb98:	61da      	str	r2, [r3, #28]
     boot file name copied in dhcp_parse_reply if not overloaded */
  ip4_addr_copy(dhcp->offered_si_addr, msg_in->siaddr);
#endif /* LWIP_DHCP_BOOTP_FILE */

  /* subnet mask given? */
  if (dhcp_option_given(dhcp, DHCP_OPTION_IDX_SUBNET_MASK)) {
 810eb9a:	4b21      	ldr	r3, [pc, #132]	; (810ec20 <dhcp_handle_ack+0xf8>)
 810eb9c:	799b      	ldrb	r3, [r3, #6]
 810eb9e:	2b00      	cmp	r3, #0
 810eba0:	d00b      	beq.n	810ebba <dhcp_handle_ack+0x92>
    /* remember given subnet mask */
    ip4_addr_set_u32(&dhcp->offered_sn_mask, lwip_htonl(dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_SUBNET_MASK)));
 810eba2:	4b20      	ldr	r3, [pc, #128]	; (810ec24 <dhcp_handle_ack+0xfc>)
 810eba4:	699b      	ldr	r3, [r3, #24]
 810eba6:	4618      	mov	r0, r3
 810eba8:	f7ff fc88 	bl	810e4bc <lwip_htonl>
 810ebac:	4602      	mov	r2, r0
 810ebae:	693b      	ldr	r3, [r7, #16]
 810ebb0:	621a      	str	r2, [r3, #32]
    dhcp->subnet_mask_given = 1;
 810ebb2:	693b      	ldr	r3, [r7, #16]
 810ebb4:	2201      	movs	r2, #1
 810ebb6:	71da      	strb	r2, [r3, #7]
 810ebb8:	e002      	b.n	810ebc0 <dhcp_handle_ack+0x98>
  } else {
    dhcp->subnet_mask_given = 0;
 810ebba:	693b      	ldr	r3, [r7, #16]
 810ebbc:	2200      	movs	r2, #0
 810ebbe:	71da      	strb	r2, [r3, #7]
  }

  /* gateway router */
  if (dhcp_option_given(dhcp, DHCP_OPTION_IDX_ROUTER)) {
 810ebc0:	4b17      	ldr	r3, [pc, #92]	; (810ec20 <dhcp_handle_ack+0xf8>)
 810ebc2:	79db      	ldrb	r3, [r3, #7]
 810ebc4:	2b00      	cmp	r3, #0
 810ebc6:	d007      	beq.n	810ebd8 <dhcp_handle_ack+0xb0>
    ip4_addr_set_u32(&dhcp->offered_gw_addr, lwip_htonl(dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_ROUTER)));
 810ebc8:	4b16      	ldr	r3, [pc, #88]	; (810ec24 <dhcp_handle_ack+0xfc>)
 810ebca:	69db      	ldr	r3, [r3, #28]
 810ebcc:	4618      	mov	r0, r3
 810ebce:	f7ff fc75 	bl	810e4bc <lwip_htonl>
 810ebd2:	4602      	mov	r2, r0
 810ebd4:	693b      	ldr	r3, [r7, #16]
 810ebd6:	625a      	str	r2, [r3, #36]	; 0x24
  dhcp_set_ntp_servers(n, ntp_server_addrs);
#endif /* LWIP_DHCP_GET_NTP_SRV */

#if LWIP_DHCP_PROVIDE_DNS_SERVERS
  /* DNS servers */
  for (n = 0; (n < LWIP_DHCP_PROVIDE_DNS_SERVERS) && dhcp_option_given(dhcp, DHCP_OPTION_IDX_DNS_SERVER + n); n++) {
 810ebd8:	2300      	movs	r3, #0
 810ebda:	75fb      	strb	r3, [r7, #23]
 810ebdc:	e013      	b.n	810ec06 <dhcp_handle_ack+0xde>
    ip_addr_t dns_addr;
    ip_addr_set_ip4_u32_val(dns_addr, lwip_htonl(dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_DNS_SERVER + n)));
 810ebde:	7dfb      	ldrb	r3, [r7, #23]
 810ebe0:	3308      	adds	r3, #8
 810ebe2:	4a10      	ldr	r2, [pc, #64]	; (810ec24 <dhcp_handle_ack+0xfc>)
 810ebe4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 810ebe8:	4618      	mov	r0, r3
 810ebea:	f7ff fc67 	bl	810e4bc <lwip_htonl>
 810ebee:	4603      	mov	r3, r0
 810ebf0:	60fb      	str	r3, [r7, #12]
    dns_setserver(n, &dns_addr);
 810ebf2:	f107 020c 	add.w	r2, r7, #12
 810ebf6:	7dfb      	ldrb	r3, [r7, #23]
 810ebf8:	4611      	mov	r1, r2
 810ebfa:	4618      	mov	r0, r3
 810ebfc:	f001 fb62 	bl	81102c4 <dns_setserver>
  for (n = 0; (n < LWIP_DHCP_PROVIDE_DNS_SERVERS) && dhcp_option_given(dhcp, DHCP_OPTION_IDX_DNS_SERVER + n); n++) {
 810ec00:	7dfb      	ldrb	r3, [r7, #23]
 810ec02:	3301      	adds	r3, #1
 810ec04:	75fb      	strb	r3, [r7, #23]
 810ec06:	7dfb      	ldrb	r3, [r7, #23]
 810ec08:	2b01      	cmp	r3, #1
 810ec0a:	d805      	bhi.n	810ec18 <dhcp_handle_ack+0xf0>
 810ec0c:	7dfb      	ldrb	r3, [r7, #23]
 810ec0e:	3308      	adds	r3, #8
 810ec10:	4a03      	ldr	r2, [pc, #12]	; (810ec20 <dhcp_handle_ack+0xf8>)
 810ec12:	5cd3      	ldrb	r3, [r2, r3]
 810ec14:	2b00      	cmp	r3, #0
 810ec16:	d1e2      	bne.n	810ebde <dhcp_handle_ack+0xb6>
  }
#endif /* LWIP_DHCP_PROVIDE_DNS_SERVERS */
}
 810ec18:	bf00      	nop
 810ec1a:	3718      	adds	r7, #24
 810ec1c:	46bd      	mov	sp, r7
 810ec1e:	bd80      	pop	{r7, pc}
 810ec20:	10004f5c 	.word	0x10004f5c
 810ec24:	10004f34 	.word	0x10004f34

0810ec28 <dhcp_start>:
 * - ERR_OK - No error
 * - ERR_MEM - Out of memory
 */
err_t
dhcp_start(struct netif *netif)
{
 810ec28:	b580      	push	{r7, lr}
 810ec2a:	b084      	sub	sp, #16
 810ec2c:	af00      	add	r7, sp, #0
 810ec2e:	6078      	str	r0, [r7, #4]
  struct dhcp *dhcp;
  err_t result;

  LWIP_ASSERT_CORE_LOCKED();
  LWIP_ERROR("netif != NULL", (netif != NULL), return ERR_ARG;);
 810ec30:	687b      	ldr	r3, [r7, #4]
 810ec32:	2b00      	cmp	r3, #0
 810ec34:	d109      	bne.n	810ec4a <dhcp_start+0x22>
 810ec36:	4b37      	ldr	r3, [pc, #220]	; (810ed14 <dhcp_start+0xec>)
 810ec38:	f240 22e7 	movw	r2, #743	; 0x2e7
 810ec3c:	4936      	ldr	r1, [pc, #216]	; (810ed18 <dhcp_start+0xf0>)
 810ec3e:	4837      	ldr	r0, [pc, #220]	; (810ed1c <dhcp_start+0xf4>)
 810ec40:	f00c fdde 	bl	811b800 <iprintf>
 810ec44:	f06f 030f 	mvn.w	r3, #15
 810ec48:	e060      	b.n	810ed0c <dhcp_start+0xe4>
  LWIP_ERROR("netif is not up, old style port?", netif_is_up(netif), return ERR_ARG;);
 810ec4a:	687b      	ldr	r3, [r7, #4]
 810ec4c:	f893 3031 	ldrb.w	r3, [r3, #49]	; 0x31
 810ec50:	f003 0301 	and.w	r3, r3, #1
 810ec54:	2b00      	cmp	r3, #0
 810ec56:	d109      	bne.n	810ec6c <dhcp_start+0x44>
 810ec58:	4b2e      	ldr	r3, [pc, #184]	; (810ed14 <dhcp_start+0xec>)
 810ec5a:	f44f 723a 	mov.w	r2, #744	; 0x2e8
 810ec5e:	4930      	ldr	r1, [pc, #192]	; (810ed20 <dhcp_start+0xf8>)
 810ec60:	482e      	ldr	r0, [pc, #184]	; (810ed1c <dhcp_start+0xf4>)
 810ec62:	f00c fdcd 	bl	811b800 <iprintf>
 810ec66:	f06f 030f 	mvn.w	r3, #15
 810ec6a:	e04f      	b.n	810ed0c <dhcp_start+0xe4>
  dhcp = netif_dhcp_data(netif);
 810ec6c:	687b      	ldr	r3, [r7, #4]
 810ec6e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 810ec70:	60fb      	str	r3, [r7, #12]
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_start(netif=%p) %c%c%"U16_F"\n", (void *)netif, netif->name[0], netif->name[1], (u16_t)netif->num));

  /* check MTU of the netif */
  if (netif->mtu < DHCP_MAX_MSG_LEN_MIN_REQUIRED) {
 810ec72:	687b      	ldr	r3, [r7, #4]
 810ec74:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
 810ec76:	f5b3 7f10 	cmp.w	r3, #576	; 0x240
 810ec7a:	d202      	bcs.n	810ec82 <dhcp_start+0x5a>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_start(): Cannot use this netif with DHCP: MTU is too small\n"));
    return ERR_MEM;
 810ec7c:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 810ec80:	e044      	b.n	810ed0c <dhcp_start+0xe4>
  }

  /* no DHCP client attached yet? */
  if (dhcp == NULL) {
 810ec82:	68fb      	ldr	r3, [r7, #12]
 810ec84:	2b00      	cmp	r3, #0
 810ec86:	d10d      	bne.n	810eca4 <dhcp_start+0x7c>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_start(): mallocing new DHCP client\n"));
    dhcp = (struct dhcp *)mem_malloc(sizeof(struct dhcp));
 810ec88:	2034      	movs	r0, #52	; 0x34
 810ec8a:	f004 fc83 	bl	8113594 <mem_malloc>
 810ec8e:	60f8      	str	r0, [r7, #12]
    if (dhcp == NULL) {
 810ec90:	68fb      	ldr	r3, [r7, #12]
 810ec92:	2b00      	cmp	r3, #0
 810ec94:	d102      	bne.n	810ec9c <dhcp_start+0x74>
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_start(): could not allocate dhcp\n"));
      return ERR_MEM;
 810ec96:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 810ec9a:	e037      	b.n	810ed0c <dhcp_start+0xe4>
    }

    /* store this dhcp client in the netif */
    netif_set_client_data(netif, LWIP_NETIF_CLIENT_DATA_INDEX_DHCP, dhcp);
 810ec9c:	687b      	ldr	r3, [r7, #4]
 810ec9e:	68fa      	ldr	r2, [r7, #12]
 810eca0:	625a      	str	r2, [r3, #36]	; 0x24
 810eca2:	e005      	b.n	810ecb0 <dhcp_start+0x88>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_start(): allocated dhcp"));
    /* already has DHCP client attached */
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_start(): restarting DHCP configuration\n"));

    if (dhcp->pcb_allocated != 0) {
 810eca4:	68fb      	ldr	r3, [r7, #12]
 810eca6:	791b      	ldrb	r3, [r3, #4]
 810eca8:	2b00      	cmp	r3, #0
 810ecaa:	d001      	beq.n	810ecb0 <dhcp_start+0x88>
      dhcp_dec_pcb_refcount(); /* free DHCP PCB if not needed any more */
 810ecac:	f7ff fc72 	bl	810e594 <dhcp_dec_pcb_refcount>
    }
    /* dhcp is cleared below, no need to reset flag*/
  }

  /* clear data structure */
  memset(dhcp, 0, sizeof(struct dhcp));
 810ecb0:	2234      	movs	r2, #52	; 0x34
 810ecb2:	2100      	movs	r1, #0
 810ecb4:	68f8      	ldr	r0, [r7, #12]
 810ecb6:	f00c fdcd 	bl	811b854 <memset>
  /* dhcp_set_state(&dhcp, DHCP_STATE_OFF); */

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_start(): starting DHCP configuration\n"));

  if (dhcp_inc_pcb_refcount() != ERR_OK) { /* ensure DHCP PCB is allocated */
 810ecba:	f7ff fc19 	bl	810e4f0 <dhcp_inc_pcb_refcount>
 810ecbe:	4603      	mov	r3, r0
 810ecc0:	2b00      	cmp	r3, #0
 810ecc2:	d002      	beq.n	810ecca <dhcp_start+0xa2>
    return ERR_MEM;
 810ecc4:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 810ecc8:	e020      	b.n	810ed0c <dhcp_start+0xe4>
  }
  dhcp->pcb_allocated = 1;
 810ecca:	68fb      	ldr	r3, [r7, #12]
 810eccc:	2201      	movs	r2, #1
 810ecce:	711a      	strb	r2, [r3, #4]

  if (!netif_is_link_up(netif)) {
 810ecd0:	687b      	ldr	r3, [r7, #4]
 810ecd2:	f893 3031 	ldrb.w	r3, [r3, #49]	; 0x31
 810ecd6:	f003 0304 	and.w	r3, r3, #4
 810ecda:	2b00      	cmp	r3, #0
 810ecdc:	d105      	bne.n	810ecea <dhcp_start+0xc2>
    /* set state INIT and wait for dhcp_network_changed() to call dhcp_discover() */
    dhcp_set_state(dhcp, DHCP_STATE_INIT);
 810ecde:	2102      	movs	r1, #2
 810ece0:	68f8      	ldr	r0, [r7, #12]
 810ece2:	f000 fd01 	bl	810f6e8 <dhcp_set_state>
    return ERR_OK;
 810ece6:	2300      	movs	r3, #0
 810ece8:	e010      	b.n	810ed0c <dhcp_start+0xe4>
  }

  /* (re)start the DHCP negotiation */
  result = dhcp_discover(netif);
 810ecea:	6878      	ldr	r0, [r7, #4]
 810ecec:	f000 f8f8 	bl	810eee0 <dhcp_discover>
 810ecf0:	4603      	mov	r3, r0
 810ecf2:	72fb      	strb	r3, [r7, #11]
  if (result != ERR_OK) {
 810ecf4:	f997 300b 	ldrsb.w	r3, [r7, #11]
 810ecf8:	2b00      	cmp	r3, #0
 810ecfa:	d005      	beq.n	810ed08 <dhcp_start+0xe0>
    /* free resources allocated above */
    dhcp_release_and_stop(netif);
 810ecfc:	6878      	ldr	r0, [r7, #4]
 810ecfe:	f000 fc59 	bl	810f5b4 <dhcp_release_and_stop>
    return ERR_MEM;
 810ed02:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 810ed06:	e001      	b.n	810ed0c <dhcp_start+0xe4>
  }
  return result;
 810ed08:	f997 300b 	ldrsb.w	r3, [r7, #11]
}
 810ed0c:	4618      	mov	r0, r3
 810ed0e:	3710      	adds	r7, #16
 810ed10:	46bd      	mov	sp, r7
 810ed12:	bd80      	pop	{r7, pc}
 810ed14:	0811c788 	.word	0x0811c788
 810ed18:	0811c89c 	.word	0x0811c89c
 810ed1c:	0811c818 	.word	0x0811c818
 810ed20:	0811c8e0 	.word	0x0811c8e0

0810ed24 <dhcp_network_changed>:
 * This enters the REBOOTING state to verify that the currently bound
 * address is still valid.
 */
void
dhcp_network_changed(struct netif *netif)
{
 810ed24:	b580      	push	{r7, lr}
 810ed26:	b084      	sub	sp, #16
 810ed28:	af00      	add	r7, sp, #0
 810ed2a:	6078      	str	r0, [r7, #4]
  struct dhcp *dhcp = netif_dhcp_data(netif);
 810ed2c:	687b      	ldr	r3, [r7, #4]
 810ed2e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 810ed30:	60fb      	str	r3, [r7, #12]

  if (!dhcp) {
 810ed32:	68fb      	ldr	r3, [r7, #12]
 810ed34:	2b00      	cmp	r3, #0
 810ed36:	d025      	beq.n	810ed84 <dhcp_network_changed+0x60>
    return;
  }
  switch (dhcp->state) {
 810ed38:	68fb      	ldr	r3, [r7, #12]
 810ed3a:	795b      	ldrb	r3, [r3, #5]
 810ed3c:	2b0a      	cmp	r3, #10
 810ed3e:	d008      	beq.n	810ed52 <dhcp_network_changed+0x2e>
 810ed40:	2b0a      	cmp	r3, #10
 810ed42:	dc0d      	bgt.n	810ed60 <dhcp_network_changed+0x3c>
 810ed44:	2b00      	cmp	r3, #0
 810ed46:	d01f      	beq.n	810ed88 <dhcp_network_changed+0x64>
 810ed48:	2b00      	cmp	r3, #0
 810ed4a:	db09      	blt.n	810ed60 <dhcp_network_changed+0x3c>
 810ed4c:	3b03      	subs	r3, #3
 810ed4e:	2b02      	cmp	r3, #2
 810ed50:	d806      	bhi.n	810ed60 <dhcp_network_changed+0x3c>
    case DHCP_STATE_REBINDING:
    case DHCP_STATE_RENEWING:
    case DHCP_STATE_BOUND:
    case DHCP_STATE_REBOOTING:
      dhcp->tries = 0;
 810ed52:	68fb      	ldr	r3, [r7, #12]
 810ed54:	2200      	movs	r2, #0
 810ed56:	719a      	strb	r2, [r3, #6]
      dhcp_reboot(netif);
 810ed58:	6878      	ldr	r0, [r7, #4]
 810ed5a:	f000 fb75 	bl	810f448 <dhcp_reboot>
      break;
 810ed5e:	e014      	b.n	810ed8a <dhcp_network_changed+0x66>
    case DHCP_STATE_OFF:
      /* stay off */
      break;
    default:
      LWIP_ASSERT("invalid dhcp->state", dhcp->state <= DHCP_STATE_BACKING_OFF);
 810ed60:	68fb      	ldr	r3, [r7, #12]
 810ed62:	795b      	ldrb	r3, [r3, #5]
 810ed64:	2b0c      	cmp	r3, #12
 810ed66:	d906      	bls.n	810ed76 <dhcp_network_changed+0x52>
 810ed68:	4b09      	ldr	r3, [pc, #36]	; (810ed90 <dhcp_network_changed+0x6c>)
 810ed6a:	f240 326d 	movw	r2, #877	; 0x36d
 810ed6e:	4909      	ldr	r1, [pc, #36]	; (810ed94 <dhcp_network_changed+0x70>)
 810ed70:	4809      	ldr	r0, [pc, #36]	; (810ed98 <dhcp_network_changed+0x74>)
 810ed72:	f00c fd45 	bl	811b800 <iprintf>
        autoip_stop(netif);
        dhcp->autoip_coop_state = DHCP_AUTOIP_COOP_STATE_OFF;
      }
#endif /* LWIP_DHCP_AUTOIP_COOP */
      /* ensure we start with short timeouts, even if already discovering */
      dhcp->tries = 0;
 810ed76:	68fb      	ldr	r3, [r7, #12]
 810ed78:	2200      	movs	r2, #0
 810ed7a:	719a      	strb	r2, [r3, #6]
      dhcp_discover(netif);
 810ed7c:	6878      	ldr	r0, [r7, #4]
 810ed7e:	f000 f8af 	bl	810eee0 <dhcp_discover>
      break;
 810ed82:	e002      	b.n	810ed8a <dhcp_network_changed+0x66>
    return;
 810ed84:	bf00      	nop
 810ed86:	e000      	b.n	810ed8a <dhcp_network_changed+0x66>
      break;
 810ed88:	bf00      	nop
  }
}
 810ed8a:	3710      	adds	r7, #16
 810ed8c:	46bd      	mov	sp, r7
 810ed8e:	bd80      	pop	{r7, pc}
 810ed90:	0811c788 	.word	0x0811c788
 810ed94:	0811c904 	.word	0x0811c904
 810ed98:	0811c818 	.word	0x0811c818

0810ed9c <dhcp_arp_reply>:
 * @param netif the network interface on which the reply was received
 * @param addr The IP address we received a reply from
 */
void
dhcp_arp_reply(struct netif *netif, const ip4_addr_t *addr)
{
 810ed9c:	b580      	push	{r7, lr}
 810ed9e:	b084      	sub	sp, #16
 810eda0:	af00      	add	r7, sp, #0
 810eda2:	6078      	str	r0, [r7, #4]
 810eda4:	6039      	str	r1, [r7, #0]
  struct dhcp *dhcp;

  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
 810eda6:	687b      	ldr	r3, [r7, #4]
 810eda8:	2b00      	cmp	r3, #0
 810edaa:	d107      	bne.n	810edbc <dhcp_arp_reply+0x20>
 810edac:	4b0e      	ldr	r3, [pc, #56]	; (810ede8 <dhcp_arp_reply+0x4c>)
 810edae:	f240 328b 	movw	r2, #907	; 0x38b
 810edb2:	490e      	ldr	r1, [pc, #56]	; (810edec <dhcp_arp_reply+0x50>)
 810edb4:	480e      	ldr	r0, [pc, #56]	; (810edf0 <dhcp_arp_reply+0x54>)
 810edb6:	f00c fd23 	bl	811b800 <iprintf>
 810edba:	e012      	b.n	810ede2 <dhcp_arp_reply+0x46>
  dhcp = netif_dhcp_data(netif);
 810edbc:	687b      	ldr	r3, [r7, #4]
 810edbe:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 810edc0:	60fb      	str	r3, [r7, #12]
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_arp_reply()\n"));
  /* is a DHCP client doing an ARP check? */
  if ((dhcp != NULL) && (dhcp->state == DHCP_STATE_CHECKING)) {
 810edc2:	68fb      	ldr	r3, [r7, #12]
 810edc4:	2b00      	cmp	r3, #0
 810edc6:	d00c      	beq.n	810ede2 <dhcp_arp_reply+0x46>
 810edc8:	68fb      	ldr	r3, [r7, #12]
 810edca:	795b      	ldrb	r3, [r3, #5]
 810edcc:	2b08      	cmp	r3, #8
 810edce:	d108      	bne.n	810ede2 <dhcp_arp_reply+0x46>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_arp_reply(): CHECKING, arp reply for 0x%08"X32_F"\n",
                ip4_addr_get_u32(addr)));
    /* did a host respond with the address we
       were offered by the DHCP server? */
    if (ip4_addr_cmp(addr, &dhcp->offered_ip_addr)) {
 810edd0:	683b      	ldr	r3, [r7, #0]
 810edd2:	681a      	ldr	r2, [r3, #0]
 810edd4:	68fb      	ldr	r3, [r7, #12]
 810edd6:	69db      	ldr	r3, [r3, #28]
 810edd8:	429a      	cmp	r2, r3
 810edda:	d102      	bne.n	810ede2 <dhcp_arp_reply+0x46>
      /* we will not accept the offered address */
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE | LWIP_DBG_LEVEL_WARNING,
                  ("dhcp_arp_reply(): arp reply matched with offered address, declining\n"));
      dhcp_decline(netif);
 810eddc:	6878      	ldr	r0, [r7, #4]
 810edde:	f000 f809 	bl	810edf4 <dhcp_decline>
    }
  }
}
 810ede2:	3710      	adds	r7, #16
 810ede4:	46bd      	mov	sp, r7
 810ede6:	bd80      	pop	{r7, pc}
 810ede8:	0811c788 	.word	0x0811c788
 810edec:	0811c89c 	.word	0x0811c89c
 810edf0:	0811c818 	.word	0x0811c818

0810edf4 <dhcp_decline>:
 *
 * @param netif the netif under DHCP control
 */
static err_t
dhcp_decline(struct netif *netif)
{
 810edf4:	b5b0      	push	{r4, r5, r7, lr}
 810edf6:	b08a      	sub	sp, #40	; 0x28
 810edf8:	af02      	add	r7, sp, #8
 810edfa:	6078      	str	r0, [r7, #4]
  struct dhcp *dhcp = netif_dhcp_data(netif);
 810edfc:	687b      	ldr	r3, [r7, #4]
 810edfe:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 810ee00:	61bb      	str	r3, [r7, #24]
  u16_t msecs;
  struct pbuf *p_out;
  u16_t options_out_len;

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_decline()\n"));
  dhcp_set_state(dhcp, DHCP_STATE_BACKING_OFF);
 810ee02:	210c      	movs	r1, #12
 810ee04:	69b8      	ldr	r0, [r7, #24]
 810ee06:	f000 fc6f 	bl	810f6e8 <dhcp_set_state>
  /* create and initialize the DHCP message header */
  p_out = dhcp_create_msg(netif, dhcp, DHCP_DECLINE, &options_out_len);
 810ee0a:	f107 030c 	add.w	r3, r7, #12
 810ee0e:	2204      	movs	r2, #4
 810ee10:	69b9      	ldr	r1, [r7, #24]
 810ee12:	6878      	ldr	r0, [r7, #4]
 810ee14:	f001 f924 	bl	8110060 <dhcp_create_msg>
 810ee18:	6178      	str	r0, [r7, #20]
  if (p_out != NULL) {
 810ee1a:	697b      	ldr	r3, [r7, #20]
 810ee1c:	2b00      	cmp	r3, #0
 810ee1e:	d035      	beq.n	810ee8c <dhcp_decline+0x98>
    struct dhcp_msg *msg_out = (struct dhcp_msg *)p_out->payload;
 810ee20:	697b      	ldr	r3, [r7, #20]
 810ee22:	685b      	ldr	r3, [r3, #4]
 810ee24:	613b      	str	r3, [r7, #16]
    options_out_len = dhcp_option(options_out_len, msg_out->options, DHCP_OPTION_REQUESTED_IP, 4);
 810ee26:	89b8      	ldrh	r0, [r7, #12]
 810ee28:	693b      	ldr	r3, [r7, #16]
 810ee2a:	f103 01f0 	add.w	r1, r3, #240	; 0xf0
 810ee2e:	2304      	movs	r3, #4
 810ee30:	2232      	movs	r2, #50	; 0x32
 810ee32:	f000 fc73 	bl	810f71c <dhcp_option>
 810ee36:	4603      	mov	r3, r0
 810ee38:	81bb      	strh	r3, [r7, #12]
    options_out_len = dhcp_option_long(options_out_len, msg_out->options, lwip_ntohl(ip4_addr_get_u32(&dhcp->offered_ip_addr)));
 810ee3a:	89bc      	ldrh	r4, [r7, #12]
 810ee3c:	693b      	ldr	r3, [r7, #16]
 810ee3e:	f103 05f0 	add.w	r5, r3, #240	; 0xf0
 810ee42:	69bb      	ldr	r3, [r7, #24]
 810ee44:	69db      	ldr	r3, [r3, #28]
 810ee46:	4618      	mov	r0, r3
 810ee48:	f7ff fb38 	bl	810e4bc <lwip_htonl>
 810ee4c:	4603      	mov	r3, r0
 810ee4e:	461a      	mov	r2, r3
 810ee50:	4629      	mov	r1, r5
 810ee52:	4620      	mov	r0, r4
 810ee54:	f000 fcee 	bl	810f834 <dhcp_option_long>
 810ee58:	4603      	mov	r3, r0
 810ee5a:	81bb      	strh	r3, [r7, #12]

    LWIP_HOOK_DHCP_APPEND_OPTIONS(netif, dhcp, DHCP_STATE_BACKING_OFF, msg_out, DHCP_DECLINE, &options_out_len);
    dhcp_option_trailer(options_out_len, msg_out->options, p_out);
 810ee5c:	89b8      	ldrh	r0, [r7, #12]
 810ee5e:	693b      	ldr	r3, [r7, #16]
 810ee60:	33f0      	adds	r3, #240	; 0xf0
 810ee62:	697a      	ldr	r2, [r7, #20]
 810ee64:	4619      	mov	r1, r3
 810ee66:	f001 f9d1 	bl	811020c <dhcp_option_trailer>

    /* per section 4.4.4, broadcast DECLINE messages */
    result = udp_sendto_if_src(dhcp_pcb, p_out, IP_ADDR_BROADCAST, LWIP_IANA_PORT_DHCP_SERVER, netif, IP4_ADDR_ANY);
 810ee6a:	4b19      	ldr	r3, [pc, #100]	; (810eed0 <dhcp_decline+0xdc>)
 810ee6c:	6818      	ldr	r0, [r3, #0]
 810ee6e:	4b19      	ldr	r3, [pc, #100]	; (810eed4 <dhcp_decline+0xe0>)
 810ee70:	9301      	str	r3, [sp, #4]
 810ee72:	687b      	ldr	r3, [r7, #4]
 810ee74:	9300      	str	r3, [sp, #0]
 810ee76:	2343      	movs	r3, #67	; 0x43
 810ee78:	4a17      	ldr	r2, [pc, #92]	; (810eed8 <dhcp_decline+0xe4>)
 810ee7a:	6979      	ldr	r1, [r7, #20]
 810ee7c:	f00b fcda 	bl	811a834 <udp_sendto_if_src>
 810ee80:	4603      	mov	r3, r0
 810ee82:	77fb      	strb	r3, [r7, #31]
    pbuf_free(p_out);
 810ee84:	6978      	ldr	r0, [r7, #20]
 810ee86:	f005 fbe7 	bl	8114658 <pbuf_free>
 810ee8a:	e001      	b.n	810ee90 <dhcp_decline+0x9c>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_decline: BACKING OFF\n"));
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS,
                ("dhcp_decline: could not allocate DHCP request\n"));
    result = ERR_MEM;
 810ee8c:	23ff      	movs	r3, #255	; 0xff
 810ee8e:	77fb      	strb	r3, [r7, #31]
  }
  if (dhcp->tries < 255) {
 810ee90:	69bb      	ldr	r3, [r7, #24]
 810ee92:	799b      	ldrb	r3, [r3, #6]
 810ee94:	2bff      	cmp	r3, #255	; 0xff
 810ee96:	d005      	beq.n	810eea4 <dhcp_decline+0xb0>
    dhcp->tries++;
 810ee98:	69bb      	ldr	r3, [r7, #24]
 810ee9a:	799b      	ldrb	r3, [r3, #6]
 810ee9c:	3301      	adds	r3, #1
 810ee9e:	b2da      	uxtb	r2, r3
 810eea0:	69bb      	ldr	r3, [r7, #24]
 810eea2:	719a      	strb	r2, [r3, #6]
  }
  msecs = 10 * 1000;
 810eea4:	f242 7310 	movw	r3, #10000	; 0x2710
 810eea8:	81fb      	strh	r3, [r7, #14]
  dhcp->request_timeout = (u16_t)((msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS);
 810eeaa:	89fb      	ldrh	r3, [r7, #14]
 810eeac:	f203 13f3 	addw	r3, r3, #499	; 0x1f3
 810eeb0:	4a0a      	ldr	r2, [pc, #40]	; (810eedc <dhcp_decline+0xe8>)
 810eeb2:	fb82 1203 	smull	r1, r2, r2, r3
 810eeb6:	1152      	asrs	r2, r2, #5
 810eeb8:	17db      	asrs	r3, r3, #31
 810eeba:	1ad3      	subs	r3, r2, r3
 810eebc:	b29a      	uxth	r2, r3
 810eebe:	69bb      	ldr	r3, [r7, #24]
 810eec0:	811a      	strh	r2, [r3, #8]
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_decline(): set request timeout %"U16_F" msecs\n", msecs));
  return result;
 810eec2:	f997 301f 	ldrsb.w	r3, [r7, #31]
}
 810eec6:	4618      	mov	r0, r3
 810eec8:	3720      	adds	r7, #32
 810eeca:	46bd      	mov	sp, r7
 810eecc:	bdb0      	pop	{r4, r5, r7, pc}
 810eece:	bf00      	nop
 810eed0:	10004f68 	.word	0x10004f68
 810eed4:	0811f934 	.word	0x0811f934
 810eed8:	0811f938 	.word	0x0811f938
 810eedc:	10624dd3 	.word	0x10624dd3

0810eee0 <dhcp_discover>:
 *
 * @param netif the netif under DHCP control
 */
static err_t
dhcp_discover(struct netif *netif)
{
 810eee0:	b580      	push	{r7, lr}
 810eee2:	b08a      	sub	sp, #40	; 0x28
 810eee4:	af02      	add	r7, sp, #8
 810eee6:	6078      	str	r0, [r7, #4]
  struct dhcp *dhcp = netif_dhcp_data(netif);
 810eee8:	687b      	ldr	r3, [r7, #4]
 810eeea:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 810eeec:	61bb      	str	r3, [r7, #24]
  err_t result = ERR_OK;
 810eeee:	2300      	movs	r3, #0
 810eef0:	75fb      	strb	r3, [r7, #23]
  struct pbuf *p_out;
  u16_t options_out_len;

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_discover()\n"));

  ip4_addr_set_any(&dhcp->offered_ip_addr);
 810eef2:	69bb      	ldr	r3, [r7, #24]
 810eef4:	2200      	movs	r2, #0
 810eef6:	61da      	str	r2, [r3, #28]
  dhcp_set_state(dhcp, DHCP_STATE_SELECTING);
 810eef8:	2106      	movs	r1, #6
 810eefa:	69b8      	ldr	r0, [r7, #24]
 810eefc:	f000 fbf4 	bl	810f6e8 <dhcp_set_state>
  /* create and initialize the DHCP message header */
  p_out = dhcp_create_msg(netif, dhcp, DHCP_DISCOVER, &options_out_len);
 810ef00:	f107 0308 	add.w	r3, r7, #8
 810ef04:	2201      	movs	r2, #1
 810ef06:	69b9      	ldr	r1, [r7, #24]
 810ef08:	6878      	ldr	r0, [r7, #4]
 810ef0a:	f001 f8a9 	bl	8110060 <dhcp_create_msg>
 810ef0e:	6138      	str	r0, [r7, #16]
  if (p_out != NULL) {
 810ef10:	693b      	ldr	r3, [r7, #16]
 810ef12:	2b00      	cmp	r3, #0
 810ef14:	d04b      	beq.n	810efae <dhcp_discover+0xce>
    struct dhcp_msg *msg_out = (struct dhcp_msg *)p_out->payload;
 810ef16:	693b      	ldr	r3, [r7, #16]
 810ef18:	685b      	ldr	r3, [r3, #4]
 810ef1a:	60fb      	str	r3, [r7, #12]
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_discover: making request\n"));

    options_out_len = dhcp_option(options_out_len, msg_out->options, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
 810ef1c:	8938      	ldrh	r0, [r7, #8]
 810ef1e:	68fb      	ldr	r3, [r7, #12]
 810ef20:	f103 01f0 	add.w	r1, r3, #240	; 0xf0
 810ef24:	2302      	movs	r3, #2
 810ef26:	2239      	movs	r2, #57	; 0x39
 810ef28:	f000 fbf8 	bl	810f71c <dhcp_option>
 810ef2c:	4603      	mov	r3, r0
 810ef2e:	813b      	strh	r3, [r7, #8]
    options_out_len = dhcp_option_short(options_out_len, msg_out->options, DHCP_MAX_MSG_LEN(netif));
 810ef30:	8938      	ldrh	r0, [r7, #8]
 810ef32:	68fb      	ldr	r3, [r7, #12]
 810ef34:	f103 01f0 	add.w	r1, r3, #240	; 0xf0
 810ef38:	687b      	ldr	r3, [r7, #4]
 810ef3a:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
 810ef3c:	461a      	mov	r2, r3
 810ef3e:	f000 fc47 	bl	810f7d0 <dhcp_option_short>
 810ef42:	4603      	mov	r3, r0
 810ef44:	813b      	strh	r3, [r7, #8]

    options_out_len = dhcp_option(options_out_len, msg_out->options, DHCP_OPTION_PARAMETER_REQUEST_LIST, LWIP_ARRAYSIZE(dhcp_discover_request_options));
 810ef46:	8938      	ldrh	r0, [r7, #8]
 810ef48:	68fb      	ldr	r3, [r7, #12]
 810ef4a:	f103 01f0 	add.w	r1, r3, #240	; 0xf0
 810ef4e:	2304      	movs	r3, #4
 810ef50:	2237      	movs	r2, #55	; 0x37
 810ef52:	f000 fbe3 	bl	810f71c <dhcp_option>
 810ef56:	4603      	mov	r3, r0
 810ef58:	813b      	strh	r3, [r7, #8]
    for (i = 0; i < LWIP_ARRAYSIZE(dhcp_discover_request_options); i++) {
 810ef5a:	2300      	movs	r3, #0
 810ef5c:	77fb      	strb	r3, [r7, #31]
 810ef5e:	e00e      	b.n	810ef7e <dhcp_discover+0x9e>
      options_out_len = dhcp_option_byte(options_out_len, msg_out->options, dhcp_discover_request_options[i]);
 810ef60:	8938      	ldrh	r0, [r7, #8]
 810ef62:	68fb      	ldr	r3, [r7, #12]
 810ef64:	f103 01f0 	add.w	r1, r3, #240	; 0xf0
 810ef68:	7ffb      	ldrb	r3, [r7, #31]
 810ef6a:	4a29      	ldr	r2, [pc, #164]	; (810f010 <dhcp_discover+0x130>)
 810ef6c:	5cd3      	ldrb	r3, [r2, r3]
 810ef6e:	461a      	mov	r2, r3
 810ef70:	f000 fc08 	bl	810f784 <dhcp_option_byte>
 810ef74:	4603      	mov	r3, r0
 810ef76:	813b      	strh	r3, [r7, #8]
    for (i = 0; i < LWIP_ARRAYSIZE(dhcp_discover_request_options); i++) {
 810ef78:	7ffb      	ldrb	r3, [r7, #31]
 810ef7a:	3301      	adds	r3, #1
 810ef7c:	77fb      	strb	r3, [r7, #31]
 810ef7e:	7ffb      	ldrb	r3, [r7, #31]
 810ef80:	2b03      	cmp	r3, #3
 810ef82:	d9ed      	bls.n	810ef60 <dhcp_discover+0x80>
    }
    LWIP_HOOK_DHCP_APPEND_OPTIONS(netif, dhcp, DHCP_STATE_SELECTING, msg_out, DHCP_DISCOVER, &options_out_len);
    dhcp_option_trailer(options_out_len, msg_out->options, p_out);
 810ef84:	8938      	ldrh	r0, [r7, #8]
 810ef86:	68fb      	ldr	r3, [r7, #12]
 810ef88:	33f0      	adds	r3, #240	; 0xf0
 810ef8a:	693a      	ldr	r2, [r7, #16]
 810ef8c:	4619      	mov	r1, r3
 810ef8e:	f001 f93d 	bl	811020c <dhcp_option_trailer>

    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_discover: sendto(DISCOVER, IP_ADDR_BROADCAST, LWIP_IANA_PORT_DHCP_SERVER)\n"));
    udp_sendto_if_src(dhcp_pcb, p_out, IP_ADDR_BROADCAST, LWIP_IANA_PORT_DHCP_SERVER, netif, IP4_ADDR_ANY);
 810ef92:	4b20      	ldr	r3, [pc, #128]	; (810f014 <dhcp_discover+0x134>)
 810ef94:	6818      	ldr	r0, [r3, #0]
 810ef96:	4b20      	ldr	r3, [pc, #128]	; (810f018 <dhcp_discover+0x138>)
 810ef98:	9301      	str	r3, [sp, #4]
 810ef9a:	687b      	ldr	r3, [r7, #4]
 810ef9c:	9300      	str	r3, [sp, #0]
 810ef9e:	2343      	movs	r3, #67	; 0x43
 810efa0:	4a1e      	ldr	r2, [pc, #120]	; (810f01c <dhcp_discover+0x13c>)
 810efa2:	6939      	ldr	r1, [r7, #16]
 810efa4:	f00b fc46 	bl	811a834 <udp_sendto_if_src>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_discover: deleting()ing\n"));
    pbuf_free(p_out);
 810efa8:	6938      	ldr	r0, [r7, #16]
 810efaa:	f005 fb55 	bl	8114658 <pbuf_free>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_discover: SELECTING\n"));
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("dhcp_discover: could not allocate DHCP request\n"));
  }
  if (dhcp->tries < 255) {
 810efae:	69bb      	ldr	r3, [r7, #24]
 810efb0:	799b      	ldrb	r3, [r3, #6]
 810efb2:	2bff      	cmp	r3, #255	; 0xff
 810efb4:	d005      	beq.n	810efc2 <dhcp_discover+0xe2>
    dhcp->tries++;
 810efb6:	69bb      	ldr	r3, [r7, #24]
 810efb8:	799b      	ldrb	r3, [r3, #6]
 810efba:	3301      	adds	r3, #1
 810efbc:	b2da      	uxtb	r2, r3
 810efbe:	69bb      	ldr	r3, [r7, #24]
 810efc0:	719a      	strb	r2, [r3, #6]
  if (dhcp->tries >= LWIP_DHCP_AUTOIP_COOP_TRIES && dhcp->autoip_coop_state == DHCP_AUTOIP_COOP_STATE_OFF) {
    dhcp->autoip_coop_state = DHCP_AUTOIP_COOP_STATE_ON;
    autoip_start(netif);
  }
#endif /* LWIP_DHCP_AUTOIP_COOP */
  msecs = (u16_t)((dhcp->tries < 6 ? 1 << dhcp->tries : 60) * 1000);
 810efc2:	69bb      	ldr	r3, [r7, #24]
 810efc4:	799b      	ldrb	r3, [r3, #6]
 810efc6:	2b05      	cmp	r3, #5
 810efc8:	d80d      	bhi.n	810efe6 <dhcp_discover+0x106>
 810efca:	69bb      	ldr	r3, [r7, #24]
 810efcc:	799b      	ldrb	r3, [r3, #6]
 810efce:	461a      	mov	r2, r3
 810efd0:	2301      	movs	r3, #1
 810efd2:	4093      	lsls	r3, r2
 810efd4:	b29b      	uxth	r3, r3
 810efd6:	461a      	mov	r2, r3
 810efd8:	0152      	lsls	r2, r2, #5
 810efda:	1ad2      	subs	r2, r2, r3
 810efdc:	0092      	lsls	r2, r2, #2
 810efde:	4413      	add	r3, r2
 810efe0:	00db      	lsls	r3, r3, #3
 810efe2:	b29b      	uxth	r3, r3
 810efe4:	e001      	b.n	810efea <dhcp_discover+0x10a>
 810efe6:	f64e 2360 	movw	r3, #60000	; 0xea60
 810efea:	817b      	strh	r3, [r7, #10]
  dhcp->request_timeout = (u16_t)((msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS);
 810efec:	897b      	ldrh	r3, [r7, #10]
 810efee:	f203 13f3 	addw	r3, r3, #499	; 0x1f3
 810eff2:	4a0b      	ldr	r2, [pc, #44]	; (810f020 <dhcp_discover+0x140>)
 810eff4:	fb82 1203 	smull	r1, r2, r2, r3
 810eff8:	1152      	asrs	r2, r2, #5
 810effa:	17db      	asrs	r3, r3, #31
 810effc:	1ad3      	subs	r3, r2, r3
 810effe:	b29a      	uxth	r2, r3
 810f000:	69bb      	ldr	r3, [r7, #24]
 810f002:	811a      	strh	r2, [r3, #8]
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_discover(): set request timeout %"U16_F" msecs\n", msecs));
  return result;
 810f004:	f997 3017 	ldrsb.w	r3, [r7, #23]
}
 810f008:	4618      	mov	r0, r3
 810f00a:	3720      	adds	r7, #32
 810f00c:	46bd      	mov	sp, r7
 810f00e:	bd80      	pop	{r7, pc}
 810f010:	10000100 	.word	0x10000100
 810f014:	10004f68 	.word	0x10004f68
 810f018:	0811f934 	.word	0x0811f934
 810f01c:	0811f938 	.word	0x0811f938
 810f020:	10624dd3 	.word	0x10624dd3

0810f024 <dhcp_bind>:
 *
 * @param netif network interface to bind to the offered address
 */
static void
dhcp_bind(struct netif *netif)
{
 810f024:	b580      	push	{r7, lr}
 810f026:	b088      	sub	sp, #32
 810f028:	af00      	add	r7, sp, #0
 810f02a:	6078      	str	r0, [r7, #4]
  u32_t timeout;
  struct dhcp *dhcp;
  ip4_addr_t sn_mask, gw_addr;
  LWIP_ERROR("dhcp_bind: netif != NULL", (netif != NULL), return;);
 810f02c:	687b      	ldr	r3, [r7, #4]
 810f02e:	2b00      	cmp	r3, #0
 810f030:	d107      	bne.n	810f042 <dhcp_bind+0x1e>
 810f032:	4b64      	ldr	r3, [pc, #400]	; (810f1c4 <dhcp_bind+0x1a0>)
 810f034:	f240 4215 	movw	r2, #1045	; 0x415
 810f038:	4963      	ldr	r1, [pc, #396]	; (810f1c8 <dhcp_bind+0x1a4>)
 810f03a:	4864      	ldr	r0, [pc, #400]	; (810f1cc <dhcp_bind+0x1a8>)
 810f03c:	f00c fbe0 	bl	811b800 <iprintf>
 810f040:	e0bc      	b.n	810f1bc <dhcp_bind+0x198>
  dhcp = netif_dhcp_data(netif);
 810f042:	687b      	ldr	r3, [r7, #4]
 810f044:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 810f046:	61bb      	str	r3, [r7, #24]
  LWIP_ERROR("dhcp_bind: dhcp != NULL", (dhcp != NULL), return;);
 810f048:	69bb      	ldr	r3, [r7, #24]
 810f04a:	2b00      	cmp	r3, #0
 810f04c:	d107      	bne.n	810f05e <dhcp_bind+0x3a>
 810f04e:	4b5d      	ldr	r3, [pc, #372]	; (810f1c4 <dhcp_bind+0x1a0>)
 810f050:	f240 4217 	movw	r2, #1047	; 0x417
 810f054:	495e      	ldr	r1, [pc, #376]	; (810f1d0 <dhcp_bind+0x1ac>)
 810f056:	485d      	ldr	r0, [pc, #372]	; (810f1cc <dhcp_bind+0x1a8>)
 810f058:	f00c fbd2 	bl	811b800 <iprintf>
 810f05c:	e0ae      	b.n	810f1bc <dhcp_bind+0x198>
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_bind(netif=%p) %c%c%"U16_F"\n", (void *)netif, netif->name[0], netif->name[1], (u16_t)netif->num));

  /* reset time used of lease */
  dhcp->lease_used = 0;
 810f05e:	69bb      	ldr	r3, [r7, #24]
 810f060:	2200      	movs	r2, #0
 810f062:	825a      	strh	r2, [r3, #18]

  if (dhcp->offered_t0_lease != 0xffffffffUL) {
 810f064:	69bb      	ldr	r3, [r7, #24]
 810f066:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 810f068:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 810f06c:	d019      	beq.n	810f0a2 <dhcp_bind+0x7e>
    /* set renewal period timer */
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_bind(): t0 renewal timer %"U32_F" secs\n", dhcp->offered_t0_lease));
    timeout = (dhcp->offered_t0_lease + DHCP_COARSE_TIMER_SECS / 2) / DHCP_COARSE_TIMER_SECS;
 810f06e:	69bb      	ldr	r3, [r7, #24]
 810f070:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 810f072:	331e      	adds	r3, #30
 810f074:	4a57      	ldr	r2, [pc, #348]	; (810f1d4 <dhcp_bind+0x1b0>)
 810f076:	fba2 2303 	umull	r2, r3, r2, r3
 810f07a:	095b      	lsrs	r3, r3, #5
 810f07c:	61fb      	str	r3, [r7, #28]
    if (timeout > 0xffff) {
 810f07e:	69fb      	ldr	r3, [r7, #28]
 810f080:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 810f084:	d302      	bcc.n	810f08c <dhcp_bind+0x68>
      timeout = 0xffff;
 810f086:	f64f 73ff 	movw	r3, #65535	; 0xffff
 810f08a:	61fb      	str	r3, [r7, #28]
    }
    dhcp->t0_timeout = (u16_t)timeout;
 810f08c:	69fb      	ldr	r3, [r7, #28]
 810f08e:	b29a      	uxth	r2, r3
 810f090:	69bb      	ldr	r3, [r7, #24]
 810f092:	829a      	strh	r2, [r3, #20]
    if (dhcp->t0_timeout == 0) {
 810f094:	69bb      	ldr	r3, [r7, #24]
 810f096:	8a9b      	ldrh	r3, [r3, #20]
 810f098:	2b00      	cmp	r3, #0
 810f09a:	d102      	bne.n	810f0a2 <dhcp_bind+0x7e>
      dhcp->t0_timeout = 1;
 810f09c:	69bb      	ldr	r3, [r7, #24]
 810f09e:	2201      	movs	r2, #1
 810f0a0:	829a      	strh	r2, [r3, #20]
    }
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_bind(): set request timeout %"U32_F" msecs\n", dhcp->offered_t0_lease * 1000));
  }

  /* temporary DHCP lease? */
  if (dhcp->offered_t1_renew != 0xffffffffUL) {
 810f0a2:	69bb      	ldr	r3, [r7, #24]
 810f0a4:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 810f0a6:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 810f0aa:	d01d      	beq.n	810f0e8 <dhcp_bind+0xc4>
    /* set renewal period timer */
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_bind(): t1 renewal timer %"U32_F" secs\n", dhcp->offered_t1_renew));
    timeout = (dhcp->offered_t1_renew + DHCP_COARSE_TIMER_SECS / 2) / DHCP_COARSE_TIMER_SECS;
 810f0ac:	69bb      	ldr	r3, [r7, #24]
 810f0ae:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 810f0b0:	331e      	adds	r3, #30
 810f0b2:	4a48      	ldr	r2, [pc, #288]	; (810f1d4 <dhcp_bind+0x1b0>)
 810f0b4:	fba2 2303 	umull	r2, r3, r2, r3
 810f0b8:	095b      	lsrs	r3, r3, #5
 810f0ba:	61fb      	str	r3, [r7, #28]
    if (timeout > 0xffff) {
 810f0bc:	69fb      	ldr	r3, [r7, #28]
 810f0be:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 810f0c2:	d302      	bcc.n	810f0ca <dhcp_bind+0xa6>
      timeout = 0xffff;
 810f0c4:	f64f 73ff 	movw	r3, #65535	; 0xffff
 810f0c8:	61fb      	str	r3, [r7, #28]
    }
    dhcp->t1_timeout = (u16_t)timeout;
 810f0ca:	69fb      	ldr	r3, [r7, #28]
 810f0cc:	b29a      	uxth	r2, r3
 810f0ce:	69bb      	ldr	r3, [r7, #24]
 810f0d0:	815a      	strh	r2, [r3, #10]
    if (dhcp->t1_timeout == 0) {
 810f0d2:	69bb      	ldr	r3, [r7, #24]
 810f0d4:	895b      	ldrh	r3, [r3, #10]
 810f0d6:	2b00      	cmp	r3, #0
 810f0d8:	d102      	bne.n	810f0e0 <dhcp_bind+0xbc>
      dhcp->t1_timeout = 1;
 810f0da:	69bb      	ldr	r3, [r7, #24]
 810f0dc:	2201      	movs	r2, #1
 810f0de:	815a      	strh	r2, [r3, #10]
    }
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_bind(): set request timeout %"U32_F" msecs\n", dhcp->offered_t1_renew * 1000));
    dhcp->t1_renew_time = dhcp->t1_timeout;
 810f0e0:	69bb      	ldr	r3, [r7, #24]
 810f0e2:	895a      	ldrh	r2, [r3, #10]
 810f0e4:	69bb      	ldr	r3, [r7, #24]
 810f0e6:	81da      	strh	r2, [r3, #14]
  }
  /* set renewal period timer */
  if (dhcp->offered_t2_rebind != 0xffffffffUL) {
 810f0e8:	69bb      	ldr	r3, [r7, #24]
 810f0ea:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 810f0ec:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 810f0f0:	d01d      	beq.n	810f12e <dhcp_bind+0x10a>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_bind(): t2 rebind timer %"U32_F" secs\n", dhcp->offered_t2_rebind));
    timeout = (dhcp->offered_t2_rebind + DHCP_COARSE_TIMER_SECS / 2) / DHCP_COARSE_TIMER_SECS;
 810f0f2:	69bb      	ldr	r3, [r7, #24]
 810f0f4:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 810f0f6:	331e      	adds	r3, #30
 810f0f8:	4a36      	ldr	r2, [pc, #216]	; (810f1d4 <dhcp_bind+0x1b0>)
 810f0fa:	fba2 2303 	umull	r2, r3, r2, r3
 810f0fe:	095b      	lsrs	r3, r3, #5
 810f100:	61fb      	str	r3, [r7, #28]
    if (timeout > 0xffff) {
 810f102:	69fb      	ldr	r3, [r7, #28]
 810f104:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 810f108:	d302      	bcc.n	810f110 <dhcp_bind+0xec>
      timeout = 0xffff;
 810f10a:	f64f 73ff 	movw	r3, #65535	; 0xffff
 810f10e:	61fb      	str	r3, [r7, #28]
    }
    dhcp->t2_timeout = (u16_t)timeout;
 810f110:	69fb      	ldr	r3, [r7, #28]
 810f112:	b29a      	uxth	r2, r3
 810f114:	69bb      	ldr	r3, [r7, #24]
 810f116:	819a      	strh	r2, [r3, #12]
    if (dhcp->t2_timeout == 0) {
 810f118:	69bb      	ldr	r3, [r7, #24]
 810f11a:	899b      	ldrh	r3, [r3, #12]
 810f11c:	2b00      	cmp	r3, #0
 810f11e:	d102      	bne.n	810f126 <dhcp_bind+0x102>
      dhcp->t2_timeout = 1;
 810f120:	69bb      	ldr	r3, [r7, #24]
 810f122:	2201      	movs	r2, #1
 810f124:	819a      	strh	r2, [r3, #12]
    }
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_bind(): set request timeout %"U32_F" msecs\n", dhcp->offered_t2_rebind * 1000));
    dhcp->t2_rebind_time = dhcp->t2_timeout;
 810f126:	69bb      	ldr	r3, [r7, #24]
 810f128:	899a      	ldrh	r2, [r3, #12]
 810f12a:	69bb      	ldr	r3, [r7, #24]
 810f12c:	821a      	strh	r2, [r3, #16]
  }

  /* If we have sub 1 minute lease, t2 and t1 will kick in at the same time. */
  if ((dhcp->t1_timeout >= dhcp->t2_timeout) && (dhcp->t2_timeout > 0)) {
 810f12e:	69bb      	ldr	r3, [r7, #24]
 810f130:	895a      	ldrh	r2, [r3, #10]
 810f132:	69bb      	ldr	r3, [r7, #24]
 810f134:	899b      	ldrh	r3, [r3, #12]
 810f136:	429a      	cmp	r2, r3
 810f138:	d306      	bcc.n	810f148 <dhcp_bind+0x124>
 810f13a:	69bb      	ldr	r3, [r7, #24]
 810f13c:	899b      	ldrh	r3, [r3, #12]
 810f13e:	2b00      	cmp	r3, #0
 810f140:	d002      	beq.n	810f148 <dhcp_bind+0x124>
    dhcp->t1_timeout = 0;
 810f142:	69bb      	ldr	r3, [r7, #24]
 810f144:	2200      	movs	r2, #0
 810f146:	815a      	strh	r2, [r3, #10]
  }

  if (dhcp->subnet_mask_given) {
 810f148:	69bb      	ldr	r3, [r7, #24]
 810f14a:	79db      	ldrb	r3, [r3, #7]
 810f14c:	2b00      	cmp	r3, #0
 810f14e:	d003      	beq.n	810f158 <dhcp_bind+0x134>
    /* copy offered network mask */
    ip4_addr_copy(sn_mask, dhcp->offered_sn_mask);
 810f150:	69bb      	ldr	r3, [r7, #24]
 810f152:	6a1b      	ldr	r3, [r3, #32]
 810f154:	613b      	str	r3, [r7, #16]
 810f156:	e014      	b.n	810f182 <dhcp_bind+0x15e>
  } else {
    /* subnet mask not given, choose a safe subnet mask given the network class */
    u8_t first_octet = ip4_addr1(&dhcp->offered_ip_addr);
 810f158:	69bb      	ldr	r3, [r7, #24]
 810f15a:	331c      	adds	r3, #28
 810f15c:	781b      	ldrb	r3, [r3, #0]
 810f15e:	75fb      	strb	r3, [r7, #23]
    if (first_octet <= 127) {
 810f160:	f997 3017 	ldrsb.w	r3, [r7, #23]
 810f164:	2b00      	cmp	r3, #0
 810f166:	db02      	blt.n	810f16e <dhcp_bind+0x14a>
      ip4_addr_set_u32(&sn_mask, PP_HTONL(0xff000000UL));
 810f168:	23ff      	movs	r3, #255	; 0xff
 810f16a:	613b      	str	r3, [r7, #16]
 810f16c:	e009      	b.n	810f182 <dhcp_bind+0x15e>
    } else if (first_octet >= 192) {
 810f16e:	7dfb      	ldrb	r3, [r7, #23]
 810f170:	2bbf      	cmp	r3, #191	; 0xbf
 810f172:	d903      	bls.n	810f17c <dhcp_bind+0x158>
      ip4_addr_set_u32(&sn_mask, PP_HTONL(0xffffff00UL));
 810f174:	f06f 437f 	mvn.w	r3, #4278190080	; 0xff000000
 810f178:	613b      	str	r3, [r7, #16]
 810f17a:	e002      	b.n	810f182 <dhcp_bind+0x15e>
    } else {
      ip4_addr_set_u32(&sn_mask, PP_HTONL(0xffff0000UL));
 810f17c:	f64f 73ff 	movw	r3, #65535	; 0xffff
 810f180:	613b      	str	r3, [r7, #16]
    }
  }

  ip4_addr_copy(gw_addr, dhcp->offered_gw_addr);
 810f182:	69bb      	ldr	r3, [r7, #24]
 810f184:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 810f186:	60fb      	str	r3, [r7, #12]
  /* gateway address not given? */
  if (ip4_addr_isany_val(gw_addr)) {
 810f188:	68fb      	ldr	r3, [r7, #12]
 810f18a:	2b00      	cmp	r3, #0
 810f18c:	d108      	bne.n	810f1a0 <dhcp_bind+0x17c>
    /* copy network address */
    ip4_addr_get_network(&gw_addr, &dhcp->offered_ip_addr, &sn_mask);
 810f18e:	69bb      	ldr	r3, [r7, #24]
 810f190:	69da      	ldr	r2, [r3, #28]
 810f192:	693b      	ldr	r3, [r7, #16]
 810f194:	4013      	ands	r3, r2
 810f196:	60fb      	str	r3, [r7, #12]
    /* use first host address on network as gateway */
    ip4_addr_set_u32(&gw_addr, ip4_addr_get_u32(&gw_addr) | PP_HTONL(0x00000001UL));
 810f198:	68fb      	ldr	r3, [r7, #12]
 810f19a:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 810f19e:	60fb      	str	r3, [r7, #12]

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_bind(): IP: 0x%08"X32_F" SN: 0x%08"X32_F" GW: 0x%08"X32_F"\n",
              ip4_addr_get_u32(&dhcp->offered_ip_addr), ip4_addr_get_u32(&sn_mask), ip4_addr_get_u32(&gw_addr)));
  /* netif is now bound to DHCP leased address - set this before assigning the address
     to ensure the callback can use dhcp_supplied_address() */
  dhcp_set_state(dhcp, DHCP_STATE_BOUND);
 810f1a0:	210a      	movs	r1, #10
 810f1a2:	69b8      	ldr	r0, [r7, #24]
 810f1a4:	f000 faa0 	bl	810f6e8 <dhcp_set_state>

  netif_set_addr(netif, &dhcp->offered_ip_addr, &sn_mask, &gw_addr);
 810f1a8:	69bb      	ldr	r3, [r7, #24]
 810f1aa:	f103 011c 	add.w	r1, r3, #28
 810f1ae:	f107 030c 	add.w	r3, r7, #12
 810f1b2:	f107 0210 	add.w	r2, r7, #16
 810f1b6:	6878      	ldr	r0, [r7, #4]
 810f1b8:	f004 fd8e 	bl	8113cd8 <netif_set_addr>
  /* interface is used by routing now that an address is set */
}
 810f1bc:	3720      	adds	r7, #32
 810f1be:	46bd      	mov	sp, r7
 810f1c0:	bd80      	pop	{r7, pc}
 810f1c2:	bf00      	nop
 810f1c4:	0811c788 	.word	0x0811c788
 810f1c8:	0811c918 	.word	0x0811c918
 810f1cc:	0811c818 	.word	0x0811c818
 810f1d0:	0811c934 	.word	0x0811c934
 810f1d4:	88888889 	.word	0x88888889

0810f1d8 <dhcp_renew>:
 *
 * @param netif network interface which must renew its lease
 */
err_t
dhcp_renew(struct netif *netif)
{
 810f1d8:	b580      	push	{r7, lr}
 810f1da:	b08a      	sub	sp, #40	; 0x28
 810f1dc:	af02      	add	r7, sp, #8
 810f1de:	6078      	str	r0, [r7, #4]
  struct dhcp *dhcp = netif_dhcp_data(netif);
 810f1e0:	687b      	ldr	r3, [r7, #4]
 810f1e2:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 810f1e4:	61bb      	str	r3, [r7, #24]
  struct pbuf *p_out;
  u16_t options_out_len;

  LWIP_ASSERT_CORE_LOCKED();
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_renew()\n"));
  dhcp_set_state(dhcp, DHCP_STATE_RENEWING);
 810f1e6:	2105      	movs	r1, #5
 810f1e8:	69b8      	ldr	r0, [r7, #24]
 810f1ea:	f000 fa7d 	bl	810f6e8 <dhcp_set_state>

  /* create and initialize the DHCP message header */
  p_out = dhcp_create_msg(netif, dhcp, DHCP_REQUEST, &options_out_len);
 810f1ee:	f107 030c 	add.w	r3, r7, #12
 810f1f2:	2203      	movs	r2, #3
 810f1f4:	69b9      	ldr	r1, [r7, #24]
 810f1f6:	6878      	ldr	r0, [r7, #4]
 810f1f8:	f000 ff32 	bl	8110060 <dhcp_create_msg>
 810f1fc:	6178      	str	r0, [r7, #20]
  if (p_out != NULL) {
 810f1fe:	697b      	ldr	r3, [r7, #20]
 810f200:	2b00      	cmp	r3, #0
 810f202:	d04e      	beq.n	810f2a2 <dhcp_renew+0xca>
    struct dhcp_msg *msg_out = (struct dhcp_msg *)p_out->payload;
 810f204:	697b      	ldr	r3, [r7, #20]
 810f206:	685b      	ldr	r3, [r3, #4]
 810f208:	613b      	str	r3, [r7, #16]
    options_out_len = dhcp_option(options_out_len, msg_out->options, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
 810f20a:	89b8      	ldrh	r0, [r7, #12]
 810f20c:	693b      	ldr	r3, [r7, #16]
 810f20e:	f103 01f0 	add.w	r1, r3, #240	; 0xf0
 810f212:	2302      	movs	r3, #2
 810f214:	2239      	movs	r2, #57	; 0x39
 810f216:	f000 fa81 	bl	810f71c <dhcp_option>
 810f21a:	4603      	mov	r3, r0
 810f21c:	81bb      	strh	r3, [r7, #12]
    options_out_len = dhcp_option_short(options_out_len, msg_out->options, DHCP_MAX_MSG_LEN(netif));
 810f21e:	89b8      	ldrh	r0, [r7, #12]
 810f220:	693b      	ldr	r3, [r7, #16]
 810f222:	f103 01f0 	add.w	r1, r3, #240	; 0xf0
 810f226:	687b      	ldr	r3, [r7, #4]
 810f228:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
 810f22a:	461a      	mov	r2, r3
 810f22c:	f000 fad0 	bl	810f7d0 <dhcp_option_short>
 810f230:	4603      	mov	r3, r0
 810f232:	81bb      	strh	r3, [r7, #12]

    options_out_len = dhcp_option(options_out_len, msg_out->options, DHCP_OPTION_PARAMETER_REQUEST_LIST, LWIP_ARRAYSIZE(dhcp_discover_request_options));
 810f234:	89b8      	ldrh	r0, [r7, #12]
 810f236:	693b      	ldr	r3, [r7, #16]
 810f238:	f103 01f0 	add.w	r1, r3, #240	; 0xf0
 810f23c:	2304      	movs	r3, #4
 810f23e:	2237      	movs	r2, #55	; 0x37
 810f240:	f000 fa6c 	bl	810f71c <dhcp_option>
 810f244:	4603      	mov	r3, r0
 810f246:	81bb      	strh	r3, [r7, #12]
    for (i = 0; i < LWIP_ARRAYSIZE(dhcp_discover_request_options); i++) {
 810f248:	2300      	movs	r3, #0
 810f24a:	77bb      	strb	r3, [r7, #30]
 810f24c:	e00e      	b.n	810f26c <dhcp_renew+0x94>
      options_out_len = dhcp_option_byte(options_out_len, msg_out->options, dhcp_discover_request_options[i]);
 810f24e:	89b8      	ldrh	r0, [r7, #12]
 810f250:	693b      	ldr	r3, [r7, #16]
 810f252:	f103 01f0 	add.w	r1, r3, #240	; 0xf0
 810f256:	7fbb      	ldrb	r3, [r7, #30]
 810f258:	4a2a      	ldr	r2, [pc, #168]	; (810f304 <dhcp_renew+0x12c>)
 810f25a:	5cd3      	ldrb	r3, [r2, r3]
 810f25c:	461a      	mov	r2, r3
 810f25e:	f000 fa91 	bl	810f784 <dhcp_option_byte>
 810f262:	4603      	mov	r3, r0
 810f264:	81bb      	strh	r3, [r7, #12]
    for (i = 0; i < LWIP_ARRAYSIZE(dhcp_discover_request_options); i++) {
 810f266:	7fbb      	ldrb	r3, [r7, #30]
 810f268:	3301      	adds	r3, #1
 810f26a:	77bb      	strb	r3, [r7, #30]
 810f26c:	7fbb      	ldrb	r3, [r7, #30]
 810f26e:	2b03      	cmp	r3, #3
 810f270:	d9ed      	bls.n	810f24e <dhcp_renew+0x76>
#if LWIP_NETIF_HOSTNAME
    options_out_len = dhcp_option_hostname(options_out_len, msg_out->options, netif);
#endif /* LWIP_NETIF_HOSTNAME */

    LWIP_HOOK_DHCP_APPEND_OPTIONS(netif, dhcp, DHCP_STATE_RENEWING, msg_out, DHCP_REQUEST, &options_out_len);
    dhcp_option_trailer(options_out_len, msg_out->options, p_out);
 810f272:	89b8      	ldrh	r0, [r7, #12]
 810f274:	693b      	ldr	r3, [r7, #16]
 810f276:	33f0      	adds	r3, #240	; 0xf0
 810f278:	697a      	ldr	r2, [r7, #20]
 810f27a:	4619      	mov	r1, r3
 810f27c:	f000 ffc6 	bl	811020c <dhcp_option_trailer>

    result = udp_sendto_if(dhcp_pcb, p_out, &dhcp->server_ip_addr, LWIP_IANA_PORT_DHCP_SERVER, netif);
 810f280:	4b21      	ldr	r3, [pc, #132]	; (810f308 <dhcp_renew+0x130>)
 810f282:	6818      	ldr	r0, [r3, #0]
 810f284:	69bb      	ldr	r3, [r7, #24]
 810f286:	f103 0218 	add.w	r2, r3, #24
 810f28a:	687b      	ldr	r3, [r7, #4]
 810f28c:	9300      	str	r3, [sp, #0]
 810f28e:	2343      	movs	r3, #67	; 0x43
 810f290:	6979      	ldr	r1, [r7, #20]
 810f292:	f00b fa5b 	bl	811a74c <udp_sendto_if>
 810f296:	4603      	mov	r3, r0
 810f298:	77fb      	strb	r3, [r7, #31]
    pbuf_free(p_out);
 810f29a:	6978      	ldr	r0, [r7, #20]
 810f29c:	f005 f9dc 	bl	8114658 <pbuf_free>
 810f2a0:	e001      	b.n	810f2a6 <dhcp_renew+0xce>

    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_renew: RENEWING\n"));
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("dhcp_renew: could not allocate DHCP request\n"));
    result = ERR_MEM;
 810f2a2:	23ff      	movs	r3, #255	; 0xff
 810f2a4:	77fb      	strb	r3, [r7, #31]
  }
  if (dhcp->tries < 255) {
 810f2a6:	69bb      	ldr	r3, [r7, #24]
 810f2a8:	799b      	ldrb	r3, [r3, #6]
 810f2aa:	2bff      	cmp	r3, #255	; 0xff
 810f2ac:	d005      	beq.n	810f2ba <dhcp_renew+0xe2>
    dhcp->tries++;
 810f2ae:	69bb      	ldr	r3, [r7, #24]
 810f2b0:	799b      	ldrb	r3, [r3, #6]
 810f2b2:	3301      	adds	r3, #1
 810f2b4:	b2da      	uxtb	r2, r3
 810f2b6:	69bb      	ldr	r3, [r7, #24]
 810f2b8:	719a      	strb	r2, [r3, #6]
  }
  /* back-off on retries, but to a maximum of 20 seconds */
  msecs = (u16_t)(dhcp->tries < 10 ? dhcp->tries * 2000 : 20 * 1000);
 810f2ba:	69bb      	ldr	r3, [r7, #24]
 810f2bc:	799b      	ldrb	r3, [r3, #6]
 810f2be:	2b09      	cmp	r3, #9
 810f2c0:	d80a      	bhi.n	810f2d8 <dhcp_renew+0x100>
 810f2c2:	69bb      	ldr	r3, [r7, #24]
 810f2c4:	799b      	ldrb	r3, [r3, #6]
 810f2c6:	b29b      	uxth	r3, r3
 810f2c8:	461a      	mov	r2, r3
 810f2ca:	0152      	lsls	r2, r2, #5
 810f2cc:	1ad2      	subs	r2, r2, r3
 810f2ce:	0092      	lsls	r2, r2, #2
 810f2d0:	4413      	add	r3, r2
 810f2d2:	011b      	lsls	r3, r3, #4
 810f2d4:	b29b      	uxth	r3, r3
 810f2d6:	e001      	b.n	810f2dc <dhcp_renew+0x104>
 810f2d8:	f644 6320 	movw	r3, #20000	; 0x4e20
 810f2dc:	81fb      	strh	r3, [r7, #14]
  dhcp->request_timeout = (u16_t)((msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS);
 810f2de:	89fb      	ldrh	r3, [r7, #14]
 810f2e0:	f203 13f3 	addw	r3, r3, #499	; 0x1f3
 810f2e4:	4a09      	ldr	r2, [pc, #36]	; (810f30c <dhcp_renew+0x134>)
 810f2e6:	fb82 1203 	smull	r1, r2, r2, r3
 810f2ea:	1152      	asrs	r2, r2, #5
 810f2ec:	17db      	asrs	r3, r3, #31
 810f2ee:	1ad3      	subs	r3, r2, r3
 810f2f0:	b29a      	uxth	r2, r3
 810f2f2:	69bb      	ldr	r3, [r7, #24]
 810f2f4:	811a      	strh	r2, [r3, #8]
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_renew(): set request timeout %"U16_F" msecs\n", msecs));
  return result;
 810f2f6:	f997 301f 	ldrsb.w	r3, [r7, #31]
}
 810f2fa:	4618      	mov	r0, r3
 810f2fc:	3720      	adds	r7, #32
 810f2fe:	46bd      	mov	sp, r7
 810f300:	bd80      	pop	{r7, pc}
 810f302:	bf00      	nop
 810f304:	10000100 	.word	0x10000100
 810f308:	10004f68 	.word	0x10004f68
 810f30c:	10624dd3 	.word	0x10624dd3

0810f310 <dhcp_rebind>:
 *
 * @param netif network interface which must rebind with a DHCP server
 */
static err_t
dhcp_rebind(struct netif *netif)
{
 810f310:	b580      	push	{r7, lr}
 810f312:	b08a      	sub	sp, #40	; 0x28
 810f314:	af02      	add	r7, sp, #8
 810f316:	6078      	str	r0, [r7, #4]
  struct dhcp *dhcp = netif_dhcp_data(netif);
 810f318:	687b      	ldr	r3, [r7, #4]
 810f31a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 810f31c:	61bb      	str	r3, [r7, #24]
  u8_t i;
  struct pbuf *p_out;
  u16_t options_out_len;

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_rebind()\n"));
  dhcp_set_state(dhcp, DHCP_STATE_REBINDING);
 810f31e:	2104      	movs	r1, #4
 810f320:	69b8      	ldr	r0, [r7, #24]
 810f322:	f000 f9e1 	bl	810f6e8 <dhcp_set_state>

  /* create and initialize the DHCP message header */
  p_out = dhcp_create_msg(netif, dhcp, DHCP_REQUEST, &options_out_len);
 810f326:	f107 030c 	add.w	r3, r7, #12
 810f32a:	2203      	movs	r2, #3
 810f32c:	69b9      	ldr	r1, [r7, #24]
 810f32e:	6878      	ldr	r0, [r7, #4]
 810f330:	f000 fe96 	bl	8110060 <dhcp_create_msg>
 810f334:	6178      	str	r0, [r7, #20]
  if (p_out != NULL) {
 810f336:	697b      	ldr	r3, [r7, #20]
 810f338:	2b00      	cmp	r3, #0
 810f33a:	d04c      	beq.n	810f3d6 <dhcp_rebind+0xc6>
    struct dhcp_msg *msg_out = (struct dhcp_msg *)p_out->payload;
 810f33c:	697b      	ldr	r3, [r7, #20]
 810f33e:	685b      	ldr	r3, [r3, #4]
 810f340:	613b      	str	r3, [r7, #16]
    options_out_len = dhcp_option(options_out_len, msg_out->options, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
 810f342:	89b8      	ldrh	r0, [r7, #12]
 810f344:	693b      	ldr	r3, [r7, #16]
 810f346:	f103 01f0 	add.w	r1, r3, #240	; 0xf0
 810f34a:	2302      	movs	r3, #2
 810f34c:	2239      	movs	r2, #57	; 0x39
 810f34e:	f000 f9e5 	bl	810f71c <dhcp_option>
 810f352:	4603      	mov	r3, r0
 810f354:	81bb      	strh	r3, [r7, #12]
    options_out_len = dhcp_option_short(options_out_len, msg_out->options, DHCP_MAX_MSG_LEN(netif));
 810f356:	89b8      	ldrh	r0, [r7, #12]
 810f358:	693b      	ldr	r3, [r7, #16]
 810f35a:	f103 01f0 	add.w	r1, r3, #240	; 0xf0
 810f35e:	687b      	ldr	r3, [r7, #4]
 810f360:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
 810f362:	461a      	mov	r2, r3
 810f364:	f000 fa34 	bl	810f7d0 <dhcp_option_short>
 810f368:	4603      	mov	r3, r0
 810f36a:	81bb      	strh	r3, [r7, #12]

    options_out_len = dhcp_option(options_out_len, msg_out->options, DHCP_OPTION_PARAMETER_REQUEST_LIST, LWIP_ARRAYSIZE(dhcp_discover_request_options));
 810f36c:	89b8      	ldrh	r0, [r7, #12]
 810f36e:	693b      	ldr	r3, [r7, #16]
 810f370:	f103 01f0 	add.w	r1, r3, #240	; 0xf0
 810f374:	2304      	movs	r3, #4
 810f376:	2237      	movs	r2, #55	; 0x37
 810f378:	f000 f9d0 	bl	810f71c <dhcp_option>
 810f37c:	4603      	mov	r3, r0
 810f37e:	81bb      	strh	r3, [r7, #12]
    for (i = 0; i < LWIP_ARRAYSIZE(dhcp_discover_request_options); i++) {
 810f380:	2300      	movs	r3, #0
 810f382:	77bb      	strb	r3, [r7, #30]
 810f384:	e00e      	b.n	810f3a4 <dhcp_rebind+0x94>
      options_out_len = dhcp_option_byte(options_out_len, msg_out->options, dhcp_discover_request_options[i]);
 810f386:	89b8      	ldrh	r0, [r7, #12]
 810f388:	693b      	ldr	r3, [r7, #16]
 810f38a:	f103 01f0 	add.w	r1, r3, #240	; 0xf0
 810f38e:	7fbb      	ldrb	r3, [r7, #30]
 810f390:	4a29      	ldr	r2, [pc, #164]	; (810f438 <dhcp_rebind+0x128>)
 810f392:	5cd3      	ldrb	r3, [r2, r3]
 810f394:	461a      	mov	r2, r3
 810f396:	f000 f9f5 	bl	810f784 <dhcp_option_byte>
 810f39a:	4603      	mov	r3, r0
 810f39c:	81bb      	strh	r3, [r7, #12]
    for (i = 0; i < LWIP_ARRAYSIZE(dhcp_discover_request_options); i++) {
 810f39e:	7fbb      	ldrb	r3, [r7, #30]
 810f3a0:	3301      	adds	r3, #1
 810f3a2:	77bb      	strb	r3, [r7, #30]
 810f3a4:	7fbb      	ldrb	r3, [r7, #30]
 810f3a6:	2b03      	cmp	r3, #3
 810f3a8:	d9ed      	bls.n	810f386 <dhcp_rebind+0x76>
#if LWIP_NETIF_HOSTNAME
    options_out_len = dhcp_option_hostname(options_out_len, msg_out->options, netif);
#endif /* LWIP_NETIF_HOSTNAME */

    LWIP_HOOK_DHCP_APPEND_OPTIONS(netif, dhcp, DHCP_STATE_REBINDING, msg_out, DHCP_DISCOVER, &options_out_len);
    dhcp_option_trailer(options_out_len, msg_out->options, p_out);
 810f3aa:	89b8      	ldrh	r0, [r7, #12]
 810f3ac:	693b      	ldr	r3, [r7, #16]
 810f3ae:	33f0      	adds	r3, #240	; 0xf0
 810f3b0:	697a      	ldr	r2, [r7, #20]
 810f3b2:	4619      	mov	r1, r3
 810f3b4:	f000 ff2a 	bl	811020c <dhcp_option_trailer>

    /* broadcast to server */
    result = udp_sendto_if(dhcp_pcb, p_out, IP_ADDR_BROADCAST, LWIP_IANA_PORT_DHCP_SERVER, netif);
 810f3b8:	4b20      	ldr	r3, [pc, #128]	; (810f43c <dhcp_rebind+0x12c>)
 810f3ba:	6818      	ldr	r0, [r3, #0]
 810f3bc:	687b      	ldr	r3, [r7, #4]
 810f3be:	9300      	str	r3, [sp, #0]
 810f3c0:	2343      	movs	r3, #67	; 0x43
 810f3c2:	4a1f      	ldr	r2, [pc, #124]	; (810f440 <dhcp_rebind+0x130>)
 810f3c4:	6979      	ldr	r1, [r7, #20]
 810f3c6:	f00b f9c1 	bl	811a74c <udp_sendto_if>
 810f3ca:	4603      	mov	r3, r0
 810f3cc:	77fb      	strb	r3, [r7, #31]
    pbuf_free(p_out);
 810f3ce:	6978      	ldr	r0, [r7, #20]
 810f3d0:	f005 f942 	bl	8114658 <pbuf_free>
 810f3d4:	e001      	b.n	810f3da <dhcp_rebind+0xca>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_rebind: REBINDING\n"));
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("dhcp_rebind: could not allocate DHCP request\n"));
    result = ERR_MEM;
 810f3d6:	23ff      	movs	r3, #255	; 0xff
 810f3d8:	77fb      	strb	r3, [r7, #31]
  }
  if (dhcp->tries < 255) {
 810f3da:	69bb      	ldr	r3, [r7, #24]
 810f3dc:	799b      	ldrb	r3, [r3, #6]
 810f3de:	2bff      	cmp	r3, #255	; 0xff
 810f3e0:	d005      	beq.n	810f3ee <dhcp_rebind+0xde>
    dhcp->tries++;
 810f3e2:	69bb      	ldr	r3, [r7, #24]
 810f3e4:	799b      	ldrb	r3, [r3, #6]
 810f3e6:	3301      	adds	r3, #1
 810f3e8:	b2da      	uxtb	r2, r3
 810f3ea:	69bb      	ldr	r3, [r7, #24]
 810f3ec:	719a      	strb	r2, [r3, #6]
  }
  msecs = (u16_t)(dhcp->tries < 10 ? dhcp->tries * 1000 : 10 * 1000);
 810f3ee:	69bb      	ldr	r3, [r7, #24]
 810f3f0:	799b      	ldrb	r3, [r3, #6]
 810f3f2:	2b09      	cmp	r3, #9
 810f3f4:	d80a      	bhi.n	810f40c <dhcp_rebind+0xfc>
 810f3f6:	69bb      	ldr	r3, [r7, #24]
 810f3f8:	799b      	ldrb	r3, [r3, #6]
 810f3fa:	b29b      	uxth	r3, r3
 810f3fc:	461a      	mov	r2, r3
 810f3fe:	0152      	lsls	r2, r2, #5
 810f400:	1ad2      	subs	r2, r2, r3
 810f402:	0092      	lsls	r2, r2, #2
 810f404:	4413      	add	r3, r2
 810f406:	00db      	lsls	r3, r3, #3
 810f408:	b29b      	uxth	r3, r3
 810f40a:	e001      	b.n	810f410 <dhcp_rebind+0x100>
 810f40c:	f242 7310 	movw	r3, #10000	; 0x2710
 810f410:	81fb      	strh	r3, [r7, #14]
  dhcp->request_timeout = (u16_t)((msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS);
 810f412:	89fb      	ldrh	r3, [r7, #14]
 810f414:	f203 13f3 	addw	r3, r3, #499	; 0x1f3
 810f418:	4a0a      	ldr	r2, [pc, #40]	; (810f444 <dhcp_rebind+0x134>)
 810f41a:	fb82 1203 	smull	r1, r2, r2, r3
 810f41e:	1152      	asrs	r2, r2, #5
 810f420:	17db      	asrs	r3, r3, #31
 810f422:	1ad3      	subs	r3, r2, r3
 810f424:	b29a      	uxth	r2, r3
 810f426:	69bb      	ldr	r3, [r7, #24]
 810f428:	811a      	strh	r2, [r3, #8]
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_rebind(): set request timeout %"U16_F" msecs\n", msecs));
  return result;
 810f42a:	f997 301f 	ldrsb.w	r3, [r7, #31]
}
 810f42e:	4618      	mov	r0, r3
 810f430:	3720      	adds	r7, #32
 810f432:	46bd      	mov	sp, r7
 810f434:	bd80      	pop	{r7, pc}
 810f436:	bf00      	nop
 810f438:	10000100 	.word	0x10000100
 810f43c:	10004f68 	.word	0x10004f68
 810f440:	0811f938 	.word	0x0811f938
 810f444:	10624dd3 	.word	0x10624dd3

0810f448 <dhcp_reboot>:
 *
 * @param netif network interface which must reboot
 */
static err_t
dhcp_reboot(struct netif *netif)
{
 810f448:	b5b0      	push	{r4, r5, r7, lr}
 810f44a:	b08a      	sub	sp, #40	; 0x28
 810f44c:	af02      	add	r7, sp, #8
 810f44e:	6078      	str	r0, [r7, #4]
  struct dhcp *dhcp = netif_dhcp_data(netif);
 810f450:	687b      	ldr	r3, [r7, #4]
 810f452:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 810f454:	61bb      	str	r3, [r7, #24]
  u8_t i;
  struct pbuf *p_out;
  u16_t options_out_len;

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_reboot()\n"));
  dhcp_set_state(dhcp, DHCP_STATE_REBOOTING);
 810f456:	2103      	movs	r1, #3
 810f458:	69b8      	ldr	r0, [r7, #24]
 810f45a:	f000 f945 	bl	810f6e8 <dhcp_set_state>

  /* create and initialize the DHCP message header */
  p_out = dhcp_create_msg(netif, dhcp, DHCP_REQUEST, &options_out_len);
 810f45e:	f107 030c 	add.w	r3, r7, #12
 810f462:	2203      	movs	r2, #3
 810f464:	69b9      	ldr	r1, [r7, #24]
 810f466:	6878      	ldr	r0, [r7, #4]
 810f468:	f000 fdfa 	bl	8110060 <dhcp_create_msg>
 810f46c:	6178      	str	r0, [r7, #20]
  if (p_out != NULL) {
 810f46e:	697b      	ldr	r3, [r7, #20]
 810f470:	2b00      	cmp	r3, #0
 810f472:	d066      	beq.n	810f542 <dhcp_reboot+0xfa>
    struct dhcp_msg *msg_out = (struct dhcp_msg *)p_out->payload;
 810f474:	697b      	ldr	r3, [r7, #20]
 810f476:	685b      	ldr	r3, [r3, #4]
 810f478:	613b      	str	r3, [r7, #16]
    options_out_len = dhcp_option(options_out_len, msg_out->options, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
 810f47a:	89b8      	ldrh	r0, [r7, #12]
 810f47c:	693b      	ldr	r3, [r7, #16]
 810f47e:	f103 01f0 	add.w	r1, r3, #240	; 0xf0
 810f482:	2302      	movs	r3, #2
 810f484:	2239      	movs	r2, #57	; 0x39
 810f486:	f000 f949 	bl	810f71c <dhcp_option>
 810f48a:	4603      	mov	r3, r0
 810f48c:	81bb      	strh	r3, [r7, #12]
    options_out_len = dhcp_option_short(options_out_len, msg_out->options, DHCP_MAX_MSG_LEN_MIN_REQUIRED);
 810f48e:	89b8      	ldrh	r0, [r7, #12]
 810f490:	693b      	ldr	r3, [r7, #16]
 810f492:	33f0      	adds	r3, #240	; 0xf0
 810f494:	f44f 7210 	mov.w	r2, #576	; 0x240
 810f498:	4619      	mov	r1, r3
 810f49a:	f000 f999 	bl	810f7d0 <dhcp_option_short>
 810f49e:	4603      	mov	r3, r0
 810f4a0:	81bb      	strh	r3, [r7, #12]

    options_out_len = dhcp_option(options_out_len, msg_out->options, DHCP_OPTION_REQUESTED_IP, 4);
 810f4a2:	89b8      	ldrh	r0, [r7, #12]
 810f4a4:	693b      	ldr	r3, [r7, #16]
 810f4a6:	f103 01f0 	add.w	r1, r3, #240	; 0xf0
 810f4aa:	2304      	movs	r3, #4
 810f4ac:	2232      	movs	r2, #50	; 0x32
 810f4ae:	f000 f935 	bl	810f71c <dhcp_option>
 810f4b2:	4603      	mov	r3, r0
 810f4b4:	81bb      	strh	r3, [r7, #12]
    options_out_len = dhcp_option_long(options_out_len, msg_out->options, lwip_ntohl(ip4_addr_get_u32(&dhcp->offered_ip_addr)));
 810f4b6:	89bc      	ldrh	r4, [r7, #12]
 810f4b8:	693b      	ldr	r3, [r7, #16]
 810f4ba:	f103 05f0 	add.w	r5, r3, #240	; 0xf0
 810f4be:	69bb      	ldr	r3, [r7, #24]
 810f4c0:	69db      	ldr	r3, [r3, #28]
 810f4c2:	4618      	mov	r0, r3
 810f4c4:	f7fe fffa 	bl	810e4bc <lwip_htonl>
 810f4c8:	4603      	mov	r3, r0
 810f4ca:	461a      	mov	r2, r3
 810f4cc:	4629      	mov	r1, r5
 810f4ce:	4620      	mov	r0, r4
 810f4d0:	f000 f9b0 	bl	810f834 <dhcp_option_long>
 810f4d4:	4603      	mov	r3, r0
 810f4d6:	81bb      	strh	r3, [r7, #12]

    options_out_len = dhcp_option(options_out_len, msg_out->options, DHCP_OPTION_PARAMETER_REQUEST_LIST, LWIP_ARRAYSIZE(dhcp_discover_request_options));
 810f4d8:	89b8      	ldrh	r0, [r7, #12]
 810f4da:	693b      	ldr	r3, [r7, #16]
 810f4dc:	f103 01f0 	add.w	r1, r3, #240	; 0xf0
 810f4e0:	2304      	movs	r3, #4
 810f4e2:	2237      	movs	r2, #55	; 0x37
 810f4e4:	f000 f91a 	bl	810f71c <dhcp_option>
 810f4e8:	4603      	mov	r3, r0
 810f4ea:	81bb      	strh	r3, [r7, #12]
    for (i = 0; i < LWIP_ARRAYSIZE(dhcp_discover_request_options); i++) {
 810f4ec:	2300      	movs	r3, #0
 810f4ee:	77bb      	strb	r3, [r7, #30]
 810f4f0:	e00e      	b.n	810f510 <dhcp_reboot+0xc8>
      options_out_len = dhcp_option_byte(options_out_len, msg_out->options, dhcp_discover_request_options[i]);
 810f4f2:	89b8      	ldrh	r0, [r7, #12]
 810f4f4:	693b      	ldr	r3, [r7, #16]
 810f4f6:	f103 01f0 	add.w	r1, r3, #240	; 0xf0
 810f4fa:	7fbb      	ldrb	r3, [r7, #30]
 810f4fc:	4a29      	ldr	r2, [pc, #164]	; (810f5a4 <dhcp_reboot+0x15c>)
 810f4fe:	5cd3      	ldrb	r3, [r2, r3]
 810f500:	461a      	mov	r2, r3
 810f502:	f000 f93f 	bl	810f784 <dhcp_option_byte>
 810f506:	4603      	mov	r3, r0
 810f508:	81bb      	strh	r3, [r7, #12]
    for (i = 0; i < LWIP_ARRAYSIZE(dhcp_discover_request_options); i++) {
 810f50a:	7fbb      	ldrb	r3, [r7, #30]
 810f50c:	3301      	adds	r3, #1
 810f50e:	77bb      	strb	r3, [r7, #30]
 810f510:	7fbb      	ldrb	r3, [r7, #30]
 810f512:	2b03      	cmp	r3, #3
 810f514:	d9ed      	bls.n	810f4f2 <dhcp_reboot+0xaa>
#if LWIP_NETIF_HOSTNAME
    options_out_len = dhcp_option_hostname(options_out_len, msg_out->options, netif);
#endif /* LWIP_NETIF_HOSTNAME */

    LWIP_HOOK_DHCP_APPEND_OPTIONS(netif, dhcp, DHCP_STATE_REBOOTING, msg_out, DHCP_REQUEST, &options_out_len);
    dhcp_option_trailer(options_out_len, msg_out->options, p_out);
 810f516:	89b8      	ldrh	r0, [r7, #12]
 810f518:	693b      	ldr	r3, [r7, #16]
 810f51a:	33f0      	adds	r3, #240	; 0xf0
 810f51c:	697a      	ldr	r2, [r7, #20]
 810f51e:	4619      	mov	r1, r3
 810f520:	f000 fe74 	bl	811020c <dhcp_option_trailer>

    /* broadcast to server */
    result = udp_sendto_if(dhcp_pcb, p_out, IP_ADDR_BROADCAST, LWIP_IANA_PORT_DHCP_SERVER, netif);
 810f524:	4b20      	ldr	r3, [pc, #128]	; (810f5a8 <dhcp_reboot+0x160>)
 810f526:	6818      	ldr	r0, [r3, #0]
 810f528:	687b      	ldr	r3, [r7, #4]
 810f52a:	9300      	str	r3, [sp, #0]
 810f52c:	2343      	movs	r3, #67	; 0x43
 810f52e:	4a1f      	ldr	r2, [pc, #124]	; (810f5ac <dhcp_reboot+0x164>)
 810f530:	6979      	ldr	r1, [r7, #20]
 810f532:	f00b f90b 	bl	811a74c <udp_sendto_if>
 810f536:	4603      	mov	r3, r0
 810f538:	77fb      	strb	r3, [r7, #31]
    pbuf_free(p_out);
 810f53a:	6978      	ldr	r0, [r7, #20]
 810f53c:	f005 f88c 	bl	8114658 <pbuf_free>
 810f540:	e001      	b.n	810f546 <dhcp_reboot+0xfe>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_reboot: REBOOTING\n"));
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("dhcp_reboot: could not allocate DHCP request\n"));
    result = ERR_MEM;
 810f542:	23ff      	movs	r3, #255	; 0xff
 810f544:	77fb      	strb	r3, [r7, #31]
  }
  if (dhcp->tries < 255) {
 810f546:	69bb      	ldr	r3, [r7, #24]
 810f548:	799b      	ldrb	r3, [r3, #6]
 810f54a:	2bff      	cmp	r3, #255	; 0xff
 810f54c:	d005      	beq.n	810f55a <dhcp_reboot+0x112>
    dhcp->tries++;
 810f54e:	69bb      	ldr	r3, [r7, #24]
 810f550:	799b      	ldrb	r3, [r3, #6]
 810f552:	3301      	adds	r3, #1
 810f554:	b2da      	uxtb	r2, r3
 810f556:	69bb      	ldr	r3, [r7, #24]
 810f558:	719a      	strb	r2, [r3, #6]
  }
  msecs = (u16_t)(dhcp->tries < 10 ? dhcp->tries * 1000 : 10 * 1000);
 810f55a:	69bb      	ldr	r3, [r7, #24]
 810f55c:	799b      	ldrb	r3, [r3, #6]
 810f55e:	2b09      	cmp	r3, #9
 810f560:	d80a      	bhi.n	810f578 <dhcp_reboot+0x130>
 810f562:	69bb      	ldr	r3, [r7, #24]
 810f564:	799b      	ldrb	r3, [r3, #6]
 810f566:	b29b      	uxth	r3, r3
 810f568:	461a      	mov	r2, r3
 810f56a:	0152      	lsls	r2, r2, #5
 810f56c:	1ad2      	subs	r2, r2, r3
 810f56e:	0092      	lsls	r2, r2, #2
 810f570:	4413      	add	r3, r2
 810f572:	00db      	lsls	r3, r3, #3
 810f574:	b29b      	uxth	r3, r3
 810f576:	e001      	b.n	810f57c <dhcp_reboot+0x134>
 810f578:	f242 7310 	movw	r3, #10000	; 0x2710
 810f57c:	81fb      	strh	r3, [r7, #14]
  dhcp->request_timeout = (u16_t)((msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS);
 810f57e:	89fb      	ldrh	r3, [r7, #14]
 810f580:	f203 13f3 	addw	r3, r3, #499	; 0x1f3
 810f584:	4a0a      	ldr	r2, [pc, #40]	; (810f5b0 <dhcp_reboot+0x168>)
 810f586:	fb82 1203 	smull	r1, r2, r2, r3
 810f58a:	1152      	asrs	r2, r2, #5
 810f58c:	17db      	asrs	r3, r3, #31
 810f58e:	1ad3      	subs	r3, r2, r3
 810f590:	b29a      	uxth	r2, r3
 810f592:	69bb      	ldr	r3, [r7, #24]
 810f594:	811a      	strh	r2, [r3, #8]
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_reboot(): set request timeout %"U16_F" msecs\n", msecs));
  return result;
 810f596:	f997 301f 	ldrsb.w	r3, [r7, #31]
}
 810f59a:	4618      	mov	r0, r3
 810f59c:	3720      	adds	r7, #32
 810f59e:	46bd      	mov	sp, r7
 810f5a0:	bdb0      	pop	{r4, r5, r7, pc}
 810f5a2:	bf00      	nop
 810f5a4:	10000100 	.word	0x10000100
 810f5a8:	10004f68 	.word	0x10004f68
 810f5ac:	0811f938 	.word	0x0811f938
 810f5b0:	10624dd3 	.word	0x10624dd3

0810f5b4 <dhcp_release_and_stop>:
 *
 * @param netif network interface
 */
void
dhcp_release_and_stop(struct netif *netif)
{
 810f5b4:	b5b0      	push	{r4, r5, r7, lr}
 810f5b6:	b08a      	sub	sp, #40	; 0x28
 810f5b8:	af02      	add	r7, sp, #8
 810f5ba:	6078      	str	r0, [r7, #4]
  struct dhcp *dhcp = netif_dhcp_data(netif);
 810f5bc:	687b      	ldr	r3, [r7, #4]
 810f5be:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 810f5c0:	61fb      	str	r3, [r7, #28]
  ip_addr_t server_ip_addr;

  LWIP_ASSERT_CORE_LOCKED();
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_release_and_stop()\n"));
  if (dhcp == NULL) {
 810f5c2:	69fb      	ldr	r3, [r7, #28]
 810f5c4:	2b00      	cmp	r3, #0
 810f5c6:	f000 8084 	beq.w	810f6d2 <dhcp_release_and_stop+0x11e>
    return;
  }

  /* already off? -> nothing to do */
  if (dhcp->state == DHCP_STATE_OFF) {
 810f5ca:	69fb      	ldr	r3, [r7, #28]
 810f5cc:	795b      	ldrb	r3, [r3, #5]
 810f5ce:	2b00      	cmp	r3, #0
 810f5d0:	f000 8081 	beq.w	810f6d6 <dhcp_release_and_stop+0x122>
    return;
  }

  ip_addr_copy(server_ip_addr, dhcp->server_ip_addr);
 810f5d4:	69fb      	ldr	r3, [r7, #28]
 810f5d6:	699b      	ldr	r3, [r3, #24]
 810f5d8:	613b      	str	r3, [r7, #16]

  /* clean old DHCP offer */
  ip_addr_set_zero_ip4(&dhcp->server_ip_addr);
 810f5da:	69fb      	ldr	r3, [r7, #28]
 810f5dc:	2200      	movs	r2, #0
 810f5de:	619a      	str	r2, [r3, #24]
  ip4_addr_set_zero(&dhcp->offered_ip_addr);
 810f5e0:	69fb      	ldr	r3, [r7, #28]
 810f5e2:	2200      	movs	r2, #0
 810f5e4:	61da      	str	r2, [r3, #28]
  ip4_addr_set_zero(&dhcp->offered_sn_mask);
 810f5e6:	69fb      	ldr	r3, [r7, #28]
 810f5e8:	2200      	movs	r2, #0
 810f5ea:	621a      	str	r2, [r3, #32]
  ip4_addr_set_zero(&dhcp->offered_gw_addr);
 810f5ec:	69fb      	ldr	r3, [r7, #28]
 810f5ee:	2200      	movs	r2, #0
 810f5f0:	625a      	str	r2, [r3, #36]	; 0x24
#if LWIP_DHCP_BOOTP_FILE
  ip4_addr_set_zero(&dhcp->offered_si_addr);
#endif /* LWIP_DHCP_BOOTP_FILE */
  dhcp->offered_t0_lease = dhcp->offered_t1_renew = dhcp->offered_t2_rebind = 0;
 810f5f2:	69fb      	ldr	r3, [r7, #28]
 810f5f4:	2200      	movs	r2, #0
 810f5f6:	631a      	str	r2, [r3, #48]	; 0x30
 810f5f8:	69fb      	ldr	r3, [r7, #28]
 810f5fa:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 810f5fc:	69fb      	ldr	r3, [r7, #28]
 810f5fe:	62da      	str	r2, [r3, #44]	; 0x2c
 810f600:	69fb      	ldr	r3, [r7, #28]
 810f602:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 810f604:	69fb      	ldr	r3, [r7, #28]
 810f606:	629a      	str	r2, [r3, #40]	; 0x28
  dhcp->t1_renew_time = dhcp->t2_rebind_time = dhcp->lease_used = dhcp->t0_timeout = 0;
 810f608:	69fb      	ldr	r3, [r7, #28]
 810f60a:	2200      	movs	r2, #0
 810f60c:	829a      	strh	r2, [r3, #20]
 810f60e:	69fb      	ldr	r3, [r7, #28]
 810f610:	8a9a      	ldrh	r2, [r3, #20]
 810f612:	69fb      	ldr	r3, [r7, #28]
 810f614:	825a      	strh	r2, [r3, #18]
 810f616:	69fb      	ldr	r3, [r7, #28]
 810f618:	8a5a      	ldrh	r2, [r3, #18]
 810f61a:	69fb      	ldr	r3, [r7, #28]
 810f61c:	821a      	strh	r2, [r3, #16]
 810f61e:	69fb      	ldr	r3, [r7, #28]
 810f620:	8a1a      	ldrh	r2, [r3, #16]
 810f622:	69fb      	ldr	r3, [r7, #28]
 810f624:	81da      	strh	r2, [r3, #14]

  /* send release message when current IP was assigned via DHCP */
  if (dhcp_supplied_address(netif)) {
 810f626:	6878      	ldr	r0, [r7, #4]
 810f628:	f000 fe1e 	bl	8110268 <dhcp_supplied_address>
 810f62c:	4603      	mov	r3, r0
 810f62e:	2b00      	cmp	r3, #0
 810f630:	d03b      	beq.n	810f6aa <dhcp_release_and_stop+0xf6>
    /* create and initialize the DHCP message header */
    struct pbuf *p_out;
    u16_t options_out_len;
    p_out = dhcp_create_msg(netif, dhcp, DHCP_RELEASE, &options_out_len);
 810f632:	f107 030e 	add.w	r3, r7, #14
 810f636:	2207      	movs	r2, #7
 810f638:	69f9      	ldr	r1, [r7, #28]
 810f63a:	6878      	ldr	r0, [r7, #4]
 810f63c:	f000 fd10 	bl	8110060 <dhcp_create_msg>
 810f640:	61b8      	str	r0, [r7, #24]
    if (p_out != NULL) {
 810f642:	69bb      	ldr	r3, [r7, #24]
 810f644:	2b00      	cmp	r3, #0
 810f646:	d030      	beq.n	810f6aa <dhcp_release_and_stop+0xf6>
      struct dhcp_msg *msg_out = (struct dhcp_msg *)p_out->payload;
 810f648:	69bb      	ldr	r3, [r7, #24]
 810f64a:	685b      	ldr	r3, [r3, #4]
 810f64c:	617b      	str	r3, [r7, #20]
      options_out_len = dhcp_option(options_out_len, msg_out->options, DHCP_OPTION_SERVER_ID, 4);
 810f64e:	89f8      	ldrh	r0, [r7, #14]
 810f650:	697b      	ldr	r3, [r7, #20]
 810f652:	f103 01f0 	add.w	r1, r3, #240	; 0xf0
 810f656:	2304      	movs	r3, #4
 810f658:	2236      	movs	r2, #54	; 0x36
 810f65a:	f000 f85f 	bl	810f71c <dhcp_option>
 810f65e:	4603      	mov	r3, r0
 810f660:	81fb      	strh	r3, [r7, #14]
      options_out_len = dhcp_option_long(options_out_len, msg_out->options, lwip_ntohl(ip4_addr_get_u32(ip_2_ip4(&server_ip_addr))));
 810f662:	89fc      	ldrh	r4, [r7, #14]
 810f664:	697b      	ldr	r3, [r7, #20]
 810f666:	f103 05f0 	add.w	r5, r3, #240	; 0xf0
 810f66a:	693b      	ldr	r3, [r7, #16]
 810f66c:	4618      	mov	r0, r3
 810f66e:	f7fe ff25 	bl	810e4bc <lwip_htonl>
 810f672:	4603      	mov	r3, r0
 810f674:	461a      	mov	r2, r3
 810f676:	4629      	mov	r1, r5
 810f678:	4620      	mov	r0, r4
 810f67a:	f000 f8db 	bl	810f834 <dhcp_option_long>
 810f67e:	4603      	mov	r3, r0
 810f680:	81fb      	strh	r3, [r7, #14]

      LWIP_HOOK_DHCP_APPEND_OPTIONS(netif, dhcp, dhcp->state, msg_out, DHCP_RELEASE, &options_out_len);
      dhcp_option_trailer(options_out_len, msg_out->options, p_out);
 810f682:	89f8      	ldrh	r0, [r7, #14]
 810f684:	697b      	ldr	r3, [r7, #20]
 810f686:	33f0      	adds	r3, #240	; 0xf0
 810f688:	69ba      	ldr	r2, [r7, #24]
 810f68a:	4619      	mov	r1, r3
 810f68c:	f000 fdbe 	bl	811020c <dhcp_option_trailer>

      udp_sendto_if(dhcp_pcb, p_out, &server_ip_addr, LWIP_IANA_PORT_DHCP_SERVER, netif);
 810f690:	4b13      	ldr	r3, [pc, #76]	; (810f6e0 <dhcp_release_and_stop+0x12c>)
 810f692:	6818      	ldr	r0, [r3, #0]
 810f694:	f107 0210 	add.w	r2, r7, #16
 810f698:	687b      	ldr	r3, [r7, #4]
 810f69a:	9300      	str	r3, [sp, #0]
 810f69c:	2343      	movs	r3, #67	; 0x43
 810f69e:	69b9      	ldr	r1, [r7, #24]
 810f6a0:	f00b f854 	bl	811a74c <udp_sendto_if>
      pbuf_free(p_out);
 810f6a4:	69b8      	ldr	r0, [r7, #24]
 810f6a6:	f004 ffd7 	bl	8114658 <pbuf_free>
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("dhcp_release: could not allocate DHCP request\n"));
    }
  }

  /* remove IP address from interface (prevents routing from selecting this interface) */
  netif_set_addr(netif, IP4_ADDR_ANY4, IP4_ADDR_ANY4, IP4_ADDR_ANY4);
 810f6aa:	4b0e      	ldr	r3, [pc, #56]	; (810f6e4 <dhcp_release_and_stop+0x130>)
 810f6ac:	4a0d      	ldr	r2, [pc, #52]	; (810f6e4 <dhcp_release_and_stop+0x130>)
 810f6ae:	490d      	ldr	r1, [pc, #52]	; (810f6e4 <dhcp_release_and_stop+0x130>)
 810f6b0:	6878      	ldr	r0, [r7, #4]
 810f6b2:	f004 fb11 	bl	8113cd8 <netif_set_addr>
    autoip_stop(netif);
    dhcp->autoip_coop_state = DHCP_AUTOIP_COOP_STATE_OFF;
  }
#endif /* LWIP_DHCP_AUTOIP_COOP */

  dhcp_set_state(dhcp, DHCP_STATE_OFF);
 810f6b6:	2100      	movs	r1, #0
 810f6b8:	69f8      	ldr	r0, [r7, #28]
 810f6ba:	f000 f815 	bl	810f6e8 <dhcp_set_state>

  if (dhcp->pcb_allocated != 0) {
 810f6be:	69fb      	ldr	r3, [r7, #28]
 810f6c0:	791b      	ldrb	r3, [r3, #4]
 810f6c2:	2b00      	cmp	r3, #0
 810f6c4:	d008      	beq.n	810f6d8 <dhcp_release_and_stop+0x124>
    dhcp_dec_pcb_refcount(); /* free DHCP PCB if not needed any more */
 810f6c6:	f7fe ff65 	bl	810e594 <dhcp_dec_pcb_refcount>
    dhcp->pcb_allocated = 0;
 810f6ca:	69fb      	ldr	r3, [r7, #28]
 810f6cc:	2200      	movs	r2, #0
 810f6ce:	711a      	strb	r2, [r3, #4]
 810f6d0:	e002      	b.n	810f6d8 <dhcp_release_and_stop+0x124>
    return;
 810f6d2:	bf00      	nop
 810f6d4:	e000      	b.n	810f6d8 <dhcp_release_and_stop+0x124>
    return;
 810f6d6:	bf00      	nop
  }
}
 810f6d8:	3720      	adds	r7, #32
 810f6da:	46bd      	mov	sp, r7
 810f6dc:	bdb0      	pop	{r4, r5, r7, pc}
 810f6de:	bf00      	nop
 810f6e0:	10004f68 	.word	0x10004f68
 810f6e4:	0811f934 	.word	0x0811f934

0810f6e8 <dhcp_set_state>:
 *
 * If the state changed, reset the number of tries.
 */
static void
dhcp_set_state(struct dhcp *dhcp, u8_t new_state)
{
 810f6e8:	b480      	push	{r7}
 810f6ea:	b083      	sub	sp, #12
 810f6ec:	af00      	add	r7, sp, #0
 810f6ee:	6078      	str	r0, [r7, #4]
 810f6f0:	460b      	mov	r3, r1
 810f6f2:	70fb      	strb	r3, [r7, #3]
  if (new_state != dhcp->state) {
 810f6f4:	687b      	ldr	r3, [r7, #4]
 810f6f6:	795b      	ldrb	r3, [r3, #5]
 810f6f8:	78fa      	ldrb	r2, [r7, #3]
 810f6fa:	429a      	cmp	r2, r3
 810f6fc:	d008      	beq.n	810f710 <dhcp_set_state+0x28>
    dhcp->state = new_state;
 810f6fe:	687b      	ldr	r3, [r7, #4]
 810f700:	78fa      	ldrb	r2, [r7, #3]
 810f702:	715a      	strb	r2, [r3, #5]
    dhcp->tries = 0;
 810f704:	687b      	ldr	r3, [r7, #4]
 810f706:	2200      	movs	r2, #0
 810f708:	719a      	strb	r2, [r3, #6]
    dhcp->request_timeout = 0;
 810f70a:	687b      	ldr	r3, [r7, #4]
 810f70c:	2200      	movs	r2, #0
 810f70e:	811a      	strh	r2, [r3, #8]
  }
}
 810f710:	bf00      	nop
 810f712:	370c      	adds	r7, #12
 810f714:	46bd      	mov	sp, r7
 810f716:	f85d 7b04 	ldr.w	r7, [sp], #4
 810f71a:	4770      	bx	lr

0810f71c <dhcp_option>:
 * DHCP message.
 *
 */
static u16_t
dhcp_option(u16_t options_out_len, u8_t *options, u8_t option_type, u8_t option_len)
{
 810f71c:	b580      	push	{r7, lr}
 810f71e:	b082      	sub	sp, #8
 810f720:	af00      	add	r7, sp, #0
 810f722:	6039      	str	r1, [r7, #0]
 810f724:	4611      	mov	r1, r2
 810f726:	461a      	mov	r2, r3
 810f728:	4603      	mov	r3, r0
 810f72a:	80fb      	strh	r3, [r7, #6]
 810f72c:	460b      	mov	r3, r1
 810f72e:	717b      	strb	r3, [r7, #5]
 810f730:	4613      	mov	r3, r2
 810f732:	713b      	strb	r3, [r7, #4]
  LWIP_ASSERT("dhcp_option: options_out_len + 2 + option_len <= DHCP_OPTIONS_LEN", options_out_len + 2U + option_len <= DHCP_OPTIONS_LEN);
 810f734:	88fa      	ldrh	r2, [r7, #6]
 810f736:	793b      	ldrb	r3, [r7, #4]
 810f738:	4413      	add	r3, r2
 810f73a:	3302      	adds	r3, #2
 810f73c:	2b44      	cmp	r3, #68	; 0x44
 810f73e:	d906      	bls.n	810f74e <dhcp_option+0x32>
 810f740:	4b0d      	ldr	r3, [pc, #52]	; (810f778 <dhcp_option+0x5c>)
 810f742:	f240 529a 	movw	r2, #1434	; 0x59a
 810f746:	490d      	ldr	r1, [pc, #52]	; (810f77c <dhcp_option+0x60>)
 810f748:	480d      	ldr	r0, [pc, #52]	; (810f780 <dhcp_option+0x64>)
 810f74a:	f00c f859 	bl	811b800 <iprintf>
  options[options_out_len++] = option_type;
 810f74e:	88fb      	ldrh	r3, [r7, #6]
 810f750:	1c5a      	adds	r2, r3, #1
 810f752:	80fa      	strh	r2, [r7, #6]
 810f754:	461a      	mov	r2, r3
 810f756:	683b      	ldr	r3, [r7, #0]
 810f758:	4413      	add	r3, r2
 810f75a:	797a      	ldrb	r2, [r7, #5]
 810f75c:	701a      	strb	r2, [r3, #0]
  options[options_out_len++] = option_len;
 810f75e:	88fb      	ldrh	r3, [r7, #6]
 810f760:	1c5a      	adds	r2, r3, #1
 810f762:	80fa      	strh	r2, [r7, #6]
 810f764:	461a      	mov	r2, r3
 810f766:	683b      	ldr	r3, [r7, #0]
 810f768:	4413      	add	r3, r2
 810f76a:	793a      	ldrb	r2, [r7, #4]
 810f76c:	701a      	strb	r2, [r3, #0]
  return options_out_len;
 810f76e:	88fb      	ldrh	r3, [r7, #6]
}
 810f770:	4618      	mov	r0, r3
 810f772:	3708      	adds	r7, #8
 810f774:	46bd      	mov	sp, r7
 810f776:	bd80      	pop	{r7, pc}
 810f778:	0811c788 	.word	0x0811c788
 810f77c:	0811c94c 	.word	0x0811c94c
 810f780:	0811c818 	.word	0x0811c818

0810f784 <dhcp_option_byte>:
 * Concatenate a single byte to the outgoing DHCP message.
 *
 */
static u16_t
dhcp_option_byte(u16_t options_out_len, u8_t *options, u8_t value)
{
 810f784:	b580      	push	{r7, lr}
 810f786:	b082      	sub	sp, #8
 810f788:	af00      	add	r7, sp, #0
 810f78a:	4603      	mov	r3, r0
 810f78c:	6039      	str	r1, [r7, #0]
 810f78e:	80fb      	strh	r3, [r7, #6]
 810f790:	4613      	mov	r3, r2
 810f792:	717b      	strb	r3, [r7, #5]
  LWIP_ASSERT("dhcp_option_byte: options_out_len < DHCP_OPTIONS_LEN", options_out_len < DHCP_OPTIONS_LEN);
 810f794:	88fb      	ldrh	r3, [r7, #6]
 810f796:	2b43      	cmp	r3, #67	; 0x43
 810f798:	d906      	bls.n	810f7a8 <dhcp_option_byte+0x24>
 810f79a:	4b0a      	ldr	r3, [pc, #40]	; (810f7c4 <dhcp_option_byte+0x40>)
 810f79c:	f240 52a6 	movw	r2, #1446	; 0x5a6
 810f7a0:	4909      	ldr	r1, [pc, #36]	; (810f7c8 <dhcp_option_byte+0x44>)
 810f7a2:	480a      	ldr	r0, [pc, #40]	; (810f7cc <dhcp_option_byte+0x48>)
 810f7a4:	f00c f82c 	bl	811b800 <iprintf>
  options[options_out_len++] = value;
 810f7a8:	88fb      	ldrh	r3, [r7, #6]
 810f7aa:	1c5a      	adds	r2, r3, #1
 810f7ac:	80fa      	strh	r2, [r7, #6]
 810f7ae:	461a      	mov	r2, r3
 810f7b0:	683b      	ldr	r3, [r7, #0]
 810f7b2:	4413      	add	r3, r2
 810f7b4:	797a      	ldrb	r2, [r7, #5]
 810f7b6:	701a      	strb	r2, [r3, #0]
  return options_out_len;
 810f7b8:	88fb      	ldrh	r3, [r7, #6]
}
 810f7ba:	4618      	mov	r0, r3
 810f7bc:	3708      	adds	r7, #8
 810f7be:	46bd      	mov	sp, r7
 810f7c0:	bd80      	pop	{r7, pc}
 810f7c2:	bf00      	nop
 810f7c4:	0811c788 	.word	0x0811c788
 810f7c8:	0811c990 	.word	0x0811c990
 810f7cc:	0811c818 	.word	0x0811c818

0810f7d0 <dhcp_option_short>:

static u16_t
dhcp_option_short(u16_t options_out_len, u8_t *options, u16_t value)
{
 810f7d0:	b580      	push	{r7, lr}
 810f7d2:	b082      	sub	sp, #8
 810f7d4:	af00      	add	r7, sp, #0
 810f7d6:	4603      	mov	r3, r0
 810f7d8:	6039      	str	r1, [r7, #0]
 810f7da:	80fb      	strh	r3, [r7, #6]
 810f7dc:	4613      	mov	r3, r2
 810f7de:	80bb      	strh	r3, [r7, #4]
  LWIP_ASSERT("dhcp_option_short: options_out_len + 2 <= DHCP_OPTIONS_LEN", options_out_len + 2U <= DHCP_OPTIONS_LEN);
 810f7e0:	88fb      	ldrh	r3, [r7, #6]
 810f7e2:	3302      	adds	r3, #2
 810f7e4:	2b44      	cmp	r3, #68	; 0x44
 810f7e6:	d906      	bls.n	810f7f6 <dhcp_option_short+0x26>
 810f7e8:	4b0f      	ldr	r3, [pc, #60]	; (810f828 <dhcp_option_short+0x58>)
 810f7ea:	f240 52ae 	movw	r2, #1454	; 0x5ae
 810f7ee:	490f      	ldr	r1, [pc, #60]	; (810f82c <dhcp_option_short+0x5c>)
 810f7f0:	480f      	ldr	r0, [pc, #60]	; (810f830 <dhcp_option_short+0x60>)
 810f7f2:	f00c f805 	bl	811b800 <iprintf>
  options[options_out_len++] = (u8_t)((value & 0xff00U) >> 8);
 810f7f6:	88bb      	ldrh	r3, [r7, #4]
 810f7f8:	0a1b      	lsrs	r3, r3, #8
 810f7fa:	b29a      	uxth	r2, r3
 810f7fc:	88fb      	ldrh	r3, [r7, #6]
 810f7fe:	1c59      	adds	r1, r3, #1
 810f800:	80f9      	strh	r1, [r7, #6]
 810f802:	4619      	mov	r1, r3
 810f804:	683b      	ldr	r3, [r7, #0]
 810f806:	440b      	add	r3, r1
 810f808:	b2d2      	uxtb	r2, r2
 810f80a:	701a      	strb	r2, [r3, #0]
  options[options_out_len++] = (u8_t) (value & 0x00ffU);
 810f80c:	88fb      	ldrh	r3, [r7, #6]
 810f80e:	1c5a      	adds	r2, r3, #1
 810f810:	80fa      	strh	r2, [r7, #6]
 810f812:	461a      	mov	r2, r3
 810f814:	683b      	ldr	r3, [r7, #0]
 810f816:	4413      	add	r3, r2
 810f818:	88ba      	ldrh	r2, [r7, #4]
 810f81a:	b2d2      	uxtb	r2, r2
 810f81c:	701a      	strb	r2, [r3, #0]
  return options_out_len;
 810f81e:	88fb      	ldrh	r3, [r7, #6]
}
 810f820:	4618      	mov	r0, r3
 810f822:	3708      	adds	r7, #8
 810f824:	46bd      	mov	sp, r7
 810f826:	bd80      	pop	{r7, pc}
 810f828:	0811c788 	.word	0x0811c788
 810f82c:	0811c9c8 	.word	0x0811c9c8
 810f830:	0811c818 	.word	0x0811c818

0810f834 <dhcp_option_long>:

static u16_t
dhcp_option_long(u16_t options_out_len, u8_t *options, u32_t value)
{
 810f834:	b580      	push	{r7, lr}
 810f836:	b084      	sub	sp, #16
 810f838:	af00      	add	r7, sp, #0
 810f83a:	4603      	mov	r3, r0
 810f83c:	60b9      	str	r1, [r7, #8]
 810f83e:	607a      	str	r2, [r7, #4]
 810f840:	81fb      	strh	r3, [r7, #14]
  LWIP_ASSERT("dhcp_option_long: options_out_len + 4 <= DHCP_OPTIONS_LEN", options_out_len + 4U <= DHCP_OPTIONS_LEN);
 810f842:	89fb      	ldrh	r3, [r7, #14]
 810f844:	3304      	adds	r3, #4
 810f846:	2b44      	cmp	r3, #68	; 0x44
 810f848:	d906      	bls.n	810f858 <dhcp_option_long+0x24>
 810f84a:	4b19      	ldr	r3, [pc, #100]	; (810f8b0 <dhcp_option_long+0x7c>)
 810f84c:	f240 52b7 	movw	r2, #1463	; 0x5b7
 810f850:	4918      	ldr	r1, [pc, #96]	; (810f8b4 <dhcp_option_long+0x80>)
 810f852:	4819      	ldr	r0, [pc, #100]	; (810f8b8 <dhcp_option_long+0x84>)
 810f854:	f00b ffd4 	bl	811b800 <iprintf>
  options[options_out_len++] = (u8_t)((value & 0xff000000UL) >> 24);
 810f858:	687b      	ldr	r3, [r7, #4]
 810f85a:	0e1a      	lsrs	r2, r3, #24
 810f85c:	89fb      	ldrh	r3, [r7, #14]
 810f85e:	1c59      	adds	r1, r3, #1
 810f860:	81f9      	strh	r1, [r7, #14]
 810f862:	4619      	mov	r1, r3
 810f864:	68bb      	ldr	r3, [r7, #8]
 810f866:	440b      	add	r3, r1
 810f868:	b2d2      	uxtb	r2, r2
 810f86a:	701a      	strb	r2, [r3, #0]
  options[options_out_len++] = (u8_t)((value & 0x00ff0000UL) >> 16);
 810f86c:	687b      	ldr	r3, [r7, #4]
 810f86e:	0c1a      	lsrs	r2, r3, #16
 810f870:	89fb      	ldrh	r3, [r7, #14]
 810f872:	1c59      	adds	r1, r3, #1
 810f874:	81f9      	strh	r1, [r7, #14]
 810f876:	4619      	mov	r1, r3
 810f878:	68bb      	ldr	r3, [r7, #8]
 810f87a:	440b      	add	r3, r1
 810f87c:	b2d2      	uxtb	r2, r2
 810f87e:	701a      	strb	r2, [r3, #0]
  options[options_out_len++] = (u8_t)((value & 0x0000ff00UL) >> 8);
 810f880:	687b      	ldr	r3, [r7, #4]
 810f882:	0a1a      	lsrs	r2, r3, #8
 810f884:	89fb      	ldrh	r3, [r7, #14]
 810f886:	1c59      	adds	r1, r3, #1
 810f888:	81f9      	strh	r1, [r7, #14]
 810f88a:	4619      	mov	r1, r3
 810f88c:	68bb      	ldr	r3, [r7, #8]
 810f88e:	440b      	add	r3, r1
 810f890:	b2d2      	uxtb	r2, r2
 810f892:	701a      	strb	r2, [r3, #0]
  options[options_out_len++] = (u8_t)((value & 0x000000ffUL));
 810f894:	89fb      	ldrh	r3, [r7, #14]
 810f896:	1c5a      	adds	r2, r3, #1
 810f898:	81fa      	strh	r2, [r7, #14]
 810f89a:	461a      	mov	r2, r3
 810f89c:	68bb      	ldr	r3, [r7, #8]
 810f89e:	4413      	add	r3, r2
 810f8a0:	687a      	ldr	r2, [r7, #4]
 810f8a2:	b2d2      	uxtb	r2, r2
 810f8a4:	701a      	strb	r2, [r3, #0]
  return options_out_len;
 810f8a6:	89fb      	ldrh	r3, [r7, #14]
}
 810f8a8:	4618      	mov	r0, r3
 810f8aa:	3710      	adds	r7, #16
 810f8ac:	46bd      	mov	sp, r7
 810f8ae:	bd80      	pop	{r7, pc}
 810f8b0:	0811c788 	.word	0x0811c788
 810f8b4:	0811ca04 	.word	0x0811ca04
 810f8b8:	0811c818 	.word	0x0811c818

0810f8bc <dhcp_parse_reply>:
 * use that further on.
 *
 */
static err_t
dhcp_parse_reply(struct pbuf *p, struct dhcp *dhcp)
{
 810f8bc:	b580      	push	{r7, lr}
 810f8be:	b090      	sub	sp, #64	; 0x40
 810f8c0:	af00      	add	r7, sp, #0
 810f8c2:	6078      	str	r0, [r7, #4]
 810f8c4:	6039      	str	r1, [r7, #0]
  u16_t offset;
  u16_t offset_max;
  u16_t options_idx;
  u16_t options_idx_max;
  struct pbuf *q;
  int parse_file_as_options = 0;
 810f8c6:	2300      	movs	r3, #0
 810f8c8:	62fb      	str	r3, [r7, #44]	; 0x2c
  int parse_sname_as_options = 0;
 810f8ca:	2300      	movs	r3, #0
 810f8cc:	62bb      	str	r3, [r7, #40]	; 0x28
#endif

  LWIP_UNUSED_ARG(dhcp);

  /* clear received options */
  dhcp_clear_all_options(dhcp);
 810f8ce:	220a      	movs	r2, #10
 810f8d0:	2100      	movs	r1, #0
 810f8d2:	48ba      	ldr	r0, [pc, #744]	; (810fbbc <dhcp_parse_reply+0x300>)
 810f8d4:	f00b ffbe 	bl	811b854 <memset>
  /* check that beginning of dhcp_msg (up to and including chaddr) is in first pbuf */
  if (p->len < DHCP_SNAME_OFS) {
 810f8d8:	687b      	ldr	r3, [r7, #4]
 810f8da:	895b      	ldrh	r3, [r3, #10]
 810f8dc:	2b2b      	cmp	r3, #43	; 0x2b
 810f8de:	d802      	bhi.n	810f8e6 <dhcp_parse_reply+0x2a>
    return ERR_BUF;
 810f8e0:	f06f 0301 	mvn.w	r3, #1
 810f8e4:	e2ea      	b.n	810febc <dhcp_parse_reply+0x600>
  }
  msg_in = (struct dhcp_msg *)p->payload;
 810f8e6:	687b      	ldr	r3, [r7, #4]
 810f8e8:	685b      	ldr	r3, [r3, #4]
 810f8ea:	61bb      	str	r3, [r7, #24]
#endif /* LWIP_DHCP_BOOTP_FILE */

  /* parse options */

  /* start with options field */
  options_idx = DHCP_OPTIONS_OFS;
 810f8ec:	23f0      	movs	r3, #240	; 0xf0
 810f8ee:	86fb      	strh	r3, [r7, #54]	; 0x36
  /* parse options to the end of the received packet */
  options_idx_max = p->tot_len;
 810f8f0:	687b      	ldr	r3, [r7, #4]
 810f8f2:	891b      	ldrh	r3, [r3, #8]
 810f8f4:	86bb      	strh	r3, [r7, #52]	; 0x34
again:
  q = p;
 810f8f6:	687b      	ldr	r3, [r7, #4]
 810f8f8:	633b      	str	r3, [r7, #48]	; 0x30
  while ((q != NULL) && (options_idx >= q->len)) {
 810f8fa:	e00c      	b.n	810f916 <dhcp_parse_reply+0x5a>
    options_idx = (u16_t)(options_idx - q->len);
 810f8fc:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 810f8fe:	895b      	ldrh	r3, [r3, #10]
 810f900:	8efa      	ldrh	r2, [r7, #54]	; 0x36
 810f902:	1ad3      	subs	r3, r2, r3
 810f904:	86fb      	strh	r3, [r7, #54]	; 0x36
    options_idx_max = (u16_t)(options_idx_max - q->len);
 810f906:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 810f908:	895b      	ldrh	r3, [r3, #10]
 810f90a:	8eba      	ldrh	r2, [r7, #52]	; 0x34
 810f90c:	1ad3      	subs	r3, r2, r3
 810f90e:	86bb      	strh	r3, [r7, #52]	; 0x34
    q = q->next;
 810f910:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 810f912:	681b      	ldr	r3, [r3, #0]
 810f914:	633b      	str	r3, [r7, #48]	; 0x30
  while ((q != NULL) && (options_idx >= q->len)) {
 810f916:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 810f918:	2b00      	cmp	r3, #0
 810f91a:	d004      	beq.n	810f926 <dhcp_parse_reply+0x6a>
 810f91c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 810f91e:	895b      	ldrh	r3, [r3, #10]
 810f920:	8efa      	ldrh	r2, [r7, #54]	; 0x36
 810f922:	429a      	cmp	r2, r3
 810f924:	d2ea      	bcs.n	810f8fc <dhcp_parse_reply+0x40>
  }
  if (q == NULL) {
 810f926:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 810f928:	2b00      	cmp	r3, #0
 810f92a:	d102      	bne.n	810f932 <dhcp_parse_reply+0x76>
    return ERR_BUF;
 810f92c:	f06f 0301 	mvn.w	r3, #1
 810f930:	e2c4      	b.n	810febc <dhcp_parse_reply+0x600>
  }
  offset = options_idx;
 810f932:	8efb      	ldrh	r3, [r7, #54]	; 0x36
 810f934:	877b      	strh	r3, [r7, #58]	; 0x3a
  offset_max = options_idx_max;
 810f936:	8ebb      	ldrh	r3, [r7, #52]	; 0x34
 810f938:	873b      	strh	r3, [r7, #56]	; 0x38
  options = (u8_t *)q->payload;
 810f93a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 810f93c:	685b      	ldr	r3, [r3, #4]
 810f93e:	63fb      	str	r3, [r7, #60]	; 0x3c
  /* at least 1 byte to read and no end marker, then at least 3 bytes to read? */
  while ((q != NULL) && (offset < offset_max) && (options[offset] != DHCP_OPTION_END)) {
 810f940:	e267      	b.n	810fe12 <dhcp_parse_reply+0x556>
    u8_t op = options[offset];
 810f942:	8f7b      	ldrh	r3, [r7, #58]	; 0x3a
 810f944:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 810f946:	4413      	add	r3, r2
 810f948:	781b      	ldrb	r3, [r3, #0]
 810f94a:	75fb      	strb	r3, [r7, #23]
    u8_t len;
    u8_t decode_len = 0;
 810f94c:	2300      	movs	r3, #0
 810f94e:	f887 3026 	strb.w	r3, [r7, #38]	; 0x26
    int decode_idx = -1;
 810f952:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 810f956:	623b      	str	r3, [r7, #32]
    u16_t val_offset = (u16_t)(offset + 2);
 810f958:	8f7b      	ldrh	r3, [r7, #58]	; 0x3a
 810f95a:	3302      	adds	r3, #2
 810f95c:	83fb      	strh	r3, [r7, #30]
    if (val_offset < offset) {
 810f95e:	8bfa      	ldrh	r2, [r7, #30]
 810f960:	8f7b      	ldrh	r3, [r7, #58]	; 0x3a
 810f962:	429a      	cmp	r2, r3
 810f964:	d202      	bcs.n	810f96c <dhcp_parse_reply+0xb0>
      /* overflow */
      return ERR_BUF;
 810f966:	f06f 0301 	mvn.w	r3, #1
 810f96a:	e2a7      	b.n	810febc <dhcp_parse_reply+0x600>
    }
    /* len byte might be in the next pbuf */
    if ((offset + 1) < q->len) {
 810f96c:	8f7b      	ldrh	r3, [r7, #58]	; 0x3a
 810f96e:	3301      	adds	r3, #1
 810f970:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 810f972:	8952      	ldrh	r2, [r2, #10]
 810f974:	4293      	cmp	r3, r2
 810f976:	da07      	bge.n	810f988 <dhcp_parse_reply+0xcc>
      len = options[offset + 1];
 810f978:	8f7b      	ldrh	r3, [r7, #58]	; 0x3a
 810f97a:	3301      	adds	r3, #1
 810f97c:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 810f97e:	4413      	add	r3, r2
 810f980:	781b      	ldrb	r3, [r3, #0]
 810f982:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
 810f986:	e00b      	b.n	810f9a0 <dhcp_parse_reply+0xe4>
    } else {
      len = (q->next != NULL ? ((u8_t *)q->next->payload)[0] : 0);
 810f988:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 810f98a:	681b      	ldr	r3, [r3, #0]
 810f98c:	2b00      	cmp	r3, #0
 810f98e:	d004      	beq.n	810f99a <dhcp_parse_reply+0xde>
 810f990:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 810f992:	681b      	ldr	r3, [r3, #0]
 810f994:	685b      	ldr	r3, [r3, #4]
 810f996:	781b      	ldrb	r3, [r3, #0]
 810f998:	e000      	b.n	810f99c <dhcp_parse_reply+0xe0>
 810f99a:	2300      	movs	r3, #0
 810f99c:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
    }
    /* LWIP_DEBUGF(DHCP_DEBUG, ("msg_offset=%"U16_F", q->len=%"U16_F, msg_offset, q->len)); */
    decode_len = len;
 810f9a0:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 810f9a4:	f887 3026 	strb.w	r3, [r7, #38]	; 0x26
    switch (op) {
 810f9a8:	7dfb      	ldrb	r3, [r7, #23]
 810f9aa:	2b3b      	cmp	r3, #59	; 0x3b
 810f9ac:	f200 815a 	bhi.w	810fc64 <dhcp_parse_reply+0x3a8>
 810f9b0:	a201      	add	r2, pc, #4	; (adr r2, 810f9b8 <dhcp_parse_reply+0xfc>)
 810f9b2:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 810f9b6:	bf00      	nop
 810f9b8:	0810faa9 	.word	0x0810faa9
 810f9bc:	0810fab9 	.word	0x0810fab9
 810f9c0:	0810fc65 	.word	0x0810fc65
 810f9c4:	0810fadb 	.word	0x0810fadb
 810f9c8:	0810fc65 	.word	0x0810fc65
 810f9cc:	0810fc65 	.word	0x0810fc65
 810f9d0:	0810fb07 	.word	0x0810fb07
 810f9d4:	0810fc65 	.word	0x0810fc65
 810f9d8:	0810fc65 	.word	0x0810fc65
 810f9dc:	0810fc65 	.word	0x0810fc65
 810f9e0:	0810fc65 	.word	0x0810fc65
 810f9e4:	0810fc65 	.word	0x0810fc65
 810f9e8:	0810fc65 	.word	0x0810fc65
 810f9ec:	0810fc65 	.word	0x0810fc65
 810f9f0:	0810fc65 	.word	0x0810fc65
 810f9f4:	0810fc65 	.word	0x0810fc65
 810f9f8:	0810fc65 	.word	0x0810fc65
 810f9fc:	0810fc65 	.word	0x0810fc65
 810fa00:	0810fc65 	.word	0x0810fc65
 810fa04:	0810fc65 	.word	0x0810fc65
 810fa08:	0810fc65 	.word	0x0810fc65
 810fa0c:	0810fc65 	.word	0x0810fc65
 810fa10:	0810fc65 	.word	0x0810fc65
 810fa14:	0810fc65 	.word	0x0810fc65
 810fa18:	0810fc65 	.word	0x0810fc65
 810fa1c:	0810fc65 	.word	0x0810fc65
 810fa20:	0810fc65 	.word	0x0810fc65
 810fa24:	0810fc65 	.word	0x0810fc65
 810fa28:	0810fc65 	.word	0x0810fc65
 810fa2c:	0810fc65 	.word	0x0810fc65
 810fa30:	0810fc65 	.word	0x0810fc65
 810fa34:	0810fc65 	.word	0x0810fc65
 810fa38:	0810fc65 	.word	0x0810fc65
 810fa3c:	0810fc65 	.word	0x0810fc65
 810fa40:	0810fc65 	.word	0x0810fc65
 810fa44:	0810fc65 	.word	0x0810fc65
 810fa48:	0810fc65 	.word	0x0810fc65
 810fa4c:	0810fc65 	.word	0x0810fc65
 810fa50:	0810fc65 	.word	0x0810fc65
 810fa54:	0810fc65 	.word	0x0810fc65
 810fa58:	0810fc65 	.word	0x0810fc65
 810fa5c:	0810fc65 	.word	0x0810fc65
 810fa60:	0810fc65 	.word	0x0810fc65
 810fa64:	0810fc65 	.word	0x0810fc65
 810fa68:	0810fc65 	.word	0x0810fc65
 810fa6c:	0810fc65 	.word	0x0810fc65
 810fa70:	0810fc65 	.word	0x0810fc65
 810fa74:	0810fc65 	.word	0x0810fc65
 810fa78:	0810fc65 	.word	0x0810fc65
 810fa7c:	0810fc65 	.word	0x0810fc65
 810fa80:	0810fc65 	.word	0x0810fc65
 810fa84:	0810fb5d 	.word	0x0810fb5d
 810fa88:	0810fb7f 	.word	0x0810fb7f
 810fa8c:	0810fbdd 	.word	0x0810fbdd
 810fa90:	0810fbff 	.word	0x0810fbff
 810fa94:	0810fc65 	.word	0x0810fc65
 810fa98:	0810fc65 	.word	0x0810fc65
 810fa9c:	0810fc65 	.word	0x0810fc65
 810faa0:	0810fc21 	.word	0x0810fc21
 810faa4:	0810fc43 	.word	0x0810fc43
      /* case(DHCP_OPTION_END): handled above */
      case (DHCP_OPTION_PAD):
        /* special option: no len encoded */
        decode_len = len = 0;
 810faa8:	2300      	movs	r3, #0
 810faaa:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
 810faae:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 810fab2:	f887 3026 	strb.w	r3, [r7, #38]	; 0x26
        /* will be increased below */
        break;
 810fab6:	e0d9      	b.n	810fc6c <dhcp_parse_reply+0x3b0>
      case (DHCP_OPTION_SUBNET_MASK):
        LWIP_ERROR("len == 4", len == 4, return ERR_VAL;);
 810fab8:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 810fabc:	2b04      	cmp	r3, #4
 810fabe:	d009      	beq.n	810fad4 <dhcp_parse_reply+0x218>
 810fac0:	4b3f      	ldr	r3, [pc, #252]	; (810fbc0 <dhcp_parse_reply+0x304>)
 810fac2:	f240 622e 	movw	r2, #1582	; 0x62e
 810fac6:	493f      	ldr	r1, [pc, #252]	; (810fbc4 <dhcp_parse_reply+0x308>)
 810fac8:	483f      	ldr	r0, [pc, #252]	; (810fbc8 <dhcp_parse_reply+0x30c>)
 810faca:	f00b fe99 	bl	811b800 <iprintf>
 810face:	f06f 0305 	mvn.w	r3, #5
 810fad2:	e1f3      	b.n	810febc <dhcp_parse_reply+0x600>
        decode_idx = DHCP_OPTION_IDX_SUBNET_MASK;
 810fad4:	2306      	movs	r3, #6
 810fad6:	623b      	str	r3, [r7, #32]
        break;
 810fad8:	e0c8      	b.n	810fc6c <dhcp_parse_reply+0x3b0>
      case (DHCP_OPTION_ROUTER):
        decode_len = 4; /* only copy the first given router */
 810fada:	2304      	movs	r3, #4
 810fadc:	f887 3026 	strb.w	r3, [r7, #38]	; 0x26
        LWIP_ERROR("len >= decode_len", len >= decode_len, return ERR_VAL;);
 810fae0:	f897 2027 	ldrb.w	r2, [r7, #39]	; 0x27
 810fae4:	f897 3026 	ldrb.w	r3, [r7, #38]	; 0x26
 810fae8:	429a      	cmp	r2, r3
 810faea:	d209      	bcs.n	810fb00 <dhcp_parse_reply+0x244>
 810faec:	4b34      	ldr	r3, [pc, #208]	; (810fbc0 <dhcp_parse_reply+0x304>)
 810faee:	f240 6233 	movw	r2, #1587	; 0x633
 810faf2:	4936      	ldr	r1, [pc, #216]	; (810fbcc <dhcp_parse_reply+0x310>)
 810faf4:	4834      	ldr	r0, [pc, #208]	; (810fbc8 <dhcp_parse_reply+0x30c>)
 810faf6:	f00b fe83 	bl	811b800 <iprintf>
 810fafa:	f06f 0305 	mvn.w	r3, #5
 810fafe:	e1dd      	b.n	810febc <dhcp_parse_reply+0x600>
        decode_idx = DHCP_OPTION_IDX_ROUTER;
 810fb00:	2307      	movs	r3, #7
 810fb02:	623b      	str	r3, [r7, #32]
        break;
 810fb04:	e0b2      	b.n	810fc6c <dhcp_parse_reply+0x3b0>
#if LWIP_DHCP_PROVIDE_DNS_SERVERS
      case (DHCP_OPTION_DNS_SERVER):
        /* special case: there might be more than one server */
        LWIP_ERROR("len %% 4 == 0", len % 4 == 0, return ERR_VAL;);
 810fb06:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 810fb0a:	f003 0303 	and.w	r3, r3, #3
 810fb0e:	b2db      	uxtb	r3, r3
 810fb10:	2b00      	cmp	r3, #0
 810fb12:	d009      	beq.n	810fb28 <dhcp_parse_reply+0x26c>
 810fb14:	4b2a      	ldr	r3, [pc, #168]	; (810fbc0 <dhcp_parse_reply+0x304>)
 810fb16:	f240 6239 	movw	r2, #1593	; 0x639
 810fb1a:	492d      	ldr	r1, [pc, #180]	; (810fbd0 <dhcp_parse_reply+0x314>)
 810fb1c:	482a      	ldr	r0, [pc, #168]	; (810fbc8 <dhcp_parse_reply+0x30c>)
 810fb1e:	f00b fe6f 	bl	811b800 <iprintf>
 810fb22:	f06f 0305 	mvn.w	r3, #5
 810fb26:	e1c9      	b.n	810febc <dhcp_parse_reply+0x600>
        /* limit number of DNS servers */
        decode_len = LWIP_MIN(len, 4 * DNS_MAX_SERVERS);
 810fb28:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 810fb2c:	2b08      	cmp	r3, #8
 810fb2e:	bf28      	it	cs
 810fb30:	2308      	movcs	r3, #8
 810fb32:	f887 3026 	strb.w	r3, [r7, #38]	; 0x26
        LWIP_ERROR("len >= decode_len", len >= decode_len, return ERR_VAL;);
 810fb36:	f897 2027 	ldrb.w	r2, [r7, #39]	; 0x27
 810fb3a:	f897 3026 	ldrb.w	r3, [r7, #38]	; 0x26
 810fb3e:	429a      	cmp	r2, r3
 810fb40:	d209      	bcs.n	810fb56 <dhcp_parse_reply+0x29a>
 810fb42:	4b1f      	ldr	r3, [pc, #124]	; (810fbc0 <dhcp_parse_reply+0x304>)
 810fb44:	f240 623c 	movw	r2, #1596	; 0x63c
 810fb48:	4920      	ldr	r1, [pc, #128]	; (810fbcc <dhcp_parse_reply+0x310>)
 810fb4a:	481f      	ldr	r0, [pc, #124]	; (810fbc8 <dhcp_parse_reply+0x30c>)
 810fb4c:	f00b fe58 	bl	811b800 <iprintf>
 810fb50:	f06f 0305 	mvn.w	r3, #5
 810fb54:	e1b2      	b.n	810febc <dhcp_parse_reply+0x600>
        decode_idx = DHCP_OPTION_IDX_DNS_SERVER;
 810fb56:	2308      	movs	r3, #8
 810fb58:	623b      	str	r3, [r7, #32]
        break;
 810fb5a:	e087      	b.n	810fc6c <dhcp_parse_reply+0x3b0>
#endif /* LWIP_DHCP_PROVIDE_DNS_SERVERS */
      case (DHCP_OPTION_LEASE_TIME):
        LWIP_ERROR("len == 4", len == 4, return ERR_VAL;);
 810fb5c:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 810fb60:	2b04      	cmp	r3, #4
 810fb62:	d009      	beq.n	810fb78 <dhcp_parse_reply+0x2bc>
 810fb64:	4b16      	ldr	r3, [pc, #88]	; (810fbc0 <dhcp_parse_reply+0x304>)
 810fb66:	f240 6241 	movw	r2, #1601	; 0x641
 810fb6a:	4916      	ldr	r1, [pc, #88]	; (810fbc4 <dhcp_parse_reply+0x308>)
 810fb6c:	4816      	ldr	r0, [pc, #88]	; (810fbc8 <dhcp_parse_reply+0x30c>)
 810fb6e:	f00b fe47 	bl	811b800 <iprintf>
 810fb72:	f06f 0305 	mvn.w	r3, #5
 810fb76:	e1a1      	b.n	810febc <dhcp_parse_reply+0x600>
        decode_idx = DHCP_OPTION_IDX_LEASE_TIME;
 810fb78:	2303      	movs	r3, #3
 810fb7a:	623b      	str	r3, [r7, #32]
        break;
 810fb7c:	e076      	b.n	810fc6c <dhcp_parse_reply+0x3b0>
        LWIP_ERROR("len >= decode_len", len >= decode_len, return ERR_VAL;);
        decode_idx = DHCP_OPTION_IDX_NTP_SERVER;
        break;
#endif /* LWIP_DHCP_GET_NTP_SRV*/
      case (DHCP_OPTION_OVERLOAD):
        LWIP_ERROR("len == 1", len == 1, return ERR_VAL;);
 810fb7e:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 810fb82:	2b01      	cmp	r3, #1
 810fb84:	d009      	beq.n	810fb9a <dhcp_parse_reply+0x2de>
 810fb86:	4b0e      	ldr	r3, [pc, #56]	; (810fbc0 <dhcp_parse_reply+0x304>)
 810fb88:	f240 624f 	movw	r2, #1615	; 0x64f
 810fb8c:	4911      	ldr	r1, [pc, #68]	; (810fbd4 <dhcp_parse_reply+0x318>)
 810fb8e:	480e      	ldr	r0, [pc, #56]	; (810fbc8 <dhcp_parse_reply+0x30c>)
 810fb90:	f00b fe36 	bl	811b800 <iprintf>
 810fb94:	f06f 0305 	mvn.w	r3, #5
 810fb98:	e190      	b.n	810febc <dhcp_parse_reply+0x600>
        /* decode overload only in options, not in file/sname: invalid packet */
        LWIP_ERROR("overload in file/sname", options_idx == DHCP_OPTIONS_OFS, return ERR_VAL;);
 810fb9a:	8efb      	ldrh	r3, [r7, #54]	; 0x36
 810fb9c:	2bf0      	cmp	r3, #240	; 0xf0
 810fb9e:	d009      	beq.n	810fbb4 <dhcp_parse_reply+0x2f8>
 810fba0:	4b07      	ldr	r3, [pc, #28]	; (810fbc0 <dhcp_parse_reply+0x304>)
 810fba2:	f240 6251 	movw	r2, #1617	; 0x651
 810fba6:	490c      	ldr	r1, [pc, #48]	; (810fbd8 <dhcp_parse_reply+0x31c>)
 810fba8:	4807      	ldr	r0, [pc, #28]	; (810fbc8 <dhcp_parse_reply+0x30c>)
 810fbaa:	f00b fe29 	bl	811b800 <iprintf>
 810fbae:	f06f 0305 	mvn.w	r3, #5
 810fbb2:	e183      	b.n	810febc <dhcp_parse_reply+0x600>
        decode_idx = DHCP_OPTION_IDX_OVERLOAD;
 810fbb4:	2300      	movs	r3, #0
 810fbb6:	623b      	str	r3, [r7, #32]
        break;
 810fbb8:	e058      	b.n	810fc6c <dhcp_parse_reply+0x3b0>
 810fbba:	bf00      	nop
 810fbbc:	10004f5c 	.word	0x10004f5c
 810fbc0:	0811c788 	.word	0x0811c788
 810fbc4:	0811ca40 	.word	0x0811ca40
 810fbc8:	0811c818 	.word	0x0811c818
 810fbcc:	0811ca4c 	.word	0x0811ca4c
 810fbd0:	0811ca60 	.word	0x0811ca60
 810fbd4:	0811ca70 	.word	0x0811ca70
 810fbd8:	0811ca7c 	.word	0x0811ca7c
      case (DHCP_OPTION_MESSAGE_TYPE):
        LWIP_ERROR("len == 1", len == 1, return ERR_VAL;);
 810fbdc:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 810fbe0:	2b01      	cmp	r3, #1
 810fbe2:	d009      	beq.n	810fbf8 <dhcp_parse_reply+0x33c>
 810fbe4:	4b9d      	ldr	r3, [pc, #628]	; (810fe5c <dhcp_parse_reply+0x5a0>)
 810fbe6:	f240 6255 	movw	r2, #1621	; 0x655
 810fbea:	499d      	ldr	r1, [pc, #628]	; (810fe60 <dhcp_parse_reply+0x5a4>)
 810fbec:	489d      	ldr	r0, [pc, #628]	; (810fe64 <dhcp_parse_reply+0x5a8>)
 810fbee:	f00b fe07 	bl	811b800 <iprintf>
 810fbf2:	f06f 0305 	mvn.w	r3, #5
 810fbf6:	e161      	b.n	810febc <dhcp_parse_reply+0x600>
        decode_idx = DHCP_OPTION_IDX_MSG_TYPE;
 810fbf8:	2301      	movs	r3, #1
 810fbfa:	623b      	str	r3, [r7, #32]
        break;
 810fbfc:	e036      	b.n	810fc6c <dhcp_parse_reply+0x3b0>
      case (DHCP_OPTION_SERVER_ID):
        LWIP_ERROR("len == 4", len == 4, return ERR_VAL;);
 810fbfe:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 810fc02:	2b04      	cmp	r3, #4
 810fc04:	d009      	beq.n	810fc1a <dhcp_parse_reply+0x35e>
 810fc06:	4b95      	ldr	r3, [pc, #596]	; (810fe5c <dhcp_parse_reply+0x5a0>)
 810fc08:	f240 6259 	movw	r2, #1625	; 0x659
 810fc0c:	4996      	ldr	r1, [pc, #600]	; (810fe68 <dhcp_parse_reply+0x5ac>)
 810fc0e:	4895      	ldr	r0, [pc, #596]	; (810fe64 <dhcp_parse_reply+0x5a8>)
 810fc10:	f00b fdf6 	bl	811b800 <iprintf>
 810fc14:	f06f 0305 	mvn.w	r3, #5
 810fc18:	e150      	b.n	810febc <dhcp_parse_reply+0x600>
        decode_idx = DHCP_OPTION_IDX_SERVER_ID;
 810fc1a:	2302      	movs	r3, #2
 810fc1c:	623b      	str	r3, [r7, #32]
        break;
 810fc1e:	e025      	b.n	810fc6c <dhcp_parse_reply+0x3b0>
      case (DHCP_OPTION_T1):
        LWIP_ERROR("len == 4", len == 4, return ERR_VAL;);
 810fc20:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 810fc24:	2b04      	cmp	r3, #4
 810fc26:	d009      	beq.n	810fc3c <dhcp_parse_reply+0x380>
 810fc28:	4b8c      	ldr	r3, [pc, #560]	; (810fe5c <dhcp_parse_reply+0x5a0>)
 810fc2a:	f240 625d 	movw	r2, #1629	; 0x65d
 810fc2e:	498e      	ldr	r1, [pc, #568]	; (810fe68 <dhcp_parse_reply+0x5ac>)
 810fc30:	488c      	ldr	r0, [pc, #560]	; (810fe64 <dhcp_parse_reply+0x5a8>)
 810fc32:	f00b fde5 	bl	811b800 <iprintf>
 810fc36:	f06f 0305 	mvn.w	r3, #5
 810fc3a:	e13f      	b.n	810febc <dhcp_parse_reply+0x600>
        decode_idx = DHCP_OPTION_IDX_T1;
 810fc3c:	2304      	movs	r3, #4
 810fc3e:	623b      	str	r3, [r7, #32]
        break;
 810fc40:	e014      	b.n	810fc6c <dhcp_parse_reply+0x3b0>
      case (DHCP_OPTION_T2):
        LWIP_ERROR("len == 4", len == 4, return ERR_VAL;);
 810fc42:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 810fc46:	2b04      	cmp	r3, #4
 810fc48:	d009      	beq.n	810fc5e <dhcp_parse_reply+0x3a2>
 810fc4a:	4b84      	ldr	r3, [pc, #528]	; (810fe5c <dhcp_parse_reply+0x5a0>)
 810fc4c:	f240 6261 	movw	r2, #1633	; 0x661
 810fc50:	4985      	ldr	r1, [pc, #532]	; (810fe68 <dhcp_parse_reply+0x5ac>)
 810fc52:	4884      	ldr	r0, [pc, #528]	; (810fe64 <dhcp_parse_reply+0x5a8>)
 810fc54:	f00b fdd4 	bl	811b800 <iprintf>
 810fc58:	f06f 0305 	mvn.w	r3, #5
 810fc5c:	e12e      	b.n	810febc <dhcp_parse_reply+0x600>
        decode_idx = DHCP_OPTION_IDX_T2;
 810fc5e:	2305      	movs	r3, #5
 810fc60:	623b      	str	r3, [r7, #32]
        break;
 810fc62:	e003      	b.n	810fc6c <dhcp_parse_reply+0x3b0>
      default:
        decode_len = 0;
 810fc64:	2300      	movs	r3, #0
 810fc66:	f887 3026 	strb.w	r3, [r7, #38]	; 0x26
        LWIP_DEBUGF(DHCP_DEBUG, ("skipping option %"U16_F" in options\n", (u16_t)op));
        LWIP_HOOK_DHCP_PARSE_OPTION(ip_current_netif(), dhcp, dhcp->state, msg_in,
                                    dhcp_option_given(dhcp, DHCP_OPTION_IDX_MSG_TYPE) ? (u8_t)dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_MSG_TYPE) : 0,
                                    op, len, q, val_offset);
        break;
 810fc6a:	bf00      	nop
    }
    if (op == DHCP_OPTION_PAD) {
 810fc6c:	7dfb      	ldrb	r3, [r7, #23]
 810fc6e:	2b00      	cmp	r3, #0
 810fc70:	d103      	bne.n	810fc7a <dhcp_parse_reply+0x3be>
      offset++;
 810fc72:	8f7b      	ldrh	r3, [r7, #58]	; 0x3a
 810fc74:	3301      	adds	r3, #1
 810fc76:	877b      	strh	r3, [r7, #58]	; 0x3a
 810fc78:	e0a1      	b.n	810fdbe <dhcp_parse_reply+0x502>
    } else {
      if (offset + len + 2 > 0xFFFF) {
 810fc7a:	8f7a      	ldrh	r2, [r7, #58]	; 0x3a
 810fc7c:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 810fc80:	4413      	add	r3, r2
 810fc82:	f64f 72fd 	movw	r2, #65533	; 0xfffd
 810fc86:	4293      	cmp	r3, r2
 810fc88:	dd02      	ble.n	810fc90 <dhcp_parse_reply+0x3d4>
        /* overflow */
        return ERR_BUF;
 810fc8a:	f06f 0301 	mvn.w	r3, #1
 810fc8e:	e115      	b.n	810febc <dhcp_parse_reply+0x600>
      }
      offset = (u16_t)(offset + len + 2);
 810fc90:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 810fc94:	b29a      	uxth	r2, r3
 810fc96:	8f7b      	ldrh	r3, [r7, #58]	; 0x3a
 810fc98:	4413      	add	r3, r2
 810fc9a:	b29b      	uxth	r3, r3
 810fc9c:	3302      	adds	r3, #2
 810fc9e:	877b      	strh	r3, [r7, #58]	; 0x3a
      if (decode_len > 0) {
 810fca0:	f897 3026 	ldrb.w	r3, [r7, #38]	; 0x26
 810fca4:	2b00      	cmp	r3, #0
 810fca6:	f000 808a 	beq.w	810fdbe <dhcp_parse_reply+0x502>
        u32_t value = 0;
 810fcaa:	2300      	movs	r3, #0
 810fcac:	60bb      	str	r3, [r7, #8]
        u16_t copy_len;
decode_next:
        LWIP_ASSERT("check decode_idx", decode_idx >= 0 && decode_idx < DHCP_OPTION_IDX_MAX);
 810fcae:	6a3b      	ldr	r3, [r7, #32]
 810fcb0:	2b00      	cmp	r3, #0
 810fcb2:	db02      	blt.n	810fcba <dhcp_parse_reply+0x3fe>
 810fcb4:	6a3b      	ldr	r3, [r7, #32]
 810fcb6:	2b09      	cmp	r3, #9
 810fcb8:	dd06      	ble.n	810fcc8 <dhcp_parse_reply+0x40c>
 810fcba:	4b68      	ldr	r3, [pc, #416]	; (810fe5c <dhcp_parse_reply+0x5a0>)
 810fcbc:	f44f 62cf 	mov.w	r2, #1656	; 0x678
 810fcc0:	496a      	ldr	r1, [pc, #424]	; (810fe6c <dhcp_parse_reply+0x5b0>)
 810fcc2:	4868      	ldr	r0, [pc, #416]	; (810fe64 <dhcp_parse_reply+0x5a8>)
 810fcc4:	f00b fd9c 	bl	811b800 <iprintf>
        if (!dhcp_option_given(dhcp, decode_idx)) {
 810fcc8:	4a69      	ldr	r2, [pc, #420]	; (810fe70 <dhcp_parse_reply+0x5b4>)
 810fcca:	6a3b      	ldr	r3, [r7, #32]
 810fccc:	4413      	add	r3, r2
 810fcce:	781b      	ldrb	r3, [r3, #0]
 810fcd0:	2b00      	cmp	r3, #0
 810fcd2:	d174      	bne.n	810fdbe <dhcp_parse_reply+0x502>
          copy_len = LWIP_MIN(decode_len, 4);
 810fcd4:	f897 3026 	ldrb.w	r3, [r7, #38]	; 0x26
 810fcd8:	2b04      	cmp	r3, #4
 810fcda:	bf28      	it	cs
 810fcdc:	2304      	movcs	r3, #4
 810fcde:	b2db      	uxtb	r3, r3
 810fce0:	82bb      	strh	r3, [r7, #20]
          if (pbuf_copy_partial(q, &value, copy_len, val_offset) != copy_len) {
 810fce2:	8bfb      	ldrh	r3, [r7, #30]
 810fce4:	8aba      	ldrh	r2, [r7, #20]
 810fce6:	f107 0108 	add.w	r1, r7, #8
 810fcea:	6b38      	ldr	r0, [r7, #48]	; 0x30
 810fcec:	f004 feae 	bl	8114a4c <pbuf_copy_partial>
 810fcf0:	4603      	mov	r3, r0
 810fcf2:	461a      	mov	r2, r3
 810fcf4:	8abb      	ldrh	r3, [r7, #20]
 810fcf6:	4293      	cmp	r3, r2
 810fcf8:	d002      	beq.n	810fd00 <dhcp_parse_reply+0x444>
            return ERR_BUF;
 810fcfa:	f06f 0301 	mvn.w	r3, #1
 810fcfe:	e0dd      	b.n	810febc <dhcp_parse_reply+0x600>
          }
          if (decode_len > 4) {
 810fd00:	f897 3026 	ldrb.w	r3, [r7, #38]	; 0x26
 810fd04:	2b04      	cmp	r3, #4
 810fd06:	d933      	bls.n	810fd70 <dhcp_parse_reply+0x4b4>
            /* decode more than one u32_t */
            u16_t next_val_offset;
            LWIP_ERROR("decode_len %% 4 == 0", decode_len % 4 == 0, return ERR_VAL;);
 810fd08:	f897 3026 	ldrb.w	r3, [r7, #38]	; 0x26
 810fd0c:	f003 0303 	and.w	r3, r3, #3
 810fd10:	b2db      	uxtb	r3, r3
 810fd12:	2b00      	cmp	r3, #0
 810fd14:	d009      	beq.n	810fd2a <dhcp_parse_reply+0x46e>
 810fd16:	4b51      	ldr	r3, [pc, #324]	; (810fe5c <dhcp_parse_reply+0x5a0>)
 810fd18:	f240 6281 	movw	r2, #1665	; 0x681
 810fd1c:	4955      	ldr	r1, [pc, #340]	; (810fe74 <dhcp_parse_reply+0x5b8>)
 810fd1e:	4851      	ldr	r0, [pc, #324]	; (810fe64 <dhcp_parse_reply+0x5a8>)
 810fd20:	f00b fd6e 	bl	811b800 <iprintf>
 810fd24:	f06f 0305 	mvn.w	r3, #5
 810fd28:	e0c8      	b.n	810febc <dhcp_parse_reply+0x600>
            dhcp_got_option(dhcp, decode_idx);
 810fd2a:	4a51      	ldr	r2, [pc, #324]	; (810fe70 <dhcp_parse_reply+0x5b4>)
 810fd2c:	6a3b      	ldr	r3, [r7, #32]
 810fd2e:	4413      	add	r3, r2
 810fd30:	2201      	movs	r2, #1
 810fd32:	701a      	strb	r2, [r3, #0]
            dhcp_set_option_value(dhcp, decode_idx, lwip_htonl(value));
 810fd34:	68bb      	ldr	r3, [r7, #8]
 810fd36:	4618      	mov	r0, r3
 810fd38:	f7fe fbc0 	bl	810e4bc <lwip_htonl>
 810fd3c:	4602      	mov	r2, r0
 810fd3e:	494e      	ldr	r1, [pc, #312]	; (810fe78 <dhcp_parse_reply+0x5bc>)
 810fd40:	6a3b      	ldr	r3, [r7, #32]
 810fd42:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
            decode_len = (u8_t)(decode_len - 4);
 810fd46:	f897 3026 	ldrb.w	r3, [r7, #38]	; 0x26
 810fd4a:	3b04      	subs	r3, #4
 810fd4c:	f887 3026 	strb.w	r3, [r7, #38]	; 0x26
            next_val_offset = (u16_t)(val_offset + 4);
 810fd50:	8bfb      	ldrh	r3, [r7, #30]
 810fd52:	3304      	adds	r3, #4
 810fd54:	827b      	strh	r3, [r7, #18]
            if (next_val_offset < val_offset) {
 810fd56:	8a7a      	ldrh	r2, [r7, #18]
 810fd58:	8bfb      	ldrh	r3, [r7, #30]
 810fd5a:	429a      	cmp	r2, r3
 810fd5c:	d202      	bcs.n	810fd64 <dhcp_parse_reply+0x4a8>
              /* overflow */
              return ERR_BUF;
 810fd5e:	f06f 0301 	mvn.w	r3, #1
 810fd62:	e0ab      	b.n	810febc <dhcp_parse_reply+0x600>
            }
            val_offset = next_val_offset;
 810fd64:	8a7b      	ldrh	r3, [r7, #18]
 810fd66:	83fb      	strh	r3, [r7, #30]
            decode_idx++;
 810fd68:	6a3b      	ldr	r3, [r7, #32]
 810fd6a:	3301      	adds	r3, #1
 810fd6c:	623b      	str	r3, [r7, #32]
            goto decode_next;
 810fd6e:	e79e      	b.n	810fcae <dhcp_parse_reply+0x3f2>
          } else if (decode_len == 4) {
 810fd70:	f897 3026 	ldrb.w	r3, [r7, #38]	; 0x26
 810fd74:	2b04      	cmp	r3, #4
 810fd76:	d106      	bne.n	810fd86 <dhcp_parse_reply+0x4ca>
            value = lwip_ntohl(value);
 810fd78:	68bb      	ldr	r3, [r7, #8]
 810fd7a:	4618      	mov	r0, r3
 810fd7c:	f7fe fb9e 	bl	810e4bc <lwip_htonl>
 810fd80:	4603      	mov	r3, r0
 810fd82:	60bb      	str	r3, [r7, #8]
 810fd84:	e011      	b.n	810fdaa <dhcp_parse_reply+0x4ee>
          } else {
            LWIP_ERROR("invalid decode_len", decode_len == 1, return ERR_VAL;);
 810fd86:	f897 3026 	ldrb.w	r3, [r7, #38]	; 0x26
 810fd8a:	2b01      	cmp	r3, #1
 810fd8c:	d009      	beq.n	810fda2 <dhcp_parse_reply+0x4e6>
 810fd8e:	4b33      	ldr	r3, [pc, #204]	; (810fe5c <dhcp_parse_reply+0x5a0>)
 810fd90:	f44f 62d2 	mov.w	r2, #1680	; 0x690
 810fd94:	4939      	ldr	r1, [pc, #228]	; (810fe7c <dhcp_parse_reply+0x5c0>)
 810fd96:	4833      	ldr	r0, [pc, #204]	; (810fe64 <dhcp_parse_reply+0x5a8>)
 810fd98:	f00b fd32 	bl	811b800 <iprintf>
 810fd9c:	f06f 0305 	mvn.w	r3, #5
 810fda0:	e08c      	b.n	810febc <dhcp_parse_reply+0x600>
            value = ((u8_t *)&value)[0];
 810fda2:	f107 0308 	add.w	r3, r7, #8
 810fda6:	781b      	ldrb	r3, [r3, #0]
 810fda8:	60bb      	str	r3, [r7, #8]
          }
          dhcp_got_option(dhcp, decode_idx);
 810fdaa:	4a31      	ldr	r2, [pc, #196]	; (810fe70 <dhcp_parse_reply+0x5b4>)
 810fdac:	6a3b      	ldr	r3, [r7, #32]
 810fdae:	4413      	add	r3, r2
 810fdb0:	2201      	movs	r2, #1
 810fdb2:	701a      	strb	r2, [r3, #0]
          dhcp_set_option_value(dhcp, decode_idx, value);
 810fdb4:	68ba      	ldr	r2, [r7, #8]
 810fdb6:	4930      	ldr	r1, [pc, #192]	; (810fe78 <dhcp_parse_reply+0x5bc>)
 810fdb8:	6a3b      	ldr	r3, [r7, #32]
 810fdba:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
        }
      }
    }
    if (offset >= q->len) {
 810fdbe:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 810fdc0:	895b      	ldrh	r3, [r3, #10]
 810fdc2:	8f7a      	ldrh	r2, [r7, #58]	; 0x3a
 810fdc4:	429a      	cmp	r2, r3
 810fdc6:	d324      	bcc.n	810fe12 <dhcp_parse_reply+0x556>
      offset = (u16_t)(offset - q->len);
 810fdc8:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 810fdca:	895b      	ldrh	r3, [r3, #10]
 810fdcc:	8f7a      	ldrh	r2, [r7, #58]	; 0x3a
 810fdce:	1ad3      	subs	r3, r2, r3
 810fdd0:	877b      	strh	r3, [r7, #58]	; 0x3a
      offset_max = (u16_t)(offset_max - q->len);
 810fdd2:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 810fdd4:	895b      	ldrh	r3, [r3, #10]
 810fdd6:	8f3a      	ldrh	r2, [r7, #56]	; 0x38
 810fdd8:	1ad3      	subs	r3, r2, r3
 810fdda:	873b      	strh	r3, [r7, #56]	; 0x38
      if (offset < offset_max) {
 810fddc:	8f7a      	ldrh	r2, [r7, #58]	; 0x3a
 810fdde:	8f3b      	ldrh	r3, [r7, #56]	; 0x38
 810fde0:	429a      	cmp	r2, r3
 810fde2:	d213      	bcs.n	810fe0c <dhcp_parse_reply+0x550>
        q = q->next;
 810fde4:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 810fde6:	681b      	ldr	r3, [r3, #0]
 810fde8:	633b      	str	r3, [r7, #48]	; 0x30
        LWIP_ERROR("next pbuf was null", q != NULL, return ERR_VAL;);
 810fdea:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 810fdec:	2b00      	cmp	r3, #0
 810fdee:	d109      	bne.n	810fe04 <dhcp_parse_reply+0x548>
 810fdf0:	4b1a      	ldr	r3, [pc, #104]	; (810fe5c <dhcp_parse_reply+0x5a0>)
 810fdf2:	f240 629d 	movw	r2, #1693	; 0x69d
 810fdf6:	4922      	ldr	r1, [pc, #136]	; (810fe80 <dhcp_parse_reply+0x5c4>)
 810fdf8:	481a      	ldr	r0, [pc, #104]	; (810fe64 <dhcp_parse_reply+0x5a8>)
 810fdfa:	f00b fd01 	bl	811b800 <iprintf>
 810fdfe:	f06f 0305 	mvn.w	r3, #5
 810fe02:	e05b      	b.n	810febc <dhcp_parse_reply+0x600>
        options = (u8_t *)q->payload;
 810fe04:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 810fe06:	685b      	ldr	r3, [r3, #4]
 810fe08:	63fb      	str	r3, [r7, #60]	; 0x3c
 810fe0a:	e002      	b.n	810fe12 <dhcp_parse_reply+0x556>
      } else {
        /* We've run out of bytes, probably no end marker. Don't proceed. */
        return ERR_BUF;
 810fe0c:	f06f 0301 	mvn.w	r3, #1
 810fe10:	e054      	b.n	810febc <dhcp_parse_reply+0x600>
  while ((q != NULL) && (offset < offset_max) && (options[offset] != DHCP_OPTION_END)) {
 810fe12:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 810fe14:	2b00      	cmp	r3, #0
 810fe16:	d00a      	beq.n	810fe2e <dhcp_parse_reply+0x572>
 810fe18:	8f7a      	ldrh	r2, [r7, #58]	; 0x3a
 810fe1a:	8f3b      	ldrh	r3, [r7, #56]	; 0x38
 810fe1c:	429a      	cmp	r2, r3
 810fe1e:	d206      	bcs.n	810fe2e <dhcp_parse_reply+0x572>
 810fe20:	8f7b      	ldrh	r3, [r7, #58]	; 0x3a
 810fe22:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 810fe24:	4413      	add	r3, r2
 810fe26:	781b      	ldrb	r3, [r3, #0]
 810fe28:	2bff      	cmp	r3, #255	; 0xff
 810fe2a:	f47f ad8a 	bne.w	810f942 <dhcp_parse_reply+0x86>
      }
    }
  }
  /* is this an overloaded message? */
  if (dhcp_option_given(dhcp, DHCP_OPTION_IDX_OVERLOAD)) {
 810fe2e:	4b10      	ldr	r3, [pc, #64]	; (810fe70 <dhcp_parse_reply+0x5b4>)
 810fe30:	781b      	ldrb	r3, [r3, #0]
 810fe32:	2b00      	cmp	r3, #0
 810fe34:	d02d      	beq.n	810fe92 <dhcp_parse_reply+0x5d6>
    u32_t overload = dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_OVERLOAD);
 810fe36:	4b10      	ldr	r3, [pc, #64]	; (810fe78 <dhcp_parse_reply+0x5bc>)
 810fe38:	681b      	ldr	r3, [r3, #0]
 810fe3a:	60fb      	str	r3, [r7, #12]
    dhcp_clear_option(dhcp, DHCP_OPTION_IDX_OVERLOAD);
 810fe3c:	4b0c      	ldr	r3, [pc, #48]	; (810fe70 <dhcp_parse_reply+0x5b4>)
 810fe3e:	2200      	movs	r2, #0
 810fe40:	701a      	strb	r2, [r3, #0]
    if (overload == DHCP_OVERLOAD_FILE) {
 810fe42:	68fb      	ldr	r3, [r7, #12]
 810fe44:	2b01      	cmp	r3, #1
 810fe46:	d102      	bne.n	810fe4e <dhcp_parse_reply+0x592>
      parse_file_as_options = 1;
 810fe48:	2301      	movs	r3, #1
 810fe4a:	62fb      	str	r3, [r7, #44]	; 0x2c
 810fe4c:	e021      	b.n	810fe92 <dhcp_parse_reply+0x5d6>
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("overloaded file field\n"));
    } else if (overload == DHCP_OVERLOAD_SNAME) {
 810fe4e:	68fb      	ldr	r3, [r7, #12]
 810fe50:	2b02      	cmp	r3, #2
 810fe52:	d117      	bne.n	810fe84 <dhcp_parse_reply+0x5c8>
      parse_sname_as_options = 1;
 810fe54:	2301      	movs	r3, #1
 810fe56:	62bb      	str	r3, [r7, #40]	; 0x28
 810fe58:	e01b      	b.n	810fe92 <dhcp_parse_reply+0x5d6>
 810fe5a:	bf00      	nop
 810fe5c:	0811c788 	.word	0x0811c788
 810fe60:	0811ca70 	.word	0x0811ca70
 810fe64:	0811c818 	.word	0x0811c818
 810fe68:	0811ca40 	.word	0x0811ca40
 810fe6c:	0811ca94 	.word	0x0811ca94
 810fe70:	10004f5c 	.word	0x10004f5c
 810fe74:	0811caa8 	.word	0x0811caa8
 810fe78:	10004f34 	.word	0x10004f34
 810fe7c:	0811cac0 	.word	0x0811cac0
 810fe80:	0811cad4 	.word	0x0811cad4
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("overloaded sname field\n"));
    } else if (overload == DHCP_OVERLOAD_SNAME_FILE) {
 810fe84:	68fb      	ldr	r3, [r7, #12]
 810fe86:	2b03      	cmp	r3, #3
 810fe88:	d103      	bne.n	810fe92 <dhcp_parse_reply+0x5d6>
      parse_sname_as_options = 1;
 810fe8a:	2301      	movs	r3, #1
 810fe8c:	62bb      	str	r3, [r7, #40]	; 0x28
      parse_file_as_options = 1;
 810fe8e:	2301      	movs	r3, #1
 810fe90:	62fb      	str	r3, [r7, #44]	; 0x2c
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("overloaded sname and file field\n"));
    } else {
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("invalid overload option: %d\n", (int)overload));
    }
  }
  if (parse_file_as_options) {
 810fe92:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 810fe94:	2b00      	cmp	r3, #0
 810fe96:	d006      	beq.n	810fea6 <dhcp_parse_reply+0x5ea>
    /* if both are overloaded, parse file first and then sname (RFC 2131 ch. 4.1) */
    parse_file_as_options = 0;
 810fe98:	2300      	movs	r3, #0
 810fe9a:	62fb      	str	r3, [r7, #44]	; 0x2c
    options_idx = DHCP_FILE_OFS;
 810fe9c:	236c      	movs	r3, #108	; 0x6c
 810fe9e:	86fb      	strh	r3, [r7, #54]	; 0x36
    options_idx_max = DHCP_FILE_OFS + DHCP_FILE_LEN;
 810fea0:	23ec      	movs	r3, #236	; 0xec
 810fea2:	86bb      	strh	r3, [r7, #52]	; 0x34
#if LWIP_DHCP_BOOTP_FILE
    file_overloaded = 1;
#endif
    goto again;
 810fea4:	e527      	b.n	810f8f6 <dhcp_parse_reply+0x3a>
  } else if (parse_sname_as_options) {
 810fea6:	6abb      	ldr	r3, [r7, #40]	; 0x28
 810fea8:	2b00      	cmp	r3, #0
 810feaa:	d006      	beq.n	810feba <dhcp_parse_reply+0x5fe>
    parse_sname_as_options = 0;
 810feac:	2300      	movs	r3, #0
 810feae:	62bb      	str	r3, [r7, #40]	; 0x28
    options_idx = DHCP_SNAME_OFS;
 810feb0:	232c      	movs	r3, #44	; 0x2c
 810feb2:	86fb      	strh	r3, [r7, #54]	; 0x36
    options_idx_max = DHCP_SNAME_OFS + DHCP_SNAME_LEN;
 810feb4:	236c      	movs	r3, #108	; 0x6c
 810feb6:	86bb      	strh	r3, [r7, #52]	; 0x34
    goto again;
 810feb8:	e51d      	b.n	810f8f6 <dhcp_parse_reply+0x3a>
    }
    /* make sure the string is really NULL-terminated */
    dhcp->boot_file_name[DHCP_FILE_LEN-1] = 0;
  }
#endif /* LWIP_DHCP_BOOTP_FILE */ 
  return ERR_OK;
 810feba:	2300      	movs	r3, #0
}
 810febc:	4618      	mov	r0, r3
 810febe:	3740      	adds	r7, #64	; 0x40
 810fec0:	46bd      	mov	sp, r7
 810fec2:	bd80      	pop	{r7, pc}

0810fec4 <dhcp_recv>:
/**
 * If an incoming DHCP message is in response to us, then trigger the state machine
 */
static void
dhcp_recv(void *arg, struct udp_pcb *pcb, struct pbuf *p, const ip_addr_t *addr, u16_t port)
{
 810fec4:	b580      	push	{r7, lr}
 810fec6:	b08a      	sub	sp, #40	; 0x28
 810fec8:	af00      	add	r7, sp, #0
 810feca:	60f8      	str	r0, [r7, #12]
 810fecc:	60b9      	str	r1, [r7, #8]
 810fece:	607a      	str	r2, [r7, #4]
 810fed0:	603b      	str	r3, [r7, #0]
  struct netif *netif = ip_current_input_netif();
 810fed2:	4b60      	ldr	r3, [pc, #384]	; (8110054 <dhcp_recv+0x190>)
 810fed4:	685b      	ldr	r3, [r3, #4]
 810fed6:	623b      	str	r3, [r7, #32]
  struct dhcp *dhcp = netif_dhcp_data(netif);
 810fed8:	6a3b      	ldr	r3, [r7, #32]
 810feda:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 810fedc:	61fb      	str	r3, [r7, #28]
  struct dhcp_msg *reply_msg = (struct dhcp_msg *)p->payload;
 810fede:	687b      	ldr	r3, [r7, #4]
 810fee0:	685b      	ldr	r3, [r3, #4]
 810fee2:	61bb      	str	r3, [r7, #24]
  struct dhcp_msg *msg_in;

  LWIP_UNUSED_ARG(arg);

  /* Caught DHCP message from netif that does not have DHCP enabled? -> not interested */
  if ((dhcp == NULL) || (dhcp->pcb_allocated == 0)) {
 810fee4:	69fb      	ldr	r3, [r7, #28]
 810fee6:	2b00      	cmp	r3, #0
 810fee8:	f000 809d 	beq.w	8110026 <dhcp_recv+0x162>
 810feec:	69fb      	ldr	r3, [r7, #28]
 810feee:	791b      	ldrb	r3, [r3, #4]
 810fef0:	2b00      	cmp	r3, #0
 810fef2:	f000 8098 	beq.w	8110026 <dhcp_recv+0x162>
  /* prevent warnings about unused arguments */
  LWIP_UNUSED_ARG(pcb);
  LWIP_UNUSED_ARG(addr);
  LWIP_UNUSED_ARG(port);

  if (p->len < DHCP_MIN_REPLY_LEN) {
 810fef6:	687b      	ldr	r3, [r7, #4]
 810fef8:	895b      	ldrh	r3, [r3, #10]
 810fefa:	2b2b      	cmp	r3, #43	; 0x2b
 810fefc:	f240 8095 	bls.w	811002a <dhcp_recv+0x166>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING, ("DHCP reply message or pbuf too short\n"));
    goto free_pbuf_and_return;
  }

  if (reply_msg->op != DHCP_BOOTREPLY) {
 810ff00:	69bb      	ldr	r3, [r7, #24]
 810ff02:	781b      	ldrb	r3, [r3, #0]
 810ff04:	2b02      	cmp	r3, #2
 810ff06:	f040 8092 	bne.w	811002e <dhcp_recv+0x16a>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING, ("not a DHCP reply message, but type %"U16_F"\n", (u16_t)reply_msg->op));
    goto free_pbuf_and_return;
  }
  /* iterate through hardware address and match against DHCP message */
  for (i = 0; i < netif->hwaddr_len && i < LWIP_MIN(DHCP_CHADDR_LEN, NETIF_MAX_HWADDR_LEN); i++) {
 810ff0a:	2300      	movs	r3, #0
 810ff0c:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
 810ff10:	e012      	b.n	810ff38 <dhcp_recv+0x74>
    if (netif->hwaddr[i] != reply_msg->chaddr[i]) {
 810ff12:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 810ff16:	6a3a      	ldr	r2, [r7, #32]
 810ff18:	4413      	add	r3, r2
 810ff1a:	f893 202a 	ldrb.w	r2, [r3, #42]	; 0x2a
 810ff1e:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 810ff22:	69b9      	ldr	r1, [r7, #24]
 810ff24:	440b      	add	r3, r1
 810ff26:	7f1b      	ldrb	r3, [r3, #28]
 810ff28:	429a      	cmp	r2, r3
 810ff2a:	f040 8082 	bne.w	8110032 <dhcp_recv+0x16e>
  for (i = 0; i < netif->hwaddr_len && i < LWIP_MIN(DHCP_CHADDR_LEN, NETIF_MAX_HWADDR_LEN); i++) {
 810ff2e:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 810ff32:	3301      	adds	r3, #1
 810ff34:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
 810ff38:	6a3b      	ldr	r3, [r7, #32]
 810ff3a:	f893 3030 	ldrb.w	r3, [r3, #48]	; 0x30
 810ff3e:	f897 2027 	ldrb.w	r2, [r7, #39]	; 0x27
 810ff42:	429a      	cmp	r2, r3
 810ff44:	d203      	bcs.n	810ff4e <dhcp_recv+0x8a>
 810ff46:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 810ff4a:	2b05      	cmp	r3, #5
 810ff4c:	d9e1      	bls.n	810ff12 <dhcp_recv+0x4e>
                   (u16_t)i, (u16_t)netif->hwaddr[i], (u16_t)i, (u16_t)reply_msg->chaddr[i]));
      goto free_pbuf_and_return;
    }
  }
  /* match transaction ID against what we expected */
  if (lwip_ntohl(reply_msg->xid) != dhcp->xid) {
 810ff4e:	69bb      	ldr	r3, [r7, #24]
 810ff50:	685b      	ldr	r3, [r3, #4]
 810ff52:	4618      	mov	r0, r3
 810ff54:	f7fe fab2 	bl	810e4bc <lwip_htonl>
 810ff58:	4602      	mov	r2, r0
 810ff5a:	69fb      	ldr	r3, [r7, #28]
 810ff5c:	681b      	ldr	r3, [r3, #0]
 810ff5e:	429a      	cmp	r2, r3
 810ff60:	d169      	bne.n	8110036 <dhcp_recv+0x172>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING,
                ("transaction id mismatch reply_msg->xid(%"X32_F")!=dhcp->xid(%"X32_F")\n", lwip_ntohl(reply_msg->xid), dhcp->xid));
    goto free_pbuf_and_return;
  }
  /* option fields could be unfold? */
  if (dhcp_parse_reply(p, dhcp) != ERR_OK) {
 810ff62:	69f9      	ldr	r1, [r7, #28]
 810ff64:	6878      	ldr	r0, [r7, #4]
 810ff66:	f7ff fca9 	bl	810f8bc <dhcp_parse_reply>
 810ff6a:	4603      	mov	r3, r0
 810ff6c:	2b00      	cmp	r3, #0
 810ff6e:	d164      	bne.n	811003a <dhcp_recv+0x176>
    goto free_pbuf_and_return;
  }

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("searching DHCP_OPTION_MESSAGE_TYPE\n"));
  /* obtain pointer to DHCP message type */
  if (!dhcp_option_given(dhcp, DHCP_OPTION_IDX_MSG_TYPE)) {
 810ff70:	4b39      	ldr	r3, [pc, #228]	; (8110058 <dhcp_recv+0x194>)
 810ff72:	785b      	ldrb	r3, [r3, #1]
 810ff74:	2b00      	cmp	r3, #0
 810ff76:	d062      	beq.n	811003e <dhcp_recv+0x17a>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING, ("DHCP_OPTION_MESSAGE_TYPE option not found\n"));
    goto free_pbuf_and_return;
  }

  msg_in = (struct dhcp_msg *)p->payload;
 810ff78:	687b      	ldr	r3, [r7, #4]
 810ff7a:	685b      	ldr	r3, [r3, #4]
 810ff7c:	617b      	str	r3, [r7, #20]
  /* read DHCP message type */
  msg_type = (u8_t)dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_MSG_TYPE);
 810ff7e:	4b37      	ldr	r3, [pc, #220]	; (811005c <dhcp_recv+0x198>)
 810ff80:	685b      	ldr	r3, [r3, #4]
 810ff82:	74fb      	strb	r3, [r7, #19]
  /* message type is DHCP ACK? */
  if (msg_type == DHCP_ACK) {
 810ff84:	7cfb      	ldrb	r3, [r7, #19]
 810ff86:	2b05      	cmp	r3, #5
 810ff88:	d12a      	bne.n	810ffe0 <dhcp_recv+0x11c>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("DHCP_ACK received\n"));
    /* in requesting state? */
    if (dhcp->state == DHCP_STATE_REQUESTING) {
 810ff8a:	69fb      	ldr	r3, [r7, #28]
 810ff8c:	795b      	ldrb	r3, [r3, #5]
 810ff8e:	2b01      	cmp	r3, #1
 810ff90:	d112      	bne.n	810ffb8 <dhcp_recv+0xf4>
      dhcp_handle_ack(netif, msg_in);
 810ff92:	6979      	ldr	r1, [r7, #20]
 810ff94:	6a38      	ldr	r0, [r7, #32]
 810ff96:	f7fe fdc7 	bl	810eb28 <dhcp_handle_ack>
#if DHCP_DOES_ARP_CHECK
      if ((netif->flags & NETIF_FLAG_ETHARP) != 0) {
 810ff9a:	6a3b      	ldr	r3, [r7, #32]
 810ff9c:	f893 3031 	ldrb.w	r3, [r3, #49]	; 0x31
 810ffa0:	f003 0308 	and.w	r3, r3, #8
 810ffa4:	2b00      	cmp	r3, #0
 810ffa6:	d003      	beq.n	810ffb0 <dhcp_recv+0xec>
        /* check if the acknowledged lease address is already in use */
        dhcp_check(netif);
 810ffa8:	6a38      	ldr	r0, [r7, #32]
 810ffaa:	f7fe fb37 	bl	810e61c <dhcp_check>
 810ffae:	e049      	b.n	8110044 <dhcp_recv+0x180>
      } else {
        /* bind interface to the acknowledged lease address */
        dhcp_bind(netif);
 810ffb0:	6a38      	ldr	r0, [r7, #32]
 810ffb2:	f7ff f837 	bl	810f024 <dhcp_bind>
 810ffb6:	e045      	b.n	8110044 <dhcp_recv+0x180>
      /* bind interface to the acknowledged lease address */
      dhcp_bind(netif);
#endif
    }
    /* already bound to the given lease address? */
    else if ((dhcp->state == DHCP_STATE_REBOOTING) || (dhcp->state == DHCP_STATE_REBINDING) ||
 810ffb8:	69fb      	ldr	r3, [r7, #28]
 810ffba:	795b      	ldrb	r3, [r3, #5]
 810ffbc:	2b03      	cmp	r3, #3
 810ffbe:	d007      	beq.n	810ffd0 <dhcp_recv+0x10c>
 810ffc0:	69fb      	ldr	r3, [r7, #28]
 810ffc2:	795b      	ldrb	r3, [r3, #5]
 810ffc4:	2b04      	cmp	r3, #4
 810ffc6:	d003      	beq.n	810ffd0 <dhcp_recv+0x10c>
             (dhcp->state == DHCP_STATE_RENEWING)) {
 810ffc8:	69fb      	ldr	r3, [r7, #28]
 810ffca:	795b      	ldrb	r3, [r3, #5]
    else if ((dhcp->state == DHCP_STATE_REBOOTING) || (dhcp->state == DHCP_STATE_REBINDING) ||
 810ffcc:	2b05      	cmp	r3, #5
 810ffce:	d139      	bne.n	8110044 <dhcp_recv+0x180>
      dhcp_handle_ack(netif, msg_in);
 810ffd0:	6979      	ldr	r1, [r7, #20]
 810ffd2:	6a38      	ldr	r0, [r7, #32]
 810ffd4:	f7fe fda8 	bl	810eb28 <dhcp_handle_ack>
      dhcp_bind(netif);
 810ffd8:	6a38      	ldr	r0, [r7, #32]
 810ffda:	f7ff f823 	bl	810f024 <dhcp_bind>
 810ffde:	e031      	b.n	8110044 <dhcp_recv+0x180>
    }
  }
  /* received a DHCP_NAK in appropriate state? */
  else if ((msg_type == DHCP_NAK) &&
 810ffe0:	7cfb      	ldrb	r3, [r7, #19]
 810ffe2:	2b06      	cmp	r3, #6
 810ffe4:	d113      	bne.n	811000e <dhcp_recv+0x14a>
           ((dhcp->state == DHCP_STATE_REBOOTING) || (dhcp->state == DHCP_STATE_REQUESTING) ||
 810ffe6:	69fb      	ldr	r3, [r7, #28]
 810ffe8:	795b      	ldrb	r3, [r3, #5]
  else if ((msg_type == DHCP_NAK) &&
 810ffea:	2b03      	cmp	r3, #3
 810ffec:	d00b      	beq.n	8110006 <dhcp_recv+0x142>
           ((dhcp->state == DHCP_STATE_REBOOTING) || (dhcp->state == DHCP_STATE_REQUESTING) ||
 810ffee:	69fb      	ldr	r3, [r7, #28]
 810fff0:	795b      	ldrb	r3, [r3, #5]
 810fff2:	2b01      	cmp	r3, #1
 810fff4:	d007      	beq.n	8110006 <dhcp_recv+0x142>
            (dhcp->state == DHCP_STATE_REBINDING) || (dhcp->state == DHCP_STATE_RENEWING  ))) {
 810fff6:	69fb      	ldr	r3, [r7, #28]
 810fff8:	795b      	ldrb	r3, [r3, #5]
           ((dhcp->state == DHCP_STATE_REBOOTING) || (dhcp->state == DHCP_STATE_REQUESTING) ||
 810fffa:	2b04      	cmp	r3, #4
 810fffc:	d003      	beq.n	8110006 <dhcp_recv+0x142>
            (dhcp->state == DHCP_STATE_REBINDING) || (dhcp->state == DHCP_STATE_RENEWING  ))) {
 810fffe:	69fb      	ldr	r3, [r7, #28]
 8110000:	795b      	ldrb	r3, [r3, #5]
 8110002:	2b05      	cmp	r3, #5
 8110004:	d103      	bne.n	811000e <dhcp_recv+0x14a>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("DHCP_NAK received\n"));
    dhcp_handle_nak(netif);
 8110006:	6a38      	ldr	r0, [r7, #32]
 8110008:	f7fe faee 	bl	810e5e8 <dhcp_handle_nak>
 811000c:	e01a      	b.n	8110044 <dhcp_recv+0x180>
  }
  /* received a DHCP_OFFER in DHCP_STATE_SELECTING state? */
  else if ((msg_type == DHCP_OFFER) && (dhcp->state == DHCP_STATE_SELECTING)) {
 811000e:	7cfb      	ldrb	r3, [r7, #19]
 8110010:	2b02      	cmp	r3, #2
 8110012:	d116      	bne.n	8110042 <dhcp_recv+0x17e>
 8110014:	69fb      	ldr	r3, [r7, #28]
 8110016:	795b      	ldrb	r3, [r3, #5]
 8110018:	2b06      	cmp	r3, #6
 811001a:	d112      	bne.n	8110042 <dhcp_recv+0x17e>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("DHCP_OFFER received in DHCP_STATE_SELECTING state\n"));
    /* remember offered lease */
    dhcp_handle_offer(netif, msg_in);
 811001c:	6979      	ldr	r1, [r7, #20]
 811001e:	6a38      	ldr	r0, [r7, #32]
 8110020:	f7fe fb30 	bl	810e684 <dhcp_handle_offer>
 8110024:	e00e      	b.n	8110044 <dhcp_recv+0x180>
    goto free_pbuf_and_return;
 8110026:	bf00      	nop
 8110028:	e00c      	b.n	8110044 <dhcp_recv+0x180>
    goto free_pbuf_and_return;
 811002a:	bf00      	nop
 811002c:	e00a      	b.n	8110044 <dhcp_recv+0x180>
    goto free_pbuf_and_return;
 811002e:	bf00      	nop
 8110030:	e008      	b.n	8110044 <dhcp_recv+0x180>
      goto free_pbuf_and_return;
 8110032:	bf00      	nop
 8110034:	e006      	b.n	8110044 <dhcp_recv+0x180>
    goto free_pbuf_and_return;
 8110036:	bf00      	nop
 8110038:	e004      	b.n	8110044 <dhcp_recv+0x180>
    goto free_pbuf_and_return;
 811003a:	bf00      	nop
 811003c:	e002      	b.n	8110044 <dhcp_recv+0x180>
    goto free_pbuf_and_return;
 811003e:	bf00      	nop
 8110040:	e000      	b.n	8110044 <dhcp_recv+0x180>
  }

free_pbuf_and_return:
 8110042:	bf00      	nop
  pbuf_free(p);
 8110044:	6878      	ldr	r0, [r7, #4]
 8110046:	f004 fb07 	bl	8114658 <pbuf_free>
}
 811004a:	bf00      	nop
 811004c:	3728      	adds	r7, #40	; 0x28
 811004e:	46bd      	mov	sp, r7
 8110050:	bd80      	pop	{r7, pc}
 8110052:	bf00      	nop
 8110054:	100054f0 	.word	0x100054f0
 8110058:	10004f5c 	.word	0x10004f5c
 811005c:	10004f34 	.word	0x10004f34

08110060 <dhcp_create_msg>:
 * @param dhcp dhcp control struct
 * @param message_type message type of the request
 */
static struct pbuf *
dhcp_create_msg(struct netif *netif, struct dhcp *dhcp, u8_t message_type, u16_t *options_out_len)
{
 8110060:	b580      	push	{r7, lr}
 8110062:	b088      	sub	sp, #32
 8110064:	af00      	add	r7, sp, #0
 8110066:	60f8      	str	r0, [r7, #12]
 8110068:	60b9      	str	r1, [r7, #8]
 811006a:	603b      	str	r3, [r7, #0]
 811006c:	4613      	mov	r3, r2
 811006e:	71fb      	strb	r3, [r7, #7]
  if (!xid_initialised) {
    xid = DHCP_GLOBAL_XID;
    xid_initialised = !xid_initialised;
  }
#endif
  LWIP_ERROR("dhcp_create_msg: netif != NULL", (netif != NULL), return NULL;);
 8110070:	68fb      	ldr	r3, [r7, #12]
 8110072:	2b00      	cmp	r3, #0
 8110074:	d108      	bne.n	8110088 <dhcp_create_msg+0x28>
 8110076:	4b5f      	ldr	r3, [pc, #380]	; (81101f4 <dhcp_create_msg+0x194>)
 8110078:	f240 7269 	movw	r2, #1897	; 0x769
 811007c:	495e      	ldr	r1, [pc, #376]	; (81101f8 <dhcp_create_msg+0x198>)
 811007e:	485f      	ldr	r0, [pc, #380]	; (81101fc <dhcp_create_msg+0x19c>)
 8110080:	f00b fbbe 	bl	811b800 <iprintf>
 8110084:	2300      	movs	r3, #0
 8110086:	e0b1      	b.n	81101ec <dhcp_create_msg+0x18c>
  LWIP_ERROR("dhcp_create_msg: dhcp != NULL", (dhcp != NULL), return NULL;);
 8110088:	68bb      	ldr	r3, [r7, #8]
 811008a:	2b00      	cmp	r3, #0
 811008c:	d108      	bne.n	81100a0 <dhcp_create_msg+0x40>
 811008e:	4b59      	ldr	r3, [pc, #356]	; (81101f4 <dhcp_create_msg+0x194>)
 8110090:	f240 726a 	movw	r2, #1898	; 0x76a
 8110094:	495a      	ldr	r1, [pc, #360]	; (8110200 <dhcp_create_msg+0x1a0>)
 8110096:	4859      	ldr	r0, [pc, #356]	; (81101fc <dhcp_create_msg+0x19c>)
 8110098:	f00b fbb2 	bl	811b800 <iprintf>
 811009c:	2300      	movs	r3, #0
 811009e:	e0a5      	b.n	81101ec <dhcp_create_msg+0x18c>
  p_out = pbuf_alloc(PBUF_TRANSPORT, sizeof(struct dhcp_msg), PBUF_RAM);
 81100a0:	f44f 7220 	mov.w	r2, #640	; 0x280
 81100a4:	f44f 719a 	mov.w	r1, #308	; 0x134
 81100a8:	2036      	movs	r0, #54	; 0x36
 81100aa:	f003 fff1 	bl	8114090 <pbuf_alloc>
 81100ae:	61b8      	str	r0, [r7, #24]
  if (p_out == NULL) {
 81100b0:	69bb      	ldr	r3, [r7, #24]
 81100b2:	2b00      	cmp	r3, #0
 81100b4:	d101      	bne.n	81100ba <dhcp_create_msg+0x5a>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS,
                ("dhcp_create_msg(): could not allocate pbuf\n"));
    return NULL;
 81100b6:	2300      	movs	r3, #0
 81100b8:	e098      	b.n	81101ec <dhcp_create_msg+0x18c>
  }
  LWIP_ASSERT("dhcp_create_msg: check that first pbuf can hold struct dhcp_msg",
 81100ba:	69bb      	ldr	r3, [r7, #24]
 81100bc:	895b      	ldrh	r3, [r3, #10]
 81100be:	f5b3 7f9a 	cmp.w	r3, #308	; 0x134
 81100c2:	d206      	bcs.n	81100d2 <dhcp_create_msg+0x72>
 81100c4:	4b4b      	ldr	r3, [pc, #300]	; (81101f4 <dhcp_create_msg+0x194>)
 81100c6:	f240 7271 	movw	r2, #1905	; 0x771
 81100ca:	494e      	ldr	r1, [pc, #312]	; (8110204 <dhcp_create_msg+0x1a4>)
 81100cc:	484b      	ldr	r0, [pc, #300]	; (81101fc <dhcp_create_msg+0x19c>)
 81100ce:	f00b fb97 	bl	811b800 <iprintf>
              (p_out->len >= sizeof(struct dhcp_msg)));

  /* DHCP_REQUEST should reuse 'xid' from DHCPOFFER */
  if ((message_type != DHCP_REQUEST) || (dhcp->state == DHCP_STATE_REBOOTING)) {
 81100d2:	79fb      	ldrb	r3, [r7, #7]
 81100d4:	2b03      	cmp	r3, #3
 81100d6:	d103      	bne.n	81100e0 <dhcp_create_msg+0x80>
 81100d8:	68bb      	ldr	r3, [r7, #8]
 81100da:	795b      	ldrb	r3, [r3, #5]
 81100dc:	2b03      	cmp	r3, #3
 81100de:	d10d      	bne.n	81100fc <dhcp_create_msg+0x9c>
    /* reuse transaction identifier in retransmissions */
    if (dhcp->tries == 0) {
 81100e0:	68bb      	ldr	r3, [r7, #8]
 81100e2:	799b      	ldrb	r3, [r3, #6]
 81100e4:	2b00      	cmp	r3, #0
 81100e6:	d105      	bne.n	81100f4 <dhcp_create_msg+0x94>
#if DHCP_CREATE_RAND_XID && defined(LWIP_RAND)
      xid = LWIP_RAND();
 81100e8:	f00b fa9c 	bl	811b624 <rand>
 81100ec:	4603      	mov	r3, r0
 81100ee:	461a      	mov	r2, r3
 81100f0:	4b45      	ldr	r3, [pc, #276]	; (8110208 <dhcp_create_msg+0x1a8>)
 81100f2:	601a      	str	r2, [r3, #0]
#else /* DHCP_CREATE_RAND_XID && defined(LWIP_RAND) */
      xid++;
#endif /* DHCP_CREATE_RAND_XID && defined(LWIP_RAND) */
    }
    dhcp->xid = xid;
 81100f4:	4b44      	ldr	r3, [pc, #272]	; (8110208 <dhcp_create_msg+0x1a8>)
 81100f6:	681a      	ldr	r2, [r3, #0]
 81100f8:	68bb      	ldr	r3, [r7, #8]
 81100fa:	601a      	str	r2, [r3, #0]
  }
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE,
              ("transaction id xid(%"X32_F")\n", xid));

  msg_out = (struct dhcp_msg *)p_out->payload;
 81100fc:	69bb      	ldr	r3, [r7, #24]
 81100fe:	685b      	ldr	r3, [r3, #4]
 8110100:	617b      	str	r3, [r7, #20]
  memset(msg_out, 0, sizeof(struct dhcp_msg));
 8110102:	f44f 729a 	mov.w	r2, #308	; 0x134
 8110106:	2100      	movs	r1, #0
 8110108:	6978      	ldr	r0, [r7, #20]
 811010a:	f00b fba3 	bl	811b854 <memset>

  msg_out->op = DHCP_BOOTREQUEST;
 811010e:	697b      	ldr	r3, [r7, #20]
 8110110:	2201      	movs	r2, #1
 8110112:	701a      	strb	r2, [r3, #0]
  /* @todo: make link layer independent */
  msg_out->htype = LWIP_IANA_HWTYPE_ETHERNET;
 8110114:	697b      	ldr	r3, [r7, #20]
 8110116:	2201      	movs	r2, #1
 8110118:	705a      	strb	r2, [r3, #1]
  msg_out->hlen = netif->hwaddr_len;
 811011a:	68fb      	ldr	r3, [r7, #12]
 811011c:	f893 2030 	ldrb.w	r2, [r3, #48]	; 0x30
 8110120:	697b      	ldr	r3, [r7, #20]
 8110122:	709a      	strb	r2, [r3, #2]
  msg_out->xid = lwip_htonl(dhcp->xid);
 8110124:	68bb      	ldr	r3, [r7, #8]
 8110126:	681b      	ldr	r3, [r3, #0]
 8110128:	4618      	mov	r0, r3
 811012a:	f7fe f9c7 	bl	810e4bc <lwip_htonl>
 811012e:	4602      	mov	r2, r0
 8110130:	697b      	ldr	r3, [r7, #20]
 8110132:	605a      	str	r2, [r3, #4]
  /* we don't need the broadcast flag since we can receive unicast traffic
     before being fully configured! */
  /* set ciaddr to netif->ip_addr based on message_type and state */
  if ((message_type == DHCP_INFORM) || (message_type == DHCP_DECLINE) || (message_type == DHCP_RELEASE) ||
 8110134:	79fb      	ldrb	r3, [r7, #7]
 8110136:	2b08      	cmp	r3, #8
 8110138:	d010      	beq.n	811015c <dhcp_create_msg+0xfc>
 811013a:	79fb      	ldrb	r3, [r7, #7]
 811013c:	2b04      	cmp	r3, #4
 811013e:	d00d      	beq.n	811015c <dhcp_create_msg+0xfc>
 8110140:	79fb      	ldrb	r3, [r7, #7]
 8110142:	2b07      	cmp	r3, #7
 8110144:	d00a      	beq.n	811015c <dhcp_create_msg+0xfc>
 8110146:	79fb      	ldrb	r3, [r7, #7]
 8110148:	2b03      	cmp	r3, #3
 811014a:	d10c      	bne.n	8110166 <dhcp_create_msg+0x106>
      ((message_type == DHCP_REQUEST) && /* DHCP_STATE_BOUND not used for sending! */
       ((dhcp->state == DHCP_STATE_RENEWING) || dhcp->state == DHCP_STATE_REBINDING))) {
 811014c:	68bb      	ldr	r3, [r7, #8]
 811014e:	795b      	ldrb	r3, [r3, #5]
      ((message_type == DHCP_REQUEST) && /* DHCP_STATE_BOUND not used for sending! */
 8110150:	2b05      	cmp	r3, #5
 8110152:	d003      	beq.n	811015c <dhcp_create_msg+0xfc>
       ((dhcp->state == DHCP_STATE_RENEWING) || dhcp->state == DHCP_STATE_REBINDING))) {
 8110154:	68bb      	ldr	r3, [r7, #8]
 8110156:	795b      	ldrb	r3, [r3, #5]
 8110158:	2b04      	cmp	r3, #4
 811015a:	d104      	bne.n	8110166 <dhcp_create_msg+0x106>
    ip4_addr_copy(msg_out->ciaddr, *netif_ip4_addr(netif));
 811015c:	68fb      	ldr	r3, [r7, #12]
 811015e:	3304      	adds	r3, #4
 8110160:	681a      	ldr	r2, [r3, #0]
 8110162:	697b      	ldr	r3, [r7, #20]
 8110164:	60da      	str	r2, [r3, #12]
  }
  for (i = 0; i < LWIP_MIN(DHCP_CHADDR_LEN, NETIF_MAX_HWADDR_LEN); i++) {
 8110166:	2300      	movs	r3, #0
 8110168:	83fb      	strh	r3, [r7, #30]
 811016a:	e00c      	b.n	8110186 <dhcp_create_msg+0x126>
    /* copy netif hardware address (padded with zeroes through memset already) */
    msg_out->chaddr[i] = netif->hwaddr[i];
 811016c:	8bfa      	ldrh	r2, [r7, #30]
 811016e:	8bfb      	ldrh	r3, [r7, #30]
 8110170:	68f9      	ldr	r1, [r7, #12]
 8110172:	440a      	add	r2, r1
 8110174:	f892 102a 	ldrb.w	r1, [r2, #42]	; 0x2a
 8110178:	697a      	ldr	r2, [r7, #20]
 811017a:	4413      	add	r3, r2
 811017c:	460a      	mov	r2, r1
 811017e:	771a      	strb	r2, [r3, #28]
  for (i = 0; i < LWIP_MIN(DHCP_CHADDR_LEN, NETIF_MAX_HWADDR_LEN); i++) {
 8110180:	8bfb      	ldrh	r3, [r7, #30]
 8110182:	3301      	adds	r3, #1
 8110184:	83fb      	strh	r3, [r7, #30]
 8110186:	8bfb      	ldrh	r3, [r7, #30]
 8110188:	2b05      	cmp	r3, #5
 811018a:	d9ef      	bls.n	811016c <dhcp_create_msg+0x10c>
  }
  msg_out->cookie = PP_HTONL(DHCP_MAGIC_COOKIE);
 811018c:	697b      	ldr	r3, [r7, #20]
 811018e:	2200      	movs	r2, #0
 8110190:	f042 0263 	orr.w	r2, r2, #99	; 0x63
 8110194:	f883 20ec 	strb.w	r2, [r3, #236]	; 0xec
 8110198:	2200      	movs	r2, #0
 811019a:	f062 027d 	orn	r2, r2, #125	; 0x7d
 811019e:	f883 20ed 	strb.w	r2, [r3, #237]	; 0xed
 81101a2:	2200      	movs	r2, #0
 81101a4:	f042 0253 	orr.w	r2, r2, #83	; 0x53
 81101a8:	f883 20ee 	strb.w	r2, [r3, #238]	; 0xee
 81101ac:	2200      	movs	r2, #0
 81101ae:	f042 0263 	orr.w	r2, r2, #99	; 0x63
 81101b2:	f883 20ef 	strb.w	r2, [r3, #239]	; 0xef
  /* Add option MESSAGE_TYPE */
  options_out_len_loc = dhcp_option(0, msg_out->options, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
 81101b6:	697b      	ldr	r3, [r7, #20]
 81101b8:	f103 01f0 	add.w	r1, r3, #240	; 0xf0
 81101bc:	2301      	movs	r3, #1
 81101be:	2235      	movs	r2, #53	; 0x35
 81101c0:	2000      	movs	r0, #0
 81101c2:	f7ff faab 	bl	810f71c <dhcp_option>
 81101c6:	4603      	mov	r3, r0
 81101c8:	827b      	strh	r3, [r7, #18]
  options_out_len_loc = dhcp_option_byte(options_out_len_loc, msg_out->options, message_type);
 81101ca:	697b      	ldr	r3, [r7, #20]
 81101cc:	f103 01f0 	add.w	r1, r3, #240	; 0xf0
 81101d0:	79fa      	ldrb	r2, [r7, #7]
 81101d2:	8a7b      	ldrh	r3, [r7, #18]
 81101d4:	4618      	mov	r0, r3
 81101d6:	f7ff fad5 	bl	810f784 <dhcp_option_byte>
 81101da:	4603      	mov	r3, r0
 81101dc:	827b      	strh	r3, [r7, #18]
  if (options_out_len) {
 81101de:	683b      	ldr	r3, [r7, #0]
 81101e0:	2b00      	cmp	r3, #0
 81101e2:	d002      	beq.n	81101ea <dhcp_create_msg+0x18a>
    *options_out_len = options_out_len_loc;
 81101e4:	683b      	ldr	r3, [r7, #0]
 81101e6:	8a7a      	ldrh	r2, [r7, #18]
 81101e8:	801a      	strh	r2, [r3, #0]
  }
  return p_out;
 81101ea:	69bb      	ldr	r3, [r7, #24]
}
 81101ec:	4618      	mov	r0, r3
 81101ee:	3720      	adds	r7, #32
 81101f0:	46bd      	mov	sp, r7
 81101f2:	bd80      	pop	{r7, pc}
 81101f4:	0811c788 	.word	0x0811c788
 81101f8:	0811cae8 	.word	0x0811cae8
 81101fc:	0811c818 	.word	0x0811c818
 8110200:	0811cb08 	.word	0x0811cb08
 8110204:	0811cb28 	.word	0x0811cb28
 8110208:	10004f70 	.word	0x10004f70

0811020c <dhcp_option_trailer>:
 * Adds the END option to the DHCP message, and if
 * necessary, up to three padding bytes.
 */
static void
dhcp_option_trailer(u16_t options_out_len, u8_t *options, struct pbuf *p_out)
{
 811020c:	b580      	push	{r7, lr}
 811020e:	b084      	sub	sp, #16
 8110210:	af00      	add	r7, sp, #0
 8110212:	4603      	mov	r3, r0
 8110214:	60b9      	str	r1, [r7, #8]
 8110216:	607a      	str	r2, [r7, #4]
 8110218:	81fb      	strh	r3, [r7, #14]
  options[options_out_len++] = DHCP_OPTION_END;
 811021a:	89fb      	ldrh	r3, [r7, #14]
 811021c:	1c5a      	adds	r2, r3, #1
 811021e:	81fa      	strh	r2, [r7, #14]
 8110220:	461a      	mov	r2, r3
 8110222:	68bb      	ldr	r3, [r7, #8]
 8110224:	4413      	add	r3, r2
 8110226:	22ff      	movs	r2, #255	; 0xff
 8110228:	701a      	strb	r2, [r3, #0]
  /* packet is too small, or not 4 byte aligned? */
  while (((options_out_len < DHCP_MIN_OPTIONS_LEN) || (options_out_len & 3)) &&
 811022a:	e007      	b.n	811023c <dhcp_option_trailer+0x30>
         (options_out_len < DHCP_OPTIONS_LEN)) {
    /* add a fill/padding byte */
    options[options_out_len++] = 0;
 811022c:	89fb      	ldrh	r3, [r7, #14]
 811022e:	1c5a      	adds	r2, r3, #1
 8110230:	81fa      	strh	r2, [r7, #14]
 8110232:	461a      	mov	r2, r3
 8110234:	68bb      	ldr	r3, [r7, #8]
 8110236:	4413      	add	r3, r2
 8110238:	2200      	movs	r2, #0
 811023a:	701a      	strb	r2, [r3, #0]
  while (((options_out_len < DHCP_MIN_OPTIONS_LEN) || (options_out_len & 3)) &&
 811023c:	89fb      	ldrh	r3, [r7, #14]
 811023e:	2b43      	cmp	r3, #67	; 0x43
 8110240:	d904      	bls.n	811024c <dhcp_option_trailer+0x40>
 8110242:	89fb      	ldrh	r3, [r7, #14]
 8110244:	f003 0303 	and.w	r3, r3, #3
 8110248:	2b00      	cmp	r3, #0
 811024a:	d002      	beq.n	8110252 <dhcp_option_trailer+0x46>
 811024c:	89fb      	ldrh	r3, [r7, #14]
 811024e:	2b43      	cmp	r3, #67	; 0x43
 8110250:	d9ec      	bls.n	811022c <dhcp_option_trailer+0x20>
  }
  /* shrink the pbuf to the actual content length */
  pbuf_realloc(p_out, (u16_t)(sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + options_out_len));
 8110252:	89fb      	ldrh	r3, [r7, #14]
 8110254:	33f0      	adds	r3, #240	; 0xf0
 8110256:	b29b      	uxth	r3, r3
 8110258:	4619      	mov	r1, r3
 811025a:	6878      	ldr	r0, [r7, #4]
 811025c:	f004 f876 	bl	811434c <pbuf_realloc>
}
 8110260:	bf00      	nop
 8110262:	3710      	adds	r7, #16
 8110264:	46bd      	mov	sp, r7
 8110266:	bd80      	pop	{r7, pc}

08110268 <dhcp_supplied_address>:
 * @return 1 if DHCP supplied netif->ip_addr (states BOUND or RENEWING),
 *         0 otherwise
 */
u8_t
dhcp_supplied_address(const struct netif *netif)
{
 8110268:	b480      	push	{r7}
 811026a:	b085      	sub	sp, #20
 811026c:	af00      	add	r7, sp, #0
 811026e:	6078      	str	r0, [r7, #4]
  if ((netif != NULL) && (netif_dhcp_data(netif) != NULL)) {
 8110270:	687b      	ldr	r3, [r7, #4]
 8110272:	2b00      	cmp	r3, #0
 8110274:	d017      	beq.n	81102a6 <dhcp_supplied_address+0x3e>
 8110276:	687b      	ldr	r3, [r7, #4]
 8110278:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 811027a:	2b00      	cmp	r3, #0
 811027c:	d013      	beq.n	81102a6 <dhcp_supplied_address+0x3e>
    struct dhcp *dhcp = netif_dhcp_data(netif);
 811027e:	687b      	ldr	r3, [r7, #4]
 8110280:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8110282:	60fb      	str	r3, [r7, #12]
    return (dhcp->state == DHCP_STATE_BOUND) || (dhcp->state == DHCP_STATE_RENEWING) ||
 8110284:	68fb      	ldr	r3, [r7, #12]
 8110286:	795b      	ldrb	r3, [r3, #5]
 8110288:	2b0a      	cmp	r3, #10
 811028a:	d007      	beq.n	811029c <dhcp_supplied_address+0x34>
 811028c:	68fb      	ldr	r3, [r7, #12]
 811028e:	795b      	ldrb	r3, [r3, #5]
 8110290:	2b05      	cmp	r3, #5
 8110292:	d003      	beq.n	811029c <dhcp_supplied_address+0x34>
           (dhcp->state == DHCP_STATE_REBINDING);
 8110294:	68fb      	ldr	r3, [r7, #12]
 8110296:	795b      	ldrb	r3, [r3, #5]
    return (dhcp->state == DHCP_STATE_BOUND) || (dhcp->state == DHCP_STATE_RENEWING) ||
 8110298:	2b04      	cmp	r3, #4
 811029a:	d101      	bne.n	81102a0 <dhcp_supplied_address+0x38>
 811029c:	2301      	movs	r3, #1
 811029e:	e000      	b.n	81102a2 <dhcp_supplied_address+0x3a>
 81102a0:	2300      	movs	r3, #0
 81102a2:	b2db      	uxtb	r3, r3
 81102a4:	e000      	b.n	81102a8 <dhcp_supplied_address+0x40>
  }
  return 0;
 81102a6:	2300      	movs	r3, #0
}
 81102a8:	4618      	mov	r0, r3
 81102aa:	3714      	adds	r7, #20
 81102ac:	46bd      	mov	sp, r7
 81102ae:	f85d 7b04 	ldr.w	r7, [sp], #4
 81102b2:	4770      	bx	lr

081102b4 <dns_init>:
 * Initialize the resolver: set up the UDP pcb and configure the default server
 * (if DNS_SERVER_ADDRESS is set).
 */
void
dns_init(void)
{
 81102b4:	b480      	push	{r7}
 81102b6:	af00      	add	r7, sp, #0
#endif

#if DNS_LOCAL_HOSTLIST
  dns_init_local();
#endif
}
 81102b8:	bf00      	nop
 81102ba:	46bd      	mov	sp, r7
 81102bc:	f85d 7b04 	ldr.w	r7, [sp], #4
 81102c0:	4770      	bx	lr
	...

081102c4 <dns_setserver>:
 * @param numdns the index of the DNS server to set must be < DNS_MAX_SERVERS
 * @param dnsserver IP address of the DNS server to set
 */
void
dns_setserver(u8_t numdns, const ip_addr_t *dnsserver)
{
 81102c4:	b480      	push	{r7}
 81102c6:	b083      	sub	sp, #12
 81102c8:	af00      	add	r7, sp, #0
 81102ca:	4603      	mov	r3, r0
 81102cc:	6039      	str	r1, [r7, #0]
 81102ce:	71fb      	strb	r3, [r7, #7]
  if (numdns < DNS_MAX_SERVERS) {
 81102d0:	79fb      	ldrb	r3, [r7, #7]
 81102d2:	2b01      	cmp	r3, #1
 81102d4:	d80f      	bhi.n	81102f6 <dns_setserver+0x32>
    if (dnsserver != NULL) {
 81102d6:	683b      	ldr	r3, [r7, #0]
 81102d8:	2b00      	cmp	r3, #0
 81102da:	d006      	beq.n	81102ea <dns_setserver+0x26>
      dns_servers[numdns] = (*dnsserver);
 81102dc:	79fb      	ldrb	r3, [r7, #7]
 81102de:	4909      	ldr	r1, [pc, #36]	; (8110304 <dns_setserver+0x40>)
 81102e0:	683a      	ldr	r2, [r7, #0]
 81102e2:	6812      	ldr	r2, [r2, #0]
 81102e4:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    } else {
      dns_servers[numdns] = *IP_ADDR_ANY;
    }
  }
}
 81102e8:	e005      	b.n	81102f6 <dns_setserver+0x32>
      dns_servers[numdns] = *IP_ADDR_ANY;
 81102ea:	79fb      	ldrb	r3, [r7, #7]
 81102ec:	4905      	ldr	r1, [pc, #20]	; (8110304 <dns_setserver+0x40>)
 81102ee:	4a06      	ldr	r2, [pc, #24]	; (8110308 <dns_setserver+0x44>)
 81102f0:	6812      	ldr	r2, [r2, #0]
 81102f2:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
 81102f6:	bf00      	nop
 81102f8:	370c      	adds	r7, #12
 81102fa:	46bd      	mov	sp, r7
 81102fc:	f85d 7b04 	ldr.w	r7, [sp], #4
 8110300:	4770      	bx	lr
 8110302:	bf00      	nop
 8110304:	100053f4 	.word	0x100053f4
 8110308:	0811f934 	.word	0x0811f934

0811030c <dns_tmr>:
 * The DNS resolver client timer - handle retries and timeouts and should
 * be called every DNS_TMR_INTERVAL milliseconds (every second by default).
 */
void
dns_tmr(void)
{
 811030c:	b580      	push	{r7, lr}
 811030e:	af00      	add	r7, sp, #0
  LWIP_DEBUGF(DNS_DEBUG, ("dns_tmr: dns_check_entries\n"));
  dns_check_entries();
 8110310:	f000 faa8 	bl	8110864 <dns_check_entries>
}
 8110314:	bf00      	nop
 8110316:	bd80      	pop	{r7, pc}

08110318 <dns_send>:
 * @param idx the DNS table entry index for which to send a request
 * @return ERR_OK if packet is sent; an err_t indicating the problem otherwise
 */
static err_t
dns_send(u8_t idx)
{
 8110318:	b580      	push	{r7, lr}
 811031a:	b090      	sub	sp, #64	; 0x40
 811031c:	af00      	add	r7, sp, #0
 811031e:	4603      	mov	r3, r0
 8110320:	71fb      	strb	r3, [r7, #7]
  struct pbuf *p;
  u16_t query_idx, copy_len;
  const char *hostname, *hostname_part;
  u8_t n;
  u8_t pcb_idx;
  struct dns_table_entry *entry = &dns_table[idx];
 8110322:	79fa      	ldrb	r2, [r7, #7]
 8110324:	4613      	mov	r3, r2
 8110326:	011b      	lsls	r3, r3, #4
 8110328:	4413      	add	r3, r2
 811032a:	011b      	lsls	r3, r3, #4
 811032c:	4a6c      	ldr	r2, [pc, #432]	; (81104e0 <dns_send+0x1c8>)
 811032e:	4413      	add	r3, r2
 8110330:	633b      	str	r3, [r7, #48]	; 0x30

  LWIP_DEBUGF(DNS_DEBUG, ("dns_send: dns_servers[%"U16_F"] \"%s\": request\n",
                          (u16_t)(entry->server_idx), entry->name));
  LWIP_ASSERT("dns server out of array", entry->server_idx < DNS_MAX_SERVERS);
 8110332:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8110334:	7adb      	ldrb	r3, [r3, #11]
 8110336:	2b01      	cmp	r3, #1
 8110338:	d906      	bls.n	8110348 <dns_send+0x30>
 811033a:	4b6a      	ldr	r3, [pc, #424]	; (81104e4 <dns_send+0x1cc>)
 811033c:	f240 22fa 	movw	r2, #762	; 0x2fa
 8110340:	4969      	ldr	r1, [pc, #420]	; (81104e8 <dns_send+0x1d0>)
 8110342:	486a      	ldr	r0, [pc, #424]	; (81104ec <dns_send+0x1d4>)
 8110344:	f00b fa5c 	bl	811b800 <iprintf>
  if (ip_addr_isany_val(dns_servers[entry->server_idx])
 8110348:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 811034a:	7adb      	ldrb	r3, [r3, #11]
 811034c:	461a      	mov	r2, r3
 811034e:	4b68      	ldr	r3, [pc, #416]	; (81104f0 <dns_send+0x1d8>)
 8110350:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8110354:	2b00      	cmp	r3, #0
 8110356:	d109      	bne.n	811036c <dns_send+0x54>
      && !entry->is_mdns
#endif
     ) {
    /* DNS server not valid anymore, e.g. PPP netif has been shut down */
    /* call specified callback function if provided */
    dns_call_found(idx, NULL);
 8110358:	79fb      	ldrb	r3, [r7, #7]
 811035a:	2100      	movs	r1, #0
 811035c:	4618      	mov	r0, r3
 811035e:	f000 f8cb 	bl	81104f8 <dns_call_found>
    /* flush this entry */
    entry->state = DNS_STATE_UNUSED;
 8110362:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8110364:	2200      	movs	r2, #0
 8110366:	729a      	strb	r2, [r3, #10]
    return ERR_OK;
 8110368:	2300      	movs	r3, #0
 811036a:	e0b4      	b.n	81104d6 <dns_send+0x1be>
  }

  /* if here, we have either a new query or a retry on a previous query to process */
  p = pbuf_alloc(PBUF_TRANSPORT, (u16_t)(SIZEOF_DNS_HDR + strlen(entry->name) + 2 +
 811036c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 811036e:	3310      	adds	r3, #16
 8110370:	4618      	mov	r0, r3
 8110372:	f7ef ffb5 	bl	81002e0 <strlen>
 8110376:	4603      	mov	r3, r0
 8110378:	b29b      	uxth	r3, r3
 811037a:	3312      	adds	r3, #18
 811037c:	b29b      	uxth	r3, r3
 811037e:	f44f 7220 	mov.w	r2, #640	; 0x280
 8110382:	4619      	mov	r1, r3
 8110384:	2036      	movs	r0, #54	; 0x36
 8110386:	f003 fe83 	bl	8114090 <pbuf_alloc>
 811038a:	62f8      	str	r0, [r7, #44]	; 0x2c
                                         SIZEOF_DNS_QUERY), PBUF_RAM);
  if (p != NULL) {
 811038c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 811038e:	2b00      	cmp	r3, #0
 8110390:	f000 8095 	beq.w	81104be <dns_send+0x1a6>
    const ip_addr_t *dst;
    u16_t dst_port;
    /* fill dns header */
    memset(&hdr, 0, SIZEOF_DNS_HDR);
 8110394:	f107 0310 	add.w	r3, r7, #16
 8110398:	220c      	movs	r2, #12
 811039a:	2100      	movs	r1, #0
 811039c:	4618      	mov	r0, r3
 811039e:	f00b fa59 	bl	811b854 <memset>
    hdr.id = lwip_htons(entry->txid);
 81103a2:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 81103a4:	891b      	ldrh	r3, [r3, #8]
 81103a6:	4618      	mov	r0, r3
 81103a8:	f7fe f873 	bl	810e492 <lwip_htons>
 81103ac:	4603      	mov	r3, r0
 81103ae:	823b      	strh	r3, [r7, #16]
    hdr.flags1 = DNS_FLAG1_RD;
 81103b0:	2301      	movs	r3, #1
 81103b2:	74bb      	strb	r3, [r7, #18]
    hdr.numquestions = PP_HTONS(1);
 81103b4:	f44f 7380 	mov.w	r3, #256	; 0x100
 81103b8:	82bb      	strh	r3, [r7, #20]
    pbuf_take(p, &hdr, SIZEOF_DNS_HDR);
 81103ba:	f107 0310 	add.w	r3, r7, #16
 81103be:	220c      	movs	r2, #12
 81103c0:	4619      	mov	r1, r3
 81103c2:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 81103c4:	f004 fbf0 	bl	8114ba8 <pbuf_take>
    hostname = entry->name;
 81103c8:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 81103ca:	3310      	adds	r3, #16
 81103cc:	63bb      	str	r3, [r7, #56]	; 0x38
    --hostname;
 81103ce:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 81103d0:	3b01      	subs	r3, #1
 81103d2:	63bb      	str	r3, [r7, #56]	; 0x38

    /* convert hostname into suitable query format. */
    query_idx = SIZEOF_DNS_HDR;
 81103d4:	230c      	movs	r3, #12
 81103d6:	87bb      	strh	r3, [r7, #60]	; 0x3c
    do {
      ++hostname;
 81103d8:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 81103da:	3301      	adds	r3, #1
 81103dc:	63bb      	str	r3, [r7, #56]	; 0x38
      hostname_part = hostname;
 81103de:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 81103e0:	62bb      	str	r3, [r7, #40]	; 0x28
      for (n = 0; *hostname != '.' && *hostname != 0; ++hostname) {
 81103e2:	2300      	movs	r3, #0
 81103e4:	f887 3037 	strb.w	r3, [r7, #55]	; 0x37
 81103e8:	e007      	b.n	81103fa <dns_send+0xe2>
        ++n;
 81103ea:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
 81103ee:	3301      	adds	r3, #1
 81103f0:	f887 3037 	strb.w	r3, [r7, #55]	; 0x37
      for (n = 0; *hostname != '.' && *hostname != 0; ++hostname) {
 81103f4:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 81103f6:	3301      	adds	r3, #1
 81103f8:	63bb      	str	r3, [r7, #56]	; 0x38
 81103fa:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 81103fc:	781b      	ldrb	r3, [r3, #0]
 81103fe:	2b2e      	cmp	r3, #46	; 0x2e
 8110400:	d003      	beq.n	811040a <dns_send+0xf2>
 8110402:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8110404:	781b      	ldrb	r3, [r3, #0]
 8110406:	2b00      	cmp	r3, #0
 8110408:	d1ef      	bne.n	81103ea <dns_send+0xd2>
      }
      copy_len = (u16_t)(hostname - hostname_part);
 811040a:	6bba      	ldr	r2, [r7, #56]	; 0x38
 811040c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 811040e:	1ad3      	subs	r3, r2, r3
 8110410:	84fb      	strh	r3, [r7, #38]	; 0x26
      if (query_idx + n + 1 > 0xFFFF) {
 8110412:	8fba      	ldrh	r2, [r7, #60]	; 0x3c
 8110414:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
 8110418:	4413      	add	r3, r2
 811041a:	f64f 72fe 	movw	r2, #65534	; 0xfffe
 811041e:	4293      	cmp	r3, r2
 8110420:	dc53      	bgt.n	81104ca <dns_send+0x1b2>
        /* u16_t overflow */
        goto overflow_return;
      }
      pbuf_put_at(p, query_idx, n);
 8110422:	f897 2037 	ldrb.w	r2, [r7, #55]	; 0x37
 8110426:	8fbb      	ldrh	r3, [r7, #60]	; 0x3c
 8110428:	4619      	mov	r1, r3
 811042a:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 811042c:	f004 fcea 	bl	8114e04 <pbuf_put_at>
      pbuf_take_at(p, hostname_part, copy_len, (u16_t)(query_idx + 1));
 8110430:	8fbb      	ldrh	r3, [r7, #60]	; 0x3c
 8110432:	3301      	adds	r3, #1
 8110434:	b29b      	uxth	r3, r3
 8110436:	8cfa      	ldrh	r2, [r7, #38]	; 0x26
 8110438:	6ab9      	ldr	r1, [r7, #40]	; 0x28
 811043a:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 811043c:	f004 fc46 	bl	8114ccc <pbuf_take_at>
      query_idx = (u16_t)(query_idx + n + 1);
 8110440:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
 8110444:	b29a      	uxth	r2, r3
 8110446:	8fbb      	ldrh	r3, [r7, #60]	; 0x3c
 8110448:	4413      	add	r3, r2
 811044a:	b29b      	uxth	r3, r3
 811044c:	3301      	adds	r3, #1
 811044e:	87bb      	strh	r3, [r7, #60]	; 0x3c
    } while (*hostname != 0);
 8110450:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8110452:	781b      	ldrb	r3, [r3, #0]
 8110454:	2b00      	cmp	r3, #0
 8110456:	d1bf      	bne.n	81103d8 <dns_send+0xc0>
    pbuf_put_at(p, query_idx, 0);
 8110458:	8fbb      	ldrh	r3, [r7, #60]	; 0x3c
 811045a:	2200      	movs	r2, #0
 811045c:	4619      	mov	r1, r3
 811045e:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 8110460:	f004 fcd0 	bl	8114e04 <pbuf_put_at>
    query_idx++;
 8110464:	8fbb      	ldrh	r3, [r7, #60]	; 0x3c
 8110466:	3301      	adds	r3, #1
 8110468:	87bb      	strh	r3, [r7, #60]	; 0x3c

    /* fill dns query */
    if (LWIP_DNS_ADDRTYPE_IS_IPV6(entry->reqaddrtype)) {
      qry.type = PP_HTONS(DNS_RRTYPE_AAAA);
    } else {
      qry.type = PP_HTONS(DNS_RRTYPE_A);
 811046a:	f44f 7380 	mov.w	r3, #256	; 0x100
 811046e:	81bb      	strh	r3, [r7, #12]
    }
    qry.cls = PP_HTONS(DNS_RRCLASS_IN);
 8110470:	f44f 7380 	mov.w	r3, #256	; 0x100
 8110474:	81fb      	strh	r3, [r7, #14]
    pbuf_take_at(p, &qry, SIZEOF_DNS_QUERY, query_idx);
 8110476:	8fbb      	ldrh	r3, [r7, #60]	; 0x3c
 8110478:	f107 010c 	add.w	r1, r7, #12
 811047c:	2204      	movs	r2, #4
 811047e:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 8110480:	f004 fc24 	bl	8114ccc <pbuf_take_at>

#if ((LWIP_DNS_SECURE & LWIP_DNS_SECURE_RAND_SRC_PORT) != 0)
    pcb_idx = entry->pcb_idx;
 8110484:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8110486:	7bdb      	ldrb	r3, [r3, #15]
 8110488:	f887 3025 	strb.w	r3, [r7, #37]	; 0x25
      }
#endif
    } else
#endif /* LWIP_DNS_SUPPORT_MDNS_QUERIES */
    {
      dst_port = DNS_SERVER_PORT;
 811048c:	2335      	movs	r3, #53	; 0x35
 811048e:	847b      	strh	r3, [r7, #34]	; 0x22
      dst = &dns_servers[entry->server_idx];
 8110490:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8110492:	7adb      	ldrb	r3, [r3, #11]
 8110494:	009b      	lsls	r3, r3, #2
 8110496:	4a16      	ldr	r2, [pc, #88]	; (81104f0 <dns_send+0x1d8>)
 8110498:	4413      	add	r3, r2
 811049a:	61fb      	str	r3, [r7, #28]
    }
    err = udp_sendto(dns_pcbs[pcb_idx], p, dst, dst_port);
 811049c:	f897 3025 	ldrb.w	r3, [r7, #37]	; 0x25
 81104a0:	4a14      	ldr	r2, [pc, #80]	; (81104f4 <dns_send+0x1dc>)
 81104a2:	f852 0023 	ldr.w	r0, [r2, r3, lsl #2]
 81104a6:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
 81104a8:	69fa      	ldr	r2, [r7, #28]
 81104aa:	6af9      	ldr	r1, [r7, #44]	; 0x2c
 81104ac:	f00a f8f2 	bl	811a694 <udp_sendto>
 81104b0:	4603      	mov	r3, r0
 81104b2:	f887 303f 	strb.w	r3, [r7, #63]	; 0x3f

    /* free pbuf */
    pbuf_free(p);
 81104b6:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 81104b8:	f004 f8ce 	bl	8114658 <pbuf_free>
 81104bc:	e002      	b.n	81104c4 <dns_send+0x1ac>
  } else {
    err = ERR_MEM;
 81104be:	23ff      	movs	r3, #255	; 0xff
 81104c0:	f887 303f 	strb.w	r3, [r7, #63]	; 0x3f
  }

  return err;
 81104c4:	f997 303f 	ldrsb.w	r3, [r7, #63]	; 0x3f
 81104c8:	e005      	b.n	81104d6 <dns_send+0x1be>
        goto overflow_return;
 81104ca:	bf00      	nop
overflow_return:
  pbuf_free(p);
 81104cc:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 81104ce:	f004 f8c3 	bl	8114658 <pbuf_free>
  return ERR_VAL;
 81104d2:	f06f 0305 	mvn.w	r3, #5
}
 81104d6:	4618      	mov	r0, r3
 81104d8:	3740      	adds	r7, #64	; 0x40
 81104da:	46bd      	mov	sp, r7
 81104dc:	bd80      	pop	{r7, pc}
 81104de:	bf00      	nop
 81104e0:	10004f84 	.word	0x10004f84
 81104e4:	0811cb68 	.word	0x0811cb68
 81104e8:	0811cbcc 	.word	0x0811cbcc
 81104ec:	0811cbe4 	.word	0x0811cbe4
 81104f0:	100053f4 	.word	0x100053f4
 81104f4:	10004f74 	.word	0x10004f74

081104f8 <dns_call_found>:
 * @param idx dns table index of the entry that is resolved or removed
 * @param addr IP address for the hostname (or NULL on error or memory shortage)
 */
static void
dns_call_found(u8_t idx, ip_addr_t *addr)
{
 81104f8:	b590      	push	{r4, r7, lr}
 81104fa:	b085      	sub	sp, #20
 81104fc:	af00      	add	r7, sp, #0
 81104fe:	4603      	mov	r3, r0
 8110500:	6039      	str	r1, [r7, #0]
 8110502:	71fb      	strb	r3, [r7, #7]
    }
  }
#endif /* LWIP_IPV4 && LWIP_IPV6 */

#if ((LWIP_DNS_SECURE & LWIP_DNS_SECURE_NO_MULTIPLE_OUTSTANDING) != 0)
  for (i = 0; i < DNS_MAX_REQUESTS; i++) {
 8110504:	2300      	movs	r3, #0
 8110506:	73fb      	strb	r3, [r7, #15]
 8110508:	e03d      	b.n	8110586 <dns_call_found+0x8e>
    if (dns_requests[i].found && (dns_requests[i].dns_table_idx == idx)) {
 811050a:	7bfa      	ldrb	r2, [r7, #15]
 811050c:	4957      	ldr	r1, [pc, #348]	; (811066c <dns_call_found+0x174>)
 811050e:	4613      	mov	r3, r2
 8110510:	005b      	lsls	r3, r3, #1
 8110512:	4413      	add	r3, r2
 8110514:	009b      	lsls	r3, r3, #2
 8110516:	440b      	add	r3, r1
 8110518:	681b      	ldr	r3, [r3, #0]
 811051a:	2b00      	cmp	r3, #0
 811051c:	d030      	beq.n	8110580 <dns_call_found+0x88>
 811051e:	7bfa      	ldrb	r2, [r7, #15]
 8110520:	4952      	ldr	r1, [pc, #328]	; (811066c <dns_call_found+0x174>)
 8110522:	4613      	mov	r3, r2
 8110524:	005b      	lsls	r3, r3, #1
 8110526:	4413      	add	r3, r2
 8110528:	009b      	lsls	r3, r3, #2
 811052a:	440b      	add	r3, r1
 811052c:	3308      	adds	r3, #8
 811052e:	781b      	ldrb	r3, [r3, #0]
 8110530:	79fa      	ldrb	r2, [r7, #7]
 8110532:	429a      	cmp	r2, r3
 8110534:	d124      	bne.n	8110580 <dns_call_found+0x88>
      (*dns_requests[i].found)(dns_table[idx].name, addr, dns_requests[i].arg);
 8110536:	7bfa      	ldrb	r2, [r7, #15]
 8110538:	494c      	ldr	r1, [pc, #304]	; (811066c <dns_call_found+0x174>)
 811053a:	4613      	mov	r3, r2
 811053c:	005b      	lsls	r3, r3, #1
 811053e:	4413      	add	r3, r2
 8110540:	009b      	lsls	r3, r3, #2
 8110542:	440b      	add	r3, r1
 8110544:	681c      	ldr	r4, [r3, #0]
 8110546:	79fa      	ldrb	r2, [r7, #7]
 8110548:	4613      	mov	r3, r2
 811054a:	011b      	lsls	r3, r3, #4
 811054c:	4413      	add	r3, r2
 811054e:	011b      	lsls	r3, r3, #4
 8110550:	3310      	adds	r3, #16
 8110552:	4a47      	ldr	r2, [pc, #284]	; (8110670 <dns_call_found+0x178>)
 8110554:	1898      	adds	r0, r3, r2
 8110556:	7bfa      	ldrb	r2, [r7, #15]
 8110558:	4944      	ldr	r1, [pc, #272]	; (811066c <dns_call_found+0x174>)
 811055a:	4613      	mov	r3, r2
 811055c:	005b      	lsls	r3, r3, #1
 811055e:	4413      	add	r3, r2
 8110560:	009b      	lsls	r3, r3, #2
 8110562:	440b      	add	r3, r1
 8110564:	3304      	adds	r3, #4
 8110566:	681b      	ldr	r3, [r3, #0]
 8110568:	461a      	mov	r2, r3
 811056a:	6839      	ldr	r1, [r7, #0]
 811056c:	47a0      	blx	r4
      /* flush this entry */
      dns_requests[i].found = NULL;
 811056e:	7bfa      	ldrb	r2, [r7, #15]
 8110570:	493e      	ldr	r1, [pc, #248]	; (811066c <dns_call_found+0x174>)
 8110572:	4613      	mov	r3, r2
 8110574:	005b      	lsls	r3, r3, #1
 8110576:	4413      	add	r3, r2
 8110578:	009b      	lsls	r3, r3, #2
 811057a:	440b      	add	r3, r1
 811057c:	2200      	movs	r2, #0
 811057e:	601a      	str	r2, [r3, #0]
  for (i = 0; i < DNS_MAX_REQUESTS; i++) {
 8110580:	7bfb      	ldrb	r3, [r7, #15]
 8110582:	3301      	adds	r3, #1
 8110584:	73fb      	strb	r3, [r7, #15]
 8110586:	7bfb      	ldrb	r3, [r7, #15]
 8110588:	2b03      	cmp	r3, #3
 811058a:	d9be      	bls.n	811050a <dns_call_found+0x12>
  }
  dns_requests[idx].found = NULL;
#endif
#if ((LWIP_DNS_SECURE & LWIP_DNS_SECURE_RAND_SRC_PORT) != 0)
  /* close the pcb used unless other request are using it */
  for (i = 0; i < DNS_MAX_REQUESTS; i++) {
 811058c:	2300      	movs	r3, #0
 811058e:	73fb      	strb	r3, [r7, #15]
 8110590:	e031      	b.n	81105f6 <dns_call_found+0xfe>
    if (i == idx) {
 8110592:	7bfa      	ldrb	r2, [r7, #15]
 8110594:	79fb      	ldrb	r3, [r7, #7]
 8110596:	429a      	cmp	r2, r3
 8110598:	d029      	beq.n	81105ee <dns_call_found+0xf6>
      continue; /* only check other requests */
    }
    if (dns_table[i].state == DNS_STATE_ASKING) {
 811059a:	7bfa      	ldrb	r2, [r7, #15]
 811059c:	4934      	ldr	r1, [pc, #208]	; (8110670 <dns_call_found+0x178>)
 811059e:	4613      	mov	r3, r2
 81105a0:	011b      	lsls	r3, r3, #4
 81105a2:	4413      	add	r3, r2
 81105a4:	011b      	lsls	r3, r3, #4
 81105a6:	440b      	add	r3, r1
 81105a8:	330a      	adds	r3, #10
 81105aa:	781b      	ldrb	r3, [r3, #0]
 81105ac:	2b02      	cmp	r3, #2
 81105ae:	d11f      	bne.n	81105f0 <dns_call_found+0xf8>
      if (dns_table[i].pcb_idx == dns_table[idx].pcb_idx) {
 81105b0:	7bfa      	ldrb	r2, [r7, #15]
 81105b2:	492f      	ldr	r1, [pc, #188]	; (8110670 <dns_call_found+0x178>)
 81105b4:	4613      	mov	r3, r2
 81105b6:	011b      	lsls	r3, r3, #4
 81105b8:	4413      	add	r3, r2
 81105ba:	011b      	lsls	r3, r3, #4
 81105bc:	440b      	add	r3, r1
 81105be:	330f      	adds	r3, #15
 81105c0:	7819      	ldrb	r1, [r3, #0]
 81105c2:	79fa      	ldrb	r2, [r7, #7]
 81105c4:	482a      	ldr	r0, [pc, #168]	; (8110670 <dns_call_found+0x178>)
 81105c6:	4613      	mov	r3, r2
 81105c8:	011b      	lsls	r3, r3, #4
 81105ca:	4413      	add	r3, r2
 81105cc:	011b      	lsls	r3, r3, #4
 81105ce:	4403      	add	r3, r0
 81105d0:	330f      	adds	r3, #15
 81105d2:	781b      	ldrb	r3, [r3, #0]
 81105d4:	4299      	cmp	r1, r3
 81105d6:	d10b      	bne.n	81105f0 <dns_call_found+0xf8>
        /* another request is still using the same pcb */
        dns_table[idx].pcb_idx = DNS_MAX_SOURCE_PORTS;
 81105d8:	79fa      	ldrb	r2, [r7, #7]
 81105da:	4925      	ldr	r1, [pc, #148]	; (8110670 <dns_call_found+0x178>)
 81105dc:	4613      	mov	r3, r2
 81105de:	011b      	lsls	r3, r3, #4
 81105e0:	4413      	add	r3, r2
 81105e2:	011b      	lsls	r3, r3, #4
 81105e4:	440b      	add	r3, r1
 81105e6:	330f      	adds	r3, #15
 81105e8:	2204      	movs	r2, #4
 81105ea:	701a      	strb	r2, [r3, #0]
        break;
 81105ec:	e006      	b.n	81105fc <dns_call_found+0x104>
      continue; /* only check other requests */
 81105ee:	bf00      	nop
  for (i = 0; i < DNS_MAX_REQUESTS; i++) {
 81105f0:	7bfb      	ldrb	r3, [r7, #15]
 81105f2:	3301      	adds	r3, #1
 81105f4:	73fb      	strb	r3, [r7, #15]
 81105f6:	7bfb      	ldrb	r3, [r7, #15]
 81105f8:	2b03      	cmp	r3, #3
 81105fa:	d9ca      	bls.n	8110592 <dns_call_found+0x9a>
      }
    }
  }
  if (dns_table[idx].pcb_idx < DNS_MAX_SOURCE_PORTS) {
 81105fc:	79fa      	ldrb	r2, [r7, #7]
 81105fe:	491c      	ldr	r1, [pc, #112]	; (8110670 <dns_call_found+0x178>)
 8110600:	4613      	mov	r3, r2
 8110602:	011b      	lsls	r3, r3, #4
 8110604:	4413      	add	r3, r2
 8110606:	011b      	lsls	r3, r3, #4
 8110608:	440b      	add	r3, r1
 811060a:	330f      	adds	r3, #15
 811060c:	781b      	ldrb	r3, [r3, #0]
 811060e:	2b03      	cmp	r3, #3
 8110610:	d827      	bhi.n	8110662 <dns_call_found+0x16a>
    /* if we come here, the pcb is not used any more and can be removed */
    udp_remove(dns_pcbs[dns_table[idx].pcb_idx]);
 8110612:	79fa      	ldrb	r2, [r7, #7]
 8110614:	4916      	ldr	r1, [pc, #88]	; (8110670 <dns_call_found+0x178>)
 8110616:	4613      	mov	r3, r2
 8110618:	011b      	lsls	r3, r3, #4
 811061a:	4413      	add	r3, r2
 811061c:	011b      	lsls	r3, r3, #4
 811061e:	440b      	add	r3, r1
 8110620:	330f      	adds	r3, #15
 8110622:	781b      	ldrb	r3, [r3, #0]
 8110624:	461a      	mov	r2, r3
 8110626:	4b13      	ldr	r3, [pc, #76]	; (8110674 <dns_call_found+0x17c>)
 8110628:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 811062c:	4618      	mov	r0, r3
 811062e:	f00a fafd 	bl	811ac2c <udp_remove>
    dns_pcbs[dns_table[idx].pcb_idx] = NULL;
 8110632:	79fa      	ldrb	r2, [r7, #7]
 8110634:	490e      	ldr	r1, [pc, #56]	; (8110670 <dns_call_found+0x178>)
 8110636:	4613      	mov	r3, r2
 8110638:	011b      	lsls	r3, r3, #4
 811063a:	4413      	add	r3, r2
 811063c:	011b      	lsls	r3, r3, #4
 811063e:	440b      	add	r3, r1
 8110640:	330f      	adds	r3, #15
 8110642:	781b      	ldrb	r3, [r3, #0]
 8110644:	4619      	mov	r1, r3
 8110646:	4b0b      	ldr	r3, [pc, #44]	; (8110674 <dns_call_found+0x17c>)
 8110648:	2200      	movs	r2, #0
 811064a:	f843 2021 	str.w	r2, [r3, r1, lsl #2]
    dns_table[idx].pcb_idx = DNS_MAX_SOURCE_PORTS;
 811064e:	79fa      	ldrb	r2, [r7, #7]
 8110650:	4907      	ldr	r1, [pc, #28]	; (8110670 <dns_call_found+0x178>)
 8110652:	4613      	mov	r3, r2
 8110654:	011b      	lsls	r3, r3, #4
 8110656:	4413      	add	r3, r2
 8110658:	011b      	lsls	r3, r3, #4
 811065a:	440b      	add	r3, r1
 811065c:	330f      	adds	r3, #15
 811065e:	2204      	movs	r2, #4
 8110660:	701a      	strb	r2, [r3, #0]
  }
#endif
}
 8110662:	bf00      	nop
 8110664:	3714      	adds	r7, #20
 8110666:	46bd      	mov	sp, r7
 8110668:	bd90      	pop	{r4, r7, pc}
 811066a:	bf00      	nop
 811066c:	100053c4 	.word	0x100053c4
 8110670:	10004f84 	.word	0x10004f84
 8110674:	10004f74 	.word	0x10004f74

08110678 <dns_create_txid>:

/* Create a query transmission ID that is unique for all outstanding queries */
static u16_t
dns_create_txid(void)
{
 8110678:	b580      	push	{r7, lr}
 811067a:	b082      	sub	sp, #8
 811067c:	af00      	add	r7, sp, #0
  u16_t txid;
  u8_t i;

again:
  txid = (u16_t)DNS_RAND_TXID();
 811067e:	f00a ffd1 	bl	811b624 <rand>
 8110682:	4603      	mov	r3, r0
 8110684:	80bb      	strh	r3, [r7, #4]

  /* check whether the ID is unique */
  for (i = 0; i < DNS_TABLE_SIZE; i++) {
 8110686:	2300      	movs	r3, #0
 8110688:	71fb      	strb	r3, [r7, #7]
 811068a:	e01a      	b.n	81106c2 <dns_create_txid+0x4a>
    if ((dns_table[i].state == DNS_STATE_ASKING) &&
 811068c:	79fa      	ldrb	r2, [r7, #7]
 811068e:	4911      	ldr	r1, [pc, #68]	; (81106d4 <dns_create_txid+0x5c>)
 8110690:	4613      	mov	r3, r2
 8110692:	011b      	lsls	r3, r3, #4
 8110694:	4413      	add	r3, r2
 8110696:	011b      	lsls	r3, r3, #4
 8110698:	440b      	add	r3, r1
 811069a:	330a      	adds	r3, #10
 811069c:	781b      	ldrb	r3, [r3, #0]
 811069e:	2b02      	cmp	r3, #2
 81106a0:	d10c      	bne.n	81106bc <dns_create_txid+0x44>
        (dns_table[i].txid == txid)) {
 81106a2:	79fa      	ldrb	r2, [r7, #7]
 81106a4:	490b      	ldr	r1, [pc, #44]	; (81106d4 <dns_create_txid+0x5c>)
 81106a6:	4613      	mov	r3, r2
 81106a8:	011b      	lsls	r3, r3, #4
 81106aa:	4413      	add	r3, r2
 81106ac:	011b      	lsls	r3, r3, #4
 81106ae:	440b      	add	r3, r1
 81106b0:	3308      	adds	r3, #8
 81106b2:	881b      	ldrh	r3, [r3, #0]
    if ((dns_table[i].state == DNS_STATE_ASKING) &&
 81106b4:	88ba      	ldrh	r2, [r7, #4]
 81106b6:	429a      	cmp	r2, r3
 81106b8:	d100      	bne.n	81106bc <dns_create_txid+0x44>
      /* ID already used by another pending query */
      goto again;
 81106ba:	e7e0      	b.n	811067e <dns_create_txid+0x6>
  for (i = 0; i < DNS_TABLE_SIZE; i++) {
 81106bc:	79fb      	ldrb	r3, [r7, #7]
 81106be:	3301      	adds	r3, #1
 81106c0:	71fb      	strb	r3, [r7, #7]
 81106c2:	79fb      	ldrb	r3, [r7, #7]
 81106c4:	2b03      	cmp	r3, #3
 81106c6:	d9e1      	bls.n	811068c <dns_create_txid+0x14>
    }
  }

  return txid;
 81106c8:	88bb      	ldrh	r3, [r7, #4]
}
 81106ca:	4618      	mov	r0, r3
 81106cc:	3708      	adds	r7, #8
 81106ce:	46bd      	mov	sp, r7
 81106d0:	bd80      	pop	{r7, pc}
 81106d2:	bf00      	nop
 81106d4:	10004f84 	.word	0x10004f84

081106d8 <dns_backupserver_available>:
/**
 * Check whether there are other backup DNS servers available to try
 */
static u8_t
dns_backupserver_available(struct dns_table_entry *pentry)
{
 81106d8:	b480      	push	{r7}
 81106da:	b085      	sub	sp, #20
 81106dc:	af00      	add	r7, sp, #0
 81106de:	6078      	str	r0, [r7, #4]
  u8_t ret = 0;
 81106e0:	2300      	movs	r3, #0
 81106e2:	73fb      	strb	r3, [r7, #15]

  if (pentry) {
 81106e4:	687b      	ldr	r3, [r7, #4]
 81106e6:	2b00      	cmp	r3, #0
 81106e8:	d00d      	beq.n	8110706 <dns_backupserver_available+0x2e>
    if ((pentry->server_idx + 1 < DNS_MAX_SERVERS) && !ip_addr_isany_val(dns_servers[pentry->server_idx + 1])) {
 81106ea:	687b      	ldr	r3, [r7, #4]
 81106ec:	7adb      	ldrb	r3, [r3, #11]
 81106ee:	2b00      	cmp	r3, #0
 81106f0:	d109      	bne.n	8110706 <dns_backupserver_available+0x2e>
 81106f2:	687b      	ldr	r3, [r7, #4]
 81106f4:	7adb      	ldrb	r3, [r3, #11]
 81106f6:	3301      	adds	r3, #1
 81106f8:	4a06      	ldr	r2, [pc, #24]	; (8110714 <dns_backupserver_available+0x3c>)
 81106fa:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 81106fe:	2b00      	cmp	r3, #0
 8110700:	d001      	beq.n	8110706 <dns_backupserver_available+0x2e>
      ret = 1;
 8110702:	2301      	movs	r3, #1
 8110704:	73fb      	strb	r3, [r7, #15]
    }
  }

  return ret;
 8110706:	7bfb      	ldrb	r3, [r7, #15]
}
 8110708:	4618      	mov	r0, r3
 811070a:	3714      	adds	r7, #20
 811070c:	46bd      	mov	sp, r7
 811070e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8110712:	4770      	bx	lr
 8110714:	100053f4 	.word	0x100053f4

08110718 <dns_check_entry>:
 *
 * @param i index of the dns_table entry to check
 */
static void
dns_check_entry(u8_t i)
{
 8110718:	b580      	push	{r7, lr}
 811071a:	b084      	sub	sp, #16
 811071c:	af00      	add	r7, sp, #0
 811071e:	4603      	mov	r3, r0
 8110720:	71fb      	strb	r3, [r7, #7]
  err_t err;
  struct dns_table_entry *entry = &dns_table[i];
 8110722:	79fa      	ldrb	r2, [r7, #7]
 8110724:	4613      	mov	r3, r2
 8110726:	011b      	lsls	r3, r3, #4
 8110728:	4413      	add	r3, r2
 811072a:	011b      	lsls	r3, r3, #4
 811072c:	4a48      	ldr	r2, [pc, #288]	; (8110850 <dns_check_entry+0x138>)
 811072e:	4413      	add	r3, r2
 8110730:	60fb      	str	r3, [r7, #12]

  LWIP_ASSERT("array index out of bounds", i < DNS_TABLE_SIZE);
 8110732:	79fb      	ldrb	r3, [r7, #7]
 8110734:	2b03      	cmp	r3, #3
 8110736:	d906      	bls.n	8110746 <dns_check_entry+0x2e>
 8110738:	4b46      	ldr	r3, [pc, #280]	; (8110854 <dns_check_entry+0x13c>)
 811073a:	f240 421c 	movw	r2, #1052	; 0x41c
 811073e:	4946      	ldr	r1, [pc, #280]	; (8110858 <dns_check_entry+0x140>)
 8110740:	4846      	ldr	r0, [pc, #280]	; (811085c <dns_check_entry+0x144>)
 8110742:	f00b f85d 	bl	811b800 <iprintf>

  switch (entry->state) {
 8110746:	68fb      	ldr	r3, [r7, #12]
 8110748:	7a9b      	ldrb	r3, [r3, #10]
 811074a:	2b03      	cmp	r3, #3
 811074c:	d86f      	bhi.n	811082e <dns_check_entry+0x116>
 811074e:	a201      	add	r2, pc, #4	; (adr r2, 8110754 <dns_check_entry+0x3c>)
 8110750:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8110754:	0811083f 	.word	0x0811083f
 8110758:	08110765 	.word	0x08110765
 811075c:	08110797 	.word	0x08110797
 8110760:	0811080d 	.word	0x0811080d
    case DNS_STATE_NEW:
      /* initialize new entry */
      entry->txid = dns_create_txid();
 8110764:	f7ff ff88 	bl	8110678 <dns_create_txid>
 8110768:	4603      	mov	r3, r0
 811076a:	461a      	mov	r2, r3
 811076c:	68fb      	ldr	r3, [r7, #12]
 811076e:	811a      	strh	r2, [r3, #8]
      entry->state = DNS_STATE_ASKING;
 8110770:	68fb      	ldr	r3, [r7, #12]
 8110772:	2202      	movs	r2, #2
 8110774:	729a      	strb	r2, [r3, #10]
      entry->server_idx = 0;
 8110776:	68fb      	ldr	r3, [r7, #12]
 8110778:	2200      	movs	r2, #0
 811077a:	72da      	strb	r2, [r3, #11]
      entry->tmr = 1;
 811077c:	68fb      	ldr	r3, [r7, #12]
 811077e:	2201      	movs	r2, #1
 8110780:	731a      	strb	r2, [r3, #12]
      entry->retries = 0;
 8110782:	68fb      	ldr	r3, [r7, #12]
 8110784:	2200      	movs	r2, #0
 8110786:	735a      	strb	r2, [r3, #13]

      /* send DNS packet for this entry */
      err = dns_send(i);
 8110788:	79fb      	ldrb	r3, [r7, #7]
 811078a:	4618      	mov	r0, r3
 811078c:	f7ff fdc4 	bl	8110318 <dns_send>
 8110790:	4603      	mov	r3, r0
 8110792:	72fb      	strb	r3, [r7, #11]
      if (err != ERR_OK) {
        LWIP_DEBUGF(DNS_DEBUG | LWIP_DBG_LEVEL_WARNING,
                    ("dns_send returned error: %s\n", lwip_strerr(err)));
      }
      break;
 8110794:	e058      	b.n	8110848 <dns_check_entry+0x130>
    case DNS_STATE_ASKING:
      if (--entry->tmr == 0) {
 8110796:	68fb      	ldr	r3, [r7, #12]
 8110798:	7b1b      	ldrb	r3, [r3, #12]
 811079a:	3b01      	subs	r3, #1
 811079c:	b2da      	uxtb	r2, r3
 811079e:	68fb      	ldr	r3, [r7, #12]
 81107a0:	731a      	strb	r2, [r3, #12]
 81107a2:	68fb      	ldr	r3, [r7, #12]
 81107a4:	7b1b      	ldrb	r3, [r3, #12]
 81107a6:	2b00      	cmp	r3, #0
 81107a8:	d14b      	bne.n	8110842 <dns_check_entry+0x12a>
        if (++entry->retries == DNS_MAX_RETRIES) {
 81107aa:	68fb      	ldr	r3, [r7, #12]
 81107ac:	7b5b      	ldrb	r3, [r3, #13]
 81107ae:	3301      	adds	r3, #1
 81107b0:	b2da      	uxtb	r2, r3
 81107b2:	68fb      	ldr	r3, [r7, #12]
 81107b4:	735a      	strb	r2, [r3, #13]
 81107b6:	68fb      	ldr	r3, [r7, #12]
 81107b8:	7b5b      	ldrb	r3, [r3, #13]
 81107ba:	2b04      	cmp	r3, #4
 81107bc:	d11b      	bne.n	81107f6 <dns_check_entry+0xde>
          if (dns_backupserver_available(entry)
 81107be:	68f8      	ldr	r0, [r7, #12]
 81107c0:	f7ff ff8a 	bl	81106d8 <dns_backupserver_available>
 81107c4:	4603      	mov	r3, r0
 81107c6:	2b00      	cmp	r3, #0
 81107c8:	d00c      	beq.n	81107e4 <dns_check_entry+0xcc>
#if LWIP_DNS_SUPPORT_MDNS_QUERIES
              && !entry->is_mdns
#endif /* LWIP_DNS_SUPPORT_MDNS_QUERIES */
             ) {
            /* change of server */
            entry->server_idx++;
 81107ca:	68fb      	ldr	r3, [r7, #12]
 81107cc:	7adb      	ldrb	r3, [r3, #11]
 81107ce:	3301      	adds	r3, #1
 81107d0:	b2da      	uxtb	r2, r3
 81107d2:	68fb      	ldr	r3, [r7, #12]
 81107d4:	72da      	strb	r2, [r3, #11]
            entry->tmr = 1;
 81107d6:	68fb      	ldr	r3, [r7, #12]
 81107d8:	2201      	movs	r2, #1
 81107da:	731a      	strb	r2, [r3, #12]
            entry->retries = 0;
 81107dc:	68fb      	ldr	r3, [r7, #12]
 81107de:	2200      	movs	r2, #0
 81107e0:	735a      	strb	r2, [r3, #13]
 81107e2:	e00c      	b.n	81107fe <dns_check_entry+0xe6>
          } else {
            LWIP_DEBUGF(DNS_DEBUG, ("dns_check_entry: \"%s\": timeout\n", entry->name));
            /* call specified callback function if provided */
            dns_call_found(i, NULL);
 81107e4:	79fb      	ldrb	r3, [r7, #7]
 81107e6:	2100      	movs	r1, #0
 81107e8:	4618      	mov	r0, r3
 81107ea:	f7ff fe85 	bl	81104f8 <dns_call_found>
            /* flush this entry */
            entry->state = DNS_STATE_UNUSED;
 81107ee:	68fb      	ldr	r3, [r7, #12]
 81107f0:	2200      	movs	r2, #0
 81107f2:	729a      	strb	r2, [r3, #10]
            break;
 81107f4:	e028      	b.n	8110848 <dns_check_entry+0x130>
          }
        } else {
          /* wait longer for the next retry */
          entry->tmr = entry->retries;
 81107f6:	68fb      	ldr	r3, [r7, #12]
 81107f8:	7b5a      	ldrb	r2, [r3, #13]
 81107fa:	68fb      	ldr	r3, [r7, #12]
 81107fc:	731a      	strb	r2, [r3, #12]
        }

        /* send DNS packet for this entry */
        err = dns_send(i);
 81107fe:	79fb      	ldrb	r3, [r7, #7]
 8110800:	4618      	mov	r0, r3
 8110802:	f7ff fd89 	bl	8110318 <dns_send>
 8110806:	4603      	mov	r3, r0
 8110808:	72fb      	strb	r3, [r7, #11]
        if (err != ERR_OK) {
          LWIP_DEBUGF(DNS_DEBUG | LWIP_DBG_LEVEL_WARNING,
                      ("dns_send returned error: %s\n", lwip_strerr(err)));
        }
      }
      break;
 811080a:	e01a      	b.n	8110842 <dns_check_entry+0x12a>
    case DNS_STATE_DONE:
      /* if the time to live is nul */
      if ((entry->ttl == 0) || (--entry->ttl == 0)) {
 811080c:	68fb      	ldr	r3, [r7, #12]
 811080e:	681b      	ldr	r3, [r3, #0]
 8110810:	2b00      	cmp	r3, #0
 8110812:	d008      	beq.n	8110826 <dns_check_entry+0x10e>
 8110814:	68fb      	ldr	r3, [r7, #12]
 8110816:	681b      	ldr	r3, [r3, #0]
 8110818:	1e5a      	subs	r2, r3, #1
 811081a:	68fb      	ldr	r3, [r7, #12]
 811081c:	601a      	str	r2, [r3, #0]
 811081e:	68fb      	ldr	r3, [r7, #12]
 8110820:	681b      	ldr	r3, [r3, #0]
 8110822:	2b00      	cmp	r3, #0
 8110824:	d10f      	bne.n	8110846 <dns_check_entry+0x12e>
        LWIP_DEBUGF(DNS_DEBUG, ("dns_check_entry: \"%s\": flush\n", entry->name));
        /* flush this entry, there cannot be any related pending entries in this state */
        entry->state = DNS_STATE_UNUSED;
 8110826:	68fb      	ldr	r3, [r7, #12]
 8110828:	2200      	movs	r2, #0
 811082a:	729a      	strb	r2, [r3, #10]
      }
      break;
 811082c:	e00b      	b.n	8110846 <dns_check_entry+0x12e>
    case DNS_STATE_UNUSED:
      /* nothing to do */
      break;
    default:
      LWIP_ASSERT("unknown dns_table entry state:", 0);
 811082e:	4b09      	ldr	r3, [pc, #36]	; (8110854 <dns_check_entry+0x13c>)
 8110830:	f240 425b 	movw	r2, #1115	; 0x45b
 8110834:	490a      	ldr	r1, [pc, #40]	; (8110860 <dns_check_entry+0x148>)
 8110836:	4809      	ldr	r0, [pc, #36]	; (811085c <dns_check_entry+0x144>)
 8110838:	f00a ffe2 	bl	811b800 <iprintf>
      break;
 811083c:	e004      	b.n	8110848 <dns_check_entry+0x130>
      break;
 811083e:	bf00      	nop
 8110840:	e002      	b.n	8110848 <dns_check_entry+0x130>
      break;
 8110842:	bf00      	nop
 8110844:	e000      	b.n	8110848 <dns_check_entry+0x130>
      break;
 8110846:	bf00      	nop
  }
}
 8110848:	bf00      	nop
 811084a:	3710      	adds	r7, #16
 811084c:	46bd      	mov	sp, r7
 811084e:	bd80      	pop	{r7, pc}
 8110850:	10004f84 	.word	0x10004f84
 8110854:	0811cb68 	.word	0x0811cb68
 8110858:	0811cc0c 	.word	0x0811cc0c
 811085c:	0811cbe4 	.word	0x0811cbe4
 8110860:	0811cc28 	.word	0x0811cc28

08110864 <dns_check_entries>:
/**
 * Call dns_check_entry for each entry in dns_table - check all entries.
 */
static void
dns_check_entries(void)
{
 8110864:	b580      	push	{r7, lr}
 8110866:	b082      	sub	sp, #8
 8110868:	af00      	add	r7, sp, #0
  u8_t i;

  for (i = 0; i < DNS_TABLE_SIZE; ++i) {
 811086a:	2300      	movs	r3, #0
 811086c:	71fb      	strb	r3, [r7, #7]
 811086e:	e006      	b.n	811087e <dns_check_entries+0x1a>
    dns_check_entry(i);
 8110870:	79fb      	ldrb	r3, [r7, #7]
 8110872:	4618      	mov	r0, r3
 8110874:	f7ff ff50 	bl	8110718 <dns_check_entry>
  for (i = 0; i < DNS_TABLE_SIZE; ++i) {
 8110878:	79fb      	ldrb	r3, [r7, #7]
 811087a:	3301      	adds	r3, #1
 811087c:	71fb      	strb	r3, [r7, #7]
 811087e:	79fb      	ldrb	r3, [r7, #7]
 8110880:	2b03      	cmp	r3, #3
 8110882:	d9f5      	bls.n	8110870 <dns_check_entries+0xc>
  }
}
 8110884:	bf00      	nop
 8110886:	bf00      	nop
 8110888:	3708      	adds	r7, #8
 811088a:	46bd      	mov	sp, r7
 811088c:	bd80      	pop	{r7, pc}
	...

08110890 <etharp_free_entry>:
#endif /* ARP_QUEUEING */

/** Clean up ARP table entries */
static void
etharp_free_entry(int i)
{
 8110890:	b580      	push	{r7, lr}
 8110892:	b082      	sub	sp, #8
 8110894:	af00      	add	r7, sp, #0
 8110896:	6078      	str	r0, [r7, #4]
  /* remove from SNMP ARP index tree */
  mib2_remove_arp_entry(arp_table[i].netif, &arp_table[i].ipaddr);
  /* and empty packet queue */
  if (arp_table[i].q != NULL) {
 8110898:	4915      	ldr	r1, [pc, #84]	; (81108f0 <etharp_free_entry+0x60>)
 811089a:	687a      	ldr	r2, [r7, #4]
 811089c:	4613      	mov	r3, r2
 811089e:	005b      	lsls	r3, r3, #1
 81108a0:	4413      	add	r3, r2
 81108a2:	00db      	lsls	r3, r3, #3
 81108a4:	440b      	add	r3, r1
 81108a6:	681b      	ldr	r3, [r3, #0]
 81108a8:	2b00      	cmp	r3, #0
 81108aa:	d013      	beq.n	81108d4 <etharp_free_entry+0x44>
    /* remove all queued packets */
    LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_free_entry: freeing entry %"U16_F", packet queue %p.\n", (u16_t)i, (void *)(arp_table[i].q)));
    free_etharp_q(arp_table[i].q);
 81108ac:	4910      	ldr	r1, [pc, #64]	; (81108f0 <etharp_free_entry+0x60>)
 81108ae:	687a      	ldr	r2, [r7, #4]
 81108b0:	4613      	mov	r3, r2
 81108b2:	005b      	lsls	r3, r3, #1
 81108b4:	4413      	add	r3, r2
 81108b6:	00db      	lsls	r3, r3, #3
 81108b8:	440b      	add	r3, r1
 81108ba:	681b      	ldr	r3, [r3, #0]
 81108bc:	4618      	mov	r0, r3
 81108be:	f003 fecb 	bl	8114658 <pbuf_free>
    arp_table[i].q = NULL;
 81108c2:	490b      	ldr	r1, [pc, #44]	; (81108f0 <etharp_free_entry+0x60>)
 81108c4:	687a      	ldr	r2, [r7, #4]
 81108c6:	4613      	mov	r3, r2
 81108c8:	005b      	lsls	r3, r3, #1
 81108ca:	4413      	add	r3, r2
 81108cc:	00db      	lsls	r3, r3, #3
 81108ce:	440b      	add	r3, r1
 81108d0:	2200      	movs	r2, #0
 81108d2:	601a      	str	r2, [r3, #0]
  }
  /* recycle entry for re-use */
  arp_table[i].state = ETHARP_STATE_EMPTY;
 81108d4:	4906      	ldr	r1, [pc, #24]	; (81108f0 <etharp_free_entry+0x60>)
 81108d6:	687a      	ldr	r2, [r7, #4]
 81108d8:	4613      	mov	r3, r2
 81108da:	005b      	lsls	r3, r3, #1
 81108dc:	4413      	add	r3, r2
 81108de:	00db      	lsls	r3, r3, #3
 81108e0:	440b      	add	r3, r1
 81108e2:	3314      	adds	r3, #20
 81108e4:	2200      	movs	r2, #0
 81108e6:	701a      	strb	r2, [r3, #0]
  arp_table[i].ctime = 0;
  arp_table[i].netif = NULL;
  ip4_addr_set_zero(&arp_table[i].ipaddr);
  arp_table[i].ethaddr = ethzero;
#endif /* LWIP_DEBUG */
}
 81108e8:	bf00      	nop
 81108ea:	3708      	adds	r7, #8
 81108ec:	46bd      	mov	sp, r7
 81108ee:	bd80      	pop	{r7, pc}
 81108f0:	100053fc 	.word	0x100053fc

081108f4 <etharp_tmr>:
 * This function should be called every ARP_TMR_INTERVAL milliseconds (1 second),
 * in order to expire entries in the ARP table.
 */
void
etharp_tmr(void)
{
 81108f4:	b580      	push	{r7, lr}
 81108f6:	b082      	sub	sp, #8
 81108f8:	af00      	add	r7, sp, #0
  int i;

  LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_timer\n"));
  /* remove expired entries from the ARP table */
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
 81108fa:	2300      	movs	r3, #0
 81108fc:	607b      	str	r3, [r7, #4]
 81108fe:	e096      	b.n	8110a2e <etharp_tmr+0x13a>
    u8_t state = arp_table[i].state;
 8110900:	494f      	ldr	r1, [pc, #316]	; (8110a40 <etharp_tmr+0x14c>)
 8110902:	687a      	ldr	r2, [r7, #4]
 8110904:	4613      	mov	r3, r2
 8110906:	005b      	lsls	r3, r3, #1
 8110908:	4413      	add	r3, r2
 811090a:	00db      	lsls	r3, r3, #3
 811090c:	440b      	add	r3, r1
 811090e:	3314      	adds	r3, #20
 8110910:	781b      	ldrb	r3, [r3, #0]
 8110912:	70fb      	strb	r3, [r7, #3]
    if (state != ETHARP_STATE_EMPTY
 8110914:	78fb      	ldrb	r3, [r7, #3]
 8110916:	2b00      	cmp	r3, #0
 8110918:	f000 8086 	beq.w	8110a28 <etharp_tmr+0x134>
#if ETHARP_SUPPORT_STATIC_ENTRIES
        && (state != ETHARP_STATE_STATIC)
#endif /* ETHARP_SUPPORT_STATIC_ENTRIES */
       ) {
      arp_table[i].ctime++;
 811091c:	4948      	ldr	r1, [pc, #288]	; (8110a40 <etharp_tmr+0x14c>)
 811091e:	687a      	ldr	r2, [r7, #4]
 8110920:	4613      	mov	r3, r2
 8110922:	005b      	lsls	r3, r3, #1
 8110924:	4413      	add	r3, r2
 8110926:	00db      	lsls	r3, r3, #3
 8110928:	440b      	add	r3, r1
 811092a:	3312      	adds	r3, #18
 811092c:	881b      	ldrh	r3, [r3, #0]
 811092e:	3301      	adds	r3, #1
 8110930:	b298      	uxth	r0, r3
 8110932:	4943      	ldr	r1, [pc, #268]	; (8110a40 <etharp_tmr+0x14c>)
 8110934:	687a      	ldr	r2, [r7, #4]
 8110936:	4613      	mov	r3, r2
 8110938:	005b      	lsls	r3, r3, #1
 811093a:	4413      	add	r3, r2
 811093c:	00db      	lsls	r3, r3, #3
 811093e:	440b      	add	r3, r1
 8110940:	3312      	adds	r3, #18
 8110942:	4602      	mov	r2, r0
 8110944:	801a      	strh	r2, [r3, #0]
      if ((arp_table[i].ctime >= ARP_MAXAGE) ||
 8110946:	493e      	ldr	r1, [pc, #248]	; (8110a40 <etharp_tmr+0x14c>)
 8110948:	687a      	ldr	r2, [r7, #4]
 811094a:	4613      	mov	r3, r2
 811094c:	005b      	lsls	r3, r3, #1
 811094e:	4413      	add	r3, r2
 8110950:	00db      	lsls	r3, r3, #3
 8110952:	440b      	add	r3, r1
 8110954:	3312      	adds	r3, #18
 8110956:	881b      	ldrh	r3, [r3, #0]
 8110958:	f5b3 7f96 	cmp.w	r3, #300	; 0x12c
 811095c:	d215      	bcs.n	811098a <etharp_tmr+0x96>
          ((arp_table[i].state == ETHARP_STATE_PENDING)  &&
 811095e:	4938      	ldr	r1, [pc, #224]	; (8110a40 <etharp_tmr+0x14c>)
 8110960:	687a      	ldr	r2, [r7, #4]
 8110962:	4613      	mov	r3, r2
 8110964:	005b      	lsls	r3, r3, #1
 8110966:	4413      	add	r3, r2
 8110968:	00db      	lsls	r3, r3, #3
 811096a:	440b      	add	r3, r1
 811096c:	3314      	adds	r3, #20
 811096e:	781b      	ldrb	r3, [r3, #0]
      if ((arp_table[i].ctime >= ARP_MAXAGE) ||
 8110970:	2b01      	cmp	r3, #1
 8110972:	d10e      	bne.n	8110992 <etharp_tmr+0x9e>
           (arp_table[i].ctime >= ARP_MAXPENDING))) {
 8110974:	4932      	ldr	r1, [pc, #200]	; (8110a40 <etharp_tmr+0x14c>)
 8110976:	687a      	ldr	r2, [r7, #4]
 8110978:	4613      	mov	r3, r2
 811097a:	005b      	lsls	r3, r3, #1
 811097c:	4413      	add	r3, r2
 811097e:	00db      	lsls	r3, r3, #3
 8110980:	440b      	add	r3, r1
 8110982:	3312      	adds	r3, #18
 8110984:	881b      	ldrh	r3, [r3, #0]
          ((arp_table[i].state == ETHARP_STATE_PENDING)  &&
 8110986:	2b04      	cmp	r3, #4
 8110988:	d903      	bls.n	8110992 <etharp_tmr+0x9e>
        /* pending or stable entry has become old! */
        LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_timer: expired %s entry %d.\n",
                                   arp_table[i].state >= ETHARP_STATE_STABLE ? "stable" : "pending", i));
        /* clean up entries that have just been expired */
        etharp_free_entry(i);
 811098a:	6878      	ldr	r0, [r7, #4]
 811098c:	f7ff ff80 	bl	8110890 <etharp_free_entry>
 8110990:	e04a      	b.n	8110a28 <etharp_tmr+0x134>
      } else if (arp_table[i].state == ETHARP_STATE_STABLE_REREQUESTING_1) {
 8110992:	492b      	ldr	r1, [pc, #172]	; (8110a40 <etharp_tmr+0x14c>)
 8110994:	687a      	ldr	r2, [r7, #4]
 8110996:	4613      	mov	r3, r2
 8110998:	005b      	lsls	r3, r3, #1
 811099a:	4413      	add	r3, r2
 811099c:	00db      	lsls	r3, r3, #3
 811099e:	440b      	add	r3, r1
 81109a0:	3314      	adds	r3, #20
 81109a2:	781b      	ldrb	r3, [r3, #0]
 81109a4:	2b03      	cmp	r3, #3
 81109a6:	d10a      	bne.n	81109be <etharp_tmr+0xca>
        /* Don't send more than one request every 2 seconds. */
        arp_table[i].state = ETHARP_STATE_STABLE_REREQUESTING_2;
 81109a8:	4925      	ldr	r1, [pc, #148]	; (8110a40 <etharp_tmr+0x14c>)
 81109aa:	687a      	ldr	r2, [r7, #4]
 81109ac:	4613      	mov	r3, r2
 81109ae:	005b      	lsls	r3, r3, #1
 81109b0:	4413      	add	r3, r2
 81109b2:	00db      	lsls	r3, r3, #3
 81109b4:	440b      	add	r3, r1
 81109b6:	3314      	adds	r3, #20
 81109b8:	2204      	movs	r2, #4
 81109ba:	701a      	strb	r2, [r3, #0]
 81109bc:	e034      	b.n	8110a28 <etharp_tmr+0x134>
      } else if (arp_table[i].state == ETHARP_STATE_STABLE_REREQUESTING_2) {
 81109be:	4920      	ldr	r1, [pc, #128]	; (8110a40 <etharp_tmr+0x14c>)
 81109c0:	687a      	ldr	r2, [r7, #4]
 81109c2:	4613      	mov	r3, r2
 81109c4:	005b      	lsls	r3, r3, #1
 81109c6:	4413      	add	r3, r2
 81109c8:	00db      	lsls	r3, r3, #3
 81109ca:	440b      	add	r3, r1
 81109cc:	3314      	adds	r3, #20
 81109ce:	781b      	ldrb	r3, [r3, #0]
 81109d0:	2b04      	cmp	r3, #4
 81109d2:	d10a      	bne.n	81109ea <etharp_tmr+0xf6>
        /* Reset state to stable, so that the next transmitted packet will
           re-send an ARP request. */
        arp_table[i].state = ETHARP_STATE_STABLE;
 81109d4:	491a      	ldr	r1, [pc, #104]	; (8110a40 <etharp_tmr+0x14c>)
 81109d6:	687a      	ldr	r2, [r7, #4]
 81109d8:	4613      	mov	r3, r2
 81109da:	005b      	lsls	r3, r3, #1
 81109dc:	4413      	add	r3, r2
 81109de:	00db      	lsls	r3, r3, #3
 81109e0:	440b      	add	r3, r1
 81109e2:	3314      	adds	r3, #20
 81109e4:	2202      	movs	r2, #2
 81109e6:	701a      	strb	r2, [r3, #0]
 81109e8:	e01e      	b.n	8110a28 <etharp_tmr+0x134>
      } else if (arp_table[i].state == ETHARP_STATE_PENDING) {
 81109ea:	4915      	ldr	r1, [pc, #84]	; (8110a40 <etharp_tmr+0x14c>)
 81109ec:	687a      	ldr	r2, [r7, #4]
 81109ee:	4613      	mov	r3, r2
 81109f0:	005b      	lsls	r3, r3, #1
 81109f2:	4413      	add	r3, r2
 81109f4:	00db      	lsls	r3, r3, #3
 81109f6:	440b      	add	r3, r1
 81109f8:	3314      	adds	r3, #20
 81109fa:	781b      	ldrb	r3, [r3, #0]
 81109fc:	2b01      	cmp	r3, #1
 81109fe:	d113      	bne.n	8110a28 <etharp_tmr+0x134>
        /* still pending, resend an ARP query */
        etharp_request(arp_table[i].netif, &arp_table[i].ipaddr);
 8110a00:	490f      	ldr	r1, [pc, #60]	; (8110a40 <etharp_tmr+0x14c>)
 8110a02:	687a      	ldr	r2, [r7, #4]
 8110a04:	4613      	mov	r3, r2
 8110a06:	005b      	lsls	r3, r3, #1
 8110a08:	4413      	add	r3, r2
 8110a0a:	00db      	lsls	r3, r3, #3
 8110a0c:	440b      	add	r3, r1
 8110a0e:	3308      	adds	r3, #8
 8110a10:	6818      	ldr	r0, [r3, #0]
 8110a12:	687a      	ldr	r2, [r7, #4]
 8110a14:	4613      	mov	r3, r2
 8110a16:	005b      	lsls	r3, r3, #1
 8110a18:	4413      	add	r3, r2
 8110a1a:	00db      	lsls	r3, r3, #3
 8110a1c:	4a08      	ldr	r2, [pc, #32]	; (8110a40 <etharp_tmr+0x14c>)
 8110a1e:	4413      	add	r3, r2
 8110a20:	3304      	adds	r3, #4
 8110a22:	4619      	mov	r1, r3
 8110a24:	f000 fe72 	bl	811170c <etharp_request>
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
 8110a28:	687b      	ldr	r3, [r7, #4]
 8110a2a:	3301      	adds	r3, #1
 8110a2c:	607b      	str	r3, [r7, #4]
 8110a2e:	687b      	ldr	r3, [r7, #4]
 8110a30:	2b09      	cmp	r3, #9
 8110a32:	f77f af65 	ble.w	8110900 <etharp_tmr+0xc>
      }
    }
  }
}
 8110a36:	bf00      	nop
 8110a38:	bf00      	nop
 8110a3a:	3708      	adds	r7, #8
 8110a3c:	46bd      	mov	sp, r7
 8110a3e:	bd80      	pop	{r7, pc}
 8110a40:	100053fc 	.word	0x100053fc

08110a44 <etharp_find_entry>:
 * @return The ARP entry index that matched or is created, ERR_MEM if no
 * entry is found or could be recycled.
 */
static s16_t
etharp_find_entry(const ip4_addr_t *ipaddr, u8_t flags, struct netif *netif)
{
 8110a44:	b580      	push	{r7, lr}
 8110a46:	b08a      	sub	sp, #40	; 0x28
 8110a48:	af00      	add	r7, sp, #0
 8110a4a:	60f8      	str	r0, [r7, #12]
 8110a4c:	460b      	mov	r3, r1
 8110a4e:	607a      	str	r2, [r7, #4]
 8110a50:	72fb      	strb	r3, [r7, #11]
  s16_t old_pending = ARP_TABLE_SIZE, old_stable = ARP_TABLE_SIZE;
 8110a52:	230a      	movs	r3, #10
 8110a54:	84fb      	strh	r3, [r7, #38]	; 0x26
 8110a56:	230a      	movs	r3, #10
 8110a58:	84bb      	strh	r3, [r7, #36]	; 0x24
  s16_t empty = ARP_TABLE_SIZE;
 8110a5a:	230a      	movs	r3, #10
 8110a5c:	847b      	strh	r3, [r7, #34]	; 0x22
  s16_t i = 0;
 8110a5e:	2300      	movs	r3, #0
 8110a60:	843b      	strh	r3, [r7, #32]
  /* oldest entry with packets on queue */
  s16_t old_queue = ARP_TABLE_SIZE;
 8110a62:	230a      	movs	r3, #10
 8110a64:	83fb      	strh	r3, [r7, #30]
  /* its age */
  u16_t age_queue = 0, age_pending = 0, age_stable = 0;
 8110a66:	2300      	movs	r3, #0
 8110a68:	83bb      	strh	r3, [r7, #28]
 8110a6a:	2300      	movs	r3, #0
 8110a6c:	837b      	strh	r3, [r7, #26]
 8110a6e:	2300      	movs	r3, #0
 8110a70:	833b      	strh	r3, [r7, #24]
   * 4) remember the oldest pending entry with queued packets (if any)
   * 5) search for a matching IP entry, either pending or stable
   *    until 5 matches, or all entries are searched for.
   */

  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
 8110a72:	2300      	movs	r3, #0
 8110a74:	843b      	strh	r3, [r7, #32]
 8110a76:	e0ae      	b.n	8110bd6 <etharp_find_entry+0x192>
    u8_t state = arp_table[i].state;
 8110a78:	f9b7 2020 	ldrsh.w	r2, [r7, #32]
 8110a7c:	49a6      	ldr	r1, [pc, #664]	; (8110d18 <etharp_find_entry+0x2d4>)
 8110a7e:	4613      	mov	r3, r2
 8110a80:	005b      	lsls	r3, r3, #1
 8110a82:	4413      	add	r3, r2
 8110a84:	00db      	lsls	r3, r3, #3
 8110a86:	440b      	add	r3, r1
 8110a88:	3314      	adds	r3, #20
 8110a8a:	781b      	ldrb	r3, [r3, #0]
 8110a8c:	75fb      	strb	r3, [r7, #23]
    /* no empty entry found yet and now we do find one? */
    if ((empty == ARP_TABLE_SIZE) && (state == ETHARP_STATE_EMPTY)) {
 8110a8e:	f9b7 3022 	ldrsh.w	r3, [r7, #34]	; 0x22
 8110a92:	2b0a      	cmp	r3, #10
 8110a94:	d105      	bne.n	8110aa2 <etharp_find_entry+0x5e>
 8110a96:	7dfb      	ldrb	r3, [r7, #23]
 8110a98:	2b00      	cmp	r3, #0
 8110a9a:	d102      	bne.n	8110aa2 <etharp_find_entry+0x5e>
      LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_find_entry: found empty entry %d\n", (int)i));
      /* remember first empty entry */
      empty = i;
 8110a9c:	8c3b      	ldrh	r3, [r7, #32]
 8110a9e:	847b      	strh	r3, [r7, #34]	; 0x22
 8110aa0:	e095      	b.n	8110bce <etharp_find_entry+0x18a>
    } else if (state != ETHARP_STATE_EMPTY) {
 8110aa2:	7dfb      	ldrb	r3, [r7, #23]
 8110aa4:	2b00      	cmp	r3, #0
 8110aa6:	f000 8092 	beq.w	8110bce <etharp_find_entry+0x18a>
      LWIP_ASSERT("state == ETHARP_STATE_PENDING || state >= ETHARP_STATE_STABLE",
 8110aaa:	7dfb      	ldrb	r3, [r7, #23]
 8110aac:	2b01      	cmp	r3, #1
 8110aae:	d009      	beq.n	8110ac4 <etharp_find_entry+0x80>
 8110ab0:	7dfb      	ldrb	r3, [r7, #23]
 8110ab2:	2b01      	cmp	r3, #1
 8110ab4:	d806      	bhi.n	8110ac4 <etharp_find_entry+0x80>
 8110ab6:	4b99      	ldr	r3, [pc, #612]	; (8110d1c <etharp_find_entry+0x2d8>)
 8110ab8:	f240 1223 	movw	r2, #291	; 0x123
 8110abc:	4998      	ldr	r1, [pc, #608]	; (8110d20 <etharp_find_entry+0x2dc>)
 8110abe:	4899      	ldr	r0, [pc, #612]	; (8110d24 <etharp_find_entry+0x2e0>)
 8110ac0:	f00a fe9e 	bl	811b800 <iprintf>
                  state == ETHARP_STATE_PENDING || state >= ETHARP_STATE_STABLE);
      /* if given, does IP address match IP address in ARP entry? */
      if (ipaddr && ip4_addr_cmp(ipaddr, &arp_table[i].ipaddr)
 8110ac4:	68fb      	ldr	r3, [r7, #12]
 8110ac6:	2b00      	cmp	r3, #0
 8110ac8:	d020      	beq.n	8110b0c <etharp_find_entry+0xc8>
 8110aca:	68fb      	ldr	r3, [r7, #12]
 8110acc:	6819      	ldr	r1, [r3, #0]
 8110ace:	f9b7 2020 	ldrsh.w	r2, [r7, #32]
 8110ad2:	4891      	ldr	r0, [pc, #580]	; (8110d18 <etharp_find_entry+0x2d4>)
 8110ad4:	4613      	mov	r3, r2
 8110ad6:	005b      	lsls	r3, r3, #1
 8110ad8:	4413      	add	r3, r2
 8110ada:	00db      	lsls	r3, r3, #3
 8110adc:	4403      	add	r3, r0
 8110ade:	3304      	adds	r3, #4
 8110ae0:	681b      	ldr	r3, [r3, #0]
 8110ae2:	4299      	cmp	r1, r3
 8110ae4:	d112      	bne.n	8110b0c <etharp_find_entry+0xc8>
#if ETHARP_TABLE_MATCH_NETIF
          && ((netif == NULL) || (netif == arp_table[i].netif))
 8110ae6:	687b      	ldr	r3, [r7, #4]
 8110ae8:	2b00      	cmp	r3, #0
 8110aea:	d00c      	beq.n	8110b06 <etharp_find_entry+0xc2>
 8110aec:	f9b7 2020 	ldrsh.w	r2, [r7, #32]
 8110af0:	4989      	ldr	r1, [pc, #548]	; (8110d18 <etharp_find_entry+0x2d4>)
 8110af2:	4613      	mov	r3, r2
 8110af4:	005b      	lsls	r3, r3, #1
 8110af6:	4413      	add	r3, r2
 8110af8:	00db      	lsls	r3, r3, #3
 8110afa:	440b      	add	r3, r1
 8110afc:	3308      	adds	r3, #8
 8110afe:	681b      	ldr	r3, [r3, #0]
 8110b00:	687a      	ldr	r2, [r7, #4]
 8110b02:	429a      	cmp	r2, r3
 8110b04:	d102      	bne.n	8110b0c <etharp_find_entry+0xc8>
#endif /* ETHARP_TABLE_MATCH_NETIF */
         ) {
        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: found matching entry %d\n", (int)i));
        /* found exact IP address match, simply bail out */
        return i;
 8110b06:	f9b7 3020 	ldrsh.w	r3, [r7, #32]
 8110b0a:	e100      	b.n	8110d0e <etharp_find_entry+0x2ca>
      }
      /* pending entry? */
      if (state == ETHARP_STATE_PENDING) {
 8110b0c:	7dfb      	ldrb	r3, [r7, #23]
 8110b0e:	2b01      	cmp	r3, #1
 8110b10:	d140      	bne.n	8110b94 <etharp_find_entry+0x150>
        /* pending with queued packets? */
        if (arp_table[i].q != NULL) {
 8110b12:	f9b7 2020 	ldrsh.w	r2, [r7, #32]
 8110b16:	4980      	ldr	r1, [pc, #512]	; (8110d18 <etharp_find_entry+0x2d4>)
 8110b18:	4613      	mov	r3, r2
 8110b1a:	005b      	lsls	r3, r3, #1
 8110b1c:	4413      	add	r3, r2
 8110b1e:	00db      	lsls	r3, r3, #3
 8110b20:	440b      	add	r3, r1
 8110b22:	681b      	ldr	r3, [r3, #0]
 8110b24:	2b00      	cmp	r3, #0
 8110b26:	d01a      	beq.n	8110b5e <etharp_find_entry+0x11a>
          if (arp_table[i].ctime >= age_queue) {
 8110b28:	f9b7 2020 	ldrsh.w	r2, [r7, #32]
 8110b2c:	497a      	ldr	r1, [pc, #488]	; (8110d18 <etharp_find_entry+0x2d4>)
 8110b2e:	4613      	mov	r3, r2
 8110b30:	005b      	lsls	r3, r3, #1
 8110b32:	4413      	add	r3, r2
 8110b34:	00db      	lsls	r3, r3, #3
 8110b36:	440b      	add	r3, r1
 8110b38:	3312      	adds	r3, #18
 8110b3a:	881b      	ldrh	r3, [r3, #0]
 8110b3c:	8bba      	ldrh	r2, [r7, #28]
 8110b3e:	429a      	cmp	r2, r3
 8110b40:	d845      	bhi.n	8110bce <etharp_find_entry+0x18a>
            old_queue = i;
 8110b42:	8c3b      	ldrh	r3, [r7, #32]
 8110b44:	83fb      	strh	r3, [r7, #30]
            age_queue = arp_table[i].ctime;
 8110b46:	f9b7 2020 	ldrsh.w	r2, [r7, #32]
 8110b4a:	4973      	ldr	r1, [pc, #460]	; (8110d18 <etharp_find_entry+0x2d4>)
 8110b4c:	4613      	mov	r3, r2
 8110b4e:	005b      	lsls	r3, r3, #1
 8110b50:	4413      	add	r3, r2
 8110b52:	00db      	lsls	r3, r3, #3
 8110b54:	440b      	add	r3, r1
 8110b56:	3312      	adds	r3, #18
 8110b58:	881b      	ldrh	r3, [r3, #0]
 8110b5a:	83bb      	strh	r3, [r7, #28]
 8110b5c:	e037      	b.n	8110bce <etharp_find_entry+0x18a>
          }
        } else
          /* pending without queued packets? */
        {
          if (arp_table[i].ctime >= age_pending) {
 8110b5e:	f9b7 2020 	ldrsh.w	r2, [r7, #32]
 8110b62:	496d      	ldr	r1, [pc, #436]	; (8110d18 <etharp_find_entry+0x2d4>)
 8110b64:	4613      	mov	r3, r2
 8110b66:	005b      	lsls	r3, r3, #1
 8110b68:	4413      	add	r3, r2
 8110b6a:	00db      	lsls	r3, r3, #3
 8110b6c:	440b      	add	r3, r1
 8110b6e:	3312      	adds	r3, #18
 8110b70:	881b      	ldrh	r3, [r3, #0]
 8110b72:	8b7a      	ldrh	r2, [r7, #26]
 8110b74:	429a      	cmp	r2, r3
 8110b76:	d82a      	bhi.n	8110bce <etharp_find_entry+0x18a>
            old_pending = i;
 8110b78:	8c3b      	ldrh	r3, [r7, #32]
 8110b7a:	84fb      	strh	r3, [r7, #38]	; 0x26
            age_pending = arp_table[i].ctime;
 8110b7c:	f9b7 2020 	ldrsh.w	r2, [r7, #32]
 8110b80:	4965      	ldr	r1, [pc, #404]	; (8110d18 <etharp_find_entry+0x2d4>)
 8110b82:	4613      	mov	r3, r2
 8110b84:	005b      	lsls	r3, r3, #1
 8110b86:	4413      	add	r3, r2
 8110b88:	00db      	lsls	r3, r3, #3
 8110b8a:	440b      	add	r3, r1
 8110b8c:	3312      	adds	r3, #18
 8110b8e:	881b      	ldrh	r3, [r3, #0]
 8110b90:	837b      	strh	r3, [r7, #26]
 8110b92:	e01c      	b.n	8110bce <etharp_find_entry+0x18a>
          }
        }
        /* stable entry? */
      } else if (state >= ETHARP_STATE_STABLE) {
 8110b94:	7dfb      	ldrb	r3, [r7, #23]
 8110b96:	2b01      	cmp	r3, #1
 8110b98:	d919      	bls.n	8110bce <etharp_find_entry+0x18a>
        /* don't record old_stable for static entries since they never expire */
        if (state < ETHARP_STATE_STATIC)
#endif /* ETHARP_SUPPORT_STATIC_ENTRIES */
        {
          /* remember entry with oldest stable entry in oldest, its age in maxtime */
          if (arp_table[i].ctime >= age_stable) {
 8110b9a:	f9b7 2020 	ldrsh.w	r2, [r7, #32]
 8110b9e:	495e      	ldr	r1, [pc, #376]	; (8110d18 <etharp_find_entry+0x2d4>)
 8110ba0:	4613      	mov	r3, r2
 8110ba2:	005b      	lsls	r3, r3, #1
 8110ba4:	4413      	add	r3, r2
 8110ba6:	00db      	lsls	r3, r3, #3
 8110ba8:	440b      	add	r3, r1
 8110baa:	3312      	adds	r3, #18
 8110bac:	881b      	ldrh	r3, [r3, #0]
 8110bae:	8b3a      	ldrh	r2, [r7, #24]
 8110bb0:	429a      	cmp	r2, r3
 8110bb2:	d80c      	bhi.n	8110bce <etharp_find_entry+0x18a>
            old_stable = i;
 8110bb4:	8c3b      	ldrh	r3, [r7, #32]
 8110bb6:	84bb      	strh	r3, [r7, #36]	; 0x24
            age_stable = arp_table[i].ctime;
 8110bb8:	f9b7 2020 	ldrsh.w	r2, [r7, #32]
 8110bbc:	4956      	ldr	r1, [pc, #344]	; (8110d18 <etharp_find_entry+0x2d4>)
 8110bbe:	4613      	mov	r3, r2
 8110bc0:	005b      	lsls	r3, r3, #1
 8110bc2:	4413      	add	r3, r2
 8110bc4:	00db      	lsls	r3, r3, #3
 8110bc6:	440b      	add	r3, r1
 8110bc8:	3312      	adds	r3, #18
 8110bca:	881b      	ldrh	r3, [r3, #0]
 8110bcc:	833b      	strh	r3, [r7, #24]
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
 8110bce:	8c3b      	ldrh	r3, [r7, #32]
 8110bd0:	3301      	adds	r3, #1
 8110bd2:	b29b      	uxth	r3, r3
 8110bd4:	843b      	strh	r3, [r7, #32]
 8110bd6:	f9b7 3020 	ldrsh.w	r3, [r7, #32]
 8110bda:	2b09      	cmp	r3, #9
 8110bdc:	f77f af4c 	ble.w	8110a78 <etharp_find_entry+0x34>
    }
  }
  /* { we have no match } => try to create a new entry */

  /* don't create new entry, only search? */
  if (((flags & ETHARP_FLAG_FIND_ONLY) != 0) ||
 8110be0:	7afb      	ldrb	r3, [r7, #11]
 8110be2:	f003 0302 	and.w	r3, r3, #2
 8110be6:	2b00      	cmp	r3, #0
 8110be8:	d108      	bne.n	8110bfc <etharp_find_entry+0x1b8>
 8110bea:	f9b7 3022 	ldrsh.w	r3, [r7, #34]	; 0x22
 8110bee:	2b0a      	cmp	r3, #10
 8110bf0:	d107      	bne.n	8110c02 <etharp_find_entry+0x1be>
      /* or no empty entry found and not allowed to recycle? */
      ((empty == ARP_TABLE_SIZE) && ((flags & ETHARP_FLAG_TRY_HARD) == 0))) {
 8110bf2:	7afb      	ldrb	r3, [r7, #11]
 8110bf4:	f003 0301 	and.w	r3, r3, #1
 8110bf8:	2b00      	cmp	r3, #0
 8110bfa:	d102      	bne.n	8110c02 <etharp_find_entry+0x1be>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: no empty entry found and not allowed to recycle\n"));
    return (s16_t)ERR_MEM;
 8110bfc:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 8110c00:	e085      	b.n	8110d0e <etharp_find_entry+0x2ca>
   *
   * { ETHARP_FLAG_TRY_HARD is set at this point }
   */

  /* 1) empty entry available? */
  if (empty < ARP_TABLE_SIZE) {
 8110c02:	f9b7 3022 	ldrsh.w	r3, [r7, #34]	; 0x22
 8110c06:	2b09      	cmp	r3, #9
 8110c08:	dc02      	bgt.n	8110c10 <etharp_find_entry+0x1cc>
    i = empty;
 8110c0a:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
 8110c0c:	843b      	strh	r3, [r7, #32]
 8110c0e:	e039      	b.n	8110c84 <etharp_find_entry+0x240>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: selecting empty entry %d\n", (int)i));
  } else {
    /* 2) found recyclable stable entry? */
    if (old_stable < ARP_TABLE_SIZE) {
 8110c10:	f9b7 3024 	ldrsh.w	r3, [r7, #36]	; 0x24
 8110c14:	2b09      	cmp	r3, #9
 8110c16:	dc14      	bgt.n	8110c42 <etharp_find_entry+0x1fe>
      /* recycle oldest stable*/
      i = old_stable;
 8110c18:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
 8110c1a:	843b      	strh	r3, [r7, #32]
      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: selecting oldest stable entry %d\n", (int)i));
      /* no queued packets should exist on stable entries */
      LWIP_ASSERT("arp_table[i].q == NULL", arp_table[i].q == NULL);
 8110c1c:	f9b7 2020 	ldrsh.w	r2, [r7, #32]
 8110c20:	493d      	ldr	r1, [pc, #244]	; (8110d18 <etharp_find_entry+0x2d4>)
 8110c22:	4613      	mov	r3, r2
 8110c24:	005b      	lsls	r3, r3, #1
 8110c26:	4413      	add	r3, r2
 8110c28:	00db      	lsls	r3, r3, #3
 8110c2a:	440b      	add	r3, r1
 8110c2c:	681b      	ldr	r3, [r3, #0]
 8110c2e:	2b00      	cmp	r3, #0
 8110c30:	d018      	beq.n	8110c64 <etharp_find_entry+0x220>
 8110c32:	4b3a      	ldr	r3, [pc, #232]	; (8110d1c <etharp_find_entry+0x2d8>)
 8110c34:	f240 126d 	movw	r2, #365	; 0x16d
 8110c38:	493b      	ldr	r1, [pc, #236]	; (8110d28 <etharp_find_entry+0x2e4>)
 8110c3a:	483a      	ldr	r0, [pc, #232]	; (8110d24 <etharp_find_entry+0x2e0>)
 8110c3c:	f00a fde0 	bl	811b800 <iprintf>
 8110c40:	e010      	b.n	8110c64 <etharp_find_entry+0x220>
      /* 3) found recyclable pending entry without queued packets? */
    } else if (old_pending < ARP_TABLE_SIZE) {
 8110c42:	f9b7 3026 	ldrsh.w	r3, [r7, #38]	; 0x26
 8110c46:	2b09      	cmp	r3, #9
 8110c48:	dc02      	bgt.n	8110c50 <etharp_find_entry+0x20c>
      /* recycle oldest pending */
      i = old_pending;
 8110c4a:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 8110c4c:	843b      	strh	r3, [r7, #32]
 8110c4e:	e009      	b.n	8110c64 <etharp_find_entry+0x220>
      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: selecting oldest pending entry %d (without queue)\n", (int)i));
      /* 4) found recyclable pending entry with queued packets? */
    } else if (old_queue < ARP_TABLE_SIZE) {
 8110c50:	f9b7 301e 	ldrsh.w	r3, [r7, #30]
 8110c54:	2b09      	cmp	r3, #9
 8110c56:	dc02      	bgt.n	8110c5e <etharp_find_entry+0x21a>
      /* recycle oldest pending (queued packets are free in etharp_free_entry) */
      i = old_queue;
 8110c58:	8bfb      	ldrh	r3, [r7, #30]
 8110c5a:	843b      	strh	r3, [r7, #32]
 8110c5c:	e002      	b.n	8110c64 <etharp_find_entry+0x220>
      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: selecting oldest pending entry %d, freeing packet queue %p\n", (int)i, (void *)(arp_table[i].q)));
      /* no empty or recyclable entries found */
    } else {
      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: no empty or recyclable entries found\n"));
      return (s16_t)ERR_MEM;
 8110c5e:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 8110c62:	e054      	b.n	8110d0e <etharp_find_entry+0x2ca>
    }

    /* { empty or recyclable entry found } */
    LWIP_ASSERT("i < ARP_TABLE_SIZE", i < ARP_TABLE_SIZE);
 8110c64:	f9b7 3020 	ldrsh.w	r3, [r7, #32]
 8110c68:	2b09      	cmp	r3, #9
 8110c6a:	dd06      	ble.n	8110c7a <etharp_find_entry+0x236>
 8110c6c:	4b2b      	ldr	r3, [pc, #172]	; (8110d1c <etharp_find_entry+0x2d8>)
 8110c6e:	f240 127f 	movw	r2, #383	; 0x17f
 8110c72:	492e      	ldr	r1, [pc, #184]	; (8110d2c <etharp_find_entry+0x2e8>)
 8110c74:	482b      	ldr	r0, [pc, #172]	; (8110d24 <etharp_find_entry+0x2e0>)
 8110c76:	f00a fdc3 	bl	811b800 <iprintf>
    etharp_free_entry(i);
 8110c7a:	f9b7 3020 	ldrsh.w	r3, [r7, #32]
 8110c7e:	4618      	mov	r0, r3
 8110c80:	f7ff fe06 	bl	8110890 <etharp_free_entry>
  }

  LWIP_ASSERT("i < ARP_TABLE_SIZE", i < ARP_TABLE_SIZE);
 8110c84:	f9b7 3020 	ldrsh.w	r3, [r7, #32]
 8110c88:	2b09      	cmp	r3, #9
 8110c8a:	dd06      	ble.n	8110c9a <etharp_find_entry+0x256>
 8110c8c:	4b23      	ldr	r3, [pc, #140]	; (8110d1c <etharp_find_entry+0x2d8>)
 8110c8e:	f240 1283 	movw	r2, #387	; 0x183
 8110c92:	4926      	ldr	r1, [pc, #152]	; (8110d2c <etharp_find_entry+0x2e8>)
 8110c94:	4823      	ldr	r0, [pc, #140]	; (8110d24 <etharp_find_entry+0x2e0>)
 8110c96:	f00a fdb3 	bl	811b800 <iprintf>
  LWIP_ASSERT("arp_table[i].state == ETHARP_STATE_EMPTY",
 8110c9a:	f9b7 2020 	ldrsh.w	r2, [r7, #32]
 8110c9e:	491e      	ldr	r1, [pc, #120]	; (8110d18 <etharp_find_entry+0x2d4>)
 8110ca0:	4613      	mov	r3, r2
 8110ca2:	005b      	lsls	r3, r3, #1
 8110ca4:	4413      	add	r3, r2
 8110ca6:	00db      	lsls	r3, r3, #3
 8110ca8:	440b      	add	r3, r1
 8110caa:	3314      	adds	r3, #20
 8110cac:	781b      	ldrb	r3, [r3, #0]
 8110cae:	2b00      	cmp	r3, #0
 8110cb0:	d006      	beq.n	8110cc0 <etharp_find_entry+0x27c>
 8110cb2:	4b1a      	ldr	r3, [pc, #104]	; (8110d1c <etharp_find_entry+0x2d8>)
 8110cb4:	f44f 72c2 	mov.w	r2, #388	; 0x184
 8110cb8:	491d      	ldr	r1, [pc, #116]	; (8110d30 <etharp_find_entry+0x2ec>)
 8110cba:	481a      	ldr	r0, [pc, #104]	; (8110d24 <etharp_find_entry+0x2e0>)
 8110cbc:	f00a fda0 	bl	811b800 <iprintf>
              arp_table[i].state == ETHARP_STATE_EMPTY);

  /* IP address given? */
  if (ipaddr != NULL) {
 8110cc0:	68fb      	ldr	r3, [r7, #12]
 8110cc2:	2b00      	cmp	r3, #0
 8110cc4:	d00b      	beq.n	8110cde <etharp_find_entry+0x29a>
    /* set IP address */
    ip4_addr_copy(arp_table[i].ipaddr, *ipaddr);
 8110cc6:	f9b7 2020 	ldrsh.w	r2, [r7, #32]
 8110cca:	68fb      	ldr	r3, [r7, #12]
 8110ccc:	6819      	ldr	r1, [r3, #0]
 8110cce:	4812      	ldr	r0, [pc, #72]	; (8110d18 <etharp_find_entry+0x2d4>)
 8110cd0:	4613      	mov	r3, r2
 8110cd2:	005b      	lsls	r3, r3, #1
 8110cd4:	4413      	add	r3, r2
 8110cd6:	00db      	lsls	r3, r3, #3
 8110cd8:	4403      	add	r3, r0
 8110cda:	3304      	adds	r3, #4
 8110cdc:	6019      	str	r1, [r3, #0]
  }
  arp_table[i].ctime = 0;
 8110cde:	f9b7 2020 	ldrsh.w	r2, [r7, #32]
 8110ce2:	490d      	ldr	r1, [pc, #52]	; (8110d18 <etharp_find_entry+0x2d4>)
 8110ce4:	4613      	mov	r3, r2
 8110ce6:	005b      	lsls	r3, r3, #1
 8110ce8:	4413      	add	r3, r2
 8110cea:	00db      	lsls	r3, r3, #3
 8110cec:	440b      	add	r3, r1
 8110cee:	3312      	adds	r3, #18
 8110cf0:	2200      	movs	r2, #0
 8110cf2:	801a      	strh	r2, [r3, #0]
#if ETHARP_TABLE_MATCH_NETIF
  arp_table[i].netif = netif;
 8110cf4:	f9b7 2020 	ldrsh.w	r2, [r7, #32]
 8110cf8:	4907      	ldr	r1, [pc, #28]	; (8110d18 <etharp_find_entry+0x2d4>)
 8110cfa:	4613      	mov	r3, r2
 8110cfc:	005b      	lsls	r3, r3, #1
 8110cfe:	4413      	add	r3, r2
 8110d00:	00db      	lsls	r3, r3, #3
 8110d02:	440b      	add	r3, r1
 8110d04:	3308      	adds	r3, #8
 8110d06:	687a      	ldr	r2, [r7, #4]
 8110d08:	601a      	str	r2, [r3, #0]
#endif /* ETHARP_TABLE_MATCH_NETIF */
  return (s16_t)i;
 8110d0a:	f9b7 3020 	ldrsh.w	r3, [r7, #32]
}
 8110d0e:	4618      	mov	r0, r3
 8110d10:	3728      	adds	r7, #40	; 0x28
 8110d12:	46bd      	mov	sp, r7
 8110d14:	bd80      	pop	{r7, pc}
 8110d16:	bf00      	nop
 8110d18:	100053fc 	.word	0x100053fc
 8110d1c:	0811cc48 	.word	0x0811cc48
 8110d20:	0811ccb4 	.word	0x0811ccb4
 8110d24:	0811ccf4 	.word	0x0811ccf4
 8110d28:	0811cd1c 	.word	0x0811cd1c
 8110d2c:	0811cd34 	.word	0x0811cd34
 8110d30:	0811cd48 	.word	0x0811cd48

08110d34 <etharp_update_arp_entry>:
 *
 * @see pbuf_free()
 */
static err_t
etharp_update_arp_entry(struct netif *netif, const ip4_addr_t *ipaddr, struct eth_addr *ethaddr, u8_t flags)
{
 8110d34:	b580      	push	{r7, lr}
 8110d36:	b088      	sub	sp, #32
 8110d38:	af02      	add	r7, sp, #8
 8110d3a:	60f8      	str	r0, [r7, #12]
 8110d3c:	60b9      	str	r1, [r7, #8]
 8110d3e:	607a      	str	r2, [r7, #4]
 8110d40:	70fb      	strb	r3, [r7, #3]
  s16_t i;
  LWIP_ASSERT("netif->hwaddr_len == ETH_HWADDR_LEN", netif->hwaddr_len == ETH_HWADDR_LEN);
 8110d42:	68fb      	ldr	r3, [r7, #12]
 8110d44:	f893 3030 	ldrb.w	r3, [r3, #48]	; 0x30
 8110d48:	2b06      	cmp	r3, #6
 8110d4a:	d006      	beq.n	8110d5a <etharp_update_arp_entry+0x26>
 8110d4c:	4b48      	ldr	r3, [pc, #288]	; (8110e70 <etharp_update_arp_entry+0x13c>)
 8110d4e:	f240 12a9 	movw	r2, #425	; 0x1a9
 8110d52:	4948      	ldr	r1, [pc, #288]	; (8110e74 <etharp_update_arp_entry+0x140>)
 8110d54:	4848      	ldr	r0, [pc, #288]	; (8110e78 <etharp_update_arp_entry+0x144>)
 8110d56:	f00a fd53 	bl	811b800 <iprintf>
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_update_arp_entry: %"U16_F".%"U16_F".%"U16_F".%"U16_F" - %02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F"\n",
              ip4_addr1_16(ipaddr), ip4_addr2_16(ipaddr), ip4_addr3_16(ipaddr), ip4_addr4_16(ipaddr),
              (u16_t)ethaddr->addr[0], (u16_t)ethaddr->addr[1], (u16_t)ethaddr->addr[2],
              (u16_t)ethaddr->addr[3], (u16_t)ethaddr->addr[4], (u16_t)ethaddr->addr[5]));
  /* non-unicast address? */
  if (ip4_addr_isany(ipaddr) ||
 8110d5a:	68bb      	ldr	r3, [r7, #8]
 8110d5c:	2b00      	cmp	r3, #0
 8110d5e:	d012      	beq.n	8110d86 <etharp_update_arp_entry+0x52>
 8110d60:	68bb      	ldr	r3, [r7, #8]
 8110d62:	681b      	ldr	r3, [r3, #0]
 8110d64:	2b00      	cmp	r3, #0
 8110d66:	d00e      	beq.n	8110d86 <etharp_update_arp_entry+0x52>
      ip4_addr_isbroadcast(ipaddr, netif) ||
 8110d68:	68bb      	ldr	r3, [r7, #8]
 8110d6a:	681b      	ldr	r3, [r3, #0]
 8110d6c:	68f9      	ldr	r1, [r7, #12]
 8110d6e:	4618      	mov	r0, r3
 8110d70:	f001 faf0 	bl	8112354 <ip4_addr_isbroadcast_u32>
 8110d74:	4603      	mov	r3, r0
  if (ip4_addr_isany(ipaddr) ||
 8110d76:	2b00      	cmp	r3, #0
 8110d78:	d105      	bne.n	8110d86 <etharp_update_arp_entry+0x52>
      ip4_addr_ismulticast(ipaddr)) {
 8110d7a:	68bb      	ldr	r3, [r7, #8]
 8110d7c:	681b      	ldr	r3, [r3, #0]
 8110d7e:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
      ip4_addr_isbroadcast(ipaddr, netif) ||
 8110d82:	2be0      	cmp	r3, #224	; 0xe0
 8110d84:	d102      	bne.n	8110d8c <etharp_update_arp_entry+0x58>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_update_arp_entry: will not add non-unicast IP address to ARP cache\n"));
    return ERR_ARG;
 8110d86:	f06f 030f 	mvn.w	r3, #15
 8110d8a:	e06c      	b.n	8110e66 <etharp_update_arp_entry+0x132>
  }
  /* find or create ARP entry */
  i = etharp_find_entry(ipaddr, flags, netif);
 8110d8c:	78fb      	ldrb	r3, [r7, #3]
 8110d8e:	68fa      	ldr	r2, [r7, #12]
 8110d90:	4619      	mov	r1, r3
 8110d92:	68b8      	ldr	r0, [r7, #8]
 8110d94:	f7ff fe56 	bl	8110a44 <etharp_find_entry>
 8110d98:	4603      	mov	r3, r0
 8110d9a:	82fb      	strh	r3, [r7, #22]
  /* bail out if no entry could be found */
  if (i < 0) {
 8110d9c:	f9b7 3016 	ldrsh.w	r3, [r7, #22]
 8110da0:	2b00      	cmp	r3, #0
 8110da2:	da02      	bge.n	8110daa <etharp_update_arp_entry+0x76>
    return (err_t)i;
 8110da4:	8afb      	ldrh	r3, [r7, #22]
 8110da6:	b25b      	sxtb	r3, r3
 8110da8:	e05d      	b.n	8110e66 <etharp_update_arp_entry+0x132>
    return ERR_VAL;
  } else
#endif /* ETHARP_SUPPORT_STATIC_ENTRIES */
  {
    /* mark it stable */
    arp_table[i].state = ETHARP_STATE_STABLE;
 8110daa:	f9b7 2016 	ldrsh.w	r2, [r7, #22]
 8110dae:	4933      	ldr	r1, [pc, #204]	; (8110e7c <etharp_update_arp_entry+0x148>)
 8110db0:	4613      	mov	r3, r2
 8110db2:	005b      	lsls	r3, r3, #1
 8110db4:	4413      	add	r3, r2
 8110db6:	00db      	lsls	r3, r3, #3
 8110db8:	440b      	add	r3, r1
 8110dba:	3314      	adds	r3, #20
 8110dbc:	2202      	movs	r2, #2
 8110dbe:	701a      	strb	r2, [r3, #0]
  }

  /* record network interface */
  arp_table[i].netif = netif;
 8110dc0:	f9b7 2016 	ldrsh.w	r2, [r7, #22]
 8110dc4:	492d      	ldr	r1, [pc, #180]	; (8110e7c <etharp_update_arp_entry+0x148>)
 8110dc6:	4613      	mov	r3, r2
 8110dc8:	005b      	lsls	r3, r3, #1
 8110dca:	4413      	add	r3, r2
 8110dcc:	00db      	lsls	r3, r3, #3
 8110dce:	440b      	add	r3, r1
 8110dd0:	3308      	adds	r3, #8
 8110dd2:	68fa      	ldr	r2, [r7, #12]
 8110dd4:	601a      	str	r2, [r3, #0]
  /* insert in SNMP ARP index tree */
  mib2_add_arp_entry(netif, &arp_table[i].ipaddr);

  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_update_arp_entry: updating stable entry %"S16_F"\n", i));
  /* update address */
  SMEMCPY(&arp_table[i].ethaddr, ethaddr, ETH_HWADDR_LEN);
 8110dd6:	f9b7 2016 	ldrsh.w	r2, [r7, #22]
 8110dda:	4613      	mov	r3, r2
 8110ddc:	005b      	lsls	r3, r3, #1
 8110dde:	4413      	add	r3, r2
 8110de0:	00db      	lsls	r3, r3, #3
 8110de2:	3308      	adds	r3, #8
 8110de4:	4a25      	ldr	r2, [pc, #148]	; (8110e7c <etharp_update_arp_entry+0x148>)
 8110de6:	4413      	add	r3, r2
 8110de8:	3304      	adds	r3, #4
 8110dea:	2206      	movs	r2, #6
 8110dec:	6879      	ldr	r1, [r7, #4]
 8110dee:	4618      	mov	r0, r3
 8110df0:	f00a fd5e 	bl	811b8b0 <memcpy>
  /* reset time stamp */
  arp_table[i].ctime = 0;
 8110df4:	f9b7 2016 	ldrsh.w	r2, [r7, #22]
 8110df8:	4920      	ldr	r1, [pc, #128]	; (8110e7c <etharp_update_arp_entry+0x148>)
 8110dfa:	4613      	mov	r3, r2
 8110dfc:	005b      	lsls	r3, r3, #1
 8110dfe:	4413      	add	r3, r2
 8110e00:	00db      	lsls	r3, r3, #3
 8110e02:	440b      	add	r3, r1
 8110e04:	3312      	adds	r3, #18
 8110e06:	2200      	movs	r2, #0
 8110e08:	801a      	strh	r2, [r3, #0]
    /* get the packet pointer */
    p = q->p;
    /* now queue entry can be freed */
    memp_free(MEMP_ARP_QUEUE, q);
#else /* ARP_QUEUEING */
  if (arp_table[i].q != NULL) {
 8110e0a:	f9b7 2016 	ldrsh.w	r2, [r7, #22]
 8110e0e:	491b      	ldr	r1, [pc, #108]	; (8110e7c <etharp_update_arp_entry+0x148>)
 8110e10:	4613      	mov	r3, r2
 8110e12:	005b      	lsls	r3, r3, #1
 8110e14:	4413      	add	r3, r2
 8110e16:	00db      	lsls	r3, r3, #3
 8110e18:	440b      	add	r3, r1
 8110e1a:	681b      	ldr	r3, [r3, #0]
 8110e1c:	2b00      	cmp	r3, #0
 8110e1e:	d021      	beq.n	8110e64 <etharp_update_arp_entry+0x130>
    struct pbuf *p = arp_table[i].q;
 8110e20:	f9b7 2016 	ldrsh.w	r2, [r7, #22]
 8110e24:	4915      	ldr	r1, [pc, #84]	; (8110e7c <etharp_update_arp_entry+0x148>)
 8110e26:	4613      	mov	r3, r2
 8110e28:	005b      	lsls	r3, r3, #1
 8110e2a:	4413      	add	r3, r2
 8110e2c:	00db      	lsls	r3, r3, #3
 8110e2e:	440b      	add	r3, r1
 8110e30:	681b      	ldr	r3, [r3, #0]
 8110e32:	613b      	str	r3, [r7, #16]
    arp_table[i].q = NULL;
 8110e34:	f9b7 2016 	ldrsh.w	r2, [r7, #22]
 8110e38:	4910      	ldr	r1, [pc, #64]	; (8110e7c <etharp_update_arp_entry+0x148>)
 8110e3a:	4613      	mov	r3, r2
 8110e3c:	005b      	lsls	r3, r3, #1
 8110e3e:	4413      	add	r3, r2
 8110e40:	00db      	lsls	r3, r3, #3
 8110e42:	440b      	add	r3, r1
 8110e44:	2200      	movs	r2, #0
 8110e46:	601a      	str	r2, [r3, #0]
#endif /* ARP_QUEUEING */
    /* send the queued IP packet */
    ethernet_output(netif, p, (struct eth_addr *)(netif->hwaddr), ethaddr, ETHTYPE_IP);
 8110e48:	68fb      	ldr	r3, [r7, #12]
 8110e4a:	f103 022a 	add.w	r2, r3, #42	; 0x2a
 8110e4e:	f44f 6300 	mov.w	r3, #2048	; 0x800
 8110e52:	9300      	str	r3, [sp, #0]
 8110e54:	687b      	ldr	r3, [r7, #4]
 8110e56:	6939      	ldr	r1, [r7, #16]
 8110e58:	68f8      	ldr	r0, [r7, #12]
 8110e5a:	f000 fcf7 	bl	811184c <ethernet_output>
    /* free the queued IP packet */
    pbuf_free(p);
 8110e5e:	6938      	ldr	r0, [r7, #16]
 8110e60:	f003 fbfa 	bl	8114658 <pbuf_free>
  }
  return ERR_OK;
 8110e64:	2300      	movs	r3, #0
}
 8110e66:	4618      	mov	r0, r3
 8110e68:	3718      	adds	r7, #24
 8110e6a:	46bd      	mov	sp, r7
 8110e6c:	bd80      	pop	{r7, pc}
 8110e6e:	bf00      	nop
 8110e70:	0811cc48 	.word	0x0811cc48
 8110e74:	0811cd74 	.word	0x0811cd74
 8110e78:	0811ccf4 	.word	0x0811ccf4
 8110e7c:	100053fc 	.word	0x100053fc

08110e80 <etharp_cleanup_netif>:
 *
 * @param netif points to a network interface
 */
void
etharp_cleanup_netif(struct netif *netif)
{
 8110e80:	b580      	push	{r7, lr}
 8110e82:	b084      	sub	sp, #16
 8110e84:	af00      	add	r7, sp, #0
 8110e86:	6078      	str	r0, [r7, #4]
  int i;

  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
 8110e88:	2300      	movs	r3, #0
 8110e8a:	60fb      	str	r3, [r7, #12]
 8110e8c:	e01e      	b.n	8110ecc <etharp_cleanup_netif+0x4c>
    u8_t state = arp_table[i].state;
 8110e8e:	4913      	ldr	r1, [pc, #76]	; (8110edc <etharp_cleanup_netif+0x5c>)
 8110e90:	68fa      	ldr	r2, [r7, #12]
 8110e92:	4613      	mov	r3, r2
 8110e94:	005b      	lsls	r3, r3, #1
 8110e96:	4413      	add	r3, r2
 8110e98:	00db      	lsls	r3, r3, #3
 8110e9a:	440b      	add	r3, r1
 8110e9c:	3314      	adds	r3, #20
 8110e9e:	781b      	ldrb	r3, [r3, #0]
 8110ea0:	72fb      	strb	r3, [r7, #11]
    if ((state != ETHARP_STATE_EMPTY) && (arp_table[i].netif == netif)) {
 8110ea2:	7afb      	ldrb	r3, [r7, #11]
 8110ea4:	2b00      	cmp	r3, #0
 8110ea6:	d00e      	beq.n	8110ec6 <etharp_cleanup_netif+0x46>
 8110ea8:	490c      	ldr	r1, [pc, #48]	; (8110edc <etharp_cleanup_netif+0x5c>)
 8110eaa:	68fa      	ldr	r2, [r7, #12]
 8110eac:	4613      	mov	r3, r2
 8110eae:	005b      	lsls	r3, r3, #1
 8110eb0:	4413      	add	r3, r2
 8110eb2:	00db      	lsls	r3, r3, #3
 8110eb4:	440b      	add	r3, r1
 8110eb6:	3308      	adds	r3, #8
 8110eb8:	681b      	ldr	r3, [r3, #0]
 8110eba:	687a      	ldr	r2, [r7, #4]
 8110ebc:	429a      	cmp	r2, r3
 8110ebe:	d102      	bne.n	8110ec6 <etharp_cleanup_netif+0x46>
      etharp_free_entry(i);
 8110ec0:	68f8      	ldr	r0, [r7, #12]
 8110ec2:	f7ff fce5 	bl	8110890 <etharp_free_entry>
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
 8110ec6:	68fb      	ldr	r3, [r7, #12]
 8110ec8:	3301      	adds	r3, #1
 8110eca:	60fb      	str	r3, [r7, #12]
 8110ecc:	68fb      	ldr	r3, [r7, #12]
 8110ece:	2b09      	cmp	r3, #9
 8110ed0:	dddd      	ble.n	8110e8e <etharp_cleanup_netif+0xe>
    }
  }
}
 8110ed2:	bf00      	nop
 8110ed4:	bf00      	nop
 8110ed6:	3710      	adds	r7, #16
 8110ed8:	46bd      	mov	sp, r7
 8110eda:	bd80      	pop	{r7, pc}
 8110edc:	100053fc 	.word	0x100053fc

08110ee0 <etharp_input>:
 *
 * @see pbuf_free()
 */
void
etharp_input(struct pbuf *p, struct netif *netif)
{
 8110ee0:	b5b0      	push	{r4, r5, r7, lr}
 8110ee2:	b08a      	sub	sp, #40	; 0x28
 8110ee4:	af04      	add	r7, sp, #16
 8110ee6:	6078      	str	r0, [r7, #4]
 8110ee8:	6039      	str	r1, [r7, #0]
  ip4_addr_t sipaddr, dipaddr;
  u8_t for_us;

  LWIP_ASSERT_CORE_LOCKED();

  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
 8110eea:	683b      	ldr	r3, [r7, #0]
 8110eec:	2b00      	cmp	r3, #0
 8110eee:	d107      	bne.n	8110f00 <etharp_input+0x20>
 8110ef0:	4b3f      	ldr	r3, [pc, #252]	; (8110ff0 <etharp_input+0x110>)
 8110ef2:	f240 228a 	movw	r2, #650	; 0x28a
 8110ef6:	493f      	ldr	r1, [pc, #252]	; (8110ff4 <etharp_input+0x114>)
 8110ef8:	483f      	ldr	r0, [pc, #252]	; (8110ff8 <etharp_input+0x118>)
 8110efa:	f00a fc81 	bl	811b800 <iprintf>
 8110efe:	e074      	b.n	8110fea <etharp_input+0x10a>

  hdr = (struct etharp_hdr *)p->payload;
 8110f00:	687b      	ldr	r3, [r7, #4]
 8110f02:	685b      	ldr	r3, [r3, #4]
 8110f04:	613b      	str	r3, [r7, #16]

  /* RFC 826 "Packet Reception": */
  if ((hdr->hwtype != PP_HTONS(LWIP_IANA_HWTYPE_ETHERNET)) ||
 8110f06:	693b      	ldr	r3, [r7, #16]
 8110f08:	881b      	ldrh	r3, [r3, #0]
 8110f0a:	b29b      	uxth	r3, r3
 8110f0c:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 8110f10:	d10c      	bne.n	8110f2c <etharp_input+0x4c>
      (hdr->hwlen != ETH_HWADDR_LEN) ||
 8110f12:	693b      	ldr	r3, [r7, #16]
 8110f14:	791b      	ldrb	r3, [r3, #4]
  if ((hdr->hwtype != PP_HTONS(LWIP_IANA_HWTYPE_ETHERNET)) ||
 8110f16:	2b06      	cmp	r3, #6
 8110f18:	d108      	bne.n	8110f2c <etharp_input+0x4c>
      (hdr->protolen != sizeof(ip4_addr_t)) ||
 8110f1a:	693b      	ldr	r3, [r7, #16]
 8110f1c:	795b      	ldrb	r3, [r3, #5]
      (hdr->hwlen != ETH_HWADDR_LEN) ||
 8110f1e:	2b04      	cmp	r3, #4
 8110f20:	d104      	bne.n	8110f2c <etharp_input+0x4c>
      (hdr->proto != PP_HTONS(ETHTYPE_IP)))  {
 8110f22:	693b      	ldr	r3, [r7, #16]
 8110f24:	885b      	ldrh	r3, [r3, #2]
 8110f26:	b29b      	uxth	r3, r3
      (hdr->protolen != sizeof(ip4_addr_t)) ||
 8110f28:	2b08      	cmp	r3, #8
 8110f2a:	d003      	beq.n	8110f34 <etharp_input+0x54>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING,
                ("etharp_input: packet dropped, wrong hw type, hwlen, proto, protolen or ethernet type (%"U16_F"/%"U16_F"/%"U16_F"/%"U16_F")\n",
                 hdr->hwtype, (u16_t)hdr->hwlen, hdr->proto, (u16_t)hdr->protolen));
    ETHARP_STATS_INC(etharp.proterr);
    ETHARP_STATS_INC(etharp.drop);
    pbuf_free(p);
 8110f2c:	6878      	ldr	r0, [r7, #4]
 8110f2e:	f003 fb93 	bl	8114658 <pbuf_free>
    return;
 8110f32:	e05a      	b.n	8110fea <etharp_input+0x10a>
  autoip_arp_reply(netif, hdr);
#endif /* LWIP_AUTOIP */

  /* Copy struct ip4_addr_wordaligned to aligned ip4_addr, to support compilers without
   * structure packing (not using structure copy which breaks strict-aliasing rules). */
  IPADDR_WORDALIGNED_COPY_TO_IP4_ADDR_T(&sipaddr, &hdr->sipaddr);
 8110f34:	693b      	ldr	r3, [r7, #16]
 8110f36:	330e      	adds	r3, #14
 8110f38:	681b      	ldr	r3, [r3, #0]
 8110f3a:	60fb      	str	r3, [r7, #12]
  IPADDR_WORDALIGNED_COPY_TO_IP4_ADDR_T(&dipaddr, &hdr->dipaddr);
 8110f3c:	693b      	ldr	r3, [r7, #16]
 8110f3e:	3318      	adds	r3, #24
 8110f40:	681b      	ldr	r3, [r3, #0]
 8110f42:	60bb      	str	r3, [r7, #8]

  /* this interface is not configured? */
  if (ip4_addr_isany_val(*netif_ip4_addr(netif))) {
 8110f44:	683b      	ldr	r3, [r7, #0]
 8110f46:	3304      	adds	r3, #4
 8110f48:	681b      	ldr	r3, [r3, #0]
 8110f4a:	2b00      	cmp	r3, #0
 8110f4c:	d102      	bne.n	8110f54 <etharp_input+0x74>
    for_us = 0;
 8110f4e:	2300      	movs	r3, #0
 8110f50:	75fb      	strb	r3, [r7, #23]
 8110f52:	e009      	b.n	8110f68 <etharp_input+0x88>
  } else {
    /* ARP packet directed to us? */
    for_us = (u8_t)ip4_addr_cmp(&dipaddr, netif_ip4_addr(netif));
 8110f54:	68ba      	ldr	r2, [r7, #8]
 8110f56:	683b      	ldr	r3, [r7, #0]
 8110f58:	3304      	adds	r3, #4
 8110f5a:	681b      	ldr	r3, [r3, #0]
 8110f5c:	429a      	cmp	r2, r3
 8110f5e:	bf0c      	ite	eq
 8110f60:	2301      	moveq	r3, #1
 8110f62:	2300      	movne	r3, #0
 8110f64:	b2db      	uxtb	r3, r3
 8110f66:	75fb      	strb	r3, [r7, #23]
  /* ARP message directed to us?
      -> add IP address in ARP cache; assume requester wants to talk to us,
         can result in directly sending the queued packets for this host.
     ARP message not directed to us?
      ->  update the source IP address in the cache, if present */
  etharp_update_arp_entry(netif, &sipaddr, &(hdr->shwaddr),
 8110f68:	693b      	ldr	r3, [r7, #16]
 8110f6a:	f103 0208 	add.w	r2, r3, #8
 8110f6e:	7dfb      	ldrb	r3, [r7, #23]
 8110f70:	2b00      	cmp	r3, #0
 8110f72:	d001      	beq.n	8110f78 <etharp_input+0x98>
 8110f74:	2301      	movs	r3, #1
 8110f76:	e000      	b.n	8110f7a <etharp_input+0x9a>
 8110f78:	2302      	movs	r3, #2
 8110f7a:	f107 010c 	add.w	r1, r7, #12
 8110f7e:	6838      	ldr	r0, [r7, #0]
 8110f80:	f7ff fed8 	bl	8110d34 <etharp_update_arp_entry>
                          for_us ? ETHARP_FLAG_TRY_HARD : ETHARP_FLAG_FIND_ONLY);

  /* now act on the message itself */
  switch (hdr->opcode) {
 8110f84:	693b      	ldr	r3, [r7, #16]
 8110f86:	88db      	ldrh	r3, [r3, #6]
 8110f88:	b29b      	uxth	r3, r3
 8110f8a:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 8110f8e:	d003      	beq.n	8110f98 <etharp_input+0xb8>
 8110f90:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 8110f94:	d01e      	beq.n	8110fd4 <etharp_input+0xf4>
#endif /* (LWIP_DHCP && DHCP_DOES_ARP_CHECK) */
      break;
    default:
      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_input: ARP unknown opcode type %"S16_F"\n", lwip_htons(hdr->opcode)));
      ETHARP_STATS_INC(etharp.err);
      break;
 8110f96:	e025      	b.n	8110fe4 <etharp_input+0x104>
      if (for_us) {
 8110f98:	7dfb      	ldrb	r3, [r7, #23]
 8110f9a:	2b00      	cmp	r3, #0
 8110f9c:	d021      	beq.n	8110fe2 <etharp_input+0x102>
                   (struct eth_addr *)netif->hwaddr, &hdr->shwaddr,
 8110f9e:	683b      	ldr	r3, [r7, #0]
 8110fa0:	f103 002a 	add.w	r0, r3, #42	; 0x2a
 8110fa4:	693b      	ldr	r3, [r7, #16]
 8110fa6:	f103 0408 	add.w	r4, r3, #8
                   (struct eth_addr *)netif->hwaddr, netif_ip4_addr(netif),
 8110faa:	683b      	ldr	r3, [r7, #0]
 8110fac:	f103 052a 	add.w	r5, r3, #42	; 0x2a
 8110fb0:	683b      	ldr	r3, [r7, #0]
 8110fb2:	3304      	adds	r3, #4
                   &hdr->shwaddr, &sipaddr,
 8110fb4:	693a      	ldr	r2, [r7, #16]
 8110fb6:	3208      	adds	r2, #8
        etharp_raw(netif,
 8110fb8:	2102      	movs	r1, #2
 8110fba:	9103      	str	r1, [sp, #12]
 8110fbc:	f107 010c 	add.w	r1, r7, #12
 8110fc0:	9102      	str	r1, [sp, #8]
 8110fc2:	9201      	str	r2, [sp, #4]
 8110fc4:	9300      	str	r3, [sp, #0]
 8110fc6:	462b      	mov	r3, r5
 8110fc8:	4622      	mov	r2, r4
 8110fca:	4601      	mov	r1, r0
 8110fcc:	6838      	ldr	r0, [r7, #0]
 8110fce:	f000 faef 	bl	81115b0 <etharp_raw>
      break;
 8110fd2:	e006      	b.n	8110fe2 <etharp_input+0x102>
      dhcp_arp_reply(netif, &sipaddr);
 8110fd4:	f107 030c 	add.w	r3, r7, #12
 8110fd8:	4619      	mov	r1, r3
 8110fda:	6838      	ldr	r0, [r7, #0]
 8110fdc:	f7fd fede 	bl	810ed9c <dhcp_arp_reply>
      break;
 8110fe0:	e000      	b.n	8110fe4 <etharp_input+0x104>
      break;
 8110fe2:	bf00      	nop
  }
  /* free ARP packet */
  pbuf_free(p);
 8110fe4:	6878      	ldr	r0, [r7, #4]
 8110fe6:	f003 fb37 	bl	8114658 <pbuf_free>
}
 8110fea:	3718      	adds	r7, #24
 8110fec:	46bd      	mov	sp, r7
 8110fee:	bdb0      	pop	{r4, r5, r7, pc}
 8110ff0:	0811cc48 	.word	0x0811cc48
 8110ff4:	0811cdcc 	.word	0x0811cdcc
 8110ff8:	0811ccf4 	.word	0x0811ccf4

08110ffc <etharp_output_to_arp_index>:
/** Just a small helper function that sends a pbuf to an ethernet address
 * in the arp_table specified by the index 'arp_idx'.
 */
static err_t
etharp_output_to_arp_index(struct netif *netif, struct pbuf *q, netif_addr_idx_t arp_idx)
{
 8110ffc:	b580      	push	{r7, lr}
 8110ffe:	b086      	sub	sp, #24
 8111000:	af02      	add	r7, sp, #8
 8111002:	60f8      	str	r0, [r7, #12]
 8111004:	60b9      	str	r1, [r7, #8]
 8111006:	4613      	mov	r3, r2
 8111008:	71fb      	strb	r3, [r7, #7]
  LWIP_ASSERT("arp_table[arp_idx].state >= ETHARP_STATE_STABLE",
 811100a:	79fa      	ldrb	r2, [r7, #7]
 811100c:	4944      	ldr	r1, [pc, #272]	; (8111120 <etharp_output_to_arp_index+0x124>)
 811100e:	4613      	mov	r3, r2
 8111010:	005b      	lsls	r3, r3, #1
 8111012:	4413      	add	r3, r2
 8111014:	00db      	lsls	r3, r3, #3
 8111016:	440b      	add	r3, r1
 8111018:	3314      	adds	r3, #20
 811101a:	781b      	ldrb	r3, [r3, #0]
 811101c:	2b01      	cmp	r3, #1
 811101e:	d806      	bhi.n	811102e <etharp_output_to_arp_index+0x32>
 8111020:	4b40      	ldr	r3, [pc, #256]	; (8111124 <etharp_output_to_arp_index+0x128>)
 8111022:	f240 22ee 	movw	r2, #750	; 0x2ee
 8111026:	4940      	ldr	r1, [pc, #256]	; (8111128 <etharp_output_to_arp_index+0x12c>)
 8111028:	4840      	ldr	r0, [pc, #256]	; (811112c <etharp_output_to_arp_index+0x130>)
 811102a:	f00a fbe9 	bl	811b800 <iprintf>
              arp_table[arp_idx].state >= ETHARP_STATE_STABLE);
  /* if arp table entry is about to expire: re-request it,
     but only if its state is ETHARP_STATE_STABLE to prevent flooding the
     network with ARP requests if this address is used frequently. */
  if (arp_table[arp_idx].state == ETHARP_STATE_STABLE) {
 811102e:	79fa      	ldrb	r2, [r7, #7]
 8111030:	493b      	ldr	r1, [pc, #236]	; (8111120 <etharp_output_to_arp_index+0x124>)
 8111032:	4613      	mov	r3, r2
 8111034:	005b      	lsls	r3, r3, #1
 8111036:	4413      	add	r3, r2
 8111038:	00db      	lsls	r3, r3, #3
 811103a:	440b      	add	r3, r1
 811103c:	3314      	adds	r3, #20
 811103e:	781b      	ldrb	r3, [r3, #0]
 8111040:	2b02      	cmp	r3, #2
 8111042:	d153      	bne.n	81110ec <etharp_output_to_arp_index+0xf0>
    if (arp_table[arp_idx].ctime >= ARP_AGE_REREQUEST_USED_BROADCAST) {
 8111044:	79fa      	ldrb	r2, [r7, #7]
 8111046:	4936      	ldr	r1, [pc, #216]	; (8111120 <etharp_output_to_arp_index+0x124>)
 8111048:	4613      	mov	r3, r2
 811104a:	005b      	lsls	r3, r3, #1
 811104c:	4413      	add	r3, r2
 811104e:	00db      	lsls	r3, r3, #3
 8111050:	440b      	add	r3, r1
 8111052:	3312      	adds	r3, #18
 8111054:	881b      	ldrh	r3, [r3, #0]
 8111056:	f5b3 7f8e 	cmp.w	r3, #284	; 0x11c
 811105a:	d919      	bls.n	8111090 <etharp_output_to_arp_index+0x94>
      /* issue a standard request using broadcast */
      if (etharp_request(netif, &arp_table[arp_idx].ipaddr) == ERR_OK) {
 811105c:	79fa      	ldrb	r2, [r7, #7]
 811105e:	4613      	mov	r3, r2
 8111060:	005b      	lsls	r3, r3, #1
 8111062:	4413      	add	r3, r2
 8111064:	00db      	lsls	r3, r3, #3
 8111066:	4a2e      	ldr	r2, [pc, #184]	; (8111120 <etharp_output_to_arp_index+0x124>)
 8111068:	4413      	add	r3, r2
 811106a:	3304      	adds	r3, #4
 811106c:	4619      	mov	r1, r3
 811106e:	68f8      	ldr	r0, [r7, #12]
 8111070:	f000 fb4c 	bl	811170c <etharp_request>
 8111074:	4603      	mov	r3, r0
 8111076:	2b00      	cmp	r3, #0
 8111078:	d138      	bne.n	81110ec <etharp_output_to_arp_index+0xf0>
        arp_table[arp_idx].state = ETHARP_STATE_STABLE_REREQUESTING_1;
 811107a:	79fa      	ldrb	r2, [r7, #7]
 811107c:	4928      	ldr	r1, [pc, #160]	; (8111120 <etharp_output_to_arp_index+0x124>)
 811107e:	4613      	mov	r3, r2
 8111080:	005b      	lsls	r3, r3, #1
 8111082:	4413      	add	r3, r2
 8111084:	00db      	lsls	r3, r3, #3
 8111086:	440b      	add	r3, r1
 8111088:	3314      	adds	r3, #20
 811108a:	2203      	movs	r2, #3
 811108c:	701a      	strb	r2, [r3, #0]
 811108e:	e02d      	b.n	81110ec <etharp_output_to_arp_index+0xf0>
      }
    } else if (arp_table[arp_idx].ctime >= ARP_AGE_REREQUEST_USED_UNICAST) {
 8111090:	79fa      	ldrb	r2, [r7, #7]
 8111092:	4923      	ldr	r1, [pc, #140]	; (8111120 <etharp_output_to_arp_index+0x124>)
 8111094:	4613      	mov	r3, r2
 8111096:	005b      	lsls	r3, r3, #1
 8111098:	4413      	add	r3, r2
 811109a:	00db      	lsls	r3, r3, #3
 811109c:	440b      	add	r3, r1
 811109e:	3312      	adds	r3, #18
 81110a0:	881b      	ldrh	r3, [r3, #0]
 81110a2:	f5b3 7f87 	cmp.w	r3, #270	; 0x10e
 81110a6:	d321      	bcc.n	81110ec <etharp_output_to_arp_index+0xf0>
      /* issue a unicast request (for 15 seconds) to prevent unnecessary broadcast */
      if (etharp_request_dst(netif, &arp_table[arp_idx].ipaddr, &arp_table[arp_idx].ethaddr) == ERR_OK) {
 81110a8:	79fa      	ldrb	r2, [r7, #7]
 81110aa:	4613      	mov	r3, r2
 81110ac:	005b      	lsls	r3, r3, #1
 81110ae:	4413      	add	r3, r2
 81110b0:	00db      	lsls	r3, r3, #3
 81110b2:	4a1b      	ldr	r2, [pc, #108]	; (8111120 <etharp_output_to_arp_index+0x124>)
 81110b4:	4413      	add	r3, r2
 81110b6:	1d19      	adds	r1, r3, #4
 81110b8:	79fa      	ldrb	r2, [r7, #7]
 81110ba:	4613      	mov	r3, r2
 81110bc:	005b      	lsls	r3, r3, #1
 81110be:	4413      	add	r3, r2
 81110c0:	00db      	lsls	r3, r3, #3
 81110c2:	3308      	adds	r3, #8
 81110c4:	4a16      	ldr	r2, [pc, #88]	; (8111120 <etharp_output_to_arp_index+0x124>)
 81110c6:	4413      	add	r3, r2
 81110c8:	3304      	adds	r3, #4
 81110ca:	461a      	mov	r2, r3
 81110cc:	68f8      	ldr	r0, [r7, #12]
 81110ce:	f000 fafb 	bl	81116c8 <etharp_request_dst>
 81110d2:	4603      	mov	r3, r0
 81110d4:	2b00      	cmp	r3, #0
 81110d6:	d109      	bne.n	81110ec <etharp_output_to_arp_index+0xf0>
        arp_table[arp_idx].state = ETHARP_STATE_STABLE_REREQUESTING_1;
 81110d8:	79fa      	ldrb	r2, [r7, #7]
 81110da:	4911      	ldr	r1, [pc, #68]	; (8111120 <etharp_output_to_arp_index+0x124>)
 81110dc:	4613      	mov	r3, r2
 81110de:	005b      	lsls	r3, r3, #1
 81110e0:	4413      	add	r3, r2
 81110e2:	00db      	lsls	r3, r3, #3
 81110e4:	440b      	add	r3, r1
 81110e6:	3314      	adds	r3, #20
 81110e8:	2203      	movs	r2, #3
 81110ea:	701a      	strb	r2, [r3, #0]
      }
    }
  }

  return ethernet_output(netif, q, (struct eth_addr *)(netif->hwaddr), &arp_table[arp_idx].ethaddr, ETHTYPE_IP);
 81110ec:	68fb      	ldr	r3, [r7, #12]
 81110ee:	f103 012a 	add.w	r1, r3, #42	; 0x2a
 81110f2:	79fa      	ldrb	r2, [r7, #7]
 81110f4:	4613      	mov	r3, r2
 81110f6:	005b      	lsls	r3, r3, #1
 81110f8:	4413      	add	r3, r2
 81110fa:	00db      	lsls	r3, r3, #3
 81110fc:	3308      	adds	r3, #8
 81110fe:	4a08      	ldr	r2, [pc, #32]	; (8111120 <etharp_output_to_arp_index+0x124>)
 8111100:	4413      	add	r3, r2
 8111102:	3304      	adds	r3, #4
 8111104:	f44f 6200 	mov.w	r2, #2048	; 0x800
 8111108:	9200      	str	r2, [sp, #0]
 811110a:	460a      	mov	r2, r1
 811110c:	68b9      	ldr	r1, [r7, #8]
 811110e:	68f8      	ldr	r0, [r7, #12]
 8111110:	f000 fb9c 	bl	811184c <ethernet_output>
 8111114:	4603      	mov	r3, r0
}
 8111116:	4618      	mov	r0, r3
 8111118:	3710      	adds	r7, #16
 811111a:	46bd      	mov	sp, r7
 811111c:	bd80      	pop	{r7, pc}
 811111e:	bf00      	nop
 8111120:	100053fc 	.word	0x100053fc
 8111124:	0811cc48 	.word	0x0811cc48
 8111128:	0811cdec 	.word	0x0811cdec
 811112c:	0811ccf4 	.word	0x0811ccf4

08111130 <etharp_output>:
 * - ERR_RTE No route to destination (no gateway to external networks),
 * or the return type of either etharp_query() or ethernet_output().
 */
err_t
etharp_output(struct netif *netif, struct pbuf *q, const ip4_addr_t *ipaddr)
{
 8111130:	b580      	push	{r7, lr}
 8111132:	b08a      	sub	sp, #40	; 0x28
 8111134:	af02      	add	r7, sp, #8
 8111136:	60f8      	str	r0, [r7, #12]
 8111138:	60b9      	str	r1, [r7, #8]
 811113a:	607a      	str	r2, [r7, #4]
  const struct eth_addr *dest;
  struct eth_addr mcastaddr;
  const ip4_addr_t *dst_addr = ipaddr;
 811113c:	687b      	ldr	r3, [r7, #4]
 811113e:	61bb      	str	r3, [r7, #24]

  LWIP_ASSERT_CORE_LOCKED();
  LWIP_ASSERT("netif != NULL", netif != NULL);
 8111140:	68fb      	ldr	r3, [r7, #12]
 8111142:	2b00      	cmp	r3, #0
 8111144:	d106      	bne.n	8111154 <etharp_output+0x24>
 8111146:	4b73      	ldr	r3, [pc, #460]	; (8111314 <etharp_output+0x1e4>)
 8111148:	f240 321e 	movw	r2, #798	; 0x31e
 811114c:	4972      	ldr	r1, [pc, #456]	; (8111318 <etharp_output+0x1e8>)
 811114e:	4873      	ldr	r0, [pc, #460]	; (811131c <etharp_output+0x1ec>)
 8111150:	f00a fb56 	bl	811b800 <iprintf>
  LWIP_ASSERT("q != NULL", q != NULL);
 8111154:	68bb      	ldr	r3, [r7, #8]
 8111156:	2b00      	cmp	r3, #0
 8111158:	d106      	bne.n	8111168 <etharp_output+0x38>
 811115a:	4b6e      	ldr	r3, [pc, #440]	; (8111314 <etharp_output+0x1e4>)
 811115c:	f240 321f 	movw	r2, #799	; 0x31f
 8111160:	496f      	ldr	r1, [pc, #444]	; (8111320 <etharp_output+0x1f0>)
 8111162:	486e      	ldr	r0, [pc, #440]	; (811131c <etharp_output+0x1ec>)
 8111164:	f00a fb4c 	bl	811b800 <iprintf>
  LWIP_ASSERT("ipaddr != NULL", ipaddr != NULL);
 8111168:	687b      	ldr	r3, [r7, #4]
 811116a:	2b00      	cmp	r3, #0
 811116c:	d106      	bne.n	811117c <etharp_output+0x4c>
 811116e:	4b69      	ldr	r3, [pc, #420]	; (8111314 <etharp_output+0x1e4>)
 8111170:	f44f 7248 	mov.w	r2, #800	; 0x320
 8111174:	496b      	ldr	r1, [pc, #428]	; (8111324 <etharp_output+0x1f4>)
 8111176:	4869      	ldr	r0, [pc, #420]	; (811131c <etharp_output+0x1ec>)
 8111178:	f00a fb42 	bl	811b800 <iprintf>

  /* Determine on destination hardware address. Broadcasts and multicasts
   * are special, other IP addresses are looked up in the ARP table. */

  /* broadcast destination IP address? */
  if (ip4_addr_isbroadcast(ipaddr, netif)) {
 811117c:	687b      	ldr	r3, [r7, #4]
 811117e:	681b      	ldr	r3, [r3, #0]
 8111180:	68f9      	ldr	r1, [r7, #12]
 8111182:	4618      	mov	r0, r3
 8111184:	f001 f8e6 	bl	8112354 <ip4_addr_isbroadcast_u32>
 8111188:	4603      	mov	r3, r0
 811118a:	2b00      	cmp	r3, #0
 811118c:	d002      	beq.n	8111194 <etharp_output+0x64>
    /* broadcast on Ethernet also */
    dest = (const struct eth_addr *)&ethbroadcast;
 811118e:	4b66      	ldr	r3, [pc, #408]	; (8111328 <etharp_output+0x1f8>)
 8111190:	61fb      	str	r3, [r7, #28]
 8111192:	e0af      	b.n	81112f4 <etharp_output+0x1c4>
    /* multicast destination IP address? */
  } else if (ip4_addr_ismulticast(ipaddr)) {
 8111194:	687b      	ldr	r3, [r7, #4]
 8111196:	681b      	ldr	r3, [r3, #0]
 8111198:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 811119c:	2be0      	cmp	r3, #224	; 0xe0
 811119e:	d118      	bne.n	81111d2 <etharp_output+0xa2>
    /* Hash IP multicast address to MAC address.*/
    mcastaddr.addr[0] = LL_IP4_MULTICAST_ADDR_0;
 81111a0:	2301      	movs	r3, #1
 81111a2:	743b      	strb	r3, [r7, #16]
    mcastaddr.addr[1] = LL_IP4_MULTICAST_ADDR_1;
 81111a4:	2300      	movs	r3, #0
 81111a6:	747b      	strb	r3, [r7, #17]
    mcastaddr.addr[2] = LL_IP4_MULTICAST_ADDR_2;
 81111a8:	235e      	movs	r3, #94	; 0x5e
 81111aa:	74bb      	strb	r3, [r7, #18]
    mcastaddr.addr[3] = ip4_addr2(ipaddr) & 0x7f;
 81111ac:	687b      	ldr	r3, [r7, #4]
 81111ae:	3301      	adds	r3, #1
 81111b0:	781b      	ldrb	r3, [r3, #0]
 81111b2:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 81111b6:	b2db      	uxtb	r3, r3
 81111b8:	74fb      	strb	r3, [r7, #19]
    mcastaddr.addr[4] = ip4_addr3(ipaddr);
 81111ba:	687b      	ldr	r3, [r7, #4]
 81111bc:	3302      	adds	r3, #2
 81111be:	781b      	ldrb	r3, [r3, #0]
 81111c0:	753b      	strb	r3, [r7, #20]
    mcastaddr.addr[5] = ip4_addr4(ipaddr);
 81111c2:	687b      	ldr	r3, [r7, #4]
 81111c4:	3303      	adds	r3, #3
 81111c6:	781b      	ldrb	r3, [r3, #0]
 81111c8:	757b      	strb	r3, [r7, #21]
    /* destination Ethernet address is multicast */
    dest = &mcastaddr;
 81111ca:	f107 0310 	add.w	r3, r7, #16
 81111ce:	61fb      	str	r3, [r7, #28]
 81111d0:	e090      	b.n	81112f4 <etharp_output+0x1c4>
    /* unicast destination IP address? */
  } else {
    netif_addr_idx_t i;
    /* outside local network? if so, this can neither be a global broadcast nor
       a subnet broadcast. */
    if (!ip4_addr_netcmp(ipaddr, netif_ip4_addr(netif), netif_ip4_netmask(netif)) &&
 81111d2:	687b      	ldr	r3, [r7, #4]
 81111d4:	681a      	ldr	r2, [r3, #0]
 81111d6:	68fb      	ldr	r3, [r7, #12]
 81111d8:	3304      	adds	r3, #4
 81111da:	681b      	ldr	r3, [r3, #0]
 81111dc:	405a      	eors	r2, r3
 81111de:	68fb      	ldr	r3, [r7, #12]
 81111e0:	3308      	adds	r3, #8
 81111e2:	681b      	ldr	r3, [r3, #0]
 81111e4:	4013      	ands	r3, r2
 81111e6:	2b00      	cmp	r3, #0
 81111e8:	d012      	beq.n	8111210 <etharp_output+0xe0>
        !ip4_addr_islinklocal(ipaddr)) {
 81111ea:	687b      	ldr	r3, [r7, #4]
 81111ec:	681b      	ldr	r3, [r3, #0]
 81111ee:	b29b      	uxth	r3, r3
    if (!ip4_addr_netcmp(ipaddr, netif_ip4_addr(netif), netif_ip4_netmask(netif)) &&
 81111f0:	f64f 62a9 	movw	r2, #65193	; 0xfea9
 81111f4:	4293      	cmp	r3, r2
 81111f6:	d00b      	beq.n	8111210 <etharp_output+0xe0>
        dst_addr = LWIP_HOOK_ETHARP_GET_GW(netif, ipaddr);
        if (dst_addr == NULL)
#endif /* LWIP_HOOK_ETHARP_GET_GW */
        {
          /* interface has default gateway? */
          if (!ip4_addr_isany_val(*netif_ip4_gw(netif))) {
 81111f8:	68fb      	ldr	r3, [r7, #12]
 81111fa:	330c      	adds	r3, #12
 81111fc:	681b      	ldr	r3, [r3, #0]
 81111fe:	2b00      	cmp	r3, #0
 8111200:	d003      	beq.n	811120a <etharp_output+0xda>
            /* send to hardware address of default gateway IP address */
            dst_addr = netif_ip4_gw(netif);
 8111202:	68fb      	ldr	r3, [r7, #12]
 8111204:	330c      	adds	r3, #12
 8111206:	61bb      	str	r3, [r7, #24]
 8111208:	e002      	b.n	8111210 <etharp_output+0xe0>
            /* no default gateway available */
          } else {
            /* no route to destination error (default gateway missing) */
            return ERR_RTE;
 811120a:	f06f 0303 	mvn.w	r3, #3
 811120e:	e07d      	b.n	811130c <etharp_output+0x1dc>
    if (netif->hints != NULL) {
      /* per-pcb cached entry was given */
      netif_addr_idx_t etharp_cached_entry = netif->hints->addr_hint;
      if (etharp_cached_entry < ARP_TABLE_SIZE) {
#endif /* LWIP_NETIF_HWADDRHINT */
        if ((arp_table[etharp_cached_entry].state >= ETHARP_STATE_STABLE) &&
 8111210:	4b46      	ldr	r3, [pc, #280]	; (811132c <etharp_output+0x1fc>)
 8111212:	781b      	ldrb	r3, [r3, #0]
 8111214:	4619      	mov	r1, r3
 8111216:	4a46      	ldr	r2, [pc, #280]	; (8111330 <etharp_output+0x200>)
 8111218:	460b      	mov	r3, r1
 811121a:	005b      	lsls	r3, r3, #1
 811121c:	440b      	add	r3, r1
 811121e:	00db      	lsls	r3, r3, #3
 8111220:	4413      	add	r3, r2
 8111222:	3314      	adds	r3, #20
 8111224:	781b      	ldrb	r3, [r3, #0]
 8111226:	2b01      	cmp	r3, #1
 8111228:	d925      	bls.n	8111276 <etharp_output+0x146>
#if ETHARP_TABLE_MATCH_NETIF
            (arp_table[etharp_cached_entry].netif == netif) &&
 811122a:	4b40      	ldr	r3, [pc, #256]	; (811132c <etharp_output+0x1fc>)
 811122c:	781b      	ldrb	r3, [r3, #0]
 811122e:	4619      	mov	r1, r3
 8111230:	4a3f      	ldr	r2, [pc, #252]	; (8111330 <etharp_output+0x200>)
 8111232:	460b      	mov	r3, r1
 8111234:	005b      	lsls	r3, r3, #1
 8111236:	440b      	add	r3, r1
 8111238:	00db      	lsls	r3, r3, #3
 811123a:	4413      	add	r3, r2
 811123c:	3308      	adds	r3, #8
 811123e:	681b      	ldr	r3, [r3, #0]
        if ((arp_table[etharp_cached_entry].state >= ETHARP_STATE_STABLE) &&
 8111240:	68fa      	ldr	r2, [r7, #12]
 8111242:	429a      	cmp	r2, r3
 8111244:	d117      	bne.n	8111276 <etharp_output+0x146>
#endif
            (ip4_addr_cmp(dst_addr, &arp_table[etharp_cached_entry].ipaddr))) {
 8111246:	69bb      	ldr	r3, [r7, #24]
 8111248:	681a      	ldr	r2, [r3, #0]
 811124a:	4b38      	ldr	r3, [pc, #224]	; (811132c <etharp_output+0x1fc>)
 811124c:	781b      	ldrb	r3, [r3, #0]
 811124e:	4618      	mov	r0, r3
 8111250:	4937      	ldr	r1, [pc, #220]	; (8111330 <etharp_output+0x200>)
 8111252:	4603      	mov	r3, r0
 8111254:	005b      	lsls	r3, r3, #1
 8111256:	4403      	add	r3, r0
 8111258:	00db      	lsls	r3, r3, #3
 811125a:	440b      	add	r3, r1
 811125c:	3304      	adds	r3, #4
 811125e:	681b      	ldr	r3, [r3, #0]
            (arp_table[etharp_cached_entry].netif == netif) &&
 8111260:	429a      	cmp	r2, r3
 8111262:	d108      	bne.n	8111276 <etharp_output+0x146>
          /* the per-pcb-cached entry is stable and the right one! */
          ETHARP_STATS_INC(etharp.cachehit);
          return etharp_output_to_arp_index(netif, q, etharp_cached_entry);
 8111264:	4b31      	ldr	r3, [pc, #196]	; (811132c <etharp_output+0x1fc>)
 8111266:	781b      	ldrb	r3, [r3, #0]
 8111268:	461a      	mov	r2, r3
 811126a:	68b9      	ldr	r1, [r7, #8]
 811126c:	68f8      	ldr	r0, [r7, #12]
 811126e:	f7ff fec5 	bl	8110ffc <etharp_output_to_arp_index>
 8111272:	4603      	mov	r3, r0
 8111274:	e04a      	b.n	811130c <etharp_output+0x1dc>
    }
#endif /* LWIP_NETIF_HWADDRHINT */

    /* find stable entry: do this here since this is a critical path for
       throughput and etharp_find_entry() is kind of slow */
    for (i = 0; i < ARP_TABLE_SIZE; i++) {
 8111276:	2300      	movs	r3, #0
 8111278:	75fb      	strb	r3, [r7, #23]
 811127a:	e031      	b.n	81112e0 <etharp_output+0x1b0>
      if ((arp_table[i].state >= ETHARP_STATE_STABLE) &&
 811127c:	7dfa      	ldrb	r2, [r7, #23]
 811127e:	492c      	ldr	r1, [pc, #176]	; (8111330 <etharp_output+0x200>)
 8111280:	4613      	mov	r3, r2
 8111282:	005b      	lsls	r3, r3, #1
 8111284:	4413      	add	r3, r2
 8111286:	00db      	lsls	r3, r3, #3
 8111288:	440b      	add	r3, r1
 811128a:	3314      	adds	r3, #20
 811128c:	781b      	ldrb	r3, [r3, #0]
 811128e:	2b01      	cmp	r3, #1
 8111290:	d923      	bls.n	81112da <etharp_output+0x1aa>
#if ETHARP_TABLE_MATCH_NETIF
          (arp_table[i].netif == netif) &&
 8111292:	7dfa      	ldrb	r2, [r7, #23]
 8111294:	4926      	ldr	r1, [pc, #152]	; (8111330 <etharp_output+0x200>)
 8111296:	4613      	mov	r3, r2
 8111298:	005b      	lsls	r3, r3, #1
 811129a:	4413      	add	r3, r2
 811129c:	00db      	lsls	r3, r3, #3
 811129e:	440b      	add	r3, r1
 81112a0:	3308      	adds	r3, #8
 81112a2:	681b      	ldr	r3, [r3, #0]
      if ((arp_table[i].state >= ETHARP_STATE_STABLE) &&
 81112a4:	68fa      	ldr	r2, [r7, #12]
 81112a6:	429a      	cmp	r2, r3
 81112a8:	d117      	bne.n	81112da <etharp_output+0x1aa>
#endif
          (ip4_addr_cmp(dst_addr, &arp_table[i].ipaddr))) {
 81112aa:	69bb      	ldr	r3, [r7, #24]
 81112ac:	6819      	ldr	r1, [r3, #0]
 81112ae:	7dfa      	ldrb	r2, [r7, #23]
 81112b0:	481f      	ldr	r0, [pc, #124]	; (8111330 <etharp_output+0x200>)
 81112b2:	4613      	mov	r3, r2
 81112b4:	005b      	lsls	r3, r3, #1
 81112b6:	4413      	add	r3, r2
 81112b8:	00db      	lsls	r3, r3, #3
 81112ba:	4403      	add	r3, r0
 81112bc:	3304      	adds	r3, #4
 81112be:	681b      	ldr	r3, [r3, #0]
          (arp_table[i].netif == netif) &&
 81112c0:	4299      	cmp	r1, r3
 81112c2:	d10a      	bne.n	81112da <etharp_output+0x1aa>
        /* found an existing, stable entry */
        ETHARP_SET_ADDRHINT(netif, i);
 81112c4:	4a19      	ldr	r2, [pc, #100]	; (811132c <etharp_output+0x1fc>)
 81112c6:	7dfb      	ldrb	r3, [r7, #23]
 81112c8:	7013      	strb	r3, [r2, #0]
        return etharp_output_to_arp_index(netif, q, i);
 81112ca:	7dfb      	ldrb	r3, [r7, #23]
 81112cc:	461a      	mov	r2, r3
 81112ce:	68b9      	ldr	r1, [r7, #8]
 81112d0:	68f8      	ldr	r0, [r7, #12]
 81112d2:	f7ff fe93 	bl	8110ffc <etharp_output_to_arp_index>
 81112d6:	4603      	mov	r3, r0
 81112d8:	e018      	b.n	811130c <etharp_output+0x1dc>
    for (i = 0; i < ARP_TABLE_SIZE; i++) {
 81112da:	7dfb      	ldrb	r3, [r7, #23]
 81112dc:	3301      	adds	r3, #1
 81112de:	75fb      	strb	r3, [r7, #23]
 81112e0:	7dfb      	ldrb	r3, [r7, #23]
 81112e2:	2b09      	cmp	r3, #9
 81112e4:	d9ca      	bls.n	811127c <etharp_output+0x14c>
      }
    }
    /* no stable entry found, use the (slower) query function:
       queue on destination Ethernet address belonging to ipaddr */
    return etharp_query(netif, dst_addr, q);
 81112e6:	68ba      	ldr	r2, [r7, #8]
 81112e8:	69b9      	ldr	r1, [r7, #24]
 81112ea:	68f8      	ldr	r0, [r7, #12]
 81112ec:	f000 f822 	bl	8111334 <etharp_query>
 81112f0:	4603      	mov	r3, r0
 81112f2:	e00b      	b.n	811130c <etharp_output+0x1dc>
  }

  /* continuation for multicast/broadcast destinations */
  /* obtain source Ethernet address of the given interface */
  /* send packet directly on the link */
  return ethernet_output(netif, q, (struct eth_addr *)(netif->hwaddr), dest, ETHTYPE_IP);
 81112f4:	68fb      	ldr	r3, [r7, #12]
 81112f6:	f103 022a 	add.w	r2, r3, #42	; 0x2a
 81112fa:	f44f 6300 	mov.w	r3, #2048	; 0x800
 81112fe:	9300      	str	r3, [sp, #0]
 8111300:	69fb      	ldr	r3, [r7, #28]
 8111302:	68b9      	ldr	r1, [r7, #8]
 8111304:	68f8      	ldr	r0, [r7, #12]
 8111306:	f000 faa1 	bl	811184c <ethernet_output>
 811130a:	4603      	mov	r3, r0
}
 811130c:	4618      	mov	r0, r3
 811130e:	3720      	adds	r7, #32
 8111310:	46bd      	mov	sp, r7
 8111312:	bd80      	pop	{r7, pc}
 8111314:	0811cc48 	.word	0x0811cc48
 8111318:	0811cdcc 	.word	0x0811cdcc
 811131c:	0811ccf4 	.word	0x0811ccf4
 8111320:	0811ce1c 	.word	0x0811ce1c
 8111324:	0811cdbc 	.word	0x0811cdbc
 8111328:	0811f924 	.word	0x0811f924
 811132c:	100054ec 	.word	0x100054ec
 8111330:	100053fc 	.word	0x100053fc

08111334 <etharp_query>:
 * - ERR_ARG Non-unicast address given, those will not appear in ARP cache.
 *
 */
err_t
etharp_query(struct netif *netif, const ip4_addr_t *ipaddr, struct pbuf *q)
{
 8111334:	b580      	push	{r7, lr}
 8111336:	b08c      	sub	sp, #48	; 0x30
 8111338:	af02      	add	r7, sp, #8
 811133a:	60f8      	str	r0, [r7, #12]
 811133c:	60b9      	str	r1, [r7, #8]
 811133e:	607a      	str	r2, [r7, #4]
  struct eth_addr *srcaddr = (struct eth_addr *)netif->hwaddr;
 8111340:	68fb      	ldr	r3, [r7, #12]
 8111342:	332a      	adds	r3, #42	; 0x2a
 8111344:	617b      	str	r3, [r7, #20]
  err_t result = ERR_MEM;
 8111346:	23ff      	movs	r3, #255	; 0xff
 8111348:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
  int is_new_entry = 0;
 811134c:	2300      	movs	r3, #0
 811134e:	623b      	str	r3, [r7, #32]
  s16_t i_err;
  netif_addr_idx_t i;

  /* non-unicast address? */
  if (ip4_addr_isbroadcast(ipaddr, netif) ||
 8111350:	68bb      	ldr	r3, [r7, #8]
 8111352:	681b      	ldr	r3, [r3, #0]
 8111354:	68f9      	ldr	r1, [r7, #12]
 8111356:	4618      	mov	r0, r3
 8111358:	f000 fffc 	bl	8112354 <ip4_addr_isbroadcast_u32>
 811135c:	4603      	mov	r3, r0
 811135e:	2b00      	cmp	r3, #0
 8111360:	d10c      	bne.n	811137c <etharp_query+0x48>
      ip4_addr_ismulticast(ipaddr) ||
 8111362:	68bb      	ldr	r3, [r7, #8]
 8111364:	681b      	ldr	r3, [r3, #0]
 8111366:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
  if (ip4_addr_isbroadcast(ipaddr, netif) ||
 811136a:	2be0      	cmp	r3, #224	; 0xe0
 811136c:	d006      	beq.n	811137c <etharp_query+0x48>
      ip4_addr_ismulticast(ipaddr) ||
 811136e:	68bb      	ldr	r3, [r7, #8]
 8111370:	2b00      	cmp	r3, #0
 8111372:	d003      	beq.n	811137c <etharp_query+0x48>
      ip4_addr_isany(ipaddr)) {
 8111374:	68bb      	ldr	r3, [r7, #8]
 8111376:	681b      	ldr	r3, [r3, #0]
 8111378:	2b00      	cmp	r3, #0
 811137a:	d102      	bne.n	8111382 <etharp_query+0x4e>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: will not add non-unicast IP address to ARP cache\n"));
    return ERR_ARG;
 811137c:	f06f 030f 	mvn.w	r3, #15
 8111380:	e101      	b.n	8111586 <etharp_query+0x252>
  }

  /* find entry in ARP cache, ask to create entry if queueing packet */
  i_err = etharp_find_entry(ipaddr, ETHARP_FLAG_TRY_HARD, netif);
 8111382:	68fa      	ldr	r2, [r7, #12]
 8111384:	2101      	movs	r1, #1
 8111386:	68b8      	ldr	r0, [r7, #8]
 8111388:	f7ff fb5c 	bl	8110a44 <etharp_find_entry>
 811138c:	4603      	mov	r3, r0
 811138e:	827b      	strh	r3, [r7, #18]

  /* could not find or create entry? */
  if (i_err < 0) {
 8111390:	f9b7 3012 	ldrsh.w	r3, [r7, #18]
 8111394:	2b00      	cmp	r3, #0
 8111396:	da02      	bge.n	811139e <etharp_query+0x6a>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: could not create ARP entry\n"));
    if (q) {
      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: packet dropped\n"));
      ETHARP_STATS_INC(etharp.memerr);
    }
    return (err_t)i_err;
 8111398:	8a7b      	ldrh	r3, [r7, #18]
 811139a:	b25b      	sxtb	r3, r3
 811139c:	e0f3      	b.n	8111586 <etharp_query+0x252>
  }
  LWIP_ASSERT("type overflow", (size_t)i_err < NETIF_ADDR_IDX_MAX);
 811139e:	8a7b      	ldrh	r3, [r7, #18]
 81113a0:	2b7e      	cmp	r3, #126	; 0x7e
 81113a2:	d906      	bls.n	81113b2 <etharp_query+0x7e>
 81113a4:	4b7a      	ldr	r3, [pc, #488]	; (8111590 <etharp_query+0x25c>)
 81113a6:	f240 32c1 	movw	r2, #961	; 0x3c1
 81113aa:	497a      	ldr	r1, [pc, #488]	; (8111594 <etharp_query+0x260>)
 81113ac:	487a      	ldr	r0, [pc, #488]	; (8111598 <etharp_query+0x264>)
 81113ae:	f00a fa27 	bl	811b800 <iprintf>
  i = (netif_addr_idx_t)i_err;
 81113b2:	8a7b      	ldrh	r3, [r7, #18]
 81113b4:	747b      	strb	r3, [r7, #17]

  /* mark a fresh entry as pending (we just sent a request) */
  if (arp_table[i].state == ETHARP_STATE_EMPTY) {
 81113b6:	7c7a      	ldrb	r2, [r7, #17]
 81113b8:	4978      	ldr	r1, [pc, #480]	; (811159c <etharp_query+0x268>)
 81113ba:	4613      	mov	r3, r2
 81113bc:	005b      	lsls	r3, r3, #1
 81113be:	4413      	add	r3, r2
 81113c0:	00db      	lsls	r3, r3, #3
 81113c2:	440b      	add	r3, r1
 81113c4:	3314      	adds	r3, #20
 81113c6:	781b      	ldrb	r3, [r3, #0]
 81113c8:	2b00      	cmp	r3, #0
 81113ca:	d115      	bne.n	81113f8 <etharp_query+0xc4>
    is_new_entry = 1;
 81113cc:	2301      	movs	r3, #1
 81113ce:	623b      	str	r3, [r7, #32]
    arp_table[i].state = ETHARP_STATE_PENDING;
 81113d0:	7c7a      	ldrb	r2, [r7, #17]
 81113d2:	4972      	ldr	r1, [pc, #456]	; (811159c <etharp_query+0x268>)
 81113d4:	4613      	mov	r3, r2
 81113d6:	005b      	lsls	r3, r3, #1
 81113d8:	4413      	add	r3, r2
 81113da:	00db      	lsls	r3, r3, #3
 81113dc:	440b      	add	r3, r1
 81113de:	3314      	adds	r3, #20
 81113e0:	2201      	movs	r2, #1
 81113e2:	701a      	strb	r2, [r3, #0]
    /* record network interface for re-sending arp request in etharp_tmr */
    arp_table[i].netif = netif;
 81113e4:	7c7a      	ldrb	r2, [r7, #17]
 81113e6:	496d      	ldr	r1, [pc, #436]	; (811159c <etharp_query+0x268>)
 81113e8:	4613      	mov	r3, r2
 81113ea:	005b      	lsls	r3, r3, #1
 81113ec:	4413      	add	r3, r2
 81113ee:	00db      	lsls	r3, r3, #3
 81113f0:	440b      	add	r3, r1
 81113f2:	3308      	adds	r3, #8
 81113f4:	68fa      	ldr	r2, [r7, #12]
 81113f6:	601a      	str	r2, [r3, #0]
  }

  /* { i is either a STABLE or (new or existing) PENDING entry } */
  LWIP_ASSERT("arp_table[i].state == PENDING or STABLE",
 81113f8:	7c7a      	ldrb	r2, [r7, #17]
 81113fa:	4968      	ldr	r1, [pc, #416]	; (811159c <etharp_query+0x268>)
 81113fc:	4613      	mov	r3, r2
 81113fe:	005b      	lsls	r3, r3, #1
 8111400:	4413      	add	r3, r2
 8111402:	00db      	lsls	r3, r3, #3
 8111404:	440b      	add	r3, r1
 8111406:	3314      	adds	r3, #20
 8111408:	781b      	ldrb	r3, [r3, #0]
 811140a:	2b01      	cmp	r3, #1
 811140c:	d011      	beq.n	8111432 <etharp_query+0xfe>
 811140e:	7c7a      	ldrb	r2, [r7, #17]
 8111410:	4962      	ldr	r1, [pc, #392]	; (811159c <etharp_query+0x268>)
 8111412:	4613      	mov	r3, r2
 8111414:	005b      	lsls	r3, r3, #1
 8111416:	4413      	add	r3, r2
 8111418:	00db      	lsls	r3, r3, #3
 811141a:	440b      	add	r3, r1
 811141c:	3314      	adds	r3, #20
 811141e:	781b      	ldrb	r3, [r3, #0]
 8111420:	2b01      	cmp	r3, #1
 8111422:	d806      	bhi.n	8111432 <etharp_query+0xfe>
 8111424:	4b5a      	ldr	r3, [pc, #360]	; (8111590 <etharp_query+0x25c>)
 8111426:	f240 32cd 	movw	r2, #973	; 0x3cd
 811142a:	495d      	ldr	r1, [pc, #372]	; (81115a0 <etharp_query+0x26c>)
 811142c:	485a      	ldr	r0, [pc, #360]	; (8111598 <etharp_query+0x264>)
 811142e:	f00a f9e7 	bl	811b800 <iprintf>
              ((arp_table[i].state == ETHARP_STATE_PENDING) ||
               (arp_table[i].state >= ETHARP_STATE_STABLE)));

  /* do we have a new entry? or an implicit query request? */
  if (is_new_entry || (q == NULL)) {
 8111432:	6a3b      	ldr	r3, [r7, #32]
 8111434:	2b00      	cmp	r3, #0
 8111436:	d102      	bne.n	811143e <etharp_query+0x10a>
 8111438:	687b      	ldr	r3, [r7, #4]
 811143a:	2b00      	cmp	r3, #0
 811143c:	d10c      	bne.n	8111458 <etharp_query+0x124>
    /* try to resolve it; send out ARP request */
    result = etharp_request(netif, ipaddr);
 811143e:	68b9      	ldr	r1, [r7, #8]
 8111440:	68f8      	ldr	r0, [r7, #12]
 8111442:	f000 f963 	bl	811170c <etharp_request>
 8111446:	4603      	mov	r3, r0
 8111448:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
      /* ARP request couldn't be sent */
      /* We don't re-send arp request in etharp_tmr, but we still queue packets,
         since this failure could be temporary, and the next packet calling
         etharp_query again could lead to sending the queued packets. */
    }
    if (q == NULL) {
 811144c:	687b      	ldr	r3, [r7, #4]
 811144e:	2b00      	cmp	r3, #0
 8111450:	d102      	bne.n	8111458 <etharp_query+0x124>
      return result;
 8111452:	f997 3027 	ldrsb.w	r3, [r7, #39]	; 0x27
 8111456:	e096      	b.n	8111586 <etharp_query+0x252>
    }
  }

  /* packet given? */
  LWIP_ASSERT("q != NULL", q != NULL);
 8111458:	687b      	ldr	r3, [r7, #4]
 811145a:	2b00      	cmp	r3, #0
 811145c:	d106      	bne.n	811146c <etharp_query+0x138>
 811145e:	4b4c      	ldr	r3, [pc, #304]	; (8111590 <etharp_query+0x25c>)
 8111460:	f240 32e1 	movw	r2, #993	; 0x3e1
 8111464:	494f      	ldr	r1, [pc, #316]	; (81115a4 <etharp_query+0x270>)
 8111466:	484c      	ldr	r0, [pc, #304]	; (8111598 <etharp_query+0x264>)
 8111468:	f00a f9ca 	bl	811b800 <iprintf>
  /* stable entry? */
  if (arp_table[i].state >= ETHARP_STATE_STABLE) {
 811146c:	7c7a      	ldrb	r2, [r7, #17]
 811146e:	494b      	ldr	r1, [pc, #300]	; (811159c <etharp_query+0x268>)
 8111470:	4613      	mov	r3, r2
 8111472:	005b      	lsls	r3, r3, #1
 8111474:	4413      	add	r3, r2
 8111476:	00db      	lsls	r3, r3, #3
 8111478:	440b      	add	r3, r1
 811147a:	3314      	adds	r3, #20
 811147c:	781b      	ldrb	r3, [r3, #0]
 811147e:	2b01      	cmp	r3, #1
 8111480:	d917      	bls.n	81114b2 <etharp_query+0x17e>
    /* we have a valid IP->Ethernet address mapping */
    ETHARP_SET_ADDRHINT(netif, i);
 8111482:	4a49      	ldr	r2, [pc, #292]	; (81115a8 <etharp_query+0x274>)
 8111484:	7c7b      	ldrb	r3, [r7, #17]
 8111486:	7013      	strb	r3, [r2, #0]
    /* send the packet */
    result = ethernet_output(netif, q, srcaddr, &(arp_table[i].ethaddr), ETHTYPE_IP);
 8111488:	7c7a      	ldrb	r2, [r7, #17]
 811148a:	4613      	mov	r3, r2
 811148c:	005b      	lsls	r3, r3, #1
 811148e:	4413      	add	r3, r2
 8111490:	00db      	lsls	r3, r3, #3
 8111492:	3308      	adds	r3, #8
 8111494:	4a41      	ldr	r2, [pc, #260]	; (811159c <etharp_query+0x268>)
 8111496:	4413      	add	r3, r2
 8111498:	3304      	adds	r3, #4
 811149a:	f44f 6200 	mov.w	r2, #2048	; 0x800
 811149e:	9200      	str	r2, [sp, #0]
 81114a0:	697a      	ldr	r2, [r7, #20]
 81114a2:	6879      	ldr	r1, [r7, #4]
 81114a4:	68f8      	ldr	r0, [r7, #12]
 81114a6:	f000 f9d1 	bl	811184c <ethernet_output>
 81114aa:	4603      	mov	r3, r0
 81114ac:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
 81114b0:	e067      	b.n	8111582 <etharp_query+0x24e>
    /* pending entry? (either just created or already pending */
  } else if (arp_table[i].state == ETHARP_STATE_PENDING) {
 81114b2:	7c7a      	ldrb	r2, [r7, #17]
 81114b4:	4939      	ldr	r1, [pc, #228]	; (811159c <etharp_query+0x268>)
 81114b6:	4613      	mov	r3, r2
 81114b8:	005b      	lsls	r3, r3, #1
 81114ba:	4413      	add	r3, r2
 81114bc:	00db      	lsls	r3, r3, #3
 81114be:	440b      	add	r3, r1
 81114c0:	3314      	adds	r3, #20
 81114c2:	781b      	ldrb	r3, [r3, #0]
 81114c4:	2b01      	cmp	r3, #1
 81114c6:	d15c      	bne.n	8111582 <etharp_query+0x24e>
    /* entry is still pending, queue the given packet 'q' */
    struct pbuf *p;
    int copy_needed = 0;
 81114c8:	2300      	movs	r3, #0
 81114ca:	61bb      	str	r3, [r7, #24]
    /* IF q includes a pbuf that must be copied, copy the whole chain into a
     * new PBUF_RAM. See the definition of PBUF_NEEDS_COPY for details. */
    p = q;
 81114cc:	687b      	ldr	r3, [r7, #4]
 81114ce:	61fb      	str	r3, [r7, #28]
    while (p) {
 81114d0:	e01c      	b.n	811150c <etharp_query+0x1d8>
      LWIP_ASSERT("no packet queues allowed!", (p->len != p->tot_len) || (p->next == 0));
 81114d2:	69fb      	ldr	r3, [r7, #28]
 81114d4:	895a      	ldrh	r2, [r3, #10]
 81114d6:	69fb      	ldr	r3, [r7, #28]
 81114d8:	891b      	ldrh	r3, [r3, #8]
 81114da:	429a      	cmp	r2, r3
 81114dc:	d10a      	bne.n	81114f4 <etharp_query+0x1c0>
 81114de:	69fb      	ldr	r3, [r7, #28]
 81114e0:	681b      	ldr	r3, [r3, #0]
 81114e2:	2b00      	cmp	r3, #0
 81114e4:	d006      	beq.n	81114f4 <etharp_query+0x1c0>
 81114e6:	4b2a      	ldr	r3, [pc, #168]	; (8111590 <etharp_query+0x25c>)
 81114e8:	f240 32f1 	movw	r2, #1009	; 0x3f1
 81114ec:	492f      	ldr	r1, [pc, #188]	; (81115ac <etharp_query+0x278>)
 81114ee:	482a      	ldr	r0, [pc, #168]	; (8111598 <etharp_query+0x264>)
 81114f0:	f00a f986 	bl	811b800 <iprintf>
      if (PBUF_NEEDS_COPY(p)) {
 81114f4:	69fb      	ldr	r3, [r7, #28]
 81114f6:	7b1b      	ldrb	r3, [r3, #12]
 81114f8:	f003 0340 	and.w	r3, r3, #64	; 0x40
 81114fc:	2b00      	cmp	r3, #0
 81114fe:	d002      	beq.n	8111506 <etharp_query+0x1d2>
        copy_needed = 1;
 8111500:	2301      	movs	r3, #1
 8111502:	61bb      	str	r3, [r7, #24]
        break;
 8111504:	e005      	b.n	8111512 <etharp_query+0x1de>
      }
      p = p->next;
 8111506:	69fb      	ldr	r3, [r7, #28]
 8111508:	681b      	ldr	r3, [r3, #0]
 811150a:	61fb      	str	r3, [r7, #28]
    while (p) {
 811150c:	69fb      	ldr	r3, [r7, #28]
 811150e:	2b00      	cmp	r3, #0
 8111510:	d1df      	bne.n	81114d2 <etharp_query+0x19e>
    }
    if (copy_needed) {
 8111512:	69bb      	ldr	r3, [r7, #24]
 8111514:	2b00      	cmp	r3, #0
 8111516:	d007      	beq.n	8111528 <etharp_query+0x1f4>
      /* copy the whole packet into new pbufs */
      p = pbuf_clone(PBUF_LINK, PBUF_RAM, q);
 8111518:	687a      	ldr	r2, [r7, #4]
 811151a:	f44f 7120 	mov.w	r1, #640	; 0x280
 811151e:	200e      	movs	r0, #14
 8111520:	f003 fc3e 	bl	8114da0 <pbuf_clone>
 8111524:	61f8      	str	r0, [r7, #28]
 8111526:	e004      	b.n	8111532 <etharp_query+0x1fe>
    } else {
      /* referencing the old pbuf is enough */
      p = q;
 8111528:	687b      	ldr	r3, [r7, #4]
 811152a:	61fb      	str	r3, [r7, #28]
      pbuf_ref(p);
 811152c:	69f8      	ldr	r0, [r7, #28]
 811152e:	f003 f933 	bl	8114798 <pbuf_ref>
    }
    /* packet could be taken over? */
    if (p != NULL) {
 8111532:	69fb      	ldr	r3, [r7, #28]
 8111534:	2b00      	cmp	r3, #0
 8111536:	d021      	beq.n	811157c <etharp_query+0x248>
        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: could not queue a copy of PBUF_REF packet %p (out of memory)\n", (void *)q));
        result = ERR_MEM;
      }
#else /* ARP_QUEUEING */
      /* always queue one packet per ARP request only, freeing a previously queued packet */
      if (arp_table[i].q != NULL) {
 8111538:	7c7a      	ldrb	r2, [r7, #17]
 811153a:	4918      	ldr	r1, [pc, #96]	; (811159c <etharp_query+0x268>)
 811153c:	4613      	mov	r3, r2
 811153e:	005b      	lsls	r3, r3, #1
 8111540:	4413      	add	r3, r2
 8111542:	00db      	lsls	r3, r3, #3
 8111544:	440b      	add	r3, r1
 8111546:	681b      	ldr	r3, [r3, #0]
 8111548:	2b00      	cmp	r3, #0
 811154a:	d00a      	beq.n	8111562 <etharp_query+0x22e>
        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: dropped previously queued packet %p for ARP entry %"U16_F"\n", (void *)q, (u16_t)i));
        pbuf_free(arp_table[i].q);
 811154c:	7c7a      	ldrb	r2, [r7, #17]
 811154e:	4913      	ldr	r1, [pc, #76]	; (811159c <etharp_query+0x268>)
 8111550:	4613      	mov	r3, r2
 8111552:	005b      	lsls	r3, r3, #1
 8111554:	4413      	add	r3, r2
 8111556:	00db      	lsls	r3, r3, #3
 8111558:	440b      	add	r3, r1
 811155a:	681b      	ldr	r3, [r3, #0]
 811155c:	4618      	mov	r0, r3
 811155e:	f003 f87b 	bl	8114658 <pbuf_free>
      }
      arp_table[i].q = p;
 8111562:	7c7a      	ldrb	r2, [r7, #17]
 8111564:	490d      	ldr	r1, [pc, #52]	; (811159c <etharp_query+0x268>)
 8111566:	4613      	mov	r3, r2
 8111568:	005b      	lsls	r3, r3, #1
 811156a:	4413      	add	r3, r2
 811156c:	00db      	lsls	r3, r3, #3
 811156e:	440b      	add	r3, r1
 8111570:	69fa      	ldr	r2, [r7, #28]
 8111572:	601a      	str	r2, [r3, #0]
      result = ERR_OK;
 8111574:	2300      	movs	r3, #0
 8111576:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
 811157a:	e002      	b.n	8111582 <etharp_query+0x24e>
      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: queued packet %p on ARP entry %"U16_F"\n", (void *)q, (u16_t)i));
#endif /* ARP_QUEUEING */
    } else {
      ETHARP_STATS_INC(etharp.memerr);
      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: could not queue a copy of PBUF_REF packet %p (out of memory)\n", (void *)q));
      result = ERR_MEM;
 811157c:	23ff      	movs	r3, #255	; 0xff
 811157e:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
    }
  }
  return result;
 8111582:	f997 3027 	ldrsb.w	r3, [r7, #39]	; 0x27
}
 8111586:	4618      	mov	r0, r3
 8111588:	3728      	adds	r7, #40	; 0x28
 811158a:	46bd      	mov	sp, r7
 811158c:	bd80      	pop	{r7, pc}
 811158e:	bf00      	nop
 8111590:	0811cc48 	.word	0x0811cc48
 8111594:	0811ce28 	.word	0x0811ce28
 8111598:	0811ccf4 	.word	0x0811ccf4
 811159c:	100053fc 	.word	0x100053fc
 81115a0:	0811ce38 	.word	0x0811ce38
 81115a4:	0811ce1c 	.word	0x0811ce1c
 81115a8:	100054ec 	.word	0x100054ec
 81115ac:	0811ce60 	.word	0x0811ce60

081115b0 <etharp_raw>:
etharp_raw(struct netif *netif, const struct eth_addr *ethsrc_addr,
           const struct eth_addr *ethdst_addr,
           const struct eth_addr *hwsrc_addr, const ip4_addr_t *ipsrc_addr,
           const struct eth_addr *hwdst_addr, const ip4_addr_t *ipdst_addr,
           const u16_t opcode)
{
 81115b0:	b580      	push	{r7, lr}
 81115b2:	b08a      	sub	sp, #40	; 0x28
 81115b4:	af02      	add	r7, sp, #8
 81115b6:	60f8      	str	r0, [r7, #12]
 81115b8:	60b9      	str	r1, [r7, #8]
 81115ba:	607a      	str	r2, [r7, #4]
 81115bc:	603b      	str	r3, [r7, #0]
  struct pbuf *p;
  err_t result = ERR_OK;
 81115be:	2300      	movs	r3, #0
 81115c0:	77fb      	strb	r3, [r7, #31]
  struct etharp_hdr *hdr;

  LWIP_ASSERT("netif != NULL", netif != NULL);
 81115c2:	68fb      	ldr	r3, [r7, #12]
 81115c4:	2b00      	cmp	r3, #0
 81115c6:	d106      	bne.n	81115d6 <etharp_raw+0x26>
 81115c8:	4b3a      	ldr	r3, [pc, #232]	; (81116b4 <etharp_raw+0x104>)
 81115ca:	f240 4257 	movw	r2, #1111	; 0x457
 81115ce:	493a      	ldr	r1, [pc, #232]	; (81116b8 <etharp_raw+0x108>)
 81115d0:	483a      	ldr	r0, [pc, #232]	; (81116bc <etharp_raw+0x10c>)
 81115d2:	f00a f915 	bl	811b800 <iprintf>

  /* allocate a pbuf for the outgoing ARP request packet */
  p = pbuf_alloc(PBUF_LINK, SIZEOF_ETHARP_HDR, PBUF_RAM);
 81115d6:	f44f 7220 	mov.w	r2, #640	; 0x280
 81115da:	211c      	movs	r1, #28
 81115dc:	200e      	movs	r0, #14
 81115de:	f002 fd57 	bl	8114090 <pbuf_alloc>
 81115e2:	61b8      	str	r0, [r7, #24]
  /* could allocate a pbuf for an ARP request? */
  if (p == NULL) {
 81115e4:	69bb      	ldr	r3, [r7, #24]
 81115e6:	2b00      	cmp	r3, #0
 81115e8:	d102      	bne.n	81115f0 <etharp_raw+0x40>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS,
                ("etharp_raw: could not allocate pbuf for ARP request.\n"));
    ETHARP_STATS_INC(etharp.memerr);
    return ERR_MEM;
 81115ea:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 81115ee:	e05d      	b.n	81116ac <etharp_raw+0xfc>
  }
  LWIP_ASSERT("check that first pbuf can hold struct etharp_hdr",
 81115f0:	69bb      	ldr	r3, [r7, #24]
 81115f2:	895b      	ldrh	r3, [r3, #10]
 81115f4:	2b1b      	cmp	r3, #27
 81115f6:	d806      	bhi.n	8111606 <etharp_raw+0x56>
 81115f8:	4b2e      	ldr	r3, [pc, #184]	; (81116b4 <etharp_raw+0x104>)
 81115fa:	f240 4262 	movw	r2, #1122	; 0x462
 81115fe:	4930      	ldr	r1, [pc, #192]	; (81116c0 <etharp_raw+0x110>)
 8111600:	482e      	ldr	r0, [pc, #184]	; (81116bc <etharp_raw+0x10c>)
 8111602:	f00a f8fd 	bl	811b800 <iprintf>
              (p->len >= SIZEOF_ETHARP_HDR));

  hdr = (struct etharp_hdr *)p->payload;
 8111606:	69bb      	ldr	r3, [r7, #24]
 8111608:	685b      	ldr	r3, [r3, #4]
 811160a:	617b      	str	r3, [r7, #20]
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_raw: sending raw ARP packet.\n"));
  hdr->opcode = lwip_htons(opcode);
 811160c:	8ebb      	ldrh	r3, [r7, #52]	; 0x34
 811160e:	4618      	mov	r0, r3
 8111610:	f7fc ff3f 	bl	810e492 <lwip_htons>
 8111614:	4603      	mov	r3, r0
 8111616:	461a      	mov	r2, r3
 8111618:	697b      	ldr	r3, [r7, #20]
 811161a:	80da      	strh	r2, [r3, #6]

  LWIP_ASSERT("netif->hwaddr_len must be the same as ETH_HWADDR_LEN for etharp!",
 811161c:	68fb      	ldr	r3, [r7, #12]
 811161e:	f893 3030 	ldrb.w	r3, [r3, #48]	; 0x30
 8111622:	2b06      	cmp	r3, #6
 8111624:	d006      	beq.n	8111634 <etharp_raw+0x84>
 8111626:	4b23      	ldr	r3, [pc, #140]	; (81116b4 <etharp_raw+0x104>)
 8111628:	f240 4269 	movw	r2, #1129	; 0x469
 811162c:	4925      	ldr	r1, [pc, #148]	; (81116c4 <etharp_raw+0x114>)
 811162e:	4823      	ldr	r0, [pc, #140]	; (81116bc <etharp_raw+0x10c>)
 8111630:	f00a f8e6 	bl	811b800 <iprintf>
              (netif->hwaddr_len == ETH_HWADDR_LEN));

  /* Write the ARP MAC-Addresses */
  SMEMCPY(&hdr->shwaddr, hwsrc_addr, ETH_HWADDR_LEN);
 8111634:	697b      	ldr	r3, [r7, #20]
 8111636:	3308      	adds	r3, #8
 8111638:	2206      	movs	r2, #6
 811163a:	6839      	ldr	r1, [r7, #0]
 811163c:	4618      	mov	r0, r3
 811163e:	f00a f937 	bl	811b8b0 <memcpy>
  SMEMCPY(&hdr->dhwaddr, hwdst_addr, ETH_HWADDR_LEN);
 8111642:	697b      	ldr	r3, [r7, #20]
 8111644:	3312      	adds	r3, #18
 8111646:	2206      	movs	r2, #6
 8111648:	6af9      	ldr	r1, [r7, #44]	; 0x2c
 811164a:	4618      	mov	r0, r3
 811164c:	f00a f930 	bl	811b8b0 <memcpy>
  /* Copy struct ip4_addr_wordaligned to aligned ip4_addr, to support compilers without
   * structure packing. */
  IPADDR_WORDALIGNED_COPY_FROM_IP4_ADDR_T(&hdr->sipaddr, ipsrc_addr);
 8111650:	697b      	ldr	r3, [r7, #20]
 8111652:	330e      	adds	r3, #14
 8111654:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8111656:	6812      	ldr	r2, [r2, #0]
 8111658:	601a      	str	r2, [r3, #0]
  IPADDR_WORDALIGNED_COPY_FROM_IP4_ADDR_T(&hdr->dipaddr, ipdst_addr);
 811165a:	697b      	ldr	r3, [r7, #20]
 811165c:	3318      	adds	r3, #24
 811165e:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 8111660:	6812      	ldr	r2, [r2, #0]
 8111662:	601a      	str	r2, [r3, #0]

  hdr->hwtype = PP_HTONS(LWIP_IANA_HWTYPE_ETHERNET);
 8111664:	697b      	ldr	r3, [r7, #20]
 8111666:	2200      	movs	r2, #0
 8111668:	701a      	strb	r2, [r3, #0]
 811166a:	2200      	movs	r2, #0
 811166c:	f042 0201 	orr.w	r2, r2, #1
 8111670:	705a      	strb	r2, [r3, #1]
  hdr->proto = PP_HTONS(ETHTYPE_IP);
 8111672:	697b      	ldr	r3, [r7, #20]
 8111674:	2200      	movs	r2, #0
 8111676:	f042 0208 	orr.w	r2, r2, #8
 811167a:	709a      	strb	r2, [r3, #2]
 811167c:	2200      	movs	r2, #0
 811167e:	70da      	strb	r2, [r3, #3]
  /* set hwlen and protolen */
  hdr->hwlen = ETH_HWADDR_LEN;
 8111680:	697b      	ldr	r3, [r7, #20]
 8111682:	2206      	movs	r2, #6
 8111684:	711a      	strb	r2, [r3, #4]
  hdr->protolen = sizeof(ip4_addr_t);
 8111686:	697b      	ldr	r3, [r7, #20]
 8111688:	2204      	movs	r2, #4
 811168a:	715a      	strb	r2, [r3, #5]
  if (ip4_addr_islinklocal(ipsrc_addr)) {
    ethernet_output(netif, p, ethsrc_addr, &ethbroadcast, ETHTYPE_ARP);
  } else
#endif /* LWIP_AUTOIP */
  {
    ethernet_output(netif, p, ethsrc_addr, ethdst_addr, ETHTYPE_ARP);
 811168c:	f640 0306 	movw	r3, #2054	; 0x806
 8111690:	9300      	str	r3, [sp, #0]
 8111692:	687b      	ldr	r3, [r7, #4]
 8111694:	68ba      	ldr	r2, [r7, #8]
 8111696:	69b9      	ldr	r1, [r7, #24]
 8111698:	68f8      	ldr	r0, [r7, #12]
 811169a:	f000 f8d7 	bl	811184c <ethernet_output>
  }

  ETHARP_STATS_INC(etharp.xmit);
  /* free ARP query packet */
  pbuf_free(p);
 811169e:	69b8      	ldr	r0, [r7, #24]
 81116a0:	f002 ffda 	bl	8114658 <pbuf_free>
  p = NULL;
 81116a4:	2300      	movs	r3, #0
 81116a6:	61bb      	str	r3, [r7, #24]
  /* could not allocate pbuf for ARP request */

  return result;
 81116a8:	f997 301f 	ldrsb.w	r3, [r7, #31]
}
 81116ac:	4618      	mov	r0, r3
 81116ae:	3720      	adds	r7, #32
 81116b0:	46bd      	mov	sp, r7
 81116b2:	bd80      	pop	{r7, pc}
 81116b4:	0811cc48 	.word	0x0811cc48
 81116b8:	0811cdcc 	.word	0x0811cdcc
 81116bc:	0811ccf4 	.word	0x0811ccf4
 81116c0:	0811ce7c 	.word	0x0811ce7c
 81116c4:	0811ceb0 	.word	0x0811ceb0

081116c8 <etharp_request_dst>:
 *         ERR_MEM if the ARP packet couldn't be allocated
 *         any other err_t on failure
 */
static err_t
etharp_request_dst(struct netif *netif, const ip4_addr_t *ipaddr, const struct eth_addr *hw_dst_addr)
{
 81116c8:	b580      	push	{r7, lr}
 81116ca:	b088      	sub	sp, #32
 81116cc:	af04      	add	r7, sp, #16
 81116ce:	60f8      	str	r0, [r7, #12]
 81116d0:	60b9      	str	r1, [r7, #8]
 81116d2:	607a      	str	r2, [r7, #4]
  return etharp_raw(netif, (struct eth_addr *)netif->hwaddr, hw_dst_addr,
 81116d4:	68fb      	ldr	r3, [r7, #12]
 81116d6:	f103 012a 	add.w	r1, r3, #42	; 0x2a
                    (struct eth_addr *)netif->hwaddr, netif_ip4_addr(netif), &ethzero,
 81116da:	68fb      	ldr	r3, [r7, #12]
 81116dc:	f103 002a 	add.w	r0, r3, #42	; 0x2a
 81116e0:	68fb      	ldr	r3, [r7, #12]
 81116e2:	3304      	adds	r3, #4
  return etharp_raw(netif, (struct eth_addr *)netif->hwaddr, hw_dst_addr,
 81116e4:	2201      	movs	r2, #1
 81116e6:	9203      	str	r2, [sp, #12]
 81116e8:	68ba      	ldr	r2, [r7, #8]
 81116ea:	9202      	str	r2, [sp, #8]
 81116ec:	4a06      	ldr	r2, [pc, #24]	; (8111708 <etharp_request_dst+0x40>)
 81116ee:	9201      	str	r2, [sp, #4]
 81116f0:	9300      	str	r3, [sp, #0]
 81116f2:	4603      	mov	r3, r0
 81116f4:	687a      	ldr	r2, [r7, #4]
 81116f6:	68f8      	ldr	r0, [r7, #12]
 81116f8:	f7ff ff5a 	bl	81115b0 <etharp_raw>
 81116fc:	4603      	mov	r3, r0
                    ipaddr, ARP_REQUEST);
}
 81116fe:	4618      	mov	r0, r3
 8111700:	3710      	adds	r7, #16
 8111702:	46bd      	mov	sp, r7
 8111704:	bd80      	pop	{r7, pc}
 8111706:	bf00      	nop
 8111708:	0811f92c 	.word	0x0811f92c

0811170c <etharp_request>:
 *         ERR_MEM if the ARP packet couldn't be allocated
 *         any other err_t on failure
 */
err_t
etharp_request(struct netif *netif, const ip4_addr_t *ipaddr)
{
 811170c:	b580      	push	{r7, lr}
 811170e:	b082      	sub	sp, #8
 8111710:	af00      	add	r7, sp, #0
 8111712:	6078      	str	r0, [r7, #4]
 8111714:	6039      	str	r1, [r7, #0]
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_request: sending ARP request.\n"));
  return etharp_request_dst(netif, ipaddr, &ethbroadcast);
 8111716:	4a05      	ldr	r2, [pc, #20]	; (811172c <etharp_request+0x20>)
 8111718:	6839      	ldr	r1, [r7, #0]
 811171a:	6878      	ldr	r0, [r7, #4]
 811171c:	f7ff ffd4 	bl	81116c8 <etharp_request_dst>
 8111720:	4603      	mov	r3, r0
}
 8111722:	4618      	mov	r0, r3
 8111724:	3708      	adds	r7, #8
 8111726:	46bd      	mov	sp, r7
 8111728:	bd80      	pop	{r7, pc}
 811172a:	bf00      	nop
 811172c:	0811f924 	.word	0x0811f924

08111730 <ethernet_input>:
 * @see ETHARP_SUPPORT_VLAN
 * @see LWIP_HOOK_VLAN_CHECK
 */
err_t
ethernet_input(struct pbuf *p, struct netif *netif)
{
 8111730:	b580      	push	{r7, lr}
 8111732:	b086      	sub	sp, #24
 8111734:	af00      	add	r7, sp, #0
 8111736:	6078      	str	r0, [r7, #4]
 8111738:	6039      	str	r1, [r7, #0]
  struct eth_hdr *ethhdr;
  u16_t type;
#if LWIP_ARP || ETHARP_SUPPORT_VLAN || LWIP_IPV6
  u16_t next_hdr_offset = SIZEOF_ETH_HDR;
 811173a:	230e      	movs	r3, #14
 811173c:	82fb      	strh	r3, [r7, #22]
#endif /* LWIP_ARP || ETHARP_SUPPORT_VLAN */

  LWIP_ASSERT_CORE_LOCKED();

  if (p->len <= SIZEOF_ETH_HDR) {
 811173e:	687b      	ldr	r3, [r7, #4]
 8111740:	895b      	ldrh	r3, [r3, #10]
 8111742:	2b0e      	cmp	r3, #14
 8111744:	d96e      	bls.n	8111824 <ethernet_input+0xf4>
    ETHARP_STATS_INC(etharp.drop);
    MIB2_STATS_NETIF_INC(netif, ifinerrors);
    goto free_and_return;
  }

  if (p->if_idx == NETIF_NO_INDEX) {
 8111746:	687b      	ldr	r3, [r7, #4]
 8111748:	7bdb      	ldrb	r3, [r3, #15]
 811174a:	2b00      	cmp	r3, #0
 811174c:	d106      	bne.n	811175c <ethernet_input+0x2c>
    p->if_idx = netif_get_index(netif);
 811174e:	683b      	ldr	r3, [r7, #0]
 8111750:	f893 3034 	ldrb.w	r3, [r3, #52]	; 0x34
 8111754:	3301      	adds	r3, #1
 8111756:	b2da      	uxtb	r2, r3
 8111758:	687b      	ldr	r3, [r7, #4]
 811175a:	73da      	strb	r2, [r3, #15]
  }

  /* points to packet payload, which starts with an Ethernet header */
  ethhdr = (struct eth_hdr *)p->payload;
 811175c:	687b      	ldr	r3, [r7, #4]
 811175e:	685b      	ldr	r3, [r3, #4]
 8111760:	613b      	str	r3, [r7, #16]
               (unsigned char)ethhdr->dest.addr[3], (unsigned char)ethhdr->dest.addr[4], (unsigned char)ethhdr->dest.addr[5],
               (unsigned char)ethhdr->src.addr[0],  (unsigned char)ethhdr->src.addr[1],  (unsigned char)ethhdr->src.addr[2],
               (unsigned char)ethhdr->src.addr[3],  (unsigned char)ethhdr->src.addr[4],  (unsigned char)ethhdr->src.addr[5],
               lwip_htons(ethhdr->type)));

  type = ethhdr->type;
 8111762:	693b      	ldr	r3, [r7, #16]
 8111764:	7b1a      	ldrb	r2, [r3, #12]
 8111766:	7b5b      	ldrb	r3, [r3, #13]
 8111768:	021b      	lsls	r3, r3, #8
 811176a:	4313      	orrs	r3, r2
 811176c:	81fb      	strh	r3, [r7, #14]

#if LWIP_ARP_FILTER_NETIF
  netif = LWIP_ARP_FILTER_NETIF_FN(p, netif, lwip_htons(type));
#endif /* LWIP_ARP_FILTER_NETIF*/

  if (ethhdr->dest.addr[0] & 1) {
 811176e:	693b      	ldr	r3, [r7, #16]
 8111770:	781b      	ldrb	r3, [r3, #0]
 8111772:	f003 0301 	and.w	r3, r3, #1
 8111776:	2b00      	cmp	r3, #0
 8111778:	d023      	beq.n	81117c2 <ethernet_input+0x92>
    /* this might be a multicast or broadcast packet */
    if (ethhdr->dest.addr[0] == LL_IP4_MULTICAST_ADDR_0) {
 811177a:	693b      	ldr	r3, [r7, #16]
 811177c:	781b      	ldrb	r3, [r3, #0]
 811177e:	2b01      	cmp	r3, #1
 8111780:	d10f      	bne.n	81117a2 <ethernet_input+0x72>
#if LWIP_IPV4
      if ((ethhdr->dest.addr[1] == LL_IP4_MULTICAST_ADDR_1) &&
 8111782:	693b      	ldr	r3, [r7, #16]
 8111784:	785b      	ldrb	r3, [r3, #1]
 8111786:	2b00      	cmp	r3, #0
 8111788:	d11b      	bne.n	81117c2 <ethernet_input+0x92>
          (ethhdr->dest.addr[2] == LL_IP4_MULTICAST_ADDR_2)) {
 811178a:	693b      	ldr	r3, [r7, #16]
 811178c:	789b      	ldrb	r3, [r3, #2]
      if ((ethhdr->dest.addr[1] == LL_IP4_MULTICAST_ADDR_1) &&
 811178e:	2b5e      	cmp	r3, #94	; 0x5e
 8111790:	d117      	bne.n	81117c2 <ethernet_input+0x92>
        /* mark the pbuf as link-layer multicast */
        p->flags |= PBUF_FLAG_LLMCAST;
 8111792:	687b      	ldr	r3, [r7, #4]
 8111794:	7b5b      	ldrb	r3, [r3, #13]
 8111796:	f043 0310 	orr.w	r3, r3, #16
 811179a:	b2da      	uxtb	r2, r3
 811179c:	687b      	ldr	r3, [r7, #4]
 811179e:	735a      	strb	r2, [r3, #13]
 81117a0:	e00f      	b.n	81117c2 <ethernet_input+0x92>
             (ethhdr->dest.addr[1] == LL_IP6_MULTICAST_ADDR_1)) {
      /* mark the pbuf as link-layer multicast */
      p->flags |= PBUF_FLAG_LLMCAST;
    }
#endif /* LWIP_IPV6 */
    else if (eth_addr_cmp(&ethhdr->dest, &ethbroadcast)) {
 81117a2:	693b      	ldr	r3, [r7, #16]
 81117a4:	2206      	movs	r2, #6
 81117a6:	4928      	ldr	r1, [pc, #160]	; (8111848 <ethernet_input+0x118>)
 81117a8:	4618      	mov	r0, r3
 81117aa:	f00a f843 	bl	811b834 <memcmp>
 81117ae:	4603      	mov	r3, r0
 81117b0:	2b00      	cmp	r3, #0
 81117b2:	d106      	bne.n	81117c2 <ethernet_input+0x92>
      /* mark the pbuf as link-layer broadcast */
      p->flags |= PBUF_FLAG_LLBCAST;
 81117b4:	687b      	ldr	r3, [r7, #4]
 81117b6:	7b5b      	ldrb	r3, [r3, #13]
 81117b8:	f043 0308 	orr.w	r3, r3, #8
 81117bc:	b2da      	uxtb	r2, r3
 81117be:	687b      	ldr	r3, [r7, #4]
 81117c0:	735a      	strb	r2, [r3, #13]
    }
  }

  switch (type) {
 81117c2:	89fb      	ldrh	r3, [r7, #14]
 81117c4:	2b08      	cmp	r3, #8
 81117c6:	d003      	beq.n	81117d0 <ethernet_input+0xa0>
 81117c8:	f5b3 6fc1 	cmp.w	r3, #1544	; 0x608
 81117cc:	d014      	beq.n	81117f8 <ethernet_input+0xc8>
      }
#endif
      ETHARP_STATS_INC(etharp.proterr);
      ETHARP_STATS_INC(etharp.drop);
      MIB2_STATS_NETIF_INC(netif, ifinunknownprotos);
      goto free_and_return;
 81117ce:	e032      	b.n	8111836 <ethernet_input+0x106>
      if (!(netif->flags & NETIF_FLAG_ETHARP)) {
 81117d0:	683b      	ldr	r3, [r7, #0]
 81117d2:	f893 3031 	ldrb.w	r3, [r3, #49]	; 0x31
 81117d6:	f003 0308 	and.w	r3, r3, #8
 81117da:	2b00      	cmp	r3, #0
 81117dc:	d024      	beq.n	8111828 <ethernet_input+0xf8>
      if (pbuf_remove_header(p, next_hdr_offset)) {
 81117de:	8afb      	ldrh	r3, [r7, #22]
 81117e0:	4619      	mov	r1, r3
 81117e2:	6878      	ldr	r0, [r7, #4]
 81117e4:	f002 feb2 	bl	811454c <pbuf_remove_header>
 81117e8:	4603      	mov	r3, r0
 81117ea:	2b00      	cmp	r3, #0
 81117ec:	d11e      	bne.n	811182c <ethernet_input+0xfc>
        ip4_input(p, netif);
 81117ee:	6839      	ldr	r1, [r7, #0]
 81117f0:	6878      	ldr	r0, [r7, #4]
 81117f2:	f000 fb95 	bl	8111f20 <ip4_input>
      break;
 81117f6:	e013      	b.n	8111820 <ethernet_input+0xf0>
      if (!(netif->flags & NETIF_FLAG_ETHARP)) {
 81117f8:	683b      	ldr	r3, [r7, #0]
 81117fa:	f893 3031 	ldrb.w	r3, [r3, #49]	; 0x31
 81117fe:	f003 0308 	and.w	r3, r3, #8
 8111802:	2b00      	cmp	r3, #0
 8111804:	d014      	beq.n	8111830 <ethernet_input+0x100>
      if (pbuf_remove_header(p, next_hdr_offset)) {
 8111806:	8afb      	ldrh	r3, [r7, #22]
 8111808:	4619      	mov	r1, r3
 811180a:	6878      	ldr	r0, [r7, #4]
 811180c:	f002 fe9e 	bl	811454c <pbuf_remove_header>
 8111810:	4603      	mov	r3, r0
 8111812:	2b00      	cmp	r3, #0
 8111814:	d10e      	bne.n	8111834 <ethernet_input+0x104>
        etharp_input(p, netif);
 8111816:	6839      	ldr	r1, [r7, #0]
 8111818:	6878      	ldr	r0, [r7, #4]
 811181a:	f7ff fb61 	bl	8110ee0 <etharp_input>
      break;
 811181e:	bf00      	nop
  }

  /* This means the pbuf is freed or consumed,
     so the caller doesn't have to free it again */
  return ERR_OK;
 8111820:	2300      	movs	r3, #0
 8111822:	e00c      	b.n	811183e <ethernet_input+0x10e>
    goto free_and_return;
 8111824:	bf00      	nop
 8111826:	e006      	b.n	8111836 <ethernet_input+0x106>
        goto free_and_return;
 8111828:	bf00      	nop
 811182a:	e004      	b.n	8111836 <ethernet_input+0x106>
        goto free_and_return;
 811182c:	bf00      	nop
 811182e:	e002      	b.n	8111836 <ethernet_input+0x106>
        goto free_and_return;
 8111830:	bf00      	nop
 8111832:	e000      	b.n	8111836 <ethernet_input+0x106>
        goto free_and_return;
 8111834:	bf00      	nop

free_and_return:
  pbuf_free(p);
 8111836:	6878      	ldr	r0, [r7, #4]
 8111838:	f002 ff0e 	bl	8114658 <pbuf_free>
  return ERR_OK;
 811183c:	2300      	movs	r3, #0
}
 811183e:	4618      	mov	r0, r3
 8111840:	3718      	adds	r7, #24
 8111842:	46bd      	mov	sp, r7
 8111844:	bd80      	pop	{r7, pc}
 8111846:	bf00      	nop
 8111848:	0811f924 	.word	0x0811f924

0811184c <ethernet_output>:
 * @return ERR_OK if the packet was sent, any other err_t on failure
 */
err_t
ethernet_output(struct netif * netif, struct pbuf * p,
                const struct eth_addr * src, const struct eth_addr * dst,
                u16_t eth_type) {
 811184c:	b580      	push	{r7, lr}
 811184e:	b086      	sub	sp, #24
 8111850:	af00      	add	r7, sp, #0
 8111852:	60f8      	str	r0, [r7, #12]
 8111854:	60b9      	str	r1, [r7, #8]
 8111856:	607a      	str	r2, [r7, #4]
 8111858:	603b      	str	r3, [r7, #0]
  struct eth_hdr *ethhdr;
  u16_t eth_type_be = lwip_htons(eth_type);
 811185a:	8c3b      	ldrh	r3, [r7, #32]
 811185c:	4618      	mov	r0, r3
 811185e:	f7fc fe18 	bl	810e492 <lwip_htons>
 8111862:	4603      	mov	r3, r0
 8111864:	82fb      	strh	r3, [r7, #22]

    eth_type_be = PP_HTONS(ETHTYPE_VLAN);
  } else
#endif /* ETHARP_SUPPORT_VLAN && defined(LWIP_HOOK_VLAN_SET) */
  {
    if (pbuf_add_header(p, SIZEOF_ETH_HDR) != 0) {
 8111866:	210e      	movs	r1, #14
 8111868:	68b8      	ldr	r0, [r7, #8]
 811186a:	f002 fe5f 	bl	811452c <pbuf_add_header>
 811186e:	4603      	mov	r3, r0
 8111870:	2b00      	cmp	r3, #0
 8111872:	d125      	bne.n	81118c0 <ethernet_output+0x74>
    }
  }

  LWIP_ASSERT_CORE_LOCKED();

  ethhdr = (struct eth_hdr *)p->payload;
 8111874:	68bb      	ldr	r3, [r7, #8]
 8111876:	685b      	ldr	r3, [r3, #4]
 8111878:	613b      	str	r3, [r7, #16]
  ethhdr->type = eth_type_be;
 811187a:	693b      	ldr	r3, [r7, #16]
 811187c:	8afa      	ldrh	r2, [r7, #22]
 811187e:	819a      	strh	r2, [r3, #12]
  SMEMCPY(&ethhdr->dest, dst, ETH_HWADDR_LEN);
 8111880:	693b      	ldr	r3, [r7, #16]
 8111882:	2206      	movs	r2, #6
 8111884:	6839      	ldr	r1, [r7, #0]
 8111886:	4618      	mov	r0, r3
 8111888:	f00a f812 	bl	811b8b0 <memcpy>
  SMEMCPY(&ethhdr->src,  src, ETH_HWADDR_LEN);
 811188c:	693b      	ldr	r3, [r7, #16]
 811188e:	3306      	adds	r3, #6
 8111890:	2206      	movs	r2, #6
 8111892:	6879      	ldr	r1, [r7, #4]
 8111894:	4618      	mov	r0, r3
 8111896:	f00a f80b 	bl	811b8b0 <memcpy>

  LWIP_ASSERT("netif->hwaddr_len must be 6 for ethernet_output!",
 811189a:	68fb      	ldr	r3, [r7, #12]
 811189c:	f893 3030 	ldrb.w	r3, [r3, #48]	; 0x30
 81118a0:	2b06      	cmp	r3, #6
 81118a2:	d006      	beq.n	81118b2 <ethernet_output+0x66>
 81118a4:	4b0a      	ldr	r3, [pc, #40]	; (81118d0 <ethernet_output+0x84>)
 81118a6:	f44f 7299 	mov.w	r2, #306	; 0x132
 81118aa:	490a      	ldr	r1, [pc, #40]	; (81118d4 <ethernet_output+0x88>)
 81118ac:	480a      	ldr	r0, [pc, #40]	; (81118d8 <ethernet_output+0x8c>)
 81118ae:	f009 ffa7 	bl	811b800 <iprintf>
              (netif->hwaddr_len == ETH_HWADDR_LEN));
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE,
              ("ethernet_output: sending packet %p\n", (void *)p));

  /* send the packet */
  return netif->linkoutput(netif, p);
 81118b2:	68fb      	ldr	r3, [r7, #12]
 81118b4:	699b      	ldr	r3, [r3, #24]
 81118b6:	68b9      	ldr	r1, [r7, #8]
 81118b8:	68f8      	ldr	r0, [r7, #12]
 81118ba:	4798      	blx	r3
 81118bc:	4603      	mov	r3, r0
 81118be:	e002      	b.n	81118c6 <ethernet_output+0x7a>
      goto pbuf_header_failed;
 81118c0:	bf00      	nop

pbuf_header_failed:
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS,
              ("ethernet_output: could not allocate room for header.\n"));
  LINK_STATS_INC(link.lenerr);
  return ERR_BUF;
 81118c2:	f06f 0301 	mvn.w	r3, #1
}
 81118c6:	4618      	mov	r0, r3
 81118c8:	3718      	adds	r7, #24
 81118ca:	46bd      	mov	sp, r7
 81118cc:	bd80      	pop	{r7, pc}
 81118ce:	bf00      	nop
 81118d0:	0811cef4 	.word	0x0811cef4
 81118d4:	0811cf5c 	.word	0x0811cf5c
 81118d8:	0811cf90 	.word	0x0811cf90

081118dc <icmp_input>:
 * @param p the icmp echo request packet, p->payload pointing to the icmp header
 * @param inp the netif on which this packet was received
 */
void
icmp_input(struct pbuf *p, struct netif *inp)
{
 81118dc:	b580      	push	{r7, lr}
 81118de:	b08e      	sub	sp, #56	; 0x38
 81118e0:	af04      	add	r7, sp, #16
 81118e2:	6078      	str	r0, [r7, #4]
 81118e4:	6039      	str	r1, [r7, #0]
  const ip4_addr_t *src;

  ICMP_STATS_INC(icmp.recv);
  MIB2_STATS_INC(mib2.icmpinmsgs);

  iphdr_in = ip4_current_header();
 81118e6:	4b87      	ldr	r3, [pc, #540]	; (8111b04 <icmp_input+0x228>)
 81118e8:	689b      	ldr	r3, [r3, #8]
 81118ea:	627b      	str	r3, [r7, #36]	; 0x24
  hlen = IPH_HL_BYTES(iphdr_in);
 81118ec:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 81118ee:	781b      	ldrb	r3, [r3, #0]
 81118f0:	f003 030f 	and.w	r3, r3, #15
 81118f4:	b2db      	uxtb	r3, r3
 81118f6:	009b      	lsls	r3, r3, #2
 81118f8:	b2db      	uxtb	r3, r3
 81118fa:	847b      	strh	r3, [r7, #34]	; 0x22
  if (hlen < IP_HLEN) {
 81118fc:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
 81118fe:	2b13      	cmp	r3, #19
 8111900:	f240 80e8 	bls.w	8111ad4 <icmp_input+0x1f8>
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: short IP header (%"S16_F" bytes) received\n", hlen));
    goto lenerr;
  }
  if (p->len < sizeof(u16_t) * 2) {
 8111904:	687b      	ldr	r3, [r7, #4]
 8111906:	895b      	ldrh	r3, [r3, #10]
 8111908:	2b03      	cmp	r3, #3
 811190a:	f240 80e5 	bls.w	8111ad8 <icmp_input+0x1fc>
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: short ICMP (%"U16_F" bytes) received\n", p->tot_len));
    goto lenerr;
  }

  type = *((u8_t *)p->payload);
 811190e:	687b      	ldr	r3, [r7, #4]
 8111910:	685b      	ldr	r3, [r3, #4]
 8111912:	781b      	ldrb	r3, [r3, #0]
 8111914:	f887 3021 	strb.w	r3, [r7, #33]	; 0x21
#ifdef LWIP_DEBUG
  code = *(((u8_t *)p->payload) + 1);
  /* if debug is enabled but debug statement below is somehow disabled: */
  LWIP_UNUSED_ARG(code);
#endif /* LWIP_DEBUG */
  switch (type) {
 8111918:	f897 3021 	ldrb.w	r3, [r7, #33]	; 0x21
 811191c:	2b00      	cmp	r3, #0
 811191e:	f000 80d2 	beq.w	8111ac6 <icmp_input+0x1ea>
 8111922:	2b08      	cmp	r3, #8
 8111924:	f040 80d2 	bne.w	8111acc <icmp_input+0x1f0>
         (as obviously, an echo request has been sent, too). */
      MIB2_STATS_INC(mib2.icmpinechoreps);
      break;
    case ICMP_ECHO:
      MIB2_STATS_INC(mib2.icmpinechos);
      src = ip4_current_dest_addr();
 8111928:	4b77      	ldr	r3, [pc, #476]	; (8111b08 <icmp_input+0x22c>)
 811192a:	61fb      	str	r3, [r7, #28]
      /* multicast destination address? */
      if (ip4_addr_ismulticast(ip4_current_dest_addr())) {
 811192c:	4b75      	ldr	r3, [pc, #468]	; (8111b04 <icmp_input+0x228>)
 811192e:	695b      	ldr	r3, [r3, #20]
 8111930:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 8111934:	2be0      	cmp	r3, #224	; 0xe0
 8111936:	f000 80d6 	beq.w	8111ae6 <icmp_input+0x20a>
        LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: Not echoing to multicast pings\n"));
        goto icmperr;
#endif /* LWIP_MULTICAST_PING */
      }
      /* broadcast destination address? */
      if (ip4_addr_isbroadcast(ip4_current_dest_addr(), ip_current_netif())) {
 811193a:	4b72      	ldr	r3, [pc, #456]	; (8111b04 <icmp_input+0x228>)
 811193c:	695b      	ldr	r3, [r3, #20]
 811193e:	4a71      	ldr	r2, [pc, #452]	; (8111b04 <icmp_input+0x228>)
 8111940:	6812      	ldr	r2, [r2, #0]
 8111942:	4611      	mov	r1, r2
 8111944:	4618      	mov	r0, r3
 8111946:	f000 fd05 	bl	8112354 <ip4_addr_isbroadcast_u32>
 811194a:	4603      	mov	r3, r0
 811194c:	2b00      	cmp	r3, #0
 811194e:	f040 80cc 	bne.w	8111aea <icmp_input+0x20e>
        LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: Not echoing to broadcast pings\n"));
        goto icmperr;
#endif /* LWIP_BROADCAST_PING */
      }
      LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ping\n"));
      if (p->tot_len < sizeof(struct icmp_echo_hdr)) {
 8111952:	687b      	ldr	r3, [r7, #4]
 8111954:	891b      	ldrh	r3, [r3, #8]
 8111956:	2b07      	cmp	r3, #7
 8111958:	f240 80c0 	bls.w	8111adc <icmp_input+0x200>
        LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: bad ICMP echo received\n"));
        goto lenerr;
      }
#if CHECKSUM_CHECK_ICMP
      IF__NETIF_CHECKSUM_ENABLED(inp, NETIF_CHECKSUM_CHECK_ICMP) {
        if (inet_chksum_pbuf(p) != 0) {
 811195c:	6878      	ldr	r0, [r7, #4]
 811195e:	f000 f9e0 	bl	8111d22 <inet_chksum_pbuf>
 8111962:	4603      	mov	r3, r0
 8111964:	2b00      	cmp	r3, #0
 8111966:	d003      	beq.n	8111970 <icmp_input+0x94>
          LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: checksum failed for received ICMP echo\n"));
          pbuf_free(p);
 8111968:	6878      	ldr	r0, [r7, #4]
 811196a:	f002 fe75 	bl	8114658 <pbuf_free>
          ICMP_STATS_INC(icmp.chkerr);
          MIB2_STATS_INC(mib2.icmpinerrors);
          return;
 811196e:	e0c5      	b.n	8111afc <icmp_input+0x220>
        }
      }
#endif
#if LWIP_ICMP_ECHO_CHECK_INPUT_PBUF_LEN
      if (pbuf_add_header(p, hlen + PBUF_LINK_HLEN + PBUF_LINK_ENCAPSULATION_HLEN)) {
 8111970:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
 8111972:	330e      	adds	r3, #14
 8111974:	4619      	mov	r1, r3
 8111976:	6878      	ldr	r0, [r7, #4]
 8111978:	f002 fdd8 	bl	811452c <pbuf_add_header>
 811197c:	4603      	mov	r3, r0
 811197e:	2b00      	cmp	r3, #0
 8111980:	d04b      	beq.n	8111a1a <icmp_input+0x13e>
        /* p is not big enough to contain link headers
         * allocate a new one and copy p into it
         */
        struct pbuf *r;
        u16_t alloc_len = (u16_t)(p->tot_len + hlen);
 8111982:	687b      	ldr	r3, [r7, #4]
 8111984:	891a      	ldrh	r2, [r3, #8]
 8111986:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
 8111988:	4413      	add	r3, r2
 811198a:	837b      	strh	r3, [r7, #26]
        if (alloc_len < p->tot_len) {
 811198c:	687b      	ldr	r3, [r7, #4]
 811198e:	891b      	ldrh	r3, [r3, #8]
 8111990:	8b7a      	ldrh	r2, [r7, #26]
 8111992:	429a      	cmp	r2, r3
 8111994:	f0c0 80ab 	bcc.w	8111aee <icmp_input+0x212>
          LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: allocating new pbuf failed (tot_len overflow)\n"));
          goto icmperr;
        }
        /* allocate new packet buffer with space for link headers */
        r = pbuf_alloc(PBUF_LINK, alloc_len, PBUF_RAM);
 8111998:	8b7b      	ldrh	r3, [r7, #26]
 811199a:	f44f 7220 	mov.w	r2, #640	; 0x280
 811199e:	4619      	mov	r1, r3
 81119a0:	200e      	movs	r0, #14
 81119a2:	f002 fb75 	bl	8114090 <pbuf_alloc>
 81119a6:	6178      	str	r0, [r7, #20]
        if (r == NULL) {
 81119a8:	697b      	ldr	r3, [r7, #20]
 81119aa:	2b00      	cmp	r3, #0
 81119ac:	f000 80a1 	beq.w	8111af2 <icmp_input+0x216>
          LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: allocating new pbuf failed\n"));
          goto icmperr;
        }
        if (r->len < hlen + sizeof(struct icmp_echo_hdr)) {
 81119b0:	697b      	ldr	r3, [r7, #20]
 81119b2:	895b      	ldrh	r3, [r3, #10]
 81119b4:	461a      	mov	r2, r3
 81119b6:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
 81119b8:	3308      	adds	r3, #8
 81119ba:	429a      	cmp	r2, r3
 81119bc:	d203      	bcs.n	81119c6 <icmp_input+0xea>
          LWIP_DEBUGF(ICMP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("first pbuf cannot hold the ICMP header"));
          pbuf_free(r);
 81119be:	6978      	ldr	r0, [r7, #20]
 81119c0:	f002 fe4a 	bl	8114658 <pbuf_free>
          goto icmperr;
 81119c4:	e096      	b.n	8111af4 <icmp_input+0x218>
        }
        /* copy the ip header */
        MEMCPY(r->payload, iphdr_in, hlen);
 81119c6:	697b      	ldr	r3, [r7, #20]
 81119c8:	685b      	ldr	r3, [r3, #4]
 81119ca:	8c7a      	ldrh	r2, [r7, #34]	; 0x22
 81119cc:	6a79      	ldr	r1, [r7, #36]	; 0x24
 81119ce:	4618      	mov	r0, r3
 81119d0:	f009 ff6e 	bl	811b8b0 <memcpy>
        /* switch r->payload back to icmp header (cannot fail) */
        if (pbuf_remove_header(r, hlen)) {
 81119d4:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
 81119d6:	4619      	mov	r1, r3
 81119d8:	6978      	ldr	r0, [r7, #20]
 81119da:	f002 fdb7 	bl	811454c <pbuf_remove_header>
 81119de:	4603      	mov	r3, r0
 81119e0:	2b00      	cmp	r3, #0
 81119e2:	d009      	beq.n	81119f8 <icmp_input+0x11c>
          LWIP_ASSERT("icmp_input: moving r->payload to icmp header failed\n", 0);
 81119e4:	4b49      	ldr	r3, [pc, #292]	; (8111b0c <icmp_input+0x230>)
 81119e6:	22b6      	movs	r2, #182	; 0xb6
 81119e8:	4949      	ldr	r1, [pc, #292]	; (8111b10 <icmp_input+0x234>)
 81119ea:	484a      	ldr	r0, [pc, #296]	; (8111b14 <icmp_input+0x238>)
 81119ec:	f009 ff08 	bl	811b800 <iprintf>
          pbuf_free(r);
 81119f0:	6978      	ldr	r0, [r7, #20]
 81119f2:	f002 fe31 	bl	8114658 <pbuf_free>
          goto icmperr;
 81119f6:	e07d      	b.n	8111af4 <icmp_input+0x218>
        }
        /* copy the rest of the packet without ip header */
        if (pbuf_copy(r, p) != ERR_OK) {
 81119f8:	6879      	ldr	r1, [r7, #4]
 81119fa:	6978      	ldr	r0, [r7, #20]
 81119fc:	f002 ff54 	bl	81148a8 <pbuf_copy>
 8111a00:	4603      	mov	r3, r0
 8111a02:	2b00      	cmp	r3, #0
 8111a04:	d003      	beq.n	8111a0e <icmp_input+0x132>
          LWIP_DEBUGF(ICMP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("icmp_input: copying to new pbuf failed"));
          pbuf_free(r);
 8111a06:	6978      	ldr	r0, [r7, #20]
 8111a08:	f002 fe26 	bl	8114658 <pbuf_free>
          goto icmperr;
 8111a0c:	e072      	b.n	8111af4 <icmp_input+0x218>
        }
        /* free the original p */
        pbuf_free(p);
 8111a0e:	6878      	ldr	r0, [r7, #4]
 8111a10:	f002 fe22 	bl	8114658 <pbuf_free>
        /* we now have an identical copy of p that has room for link headers */
        p = r;
 8111a14:	697b      	ldr	r3, [r7, #20]
 8111a16:	607b      	str	r3, [r7, #4]
 8111a18:	e00f      	b.n	8111a3a <icmp_input+0x15e>
      } else {
        /* restore p->payload to point to icmp header (cannot fail) */
        if (pbuf_remove_header(p, hlen + PBUF_LINK_HLEN + PBUF_LINK_ENCAPSULATION_HLEN)) {
 8111a1a:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
 8111a1c:	330e      	adds	r3, #14
 8111a1e:	4619      	mov	r1, r3
 8111a20:	6878      	ldr	r0, [r7, #4]
 8111a22:	f002 fd93 	bl	811454c <pbuf_remove_header>
 8111a26:	4603      	mov	r3, r0
 8111a28:	2b00      	cmp	r3, #0
 8111a2a:	d006      	beq.n	8111a3a <icmp_input+0x15e>
          LWIP_ASSERT("icmp_input: restoring original p->payload failed\n", 0);
 8111a2c:	4b37      	ldr	r3, [pc, #220]	; (8111b0c <icmp_input+0x230>)
 8111a2e:	22c7      	movs	r2, #199	; 0xc7
 8111a30:	4939      	ldr	r1, [pc, #228]	; (8111b18 <icmp_input+0x23c>)
 8111a32:	4838      	ldr	r0, [pc, #224]	; (8111b14 <icmp_input+0x238>)
 8111a34:	f009 fee4 	bl	811b800 <iprintf>
          goto icmperr;
 8111a38:	e05c      	b.n	8111af4 <icmp_input+0x218>
      }
#endif /* LWIP_ICMP_ECHO_CHECK_INPUT_PBUF_LEN */
      /* At this point, all checks are OK. */
      /* We generate an answer by switching the dest and src ip addresses,
       * setting the icmp type to ECHO_RESPONSE and updating the checksum. */
      iecho = (struct icmp_echo_hdr *)p->payload;
 8111a3a:	687b      	ldr	r3, [r7, #4]
 8111a3c:	685b      	ldr	r3, [r3, #4]
 8111a3e:	613b      	str	r3, [r7, #16]
      if (pbuf_add_header(p, hlen)) {
 8111a40:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
 8111a42:	4619      	mov	r1, r3
 8111a44:	6878      	ldr	r0, [r7, #4]
 8111a46:	f002 fd71 	bl	811452c <pbuf_add_header>
 8111a4a:	4603      	mov	r3, r0
 8111a4c:	2b00      	cmp	r3, #0
 8111a4e:	d13c      	bne.n	8111aca <icmp_input+0x1ee>
        LWIP_DEBUGF(ICMP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("Can't move over header in packet"));
      } else {
        err_t ret;
        struct ip_hdr *iphdr = (struct ip_hdr *)p->payload;
 8111a50:	687b      	ldr	r3, [r7, #4]
 8111a52:	685b      	ldr	r3, [r3, #4]
 8111a54:	60fb      	str	r3, [r7, #12]
        ip4_addr_copy(iphdr->src, *src);
 8111a56:	69fb      	ldr	r3, [r7, #28]
 8111a58:	681a      	ldr	r2, [r3, #0]
 8111a5a:	68fb      	ldr	r3, [r7, #12]
 8111a5c:	60da      	str	r2, [r3, #12]
        ip4_addr_copy(iphdr->dest, *ip4_current_src_addr());
 8111a5e:	4b29      	ldr	r3, [pc, #164]	; (8111b04 <icmp_input+0x228>)
 8111a60:	691a      	ldr	r2, [r3, #16]
 8111a62:	68fb      	ldr	r3, [r7, #12]
 8111a64:	611a      	str	r2, [r3, #16]
        ICMPH_TYPE_SET(iecho, ICMP_ER);
 8111a66:	693b      	ldr	r3, [r7, #16]
 8111a68:	2200      	movs	r2, #0
 8111a6a:	701a      	strb	r2, [r3, #0]
#if CHECKSUM_GEN_ICMP
        IF__NETIF_CHECKSUM_ENABLED(inp, NETIF_CHECKSUM_GEN_ICMP) {
          /* adjust the checksum */
          if (iecho->chksum > PP_HTONS(0xffffU - (ICMP_ECHO << 8))) {
 8111a6c:	693b      	ldr	r3, [r7, #16]
 8111a6e:	885b      	ldrh	r3, [r3, #2]
 8111a70:	b29b      	uxth	r3, r3
 8111a72:	f64f 72f7 	movw	r2, #65527	; 0xfff7
 8111a76:	4293      	cmp	r3, r2
 8111a78:	d907      	bls.n	8111a8a <icmp_input+0x1ae>
            iecho->chksum = (u16_t)(iecho->chksum + PP_HTONS((u16_t)(ICMP_ECHO << 8)) + 1);
 8111a7a:	693b      	ldr	r3, [r7, #16]
 8111a7c:	885b      	ldrh	r3, [r3, #2]
 8111a7e:	b29b      	uxth	r3, r3
 8111a80:	3309      	adds	r3, #9
 8111a82:	b29a      	uxth	r2, r3
 8111a84:	693b      	ldr	r3, [r7, #16]
 8111a86:	805a      	strh	r2, [r3, #2]
 8111a88:	e006      	b.n	8111a98 <icmp_input+0x1bc>
          } else {
            iecho->chksum = (u16_t)(iecho->chksum + PP_HTONS(ICMP_ECHO << 8));
 8111a8a:	693b      	ldr	r3, [r7, #16]
 8111a8c:	885b      	ldrh	r3, [r3, #2]
 8111a8e:	b29b      	uxth	r3, r3
 8111a90:	3308      	adds	r3, #8
 8111a92:	b29a      	uxth	r2, r3
 8111a94:	693b      	ldr	r3, [r7, #16]
 8111a96:	805a      	strh	r2, [r3, #2]
#else /* CHECKSUM_GEN_ICMP */
        iecho->chksum = 0;
#endif /* CHECKSUM_GEN_ICMP */

        /* Set the correct TTL and recalculate the header checksum. */
        IPH_TTL_SET(iphdr, ICMP_TTL);
 8111a98:	68fb      	ldr	r3, [r7, #12]
 8111a9a:	22ff      	movs	r2, #255	; 0xff
 8111a9c:	721a      	strb	r2, [r3, #8]
        IPH_CHKSUM_SET(iphdr, 0);
 8111a9e:	68fb      	ldr	r3, [r7, #12]
 8111aa0:	2200      	movs	r2, #0
 8111aa2:	729a      	strb	r2, [r3, #10]
 8111aa4:	2200      	movs	r2, #0
 8111aa6:	72da      	strb	r2, [r3, #11]
        MIB2_STATS_INC(mib2.icmpoutmsgs);
        /* increase number of echo replies attempted to send */
        MIB2_STATS_INC(mib2.icmpoutechoreps);

        /* send an ICMP packet */
        ret = ip4_output_if(p, src, LWIP_IP_HDRINCL,
 8111aa8:	683b      	ldr	r3, [r7, #0]
 8111aaa:	9302      	str	r3, [sp, #8]
 8111aac:	2301      	movs	r3, #1
 8111aae:	9301      	str	r3, [sp, #4]
 8111ab0:	2300      	movs	r3, #0
 8111ab2:	9300      	str	r3, [sp, #0]
 8111ab4:	23ff      	movs	r3, #255	; 0xff
 8111ab6:	2200      	movs	r2, #0
 8111ab8:	69f9      	ldr	r1, [r7, #28]
 8111aba:	6878      	ldr	r0, [r7, #4]
 8111abc:	f000 fb72 	bl	81121a4 <ip4_output_if>
 8111ac0:	4603      	mov	r3, r0
 8111ac2:	72fb      	strb	r3, [r7, #11]
                            ICMP_TTL, 0, IP_PROTO_ICMP, inp);
        if (ret != ERR_OK) {
          LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ip_output_if returned an error: %s\n", lwip_strerr(ret)));
        }
      }
      break;
 8111ac4:	e001      	b.n	8111aca <icmp_input+0x1ee>
      break;
 8111ac6:	bf00      	nop
 8111ac8:	e000      	b.n	8111acc <icmp_input+0x1f0>
      break;
 8111aca:	bf00      	nop
      LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ICMP type %"S16_F" code %"S16_F" not supported.\n",
                               (s16_t)type, (s16_t)code));
      ICMP_STATS_INC(icmp.proterr);
      ICMP_STATS_INC(icmp.drop);
  }
  pbuf_free(p);
 8111acc:	6878      	ldr	r0, [r7, #4]
 8111ace:	f002 fdc3 	bl	8114658 <pbuf_free>
  return;
 8111ad2:	e013      	b.n	8111afc <icmp_input+0x220>
    goto lenerr;
 8111ad4:	bf00      	nop
 8111ad6:	e002      	b.n	8111ade <icmp_input+0x202>
    goto lenerr;
 8111ad8:	bf00      	nop
 8111ada:	e000      	b.n	8111ade <icmp_input+0x202>
        goto lenerr;
 8111adc:	bf00      	nop
lenerr:
  pbuf_free(p);
 8111ade:	6878      	ldr	r0, [r7, #4]
 8111ae0:	f002 fdba 	bl	8114658 <pbuf_free>
  ICMP_STATS_INC(icmp.lenerr);
  MIB2_STATS_INC(mib2.icmpinerrors);
  return;
 8111ae4:	e00a      	b.n	8111afc <icmp_input+0x220>
        goto icmperr;
 8111ae6:	bf00      	nop
 8111ae8:	e004      	b.n	8111af4 <icmp_input+0x218>
        goto icmperr;
 8111aea:	bf00      	nop
 8111aec:	e002      	b.n	8111af4 <icmp_input+0x218>
          goto icmperr;
 8111aee:	bf00      	nop
 8111af0:	e000      	b.n	8111af4 <icmp_input+0x218>
          goto icmperr;
 8111af2:	bf00      	nop
#if LWIP_ICMP_ECHO_CHECK_INPUT_PBUF_LEN || !LWIP_MULTICAST_PING || !LWIP_BROADCAST_PING
icmperr:
  pbuf_free(p);
 8111af4:	6878      	ldr	r0, [r7, #4]
 8111af6:	f002 fdaf 	bl	8114658 <pbuf_free>
  ICMP_STATS_INC(icmp.err);
  MIB2_STATS_INC(mib2.icmpinerrors);
  return;
 8111afa:	bf00      	nop
#endif /* LWIP_ICMP_ECHO_CHECK_INPUT_PBUF_LEN || !LWIP_MULTICAST_PING || !LWIP_BROADCAST_PING */
}
 8111afc:	3728      	adds	r7, #40	; 0x28
 8111afe:	46bd      	mov	sp, r7
 8111b00:	bd80      	pop	{r7, pc}
 8111b02:	bf00      	nop
 8111b04:	100054f0 	.word	0x100054f0
 8111b08:	10005504 	.word	0x10005504
 8111b0c:	0811cfb8 	.word	0x0811cfb8
 8111b10:	0811d020 	.word	0x0811d020
 8111b14:	0811d058 	.word	0x0811d058
 8111b18:	0811d080 	.word	0x0811d080

08111b1c <icmp_dest_unreach>:
 *          p->payload pointing to the IP header
 * @param t type of the 'unreachable' packet
 */
void
icmp_dest_unreach(struct pbuf *p, enum icmp_dur_type t)
{
 8111b1c:	b580      	push	{r7, lr}
 8111b1e:	b082      	sub	sp, #8
 8111b20:	af00      	add	r7, sp, #0
 8111b22:	6078      	str	r0, [r7, #4]
 8111b24:	460b      	mov	r3, r1
 8111b26:	70fb      	strb	r3, [r7, #3]
  MIB2_STATS_INC(mib2.icmpoutdestunreachs);
  icmp_send_response(p, ICMP_DUR, t);
 8111b28:	78fb      	ldrb	r3, [r7, #3]
 8111b2a:	461a      	mov	r2, r3
 8111b2c:	2103      	movs	r1, #3
 8111b2e:	6878      	ldr	r0, [r7, #4]
 8111b30:	f000 f814 	bl	8111b5c <icmp_send_response>
}
 8111b34:	bf00      	nop
 8111b36:	3708      	adds	r7, #8
 8111b38:	46bd      	mov	sp, r7
 8111b3a:	bd80      	pop	{r7, pc}

08111b3c <icmp_time_exceeded>:
 *          p->payload pointing to the IP header
 * @param t type of the 'time exceeded' packet
 */
void
icmp_time_exceeded(struct pbuf *p, enum icmp_te_type t)
{
 8111b3c:	b580      	push	{r7, lr}
 8111b3e:	b082      	sub	sp, #8
 8111b40:	af00      	add	r7, sp, #0
 8111b42:	6078      	str	r0, [r7, #4]
 8111b44:	460b      	mov	r3, r1
 8111b46:	70fb      	strb	r3, [r7, #3]
  MIB2_STATS_INC(mib2.icmpouttimeexcds);
  icmp_send_response(p, ICMP_TE, t);
 8111b48:	78fb      	ldrb	r3, [r7, #3]
 8111b4a:	461a      	mov	r2, r3
 8111b4c:	210b      	movs	r1, #11
 8111b4e:	6878      	ldr	r0, [r7, #4]
 8111b50:	f000 f804 	bl	8111b5c <icmp_send_response>
}
 8111b54:	bf00      	nop
 8111b56:	3708      	adds	r7, #8
 8111b58:	46bd      	mov	sp, r7
 8111b5a:	bd80      	pop	{r7, pc}

08111b5c <icmp_send_response>:
 * @param type Type of the ICMP header
 * @param code Code of the ICMP header
 */
static void
icmp_send_response(struct pbuf *p, u8_t type, u8_t code)
{
 8111b5c:	b580      	push	{r7, lr}
 8111b5e:	b08c      	sub	sp, #48	; 0x30
 8111b60:	af04      	add	r7, sp, #16
 8111b62:	6078      	str	r0, [r7, #4]
 8111b64:	460b      	mov	r3, r1
 8111b66:	70fb      	strb	r3, [r7, #3]
 8111b68:	4613      	mov	r3, r2
 8111b6a:	70bb      	strb	r3, [r7, #2]

  /* increase number of messages attempted to send */
  MIB2_STATS_INC(mib2.icmpoutmsgs);

  /* ICMP header + IP header + 8 bytes of data */
  q = pbuf_alloc(PBUF_IP, sizeof(struct icmp_echo_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE,
 8111b6c:	f44f 7220 	mov.w	r2, #640	; 0x280
 8111b70:	2124      	movs	r1, #36	; 0x24
 8111b72:	2022      	movs	r0, #34	; 0x22
 8111b74:	f002 fa8c 	bl	8114090 <pbuf_alloc>
 8111b78:	61f8      	str	r0, [r7, #28]
                 PBUF_RAM);
  if (q == NULL) {
 8111b7a:	69fb      	ldr	r3, [r7, #28]
 8111b7c:	2b00      	cmp	r3, #0
 8111b7e:	d056      	beq.n	8111c2e <icmp_send_response+0xd2>
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_time_exceeded: failed to allocate pbuf for ICMP packet.\n"));
    MIB2_STATS_INC(mib2.icmpouterrors);
    return;
  }
  LWIP_ASSERT("check that first pbuf can hold icmp message",
 8111b80:	69fb      	ldr	r3, [r7, #28]
 8111b82:	895b      	ldrh	r3, [r3, #10]
 8111b84:	2b23      	cmp	r3, #35	; 0x23
 8111b86:	d806      	bhi.n	8111b96 <icmp_send_response+0x3a>
 8111b88:	4b2b      	ldr	r3, [pc, #172]	; (8111c38 <icmp_send_response+0xdc>)
 8111b8a:	f44f 72b4 	mov.w	r2, #360	; 0x168
 8111b8e:	492b      	ldr	r1, [pc, #172]	; (8111c3c <icmp_send_response+0xe0>)
 8111b90:	482b      	ldr	r0, [pc, #172]	; (8111c40 <icmp_send_response+0xe4>)
 8111b92:	f009 fe35 	bl	811b800 <iprintf>
              (q->len >= (sizeof(struct icmp_echo_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE)));

  iphdr = (struct ip_hdr *)p->payload;
 8111b96:	687b      	ldr	r3, [r7, #4]
 8111b98:	685b      	ldr	r3, [r3, #4]
 8111b9a:	61bb      	str	r3, [r7, #24]
  ip4_addr_debug_print_val(ICMP_DEBUG, iphdr->src);
  LWIP_DEBUGF(ICMP_DEBUG, (" to "));
  ip4_addr_debug_print_val(ICMP_DEBUG, iphdr->dest);
  LWIP_DEBUGF(ICMP_DEBUG, ("\n"));

  icmphdr = (struct icmp_echo_hdr *)q->payload;
 8111b9c:	69fb      	ldr	r3, [r7, #28]
 8111b9e:	685b      	ldr	r3, [r3, #4]
 8111ba0:	617b      	str	r3, [r7, #20]
  icmphdr->type = type;
 8111ba2:	697b      	ldr	r3, [r7, #20]
 8111ba4:	78fa      	ldrb	r2, [r7, #3]
 8111ba6:	701a      	strb	r2, [r3, #0]
  icmphdr->code = code;
 8111ba8:	697b      	ldr	r3, [r7, #20]
 8111baa:	78ba      	ldrb	r2, [r7, #2]
 8111bac:	705a      	strb	r2, [r3, #1]
  icmphdr->id = 0;
 8111bae:	697b      	ldr	r3, [r7, #20]
 8111bb0:	2200      	movs	r2, #0
 8111bb2:	711a      	strb	r2, [r3, #4]
 8111bb4:	2200      	movs	r2, #0
 8111bb6:	715a      	strb	r2, [r3, #5]
  icmphdr->seqno = 0;
 8111bb8:	697b      	ldr	r3, [r7, #20]
 8111bba:	2200      	movs	r2, #0
 8111bbc:	719a      	strb	r2, [r3, #6]
 8111bbe:	2200      	movs	r2, #0
 8111bc0:	71da      	strb	r2, [r3, #7]

  /* copy fields from original packet */
  SMEMCPY((u8_t *)q->payload + sizeof(struct icmp_echo_hdr), (u8_t *)p->payload,
 8111bc2:	69fb      	ldr	r3, [r7, #28]
 8111bc4:	685b      	ldr	r3, [r3, #4]
 8111bc6:	f103 0008 	add.w	r0, r3, #8
 8111bca:	687b      	ldr	r3, [r7, #4]
 8111bcc:	685b      	ldr	r3, [r3, #4]
 8111bce:	221c      	movs	r2, #28
 8111bd0:	4619      	mov	r1, r3
 8111bd2:	f009 fe6d 	bl	811b8b0 <memcpy>
          IP_HLEN + ICMP_DEST_UNREACH_DATASIZE);

  ip4_addr_copy(iphdr_src, iphdr->src);
 8111bd6:	69bb      	ldr	r3, [r7, #24]
 8111bd8:	68db      	ldr	r3, [r3, #12]
 8111bda:	60fb      	str	r3, [r7, #12]
    ip4_addr_t iphdr_dst;
    ip4_addr_copy(iphdr_dst, iphdr->dest);
    netif = ip4_route_src(&iphdr_dst, &iphdr_src);
  }
#else
  netif = ip4_route(&iphdr_src);
 8111bdc:	f107 030c 	add.w	r3, r7, #12
 8111be0:	4618      	mov	r0, r3
 8111be2:	f000 f903 	bl	8111dec <ip4_route>
 8111be6:	6138      	str	r0, [r7, #16]
#endif
  if (netif != NULL) {
 8111be8:	693b      	ldr	r3, [r7, #16]
 8111bea:	2b00      	cmp	r3, #0
 8111bec:	d01b      	beq.n	8111c26 <icmp_send_response+0xca>
    /* calculate checksum */
    icmphdr->chksum = 0;
 8111bee:	697b      	ldr	r3, [r7, #20]
 8111bf0:	2200      	movs	r2, #0
 8111bf2:	709a      	strb	r2, [r3, #2]
 8111bf4:	2200      	movs	r2, #0
 8111bf6:	70da      	strb	r2, [r3, #3]
#if CHECKSUM_GEN_ICMP
    IF__NETIF_CHECKSUM_ENABLED(netif, NETIF_CHECKSUM_GEN_ICMP) {
      icmphdr->chksum = inet_chksum(icmphdr, q->len);
 8111bf8:	69fb      	ldr	r3, [r7, #28]
 8111bfa:	895b      	ldrh	r3, [r3, #10]
 8111bfc:	4619      	mov	r1, r3
 8111bfe:	6978      	ldr	r0, [r7, #20]
 8111c00:	f000 f87d 	bl	8111cfe <inet_chksum>
 8111c04:	4603      	mov	r3, r0
 8111c06:	461a      	mov	r2, r3
 8111c08:	697b      	ldr	r3, [r7, #20]
 8111c0a:	805a      	strh	r2, [r3, #2]
    }
#endif
    ICMP_STATS_INC(icmp.xmit);
    ip4_output_if(q, NULL, &iphdr_src, ICMP_TTL, 0, IP_PROTO_ICMP, netif);
 8111c0c:	f107 020c 	add.w	r2, r7, #12
 8111c10:	693b      	ldr	r3, [r7, #16]
 8111c12:	9302      	str	r3, [sp, #8]
 8111c14:	2301      	movs	r3, #1
 8111c16:	9301      	str	r3, [sp, #4]
 8111c18:	2300      	movs	r3, #0
 8111c1a:	9300      	str	r3, [sp, #0]
 8111c1c:	23ff      	movs	r3, #255	; 0xff
 8111c1e:	2100      	movs	r1, #0
 8111c20:	69f8      	ldr	r0, [r7, #28]
 8111c22:	f000 fabf 	bl	81121a4 <ip4_output_if>
  }
  pbuf_free(q);
 8111c26:	69f8      	ldr	r0, [r7, #28]
 8111c28:	f002 fd16 	bl	8114658 <pbuf_free>
 8111c2c:	e000      	b.n	8111c30 <icmp_send_response+0xd4>
    return;
 8111c2e:	bf00      	nop
}
 8111c30:	3720      	adds	r7, #32
 8111c32:	46bd      	mov	sp, r7
 8111c34:	bd80      	pop	{r7, pc}
 8111c36:	bf00      	nop
 8111c38:	0811cfb8 	.word	0x0811cfb8
 8111c3c:	0811d0b4 	.word	0x0811d0b4
 8111c40:	0811d058 	.word	0x0811d058

08111c44 <lwip_standard_chksum>:
 * @param len length of data to be summed
 * @return host order (!) lwip checksum (non-inverted Internet sum)
 */
u16_t
lwip_standard_chksum(const void *dataptr, int len)
{
 8111c44:	b480      	push	{r7}
 8111c46:	b089      	sub	sp, #36	; 0x24
 8111c48:	af00      	add	r7, sp, #0
 8111c4a:	6078      	str	r0, [r7, #4]
 8111c4c:	6039      	str	r1, [r7, #0]
  const u8_t *pb = (const u8_t *)dataptr;
 8111c4e:	687b      	ldr	r3, [r7, #4]
 8111c50:	61fb      	str	r3, [r7, #28]
  const u16_t *ps;
  u16_t t = 0;
 8111c52:	2300      	movs	r3, #0
 8111c54:	81fb      	strh	r3, [r7, #14]
  u32_t sum = 0;
 8111c56:	2300      	movs	r3, #0
 8111c58:	617b      	str	r3, [r7, #20]
  int odd = ((mem_ptr_t)pb & 1);
 8111c5a:	69fb      	ldr	r3, [r7, #28]
 8111c5c:	f003 0301 	and.w	r3, r3, #1
 8111c60:	613b      	str	r3, [r7, #16]

  /* Get aligned to u16_t */
  if (odd && len > 0) {
 8111c62:	693b      	ldr	r3, [r7, #16]
 8111c64:	2b00      	cmp	r3, #0
 8111c66:	d00d      	beq.n	8111c84 <lwip_standard_chksum+0x40>
 8111c68:	683b      	ldr	r3, [r7, #0]
 8111c6a:	2b00      	cmp	r3, #0
 8111c6c:	dd0a      	ble.n	8111c84 <lwip_standard_chksum+0x40>
    ((u8_t *)&t)[1] = *pb++;
 8111c6e:	69fa      	ldr	r2, [r7, #28]
 8111c70:	1c53      	adds	r3, r2, #1
 8111c72:	61fb      	str	r3, [r7, #28]
 8111c74:	f107 030e 	add.w	r3, r7, #14
 8111c78:	3301      	adds	r3, #1
 8111c7a:	7812      	ldrb	r2, [r2, #0]
 8111c7c:	701a      	strb	r2, [r3, #0]
    len--;
 8111c7e:	683b      	ldr	r3, [r7, #0]
 8111c80:	3b01      	subs	r3, #1
 8111c82:	603b      	str	r3, [r7, #0]
  }

  /* Add the bulk of the data */
  ps = (const u16_t *)(const void *)pb;
 8111c84:	69fb      	ldr	r3, [r7, #28]
 8111c86:	61bb      	str	r3, [r7, #24]
  while (len > 1) {
 8111c88:	e00a      	b.n	8111ca0 <lwip_standard_chksum+0x5c>
    sum += *ps++;
 8111c8a:	69bb      	ldr	r3, [r7, #24]
 8111c8c:	1c9a      	adds	r2, r3, #2
 8111c8e:	61ba      	str	r2, [r7, #24]
 8111c90:	881b      	ldrh	r3, [r3, #0]
 8111c92:	461a      	mov	r2, r3
 8111c94:	697b      	ldr	r3, [r7, #20]
 8111c96:	4413      	add	r3, r2
 8111c98:	617b      	str	r3, [r7, #20]
    len -= 2;
 8111c9a:	683b      	ldr	r3, [r7, #0]
 8111c9c:	3b02      	subs	r3, #2
 8111c9e:	603b      	str	r3, [r7, #0]
  while (len > 1) {
 8111ca0:	683b      	ldr	r3, [r7, #0]
 8111ca2:	2b01      	cmp	r3, #1
 8111ca4:	dcf1      	bgt.n	8111c8a <lwip_standard_chksum+0x46>
  }

  /* Consume left-over byte, if any */
  if (len > 0) {
 8111ca6:	683b      	ldr	r3, [r7, #0]
 8111ca8:	2b00      	cmp	r3, #0
 8111caa:	dd04      	ble.n	8111cb6 <lwip_standard_chksum+0x72>
    ((u8_t *)&t)[0] = *(const u8_t *)ps;
 8111cac:	f107 030e 	add.w	r3, r7, #14
 8111cb0:	69ba      	ldr	r2, [r7, #24]
 8111cb2:	7812      	ldrb	r2, [r2, #0]
 8111cb4:	701a      	strb	r2, [r3, #0]
  }

  /* Add end bytes */
  sum += t;
 8111cb6:	89fb      	ldrh	r3, [r7, #14]
 8111cb8:	461a      	mov	r2, r3
 8111cba:	697b      	ldr	r3, [r7, #20]
 8111cbc:	4413      	add	r3, r2
 8111cbe:	617b      	str	r3, [r7, #20]

  /* Fold 32-bit sum to 16 bits
     calling this twice is probably faster than if statements... */
  sum = FOLD_U32T(sum);
 8111cc0:	697b      	ldr	r3, [r7, #20]
 8111cc2:	0c1a      	lsrs	r2, r3, #16
 8111cc4:	697b      	ldr	r3, [r7, #20]
 8111cc6:	b29b      	uxth	r3, r3
 8111cc8:	4413      	add	r3, r2
 8111cca:	617b      	str	r3, [r7, #20]
  sum = FOLD_U32T(sum);
 8111ccc:	697b      	ldr	r3, [r7, #20]
 8111cce:	0c1a      	lsrs	r2, r3, #16
 8111cd0:	697b      	ldr	r3, [r7, #20]
 8111cd2:	b29b      	uxth	r3, r3
 8111cd4:	4413      	add	r3, r2
 8111cd6:	617b      	str	r3, [r7, #20]

  /* Swap if alignment was odd */
  if (odd) {
 8111cd8:	693b      	ldr	r3, [r7, #16]
 8111cda:	2b00      	cmp	r3, #0
 8111cdc:	d007      	beq.n	8111cee <lwip_standard_chksum+0xaa>
    sum = SWAP_BYTES_IN_WORD(sum);
 8111cde:	697b      	ldr	r3, [r7, #20]
 8111ce0:	021b      	lsls	r3, r3, #8
 8111ce2:	b29a      	uxth	r2, r3
 8111ce4:	697b      	ldr	r3, [r7, #20]
 8111ce6:	0a1b      	lsrs	r3, r3, #8
 8111ce8:	b2db      	uxtb	r3, r3
 8111cea:	4313      	orrs	r3, r2
 8111cec:	617b      	str	r3, [r7, #20]
  }

  return (u16_t)sum;
 8111cee:	697b      	ldr	r3, [r7, #20]
 8111cf0:	b29b      	uxth	r3, r3
}
 8111cf2:	4618      	mov	r0, r3
 8111cf4:	3724      	adds	r7, #36	; 0x24
 8111cf6:	46bd      	mov	sp, r7
 8111cf8:	f85d 7b04 	ldr.w	r7, [sp], #4
 8111cfc:	4770      	bx	lr

08111cfe <inet_chksum>:
 * @return checksum (as u16_t) to be saved directly in the protocol header
 */

u16_t
inet_chksum(const void *dataptr, u16_t len)
{
 8111cfe:	b580      	push	{r7, lr}
 8111d00:	b082      	sub	sp, #8
 8111d02:	af00      	add	r7, sp, #0
 8111d04:	6078      	str	r0, [r7, #4]
 8111d06:	460b      	mov	r3, r1
 8111d08:	807b      	strh	r3, [r7, #2]
  return (u16_t)~(unsigned int)LWIP_CHKSUM(dataptr, len);
 8111d0a:	887b      	ldrh	r3, [r7, #2]
 8111d0c:	4619      	mov	r1, r3
 8111d0e:	6878      	ldr	r0, [r7, #4]
 8111d10:	f7ff ff98 	bl	8111c44 <lwip_standard_chksum>
 8111d14:	4603      	mov	r3, r0
 8111d16:	43db      	mvns	r3, r3
 8111d18:	b29b      	uxth	r3, r3
}
 8111d1a:	4618      	mov	r0, r3
 8111d1c:	3708      	adds	r7, #8
 8111d1e:	46bd      	mov	sp, r7
 8111d20:	bd80      	pop	{r7, pc}

08111d22 <inet_chksum_pbuf>:
 * @param p pbuf chain over that the checksum should be calculated
 * @return checksum (as u16_t) to be saved directly in the protocol header
 */
u16_t
inet_chksum_pbuf(struct pbuf *p)
{
 8111d22:	b580      	push	{r7, lr}
 8111d24:	b086      	sub	sp, #24
 8111d26:	af00      	add	r7, sp, #0
 8111d28:	6078      	str	r0, [r7, #4]
  u32_t acc;
  struct pbuf *q;
  int swapped = 0;
 8111d2a:	2300      	movs	r3, #0
 8111d2c:	60fb      	str	r3, [r7, #12]

  acc = 0;
 8111d2e:	2300      	movs	r3, #0
 8111d30:	617b      	str	r3, [r7, #20]
  for (q = p; q != NULL; q = q->next) {
 8111d32:	687b      	ldr	r3, [r7, #4]
 8111d34:	613b      	str	r3, [r7, #16]
 8111d36:	e02b      	b.n	8111d90 <inet_chksum_pbuf+0x6e>
    acc += LWIP_CHKSUM(q->payload, q->len);
 8111d38:	693b      	ldr	r3, [r7, #16]
 8111d3a:	685a      	ldr	r2, [r3, #4]
 8111d3c:	693b      	ldr	r3, [r7, #16]
 8111d3e:	895b      	ldrh	r3, [r3, #10]
 8111d40:	4619      	mov	r1, r3
 8111d42:	4610      	mov	r0, r2
 8111d44:	f7ff ff7e 	bl	8111c44 <lwip_standard_chksum>
 8111d48:	4603      	mov	r3, r0
 8111d4a:	461a      	mov	r2, r3
 8111d4c:	697b      	ldr	r3, [r7, #20]
 8111d4e:	4413      	add	r3, r2
 8111d50:	617b      	str	r3, [r7, #20]
    acc = FOLD_U32T(acc);
 8111d52:	697b      	ldr	r3, [r7, #20]
 8111d54:	0c1a      	lsrs	r2, r3, #16
 8111d56:	697b      	ldr	r3, [r7, #20]
 8111d58:	b29b      	uxth	r3, r3
 8111d5a:	4413      	add	r3, r2
 8111d5c:	617b      	str	r3, [r7, #20]
    if (q->len % 2 != 0) {
 8111d5e:	693b      	ldr	r3, [r7, #16]
 8111d60:	895b      	ldrh	r3, [r3, #10]
 8111d62:	f003 0301 	and.w	r3, r3, #1
 8111d66:	b29b      	uxth	r3, r3
 8111d68:	2b00      	cmp	r3, #0
 8111d6a:	d00e      	beq.n	8111d8a <inet_chksum_pbuf+0x68>
      swapped = !swapped;
 8111d6c:	68fb      	ldr	r3, [r7, #12]
 8111d6e:	2b00      	cmp	r3, #0
 8111d70:	bf0c      	ite	eq
 8111d72:	2301      	moveq	r3, #1
 8111d74:	2300      	movne	r3, #0
 8111d76:	b2db      	uxtb	r3, r3
 8111d78:	60fb      	str	r3, [r7, #12]
      acc = SWAP_BYTES_IN_WORD(acc);
 8111d7a:	697b      	ldr	r3, [r7, #20]
 8111d7c:	021b      	lsls	r3, r3, #8
 8111d7e:	b29a      	uxth	r2, r3
 8111d80:	697b      	ldr	r3, [r7, #20]
 8111d82:	0a1b      	lsrs	r3, r3, #8
 8111d84:	b2db      	uxtb	r3, r3
 8111d86:	4313      	orrs	r3, r2
 8111d88:	617b      	str	r3, [r7, #20]
  for (q = p; q != NULL; q = q->next) {
 8111d8a:	693b      	ldr	r3, [r7, #16]
 8111d8c:	681b      	ldr	r3, [r3, #0]
 8111d8e:	613b      	str	r3, [r7, #16]
 8111d90:	693b      	ldr	r3, [r7, #16]
 8111d92:	2b00      	cmp	r3, #0
 8111d94:	d1d0      	bne.n	8111d38 <inet_chksum_pbuf+0x16>
    }
  }

  if (swapped) {
 8111d96:	68fb      	ldr	r3, [r7, #12]
 8111d98:	2b00      	cmp	r3, #0
 8111d9a:	d007      	beq.n	8111dac <inet_chksum_pbuf+0x8a>
    acc = SWAP_BYTES_IN_WORD(acc);
 8111d9c:	697b      	ldr	r3, [r7, #20]
 8111d9e:	021b      	lsls	r3, r3, #8
 8111da0:	b29a      	uxth	r2, r3
 8111da2:	697b      	ldr	r3, [r7, #20]
 8111da4:	0a1b      	lsrs	r3, r3, #8
 8111da6:	b2db      	uxtb	r3, r3
 8111da8:	4313      	orrs	r3, r2
 8111daa:	617b      	str	r3, [r7, #20]
  }
  return (u16_t)~(acc & 0xffffUL);
 8111dac:	697b      	ldr	r3, [r7, #20]
 8111dae:	b29b      	uxth	r3, r3
 8111db0:	43db      	mvns	r3, r3
 8111db2:	b29b      	uxth	r3, r3
}
 8111db4:	4618      	mov	r0, r3
 8111db6:	3718      	adds	r7, #24
 8111db8:	46bd      	mov	sp, r7
 8111dba:	bd80      	pop	{r7, pc}

08111dbc <lwip_init>:
 * Initialize all modules.
 * Use this in NO_SYS mode. Use tcpip_init() otherwise.
 */
void
lwip_init(void)
{
 8111dbc:	b580      	push	{r7, lr}
 8111dbe:	b082      	sub	sp, #8
 8111dc0:	af00      	add	r7, sp, #0
#ifndef LWIP_SKIP_CONST_CHECK
  int a = 0;
 8111dc2:	2300      	movs	r3, #0
 8111dc4:	607b      	str	r3, [r7, #4]
  /* Modules initialization */
  stats_init();
#if !NO_SYS
  sys_init();
#endif /* !NO_SYS */
  mem_init();
 8111dc6:	f001 fa0b 	bl	81131e0 <mem_init>
  memp_init();
 8111dca:	f001 fd0d 	bl	81137e8 <memp_init>
  pbuf_init();
  netif_init();
 8111dce:	f001 fe0b 	bl	81139e8 <netif_init>
#endif /* LWIP_IPV4 */
#if LWIP_RAW
  raw_init();
#endif /* LWIP_RAW */
#if LWIP_UDP
  udp_init();
 8111dd2:	f008 fa9d 	bl	811a310 <udp_init>
#endif /* LWIP_UDP */
#if LWIP_TCP
  tcp_init();
 8111dd6:	f003 f837 	bl	8114e48 <tcp_init>
#endif /* LWIP_TCP */
#if LWIP_IGMP
  igmp_init();
#endif /* LWIP_IGMP */
#if LWIP_DNS
  dns_init();
 8111dda:	f7fe fa6b 	bl	81102b4 <dns_init>
#if PPP_SUPPORT
  ppp_init();
#endif

#if LWIP_TIMERS
  sys_timeouts_init();
 8111dde:	f008 fa4f 	bl	811a280 <sys_timeouts_init>
#endif /* LWIP_TIMERS */
}
 8111de2:	bf00      	nop
 8111de4:	3708      	adds	r7, #8
 8111de6:	46bd      	mov	sp, r7
 8111de8:	bd80      	pop	{r7, pc}
	...

08111dec <ip4_route>:
 * @param dest the destination IP address for which to find the route
 * @return the netif on which to send to reach dest
 */
struct netif *
ip4_route(const ip4_addr_t *dest)
{
 8111dec:	b480      	push	{r7}
 8111dee:	b085      	sub	sp, #20
 8111df0:	af00      	add	r7, sp, #0
 8111df2:	6078      	str	r0, [r7, #4]

  /* bug #54569: in case LWIP_SINGLE_NETIF=1 and LWIP_DEBUGF() disabled, the following loop is optimized away */
  LWIP_UNUSED_ARG(dest);

  /* iterate through netifs */
  NETIF_FOREACH(netif) {
 8111df4:	4b33      	ldr	r3, [pc, #204]	; (8111ec4 <ip4_route+0xd8>)
 8111df6:	681b      	ldr	r3, [r3, #0]
 8111df8:	60fb      	str	r3, [r7, #12]
 8111dfa:	e036      	b.n	8111e6a <ip4_route+0x7e>
    /* is the netif up, does it have a link and a valid address? */
    if (netif_is_up(netif) && netif_is_link_up(netif) && !ip4_addr_isany_val(*netif_ip4_addr(netif))) {
 8111dfc:	68fb      	ldr	r3, [r7, #12]
 8111dfe:	f893 3031 	ldrb.w	r3, [r3, #49]	; 0x31
 8111e02:	f003 0301 	and.w	r3, r3, #1
 8111e06:	b2db      	uxtb	r3, r3
 8111e08:	2b00      	cmp	r3, #0
 8111e0a:	d02b      	beq.n	8111e64 <ip4_route+0x78>
 8111e0c:	68fb      	ldr	r3, [r7, #12]
 8111e0e:	f893 3031 	ldrb.w	r3, [r3, #49]	; 0x31
 8111e12:	089b      	lsrs	r3, r3, #2
 8111e14:	f003 0301 	and.w	r3, r3, #1
 8111e18:	b2db      	uxtb	r3, r3
 8111e1a:	2b00      	cmp	r3, #0
 8111e1c:	d022      	beq.n	8111e64 <ip4_route+0x78>
 8111e1e:	68fb      	ldr	r3, [r7, #12]
 8111e20:	3304      	adds	r3, #4
 8111e22:	681b      	ldr	r3, [r3, #0]
 8111e24:	2b00      	cmp	r3, #0
 8111e26:	d01d      	beq.n	8111e64 <ip4_route+0x78>
      /* network mask matches? */
      if (ip4_addr_netcmp(dest, netif_ip4_addr(netif), netif_ip4_netmask(netif))) {
 8111e28:	687b      	ldr	r3, [r7, #4]
 8111e2a:	681a      	ldr	r2, [r3, #0]
 8111e2c:	68fb      	ldr	r3, [r7, #12]
 8111e2e:	3304      	adds	r3, #4
 8111e30:	681b      	ldr	r3, [r3, #0]
 8111e32:	405a      	eors	r2, r3
 8111e34:	68fb      	ldr	r3, [r7, #12]
 8111e36:	3308      	adds	r3, #8
 8111e38:	681b      	ldr	r3, [r3, #0]
 8111e3a:	4013      	ands	r3, r2
 8111e3c:	2b00      	cmp	r3, #0
 8111e3e:	d101      	bne.n	8111e44 <ip4_route+0x58>
        /* return netif on which to forward IP packet */
        return netif;
 8111e40:	68fb      	ldr	r3, [r7, #12]
 8111e42:	e038      	b.n	8111eb6 <ip4_route+0xca>
      }
      /* gateway matches on a non broadcast interface? (i.e. peer in a point to point interface) */
      if (((netif->flags & NETIF_FLAG_BROADCAST) == 0) && ip4_addr_cmp(dest, netif_ip4_gw(netif))) {
 8111e44:	68fb      	ldr	r3, [r7, #12]
 8111e46:	f893 3031 	ldrb.w	r3, [r3, #49]	; 0x31
 8111e4a:	f003 0302 	and.w	r3, r3, #2
 8111e4e:	2b00      	cmp	r3, #0
 8111e50:	d108      	bne.n	8111e64 <ip4_route+0x78>
 8111e52:	687b      	ldr	r3, [r7, #4]
 8111e54:	681a      	ldr	r2, [r3, #0]
 8111e56:	68fb      	ldr	r3, [r7, #12]
 8111e58:	330c      	adds	r3, #12
 8111e5a:	681b      	ldr	r3, [r3, #0]
 8111e5c:	429a      	cmp	r2, r3
 8111e5e:	d101      	bne.n	8111e64 <ip4_route+0x78>
        /* return netif on which to forward IP packet */
        return netif;
 8111e60:	68fb      	ldr	r3, [r7, #12]
 8111e62:	e028      	b.n	8111eb6 <ip4_route+0xca>
  NETIF_FOREACH(netif) {
 8111e64:	68fb      	ldr	r3, [r7, #12]
 8111e66:	681b      	ldr	r3, [r3, #0]
 8111e68:	60fb      	str	r3, [r7, #12]
 8111e6a:	68fb      	ldr	r3, [r7, #12]
 8111e6c:	2b00      	cmp	r3, #0
 8111e6e:	d1c5      	bne.n	8111dfc <ip4_route+0x10>
    return netif;
  }
#endif
#endif /* !LWIP_SINGLE_NETIF */

  if ((netif_default == NULL) || !netif_is_up(netif_default) || !netif_is_link_up(netif_default) ||
 8111e70:	4b15      	ldr	r3, [pc, #84]	; (8111ec8 <ip4_route+0xdc>)
 8111e72:	681b      	ldr	r3, [r3, #0]
 8111e74:	2b00      	cmp	r3, #0
 8111e76:	d01a      	beq.n	8111eae <ip4_route+0xc2>
 8111e78:	4b13      	ldr	r3, [pc, #76]	; (8111ec8 <ip4_route+0xdc>)
 8111e7a:	681b      	ldr	r3, [r3, #0]
 8111e7c:	f893 3031 	ldrb.w	r3, [r3, #49]	; 0x31
 8111e80:	f003 0301 	and.w	r3, r3, #1
 8111e84:	2b00      	cmp	r3, #0
 8111e86:	d012      	beq.n	8111eae <ip4_route+0xc2>
 8111e88:	4b0f      	ldr	r3, [pc, #60]	; (8111ec8 <ip4_route+0xdc>)
 8111e8a:	681b      	ldr	r3, [r3, #0]
 8111e8c:	f893 3031 	ldrb.w	r3, [r3, #49]	; 0x31
 8111e90:	f003 0304 	and.w	r3, r3, #4
 8111e94:	2b00      	cmp	r3, #0
 8111e96:	d00a      	beq.n	8111eae <ip4_route+0xc2>
      ip4_addr_isany_val(*netif_ip4_addr(netif_default)) || ip4_addr_isloopback(dest)) {
 8111e98:	4b0b      	ldr	r3, [pc, #44]	; (8111ec8 <ip4_route+0xdc>)
 8111e9a:	681b      	ldr	r3, [r3, #0]
 8111e9c:	3304      	adds	r3, #4
 8111e9e:	681b      	ldr	r3, [r3, #0]
  if ((netif_default == NULL) || !netif_is_up(netif_default) || !netif_is_link_up(netif_default) ||
 8111ea0:	2b00      	cmp	r3, #0
 8111ea2:	d004      	beq.n	8111eae <ip4_route+0xc2>
      ip4_addr_isany_val(*netif_ip4_addr(netif_default)) || ip4_addr_isloopback(dest)) {
 8111ea4:	687b      	ldr	r3, [r7, #4]
 8111ea6:	681b      	ldr	r3, [r3, #0]
 8111ea8:	b2db      	uxtb	r3, r3
 8111eaa:	2b7f      	cmp	r3, #127	; 0x7f
 8111eac:	d101      	bne.n	8111eb2 <ip4_route+0xc6>
       If this is not good enough for you, use LWIP_HOOK_IP4_ROUTE() */
    LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("ip4_route: No route to %"U16_F".%"U16_F".%"U16_F".%"U16_F"\n",
                ip4_addr1_16(dest), ip4_addr2_16(dest), ip4_addr3_16(dest), ip4_addr4_16(dest)));
    IP_STATS_INC(ip.rterr);
    MIB2_STATS_INC(mib2.ipoutnoroutes);
    return NULL;
 8111eae:	2300      	movs	r3, #0
 8111eb0:	e001      	b.n	8111eb6 <ip4_route+0xca>
  }

  return netif_default;
 8111eb2:	4b05      	ldr	r3, [pc, #20]	; (8111ec8 <ip4_route+0xdc>)
 8111eb4:	681b      	ldr	r3, [r3, #0]
}
 8111eb6:	4618      	mov	r0, r3
 8111eb8:	3714      	adds	r7, #20
 8111eba:	46bd      	mov	sp, r7
 8111ebc:	f85d 7b04 	ldr.w	r7, [sp], #4
 8111ec0:	4770      	bx	lr
 8111ec2:	bf00      	nop
 8111ec4:	1000843c 	.word	0x1000843c
 8111ec8:	10008440 	.word	0x10008440

08111ecc <ip4_input_accept>:
#endif /* IP_FORWARD */

/** Return true if the current input packet should be accepted on this netif */
static int
ip4_input_accept(struct netif *netif)
{
 8111ecc:	b580      	push	{r7, lr}
 8111ece:	b082      	sub	sp, #8
 8111ed0:	af00      	add	r7, sp, #0
 8111ed2:	6078      	str	r0, [r7, #4]
                         ip4_addr_get_u32(ip4_current_dest_addr()) & ip4_addr_get_u32(netif_ip4_netmask(netif)),
                         ip4_addr_get_u32(netif_ip4_addr(netif)) & ip4_addr_get_u32(netif_ip4_netmask(netif)),
                         ip4_addr_get_u32(ip4_current_dest_addr()) & ~ip4_addr_get_u32(netif_ip4_netmask(netif))));

  /* interface is up and configured? */
  if ((netif_is_up(netif)) && (!ip4_addr_isany_val(*netif_ip4_addr(netif)))) {
 8111ed4:	687b      	ldr	r3, [r7, #4]
 8111ed6:	f893 3031 	ldrb.w	r3, [r3, #49]	; 0x31
 8111eda:	f003 0301 	and.w	r3, r3, #1
 8111ede:	b2db      	uxtb	r3, r3
 8111ee0:	2b00      	cmp	r3, #0
 8111ee2:	d016      	beq.n	8111f12 <ip4_input_accept+0x46>
 8111ee4:	687b      	ldr	r3, [r7, #4]
 8111ee6:	3304      	adds	r3, #4
 8111ee8:	681b      	ldr	r3, [r3, #0]
 8111eea:	2b00      	cmp	r3, #0
 8111eec:	d011      	beq.n	8111f12 <ip4_input_accept+0x46>
    /* unicast to this interface address? */
    if (ip4_addr_cmp(ip4_current_dest_addr(), netif_ip4_addr(netif)) ||
 8111eee:	4b0b      	ldr	r3, [pc, #44]	; (8111f1c <ip4_input_accept+0x50>)
 8111ef0:	695a      	ldr	r2, [r3, #20]
 8111ef2:	687b      	ldr	r3, [r7, #4]
 8111ef4:	3304      	adds	r3, #4
 8111ef6:	681b      	ldr	r3, [r3, #0]
 8111ef8:	429a      	cmp	r2, r3
 8111efa:	d008      	beq.n	8111f0e <ip4_input_accept+0x42>
        /* or broadcast on this interface network address? */
        ip4_addr_isbroadcast(ip4_current_dest_addr(), netif)
 8111efc:	4b07      	ldr	r3, [pc, #28]	; (8111f1c <ip4_input_accept+0x50>)
 8111efe:	695b      	ldr	r3, [r3, #20]
 8111f00:	6879      	ldr	r1, [r7, #4]
 8111f02:	4618      	mov	r0, r3
 8111f04:	f000 fa26 	bl	8112354 <ip4_addr_isbroadcast_u32>
 8111f08:	4603      	mov	r3, r0
    if (ip4_addr_cmp(ip4_current_dest_addr(), netif_ip4_addr(netif)) ||
 8111f0a:	2b00      	cmp	r3, #0
 8111f0c:	d001      	beq.n	8111f12 <ip4_input_accept+0x46>
#endif /* LWIP_NETIF_LOOPBACK && !LWIP_HAVE_LOOPIF */
       ) {
      LWIP_DEBUGF(IP_DEBUG, ("ip4_input: packet accepted on interface %c%c\n",
                             netif->name[0], netif->name[1]));
      /* accept on this netif */
      return 1;
 8111f0e:	2301      	movs	r3, #1
 8111f10:	e000      	b.n	8111f14 <ip4_input_accept+0x48>
      /* accept on this netif */
      return 1;
    }
#endif /* LWIP_AUTOIP */
  }
  return 0;
 8111f12:	2300      	movs	r3, #0
}
 8111f14:	4618      	mov	r0, r3
 8111f16:	3708      	adds	r7, #8
 8111f18:	46bd      	mov	sp, r7
 8111f1a:	bd80      	pop	{r7, pc}
 8111f1c:	100054f0 	.word	0x100054f0

08111f20 <ip4_input>:
 * @return ERR_OK if the packet was processed (could return ERR_* if it wasn't
 *         processed, but currently always returns ERR_OK)
 */
err_t
ip4_input(struct pbuf *p, struct netif *inp)
{
 8111f20:	b580      	push	{r7, lr}
 8111f22:	b088      	sub	sp, #32
 8111f24:	af00      	add	r7, sp, #0
 8111f26:	6078      	str	r0, [r7, #4]
 8111f28:	6039      	str	r1, [r7, #0]
  const struct ip_hdr *iphdr;
  struct netif *netif;
  u16_t iphdr_hlen;
  u16_t iphdr_len;
#if IP_ACCEPT_LINK_LAYER_ADDRESSING || LWIP_IGMP
  int check_ip_src = 1;
 8111f2a:	2301      	movs	r3, #1
 8111f2c:	617b      	str	r3, [r7, #20]

  IP_STATS_INC(ip.recv);
  MIB2_STATS_INC(mib2.ipinreceives);

  /* identify the IP header */
  iphdr = (struct ip_hdr *)p->payload;
 8111f2e:	687b      	ldr	r3, [r7, #4]
 8111f30:	685b      	ldr	r3, [r3, #4]
 8111f32:	61fb      	str	r3, [r7, #28]
  if (IPH_V(iphdr) != 4) {
 8111f34:	69fb      	ldr	r3, [r7, #28]
 8111f36:	781b      	ldrb	r3, [r3, #0]
 8111f38:	091b      	lsrs	r3, r3, #4
 8111f3a:	b2db      	uxtb	r3, r3
 8111f3c:	2b04      	cmp	r3, #4
 8111f3e:	d004      	beq.n	8111f4a <ip4_input+0x2a>
    LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_WARNING, ("IP packet dropped due to bad version number %"U16_F"\n", (u16_t)IPH_V(iphdr)));
    ip4_debug_print(p);
    pbuf_free(p);
 8111f40:	6878      	ldr	r0, [r7, #4]
 8111f42:	f002 fb89 	bl	8114658 <pbuf_free>
    IP_STATS_INC(ip.err);
    IP_STATS_INC(ip.drop);
    MIB2_STATS_INC(mib2.ipinhdrerrors);
    return ERR_OK;
 8111f46:	2300      	movs	r3, #0
 8111f48:	e123      	b.n	8112192 <ip4_input+0x272>
    return ERR_OK;
  }
#endif

  /* obtain IP header length in bytes */
  iphdr_hlen = IPH_HL_BYTES(iphdr);
 8111f4a:	69fb      	ldr	r3, [r7, #28]
 8111f4c:	781b      	ldrb	r3, [r3, #0]
 8111f4e:	f003 030f 	and.w	r3, r3, #15
 8111f52:	b2db      	uxtb	r3, r3
 8111f54:	009b      	lsls	r3, r3, #2
 8111f56:	b2db      	uxtb	r3, r3
 8111f58:	827b      	strh	r3, [r7, #18]
  /* obtain ip length in bytes */
  iphdr_len = lwip_ntohs(IPH_LEN(iphdr));
 8111f5a:	69fb      	ldr	r3, [r7, #28]
 8111f5c:	885b      	ldrh	r3, [r3, #2]
 8111f5e:	b29b      	uxth	r3, r3
 8111f60:	4618      	mov	r0, r3
 8111f62:	f7fc fa96 	bl	810e492 <lwip_htons>
 8111f66:	4603      	mov	r3, r0
 8111f68:	823b      	strh	r3, [r7, #16]

  /* Trim pbuf. This is especially required for packets < 60 bytes. */
  if (iphdr_len < p->tot_len) {
 8111f6a:	687b      	ldr	r3, [r7, #4]
 8111f6c:	891b      	ldrh	r3, [r3, #8]
 8111f6e:	8a3a      	ldrh	r2, [r7, #16]
 8111f70:	429a      	cmp	r2, r3
 8111f72:	d204      	bcs.n	8111f7e <ip4_input+0x5e>
    pbuf_realloc(p, iphdr_len);
 8111f74:	8a3b      	ldrh	r3, [r7, #16]
 8111f76:	4619      	mov	r1, r3
 8111f78:	6878      	ldr	r0, [r7, #4]
 8111f7a:	f002 f9e7 	bl	811434c <pbuf_realloc>
  }

  /* header length exceeds first pbuf length, or ip length exceeds total pbuf length? */
  if ((iphdr_hlen > p->len) || (iphdr_len > p->tot_len) || (iphdr_hlen < IP_HLEN)) {
 8111f7e:	687b      	ldr	r3, [r7, #4]
 8111f80:	895b      	ldrh	r3, [r3, #10]
 8111f82:	8a7a      	ldrh	r2, [r7, #18]
 8111f84:	429a      	cmp	r2, r3
 8111f86:	d807      	bhi.n	8111f98 <ip4_input+0x78>
 8111f88:	687b      	ldr	r3, [r7, #4]
 8111f8a:	891b      	ldrh	r3, [r3, #8]
 8111f8c:	8a3a      	ldrh	r2, [r7, #16]
 8111f8e:	429a      	cmp	r2, r3
 8111f90:	d802      	bhi.n	8111f98 <ip4_input+0x78>
 8111f92:	8a7b      	ldrh	r3, [r7, #18]
 8111f94:	2b13      	cmp	r3, #19
 8111f96:	d804      	bhi.n	8111fa2 <ip4_input+0x82>
      LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
                  ("IP (len %"U16_F") is longer than pbuf (len %"U16_F"), IP packet dropped.\n",
                   iphdr_len, p->tot_len));
    }
    /* free (drop) packet pbufs */
    pbuf_free(p);
 8111f98:	6878      	ldr	r0, [r7, #4]
 8111f9a:	f002 fb5d 	bl	8114658 <pbuf_free>
    IP_STATS_INC(ip.lenerr);
    IP_STATS_INC(ip.drop);
    MIB2_STATS_INC(mib2.ipindiscards);
    return ERR_OK;
 8111f9e:	2300      	movs	r3, #0
 8111fa0:	e0f7      	b.n	8112192 <ip4_input+0x272>
    }
  }
#endif

  /* copy IP addresses to aligned ip_addr_t */
  ip_addr_copy_from_ip4(ip_data.current_iphdr_dest, iphdr->dest);
 8111fa2:	69fb      	ldr	r3, [r7, #28]
 8111fa4:	691b      	ldr	r3, [r3, #16]
 8111fa6:	4a7d      	ldr	r2, [pc, #500]	; (811219c <ip4_input+0x27c>)
 8111fa8:	6153      	str	r3, [r2, #20]
  ip_addr_copy_from_ip4(ip_data.current_iphdr_src, iphdr->src);
 8111faa:	69fb      	ldr	r3, [r7, #28]
 8111fac:	68db      	ldr	r3, [r3, #12]
 8111fae:	4a7b      	ldr	r2, [pc, #492]	; (811219c <ip4_input+0x27c>)
 8111fb0:	6113      	str	r3, [r2, #16]

  /* match packet against an interface, i.e. is this packet for us? */
  if (ip4_addr_ismulticast(ip4_current_dest_addr())) {
 8111fb2:	4b7a      	ldr	r3, [pc, #488]	; (811219c <ip4_input+0x27c>)
 8111fb4:	695b      	ldr	r3, [r3, #20]
 8111fb6:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 8111fba:	2be0      	cmp	r3, #224	; 0xe0
 8111fbc:	d112      	bne.n	8111fe4 <ip4_input+0xc4>
      netif = inp;
    } else {
      netif = NULL;
    }
#else /* LWIP_IGMP */
    if ((netif_is_up(inp)) && (!ip4_addr_isany_val(*netif_ip4_addr(inp)))) {
 8111fbe:	683b      	ldr	r3, [r7, #0]
 8111fc0:	f893 3031 	ldrb.w	r3, [r3, #49]	; 0x31
 8111fc4:	f003 0301 	and.w	r3, r3, #1
 8111fc8:	b2db      	uxtb	r3, r3
 8111fca:	2b00      	cmp	r3, #0
 8111fcc:	d007      	beq.n	8111fde <ip4_input+0xbe>
 8111fce:	683b      	ldr	r3, [r7, #0]
 8111fd0:	3304      	adds	r3, #4
 8111fd2:	681b      	ldr	r3, [r3, #0]
 8111fd4:	2b00      	cmp	r3, #0
 8111fd6:	d002      	beq.n	8111fde <ip4_input+0xbe>
      netif = inp;
 8111fd8:	683b      	ldr	r3, [r7, #0]
 8111fda:	61bb      	str	r3, [r7, #24]
 8111fdc:	e02a      	b.n	8112034 <ip4_input+0x114>
    } else {
      netif = NULL;
 8111fde:	2300      	movs	r3, #0
 8111fe0:	61bb      	str	r3, [r7, #24]
 8111fe2:	e027      	b.n	8112034 <ip4_input+0x114>
    }
#endif /* LWIP_IGMP */
  } else {
    /* start trying with inp. if that's not acceptable, start walking the
       list of configured netifs. */
    if (ip4_input_accept(inp)) {
 8111fe4:	6838      	ldr	r0, [r7, #0]
 8111fe6:	f7ff ff71 	bl	8111ecc <ip4_input_accept>
 8111fea:	4603      	mov	r3, r0
 8111fec:	2b00      	cmp	r3, #0
 8111fee:	d002      	beq.n	8111ff6 <ip4_input+0xd6>
      netif = inp;
 8111ff0:	683b      	ldr	r3, [r7, #0]
 8111ff2:	61bb      	str	r3, [r7, #24]
 8111ff4:	e01e      	b.n	8112034 <ip4_input+0x114>
    } else {
      netif = NULL;
 8111ff6:	2300      	movs	r3, #0
 8111ff8:	61bb      	str	r3, [r7, #24]
#if !LWIP_NETIF_LOOPBACK || LWIP_HAVE_LOOPIF
      /* Packets sent to the loopback address must not be accepted on an
       * interface that does not have the loopback address assigned to it,
       * unless a non-loopback interface is used for loopback traffic. */
      if (!ip4_addr_isloopback(ip4_current_dest_addr()))
 8111ffa:	4b68      	ldr	r3, [pc, #416]	; (811219c <ip4_input+0x27c>)
 8111ffc:	695b      	ldr	r3, [r3, #20]
 8111ffe:	b2db      	uxtb	r3, r3
 8112000:	2b7f      	cmp	r3, #127	; 0x7f
 8112002:	d017      	beq.n	8112034 <ip4_input+0x114>
#endif /* !LWIP_NETIF_LOOPBACK || LWIP_HAVE_LOOPIF */
      {
#if !LWIP_SINGLE_NETIF
        NETIF_FOREACH(netif) {
 8112004:	4b66      	ldr	r3, [pc, #408]	; (81121a0 <ip4_input+0x280>)
 8112006:	681b      	ldr	r3, [r3, #0]
 8112008:	61bb      	str	r3, [r7, #24]
 811200a:	e00e      	b.n	811202a <ip4_input+0x10a>
          if (netif == inp) {
 811200c:	69ba      	ldr	r2, [r7, #24]
 811200e:	683b      	ldr	r3, [r7, #0]
 8112010:	429a      	cmp	r2, r3
 8112012:	d006      	beq.n	8112022 <ip4_input+0x102>
            /* we checked that before already */
            continue;
          }
          if (ip4_input_accept(netif)) {
 8112014:	69b8      	ldr	r0, [r7, #24]
 8112016:	f7ff ff59 	bl	8111ecc <ip4_input_accept>
 811201a:	4603      	mov	r3, r0
 811201c:	2b00      	cmp	r3, #0
 811201e:	d108      	bne.n	8112032 <ip4_input+0x112>
 8112020:	e000      	b.n	8112024 <ip4_input+0x104>
            continue;
 8112022:	bf00      	nop
        NETIF_FOREACH(netif) {
 8112024:	69bb      	ldr	r3, [r7, #24]
 8112026:	681b      	ldr	r3, [r3, #0]
 8112028:	61bb      	str	r3, [r7, #24]
 811202a:	69bb      	ldr	r3, [r7, #24]
 811202c:	2b00      	cmp	r3, #0
 811202e:	d1ed      	bne.n	811200c <ip4_input+0xec>
 8112030:	e000      	b.n	8112034 <ip4_input+0x114>
            break;
 8112032:	bf00      	nop
   * If you want to accept private broadcast communication while a netif is down,
   * define LWIP_IP_ACCEPT_UDP_PORT(dst_port), e.g.:
   *
   * #define LWIP_IP_ACCEPT_UDP_PORT(dst_port) ((dst_port) == PP_NTOHS(12345))
   */
  if (netif == NULL) {
 8112034:	69bb      	ldr	r3, [r7, #24]
 8112036:	2b00      	cmp	r3, #0
 8112038:	d111      	bne.n	811205e <ip4_input+0x13e>
    /* remote port is DHCP server? */
    if (IPH_PROTO(iphdr) == IP_PROTO_UDP) {
 811203a:	69fb      	ldr	r3, [r7, #28]
 811203c:	7a5b      	ldrb	r3, [r3, #9]
 811203e:	2b11      	cmp	r3, #17
 8112040:	d10d      	bne.n	811205e <ip4_input+0x13e>
      const struct udp_hdr *udphdr = (const struct udp_hdr *)((const u8_t *)iphdr + iphdr_hlen);
 8112042:	8a7b      	ldrh	r3, [r7, #18]
 8112044:	69fa      	ldr	r2, [r7, #28]
 8112046:	4413      	add	r3, r2
 8112048:	60fb      	str	r3, [r7, #12]
      LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_TRACE, ("ip4_input: UDP packet to DHCP client port %"U16_F"\n",
                                              lwip_ntohs(udphdr->dest)));
      if (IP_ACCEPT_LINK_LAYER_ADDRESSED_PORT(udphdr->dest)) {
 811204a:	68fb      	ldr	r3, [r7, #12]
 811204c:	885b      	ldrh	r3, [r3, #2]
 811204e:	b29b      	uxth	r3, r3
 8112050:	f5b3 4f88 	cmp.w	r3, #17408	; 0x4400
 8112054:	d103      	bne.n	811205e <ip4_input+0x13e>
        LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_TRACE, ("ip4_input: DHCP packet accepted.\n"));
        netif = inp;
 8112056:	683b      	ldr	r3, [r7, #0]
 8112058:	61bb      	str	r3, [r7, #24]
        check_ip_src = 0;
 811205a:	2300      	movs	r3, #0
 811205c:	617b      	str	r3, [r7, #20]
  }
#endif /* IP_ACCEPT_LINK_LAYER_ADDRESSING */

  /* broadcast or multicast packet source address? Compliant with RFC 1122: 3.2.1.3 */
#if LWIP_IGMP || IP_ACCEPT_LINK_LAYER_ADDRESSING
  if (check_ip_src
 811205e:	697b      	ldr	r3, [r7, #20]
 8112060:	2b00      	cmp	r3, #0
 8112062:	d017      	beq.n	8112094 <ip4_input+0x174>
#if IP_ACCEPT_LINK_LAYER_ADDRESSING
      /* DHCP servers need 0.0.0.0 to be allowed as source address (RFC 1.1.2.2: 3.2.1.3/a) */
      && !ip4_addr_isany_val(*ip4_current_src_addr())
 8112064:	4b4d      	ldr	r3, [pc, #308]	; (811219c <ip4_input+0x27c>)
 8112066:	691b      	ldr	r3, [r3, #16]
 8112068:	2b00      	cmp	r3, #0
 811206a:	d013      	beq.n	8112094 <ip4_input+0x174>
#endif /* IP_ACCEPT_LINK_LAYER_ADDRESSING */
     )
#endif /* LWIP_IGMP || IP_ACCEPT_LINK_LAYER_ADDRESSING */
  {
    if ((ip4_addr_isbroadcast(ip4_current_src_addr(), inp)) ||
 811206c:	4b4b      	ldr	r3, [pc, #300]	; (811219c <ip4_input+0x27c>)
 811206e:	691b      	ldr	r3, [r3, #16]
 8112070:	6839      	ldr	r1, [r7, #0]
 8112072:	4618      	mov	r0, r3
 8112074:	f000 f96e 	bl	8112354 <ip4_addr_isbroadcast_u32>
 8112078:	4603      	mov	r3, r0
 811207a:	2b00      	cmp	r3, #0
 811207c:	d105      	bne.n	811208a <ip4_input+0x16a>
        (ip4_addr_ismulticast(ip4_current_src_addr()))) {
 811207e:	4b47      	ldr	r3, [pc, #284]	; (811219c <ip4_input+0x27c>)
 8112080:	691b      	ldr	r3, [r3, #16]
 8112082:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
    if ((ip4_addr_isbroadcast(ip4_current_src_addr(), inp)) ||
 8112086:	2be0      	cmp	r3, #224	; 0xe0
 8112088:	d104      	bne.n	8112094 <ip4_input+0x174>
      /* packet source is not valid */
      LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING, ("ip4_input: packet source is not valid.\n"));
      /* free (drop) packet pbufs */
      pbuf_free(p);
 811208a:	6878      	ldr	r0, [r7, #4]
 811208c:	f002 fae4 	bl	8114658 <pbuf_free>
      IP_STATS_INC(ip.drop);
      MIB2_STATS_INC(mib2.ipinaddrerrors);
      MIB2_STATS_INC(mib2.ipindiscards);
      return ERR_OK;
 8112090:	2300      	movs	r3, #0
 8112092:	e07e      	b.n	8112192 <ip4_input+0x272>
    }
  }

  /* packet not for us? */
  if (netif == NULL) {
 8112094:	69bb      	ldr	r3, [r7, #24]
 8112096:	2b00      	cmp	r3, #0
 8112098:	d104      	bne.n	81120a4 <ip4_input+0x184>
    {
      IP_STATS_INC(ip.drop);
      MIB2_STATS_INC(mib2.ipinaddrerrors);
      MIB2_STATS_INC(mib2.ipindiscards);
    }
    pbuf_free(p);
 811209a:	6878      	ldr	r0, [r7, #4]
 811209c:	f002 fadc 	bl	8114658 <pbuf_free>
    return ERR_OK;
 81120a0:	2300      	movs	r3, #0
 81120a2:	e076      	b.n	8112192 <ip4_input+0x272>
  }
  /* packet consists of multiple fragments? */
  if ((IPH_OFFSET(iphdr) & PP_HTONS(IP_OFFMASK | IP_MF)) != 0) {
 81120a4:	69fb      	ldr	r3, [r7, #28]
 81120a6:	88db      	ldrh	r3, [r3, #6]
 81120a8:	b29b      	uxth	r3, r3
 81120aa:	461a      	mov	r2, r3
 81120ac:	f64f 733f 	movw	r3, #65343	; 0xff3f
 81120b0:	4013      	ands	r3, r2
 81120b2:	2b00      	cmp	r3, #0
 81120b4:	d00b      	beq.n	81120ce <ip4_input+0x1ae>
#if IP_REASSEMBLY /* packet fragment reassembly code present? */
    LWIP_DEBUGF(IP_DEBUG, ("IP packet is a fragment (id=0x%04"X16_F" tot_len=%"U16_F" len=%"U16_F" MF=%"U16_F" offset=%"U16_F"), calling ip4_reass()\n",
                           lwip_ntohs(IPH_ID(iphdr)), p->tot_len, lwip_ntohs(IPH_LEN(iphdr)), (u16_t)!!(IPH_OFFSET(iphdr) & PP_HTONS(IP_MF)), (u16_t)((lwip_ntohs(IPH_OFFSET(iphdr)) & IP_OFFMASK) * 8)));
    /* reassemble the packet*/
    p = ip4_reass(p);
 81120b6:	6878      	ldr	r0, [r7, #4]
 81120b8:	f000 fc92 	bl	81129e0 <ip4_reass>
 81120bc:	6078      	str	r0, [r7, #4]
    /* packet not fully reassembled yet? */
    if (p == NULL) {
 81120be:	687b      	ldr	r3, [r7, #4]
 81120c0:	2b00      	cmp	r3, #0
 81120c2:	d101      	bne.n	81120c8 <ip4_input+0x1a8>
      return ERR_OK;
 81120c4:	2300      	movs	r3, #0
 81120c6:	e064      	b.n	8112192 <ip4_input+0x272>
    }
    iphdr = (const struct ip_hdr *)p->payload;
 81120c8:	687b      	ldr	r3, [r7, #4]
 81120ca:	685b      	ldr	r3, [r3, #4]
 81120cc:	61fb      	str	r3, [r7, #28]
  /* send to upper layers */
  LWIP_DEBUGF(IP_DEBUG, ("ip4_input: \n"));
  ip4_debug_print(p);
  LWIP_DEBUGF(IP_DEBUG, ("ip4_input: p->len %"U16_F" p->tot_len %"U16_F"\n", p->len, p->tot_len));

  ip_data.current_netif = netif;
 81120ce:	4a33      	ldr	r2, [pc, #204]	; (811219c <ip4_input+0x27c>)
 81120d0:	69bb      	ldr	r3, [r7, #24]
 81120d2:	6013      	str	r3, [r2, #0]
  ip_data.current_input_netif = inp;
 81120d4:	4a31      	ldr	r2, [pc, #196]	; (811219c <ip4_input+0x27c>)
 81120d6:	683b      	ldr	r3, [r7, #0]
 81120d8:	6053      	str	r3, [r2, #4]
  ip_data.current_ip4_header = iphdr;
 81120da:	4a30      	ldr	r2, [pc, #192]	; (811219c <ip4_input+0x27c>)
 81120dc:	69fb      	ldr	r3, [r7, #28]
 81120de:	6093      	str	r3, [r2, #8]
  ip_data.current_ip_header_tot_len = IPH_HL_BYTES(iphdr);
 81120e0:	69fb      	ldr	r3, [r7, #28]
 81120e2:	781b      	ldrb	r3, [r3, #0]
 81120e4:	f003 030f 	and.w	r3, r3, #15
 81120e8:	b2db      	uxtb	r3, r3
 81120ea:	009b      	lsls	r3, r3, #2
 81120ec:	b2db      	uxtb	r3, r3
 81120ee:	b29a      	uxth	r2, r3
 81120f0:	4b2a      	ldr	r3, [pc, #168]	; (811219c <ip4_input+0x27c>)
 81120f2:	819a      	strh	r2, [r3, #12]
  /* raw input did not eat the packet? */
  raw_status = raw_input(p, inp);
  if (raw_status != RAW_INPUT_EATEN)
#endif /* LWIP_RAW */
  {
    pbuf_remove_header(p, iphdr_hlen); /* Move to payload, no check necessary. */
 81120f4:	8a7b      	ldrh	r3, [r7, #18]
 81120f6:	4619      	mov	r1, r3
 81120f8:	6878      	ldr	r0, [r7, #4]
 81120fa:	f002 fa27 	bl	811454c <pbuf_remove_header>

    switch (IPH_PROTO(iphdr)) {
 81120fe:	69fb      	ldr	r3, [r7, #28]
 8112100:	7a5b      	ldrb	r3, [r3, #9]
 8112102:	2b11      	cmp	r3, #17
 8112104:	d006      	beq.n	8112114 <ip4_input+0x1f4>
 8112106:	2b11      	cmp	r3, #17
 8112108:	dc13      	bgt.n	8112132 <ip4_input+0x212>
 811210a:	2b01      	cmp	r3, #1
 811210c:	d00c      	beq.n	8112128 <ip4_input+0x208>
 811210e:	2b06      	cmp	r3, #6
 8112110:	d005      	beq.n	811211e <ip4_input+0x1fe>
 8112112:	e00e      	b.n	8112132 <ip4_input+0x212>
      case IP_PROTO_UDP:
#if LWIP_UDPLITE
      case IP_PROTO_UDPLITE:
#endif /* LWIP_UDPLITE */
        MIB2_STATS_INC(mib2.ipindelivers);
        udp_input(p, inp);
 8112114:	6839      	ldr	r1, [r7, #0]
 8112116:	6878      	ldr	r0, [r7, #4]
 8112118:	f008 f9a8 	bl	811a46c <udp_input>
        break;
 811211c:	e026      	b.n	811216c <ip4_input+0x24c>
#endif /* LWIP_UDP */
#if LWIP_TCP
      case IP_PROTO_TCP:
        MIB2_STATS_INC(mib2.ipindelivers);
        tcp_input(p, inp);
 811211e:	6839      	ldr	r1, [r7, #0]
 8112120:	6878      	ldr	r0, [r7, #4]
 8112122:	f004 fa2b 	bl	811657c <tcp_input>
        break;
 8112126:	e021      	b.n	811216c <ip4_input+0x24c>
#endif /* LWIP_TCP */
#if LWIP_ICMP
      case IP_PROTO_ICMP:
        MIB2_STATS_INC(mib2.ipindelivers);
        icmp_input(p, inp);
 8112128:	6839      	ldr	r1, [r7, #0]
 811212a:	6878      	ldr	r0, [r7, #4]
 811212c:	f7ff fbd6 	bl	81118dc <icmp_input>
        break;
 8112130:	e01c      	b.n	811216c <ip4_input+0x24c>
        } else
#endif /* LWIP_RAW */
        {
#if LWIP_ICMP
          /* send ICMP destination protocol unreachable unless is was a broadcast */
          if (!ip4_addr_isbroadcast(ip4_current_dest_addr(), netif) &&
 8112132:	4b1a      	ldr	r3, [pc, #104]	; (811219c <ip4_input+0x27c>)
 8112134:	695b      	ldr	r3, [r3, #20]
 8112136:	69b9      	ldr	r1, [r7, #24]
 8112138:	4618      	mov	r0, r3
 811213a:	f000 f90b 	bl	8112354 <ip4_addr_isbroadcast_u32>
 811213e:	4603      	mov	r3, r0
 8112140:	2b00      	cmp	r3, #0
 8112142:	d10f      	bne.n	8112164 <ip4_input+0x244>
              !ip4_addr_ismulticast(ip4_current_dest_addr())) {
 8112144:	4b15      	ldr	r3, [pc, #84]	; (811219c <ip4_input+0x27c>)
 8112146:	695b      	ldr	r3, [r3, #20]
 8112148:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
          if (!ip4_addr_isbroadcast(ip4_current_dest_addr(), netif) &&
 811214c:	2be0      	cmp	r3, #224	; 0xe0
 811214e:	d009      	beq.n	8112164 <ip4_input+0x244>
            pbuf_header_force(p, (s16_t)iphdr_hlen); /* Move to ip header, no check necessary. */
 8112150:	f9b7 3012 	ldrsh.w	r3, [r7, #18]
 8112154:	4619      	mov	r1, r3
 8112156:	6878      	ldr	r0, [r7, #4]
 8112158:	f002 fa6b 	bl	8114632 <pbuf_header_force>
            icmp_dest_unreach(p, ICMP_DUR_PROTO);
 811215c:	2102      	movs	r1, #2
 811215e:	6878      	ldr	r0, [r7, #4]
 8112160:	f7ff fcdc 	bl	8111b1c <icmp_dest_unreach>

          IP_STATS_INC(ip.proterr);
          IP_STATS_INC(ip.drop);
          MIB2_STATS_INC(mib2.ipinunknownprotos);
        }
        pbuf_free(p);
 8112164:	6878      	ldr	r0, [r7, #4]
 8112166:	f002 fa77 	bl	8114658 <pbuf_free>
        break;
 811216a:	bf00      	nop
    }
  }

  /* @todo: this is not really necessary... */
  ip_data.current_netif = NULL;
 811216c:	4b0b      	ldr	r3, [pc, #44]	; (811219c <ip4_input+0x27c>)
 811216e:	2200      	movs	r2, #0
 8112170:	601a      	str	r2, [r3, #0]
  ip_data.current_input_netif = NULL;
 8112172:	4b0a      	ldr	r3, [pc, #40]	; (811219c <ip4_input+0x27c>)
 8112174:	2200      	movs	r2, #0
 8112176:	605a      	str	r2, [r3, #4]
  ip_data.current_ip4_header = NULL;
 8112178:	4b08      	ldr	r3, [pc, #32]	; (811219c <ip4_input+0x27c>)
 811217a:	2200      	movs	r2, #0
 811217c:	609a      	str	r2, [r3, #8]
  ip_data.current_ip_header_tot_len = 0;
 811217e:	4b07      	ldr	r3, [pc, #28]	; (811219c <ip4_input+0x27c>)
 8112180:	2200      	movs	r2, #0
 8112182:	819a      	strh	r2, [r3, #12]
  ip4_addr_set_any(ip4_current_src_addr());
 8112184:	4b05      	ldr	r3, [pc, #20]	; (811219c <ip4_input+0x27c>)
 8112186:	2200      	movs	r2, #0
 8112188:	611a      	str	r2, [r3, #16]
  ip4_addr_set_any(ip4_current_dest_addr());
 811218a:	4b04      	ldr	r3, [pc, #16]	; (811219c <ip4_input+0x27c>)
 811218c:	2200      	movs	r2, #0
 811218e:	615a      	str	r2, [r3, #20]

  return ERR_OK;
 8112190:	2300      	movs	r3, #0
}
 8112192:	4618      	mov	r0, r3
 8112194:	3720      	adds	r7, #32
 8112196:	46bd      	mov	sp, r7
 8112198:	bd80      	pop	{r7, pc}
 811219a:	bf00      	nop
 811219c:	100054f0 	.word	0x100054f0
 81121a0:	1000843c 	.word	0x1000843c

081121a4 <ip4_output_if>:
 */
err_t
ip4_output_if(struct pbuf *p, const ip4_addr_t *src, const ip4_addr_t *dest,
              u8_t ttl, u8_t tos,
              u8_t proto, struct netif *netif)
{
 81121a4:	b580      	push	{r7, lr}
 81121a6:	b08a      	sub	sp, #40	; 0x28
 81121a8:	af04      	add	r7, sp, #16
 81121aa:	60f8      	str	r0, [r7, #12]
 81121ac:	60b9      	str	r1, [r7, #8]
 81121ae:	607a      	str	r2, [r7, #4]
 81121b0:	70fb      	strb	r3, [r7, #3]
ip4_output_if_opt(struct pbuf *p, const ip4_addr_t *src, const ip4_addr_t *dest,
                  u8_t ttl, u8_t tos, u8_t proto, struct netif *netif, void *ip_options,
                  u16_t optlen)
{
#endif /* IP_OPTIONS_SEND */
  const ip4_addr_t *src_used = src;
 81121b2:	68bb      	ldr	r3, [r7, #8]
 81121b4:	617b      	str	r3, [r7, #20]
  if (dest != LWIP_IP_HDRINCL) {
 81121b6:	687b      	ldr	r3, [r7, #4]
 81121b8:	2b00      	cmp	r3, #0
 81121ba:	d009      	beq.n	81121d0 <ip4_output_if+0x2c>
    if (ip4_addr_isany(src)) {
 81121bc:	68bb      	ldr	r3, [r7, #8]
 81121be:	2b00      	cmp	r3, #0
 81121c0:	d003      	beq.n	81121ca <ip4_output_if+0x26>
 81121c2:	68bb      	ldr	r3, [r7, #8]
 81121c4:	681b      	ldr	r3, [r3, #0]
 81121c6:	2b00      	cmp	r3, #0
 81121c8:	d102      	bne.n	81121d0 <ip4_output_if+0x2c>
      src_used = netif_ip4_addr(netif);
 81121ca:	6abb      	ldr	r3, [r7, #40]	; 0x28
 81121cc:	3304      	adds	r3, #4
 81121ce:	617b      	str	r3, [r7, #20]

#if IP_OPTIONS_SEND
  return ip4_output_if_opt_src(p, src_used, dest, ttl, tos, proto, netif,
                               ip_options, optlen);
#else /* IP_OPTIONS_SEND */
  return ip4_output_if_src(p, src_used, dest, ttl, tos, proto, netif);
 81121d0:	78fa      	ldrb	r2, [r7, #3]
 81121d2:	6abb      	ldr	r3, [r7, #40]	; 0x28
 81121d4:	9302      	str	r3, [sp, #8]
 81121d6:	f897 3024 	ldrb.w	r3, [r7, #36]	; 0x24
 81121da:	9301      	str	r3, [sp, #4]
 81121dc:	f897 3020 	ldrb.w	r3, [r7, #32]
 81121e0:	9300      	str	r3, [sp, #0]
 81121e2:	4613      	mov	r3, r2
 81121e4:	687a      	ldr	r2, [r7, #4]
 81121e6:	6979      	ldr	r1, [r7, #20]
 81121e8:	68f8      	ldr	r0, [r7, #12]
 81121ea:	f000 f805 	bl	81121f8 <ip4_output_if_src>
 81121ee:	4603      	mov	r3, r0
#endif /* IP_OPTIONS_SEND */
}
 81121f0:	4618      	mov	r0, r3
 81121f2:	3718      	adds	r7, #24
 81121f4:	46bd      	mov	sp, r7
 81121f6:	bd80      	pop	{r7, pc}

081121f8 <ip4_output_if_src>:
 */
err_t
ip4_output_if_src(struct pbuf *p, const ip4_addr_t *src, const ip4_addr_t *dest,
                  u8_t ttl, u8_t tos,
                  u8_t proto, struct netif *netif)
{
 81121f8:	b580      	push	{r7, lr}
 81121fa:	b088      	sub	sp, #32
 81121fc:	af00      	add	r7, sp, #0
 81121fe:	60f8      	str	r0, [r7, #12]
 8112200:	60b9      	str	r1, [r7, #8]
 8112202:	607a      	str	r2, [r7, #4]
 8112204:	70fb      	strb	r3, [r7, #3]
#if CHECKSUM_GEN_IP_INLINE
  u32_t chk_sum = 0;
#endif /* CHECKSUM_GEN_IP_INLINE */

  LWIP_ASSERT_CORE_LOCKED();
  LWIP_IP_CHECK_PBUF_REF_COUNT_FOR_TX(p);
 8112206:	68fb      	ldr	r3, [r7, #12]
 8112208:	7b9b      	ldrb	r3, [r3, #14]
 811220a:	2b01      	cmp	r3, #1
 811220c:	d006      	beq.n	811221c <ip4_output_if_src+0x24>
 811220e:	4b4b      	ldr	r3, [pc, #300]	; (811233c <ip4_output_if_src+0x144>)
 8112210:	f44f 7255 	mov.w	r2, #852	; 0x354
 8112214:	494a      	ldr	r1, [pc, #296]	; (8112340 <ip4_output_if_src+0x148>)
 8112216:	484b      	ldr	r0, [pc, #300]	; (8112344 <ip4_output_if_src+0x14c>)
 8112218:	f009 faf2 	bl	811b800 <iprintf>

  MIB2_STATS_INC(mib2.ipoutrequests);

  /* Should the IP header be generated or is it already included in p? */
  if (dest != LWIP_IP_HDRINCL) {
 811221c:	687b      	ldr	r3, [r7, #4]
 811221e:	2b00      	cmp	r3, #0
 8112220:	d060      	beq.n	81122e4 <ip4_output_if_src+0xec>
    u16_t ip_hlen = IP_HLEN;
 8112222:	2314      	movs	r3, #20
 8112224:	837b      	strh	r3, [r7, #26]
      }
#endif /* CHECKSUM_GEN_IP_INLINE */
    }
#endif /* IP_OPTIONS_SEND */
    /* generate IP header */
    if (pbuf_add_header(p, IP_HLEN)) {
 8112226:	2114      	movs	r1, #20
 8112228:	68f8      	ldr	r0, [r7, #12]
 811222a:	f002 f97f 	bl	811452c <pbuf_add_header>
 811222e:	4603      	mov	r3, r0
 8112230:	2b00      	cmp	r3, #0
 8112232:	d002      	beq.n	811223a <ip4_output_if_src+0x42>
      LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("ip4_output: not enough room for IP header in pbuf\n"));

      IP_STATS_INC(ip.err);
      MIB2_STATS_INC(mib2.ipoutdiscards);
      return ERR_BUF;
 8112234:	f06f 0301 	mvn.w	r3, #1
 8112238:	e07c      	b.n	8112334 <ip4_output_if_src+0x13c>
    }

    iphdr = (struct ip_hdr *)p->payload;
 811223a:	68fb      	ldr	r3, [r7, #12]
 811223c:	685b      	ldr	r3, [r3, #4]
 811223e:	61fb      	str	r3, [r7, #28]
    LWIP_ASSERT("check that first pbuf can hold struct ip_hdr",
 8112240:	68fb      	ldr	r3, [r7, #12]
 8112242:	895b      	ldrh	r3, [r3, #10]
 8112244:	2b13      	cmp	r3, #19
 8112246:	d806      	bhi.n	8112256 <ip4_output_if_src+0x5e>
 8112248:	4b3c      	ldr	r3, [pc, #240]	; (811233c <ip4_output_if_src+0x144>)
 811224a:	f44f 7262 	mov.w	r2, #904	; 0x388
 811224e:	493e      	ldr	r1, [pc, #248]	; (8112348 <ip4_output_if_src+0x150>)
 8112250:	483c      	ldr	r0, [pc, #240]	; (8112344 <ip4_output_if_src+0x14c>)
 8112252:	f009 fad5 	bl	811b800 <iprintf>
                (p->len >= sizeof(struct ip_hdr)));

    IPH_TTL_SET(iphdr, ttl);
 8112256:	69fb      	ldr	r3, [r7, #28]
 8112258:	78fa      	ldrb	r2, [r7, #3]
 811225a:	721a      	strb	r2, [r3, #8]
    IPH_PROTO_SET(iphdr, proto);
 811225c:	69fb      	ldr	r3, [r7, #28]
 811225e:	f897 202c 	ldrb.w	r2, [r7, #44]	; 0x2c
 8112262:	725a      	strb	r2, [r3, #9]
#if CHECKSUM_GEN_IP_INLINE
    chk_sum += PP_NTOHS(proto | (ttl << 8));
#endif /* CHECKSUM_GEN_IP_INLINE */

    /* dest cannot be NULL here */
    ip4_addr_copy(iphdr->dest, *dest);
 8112264:	687b      	ldr	r3, [r7, #4]
 8112266:	681a      	ldr	r2, [r3, #0]
 8112268:	69fb      	ldr	r3, [r7, #28]
 811226a:	611a      	str	r2, [r3, #16]
#if CHECKSUM_GEN_IP_INLINE
    chk_sum += ip4_addr_get_u32(&iphdr->dest) & 0xFFFF;
    chk_sum += ip4_addr_get_u32(&iphdr->dest) >> 16;
#endif /* CHECKSUM_GEN_IP_INLINE */

    IPH_VHL_SET(iphdr, 4, ip_hlen / 4);
 811226c:	8b7b      	ldrh	r3, [r7, #26]
 811226e:	089b      	lsrs	r3, r3, #2
 8112270:	b29b      	uxth	r3, r3
 8112272:	b2db      	uxtb	r3, r3
 8112274:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8112278:	b2da      	uxtb	r2, r3
 811227a:	69fb      	ldr	r3, [r7, #28]
 811227c:	701a      	strb	r2, [r3, #0]
    IPH_TOS_SET(iphdr, tos);
 811227e:	69fb      	ldr	r3, [r7, #28]
 8112280:	f897 2028 	ldrb.w	r2, [r7, #40]	; 0x28
 8112284:	705a      	strb	r2, [r3, #1]
#if CHECKSUM_GEN_IP_INLINE
    chk_sum += PP_NTOHS(tos | (iphdr->_v_hl << 8));
#endif /* CHECKSUM_GEN_IP_INLINE */
    IPH_LEN_SET(iphdr, lwip_htons(p->tot_len));
 8112286:	68fb      	ldr	r3, [r7, #12]
 8112288:	891b      	ldrh	r3, [r3, #8]
 811228a:	4618      	mov	r0, r3
 811228c:	f7fc f901 	bl	810e492 <lwip_htons>
 8112290:	4603      	mov	r3, r0
 8112292:	461a      	mov	r2, r3
 8112294:	69fb      	ldr	r3, [r7, #28]
 8112296:	805a      	strh	r2, [r3, #2]
#if CHECKSUM_GEN_IP_INLINE
    chk_sum += iphdr->_len;
#endif /* CHECKSUM_GEN_IP_INLINE */
    IPH_OFFSET_SET(iphdr, 0);
 8112298:	69fb      	ldr	r3, [r7, #28]
 811229a:	2200      	movs	r2, #0
 811229c:	719a      	strb	r2, [r3, #6]
 811229e:	2200      	movs	r2, #0
 81122a0:	71da      	strb	r2, [r3, #7]
    IPH_ID_SET(iphdr, lwip_htons(ip_id));
 81122a2:	4b2a      	ldr	r3, [pc, #168]	; (811234c <ip4_output_if_src+0x154>)
 81122a4:	881b      	ldrh	r3, [r3, #0]
 81122a6:	4618      	mov	r0, r3
 81122a8:	f7fc f8f3 	bl	810e492 <lwip_htons>
 81122ac:	4603      	mov	r3, r0
 81122ae:	461a      	mov	r2, r3
 81122b0:	69fb      	ldr	r3, [r7, #28]
 81122b2:	809a      	strh	r2, [r3, #4]
#if CHECKSUM_GEN_IP_INLINE
    chk_sum += iphdr->_id;
#endif /* CHECKSUM_GEN_IP_INLINE */
    ++ip_id;
 81122b4:	4b25      	ldr	r3, [pc, #148]	; (811234c <ip4_output_if_src+0x154>)
 81122b6:	881b      	ldrh	r3, [r3, #0]
 81122b8:	3301      	adds	r3, #1
 81122ba:	b29a      	uxth	r2, r3
 81122bc:	4b23      	ldr	r3, [pc, #140]	; (811234c <ip4_output_if_src+0x154>)
 81122be:	801a      	strh	r2, [r3, #0]

    if (src == NULL) {
 81122c0:	68bb      	ldr	r3, [r7, #8]
 81122c2:	2b00      	cmp	r3, #0
 81122c4:	d104      	bne.n	81122d0 <ip4_output_if_src+0xd8>
      ip4_addr_copy(iphdr->src, *IP4_ADDR_ANY4);
 81122c6:	4b22      	ldr	r3, [pc, #136]	; (8112350 <ip4_output_if_src+0x158>)
 81122c8:	681a      	ldr	r2, [r3, #0]
 81122ca:	69fb      	ldr	r3, [r7, #28]
 81122cc:	60da      	str	r2, [r3, #12]
 81122ce:	e003      	b.n	81122d8 <ip4_output_if_src+0xe0>
    } else {
      /* src cannot be NULL here */
      ip4_addr_copy(iphdr->src, *src);
 81122d0:	68bb      	ldr	r3, [r7, #8]
 81122d2:	681a      	ldr	r2, [r3, #0]
 81122d4:	69fb      	ldr	r3, [r7, #28]
 81122d6:	60da      	str	r2, [r3, #12]
    else {
      IPH_CHKSUM_SET(iphdr, 0);
    }
#endif /* LWIP_CHECKSUM_CTRL_PER_NETIF*/
#else /* CHECKSUM_GEN_IP_INLINE */
    IPH_CHKSUM_SET(iphdr, 0);
 81122d8:	69fb      	ldr	r3, [r7, #28]
 81122da:	2200      	movs	r2, #0
 81122dc:	729a      	strb	r2, [r3, #10]
 81122de:	2200      	movs	r2, #0
 81122e0:	72da      	strb	r2, [r3, #11]
 81122e2:	e00f      	b.n	8112304 <ip4_output_if_src+0x10c>
    }
#endif /* CHECKSUM_GEN_IP */
#endif /* CHECKSUM_GEN_IP_INLINE */
  } else {
    /* IP header already included in p */
    if (p->len < IP_HLEN) {
 81122e4:	68fb      	ldr	r3, [r7, #12]
 81122e6:	895b      	ldrh	r3, [r3, #10]
 81122e8:	2b13      	cmp	r3, #19
 81122ea:	d802      	bhi.n	81122f2 <ip4_output_if_src+0xfa>
      LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("ip4_output: LWIP_IP_HDRINCL but pbuf is too short\n"));
      IP_STATS_INC(ip.err);
      MIB2_STATS_INC(mib2.ipoutdiscards);
      return ERR_BUF;
 81122ec:	f06f 0301 	mvn.w	r3, #1
 81122f0:	e020      	b.n	8112334 <ip4_output_if_src+0x13c>
    }
    iphdr = (struct ip_hdr *)p->payload;
 81122f2:	68fb      	ldr	r3, [r7, #12]
 81122f4:	685b      	ldr	r3, [r3, #4]
 81122f6:	61fb      	str	r3, [r7, #28]
    ip4_addr_copy(dest_addr, iphdr->dest);
 81122f8:	69fb      	ldr	r3, [r7, #28]
 81122fa:	691b      	ldr	r3, [r3, #16]
 81122fc:	617b      	str	r3, [r7, #20]
    dest = &dest_addr;
 81122fe:	f107 0314 	add.w	r3, r7, #20
 8112302:	607b      	str	r3, [r7, #4]
  }
#endif /* LWIP_MULTICAST_TX_OPTIONS */
#endif /* ENABLE_LOOPBACK */
#if IP_FRAG
  /* don't fragment if interface has mtu set to 0 [loopif] */
  if (netif->mtu && (p->tot_len > netif->mtu)) {
 8112304:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8112306:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
 8112308:	2b00      	cmp	r3, #0
 811230a:	d00c      	beq.n	8112326 <ip4_output_if_src+0x12e>
 811230c:	68fb      	ldr	r3, [r7, #12]
 811230e:	891a      	ldrh	r2, [r3, #8]
 8112310:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8112312:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
 8112314:	429a      	cmp	r2, r3
 8112316:	d906      	bls.n	8112326 <ip4_output_if_src+0x12e>
    return ip4_frag(p, netif, dest);
 8112318:	687a      	ldr	r2, [r7, #4]
 811231a:	6b39      	ldr	r1, [r7, #48]	; 0x30
 811231c:	68f8      	ldr	r0, [r7, #12]
 811231e:	f000 fd53 	bl	8112dc8 <ip4_frag>
 8112322:	4603      	mov	r3, r0
 8112324:	e006      	b.n	8112334 <ip4_output_if_src+0x13c>
  }
#endif /* IP_FRAG */

  LWIP_DEBUGF(IP_DEBUG, ("ip4_output_if: call netif->output()\n"));
  return netif->output(netif, p, dest);
 8112326:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8112328:	695b      	ldr	r3, [r3, #20]
 811232a:	687a      	ldr	r2, [r7, #4]
 811232c:	68f9      	ldr	r1, [r7, #12]
 811232e:	6b38      	ldr	r0, [r7, #48]	; 0x30
 8112330:	4798      	blx	r3
 8112332:	4603      	mov	r3, r0
}
 8112334:	4618      	mov	r0, r3
 8112336:	3720      	adds	r7, #32
 8112338:	46bd      	mov	sp, r7
 811233a:	bd80      	pop	{r7, pc}
 811233c:	0811d0e0 	.word	0x0811d0e0
 8112340:	0811d148 	.word	0x0811d148
 8112344:	0811d154 	.word	0x0811d154
 8112348:	0811d17c 	.word	0x0811d17c
 811234c:	10005508 	.word	0x10005508
 8112350:	0811f934 	.word	0x0811f934

08112354 <ip4_addr_isbroadcast_u32>:
 * @param netif the network interface against which the address is checked
 * @return returns non-zero if the address is a broadcast address
 */
u8_t
ip4_addr_isbroadcast_u32(u32_t addr, const struct netif *netif)
{
 8112354:	b480      	push	{r7}
 8112356:	b085      	sub	sp, #20
 8112358:	af00      	add	r7, sp, #0
 811235a:	6078      	str	r0, [r7, #4]
 811235c:	6039      	str	r1, [r7, #0]
  ip4_addr_t ipaddr;
  ip4_addr_set_u32(&ipaddr, addr);
 811235e:	687b      	ldr	r3, [r7, #4]
 8112360:	60fb      	str	r3, [r7, #12]

  /* all ones (broadcast) or all zeroes (old skool broadcast) */
  if ((~addr == IPADDR_ANY) ||
 8112362:	687b      	ldr	r3, [r7, #4]
 8112364:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 8112368:	d002      	beq.n	8112370 <ip4_addr_isbroadcast_u32+0x1c>
 811236a:	687b      	ldr	r3, [r7, #4]
 811236c:	2b00      	cmp	r3, #0
 811236e:	d101      	bne.n	8112374 <ip4_addr_isbroadcast_u32+0x20>
      (addr == IPADDR_ANY)) {
    return 1;
 8112370:	2301      	movs	r3, #1
 8112372:	e02a      	b.n	81123ca <ip4_addr_isbroadcast_u32+0x76>
    /* no broadcast support on this network interface? */
  } else if ((netif->flags & NETIF_FLAG_BROADCAST) == 0) {
 8112374:	683b      	ldr	r3, [r7, #0]
 8112376:	f893 3031 	ldrb.w	r3, [r3, #49]	; 0x31
 811237a:	f003 0302 	and.w	r3, r3, #2
 811237e:	2b00      	cmp	r3, #0
 8112380:	d101      	bne.n	8112386 <ip4_addr_isbroadcast_u32+0x32>
    /* the given address cannot be a broadcast address
     * nor can we check against any broadcast addresses */
    return 0;
 8112382:	2300      	movs	r3, #0
 8112384:	e021      	b.n	81123ca <ip4_addr_isbroadcast_u32+0x76>
    /* address matches network interface address exactly? => no broadcast */
  } else if (addr == ip4_addr_get_u32(netif_ip4_addr(netif))) {
 8112386:	683b      	ldr	r3, [r7, #0]
 8112388:	3304      	adds	r3, #4
 811238a:	681b      	ldr	r3, [r3, #0]
 811238c:	687a      	ldr	r2, [r7, #4]
 811238e:	429a      	cmp	r2, r3
 8112390:	d101      	bne.n	8112396 <ip4_addr_isbroadcast_u32+0x42>
    return 0;
 8112392:	2300      	movs	r3, #0
 8112394:	e019      	b.n	81123ca <ip4_addr_isbroadcast_u32+0x76>
    /*  on the same (sub) network... */
  } else if (ip4_addr_netcmp(&ipaddr, netif_ip4_addr(netif), netif_ip4_netmask(netif))
 8112396:	68fa      	ldr	r2, [r7, #12]
 8112398:	683b      	ldr	r3, [r7, #0]
 811239a:	3304      	adds	r3, #4
 811239c:	681b      	ldr	r3, [r3, #0]
 811239e:	405a      	eors	r2, r3
 81123a0:	683b      	ldr	r3, [r7, #0]
 81123a2:	3308      	adds	r3, #8
 81123a4:	681b      	ldr	r3, [r3, #0]
 81123a6:	4013      	ands	r3, r2
 81123a8:	2b00      	cmp	r3, #0
 81123aa:	d10d      	bne.n	81123c8 <ip4_addr_isbroadcast_u32+0x74>
             /* ...and host identifier bits are all ones? =>... */
             && ((addr & ~ip4_addr_get_u32(netif_ip4_netmask(netif))) ==
 81123ac:	683b      	ldr	r3, [r7, #0]
 81123ae:	3308      	adds	r3, #8
 81123b0:	681b      	ldr	r3, [r3, #0]
 81123b2:	43da      	mvns	r2, r3
 81123b4:	687b      	ldr	r3, [r7, #4]
 81123b6:	401a      	ands	r2, r3
                 (IPADDR_BROADCAST & ~ip4_addr_get_u32(netif_ip4_netmask(netif))))) {
 81123b8:	683b      	ldr	r3, [r7, #0]
 81123ba:	3308      	adds	r3, #8
 81123bc:	681b      	ldr	r3, [r3, #0]
 81123be:	43db      	mvns	r3, r3
             && ((addr & ~ip4_addr_get_u32(netif_ip4_netmask(netif))) ==
 81123c0:	429a      	cmp	r2, r3
 81123c2:	d101      	bne.n	81123c8 <ip4_addr_isbroadcast_u32+0x74>
    /* => network broadcast address */
    return 1;
 81123c4:	2301      	movs	r3, #1
 81123c6:	e000      	b.n	81123ca <ip4_addr_isbroadcast_u32+0x76>
  } else {
    return 0;
 81123c8:	2300      	movs	r3, #0
  }
}
 81123ca:	4618      	mov	r0, r3
 81123cc:	3714      	adds	r7, #20
 81123ce:	46bd      	mov	sp, r7
 81123d0:	f85d 7b04 	ldr.w	r7, [sp], #4
 81123d4:	4770      	bx	lr
	...

081123d8 <ip_reass_tmr>:
 *
 * Should be called every 1000 msec (defined by IP_TMR_INTERVAL).
 */
void
ip_reass_tmr(void)
{
 81123d8:	b580      	push	{r7, lr}
 81123da:	b084      	sub	sp, #16
 81123dc:	af00      	add	r7, sp, #0
  struct ip_reassdata *r, *prev = NULL;
 81123de:	2300      	movs	r3, #0
 81123e0:	60bb      	str	r3, [r7, #8]

  r = reassdatagrams;
 81123e2:	4b12      	ldr	r3, [pc, #72]	; (811242c <ip_reass_tmr+0x54>)
 81123e4:	681b      	ldr	r3, [r3, #0]
 81123e6:	60fb      	str	r3, [r7, #12]
  while (r != NULL) {
 81123e8:	e018      	b.n	811241c <ip_reass_tmr+0x44>
    /* Decrement the timer. Once it reaches 0,
     * clean up the incomplete fragment assembly */
    if (r->timer > 0) {
 81123ea:	68fb      	ldr	r3, [r7, #12]
 81123ec:	7fdb      	ldrb	r3, [r3, #31]
 81123ee:	2b00      	cmp	r3, #0
 81123f0:	d00b      	beq.n	811240a <ip_reass_tmr+0x32>
      r->timer--;
 81123f2:	68fb      	ldr	r3, [r7, #12]
 81123f4:	7fdb      	ldrb	r3, [r3, #31]
 81123f6:	3b01      	subs	r3, #1
 81123f8:	b2da      	uxtb	r2, r3
 81123fa:	68fb      	ldr	r3, [r7, #12]
 81123fc:	77da      	strb	r2, [r3, #31]
      LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_reass_tmr: timer dec %"U16_F"\n", (u16_t)r->timer));
      prev = r;
 81123fe:	68fb      	ldr	r3, [r7, #12]
 8112400:	60bb      	str	r3, [r7, #8]
      r = r->next;
 8112402:	68fb      	ldr	r3, [r7, #12]
 8112404:	681b      	ldr	r3, [r3, #0]
 8112406:	60fb      	str	r3, [r7, #12]
 8112408:	e008      	b.n	811241c <ip_reass_tmr+0x44>
    } else {
      /* reassembly timed out */
      struct ip_reassdata *tmp;
      LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_reass_tmr: timer timed out\n"));
      tmp = r;
 811240a:	68fb      	ldr	r3, [r7, #12]
 811240c:	607b      	str	r3, [r7, #4]
      /* get the next pointer before freeing */
      r = r->next;
 811240e:	68fb      	ldr	r3, [r7, #12]
 8112410:	681b      	ldr	r3, [r3, #0]
 8112412:	60fb      	str	r3, [r7, #12]
      /* free the helper struct and all enqueued pbufs */
      ip_reass_free_complete_datagram(tmp, prev);
 8112414:	68b9      	ldr	r1, [r7, #8]
 8112416:	6878      	ldr	r0, [r7, #4]
 8112418:	f000 f80a 	bl	8112430 <ip_reass_free_complete_datagram>
  while (r != NULL) {
 811241c:	68fb      	ldr	r3, [r7, #12]
 811241e:	2b00      	cmp	r3, #0
 8112420:	d1e3      	bne.n	81123ea <ip_reass_tmr+0x12>
    }
  }
}
 8112422:	bf00      	nop
 8112424:	bf00      	nop
 8112426:	3710      	adds	r7, #16
 8112428:	46bd      	mov	sp, r7
 811242a:	bd80      	pop	{r7, pc}
 811242c:	1000550c 	.word	0x1000550c

08112430 <ip_reass_free_complete_datagram>:
 * @param prev the previous datagram in the linked list
 * @return the number of pbufs freed
 */
static int
ip_reass_free_complete_datagram(struct ip_reassdata *ipr, struct ip_reassdata *prev)
{
 8112430:	b580      	push	{r7, lr}
 8112432:	b088      	sub	sp, #32
 8112434:	af00      	add	r7, sp, #0
 8112436:	6078      	str	r0, [r7, #4]
 8112438:	6039      	str	r1, [r7, #0]
  u16_t pbufs_freed = 0;
 811243a:	2300      	movs	r3, #0
 811243c:	83fb      	strh	r3, [r7, #30]
  u16_t clen;
  struct pbuf *p;
  struct ip_reass_helper *iprh;

  LWIP_ASSERT("prev != ipr", prev != ipr);
 811243e:	683a      	ldr	r2, [r7, #0]
 8112440:	687b      	ldr	r3, [r7, #4]
 8112442:	429a      	cmp	r2, r3
 8112444:	d105      	bne.n	8112452 <ip_reass_free_complete_datagram+0x22>
 8112446:	4b45      	ldr	r3, [pc, #276]	; (811255c <ip_reass_free_complete_datagram+0x12c>)
 8112448:	22ab      	movs	r2, #171	; 0xab
 811244a:	4945      	ldr	r1, [pc, #276]	; (8112560 <ip_reass_free_complete_datagram+0x130>)
 811244c:	4845      	ldr	r0, [pc, #276]	; (8112564 <ip_reass_free_complete_datagram+0x134>)
 811244e:	f009 f9d7 	bl	811b800 <iprintf>
  if (prev != NULL) {
 8112452:	683b      	ldr	r3, [r7, #0]
 8112454:	2b00      	cmp	r3, #0
 8112456:	d00a      	beq.n	811246e <ip_reass_free_complete_datagram+0x3e>
    LWIP_ASSERT("prev->next == ipr", prev->next == ipr);
 8112458:	683b      	ldr	r3, [r7, #0]
 811245a:	681b      	ldr	r3, [r3, #0]
 811245c:	687a      	ldr	r2, [r7, #4]
 811245e:	429a      	cmp	r2, r3
 8112460:	d005      	beq.n	811246e <ip_reass_free_complete_datagram+0x3e>
 8112462:	4b3e      	ldr	r3, [pc, #248]	; (811255c <ip_reass_free_complete_datagram+0x12c>)
 8112464:	22ad      	movs	r2, #173	; 0xad
 8112466:	4940      	ldr	r1, [pc, #256]	; (8112568 <ip_reass_free_complete_datagram+0x138>)
 8112468:	483e      	ldr	r0, [pc, #248]	; (8112564 <ip_reass_free_complete_datagram+0x134>)
 811246a:	f009 f9c9 	bl	811b800 <iprintf>
  }

  MIB2_STATS_INC(mib2.ipreasmfails);
#if LWIP_ICMP
  iprh = (struct ip_reass_helper *)ipr->p->payload;
 811246e:	687b      	ldr	r3, [r7, #4]
 8112470:	685b      	ldr	r3, [r3, #4]
 8112472:	685b      	ldr	r3, [r3, #4]
 8112474:	617b      	str	r3, [r7, #20]
  if (iprh->start == 0) {
 8112476:	697b      	ldr	r3, [r7, #20]
 8112478:	889b      	ldrh	r3, [r3, #4]
 811247a:	b29b      	uxth	r3, r3
 811247c:	2b00      	cmp	r3, #0
 811247e:	d12a      	bne.n	81124d6 <ip_reass_free_complete_datagram+0xa6>
    /* The first fragment was received, send ICMP time exceeded. */
    /* First, de-queue the first pbuf from r->p. */
    p = ipr->p;
 8112480:	687b      	ldr	r3, [r7, #4]
 8112482:	685b      	ldr	r3, [r3, #4]
 8112484:	61bb      	str	r3, [r7, #24]
    ipr->p = iprh->next_pbuf;
 8112486:	697b      	ldr	r3, [r7, #20]
 8112488:	681a      	ldr	r2, [r3, #0]
 811248a:	687b      	ldr	r3, [r7, #4]
 811248c:	605a      	str	r2, [r3, #4]
    /* Then, copy the original header into it. */
    SMEMCPY(p->payload, &ipr->iphdr, IP_HLEN);
 811248e:	69bb      	ldr	r3, [r7, #24]
 8112490:	6858      	ldr	r0, [r3, #4]
 8112492:	687b      	ldr	r3, [r7, #4]
 8112494:	3308      	adds	r3, #8
 8112496:	2214      	movs	r2, #20
 8112498:	4619      	mov	r1, r3
 811249a:	f009 fa09 	bl	811b8b0 <memcpy>
    icmp_time_exceeded(p, ICMP_TE_FRAG);
 811249e:	2101      	movs	r1, #1
 81124a0:	69b8      	ldr	r0, [r7, #24]
 81124a2:	f7ff fb4b 	bl	8111b3c <icmp_time_exceeded>
    clen = pbuf_clen(p);
 81124a6:	69b8      	ldr	r0, [r7, #24]
 81124a8:	f002 f95e 	bl	8114768 <pbuf_clen>
 81124ac:	4603      	mov	r3, r0
 81124ae:	827b      	strh	r3, [r7, #18]
    LWIP_ASSERT("pbufs_freed + clen <= 0xffff", pbufs_freed + clen <= 0xffff);
 81124b0:	8bfa      	ldrh	r2, [r7, #30]
 81124b2:	8a7b      	ldrh	r3, [r7, #18]
 81124b4:	4413      	add	r3, r2
 81124b6:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 81124ba:	db05      	blt.n	81124c8 <ip_reass_free_complete_datagram+0x98>
 81124bc:	4b27      	ldr	r3, [pc, #156]	; (811255c <ip_reass_free_complete_datagram+0x12c>)
 81124be:	22bc      	movs	r2, #188	; 0xbc
 81124c0:	492a      	ldr	r1, [pc, #168]	; (811256c <ip_reass_free_complete_datagram+0x13c>)
 81124c2:	4828      	ldr	r0, [pc, #160]	; (8112564 <ip_reass_free_complete_datagram+0x134>)
 81124c4:	f009 f99c 	bl	811b800 <iprintf>
    pbufs_freed = (u16_t)(pbufs_freed + clen);
 81124c8:	8bfa      	ldrh	r2, [r7, #30]
 81124ca:	8a7b      	ldrh	r3, [r7, #18]
 81124cc:	4413      	add	r3, r2
 81124ce:	83fb      	strh	r3, [r7, #30]
    pbuf_free(p);
 81124d0:	69b8      	ldr	r0, [r7, #24]
 81124d2:	f002 f8c1 	bl	8114658 <pbuf_free>
  }
#endif /* LWIP_ICMP */

  /* First, free all received pbufs.  The individual pbufs need to be released
     separately as they have not yet been chained */
  p = ipr->p;
 81124d6:	687b      	ldr	r3, [r7, #4]
 81124d8:	685b      	ldr	r3, [r3, #4]
 81124da:	61bb      	str	r3, [r7, #24]
  while (p != NULL) {
 81124dc:	e01f      	b.n	811251e <ip_reass_free_complete_datagram+0xee>
    struct pbuf *pcur;
    iprh = (struct ip_reass_helper *)p->payload;
 81124de:	69bb      	ldr	r3, [r7, #24]
 81124e0:	685b      	ldr	r3, [r3, #4]
 81124e2:	617b      	str	r3, [r7, #20]
    pcur = p;
 81124e4:	69bb      	ldr	r3, [r7, #24]
 81124e6:	60fb      	str	r3, [r7, #12]
    /* get the next pointer before freeing */
    p = iprh->next_pbuf;
 81124e8:	697b      	ldr	r3, [r7, #20]
 81124ea:	681b      	ldr	r3, [r3, #0]
 81124ec:	61bb      	str	r3, [r7, #24]
    clen = pbuf_clen(pcur);
 81124ee:	68f8      	ldr	r0, [r7, #12]
 81124f0:	f002 f93a 	bl	8114768 <pbuf_clen>
 81124f4:	4603      	mov	r3, r0
 81124f6:	827b      	strh	r3, [r7, #18]
    LWIP_ASSERT("pbufs_freed + clen <= 0xffff", pbufs_freed + clen <= 0xffff);
 81124f8:	8bfa      	ldrh	r2, [r7, #30]
 81124fa:	8a7b      	ldrh	r3, [r7, #18]
 81124fc:	4413      	add	r3, r2
 81124fe:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 8112502:	db05      	blt.n	8112510 <ip_reass_free_complete_datagram+0xe0>
 8112504:	4b15      	ldr	r3, [pc, #84]	; (811255c <ip_reass_free_complete_datagram+0x12c>)
 8112506:	22cc      	movs	r2, #204	; 0xcc
 8112508:	4918      	ldr	r1, [pc, #96]	; (811256c <ip_reass_free_complete_datagram+0x13c>)
 811250a:	4816      	ldr	r0, [pc, #88]	; (8112564 <ip_reass_free_complete_datagram+0x134>)
 811250c:	f009 f978 	bl	811b800 <iprintf>
    pbufs_freed = (u16_t)(pbufs_freed + clen);
 8112510:	8bfa      	ldrh	r2, [r7, #30]
 8112512:	8a7b      	ldrh	r3, [r7, #18]
 8112514:	4413      	add	r3, r2
 8112516:	83fb      	strh	r3, [r7, #30]
    pbuf_free(pcur);
 8112518:	68f8      	ldr	r0, [r7, #12]
 811251a:	f002 f89d 	bl	8114658 <pbuf_free>
  while (p != NULL) {
 811251e:	69bb      	ldr	r3, [r7, #24]
 8112520:	2b00      	cmp	r3, #0
 8112522:	d1dc      	bne.n	81124de <ip_reass_free_complete_datagram+0xae>
  }
  /* Then, unchain the struct ip_reassdata from the list and free it. */
  ip_reass_dequeue_datagram(ipr, prev);
 8112524:	6839      	ldr	r1, [r7, #0]
 8112526:	6878      	ldr	r0, [r7, #4]
 8112528:	f000 f8c2 	bl	81126b0 <ip_reass_dequeue_datagram>
  LWIP_ASSERT("ip_reass_pbufcount >= pbufs_freed", ip_reass_pbufcount >= pbufs_freed);
 811252c:	4b10      	ldr	r3, [pc, #64]	; (8112570 <ip_reass_free_complete_datagram+0x140>)
 811252e:	881b      	ldrh	r3, [r3, #0]
 8112530:	8bfa      	ldrh	r2, [r7, #30]
 8112532:	429a      	cmp	r2, r3
 8112534:	d905      	bls.n	8112542 <ip_reass_free_complete_datagram+0x112>
 8112536:	4b09      	ldr	r3, [pc, #36]	; (811255c <ip_reass_free_complete_datagram+0x12c>)
 8112538:	22d2      	movs	r2, #210	; 0xd2
 811253a:	490e      	ldr	r1, [pc, #56]	; (8112574 <ip_reass_free_complete_datagram+0x144>)
 811253c:	4809      	ldr	r0, [pc, #36]	; (8112564 <ip_reass_free_complete_datagram+0x134>)
 811253e:	f009 f95f 	bl	811b800 <iprintf>
  ip_reass_pbufcount = (u16_t)(ip_reass_pbufcount - pbufs_freed);
 8112542:	4b0b      	ldr	r3, [pc, #44]	; (8112570 <ip_reass_free_complete_datagram+0x140>)
 8112544:	881a      	ldrh	r2, [r3, #0]
 8112546:	8bfb      	ldrh	r3, [r7, #30]
 8112548:	1ad3      	subs	r3, r2, r3
 811254a:	b29a      	uxth	r2, r3
 811254c:	4b08      	ldr	r3, [pc, #32]	; (8112570 <ip_reass_free_complete_datagram+0x140>)
 811254e:	801a      	strh	r2, [r3, #0]

  return pbufs_freed;
 8112550:	8bfb      	ldrh	r3, [r7, #30]
}
 8112552:	4618      	mov	r0, r3
 8112554:	3720      	adds	r7, #32
 8112556:	46bd      	mov	sp, r7
 8112558:	bd80      	pop	{r7, pc}
 811255a:	bf00      	nop
 811255c:	0811d1ac 	.word	0x0811d1ac
 8112560:	0811d218 	.word	0x0811d218
 8112564:	0811d224 	.word	0x0811d224
 8112568:	0811d24c 	.word	0x0811d24c
 811256c:	0811d260 	.word	0x0811d260
 8112570:	10005510 	.word	0x10005510
 8112574:	0811d280 	.word	0x0811d280

08112578 <ip_reass_remove_oldest_datagram>:
 *        (used for freeing other datagrams if not enough space)
 * @return the number of pbufs freed
 */
static int
ip_reass_remove_oldest_datagram(struct ip_hdr *fraghdr, int pbufs_needed)
{
 8112578:	b580      	push	{r7, lr}
 811257a:	b08a      	sub	sp, #40	; 0x28
 811257c:	af00      	add	r7, sp, #0
 811257e:	6078      	str	r0, [r7, #4]
 8112580:	6039      	str	r1, [r7, #0]
  /* @todo Can't we simply remove the last datagram in the
   *       linked list behind reassdatagrams?
   */
  struct ip_reassdata *r, *oldest, *prev, *oldest_prev;
  int pbufs_freed = 0, pbufs_freed_current;
 8112582:	2300      	movs	r3, #0
 8112584:	617b      	str	r3, [r7, #20]
  int other_datagrams;

  /* Free datagrams until being allowed to enqueue 'pbufs_needed' pbufs,
   * but don't free the datagram that 'fraghdr' belongs to! */
  do {
    oldest = NULL;
 8112586:	2300      	movs	r3, #0
 8112588:	623b      	str	r3, [r7, #32]
    prev = NULL;
 811258a:	2300      	movs	r3, #0
 811258c:	61fb      	str	r3, [r7, #28]
    oldest_prev = NULL;
 811258e:	2300      	movs	r3, #0
 8112590:	61bb      	str	r3, [r7, #24]
    other_datagrams = 0;
 8112592:	2300      	movs	r3, #0
 8112594:	613b      	str	r3, [r7, #16]
    r = reassdatagrams;
 8112596:	4b28      	ldr	r3, [pc, #160]	; (8112638 <ip_reass_remove_oldest_datagram+0xc0>)
 8112598:	681b      	ldr	r3, [r3, #0]
 811259a:	627b      	str	r3, [r7, #36]	; 0x24
    while (r != NULL) {
 811259c:	e030      	b.n	8112600 <ip_reass_remove_oldest_datagram+0x88>
      if (!IP_ADDRESSES_AND_ID_MATCH(&r->iphdr, fraghdr)) {
 811259e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 81125a0:	695a      	ldr	r2, [r3, #20]
 81125a2:	687b      	ldr	r3, [r7, #4]
 81125a4:	68db      	ldr	r3, [r3, #12]
 81125a6:	429a      	cmp	r2, r3
 81125a8:	d10c      	bne.n	81125c4 <ip_reass_remove_oldest_datagram+0x4c>
 81125aa:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 81125ac:	699a      	ldr	r2, [r3, #24]
 81125ae:	687b      	ldr	r3, [r7, #4]
 81125b0:	691b      	ldr	r3, [r3, #16]
 81125b2:	429a      	cmp	r2, r3
 81125b4:	d106      	bne.n	81125c4 <ip_reass_remove_oldest_datagram+0x4c>
 81125b6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 81125b8:	899a      	ldrh	r2, [r3, #12]
 81125ba:	687b      	ldr	r3, [r7, #4]
 81125bc:	889b      	ldrh	r3, [r3, #4]
 81125be:	b29b      	uxth	r3, r3
 81125c0:	429a      	cmp	r2, r3
 81125c2:	d014      	beq.n	81125ee <ip_reass_remove_oldest_datagram+0x76>
        /* Not the same datagram as fraghdr */
        other_datagrams++;
 81125c4:	693b      	ldr	r3, [r7, #16]
 81125c6:	3301      	adds	r3, #1
 81125c8:	613b      	str	r3, [r7, #16]
        if (oldest == NULL) {
 81125ca:	6a3b      	ldr	r3, [r7, #32]
 81125cc:	2b00      	cmp	r3, #0
 81125ce:	d104      	bne.n	81125da <ip_reass_remove_oldest_datagram+0x62>
          oldest = r;
 81125d0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 81125d2:	623b      	str	r3, [r7, #32]
          oldest_prev = prev;
 81125d4:	69fb      	ldr	r3, [r7, #28]
 81125d6:	61bb      	str	r3, [r7, #24]
 81125d8:	e009      	b.n	81125ee <ip_reass_remove_oldest_datagram+0x76>
        } else if (r->timer <= oldest->timer) {
 81125da:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 81125dc:	7fda      	ldrb	r2, [r3, #31]
 81125de:	6a3b      	ldr	r3, [r7, #32]
 81125e0:	7fdb      	ldrb	r3, [r3, #31]
 81125e2:	429a      	cmp	r2, r3
 81125e4:	d803      	bhi.n	81125ee <ip_reass_remove_oldest_datagram+0x76>
          /* older than the previous oldest */
          oldest = r;
 81125e6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 81125e8:	623b      	str	r3, [r7, #32]
          oldest_prev = prev;
 81125ea:	69fb      	ldr	r3, [r7, #28]
 81125ec:	61bb      	str	r3, [r7, #24]
        }
      }
      if (r->next != NULL) {
 81125ee:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 81125f0:	681b      	ldr	r3, [r3, #0]
 81125f2:	2b00      	cmp	r3, #0
 81125f4:	d001      	beq.n	81125fa <ip_reass_remove_oldest_datagram+0x82>
        prev = r;
 81125f6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 81125f8:	61fb      	str	r3, [r7, #28]
      }
      r = r->next;
 81125fa:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 81125fc:	681b      	ldr	r3, [r3, #0]
 81125fe:	627b      	str	r3, [r7, #36]	; 0x24
    while (r != NULL) {
 8112600:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8112602:	2b00      	cmp	r3, #0
 8112604:	d1cb      	bne.n	811259e <ip_reass_remove_oldest_datagram+0x26>
    }
    if (oldest != NULL) {
 8112606:	6a3b      	ldr	r3, [r7, #32]
 8112608:	2b00      	cmp	r3, #0
 811260a:	d008      	beq.n	811261e <ip_reass_remove_oldest_datagram+0xa6>
      pbufs_freed_current = ip_reass_free_complete_datagram(oldest, oldest_prev);
 811260c:	69b9      	ldr	r1, [r7, #24]
 811260e:	6a38      	ldr	r0, [r7, #32]
 8112610:	f7ff ff0e 	bl	8112430 <ip_reass_free_complete_datagram>
 8112614:	60f8      	str	r0, [r7, #12]
      pbufs_freed += pbufs_freed_current;
 8112616:	697a      	ldr	r2, [r7, #20]
 8112618:	68fb      	ldr	r3, [r7, #12]
 811261a:	4413      	add	r3, r2
 811261c:	617b      	str	r3, [r7, #20]
    }
  } while ((pbufs_freed < pbufs_needed) && (other_datagrams > 1));
 811261e:	697a      	ldr	r2, [r7, #20]
 8112620:	683b      	ldr	r3, [r7, #0]
 8112622:	429a      	cmp	r2, r3
 8112624:	da02      	bge.n	811262c <ip_reass_remove_oldest_datagram+0xb4>
 8112626:	693b      	ldr	r3, [r7, #16]
 8112628:	2b01      	cmp	r3, #1
 811262a:	dcac      	bgt.n	8112586 <ip_reass_remove_oldest_datagram+0xe>
  return pbufs_freed;
 811262c:	697b      	ldr	r3, [r7, #20]
}
 811262e:	4618      	mov	r0, r3
 8112630:	3728      	adds	r7, #40	; 0x28
 8112632:	46bd      	mov	sp, r7
 8112634:	bd80      	pop	{r7, pc}
 8112636:	bf00      	nop
 8112638:	1000550c 	.word	0x1000550c

0811263c <ip_reass_enqueue_new_datagram>:
 * @param clen number of pbufs needed to enqueue (used for freeing other datagrams if not enough space)
 * @return A pointer to the queue location into which the fragment was enqueued
 */
static struct ip_reassdata *
ip_reass_enqueue_new_datagram(struct ip_hdr *fraghdr, int clen)
{
 811263c:	b580      	push	{r7, lr}
 811263e:	b084      	sub	sp, #16
 8112640:	af00      	add	r7, sp, #0
 8112642:	6078      	str	r0, [r7, #4]
 8112644:	6039      	str	r1, [r7, #0]
#if ! IP_REASS_FREE_OLDEST
  LWIP_UNUSED_ARG(clen);
#endif

  /* No matching previous fragment found, allocate a new reassdata struct */
  ipr = (struct ip_reassdata *)memp_malloc(MEMP_REASSDATA);
 8112646:	2004      	movs	r0, #4
 8112648:	f001 f934 	bl	81138b4 <memp_malloc>
 811264c:	60f8      	str	r0, [r7, #12]
  if (ipr == NULL) {
 811264e:	68fb      	ldr	r3, [r7, #12]
 8112650:	2b00      	cmp	r3, #0
 8112652:	d110      	bne.n	8112676 <ip_reass_enqueue_new_datagram+0x3a>
#if IP_REASS_FREE_OLDEST
    if (ip_reass_remove_oldest_datagram(fraghdr, clen) >= clen) {
 8112654:	6839      	ldr	r1, [r7, #0]
 8112656:	6878      	ldr	r0, [r7, #4]
 8112658:	f7ff ff8e 	bl	8112578 <ip_reass_remove_oldest_datagram>
 811265c:	4602      	mov	r2, r0
 811265e:	683b      	ldr	r3, [r7, #0]
 8112660:	4293      	cmp	r3, r2
 8112662:	dc03      	bgt.n	811266c <ip_reass_enqueue_new_datagram+0x30>
      ipr = (struct ip_reassdata *)memp_malloc(MEMP_REASSDATA);
 8112664:	2004      	movs	r0, #4
 8112666:	f001 f925 	bl	81138b4 <memp_malloc>
 811266a:	60f8      	str	r0, [r7, #12]
    }
    if (ipr == NULL)
 811266c:	68fb      	ldr	r3, [r7, #12]
 811266e:	2b00      	cmp	r3, #0
 8112670:	d101      	bne.n	8112676 <ip_reass_enqueue_new_datagram+0x3a>
#endif /* IP_REASS_FREE_OLDEST */
    {
      IPFRAG_STATS_INC(ip_frag.memerr);
      LWIP_DEBUGF(IP_REASS_DEBUG, ("Failed to alloc reassdata struct\n"));
      return NULL;
 8112672:	2300      	movs	r3, #0
 8112674:	e016      	b.n	81126a4 <ip_reass_enqueue_new_datagram+0x68>
    }
  }
  memset(ipr, 0, sizeof(struct ip_reassdata));
 8112676:	2220      	movs	r2, #32
 8112678:	2100      	movs	r1, #0
 811267a:	68f8      	ldr	r0, [r7, #12]
 811267c:	f009 f8ea 	bl	811b854 <memset>
  ipr->timer = IP_REASS_MAXAGE;
 8112680:	68fb      	ldr	r3, [r7, #12]
 8112682:	220f      	movs	r2, #15
 8112684:	77da      	strb	r2, [r3, #31]

  /* enqueue the new structure to the front of the list */
  ipr->next = reassdatagrams;
 8112686:	4b09      	ldr	r3, [pc, #36]	; (81126ac <ip_reass_enqueue_new_datagram+0x70>)
 8112688:	681a      	ldr	r2, [r3, #0]
 811268a:	68fb      	ldr	r3, [r7, #12]
 811268c:	601a      	str	r2, [r3, #0]
  reassdatagrams = ipr;
 811268e:	4a07      	ldr	r2, [pc, #28]	; (81126ac <ip_reass_enqueue_new_datagram+0x70>)
 8112690:	68fb      	ldr	r3, [r7, #12]
 8112692:	6013      	str	r3, [r2, #0]
  /* copy the ip header for later tests and input */
  /* @todo: no ip options supported? */
  SMEMCPY(&(ipr->iphdr), fraghdr, IP_HLEN);
 8112694:	68fb      	ldr	r3, [r7, #12]
 8112696:	3308      	adds	r3, #8
 8112698:	2214      	movs	r2, #20
 811269a:	6879      	ldr	r1, [r7, #4]
 811269c:	4618      	mov	r0, r3
 811269e:	f009 f907 	bl	811b8b0 <memcpy>
  return ipr;
 81126a2:	68fb      	ldr	r3, [r7, #12]
}
 81126a4:	4618      	mov	r0, r3
 81126a6:	3710      	adds	r7, #16
 81126a8:	46bd      	mov	sp, r7
 81126aa:	bd80      	pop	{r7, pc}
 81126ac:	1000550c 	.word	0x1000550c

081126b0 <ip_reass_dequeue_datagram>:
 * Dequeues a datagram from the datagram queue. Doesn't deallocate the pbufs.
 * @param ipr points to the queue entry to dequeue
 */
static void
ip_reass_dequeue_datagram(struct ip_reassdata *ipr, struct ip_reassdata *prev)
{
 81126b0:	b580      	push	{r7, lr}
 81126b2:	b082      	sub	sp, #8
 81126b4:	af00      	add	r7, sp, #0
 81126b6:	6078      	str	r0, [r7, #4]
 81126b8:	6039      	str	r1, [r7, #0]
  /* dequeue the reass struct  */
  if (reassdatagrams == ipr) {
 81126ba:	4b10      	ldr	r3, [pc, #64]	; (81126fc <ip_reass_dequeue_datagram+0x4c>)
 81126bc:	681b      	ldr	r3, [r3, #0]
 81126be:	687a      	ldr	r2, [r7, #4]
 81126c0:	429a      	cmp	r2, r3
 81126c2:	d104      	bne.n	81126ce <ip_reass_dequeue_datagram+0x1e>
    /* it was the first in the list */
    reassdatagrams = ipr->next;
 81126c4:	687b      	ldr	r3, [r7, #4]
 81126c6:	681b      	ldr	r3, [r3, #0]
 81126c8:	4a0c      	ldr	r2, [pc, #48]	; (81126fc <ip_reass_dequeue_datagram+0x4c>)
 81126ca:	6013      	str	r3, [r2, #0]
 81126cc:	e00d      	b.n	81126ea <ip_reass_dequeue_datagram+0x3a>
  } else {
    /* it wasn't the first, so it must have a valid 'prev' */
    LWIP_ASSERT("sanity check linked list", prev != NULL);
 81126ce:	683b      	ldr	r3, [r7, #0]
 81126d0:	2b00      	cmp	r3, #0
 81126d2:	d106      	bne.n	81126e2 <ip_reass_dequeue_datagram+0x32>
 81126d4:	4b0a      	ldr	r3, [pc, #40]	; (8112700 <ip_reass_dequeue_datagram+0x50>)
 81126d6:	f240 1245 	movw	r2, #325	; 0x145
 81126da:	490a      	ldr	r1, [pc, #40]	; (8112704 <ip_reass_dequeue_datagram+0x54>)
 81126dc:	480a      	ldr	r0, [pc, #40]	; (8112708 <ip_reass_dequeue_datagram+0x58>)
 81126de:	f009 f88f 	bl	811b800 <iprintf>
    prev->next = ipr->next;
 81126e2:	687b      	ldr	r3, [r7, #4]
 81126e4:	681a      	ldr	r2, [r3, #0]
 81126e6:	683b      	ldr	r3, [r7, #0]
 81126e8:	601a      	str	r2, [r3, #0]
  }

  /* now we can free the ip_reassdata struct */
  memp_free(MEMP_REASSDATA, ipr);
 81126ea:	6879      	ldr	r1, [r7, #4]
 81126ec:	2004      	movs	r0, #4
 81126ee:	f001 f951 	bl	8113994 <memp_free>
}
 81126f2:	bf00      	nop
 81126f4:	3708      	adds	r7, #8
 81126f6:	46bd      	mov	sp, r7
 81126f8:	bd80      	pop	{r7, pc}
 81126fa:	bf00      	nop
 81126fc:	1000550c 	.word	0x1000550c
 8112700:	0811d1ac 	.word	0x0811d1ac
 8112704:	0811d2a4 	.word	0x0811d2a4
 8112708:	0811d224 	.word	0x0811d224

0811270c <ip_reass_chain_frag_into_datagram_and_validate>:
 * @param is_last is 1 if this pbuf has MF==0 (ipr->flags not updated yet)
 * @return see IP_REASS_VALIDATE_* defines
 */
static int
ip_reass_chain_frag_into_datagram_and_validate(struct ip_reassdata *ipr, struct pbuf *new_p, int is_last)
{
 811270c:	b580      	push	{r7, lr}
 811270e:	b08c      	sub	sp, #48	; 0x30
 8112710:	af00      	add	r7, sp, #0
 8112712:	60f8      	str	r0, [r7, #12]
 8112714:	60b9      	str	r1, [r7, #8]
 8112716:	607a      	str	r2, [r7, #4]
  struct ip_reass_helper *iprh, *iprh_tmp, *iprh_prev = NULL;
 8112718:	2300      	movs	r3, #0
 811271a:	62bb      	str	r3, [r7, #40]	; 0x28
  struct pbuf *q;
  u16_t offset, len;
  u8_t hlen;
  struct ip_hdr *fraghdr;
  int valid = 1;
 811271c:	2301      	movs	r3, #1
 811271e:	623b      	str	r3, [r7, #32]

  /* Extract length and fragment offset from current fragment */
  fraghdr = (struct ip_hdr *)new_p->payload;
 8112720:	68bb      	ldr	r3, [r7, #8]
 8112722:	685b      	ldr	r3, [r3, #4]
 8112724:	61fb      	str	r3, [r7, #28]
  len = lwip_ntohs(IPH_LEN(fraghdr));
 8112726:	69fb      	ldr	r3, [r7, #28]
 8112728:	885b      	ldrh	r3, [r3, #2]
 811272a:	b29b      	uxth	r3, r3
 811272c:	4618      	mov	r0, r3
 811272e:	f7fb feb0 	bl	810e492 <lwip_htons>
 8112732:	4603      	mov	r3, r0
 8112734:	837b      	strh	r3, [r7, #26]
  hlen = IPH_HL_BYTES(fraghdr);
 8112736:	69fb      	ldr	r3, [r7, #28]
 8112738:	781b      	ldrb	r3, [r3, #0]
 811273a:	f003 030f 	and.w	r3, r3, #15
 811273e:	b2db      	uxtb	r3, r3
 8112740:	009b      	lsls	r3, r3, #2
 8112742:	767b      	strb	r3, [r7, #25]
  if (hlen > len) {
 8112744:	7e7b      	ldrb	r3, [r7, #25]
 8112746:	b29b      	uxth	r3, r3
 8112748:	8b7a      	ldrh	r2, [r7, #26]
 811274a:	429a      	cmp	r2, r3
 811274c:	d202      	bcs.n	8112754 <ip_reass_chain_frag_into_datagram_and_validate+0x48>
    /* invalid datagram */
    return IP_REASS_VALIDATE_PBUF_DROPPED;
 811274e:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 8112752:	e135      	b.n	81129c0 <ip_reass_chain_frag_into_datagram_and_validate+0x2b4>
  }
  len = (u16_t)(len - hlen);
 8112754:	7e7b      	ldrb	r3, [r7, #25]
 8112756:	b29b      	uxth	r3, r3
 8112758:	8b7a      	ldrh	r2, [r7, #26]
 811275a:	1ad3      	subs	r3, r2, r3
 811275c:	837b      	strh	r3, [r7, #26]
  offset = IPH_OFFSET_BYTES(fraghdr);
 811275e:	69fb      	ldr	r3, [r7, #28]
 8112760:	88db      	ldrh	r3, [r3, #6]
 8112762:	b29b      	uxth	r3, r3
 8112764:	4618      	mov	r0, r3
 8112766:	f7fb fe94 	bl	810e492 <lwip_htons>
 811276a:	4603      	mov	r3, r0
 811276c:	f3c3 030c 	ubfx	r3, r3, #0, #13
 8112770:	b29b      	uxth	r3, r3
 8112772:	00db      	lsls	r3, r3, #3
 8112774:	82fb      	strh	r3, [r7, #22]
  /* overwrite the fragment's ip header from the pbuf with our helper struct,
   * and setup the embedded helper structure. */
  /* make sure the struct ip_reass_helper fits into the IP header */
  LWIP_ASSERT("sizeof(struct ip_reass_helper) <= IP_HLEN",
              sizeof(struct ip_reass_helper) <= IP_HLEN);
  iprh = (struct ip_reass_helper *)new_p->payload;
 8112776:	68bb      	ldr	r3, [r7, #8]
 8112778:	685b      	ldr	r3, [r3, #4]
 811277a:	62fb      	str	r3, [r7, #44]	; 0x2c
  iprh->next_pbuf = NULL;
 811277c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 811277e:	2200      	movs	r2, #0
 8112780:	701a      	strb	r2, [r3, #0]
 8112782:	2200      	movs	r2, #0
 8112784:	705a      	strb	r2, [r3, #1]
 8112786:	2200      	movs	r2, #0
 8112788:	709a      	strb	r2, [r3, #2]
 811278a:	2200      	movs	r2, #0
 811278c:	70da      	strb	r2, [r3, #3]
  iprh->start = offset;
 811278e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8112790:	8afa      	ldrh	r2, [r7, #22]
 8112792:	809a      	strh	r2, [r3, #4]
  iprh->end = (u16_t)(offset + len);
 8112794:	8afa      	ldrh	r2, [r7, #22]
 8112796:	8b7b      	ldrh	r3, [r7, #26]
 8112798:	4413      	add	r3, r2
 811279a:	b29a      	uxth	r2, r3
 811279c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 811279e:	80da      	strh	r2, [r3, #6]
  if (iprh->end < offset) {
 81127a0:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 81127a2:	88db      	ldrh	r3, [r3, #6]
 81127a4:	b29b      	uxth	r3, r3
 81127a6:	8afa      	ldrh	r2, [r7, #22]
 81127a8:	429a      	cmp	r2, r3
 81127aa:	d902      	bls.n	81127b2 <ip_reass_chain_frag_into_datagram_and_validate+0xa6>
    /* u16_t overflow, cannot handle this */
    return IP_REASS_VALIDATE_PBUF_DROPPED;
 81127ac:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 81127b0:	e106      	b.n	81129c0 <ip_reass_chain_frag_into_datagram_and_validate+0x2b4>
  }

  /* Iterate through until we either get to the end of the list (append),
   * or we find one with a larger offset (insert). */
  for (q = ipr->p; q != NULL;) {
 81127b2:	68fb      	ldr	r3, [r7, #12]
 81127b4:	685b      	ldr	r3, [r3, #4]
 81127b6:	627b      	str	r3, [r7, #36]	; 0x24
 81127b8:	e068      	b.n	811288c <ip_reass_chain_frag_into_datagram_and_validate+0x180>
    iprh_tmp = (struct ip_reass_helper *)q->payload;
 81127ba:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 81127bc:	685b      	ldr	r3, [r3, #4]
 81127be:	613b      	str	r3, [r7, #16]
    if (iprh->start < iprh_tmp->start) {
 81127c0:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 81127c2:	889b      	ldrh	r3, [r3, #4]
 81127c4:	b29a      	uxth	r2, r3
 81127c6:	693b      	ldr	r3, [r7, #16]
 81127c8:	889b      	ldrh	r3, [r3, #4]
 81127ca:	b29b      	uxth	r3, r3
 81127cc:	429a      	cmp	r2, r3
 81127ce:	d235      	bcs.n	811283c <ip_reass_chain_frag_into_datagram_and_validate+0x130>
      /* the new pbuf should be inserted before this */
      iprh->next_pbuf = q;
 81127d0:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 81127d2:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 81127d4:	601a      	str	r2, [r3, #0]
      if (iprh_prev != NULL) {
 81127d6:	6abb      	ldr	r3, [r7, #40]	; 0x28
 81127d8:	2b00      	cmp	r3, #0
 81127da:	d020      	beq.n	811281e <ip_reass_chain_frag_into_datagram_and_validate+0x112>
        /* not the fragment with the lowest offset */
#if IP_REASS_CHECK_OVERLAP
        if ((iprh->start < iprh_prev->end) || (iprh->end > iprh_tmp->start)) {
 81127dc:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 81127de:	889b      	ldrh	r3, [r3, #4]
 81127e0:	b29a      	uxth	r2, r3
 81127e2:	6abb      	ldr	r3, [r7, #40]	; 0x28
 81127e4:	88db      	ldrh	r3, [r3, #6]
 81127e6:	b29b      	uxth	r3, r3
 81127e8:	429a      	cmp	r2, r3
 81127ea:	d307      	bcc.n	81127fc <ip_reass_chain_frag_into_datagram_and_validate+0xf0>
 81127ec:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 81127ee:	88db      	ldrh	r3, [r3, #6]
 81127f0:	b29a      	uxth	r2, r3
 81127f2:	693b      	ldr	r3, [r7, #16]
 81127f4:	889b      	ldrh	r3, [r3, #4]
 81127f6:	b29b      	uxth	r3, r3
 81127f8:	429a      	cmp	r2, r3
 81127fa:	d902      	bls.n	8112802 <ip_reass_chain_frag_into_datagram_and_validate+0xf6>
          /* fragment overlaps with previous or following, throw away */
          return IP_REASS_VALIDATE_PBUF_DROPPED;
 81127fc:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 8112800:	e0de      	b.n	81129c0 <ip_reass_chain_frag_into_datagram_and_validate+0x2b4>
        }
#endif /* IP_REASS_CHECK_OVERLAP */
        iprh_prev->next_pbuf = new_p;
 8112802:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8112804:	68ba      	ldr	r2, [r7, #8]
 8112806:	601a      	str	r2, [r3, #0]
        if (iprh_prev->end != iprh->start) {
 8112808:	6abb      	ldr	r3, [r7, #40]	; 0x28
 811280a:	88db      	ldrh	r3, [r3, #6]
 811280c:	b29a      	uxth	r2, r3
 811280e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8112810:	889b      	ldrh	r3, [r3, #4]
 8112812:	b29b      	uxth	r3, r3
 8112814:	429a      	cmp	r2, r3
 8112816:	d03d      	beq.n	8112894 <ip_reass_chain_frag_into_datagram_and_validate+0x188>
          /* There is a fragment missing between the current
           * and the previous fragment */
          valid = 0;
 8112818:	2300      	movs	r3, #0
 811281a:	623b      	str	r3, [r7, #32]
        }
#endif /* IP_REASS_CHECK_OVERLAP */
        /* fragment with the lowest offset */
        ipr->p = new_p;
      }
      break;
 811281c:	e03a      	b.n	8112894 <ip_reass_chain_frag_into_datagram_and_validate+0x188>
        if (iprh->end > iprh_tmp->start) {
 811281e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8112820:	88db      	ldrh	r3, [r3, #6]
 8112822:	b29a      	uxth	r2, r3
 8112824:	693b      	ldr	r3, [r7, #16]
 8112826:	889b      	ldrh	r3, [r3, #4]
 8112828:	b29b      	uxth	r3, r3
 811282a:	429a      	cmp	r2, r3
 811282c:	d902      	bls.n	8112834 <ip_reass_chain_frag_into_datagram_and_validate+0x128>
          return IP_REASS_VALIDATE_PBUF_DROPPED;
 811282e:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 8112832:	e0c5      	b.n	81129c0 <ip_reass_chain_frag_into_datagram_and_validate+0x2b4>
        ipr->p = new_p;
 8112834:	68fb      	ldr	r3, [r7, #12]
 8112836:	68ba      	ldr	r2, [r7, #8]
 8112838:	605a      	str	r2, [r3, #4]
      break;
 811283a:	e02b      	b.n	8112894 <ip_reass_chain_frag_into_datagram_and_validate+0x188>
    } else if (iprh->start == iprh_tmp->start) {
 811283c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 811283e:	889b      	ldrh	r3, [r3, #4]
 8112840:	b29a      	uxth	r2, r3
 8112842:	693b      	ldr	r3, [r7, #16]
 8112844:	889b      	ldrh	r3, [r3, #4]
 8112846:	b29b      	uxth	r3, r3
 8112848:	429a      	cmp	r2, r3
 811284a:	d102      	bne.n	8112852 <ip_reass_chain_frag_into_datagram_and_validate+0x146>
      /* received the same datagram twice: no need to keep the datagram */
      return IP_REASS_VALIDATE_PBUF_DROPPED;
 811284c:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 8112850:	e0b6      	b.n	81129c0 <ip_reass_chain_frag_into_datagram_and_validate+0x2b4>
#if IP_REASS_CHECK_OVERLAP
    } else if (iprh->start < iprh_tmp->end) {
 8112852:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8112854:	889b      	ldrh	r3, [r3, #4]
 8112856:	b29a      	uxth	r2, r3
 8112858:	693b      	ldr	r3, [r7, #16]
 811285a:	88db      	ldrh	r3, [r3, #6]
 811285c:	b29b      	uxth	r3, r3
 811285e:	429a      	cmp	r2, r3
 8112860:	d202      	bcs.n	8112868 <ip_reass_chain_frag_into_datagram_and_validate+0x15c>
      /* overlap: no need to keep the new datagram */
      return IP_REASS_VALIDATE_PBUF_DROPPED;
 8112862:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 8112866:	e0ab      	b.n	81129c0 <ip_reass_chain_frag_into_datagram_and_validate+0x2b4>
#endif /* IP_REASS_CHECK_OVERLAP */
    } else {
      /* Check if the fragments received so far have no holes. */
      if (iprh_prev != NULL) {
 8112868:	6abb      	ldr	r3, [r7, #40]	; 0x28
 811286a:	2b00      	cmp	r3, #0
 811286c:	d009      	beq.n	8112882 <ip_reass_chain_frag_into_datagram_and_validate+0x176>
        if (iprh_prev->end != iprh_tmp->start) {
 811286e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8112870:	88db      	ldrh	r3, [r3, #6]
 8112872:	b29a      	uxth	r2, r3
 8112874:	693b      	ldr	r3, [r7, #16]
 8112876:	889b      	ldrh	r3, [r3, #4]
 8112878:	b29b      	uxth	r3, r3
 811287a:	429a      	cmp	r2, r3
 811287c:	d001      	beq.n	8112882 <ip_reass_chain_frag_into_datagram_and_validate+0x176>
          /* There is a fragment missing between the current
           * and the previous fragment */
          valid = 0;
 811287e:	2300      	movs	r3, #0
 8112880:	623b      	str	r3, [r7, #32]
        }
      }
    }
    q = iprh_tmp->next_pbuf;
 8112882:	693b      	ldr	r3, [r7, #16]
 8112884:	681b      	ldr	r3, [r3, #0]
 8112886:	627b      	str	r3, [r7, #36]	; 0x24
    iprh_prev = iprh_tmp;
 8112888:	693b      	ldr	r3, [r7, #16]
 811288a:	62bb      	str	r3, [r7, #40]	; 0x28
  for (q = ipr->p; q != NULL;) {
 811288c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 811288e:	2b00      	cmp	r3, #0
 8112890:	d193      	bne.n	81127ba <ip_reass_chain_frag_into_datagram_and_validate+0xae>
 8112892:	e000      	b.n	8112896 <ip_reass_chain_frag_into_datagram_and_validate+0x18a>
      break;
 8112894:	bf00      	nop
  }

  /* If q is NULL, then we made it to the end of the list. Determine what to do now */
  if (q == NULL) {
 8112896:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8112898:	2b00      	cmp	r3, #0
 811289a:	d12d      	bne.n	81128f8 <ip_reass_chain_frag_into_datagram_and_validate+0x1ec>
    if (iprh_prev != NULL) {
 811289c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 811289e:	2b00      	cmp	r3, #0
 81128a0:	d01c      	beq.n	81128dc <ip_reass_chain_frag_into_datagram_and_validate+0x1d0>
      /* this is (for now), the fragment with the highest offset:
       * chain it to the last fragment */
#if IP_REASS_CHECK_OVERLAP
      LWIP_ASSERT("check fragments don't overlap", iprh_prev->end <= iprh->start);
 81128a2:	6abb      	ldr	r3, [r7, #40]	; 0x28
 81128a4:	88db      	ldrh	r3, [r3, #6]
 81128a6:	b29a      	uxth	r2, r3
 81128a8:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 81128aa:	889b      	ldrh	r3, [r3, #4]
 81128ac:	b29b      	uxth	r3, r3
 81128ae:	429a      	cmp	r2, r3
 81128b0:	d906      	bls.n	81128c0 <ip_reass_chain_frag_into_datagram_and_validate+0x1b4>
 81128b2:	4b45      	ldr	r3, [pc, #276]	; (81129c8 <ip_reass_chain_frag_into_datagram_and_validate+0x2bc>)
 81128b4:	f44f 72db 	mov.w	r2, #438	; 0x1b6
 81128b8:	4944      	ldr	r1, [pc, #272]	; (81129cc <ip_reass_chain_frag_into_datagram_and_validate+0x2c0>)
 81128ba:	4845      	ldr	r0, [pc, #276]	; (81129d0 <ip_reass_chain_frag_into_datagram_and_validate+0x2c4>)
 81128bc:	f008 ffa0 	bl	811b800 <iprintf>
#endif /* IP_REASS_CHECK_OVERLAP */
      iprh_prev->next_pbuf = new_p;
 81128c0:	6abb      	ldr	r3, [r7, #40]	; 0x28
 81128c2:	68ba      	ldr	r2, [r7, #8]
 81128c4:	601a      	str	r2, [r3, #0]
      if (iprh_prev->end != iprh->start) {
 81128c6:	6abb      	ldr	r3, [r7, #40]	; 0x28
 81128c8:	88db      	ldrh	r3, [r3, #6]
 81128ca:	b29a      	uxth	r2, r3
 81128cc:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 81128ce:	889b      	ldrh	r3, [r3, #4]
 81128d0:	b29b      	uxth	r3, r3
 81128d2:	429a      	cmp	r2, r3
 81128d4:	d010      	beq.n	81128f8 <ip_reass_chain_frag_into_datagram_and_validate+0x1ec>
        valid = 0;
 81128d6:	2300      	movs	r3, #0
 81128d8:	623b      	str	r3, [r7, #32]
 81128da:	e00d      	b.n	81128f8 <ip_reass_chain_frag_into_datagram_and_validate+0x1ec>
      }
    } else {
#if IP_REASS_CHECK_OVERLAP
      LWIP_ASSERT("no previous fragment, this must be the first fragment!",
 81128dc:	68fb      	ldr	r3, [r7, #12]
 81128de:	685b      	ldr	r3, [r3, #4]
 81128e0:	2b00      	cmp	r3, #0
 81128e2:	d006      	beq.n	81128f2 <ip_reass_chain_frag_into_datagram_and_validate+0x1e6>
 81128e4:	4b38      	ldr	r3, [pc, #224]	; (81129c8 <ip_reass_chain_frag_into_datagram_and_validate+0x2bc>)
 81128e6:	f44f 72df 	mov.w	r2, #446	; 0x1be
 81128ea:	493a      	ldr	r1, [pc, #232]	; (81129d4 <ip_reass_chain_frag_into_datagram_and_validate+0x2c8>)
 81128ec:	4838      	ldr	r0, [pc, #224]	; (81129d0 <ip_reass_chain_frag_into_datagram_and_validate+0x2c4>)
 81128ee:	f008 ff87 	bl	811b800 <iprintf>
                  ipr->p == NULL);
#endif /* IP_REASS_CHECK_OVERLAP */
      /* this is the first fragment we ever received for this ip datagram */
      ipr->p = new_p;
 81128f2:	68fb      	ldr	r3, [r7, #12]
 81128f4:	68ba      	ldr	r2, [r7, #8]
 81128f6:	605a      	str	r2, [r3, #4]
    }
  }

  /* At this point, the validation part begins: */
  /* If we already received the last fragment */
  if (is_last || ((ipr->flags & IP_REASS_FLAG_LASTFRAG) != 0)) {
 81128f8:	687b      	ldr	r3, [r7, #4]
 81128fa:	2b00      	cmp	r3, #0
 81128fc:	d105      	bne.n	811290a <ip_reass_chain_frag_into_datagram_and_validate+0x1fe>
 81128fe:	68fb      	ldr	r3, [r7, #12]
 8112900:	7f9b      	ldrb	r3, [r3, #30]
 8112902:	f003 0301 	and.w	r3, r3, #1
 8112906:	2b00      	cmp	r3, #0
 8112908:	d059      	beq.n	81129be <ip_reass_chain_frag_into_datagram_and_validate+0x2b2>
    /* and had no holes so far */
    if (valid) {
 811290a:	6a3b      	ldr	r3, [r7, #32]
 811290c:	2b00      	cmp	r3, #0
 811290e:	d04f      	beq.n	81129b0 <ip_reass_chain_frag_into_datagram_and_validate+0x2a4>
      /* then check if the rest of the fragments is here */
      /* Check if the queue starts with the first datagram */
      if ((ipr->p == NULL) || (((struct ip_reass_helper *)ipr->p->payload)->start != 0)) {
 8112910:	68fb      	ldr	r3, [r7, #12]
 8112912:	685b      	ldr	r3, [r3, #4]
 8112914:	2b00      	cmp	r3, #0
 8112916:	d006      	beq.n	8112926 <ip_reass_chain_frag_into_datagram_and_validate+0x21a>
 8112918:	68fb      	ldr	r3, [r7, #12]
 811291a:	685b      	ldr	r3, [r3, #4]
 811291c:	685b      	ldr	r3, [r3, #4]
 811291e:	889b      	ldrh	r3, [r3, #4]
 8112920:	b29b      	uxth	r3, r3
 8112922:	2b00      	cmp	r3, #0
 8112924:	d002      	beq.n	811292c <ip_reass_chain_frag_into_datagram_and_validate+0x220>
        valid = 0;
 8112926:	2300      	movs	r3, #0
 8112928:	623b      	str	r3, [r7, #32]
 811292a:	e041      	b.n	81129b0 <ip_reass_chain_frag_into_datagram_and_validate+0x2a4>
      } else {
        /* and check that there are no holes after this datagram */
        iprh_prev = iprh;
 811292c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 811292e:	62bb      	str	r3, [r7, #40]	; 0x28
        q = iprh->next_pbuf;
 8112930:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8112932:	681b      	ldr	r3, [r3, #0]
 8112934:	627b      	str	r3, [r7, #36]	; 0x24
        while (q != NULL) {
 8112936:	e012      	b.n	811295e <ip_reass_chain_frag_into_datagram_and_validate+0x252>
          iprh = (struct ip_reass_helper *)q->payload;
 8112938:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 811293a:	685b      	ldr	r3, [r3, #4]
 811293c:	62fb      	str	r3, [r7, #44]	; 0x2c
          if (iprh_prev->end != iprh->start) {
 811293e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8112940:	88db      	ldrh	r3, [r3, #6]
 8112942:	b29a      	uxth	r2, r3
 8112944:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8112946:	889b      	ldrh	r3, [r3, #4]
 8112948:	b29b      	uxth	r3, r3
 811294a:	429a      	cmp	r2, r3
 811294c:	d002      	beq.n	8112954 <ip_reass_chain_frag_into_datagram_and_validate+0x248>
            valid = 0;
 811294e:	2300      	movs	r3, #0
 8112950:	623b      	str	r3, [r7, #32]
            break;
 8112952:	e007      	b.n	8112964 <ip_reass_chain_frag_into_datagram_and_validate+0x258>
          }
          iprh_prev = iprh;
 8112954:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8112956:	62bb      	str	r3, [r7, #40]	; 0x28
          q = iprh->next_pbuf;
 8112958:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 811295a:	681b      	ldr	r3, [r3, #0]
 811295c:	627b      	str	r3, [r7, #36]	; 0x24
        while (q != NULL) {
 811295e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8112960:	2b00      	cmp	r3, #0
 8112962:	d1e9      	bne.n	8112938 <ip_reass_chain_frag_into_datagram_and_validate+0x22c>
        }
        /* if still valid, all fragments are received
         * (because to the MF==0 already arrived */
        if (valid) {
 8112964:	6a3b      	ldr	r3, [r7, #32]
 8112966:	2b00      	cmp	r3, #0
 8112968:	d022      	beq.n	81129b0 <ip_reass_chain_frag_into_datagram_and_validate+0x2a4>
          LWIP_ASSERT("sanity check", ipr->p != NULL);
 811296a:	68fb      	ldr	r3, [r7, #12]
 811296c:	685b      	ldr	r3, [r3, #4]
 811296e:	2b00      	cmp	r3, #0
 8112970:	d106      	bne.n	8112980 <ip_reass_chain_frag_into_datagram_and_validate+0x274>
 8112972:	4b15      	ldr	r3, [pc, #84]	; (81129c8 <ip_reass_chain_frag_into_datagram_and_validate+0x2bc>)
 8112974:	f240 12df 	movw	r2, #479	; 0x1df
 8112978:	4917      	ldr	r1, [pc, #92]	; (81129d8 <ip_reass_chain_frag_into_datagram_and_validate+0x2cc>)
 811297a:	4815      	ldr	r0, [pc, #84]	; (81129d0 <ip_reass_chain_frag_into_datagram_and_validate+0x2c4>)
 811297c:	f008 ff40 	bl	811b800 <iprintf>
          LWIP_ASSERT("sanity check",
 8112980:	68fb      	ldr	r3, [r7, #12]
 8112982:	685b      	ldr	r3, [r3, #4]
 8112984:	685b      	ldr	r3, [r3, #4]
 8112986:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8112988:	429a      	cmp	r2, r3
 811298a:	d106      	bne.n	811299a <ip_reass_chain_frag_into_datagram_and_validate+0x28e>
 811298c:	4b0e      	ldr	r3, [pc, #56]	; (81129c8 <ip_reass_chain_frag_into_datagram_and_validate+0x2bc>)
 811298e:	f44f 72f0 	mov.w	r2, #480	; 0x1e0
 8112992:	4911      	ldr	r1, [pc, #68]	; (81129d8 <ip_reass_chain_frag_into_datagram_and_validate+0x2cc>)
 8112994:	480e      	ldr	r0, [pc, #56]	; (81129d0 <ip_reass_chain_frag_into_datagram_and_validate+0x2c4>)
 8112996:	f008 ff33 	bl	811b800 <iprintf>
                      ((struct ip_reass_helper *)ipr->p->payload) != iprh);
          LWIP_ASSERT("validate_datagram:next_pbuf!=NULL",
 811299a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 811299c:	681b      	ldr	r3, [r3, #0]
 811299e:	2b00      	cmp	r3, #0
 81129a0:	d006      	beq.n	81129b0 <ip_reass_chain_frag_into_datagram_and_validate+0x2a4>
 81129a2:	4b09      	ldr	r3, [pc, #36]	; (81129c8 <ip_reass_chain_frag_into_datagram_and_validate+0x2bc>)
 81129a4:	f44f 72f1 	mov.w	r2, #482	; 0x1e2
 81129a8:	490c      	ldr	r1, [pc, #48]	; (81129dc <ip_reass_chain_frag_into_datagram_and_validate+0x2d0>)
 81129aa:	4809      	ldr	r0, [pc, #36]	; (81129d0 <ip_reass_chain_frag_into_datagram_and_validate+0x2c4>)
 81129ac:	f008 ff28 	bl	811b800 <iprintf>
      }
    }
    /* If valid is 0 here, there are some fragments missing in the middle
     * (since MF == 0 has already arrived). Such datagrams simply time out if
     * no more fragments are received... */
    return valid ? IP_REASS_VALIDATE_TELEGRAM_FINISHED : IP_REASS_VALIDATE_PBUF_QUEUED;
 81129b0:	6a3b      	ldr	r3, [r7, #32]
 81129b2:	2b00      	cmp	r3, #0
 81129b4:	bf14      	ite	ne
 81129b6:	2301      	movne	r3, #1
 81129b8:	2300      	moveq	r3, #0
 81129ba:	b2db      	uxtb	r3, r3
 81129bc:	e000      	b.n	81129c0 <ip_reass_chain_frag_into_datagram_and_validate+0x2b4>
  }
  /* If we come here, not all fragments were received, yet! */
  return IP_REASS_VALIDATE_PBUF_QUEUED; /* not yet valid! */
 81129be:	2300      	movs	r3, #0
}
 81129c0:	4618      	mov	r0, r3
 81129c2:	3730      	adds	r7, #48	; 0x30
 81129c4:	46bd      	mov	sp, r7
 81129c6:	bd80      	pop	{r7, pc}
 81129c8:	0811d1ac 	.word	0x0811d1ac
 81129cc:	0811d2c0 	.word	0x0811d2c0
 81129d0:	0811d224 	.word	0x0811d224
 81129d4:	0811d2e0 	.word	0x0811d2e0
 81129d8:	0811d318 	.word	0x0811d318
 81129dc:	0811d328 	.word	0x0811d328

081129e0 <ip4_reass>:
 * @param p points to a pbuf chain of the fragment
 * @return NULL if reassembly is incomplete, ? otherwise
 */
struct pbuf *
ip4_reass(struct pbuf *p)
{
 81129e0:	b580      	push	{r7, lr}
 81129e2:	b08e      	sub	sp, #56	; 0x38
 81129e4:	af00      	add	r7, sp, #0
 81129e6:	6078      	str	r0, [r7, #4]
  int is_last;

  IPFRAG_STATS_INC(ip_frag.recv);
  MIB2_STATS_INC(mib2.ipreasmreqds);

  fraghdr = (struct ip_hdr *)p->payload;
 81129e8:	687b      	ldr	r3, [r7, #4]
 81129ea:	685b      	ldr	r3, [r3, #4]
 81129ec:	62bb      	str	r3, [r7, #40]	; 0x28

  if (IPH_HL_BYTES(fraghdr) != IP_HLEN) {
 81129ee:	6abb      	ldr	r3, [r7, #40]	; 0x28
 81129f0:	781b      	ldrb	r3, [r3, #0]
 81129f2:	f003 030f 	and.w	r3, r3, #15
 81129f6:	b2db      	uxtb	r3, r3
 81129f8:	009b      	lsls	r3, r3, #2
 81129fa:	b2db      	uxtb	r3, r3
 81129fc:	2b14      	cmp	r3, #20
 81129fe:	f040 8171 	bne.w	8112ce4 <ip4_reass+0x304>
    LWIP_DEBUGF(IP_REASS_DEBUG, ("ip4_reass: IP options currently not supported!\n"));
    IPFRAG_STATS_INC(ip_frag.err);
    goto nullreturn;
  }

  offset = IPH_OFFSET_BYTES(fraghdr);
 8112a02:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8112a04:	88db      	ldrh	r3, [r3, #6]
 8112a06:	b29b      	uxth	r3, r3
 8112a08:	4618      	mov	r0, r3
 8112a0a:	f7fb fd42 	bl	810e492 <lwip_htons>
 8112a0e:	4603      	mov	r3, r0
 8112a10:	f3c3 030c 	ubfx	r3, r3, #0, #13
 8112a14:	b29b      	uxth	r3, r3
 8112a16:	00db      	lsls	r3, r3, #3
 8112a18:	84fb      	strh	r3, [r7, #38]	; 0x26
  len = lwip_ntohs(IPH_LEN(fraghdr));
 8112a1a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8112a1c:	885b      	ldrh	r3, [r3, #2]
 8112a1e:	b29b      	uxth	r3, r3
 8112a20:	4618      	mov	r0, r3
 8112a22:	f7fb fd36 	bl	810e492 <lwip_htons>
 8112a26:	4603      	mov	r3, r0
 8112a28:	84bb      	strh	r3, [r7, #36]	; 0x24
  hlen = IPH_HL_BYTES(fraghdr);
 8112a2a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8112a2c:	781b      	ldrb	r3, [r3, #0]
 8112a2e:	f003 030f 	and.w	r3, r3, #15
 8112a32:	b2db      	uxtb	r3, r3
 8112a34:	009b      	lsls	r3, r3, #2
 8112a36:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23
  if (hlen > len) {
 8112a3a:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
 8112a3e:	b29b      	uxth	r3, r3
 8112a40:	8cba      	ldrh	r2, [r7, #36]	; 0x24
 8112a42:	429a      	cmp	r2, r3
 8112a44:	f0c0 8150 	bcc.w	8112ce8 <ip4_reass+0x308>
    /* invalid datagram */
    goto nullreturn;
  }
  len = (u16_t)(len - hlen);
 8112a48:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
 8112a4c:	b29b      	uxth	r3, r3
 8112a4e:	8cba      	ldrh	r2, [r7, #36]	; 0x24
 8112a50:	1ad3      	subs	r3, r2, r3
 8112a52:	84bb      	strh	r3, [r7, #36]	; 0x24

  /* Check if we are allowed to enqueue more datagrams. */
  clen = pbuf_clen(p);
 8112a54:	6878      	ldr	r0, [r7, #4]
 8112a56:	f001 fe87 	bl	8114768 <pbuf_clen>
 8112a5a:	4603      	mov	r3, r0
 8112a5c:	843b      	strh	r3, [r7, #32]
  if ((ip_reass_pbufcount + clen) > IP_REASS_MAX_PBUFS) {
 8112a5e:	4b8c      	ldr	r3, [pc, #560]	; (8112c90 <ip4_reass+0x2b0>)
 8112a60:	881b      	ldrh	r3, [r3, #0]
 8112a62:	461a      	mov	r2, r3
 8112a64:	8c3b      	ldrh	r3, [r7, #32]
 8112a66:	4413      	add	r3, r2
 8112a68:	2b0a      	cmp	r3, #10
 8112a6a:	dd10      	ble.n	8112a8e <ip4_reass+0xae>
#if IP_REASS_FREE_OLDEST
    if (!ip_reass_remove_oldest_datagram(fraghdr, clen) ||
 8112a6c:	8c3b      	ldrh	r3, [r7, #32]
 8112a6e:	4619      	mov	r1, r3
 8112a70:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 8112a72:	f7ff fd81 	bl	8112578 <ip_reass_remove_oldest_datagram>
 8112a76:	4603      	mov	r3, r0
 8112a78:	2b00      	cmp	r3, #0
 8112a7a:	f000 8137 	beq.w	8112cec <ip4_reass+0x30c>
        ((ip_reass_pbufcount + clen) > IP_REASS_MAX_PBUFS))
 8112a7e:	4b84      	ldr	r3, [pc, #528]	; (8112c90 <ip4_reass+0x2b0>)
 8112a80:	881b      	ldrh	r3, [r3, #0]
 8112a82:	461a      	mov	r2, r3
 8112a84:	8c3b      	ldrh	r3, [r7, #32]
 8112a86:	4413      	add	r3, r2
    if (!ip_reass_remove_oldest_datagram(fraghdr, clen) ||
 8112a88:	2b0a      	cmp	r3, #10
 8112a8a:	f300 812f 	bgt.w	8112cec <ip4_reass+0x30c>
    }
  }

  /* Look for the datagram the fragment belongs to in the current datagram queue,
   * remembering the previous in the queue for later dequeueing. */
  for (ipr = reassdatagrams; ipr != NULL; ipr = ipr->next) {
 8112a8e:	4b81      	ldr	r3, [pc, #516]	; (8112c94 <ip4_reass+0x2b4>)
 8112a90:	681b      	ldr	r3, [r3, #0]
 8112a92:	633b      	str	r3, [r7, #48]	; 0x30
 8112a94:	e015      	b.n	8112ac2 <ip4_reass+0xe2>
    /* Check if the incoming fragment matches the one currently present
       in the reassembly buffer. If so, we proceed with copying the
       fragment into the buffer. */
    if (IP_ADDRESSES_AND_ID_MATCH(&ipr->iphdr, fraghdr)) {
 8112a96:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8112a98:	695a      	ldr	r2, [r3, #20]
 8112a9a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8112a9c:	68db      	ldr	r3, [r3, #12]
 8112a9e:	429a      	cmp	r2, r3
 8112aa0:	d10c      	bne.n	8112abc <ip4_reass+0xdc>
 8112aa2:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8112aa4:	699a      	ldr	r2, [r3, #24]
 8112aa6:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8112aa8:	691b      	ldr	r3, [r3, #16]
 8112aaa:	429a      	cmp	r2, r3
 8112aac:	d106      	bne.n	8112abc <ip4_reass+0xdc>
 8112aae:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8112ab0:	899a      	ldrh	r2, [r3, #12]
 8112ab2:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8112ab4:	889b      	ldrh	r3, [r3, #4]
 8112ab6:	b29b      	uxth	r3, r3
 8112ab8:	429a      	cmp	r2, r3
 8112aba:	d006      	beq.n	8112aca <ip4_reass+0xea>
  for (ipr = reassdatagrams; ipr != NULL; ipr = ipr->next) {
 8112abc:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8112abe:	681b      	ldr	r3, [r3, #0]
 8112ac0:	633b      	str	r3, [r7, #48]	; 0x30
 8112ac2:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8112ac4:	2b00      	cmp	r3, #0
 8112ac6:	d1e6      	bne.n	8112a96 <ip4_reass+0xb6>
 8112ac8:	e000      	b.n	8112acc <ip4_reass+0xec>
      LWIP_DEBUGF(IP_REASS_DEBUG, ("ip4_reass: matching previous fragment ID=%"X16_F"\n",
                                   lwip_ntohs(IPH_ID(fraghdr))));
      IPFRAG_STATS_INC(ip_frag.cachehit);
      break;
 8112aca:	bf00      	nop
    }
  }

  if (ipr == NULL) {
 8112acc:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8112ace:	2b00      	cmp	r3, #0
 8112ad0:	d109      	bne.n	8112ae6 <ip4_reass+0x106>
    /* Enqueue a new datagram into the datagram queue */
    ipr = ip_reass_enqueue_new_datagram(fraghdr, clen);
 8112ad2:	8c3b      	ldrh	r3, [r7, #32]
 8112ad4:	4619      	mov	r1, r3
 8112ad6:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 8112ad8:	f7ff fdb0 	bl	811263c <ip_reass_enqueue_new_datagram>
 8112adc:	6338      	str	r0, [r7, #48]	; 0x30
    /* Bail if unable to enqueue */
    if (ipr == NULL) {
 8112ade:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8112ae0:	2b00      	cmp	r3, #0
 8112ae2:	d11c      	bne.n	8112b1e <ip4_reass+0x13e>
      goto nullreturn;
 8112ae4:	e105      	b.n	8112cf2 <ip4_reass+0x312>
    }
  } else {
    if (((lwip_ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) == 0) &&
 8112ae6:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8112ae8:	88db      	ldrh	r3, [r3, #6]
 8112aea:	b29b      	uxth	r3, r3
 8112aec:	4618      	mov	r0, r3
 8112aee:	f7fb fcd0 	bl	810e492 <lwip_htons>
 8112af2:	4603      	mov	r3, r0
 8112af4:	f3c3 030c 	ubfx	r3, r3, #0, #13
 8112af8:	2b00      	cmp	r3, #0
 8112afa:	d110      	bne.n	8112b1e <ip4_reass+0x13e>
        ((lwip_ntohs(IPH_OFFSET(&ipr->iphdr)) & IP_OFFMASK) != 0)) {
 8112afc:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8112afe:	89db      	ldrh	r3, [r3, #14]
 8112b00:	4618      	mov	r0, r3
 8112b02:	f7fb fcc6 	bl	810e492 <lwip_htons>
 8112b06:	4603      	mov	r3, r0
 8112b08:	f3c3 030c 	ubfx	r3, r3, #0, #13
    if (((lwip_ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) == 0) &&
 8112b0c:	2b00      	cmp	r3, #0
 8112b0e:	d006      	beq.n	8112b1e <ip4_reass+0x13e>
      /* ipr->iphdr is not the header from the first fragment, but fraghdr is
       * -> copy fraghdr into ipr->iphdr since we want to have the header
       * of the first fragment (for ICMP time exceeded and later, for copying
       * all options, if supported)*/
      SMEMCPY(&ipr->iphdr, fraghdr, IP_HLEN);
 8112b10:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8112b12:	3308      	adds	r3, #8
 8112b14:	2214      	movs	r2, #20
 8112b16:	6ab9      	ldr	r1, [r7, #40]	; 0x28
 8112b18:	4618      	mov	r0, r3
 8112b1a:	f008 fec9 	bl	811b8b0 <memcpy>

  /* At this point, we have either created a new entry or pointing
   * to an existing one */

  /* check for 'no more fragments', and update queue entry*/
  is_last = (IPH_OFFSET(fraghdr) & PP_NTOHS(IP_MF)) == 0;
 8112b1e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8112b20:	88db      	ldrh	r3, [r3, #6]
 8112b22:	b29b      	uxth	r3, r3
 8112b24:	f003 0320 	and.w	r3, r3, #32
 8112b28:	2b00      	cmp	r3, #0
 8112b2a:	bf0c      	ite	eq
 8112b2c:	2301      	moveq	r3, #1
 8112b2e:	2300      	movne	r3, #0
 8112b30:	b2db      	uxtb	r3, r3
 8112b32:	61fb      	str	r3, [r7, #28]
  if (is_last) {
 8112b34:	69fb      	ldr	r3, [r7, #28]
 8112b36:	2b00      	cmp	r3, #0
 8112b38:	d00e      	beq.n	8112b58 <ip4_reass+0x178>
    u16_t datagram_len = (u16_t)(offset + len);
 8112b3a:	8cfa      	ldrh	r2, [r7, #38]	; 0x26
 8112b3c:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
 8112b3e:	4413      	add	r3, r2
 8112b40:	837b      	strh	r3, [r7, #26]
    if ((datagram_len < offset) || (datagram_len > (0xFFFF - IP_HLEN))) {
 8112b42:	8b7a      	ldrh	r2, [r7, #26]
 8112b44:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 8112b46:	429a      	cmp	r2, r3
 8112b48:	f0c0 80a0 	bcc.w	8112c8c <ip4_reass+0x2ac>
 8112b4c:	8b7b      	ldrh	r3, [r7, #26]
 8112b4e:	f64f 72eb 	movw	r2, #65515	; 0xffeb
 8112b52:	4293      	cmp	r3, r2
 8112b54:	f200 809a 	bhi.w	8112c8c <ip4_reass+0x2ac>
      goto nullreturn_ipr;
    }
  }
  /* find the right place to insert this pbuf */
  /* @todo: trim pbufs if fragments are overlapping */
  valid = ip_reass_chain_frag_into_datagram_and_validate(ipr, p, is_last);
 8112b58:	69fa      	ldr	r2, [r7, #28]
 8112b5a:	6879      	ldr	r1, [r7, #4]
 8112b5c:	6b38      	ldr	r0, [r7, #48]	; 0x30
 8112b5e:	f7ff fdd5 	bl	811270c <ip_reass_chain_frag_into_datagram_and_validate>
 8112b62:	6178      	str	r0, [r7, #20]
  if (valid == IP_REASS_VALIDATE_PBUF_DROPPED) {
 8112b64:	697b      	ldr	r3, [r7, #20]
 8112b66:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 8112b6a:	f000 809b 	beq.w	8112ca4 <ip4_reass+0x2c4>
  /* if we come here, the pbuf has been enqueued */

  /* Track the current number of pbufs current 'in-flight', in order to limit
     the number of fragments that may be enqueued at any one time
     (overflow checked by testing against IP_REASS_MAX_PBUFS) */
  ip_reass_pbufcount = (u16_t)(ip_reass_pbufcount + clen);
 8112b6e:	4b48      	ldr	r3, [pc, #288]	; (8112c90 <ip4_reass+0x2b0>)
 8112b70:	881a      	ldrh	r2, [r3, #0]
 8112b72:	8c3b      	ldrh	r3, [r7, #32]
 8112b74:	4413      	add	r3, r2
 8112b76:	b29a      	uxth	r2, r3
 8112b78:	4b45      	ldr	r3, [pc, #276]	; (8112c90 <ip4_reass+0x2b0>)
 8112b7a:	801a      	strh	r2, [r3, #0]
  if (is_last) {
 8112b7c:	69fb      	ldr	r3, [r7, #28]
 8112b7e:	2b00      	cmp	r3, #0
 8112b80:	d00d      	beq.n	8112b9e <ip4_reass+0x1be>
    u16_t datagram_len = (u16_t)(offset + len);
 8112b82:	8cfa      	ldrh	r2, [r7, #38]	; 0x26
 8112b84:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
 8112b86:	4413      	add	r3, r2
 8112b88:	827b      	strh	r3, [r7, #18]
    ipr->datagram_len = datagram_len;
 8112b8a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8112b8c:	8a7a      	ldrh	r2, [r7, #18]
 8112b8e:	839a      	strh	r2, [r3, #28]
    ipr->flags |= IP_REASS_FLAG_LASTFRAG;
 8112b90:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8112b92:	7f9b      	ldrb	r3, [r3, #30]
 8112b94:	f043 0301 	orr.w	r3, r3, #1
 8112b98:	b2da      	uxtb	r2, r3
 8112b9a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8112b9c:	779a      	strb	r2, [r3, #30]
    LWIP_DEBUGF(IP_REASS_DEBUG,
                ("ip4_reass: last fragment seen, total len %"S16_F"\n",
                 ipr->datagram_len));
  }

  if (valid == IP_REASS_VALIDATE_TELEGRAM_FINISHED) {
 8112b9e:	697b      	ldr	r3, [r7, #20]
 8112ba0:	2b01      	cmp	r3, #1
 8112ba2:	d171      	bne.n	8112c88 <ip4_reass+0x2a8>
    struct ip_reassdata *ipr_prev;
    /* the totally last fragment (flag more fragments = 0) was received at least
     * once AND all fragments are received */
    u16_t datagram_len = (u16_t)(ipr->datagram_len + IP_HLEN);
 8112ba4:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8112ba6:	8b9b      	ldrh	r3, [r3, #28]
 8112ba8:	3314      	adds	r3, #20
 8112baa:	823b      	strh	r3, [r7, #16]

    /* save the second pbuf before copying the header over the pointer */
    r = ((struct ip_reass_helper *)ipr->p->payload)->next_pbuf;
 8112bac:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8112bae:	685b      	ldr	r3, [r3, #4]
 8112bb0:	685b      	ldr	r3, [r3, #4]
 8112bb2:	681b      	ldr	r3, [r3, #0]
 8112bb4:	637b      	str	r3, [r7, #52]	; 0x34

    /* copy the original ip header back to the first pbuf */
    fraghdr = (struct ip_hdr *)(ipr->p->payload);
 8112bb6:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8112bb8:	685b      	ldr	r3, [r3, #4]
 8112bba:	685b      	ldr	r3, [r3, #4]
 8112bbc:	62bb      	str	r3, [r7, #40]	; 0x28
    SMEMCPY(fraghdr, &ipr->iphdr, IP_HLEN);
 8112bbe:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8112bc0:	3308      	adds	r3, #8
 8112bc2:	2214      	movs	r2, #20
 8112bc4:	4619      	mov	r1, r3
 8112bc6:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 8112bc8:	f008 fe72 	bl	811b8b0 <memcpy>
    IPH_LEN_SET(fraghdr, lwip_htons(datagram_len));
 8112bcc:	8a3b      	ldrh	r3, [r7, #16]
 8112bce:	4618      	mov	r0, r3
 8112bd0:	f7fb fc5f 	bl	810e492 <lwip_htons>
 8112bd4:	4603      	mov	r3, r0
 8112bd6:	461a      	mov	r2, r3
 8112bd8:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8112bda:	805a      	strh	r2, [r3, #2]
    IPH_OFFSET_SET(fraghdr, 0);
 8112bdc:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8112bde:	2200      	movs	r2, #0
 8112be0:	719a      	strb	r2, [r3, #6]
 8112be2:	2200      	movs	r2, #0
 8112be4:	71da      	strb	r2, [r3, #7]
    IPH_CHKSUM_SET(fraghdr, 0);
 8112be6:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8112be8:	2200      	movs	r2, #0
 8112bea:	729a      	strb	r2, [r3, #10]
 8112bec:	2200      	movs	r2, #0
 8112bee:	72da      	strb	r2, [r3, #11]
    IF__NETIF_CHECKSUM_ENABLED(ip_current_input_netif(), NETIF_CHECKSUM_GEN_IP) {
      IPH_CHKSUM_SET(fraghdr, inet_chksum(fraghdr, IP_HLEN));
    }
#endif /* CHECKSUM_GEN_IP */

    p = ipr->p;
 8112bf0:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8112bf2:	685b      	ldr	r3, [r3, #4]
 8112bf4:	607b      	str	r3, [r7, #4]

    /* chain together the pbufs contained within the reass_data list. */
    while (r != NULL) {
 8112bf6:	e00d      	b.n	8112c14 <ip4_reass+0x234>
      iprh = (struct ip_reass_helper *)r->payload;
 8112bf8:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8112bfa:	685b      	ldr	r3, [r3, #4]
 8112bfc:	60fb      	str	r3, [r7, #12]

      /* hide the ip header for every succeeding fragment */
      pbuf_remove_header(r, IP_HLEN);
 8112bfe:	2114      	movs	r1, #20
 8112c00:	6b78      	ldr	r0, [r7, #52]	; 0x34
 8112c02:	f001 fca3 	bl	811454c <pbuf_remove_header>
      pbuf_cat(p, r);
 8112c06:	6b79      	ldr	r1, [r7, #52]	; 0x34
 8112c08:	6878      	ldr	r0, [r7, #4]
 8112c0a:	f001 fde7 	bl	81147dc <pbuf_cat>
      r = iprh->next_pbuf;
 8112c0e:	68fb      	ldr	r3, [r7, #12]
 8112c10:	681b      	ldr	r3, [r3, #0]
 8112c12:	637b      	str	r3, [r7, #52]	; 0x34
    while (r != NULL) {
 8112c14:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8112c16:	2b00      	cmp	r3, #0
 8112c18:	d1ee      	bne.n	8112bf8 <ip4_reass+0x218>
    }

    /* find the previous entry in the linked list */
    if (ipr == reassdatagrams) {
 8112c1a:	4b1e      	ldr	r3, [pc, #120]	; (8112c94 <ip4_reass+0x2b4>)
 8112c1c:	681b      	ldr	r3, [r3, #0]
 8112c1e:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 8112c20:	429a      	cmp	r2, r3
 8112c22:	d102      	bne.n	8112c2a <ip4_reass+0x24a>
      ipr_prev = NULL;
 8112c24:	2300      	movs	r3, #0
 8112c26:	62fb      	str	r3, [r7, #44]	; 0x2c
 8112c28:	e010      	b.n	8112c4c <ip4_reass+0x26c>
    } else {
      for (ipr_prev = reassdatagrams; ipr_prev != NULL; ipr_prev = ipr_prev->next) {
 8112c2a:	4b1a      	ldr	r3, [pc, #104]	; (8112c94 <ip4_reass+0x2b4>)
 8112c2c:	681b      	ldr	r3, [r3, #0]
 8112c2e:	62fb      	str	r3, [r7, #44]	; 0x2c
 8112c30:	e007      	b.n	8112c42 <ip4_reass+0x262>
        if (ipr_prev->next == ipr) {
 8112c32:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8112c34:	681b      	ldr	r3, [r3, #0]
 8112c36:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 8112c38:	429a      	cmp	r2, r3
 8112c3a:	d006      	beq.n	8112c4a <ip4_reass+0x26a>
      for (ipr_prev = reassdatagrams; ipr_prev != NULL; ipr_prev = ipr_prev->next) {
 8112c3c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8112c3e:	681b      	ldr	r3, [r3, #0]
 8112c40:	62fb      	str	r3, [r7, #44]	; 0x2c
 8112c42:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8112c44:	2b00      	cmp	r3, #0
 8112c46:	d1f4      	bne.n	8112c32 <ip4_reass+0x252>
 8112c48:	e000      	b.n	8112c4c <ip4_reass+0x26c>
          break;
 8112c4a:	bf00      	nop
        }
      }
    }

    /* release the sources allocate for the fragment queue entry */
    ip_reass_dequeue_datagram(ipr, ipr_prev);
 8112c4c:	6af9      	ldr	r1, [r7, #44]	; 0x2c
 8112c4e:	6b38      	ldr	r0, [r7, #48]	; 0x30
 8112c50:	f7ff fd2e 	bl	81126b0 <ip_reass_dequeue_datagram>

    /* and adjust the number of pbufs currently queued for reassembly. */
    clen = pbuf_clen(p);
 8112c54:	6878      	ldr	r0, [r7, #4]
 8112c56:	f001 fd87 	bl	8114768 <pbuf_clen>
 8112c5a:	4603      	mov	r3, r0
 8112c5c:	843b      	strh	r3, [r7, #32]
    LWIP_ASSERT("ip_reass_pbufcount >= clen", ip_reass_pbufcount >= clen);
 8112c5e:	4b0c      	ldr	r3, [pc, #48]	; (8112c90 <ip4_reass+0x2b0>)
 8112c60:	881b      	ldrh	r3, [r3, #0]
 8112c62:	8c3a      	ldrh	r2, [r7, #32]
 8112c64:	429a      	cmp	r2, r3
 8112c66:	d906      	bls.n	8112c76 <ip4_reass+0x296>
 8112c68:	4b0b      	ldr	r3, [pc, #44]	; (8112c98 <ip4_reass+0x2b8>)
 8112c6a:	f240 229b 	movw	r2, #667	; 0x29b
 8112c6e:	490b      	ldr	r1, [pc, #44]	; (8112c9c <ip4_reass+0x2bc>)
 8112c70:	480b      	ldr	r0, [pc, #44]	; (8112ca0 <ip4_reass+0x2c0>)
 8112c72:	f008 fdc5 	bl	811b800 <iprintf>
    ip_reass_pbufcount = (u16_t)(ip_reass_pbufcount - clen);
 8112c76:	4b06      	ldr	r3, [pc, #24]	; (8112c90 <ip4_reass+0x2b0>)
 8112c78:	881a      	ldrh	r2, [r3, #0]
 8112c7a:	8c3b      	ldrh	r3, [r7, #32]
 8112c7c:	1ad3      	subs	r3, r2, r3
 8112c7e:	b29a      	uxth	r2, r3
 8112c80:	4b03      	ldr	r3, [pc, #12]	; (8112c90 <ip4_reass+0x2b0>)
 8112c82:	801a      	strh	r2, [r3, #0]

    MIB2_STATS_INC(mib2.ipreasmoks);

    /* Return the pbuf chain */
    return p;
 8112c84:	687b      	ldr	r3, [r7, #4]
 8112c86:	e038      	b.n	8112cfa <ip4_reass+0x31a>
  }
  /* the datagram is not (yet?) reassembled completely */
  LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_reass_pbufcount: %d out\n", ip_reass_pbufcount));
  return NULL;
 8112c88:	2300      	movs	r3, #0
 8112c8a:	e036      	b.n	8112cfa <ip4_reass+0x31a>
      goto nullreturn_ipr;
 8112c8c:	bf00      	nop
 8112c8e:	e00a      	b.n	8112ca6 <ip4_reass+0x2c6>
 8112c90:	10005510 	.word	0x10005510
 8112c94:	1000550c 	.word	0x1000550c
 8112c98:	0811d1ac 	.word	0x0811d1ac
 8112c9c:	0811d34c 	.word	0x0811d34c
 8112ca0:	0811d224 	.word	0x0811d224
    goto nullreturn_ipr;
 8112ca4:	bf00      	nop

nullreturn_ipr:
  LWIP_ASSERT("ipr != NULL", ipr != NULL);
 8112ca6:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8112ca8:	2b00      	cmp	r3, #0
 8112caa:	d106      	bne.n	8112cba <ip4_reass+0x2da>
 8112cac:	4b15      	ldr	r3, [pc, #84]	; (8112d04 <ip4_reass+0x324>)
 8112cae:	f44f 722a 	mov.w	r2, #680	; 0x2a8
 8112cb2:	4915      	ldr	r1, [pc, #84]	; (8112d08 <ip4_reass+0x328>)
 8112cb4:	4815      	ldr	r0, [pc, #84]	; (8112d0c <ip4_reass+0x32c>)
 8112cb6:	f008 fda3 	bl	811b800 <iprintf>
  if (ipr->p == NULL) {
 8112cba:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8112cbc:	685b      	ldr	r3, [r3, #4]
 8112cbe:	2b00      	cmp	r3, #0
 8112cc0:	d116      	bne.n	8112cf0 <ip4_reass+0x310>
    /* dropped pbuf after creating a new datagram entry: remove the entry, too */
    LWIP_ASSERT("not firstalthough just enqueued", ipr == reassdatagrams);
 8112cc2:	4b13      	ldr	r3, [pc, #76]	; (8112d10 <ip4_reass+0x330>)
 8112cc4:	681b      	ldr	r3, [r3, #0]
 8112cc6:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 8112cc8:	429a      	cmp	r2, r3
 8112cca:	d006      	beq.n	8112cda <ip4_reass+0x2fa>
 8112ccc:	4b0d      	ldr	r3, [pc, #52]	; (8112d04 <ip4_reass+0x324>)
 8112cce:	f240 22ab 	movw	r2, #683	; 0x2ab
 8112cd2:	4910      	ldr	r1, [pc, #64]	; (8112d14 <ip4_reass+0x334>)
 8112cd4:	480d      	ldr	r0, [pc, #52]	; (8112d0c <ip4_reass+0x32c>)
 8112cd6:	f008 fd93 	bl	811b800 <iprintf>
    ip_reass_dequeue_datagram(ipr, NULL);
 8112cda:	2100      	movs	r1, #0
 8112cdc:	6b38      	ldr	r0, [r7, #48]	; 0x30
 8112cde:	f7ff fce7 	bl	81126b0 <ip_reass_dequeue_datagram>
 8112ce2:	e006      	b.n	8112cf2 <ip4_reass+0x312>
    goto nullreturn;
 8112ce4:	bf00      	nop
 8112ce6:	e004      	b.n	8112cf2 <ip4_reass+0x312>
    goto nullreturn;
 8112ce8:	bf00      	nop
 8112cea:	e002      	b.n	8112cf2 <ip4_reass+0x312>
      goto nullreturn;
 8112cec:	bf00      	nop
 8112cee:	e000      	b.n	8112cf2 <ip4_reass+0x312>
  }

nullreturn:
 8112cf0:	bf00      	nop
  LWIP_DEBUGF(IP_REASS_DEBUG, ("ip4_reass: nullreturn\n"));
  IPFRAG_STATS_INC(ip_frag.drop);
  pbuf_free(p);
 8112cf2:	6878      	ldr	r0, [r7, #4]
 8112cf4:	f001 fcb0 	bl	8114658 <pbuf_free>
  return NULL;
 8112cf8:	2300      	movs	r3, #0
}
 8112cfa:	4618      	mov	r0, r3
 8112cfc:	3738      	adds	r7, #56	; 0x38
 8112cfe:	46bd      	mov	sp, r7
 8112d00:	bd80      	pop	{r7, pc}
 8112d02:	bf00      	nop
 8112d04:	0811d1ac 	.word	0x0811d1ac
 8112d08:	0811d368 	.word	0x0811d368
 8112d0c:	0811d224 	.word	0x0811d224
 8112d10:	1000550c 	.word	0x1000550c
 8112d14:	0811d374 	.word	0x0811d374

08112d18 <ip_frag_alloc_pbuf_custom_ref>:
#if IP_FRAG
#if !LWIP_NETIF_TX_SINGLE_PBUF
/** Allocate a new struct pbuf_custom_ref */
static struct pbuf_custom_ref *
ip_frag_alloc_pbuf_custom_ref(void)
{
 8112d18:	b580      	push	{r7, lr}
 8112d1a:	af00      	add	r7, sp, #0
  return (struct pbuf_custom_ref *)memp_malloc(MEMP_FRAG_PBUF);
 8112d1c:	2005      	movs	r0, #5
 8112d1e:	f000 fdc9 	bl	81138b4 <memp_malloc>
 8112d22:	4603      	mov	r3, r0
}
 8112d24:	4618      	mov	r0, r3
 8112d26:	bd80      	pop	{r7, pc}

08112d28 <ip_frag_free_pbuf_custom_ref>:

/** Free a struct pbuf_custom_ref */
static void
ip_frag_free_pbuf_custom_ref(struct pbuf_custom_ref *p)
{
 8112d28:	b580      	push	{r7, lr}
 8112d2a:	b082      	sub	sp, #8
 8112d2c:	af00      	add	r7, sp, #0
 8112d2e:	6078      	str	r0, [r7, #4]
  LWIP_ASSERT("p != NULL", p != NULL);
 8112d30:	687b      	ldr	r3, [r7, #4]
 8112d32:	2b00      	cmp	r3, #0
 8112d34:	d106      	bne.n	8112d44 <ip_frag_free_pbuf_custom_ref+0x1c>
 8112d36:	4b07      	ldr	r3, [pc, #28]	; (8112d54 <ip_frag_free_pbuf_custom_ref+0x2c>)
 8112d38:	f44f 7231 	mov.w	r2, #708	; 0x2c4
 8112d3c:	4906      	ldr	r1, [pc, #24]	; (8112d58 <ip_frag_free_pbuf_custom_ref+0x30>)
 8112d3e:	4807      	ldr	r0, [pc, #28]	; (8112d5c <ip_frag_free_pbuf_custom_ref+0x34>)
 8112d40:	f008 fd5e 	bl	811b800 <iprintf>
  memp_free(MEMP_FRAG_PBUF, p);
 8112d44:	6879      	ldr	r1, [r7, #4]
 8112d46:	2005      	movs	r0, #5
 8112d48:	f000 fe24 	bl	8113994 <memp_free>
}
 8112d4c:	bf00      	nop
 8112d4e:	3708      	adds	r7, #8
 8112d50:	46bd      	mov	sp, r7
 8112d52:	bd80      	pop	{r7, pc}
 8112d54:	0811d1ac 	.word	0x0811d1ac
 8112d58:	0811d394 	.word	0x0811d394
 8112d5c:	0811d224 	.word	0x0811d224

08112d60 <ipfrag_free_pbuf_custom>:

/** Free-callback function to free a 'struct pbuf_custom_ref', called by
 * pbuf_free. */
static void
ipfrag_free_pbuf_custom(struct pbuf *p)
{
 8112d60:	b580      	push	{r7, lr}
 8112d62:	b084      	sub	sp, #16
 8112d64:	af00      	add	r7, sp, #0
 8112d66:	6078      	str	r0, [r7, #4]
  struct pbuf_custom_ref *pcr = (struct pbuf_custom_ref *)p;
 8112d68:	687b      	ldr	r3, [r7, #4]
 8112d6a:	60fb      	str	r3, [r7, #12]
  LWIP_ASSERT("pcr != NULL", pcr != NULL);
 8112d6c:	68fb      	ldr	r3, [r7, #12]
 8112d6e:	2b00      	cmp	r3, #0
 8112d70:	d106      	bne.n	8112d80 <ipfrag_free_pbuf_custom+0x20>
 8112d72:	4b11      	ldr	r3, [pc, #68]	; (8112db8 <ipfrag_free_pbuf_custom+0x58>)
 8112d74:	f240 22ce 	movw	r2, #718	; 0x2ce
 8112d78:	4910      	ldr	r1, [pc, #64]	; (8112dbc <ipfrag_free_pbuf_custom+0x5c>)
 8112d7a:	4811      	ldr	r0, [pc, #68]	; (8112dc0 <ipfrag_free_pbuf_custom+0x60>)
 8112d7c:	f008 fd40 	bl	811b800 <iprintf>
  LWIP_ASSERT("pcr == p", (void *)pcr == (void *)p);
 8112d80:	68fa      	ldr	r2, [r7, #12]
 8112d82:	687b      	ldr	r3, [r7, #4]
 8112d84:	429a      	cmp	r2, r3
 8112d86:	d006      	beq.n	8112d96 <ipfrag_free_pbuf_custom+0x36>
 8112d88:	4b0b      	ldr	r3, [pc, #44]	; (8112db8 <ipfrag_free_pbuf_custom+0x58>)
 8112d8a:	f240 22cf 	movw	r2, #719	; 0x2cf
 8112d8e:	490d      	ldr	r1, [pc, #52]	; (8112dc4 <ipfrag_free_pbuf_custom+0x64>)
 8112d90:	480b      	ldr	r0, [pc, #44]	; (8112dc0 <ipfrag_free_pbuf_custom+0x60>)
 8112d92:	f008 fd35 	bl	811b800 <iprintf>
  if (pcr->original != NULL) {
 8112d96:	68fb      	ldr	r3, [r7, #12]
 8112d98:	695b      	ldr	r3, [r3, #20]
 8112d9a:	2b00      	cmp	r3, #0
 8112d9c:	d004      	beq.n	8112da8 <ipfrag_free_pbuf_custom+0x48>
    pbuf_free(pcr->original);
 8112d9e:	68fb      	ldr	r3, [r7, #12]
 8112da0:	695b      	ldr	r3, [r3, #20]
 8112da2:	4618      	mov	r0, r3
 8112da4:	f001 fc58 	bl	8114658 <pbuf_free>
  }
  ip_frag_free_pbuf_custom_ref(pcr);
 8112da8:	68f8      	ldr	r0, [r7, #12]
 8112daa:	f7ff ffbd 	bl	8112d28 <ip_frag_free_pbuf_custom_ref>
}
 8112dae:	bf00      	nop
 8112db0:	3710      	adds	r7, #16
 8112db2:	46bd      	mov	sp, r7
 8112db4:	bd80      	pop	{r7, pc}
 8112db6:	bf00      	nop
 8112db8:	0811d1ac 	.word	0x0811d1ac
 8112dbc:	0811d3a0 	.word	0x0811d3a0
 8112dc0:	0811d224 	.word	0x0811d224
 8112dc4:	0811d3ac 	.word	0x0811d3ac

08112dc8 <ip4_frag>:
 *
 * @return ERR_OK if sent successfully, err_t otherwise
 */
err_t
ip4_frag(struct pbuf *p, struct netif *netif, const ip4_addr_t *dest)
{
 8112dc8:	b580      	push	{r7, lr}
 8112dca:	b094      	sub	sp, #80	; 0x50
 8112dcc:	af02      	add	r7, sp, #8
 8112dce:	60f8      	str	r0, [r7, #12]
 8112dd0:	60b9      	str	r1, [r7, #8]
 8112dd2:	607a      	str	r2, [r7, #4]
  struct pbuf *rambuf;
#if !LWIP_NETIF_TX_SINGLE_PBUF
  struct pbuf *newpbuf;
  u16_t newpbuflen = 0;
 8112dd4:	2300      	movs	r3, #0
 8112dd6:	f8a7 3046 	strh.w	r3, [r7, #70]	; 0x46
  u16_t left_to_copy;
#endif
  struct ip_hdr *original_iphdr;
  struct ip_hdr *iphdr;
  const u16_t nfb = (u16_t)((netif->mtu - IP_HLEN) / 8);
 8112dda:	68bb      	ldr	r3, [r7, #8]
 8112ddc:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
 8112dde:	3b14      	subs	r3, #20
 8112de0:	2b00      	cmp	r3, #0
 8112de2:	da00      	bge.n	8112de6 <ip4_frag+0x1e>
 8112de4:	3307      	adds	r3, #7
 8112de6:	10db      	asrs	r3, r3, #3
 8112de8:	877b      	strh	r3, [r7, #58]	; 0x3a
  u16_t left, fragsize;
  u16_t ofo;
  int last;
  u16_t poff = IP_HLEN;
 8112dea:	2314      	movs	r3, #20
 8112dec:	87fb      	strh	r3, [r7, #62]	; 0x3e
  u16_t tmp;
  int mf_set;

  original_iphdr = (struct ip_hdr *)p->payload;
 8112dee:	68fb      	ldr	r3, [r7, #12]
 8112df0:	685b      	ldr	r3, [r3, #4]
 8112df2:	637b      	str	r3, [r7, #52]	; 0x34
  iphdr = original_iphdr;
 8112df4:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8112df6:	633b      	str	r3, [r7, #48]	; 0x30
  if (IPH_HL_BYTES(iphdr) != IP_HLEN) {
 8112df8:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8112dfa:	781b      	ldrb	r3, [r3, #0]
 8112dfc:	f003 030f 	and.w	r3, r3, #15
 8112e00:	b2db      	uxtb	r3, r3
 8112e02:	009b      	lsls	r3, r3, #2
 8112e04:	b2db      	uxtb	r3, r3
 8112e06:	2b14      	cmp	r3, #20
 8112e08:	d002      	beq.n	8112e10 <ip4_frag+0x48>
    /* ip4_frag() does not support IP options */
    return ERR_VAL;
 8112e0a:	f06f 0305 	mvn.w	r3, #5
 8112e0e:	e110      	b.n	8113032 <ip4_frag+0x26a>
  }
  LWIP_ERROR("ip4_frag(): pbuf too short", p->len >= IP_HLEN, return ERR_VAL);
 8112e10:	68fb      	ldr	r3, [r7, #12]
 8112e12:	895b      	ldrh	r3, [r3, #10]
 8112e14:	2b13      	cmp	r3, #19
 8112e16:	d809      	bhi.n	8112e2c <ip4_frag+0x64>
 8112e18:	4b88      	ldr	r3, [pc, #544]	; (811303c <ip4_frag+0x274>)
 8112e1a:	f44f 723f 	mov.w	r2, #764	; 0x2fc
 8112e1e:	4988      	ldr	r1, [pc, #544]	; (8113040 <ip4_frag+0x278>)
 8112e20:	4888      	ldr	r0, [pc, #544]	; (8113044 <ip4_frag+0x27c>)
 8112e22:	f008 fced 	bl	811b800 <iprintf>
 8112e26:	f06f 0305 	mvn.w	r3, #5
 8112e2a:	e102      	b.n	8113032 <ip4_frag+0x26a>

  /* Save original offset */
  tmp = lwip_ntohs(IPH_OFFSET(iphdr));
 8112e2c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8112e2e:	88db      	ldrh	r3, [r3, #6]
 8112e30:	b29b      	uxth	r3, r3
 8112e32:	4618      	mov	r0, r3
 8112e34:	f7fb fb2d 	bl	810e492 <lwip_htons>
 8112e38:	4603      	mov	r3, r0
 8112e3a:	87bb      	strh	r3, [r7, #60]	; 0x3c
  ofo = tmp & IP_OFFMASK;
 8112e3c:	8fbb      	ldrh	r3, [r7, #60]	; 0x3c
 8112e3e:	f3c3 030c 	ubfx	r3, r3, #0, #13
 8112e42:	f8a7 3040 	strh.w	r3, [r7, #64]	; 0x40
  /* already fragmented? if so, the last fragment we create must have MF, too */
  mf_set = tmp & IP_MF;
 8112e46:	8fbb      	ldrh	r3, [r7, #60]	; 0x3c
 8112e48:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
 8112e4c:	62fb      	str	r3, [r7, #44]	; 0x2c

  left = (u16_t)(p->tot_len - IP_HLEN);
 8112e4e:	68fb      	ldr	r3, [r7, #12]
 8112e50:	891b      	ldrh	r3, [r3, #8]
 8112e52:	3b14      	subs	r3, #20
 8112e54:	f8a7 3042 	strh.w	r3, [r7, #66]	; 0x42

  while (left) {
 8112e58:	e0e1      	b.n	811301e <ip4_frag+0x256>
    /* Fill this fragment */
    fragsize = LWIP_MIN(left, (u16_t)(nfb * 8));
 8112e5a:	8f7b      	ldrh	r3, [r7, #58]	; 0x3a
 8112e5c:	00db      	lsls	r3, r3, #3
 8112e5e:	b29b      	uxth	r3, r3
 8112e60:	f8b7 2042 	ldrh.w	r2, [r7, #66]	; 0x42
 8112e64:	4293      	cmp	r3, r2
 8112e66:	bf28      	it	cs
 8112e68:	4613      	movcs	r3, r2
 8112e6a:	857b      	strh	r3, [r7, #42]	; 0x2a
    /* When not using a static buffer, create a chain of pbufs.
     * The first will be a PBUF_RAM holding the link and IP header.
     * The rest will be PBUF_REFs mirroring the pbuf chain to be fragged,
     * but limited to the size of an mtu.
     */
    rambuf = pbuf_alloc(PBUF_LINK, IP_HLEN, PBUF_RAM);
 8112e6c:	f44f 7220 	mov.w	r2, #640	; 0x280
 8112e70:	2114      	movs	r1, #20
 8112e72:	200e      	movs	r0, #14
 8112e74:	f001 f90c 	bl	8114090 <pbuf_alloc>
 8112e78:	6278      	str	r0, [r7, #36]	; 0x24
    if (rambuf == NULL) {
 8112e7a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8112e7c:	2b00      	cmp	r3, #0
 8112e7e:	f000 80d5 	beq.w	811302c <ip4_frag+0x264>
      goto memerr;
    }
    LWIP_ASSERT("this needs a pbuf in one piece!",
 8112e82:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8112e84:	895b      	ldrh	r3, [r3, #10]
 8112e86:	2b13      	cmp	r3, #19
 8112e88:	d806      	bhi.n	8112e98 <ip4_frag+0xd0>
 8112e8a:	4b6c      	ldr	r3, [pc, #432]	; (811303c <ip4_frag+0x274>)
 8112e8c:	f44f 7249 	mov.w	r2, #804	; 0x324
 8112e90:	496d      	ldr	r1, [pc, #436]	; (8113048 <ip4_frag+0x280>)
 8112e92:	486c      	ldr	r0, [pc, #432]	; (8113044 <ip4_frag+0x27c>)
 8112e94:	f008 fcb4 	bl	811b800 <iprintf>
                (rambuf->len >= (IP_HLEN)));
    SMEMCPY(rambuf->payload, original_iphdr, IP_HLEN);
 8112e98:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8112e9a:	685b      	ldr	r3, [r3, #4]
 8112e9c:	2214      	movs	r2, #20
 8112e9e:	6b79      	ldr	r1, [r7, #52]	; 0x34
 8112ea0:	4618      	mov	r0, r3
 8112ea2:	f008 fd05 	bl	811b8b0 <memcpy>
    iphdr = (struct ip_hdr *)rambuf->payload;
 8112ea6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8112ea8:	685b      	ldr	r3, [r3, #4]
 8112eaa:	633b      	str	r3, [r7, #48]	; 0x30

    left_to_copy = fragsize;
 8112eac:	8d7b      	ldrh	r3, [r7, #42]	; 0x2a
 8112eae:	f8a7 3044 	strh.w	r3, [r7, #68]	; 0x44
    while (left_to_copy) {
 8112eb2:	e064      	b.n	8112f7e <ip4_frag+0x1b6>
      struct pbuf_custom_ref *pcr;
      u16_t plen = (u16_t)(p->len - poff);
 8112eb4:	68fb      	ldr	r3, [r7, #12]
 8112eb6:	895a      	ldrh	r2, [r3, #10]
 8112eb8:	8ffb      	ldrh	r3, [r7, #62]	; 0x3e
 8112eba:	1ad3      	subs	r3, r2, r3
 8112ebc:	83fb      	strh	r3, [r7, #30]
      LWIP_ASSERT("p->len >= poff", p->len >= poff);
 8112ebe:	68fb      	ldr	r3, [r7, #12]
 8112ec0:	895b      	ldrh	r3, [r3, #10]
 8112ec2:	8ffa      	ldrh	r2, [r7, #62]	; 0x3e
 8112ec4:	429a      	cmp	r2, r3
 8112ec6:	d906      	bls.n	8112ed6 <ip4_frag+0x10e>
 8112ec8:	4b5c      	ldr	r3, [pc, #368]	; (811303c <ip4_frag+0x274>)
 8112eca:	f240 322d 	movw	r2, #813	; 0x32d
 8112ece:	495f      	ldr	r1, [pc, #380]	; (811304c <ip4_frag+0x284>)
 8112ed0:	485c      	ldr	r0, [pc, #368]	; (8113044 <ip4_frag+0x27c>)
 8112ed2:	f008 fc95 	bl	811b800 <iprintf>
      newpbuflen = LWIP_MIN(left_to_copy, plen);
 8112ed6:	8bfa      	ldrh	r2, [r7, #30]
 8112ed8:	f8b7 3044 	ldrh.w	r3, [r7, #68]	; 0x44
 8112edc:	4293      	cmp	r3, r2
 8112ede:	bf28      	it	cs
 8112ee0:	4613      	movcs	r3, r2
 8112ee2:	f8a7 3046 	strh.w	r3, [r7, #70]	; 0x46
      /* Is this pbuf already empty? */
      if (!newpbuflen) {
 8112ee6:	f8b7 3046 	ldrh.w	r3, [r7, #70]	; 0x46
 8112eea:	2b00      	cmp	r3, #0
 8112eec:	d105      	bne.n	8112efa <ip4_frag+0x132>
        poff = 0;
 8112eee:	2300      	movs	r3, #0
 8112ef0:	87fb      	strh	r3, [r7, #62]	; 0x3e
        p = p->next;
 8112ef2:	68fb      	ldr	r3, [r7, #12]
 8112ef4:	681b      	ldr	r3, [r3, #0]
 8112ef6:	60fb      	str	r3, [r7, #12]
        continue;
 8112ef8:	e041      	b.n	8112f7e <ip4_frag+0x1b6>
      }
      pcr = ip_frag_alloc_pbuf_custom_ref();
 8112efa:	f7ff ff0d 	bl	8112d18 <ip_frag_alloc_pbuf_custom_ref>
 8112efe:	61b8      	str	r0, [r7, #24]
      if (pcr == NULL) {
 8112f00:	69bb      	ldr	r3, [r7, #24]
 8112f02:	2b00      	cmp	r3, #0
 8112f04:	d103      	bne.n	8112f0e <ip4_frag+0x146>
        pbuf_free(rambuf);
 8112f06:	6a78      	ldr	r0, [r7, #36]	; 0x24
 8112f08:	f001 fba6 	bl	8114658 <pbuf_free>
        goto memerr;
 8112f0c:	e08f      	b.n	811302e <ip4_frag+0x266>
      }
      /* Mirror this pbuf, although we might not need all of it. */
      newpbuf = pbuf_alloced_custom(PBUF_RAW, newpbuflen, PBUF_REF, &pcr->pc,
 8112f0e:	69b8      	ldr	r0, [r7, #24]
                                    (u8_t *)p->payload + poff, newpbuflen);
 8112f10:	68fb      	ldr	r3, [r7, #12]
 8112f12:	685a      	ldr	r2, [r3, #4]
      newpbuf = pbuf_alloced_custom(PBUF_RAW, newpbuflen, PBUF_REF, &pcr->pc,
 8112f14:	8ffb      	ldrh	r3, [r7, #62]	; 0x3e
 8112f16:	4413      	add	r3, r2
 8112f18:	f8b7 1046 	ldrh.w	r1, [r7, #70]	; 0x46
 8112f1c:	f8b7 2046 	ldrh.w	r2, [r7, #70]	; 0x46
 8112f20:	9201      	str	r2, [sp, #4]
 8112f22:	9300      	str	r3, [sp, #0]
 8112f24:	4603      	mov	r3, r0
 8112f26:	2241      	movs	r2, #65	; 0x41
 8112f28:	2000      	movs	r0, #0
 8112f2a:	f001 f9db 	bl	81142e4 <pbuf_alloced_custom>
 8112f2e:	6178      	str	r0, [r7, #20]
      if (newpbuf == NULL) {
 8112f30:	697b      	ldr	r3, [r7, #20]
 8112f32:	2b00      	cmp	r3, #0
 8112f34:	d106      	bne.n	8112f44 <ip4_frag+0x17c>
        ip_frag_free_pbuf_custom_ref(pcr);
 8112f36:	69b8      	ldr	r0, [r7, #24]
 8112f38:	f7ff fef6 	bl	8112d28 <ip_frag_free_pbuf_custom_ref>
        pbuf_free(rambuf);
 8112f3c:	6a78      	ldr	r0, [r7, #36]	; 0x24
 8112f3e:	f001 fb8b 	bl	8114658 <pbuf_free>
        goto memerr;
 8112f42:	e074      	b.n	811302e <ip4_frag+0x266>
      }
      pbuf_ref(p);
 8112f44:	68f8      	ldr	r0, [r7, #12]
 8112f46:	f001 fc27 	bl	8114798 <pbuf_ref>
      pcr->original = p;
 8112f4a:	69bb      	ldr	r3, [r7, #24]
 8112f4c:	68fa      	ldr	r2, [r7, #12]
 8112f4e:	615a      	str	r2, [r3, #20]
      pcr->pc.custom_free_function = ipfrag_free_pbuf_custom;
 8112f50:	69bb      	ldr	r3, [r7, #24]
 8112f52:	4a3f      	ldr	r2, [pc, #252]	; (8113050 <ip4_frag+0x288>)
 8112f54:	611a      	str	r2, [r3, #16]

      /* Add it to end of rambuf's chain, but using pbuf_cat, not pbuf_chain
       * so that it is removed when pbuf_dechain is later called on rambuf.
       */
      pbuf_cat(rambuf, newpbuf);
 8112f56:	6979      	ldr	r1, [r7, #20]
 8112f58:	6a78      	ldr	r0, [r7, #36]	; 0x24
 8112f5a:	f001 fc3f 	bl	81147dc <pbuf_cat>
      left_to_copy = (u16_t)(left_to_copy - newpbuflen);
 8112f5e:	f8b7 2044 	ldrh.w	r2, [r7, #68]	; 0x44
 8112f62:	f8b7 3046 	ldrh.w	r3, [r7, #70]	; 0x46
 8112f66:	1ad3      	subs	r3, r2, r3
 8112f68:	f8a7 3044 	strh.w	r3, [r7, #68]	; 0x44
      if (left_to_copy) {
 8112f6c:	f8b7 3044 	ldrh.w	r3, [r7, #68]	; 0x44
 8112f70:	2b00      	cmp	r3, #0
 8112f72:	d004      	beq.n	8112f7e <ip4_frag+0x1b6>
        poff = 0;
 8112f74:	2300      	movs	r3, #0
 8112f76:	87fb      	strh	r3, [r7, #62]	; 0x3e
        p = p->next;
 8112f78:	68fb      	ldr	r3, [r7, #12]
 8112f7a:	681b      	ldr	r3, [r3, #0]
 8112f7c:	60fb      	str	r3, [r7, #12]
    while (left_to_copy) {
 8112f7e:	f8b7 3044 	ldrh.w	r3, [r7, #68]	; 0x44
 8112f82:	2b00      	cmp	r3, #0
 8112f84:	d196      	bne.n	8112eb4 <ip4_frag+0xec>
      }
    }
    poff = (u16_t)(poff + newpbuflen);
 8112f86:	8ffa      	ldrh	r2, [r7, #62]	; 0x3e
 8112f88:	f8b7 3046 	ldrh.w	r3, [r7, #70]	; 0x46
 8112f8c:	4413      	add	r3, r2
 8112f8e:	87fb      	strh	r3, [r7, #62]	; 0x3e
#endif /* LWIP_NETIF_TX_SINGLE_PBUF */

    /* Correct header */
    last = (left <= netif->mtu - IP_HLEN);
 8112f90:	68bb      	ldr	r3, [r7, #8]
 8112f92:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
 8112f94:	f1a3 0213 	sub.w	r2, r3, #19
 8112f98:	f8b7 3042 	ldrh.w	r3, [r7, #66]	; 0x42
 8112f9c:	429a      	cmp	r2, r3
 8112f9e:	bfcc      	ite	gt
 8112fa0:	2301      	movgt	r3, #1
 8112fa2:	2300      	movle	r3, #0
 8112fa4:	b2db      	uxtb	r3, r3
 8112fa6:	623b      	str	r3, [r7, #32]

    /* Set new offset and MF flag */
    tmp = (IP_OFFMASK & (ofo));
 8112fa8:	f8b7 3040 	ldrh.w	r3, [r7, #64]	; 0x40
 8112fac:	f3c3 030c 	ubfx	r3, r3, #0, #13
 8112fb0:	87bb      	strh	r3, [r7, #60]	; 0x3c
    if (!last || mf_set) {
 8112fb2:	6a3b      	ldr	r3, [r7, #32]
 8112fb4:	2b00      	cmp	r3, #0
 8112fb6:	d002      	beq.n	8112fbe <ip4_frag+0x1f6>
 8112fb8:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8112fba:	2b00      	cmp	r3, #0
 8112fbc:	d003      	beq.n	8112fc6 <ip4_frag+0x1fe>
      /* the last fragment has MF set if the input frame had it */
      tmp = tmp | IP_MF;
 8112fbe:	8fbb      	ldrh	r3, [r7, #60]	; 0x3c
 8112fc0:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 8112fc4:	87bb      	strh	r3, [r7, #60]	; 0x3c
    }
    IPH_OFFSET_SET(iphdr, lwip_htons(tmp));
 8112fc6:	8fbb      	ldrh	r3, [r7, #60]	; 0x3c
 8112fc8:	4618      	mov	r0, r3
 8112fca:	f7fb fa62 	bl	810e492 <lwip_htons>
 8112fce:	4603      	mov	r3, r0
 8112fd0:	461a      	mov	r2, r3
 8112fd2:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8112fd4:	80da      	strh	r2, [r3, #6]
    IPH_LEN_SET(iphdr, lwip_htons((u16_t)(fragsize + IP_HLEN)));
 8112fd6:	8d7b      	ldrh	r3, [r7, #42]	; 0x2a
 8112fd8:	3314      	adds	r3, #20
 8112fda:	b29b      	uxth	r3, r3
 8112fdc:	4618      	mov	r0, r3
 8112fde:	f7fb fa58 	bl	810e492 <lwip_htons>
 8112fe2:	4603      	mov	r3, r0
 8112fe4:	461a      	mov	r2, r3
 8112fe6:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8112fe8:	805a      	strh	r2, [r3, #2]
    IPH_CHKSUM_SET(iphdr, 0);
 8112fea:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8112fec:	2200      	movs	r2, #0
 8112fee:	729a      	strb	r2, [r3, #10]
 8112ff0:	2200      	movs	r2, #0
 8112ff2:	72da      	strb	r2, [r3, #11]
#endif /* CHECKSUM_GEN_IP */

    /* No need for separate header pbuf - we allowed room for it in rambuf
     * when allocated.
     */
    netif->output(netif, rambuf, dest);
 8112ff4:	68bb      	ldr	r3, [r7, #8]
 8112ff6:	695b      	ldr	r3, [r3, #20]
 8112ff8:	687a      	ldr	r2, [r7, #4]
 8112ffa:	6a79      	ldr	r1, [r7, #36]	; 0x24
 8112ffc:	68b8      	ldr	r0, [r7, #8]
 8112ffe:	4798      	blx	r3
     * recreate it next time round the loop. If we're lucky the hardware
     * will have already sent the packet, the free will really free, and
     * there will be zero memory penalty.
     */

    pbuf_free(rambuf);
 8113000:	6a78      	ldr	r0, [r7, #36]	; 0x24
 8113002:	f001 fb29 	bl	8114658 <pbuf_free>
    left = (u16_t)(left - fragsize);
 8113006:	f8b7 2042 	ldrh.w	r2, [r7, #66]	; 0x42
 811300a:	8d7b      	ldrh	r3, [r7, #42]	; 0x2a
 811300c:	1ad3      	subs	r3, r2, r3
 811300e:	f8a7 3042 	strh.w	r3, [r7, #66]	; 0x42
    ofo = (u16_t)(ofo + nfb);
 8113012:	f8b7 2040 	ldrh.w	r2, [r7, #64]	; 0x40
 8113016:	8f7b      	ldrh	r3, [r7, #58]	; 0x3a
 8113018:	4413      	add	r3, r2
 811301a:	f8a7 3040 	strh.w	r3, [r7, #64]	; 0x40
  while (left) {
 811301e:	f8b7 3042 	ldrh.w	r3, [r7, #66]	; 0x42
 8113022:	2b00      	cmp	r3, #0
 8113024:	f47f af19 	bne.w	8112e5a <ip4_frag+0x92>
  }
  MIB2_STATS_INC(mib2.ipfragoks);
  return ERR_OK;
 8113028:	2300      	movs	r3, #0
 811302a:	e002      	b.n	8113032 <ip4_frag+0x26a>
      goto memerr;
 811302c:	bf00      	nop
memerr:
  MIB2_STATS_INC(mib2.ipfragfails);
  return ERR_MEM;
 811302e:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
}
 8113032:	4618      	mov	r0, r3
 8113034:	3748      	adds	r7, #72	; 0x48
 8113036:	46bd      	mov	sp, r7
 8113038:	bd80      	pop	{r7, pc}
 811303a:	bf00      	nop
 811303c:	0811d1ac 	.word	0x0811d1ac
 8113040:	0811d3b8 	.word	0x0811d3b8
 8113044:	0811d224 	.word	0x0811d224
 8113048:	0811d3d4 	.word	0x0811d3d4
 811304c:	0811d3f4 	.word	0x0811d3f4
 8113050:	08112d61 	.word	0x08112d61

08113054 <ptr_to_mem>:
#define mem_overflow_check_element(mem)
#endif /* MEM_OVERFLOW_CHECK */

static struct mem *
ptr_to_mem(mem_size_t ptr)
{
 8113054:	b480      	push	{r7}
 8113056:	b083      	sub	sp, #12
 8113058:	af00      	add	r7, sp, #0
 811305a:	4603      	mov	r3, r0
 811305c:	80fb      	strh	r3, [r7, #6]
  return (struct mem *)(void *)&ram[ptr];
 811305e:	4b05      	ldr	r3, [pc, #20]	; (8113074 <ptr_to_mem+0x20>)
 8113060:	681a      	ldr	r2, [r3, #0]
 8113062:	88fb      	ldrh	r3, [r7, #6]
 8113064:	4413      	add	r3, r2
}
 8113066:	4618      	mov	r0, r3
 8113068:	370c      	adds	r7, #12
 811306a:	46bd      	mov	sp, r7
 811306c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8113070:	4770      	bx	lr
 8113072:	bf00      	nop
 8113074:	10005514 	.word	0x10005514

08113078 <mem_to_ptr>:

static mem_size_t
mem_to_ptr(void *mem)
{
 8113078:	b480      	push	{r7}
 811307a:	b083      	sub	sp, #12
 811307c:	af00      	add	r7, sp, #0
 811307e:	6078      	str	r0, [r7, #4]
  return (mem_size_t)((u8_t *)mem - ram);
 8113080:	4b05      	ldr	r3, [pc, #20]	; (8113098 <mem_to_ptr+0x20>)
 8113082:	681b      	ldr	r3, [r3, #0]
 8113084:	687a      	ldr	r2, [r7, #4]
 8113086:	1ad3      	subs	r3, r2, r3
 8113088:	b29b      	uxth	r3, r3
}
 811308a:	4618      	mov	r0, r3
 811308c:	370c      	adds	r7, #12
 811308e:	46bd      	mov	sp, r7
 8113090:	f85d 7b04 	ldr.w	r7, [sp], #4
 8113094:	4770      	bx	lr
 8113096:	bf00      	nop
 8113098:	10005514 	.word	0x10005514

0811309c <plug_holes>:
 * This assumes access to the heap is protected by the calling function
 * already.
 */
static void
plug_holes(struct mem *mem)
{
 811309c:	b590      	push	{r4, r7, lr}
 811309e:	b085      	sub	sp, #20
 81130a0:	af00      	add	r7, sp, #0
 81130a2:	6078      	str	r0, [r7, #4]
  struct mem *nmem;
  struct mem *pmem;

  LWIP_ASSERT("plug_holes: mem >= ram", (u8_t *)mem >= ram);
 81130a4:	4b45      	ldr	r3, [pc, #276]	; (81131bc <plug_holes+0x120>)
 81130a6:	681b      	ldr	r3, [r3, #0]
 81130a8:	687a      	ldr	r2, [r7, #4]
 81130aa:	429a      	cmp	r2, r3
 81130ac:	d206      	bcs.n	81130bc <plug_holes+0x20>
 81130ae:	4b44      	ldr	r3, [pc, #272]	; (81131c0 <plug_holes+0x124>)
 81130b0:	f240 12df 	movw	r2, #479	; 0x1df
 81130b4:	4943      	ldr	r1, [pc, #268]	; (81131c4 <plug_holes+0x128>)
 81130b6:	4844      	ldr	r0, [pc, #272]	; (81131c8 <plug_holes+0x12c>)
 81130b8:	f008 fba2 	bl	811b800 <iprintf>
  LWIP_ASSERT("plug_holes: mem < ram_end", (u8_t *)mem < (u8_t *)ram_end);
 81130bc:	4b43      	ldr	r3, [pc, #268]	; (81131cc <plug_holes+0x130>)
 81130be:	681b      	ldr	r3, [r3, #0]
 81130c0:	687a      	ldr	r2, [r7, #4]
 81130c2:	429a      	cmp	r2, r3
 81130c4:	d306      	bcc.n	81130d4 <plug_holes+0x38>
 81130c6:	4b3e      	ldr	r3, [pc, #248]	; (81131c0 <plug_holes+0x124>)
 81130c8:	f44f 72f0 	mov.w	r2, #480	; 0x1e0
 81130cc:	4940      	ldr	r1, [pc, #256]	; (81131d0 <plug_holes+0x134>)
 81130ce:	483e      	ldr	r0, [pc, #248]	; (81131c8 <plug_holes+0x12c>)
 81130d0:	f008 fb96 	bl	811b800 <iprintf>
  LWIP_ASSERT("plug_holes: mem->used == 0", mem->used == 0);
 81130d4:	687b      	ldr	r3, [r7, #4]
 81130d6:	791b      	ldrb	r3, [r3, #4]
 81130d8:	2b00      	cmp	r3, #0
 81130da:	d006      	beq.n	81130ea <plug_holes+0x4e>
 81130dc:	4b38      	ldr	r3, [pc, #224]	; (81131c0 <plug_holes+0x124>)
 81130de:	f240 12e1 	movw	r2, #481	; 0x1e1
 81130e2:	493c      	ldr	r1, [pc, #240]	; (81131d4 <plug_holes+0x138>)
 81130e4:	4838      	ldr	r0, [pc, #224]	; (81131c8 <plug_holes+0x12c>)
 81130e6:	f008 fb8b 	bl	811b800 <iprintf>

  /* plug hole forward */
  LWIP_ASSERT("plug_holes: mem->next <= MEM_SIZE_ALIGNED", mem->next <= MEM_SIZE_ALIGNED);
 81130ea:	687b      	ldr	r3, [r7, #4]
 81130ec:	881b      	ldrh	r3, [r3, #0]
 81130ee:	f5b3 6fc8 	cmp.w	r3, #1600	; 0x640
 81130f2:	d906      	bls.n	8113102 <plug_holes+0x66>
 81130f4:	4b32      	ldr	r3, [pc, #200]	; (81131c0 <plug_holes+0x124>)
 81130f6:	f44f 72f2 	mov.w	r2, #484	; 0x1e4
 81130fa:	4937      	ldr	r1, [pc, #220]	; (81131d8 <plug_holes+0x13c>)
 81130fc:	4832      	ldr	r0, [pc, #200]	; (81131c8 <plug_holes+0x12c>)
 81130fe:	f008 fb7f 	bl	811b800 <iprintf>

  nmem = ptr_to_mem(mem->next);
 8113102:	687b      	ldr	r3, [r7, #4]
 8113104:	881b      	ldrh	r3, [r3, #0]
 8113106:	4618      	mov	r0, r3
 8113108:	f7ff ffa4 	bl	8113054 <ptr_to_mem>
 811310c:	60f8      	str	r0, [r7, #12]
  if (mem != nmem && nmem->used == 0 && (u8_t *)nmem != (u8_t *)ram_end) {
 811310e:	687a      	ldr	r2, [r7, #4]
 8113110:	68fb      	ldr	r3, [r7, #12]
 8113112:	429a      	cmp	r2, r3
 8113114:	d024      	beq.n	8113160 <plug_holes+0xc4>
 8113116:	68fb      	ldr	r3, [r7, #12]
 8113118:	791b      	ldrb	r3, [r3, #4]
 811311a:	2b00      	cmp	r3, #0
 811311c:	d120      	bne.n	8113160 <plug_holes+0xc4>
 811311e:	4b2b      	ldr	r3, [pc, #172]	; (81131cc <plug_holes+0x130>)
 8113120:	681b      	ldr	r3, [r3, #0]
 8113122:	68fa      	ldr	r2, [r7, #12]
 8113124:	429a      	cmp	r2, r3
 8113126:	d01b      	beq.n	8113160 <plug_holes+0xc4>
    /* if mem->next is unused and not end of ram, combine mem and mem->next */
    if (lfree == nmem) {
 8113128:	4b2c      	ldr	r3, [pc, #176]	; (81131dc <plug_holes+0x140>)
 811312a:	681b      	ldr	r3, [r3, #0]
 811312c:	68fa      	ldr	r2, [r7, #12]
 811312e:	429a      	cmp	r2, r3
 8113130:	d102      	bne.n	8113138 <plug_holes+0x9c>
      lfree = mem;
 8113132:	4a2a      	ldr	r2, [pc, #168]	; (81131dc <plug_holes+0x140>)
 8113134:	687b      	ldr	r3, [r7, #4]
 8113136:	6013      	str	r3, [r2, #0]
    }
    mem->next = nmem->next;
 8113138:	68fb      	ldr	r3, [r7, #12]
 811313a:	881a      	ldrh	r2, [r3, #0]
 811313c:	687b      	ldr	r3, [r7, #4]
 811313e:	801a      	strh	r2, [r3, #0]
    if (nmem->next != MEM_SIZE_ALIGNED) {
 8113140:	68fb      	ldr	r3, [r7, #12]
 8113142:	881b      	ldrh	r3, [r3, #0]
 8113144:	f5b3 6fc8 	cmp.w	r3, #1600	; 0x640
 8113148:	d00a      	beq.n	8113160 <plug_holes+0xc4>
      ptr_to_mem(nmem->next)->prev = mem_to_ptr(mem);
 811314a:	68fb      	ldr	r3, [r7, #12]
 811314c:	881b      	ldrh	r3, [r3, #0]
 811314e:	4618      	mov	r0, r3
 8113150:	f7ff ff80 	bl	8113054 <ptr_to_mem>
 8113154:	4604      	mov	r4, r0
 8113156:	6878      	ldr	r0, [r7, #4]
 8113158:	f7ff ff8e 	bl	8113078 <mem_to_ptr>
 811315c:	4603      	mov	r3, r0
 811315e:	8063      	strh	r3, [r4, #2]
    }
  }

  /* plug hole backward */
  pmem = ptr_to_mem(mem->prev);
 8113160:	687b      	ldr	r3, [r7, #4]
 8113162:	885b      	ldrh	r3, [r3, #2]
 8113164:	4618      	mov	r0, r3
 8113166:	f7ff ff75 	bl	8113054 <ptr_to_mem>
 811316a:	60b8      	str	r0, [r7, #8]
  if (pmem != mem && pmem->used == 0) {
 811316c:	68ba      	ldr	r2, [r7, #8]
 811316e:	687b      	ldr	r3, [r7, #4]
 8113170:	429a      	cmp	r2, r3
 8113172:	d01f      	beq.n	81131b4 <plug_holes+0x118>
 8113174:	68bb      	ldr	r3, [r7, #8]
 8113176:	791b      	ldrb	r3, [r3, #4]
 8113178:	2b00      	cmp	r3, #0
 811317a:	d11b      	bne.n	81131b4 <plug_holes+0x118>
    /* if mem->prev is unused, combine mem and mem->prev */
    if (lfree == mem) {
 811317c:	4b17      	ldr	r3, [pc, #92]	; (81131dc <plug_holes+0x140>)
 811317e:	681b      	ldr	r3, [r3, #0]
 8113180:	687a      	ldr	r2, [r7, #4]
 8113182:	429a      	cmp	r2, r3
 8113184:	d102      	bne.n	811318c <plug_holes+0xf0>
      lfree = pmem;
 8113186:	4a15      	ldr	r2, [pc, #84]	; (81131dc <plug_holes+0x140>)
 8113188:	68bb      	ldr	r3, [r7, #8]
 811318a:	6013      	str	r3, [r2, #0]
    }
    pmem->next = mem->next;
 811318c:	687b      	ldr	r3, [r7, #4]
 811318e:	881a      	ldrh	r2, [r3, #0]
 8113190:	68bb      	ldr	r3, [r7, #8]
 8113192:	801a      	strh	r2, [r3, #0]
    if (mem->next != MEM_SIZE_ALIGNED) {
 8113194:	687b      	ldr	r3, [r7, #4]
 8113196:	881b      	ldrh	r3, [r3, #0]
 8113198:	f5b3 6fc8 	cmp.w	r3, #1600	; 0x640
 811319c:	d00a      	beq.n	81131b4 <plug_holes+0x118>
      ptr_to_mem(mem->next)->prev = mem_to_ptr(pmem);
 811319e:	687b      	ldr	r3, [r7, #4]
 81131a0:	881b      	ldrh	r3, [r3, #0]
 81131a2:	4618      	mov	r0, r3
 81131a4:	f7ff ff56 	bl	8113054 <ptr_to_mem>
 81131a8:	4604      	mov	r4, r0
 81131aa:	68b8      	ldr	r0, [r7, #8]
 81131ac:	f7ff ff64 	bl	8113078 <mem_to_ptr>
 81131b0:	4603      	mov	r3, r0
 81131b2:	8063      	strh	r3, [r4, #2]
    }
  }
}
 81131b4:	bf00      	nop
 81131b6:	3714      	adds	r7, #20
 81131b8:	46bd      	mov	sp, r7
 81131ba:	bd90      	pop	{r4, r7, pc}
 81131bc:	10005514 	.word	0x10005514
 81131c0:	0811d404 	.word	0x0811d404
 81131c4:	0811d468 	.word	0x0811d468
 81131c8:	0811d480 	.word	0x0811d480
 81131cc:	10005518 	.word	0x10005518
 81131d0:	0811d4a8 	.word	0x0811d4a8
 81131d4:	0811d4c4 	.word	0x0811d4c4
 81131d8:	0811d4e0 	.word	0x0811d4e0
 81131dc:	1000551c 	.word	0x1000551c

081131e0 <mem_init>:
/**
 * Zero the heap and initialize start, end and lowest-free
 */
void
mem_init(void)
{
 81131e0:	b580      	push	{r7, lr}
 81131e2:	b082      	sub	sp, #8
 81131e4:	af00      	add	r7, sp, #0

  LWIP_ASSERT("Sanity check alignment",
              (SIZEOF_STRUCT_MEM & (MEM_ALIGNMENT - 1)) == 0);

  /* align the heap */
  ram = (u8_t *)LWIP_MEM_ALIGN(LWIP_RAM_HEAP_POINTER);
 81131e6:	4b16      	ldr	r3, [pc, #88]	; (8113240 <mem_init+0x60>)
 81131e8:	4a16      	ldr	r2, [pc, #88]	; (8113244 <mem_init+0x64>)
 81131ea:	601a      	str	r2, [r3, #0]
  /* initialize the start of the heap */
  mem = (struct mem *)(void *)ram;
 81131ec:	4b14      	ldr	r3, [pc, #80]	; (8113240 <mem_init+0x60>)
 81131ee:	681b      	ldr	r3, [r3, #0]
 81131f0:	607b      	str	r3, [r7, #4]
  mem->next = MEM_SIZE_ALIGNED;
 81131f2:	687b      	ldr	r3, [r7, #4]
 81131f4:	f44f 62c8 	mov.w	r2, #1600	; 0x640
 81131f8:	801a      	strh	r2, [r3, #0]
  mem->prev = 0;
 81131fa:	687b      	ldr	r3, [r7, #4]
 81131fc:	2200      	movs	r2, #0
 81131fe:	805a      	strh	r2, [r3, #2]
  mem->used = 0;
 8113200:	687b      	ldr	r3, [r7, #4]
 8113202:	2200      	movs	r2, #0
 8113204:	711a      	strb	r2, [r3, #4]
  /* initialize the end of the heap */
  ram_end = ptr_to_mem(MEM_SIZE_ALIGNED);
 8113206:	f44f 60c8 	mov.w	r0, #1600	; 0x640
 811320a:	f7ff ff23 	bl	8113054 <ptr_to_mem>
 811320e:	4603      	mov	r3, r0
 8113210:	4a0d      	ldr	r2, [pc, #52]	; (8113248 <mem_init+0x68>)
 8113212:	6013      	str	r3, [r2, #0]
  ram_end->used = 1;
 8113214:	4b0c      	ldr	r3, [pc, #48]	; (8113248 <mem_init+0x68>)
 8113216:	681b      	ldr	r3, [r3, #0]
 8113218:	2201      	movs	r2, #1
 811321a:	711a      	strb	r2, [r3, #4]
  ram_end->next = MEM_SIZE_ALIGNED;
 811321c:	4b0a      	ldr	r3, [pc, #40]	; (8113248 <mem_init+0x68>)
 811321e:	681b      	ldr	r3, [r3, #0]
 8113220:	f44f 62c8 	mov.w	r2, #1600	; 0x640
 8113224:	801a      	strh	r2, [r3, #0]
  ram_end->prev = MEM_SIZE_ALIGNED;
 8113226:	4b08      	ldr	r3, [pc, #32]	; (8113248 <mem_init+0x68>)
 8113228:	681b      	ldr	r3, [r3, #0]
 811322a:	f44f 62c8 	mov.w	r2, #1600	; 0x640
 811322e:	805a      	strh	r2, [r3, #2]
  MEM_SANITY();

  /* initialize the lowest-free pointer to the start of the heap */
  lfree = (struct mem *)(void *)ram;
 8113230:	4b03      	ldr	r3, [pc, #12]	; (8113240 <mem_init+0x60>)
 8113232:	681b      	ldr	r3, [r3, #0]
 8113234:	4a05      	ldr	r2, [pc, #20]	; (811324c <mem_init+0x6c>)
 8113236:	6013      	str	r3, [r2, #0]
  MEM_STATS_AVAIL(avail, MEM_SIZE_ALIGNED);

  if (sys_mutex_new(&mem_mutex) != ERR_OK) {
    LWIP_ASSERT("failed to create mem_mutex", 0);
  }
}
 8113238:	bf00      	nop
 811323a:	3708      	adds	r7, #8
 811323c:	46bd      	mov	sp, r7
 811323e:	bd80      	pop	{r7, pc}
 8113240:	10005514 	.word	0x10005514
 8113244:	30044000 	.word	0x30044000
 8113248:	10005518 	.word	0x10005518
 811324c:	1000551c 	.word	0x1000551c

08113250 <mem_link_valid>:
/* Check if a struct mem is correctly linked.
 * If not, double-free is a possible reason.
 */
static int
mem_link_valid(struct mem *mem)
{
 8113250:	b580      	push	{r7, lr}
 8113252:	b086      	sub	sp, #24
 8113254:	af00      	add	r7, sp, #0
 8113256:	6078      	str	r0, [r7, #4]
  struct mem *nmem, *pmem;
  mem_size_t rmem_idx;
  rmem_idx = mem_to_ptr(mem);
 8113258:	6878      	ldr	r0, [r7, #4]
 811325a:	f7ff ff0d 	bl	8113078 <mem_to_ptr>
 811325e:	4603      	mov	r3, r0
 8113260:	82fb      	strh	r3, [r7, #22]
  nmem = ptr_to_mem(mem->next);
 8113262:	687b      	ldr	r3, [r7, #4]
 8113264:	881b      	ldrh	r3, [r3, #0]
 8113266:	4618      	mov	r0, r3
 8113268:	f7ff fef4 	bl	8113054 <ptr_to_mem>
 811326c:	6138      	str	r0, [r7, #16]
  pmem = ptr_to_mem(mem->prev);
 811326e:	687b      	ldr	r3, [r7, #4]
 8113270:	885b      	ldrh	r3, [r3, #2]
 8113272:	4618      	mov	r0, r3
 8113274:	f7ff feee 	bl	8113054 <ptr_to_mem>
 8113278:	60f8      	str	r0, [r7, #12]
  if ((mem->next > MEM_SIZE_ALIGNED) || (mem->prev > MEM_SIZE_ALIGNED) ||
 811327a:	687b      	ldr	r3, [r7, #4]
 811327c:	881b      	ldrh	r3, [r3, #0]
 811327e:	f5b3 6fc8 	cmp.w	r3, #1600	; 0x640
 8113282:	d818      	bhi.n	81132b6 <mem_link_valid+0x66>
 8113284:	687b      	ldr	r3, [r7, #4]
 8113286:	885b      	ldrh	r3, [r3, #2]
 8113288:	f5b3 6fc8 	cmp.w	r3, #1600	; 0x640
 811328c:	d813      	bhi.n	81132b6 <mem_link_valid+0x66>
      ((mem->prev != rmem_idx) && (pmem->next != rmem_idx)) ||
 811328e:	687b      	ldr	r3, [r7, #4]
 8113290:	885b      	ldrh	r3, [r3, #2]
  if ((mem->next > MEM_SIZE_ALIGNED) || (mem->prev > MEM_SIZE_ALIGNED) ||
 8113292:	8afa      	ldrh	r2, [r7, #22]
 8113294:	429a      	cmp	r2, r3
 8113296:	d004      	beq.n	81132a2 <mem_link_valid+0x52>
      ((mem->prev != rmem_idx) && (pmem->next != rmem_idx)) ||
 8113298:	68fb      	ldr	r3, [r7, #12]
 811329a:	881b      	ldrh	r3, [r3, #0]
 811329c:	8afa      	ldrh	r2, [r7, #22]
 811329e:	429a      	cmp	r2, r3
 81132a0:	d109      	bne.n	81132b6 <mem_link_valid+0x66>
      ((nmem != ram_end) && (nmem->prev != rmem_idx))) {
 81132a2:	4b08      	ldr	r3, [pc, #32]	; (81132c4 <mem_link_valid+0x74>)
 81132a4:	681b      	ldr	r3, [r3, #0]
      ((mem->prev != rmem_idx) && (pmem->next != rmem_idx)) ||
 81132a6:	693a      	ldr	r2, [r7, #16]
 81132a8:	429a      	cmp	r2, r3
 81132aa:	d006      	beq.n	81132ba <mem_link_valid+0x6a>
      ((nmem != ram_end) && (nmem->prev != rmem_idx))) {
 81132ac:	693b      	ldr	r3, [r7, #16]
 81132ae:	885b      	ldrh	r3, [r3, #2]
 81132b0:	8afa      	ldrh	r2, [r7, #22]
 81132b2:	429a      	cmp	r2, r3
 81132b4:	d001      	beq.n	81132ba <mem_link_valid+0x6a>
    return 0;
 81132b6:	2300      	movs	r3, #0
 81132b8:	e000      	b.n	81132bc <mem_link_valid+0x6c>
  }
  return 1;
 81132ba:	2301      	movs	r3, #1
}
 81132bc:	4618      	mov	r0, r3
 81132be:	3718      	adds	r7, #24
 81132c0:	46bd      	mov	sp, r7
 81132c2:	bd80      	pop	{r7, pc}
 81132c4:	10005518 	.word	0x10005518

081132c8 <mem_free>:
 * @param rmem is the data portion of a struct mem as returned by a previous
 *             call to mem_malloc()
 */
void
mem_free(void *rmem)
{
 81132c8:	b580      	push	{r7, lr}
 81132ca:	b084      	sub	sp, #16
 81132cc:	af00      	add	r7, sp, #0
 81132ce:	6078      	str	r0, [r7, #4]
  struct mem *mem;
  LWIP_MEM_FREE_DECL_PROTECT();

  if (rmem == NULL) {
 81132d0:	687b      	ldr	r3, [r7, #4]
 81132d2:	2b00      	cmp	r3, #0
 81132d4:	d04c      	beq.n	8113370 <mem_free+0xa8>
    LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("mem_free(p == NULL) was called.\n"));
    return;
  }
  if ((((mem_ptr_t)rmem) & (MEM_ALIGNMENT - 1)) != 0) {
 81132d6:	687b      	ldr	r3, [r7, #4]
 81132d8:	f003 0303 	and.w	r3, r3, #3
 81132dc:	2b00      	cmp	r3, #0
 81132de:	d007      	beq.n	81132f0 <mem_free+0x28>
    LWIP_MEM_ILLEGAL_FREE("mem_free: sanity check alignment");
 81132e0:	4b25      	ldr	r3, [pc, #148]	; (8113378 <mem_free+0xb0>)
 81132e2:	f240 2273 	movw	r2, #627	; 0x273
 81132e6:	4925      	ldr	r1, [pc, #148]	; (811337c <mem_free+0xb4>)
 81132e8:	4825      	ldr	r0, [pc, #148]	; (8113380 <mem_free+0xb8>)
 81132ea:	f008 fa89 	bl	811b800 <iprintf>
    LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_LEVEL_SEVERE, ("mem_free: sanity check alignment\n"));
    /* protect mem stats from concurrent access */
    MEM_STATS_INC_LOCKED(illegal);
    return;
 81132ee:	e040      	b.n	8113372 <mem_free+0xaa>
  }

  /* Get the corresponding struct mem: */
  /* cast through void* to get rid of alignment warnings */
  mem = (struct mem *)(void *)((u8_t *)rmem - (SIZEOF_STRUCT_MEM + MEM_SANITY_OFFSET));
 81132f0:	687b      	ldr	r3, [r7, #4]
 81132f2:	3b08      	subs	r3, #8
 81132f4:	60fb      	str	r3, [r7, #12]

  if ((u8_t *)mem < ram || (u8_t *)rmem + MIN_SIZE_ALIGNED > (u8_t *)ram_end) {
 81132f6:	4b23      	ldr	r3, [pc, #140]	; (8113384 <mem_free+0xbc>)
 81132f8:	681b      	ldr	r3, [r3, #0]
 81132fa:	68fa      	ldr	r2, [r7, #12]
 81132fc:	429a      	cmp	r2, r3
 81132fe:	d306      	bcc.n	811330e <mem_free+0x46>
 8113300:	687b      	ldr	r3, [r7, #4]
 8113302:	f103 020c 	add.w	r2, r3, #12
 8113306:	4b20      	ldr	r3, [pc, #128]	; (8113388 <mem_free+0xc0>)
 8113308:	681b      	ldr	r3, [r3, #0]
 811330a:	429a      	cmp	r2, r3
 811330c:	d907      	bls.n	811331e <mem_free+0x56>
    LWIP_MEM_ILLEGAL_FREE("mem_free: illegal memory");
 811330e:	4b1a      	ldr	r3, [pc, #104]	; (8113378 <mem_free+0xb0>)
 8113310:	f240 227f 	movw	r2, #639	; 0x27f
 8113314:	491d      	ldr	r1, [pc, #116]	; (811338c <mem_free+0xc4>)
 8113316:	481a      	ldr	r0, [pc, #104]	; (8113380 <mem_free+0xb8>)
 8113318:	f008 fa72 	bl	811b800 <iprintf>
    LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_LEVEL_SEVERE, ("mem_free: illegal memory\n"));
    /* protect mem stats from concurrent access */
    MEM_STATS_INC_LOCKED(illegal);
    return;
 811331c:	e029      	b.n	8113372 <mem_free+0xaa>
  mem_overflow_check_element(mem);
#endif
  /* protect the heap from concurrent access */
  LWIP_MEM_FREE_PROTECT();
  /* mem has to be in a used state */
  if (!mem->used) {
 811331e:	68fb      	ldr	r3, [r7, #12]
 8113320:	791b      	ldrb	r3, [r3, #4]
 8113322:	2b00      	cmp	r3, #0
 8113324:	d107      	bne.n	8113336 <mem_free+0x6e>
    LWIP_MEM_ILLEGAL_FREE("mem_free: illegal memory: double free");
 8113326:	4b14      	ldr	r3, [pc, #80]	; (8113378 <mem_free+0xb0>)
 8113328:	f44f 7223 	mov.w	r2, #652	; 0x28c
 811332c:	4918      	ldr	r1, [pc, #96]	; (8113390 <mem_free+0xc8>)
 811332e:	4814      	ldr	r0, [pc, #80]	; (8113380 <mem_free+0xb8>)
 8113330:	f008 fa66 	bl	811b800 <iprintf>
    LWIP_MEM_FREE_UNPROTECT();
    LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_LEVEL_SEVERE, ("mem_free: illegal memory: double free?\n"));
    /* protect mem stats from concurrent access */
    MEM_STATS_INC_LOCKED(illegal);
    return;
 8113334:	e01d      	b.n	8113372 <mem_free+0xaa>
  }

  if (!mem_link_valid(mem)) {
 8113336:	68f8      	ldr	r0, [r7, #12]
 8113338:	f7ff ff8a 	bl	8113250 <mem_link_valid>
 811333c:	4603      	mov	r3, r0
 811333e:	2b00      	cmp	r3, #0
 8113340:	d107      	bne.n	8113352 <mem_free+0x8a>
    LWIP_MEM_ILLEGAL_FREE("mem_free: illegal memory: non-linked: double free");
 8113342:	4b0d      	ldr	r3, [pc, #52]	; (8113378 <mem_free+0xb0>)
 8113344:	f240 2295 	movw	r2, #661	; 0x295
 8113348:	4912      	ldr	r1, [pc, #72]	; (8113394 <mem_free+0xcc>)
 811334a:	480d      	ldr	r0, [pc, #52]	; (8113380 <mem_free+0xb8>)
 811334c:	f008 fa58 	bl	811b800 <iprintf>
    LWIP_MEM_FREE_UNPROTECT();
    LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_LEVEL_SEVERE, ("mem_free: illegal memory: non-linked: double free?\n"));
    /* protect mem stats from concurrent access */
    MEM_STATS_INC_LOCKED(illegal);
    return;
 8113350:	e00f      	b.n	8113372 <mem_free+0xaa>
  }

  /* mem is now unused. */
  mem->used = 0;
 8113352:	68fb      	ldr	r3, [r7, #12]
 8113354:	2200      	movs	r2, #0
 8113356:	711a      	strb	r2, [r3, #4]

  if (mem < lfree) {
 8113358:	4b0f      	ldr	r3, [pc, #60]	; (8113398 <mem_free+0xd0>)
 811335a:	681b      	ldr	r3, [r3, #0]
 811335c:	68fa      	ldr	r2, [r7, #12]
 811335e:	429a      	cmp	r2, r3
 8113360:	d202      	bcs.n	8113368 <mem_free+0xa0>
    /* the newly freed struct is now the lowest */
    lfree = mem;
 8113362:	4a0d      	ldr	r2, [pc, #52]	; (8113398 <mem_free+0xd0>)
 8113364:	68fb      	ldr	r3, [r7, #12]
 8113366:	6013      	str	r3, [r2, #0]
  }

  MEM_STATS_DEC_USED(used, mem->next - (mem_size_t)(((u8_t *)mem - ram)));

  /* finally, see if prev or next are free also */
  plug_holes(mem);
 8113368:	68f8      	ldr	r0, [r7, #12]
 811336a:	f7ff fe97 	bl	811309c <plug_holes>
 811336e:	e000      	b.n	8113372 <mem_free+0xaa>
    return;
 8113370:	bf00      	nop
  MEM_SANITY();
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  mem_free_count = 1;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_FREE_UNPROTECT();
}
 8113372:	3710      	adds	r7, #16
 8113374:	46bd      	mov	sp, r7
 8113376:	bd80      	pop	{r7, pc}
 8113378:	0811d404 	.word	0x0811d404
 811337c:	0811d50c 	.word	0x0811d50c
 8113380:	0811d480 	.word	0x0811d480
 8113384:	10005514 	.word	0x10005514
 8113388:	10005518 	.word	0x10005518
 811338c:	0811d530 	.word	0x0811d530
 8113390:	0811d54c 	.word	0x0811d54c
 8113394:	0811d574 	.word	0x0811d574
 8113398:	1000551c 	.word	0x1000551c

0811339c <mem_trim>:
 *         or NULL if newsize is > old size, in which case rmem is NOT touched
 *         or freed!
 */
void *
mem_trim(void *rmem, mem_size_t new_size)
{
 811339c:	b580      	push	{r7, lr}
 811339e:	b088      	sub	sp, #32
 81133a0:	af00      	add	r7, sp, #0
 81133a2:	6078      	str	r0, [r7, #4]
 81133a4:	460b      	mov	r3, r1
 81133a6:	807b      	strh	r3, [r7, #2]
  /* use the FREE_PROTECT here: it protects with sem OR SYS_ARCH_PROTECT */
  LWIP_MEM_FREE_DECL_PROTECT();

  /* Expand the size of the allocated memory region so that we can
     adjust for alignment. */
  newsize = (mem_size_t)LWIP_MEM_ALIGN_SIZE(new_size);
 81133a8:	887b      	ldrh	r3, [r7, #2]
 81133aa:	3303      	adds	r3, #3
 81133ac:	b29b      	uxth	r3, r3
 81133ae:	f023 0303 	bic.w	r3, r3, #3
 81133b2:	83fb      	strh	r3, [r7, #30]
  if (newsize < MIN_SIZE_ALIGNED) {
 81133b4:	8bfb      	ldrh	r3, [r7, #30]
 81133b6:	2b0b      	cmp	r3, #11
 81133b8:	d801      	bhi.n	81133be <mem_trim+0x22>
    /* every data block must be at least MIN_SIZE_ALIGNED long */
    newsize = MIN_SIZE_ALIGNED;
 81133ba:	230c      	movs	r3, #12
 81133bc:	83fb      	strh	r3, [r7, #30]
  }
#if MEM_OVERFLOW_CHECK
  newsize += MEM_SANITY_REGION_BEFORE_ALIGNED + MEM_SANITY_REGION_AFTER_ALIGNED;
#endif
  if ((newsize > MEM_SIZE_ALIGNED) || (newsize < new_size)) {
 81133be:	8bfb      	ldrh	r3, [r7, #30]
 81133c0:	f5b3 6fc8 	cmp.w	r3, #1600	; 0x640
 81133c4:	d803      	bhi.n	81133ce <mem_trim+0x32>
 81133c6:	8bfa      	ldrh	r2, [r7, #30]
 81133c8:	887b      	ldrh	r3, [r7, #2]
 81133ca:	429a      	cmp	r2, r3
 81133cc:	d201      	bcs.n	81133d2 <mem_trim+0x36>
    return NULL;
 81133ce:	2300      	movs	r3, #0
 81133d0:	e0cc      	b.n	811356c <mem_trim+0x1d0>
  }

  LWIP_ASSERT("mem_trim: legal memory", (u8_t *)rmem >= (u8_t *)ram &&
 81133d2:	4b68      	ldr	r3, [pc, #416]	; (8113574 <mem_trim+0x1d8>)
 81133d4:	681b      	ldr	r3, [r3, #0]
 81133d6:	687a      	ldr	r2, [r7, #4]
 81133d8:	429a      	cmp	r2, r3
 81133da:	d304      	bcc.n	81133e6 <mem_trim+0x4a>
 81133dc:	4b66      	ldr	r3, [pc, #408]	; (8113578 <mem_trim+0x1dc>)
 81133de:	681b      	ldr	r3, [r3, #0]
 81133e0:	687a      	ldr	r2, [r7, #4]
 81133e2:	429a      	cmp	r2, r3
 81133e4:	d306      	bcc.n	81133f4 <mem_trim+0x58>
 81133e6:	4b65      	ldr	r3, [pc, #404]	; (811357c <mem_trim+0x1e0>)
 81133e8:	f240 22d1 	movw	r2, #721	; 0x2d1
 81133ec:	4964      	ldr	r1, [pc, #400]	; (8113580 <mem_trim+0x1e4>)
 81133ee:	4865      	ldr	r0, [pc, #404]	; (8113584 <mem_trim+0x1e8>)
 81133f0:	f008 fa06 	bl	811b800 <iprintf>
              (u8_t *)rmem < (u8_t *)ram_end);

  if ((u8_t *)rmem < (u8_t *)ram || (u8_t *)rmem >= (u8_t *)ram_end) {
 81133f4:	4b5f      	ldr	r3, [pc, #380]	; (8113574 <mem_trim+0x1d8>)
 81133f6:	681b      	ldr	r3, [r3, #0]
 81133f8:	687a      	ldr	r2, [r7, #4]
 81133fa:	429a      	cmp	r2, r3
 81133fc:	d304      	bcc.n	8113408 <mem_trim+0x6c>
 81133fe:	4b5e      	ldr	r3, [pc, #376]	; (8113578 <mem_trim+0x1dc>)
 8113400:	681b      	ldr	r3, [r3, #0]
 8113402:	687a      	ldr	r2, [r7, #4]
 8113404:	429a      	cmp	r2, r3
 8113406:	d301      	bcc.n	811340c <mem_trim+0x70>
    LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_LEVEL_SEVERE, ("mem_trim: illegal memory\n"));
    /* protect mem stats from concurrent access */
    MEM_STATS_INC_LOCKED(illegal);
    return rmem;
 8113408:	687b      	ldr	r3, [r7, #4]
 811340a:	e0af      	b.n	811356c <mem_trim+0x1d0>
  }
  /* Get the corresponding struct mem ... */
  /* cast through void* to get rid of alignment warnings */
  mem = (struct mem *)(void *)((u8_t *)rmem - (SIZEOF_STRUCT_MEM + MEM_SANITY_OFFSET));
 811340c:	687b      	ldr	r3, [r7, #4]
 811340e:	3b08      	subs	r3, #8
 8113410:	61bb      	str	r3, [r7, #24]
#if MEM_OVERFLOW_CHECK
  mem_overflow_check_element(mem);
#endif
  /* ... and its offset pointer */
  ptr = mem_to_ptr(mem);
 8113412:	69b8      	ldr	r0, [r7, #24]
 8113414:	f7ff fe30 	bl	8113078 <mem_to_ptr>
 8113418:	4603      	mov	r3, r0
 811341a:	82fb      	strh	r3, [r7, #22]

  size = (mem_size_t)((mem_size_t)(mem->next - ptr) - (SIZEOF_STRUCT_MEM + MEM_SANITY_OVERHEAD));
 811341c:	69bb      	ldr	r3, [r7, #24]
 811341e:	881a      	ldrh	r2, [r3, #0]
 8113420:	8afb      	ldrh	r3, [r7, #22]
 8113422:	1ad3      	subs	r3, r2, r3
 8113424:	b29b      	uxth	r3, r3
 8113426:	3b08      	subs	r3, #8
 8113428:	82bb      	strh	r3, [r7, #20]
  LWIP_ASSERT("mem_trim can only shrink memory", newsize <= size);
 811342a:	8bfa      	ldrh	r2, [r7, #30]
 811342c:	8abb      	ldrh	r3, [r7, #20]
 811342e:	429a      	cmp	r2, r3
 8113430:	d906      	bls.n	8113440 <mem_trim+0xa4>
 8113432:	4b52      	ldr	r3, [pc, #328]	; (811357c <mem_trim+0x1e0>)
 8113434:	f44f 7239 	mov.w	r2, #740	; 0x2e4
 8113438:	4953      	ldr	r1, [pc, #332]	; (8113588 <mem_trim+0x1ec>)
 811343a:	4852      	ldr	r0, [pc, #328]	; (8113584 <mem_trim+0x1e8>)
 811343c:	f008 f9e0 	bl	811b800 <iprintf>
  if (newsize > size) {
 8113440:	8bfa      	ldrh	r2, [r7, #30]
 8113442:	8abb      	ldrh	r3, [r7, #20]
 8113444:	429a      	cmp	r2, r3
 8113446:	d901      	bls.n	811344c <mem_trim+0xb0>
    /* not supported */
    return NULL;
 8113448:	2300      	movs	r3, #0
 811344a:	e08f      	b.n	811356c <mem_trim+0x1d0>
  }
  if (newsize == size) {
 811344c:	8bfa      	ldrh	r2, [r7, #30]
 811344e:	8abb      	ldrh	r3, [r7, #20]
 8113450:	429a      	cmp	r2, r3
 8113452:	d101      	bne.n	8113458 <mem_trim+0xbc>
    /* No change in size, simply return */
    return rmem;
 8113454:	687b      	ldr	r3, [r7, #4]
 8113456:	e089      	b.n	811356c <mem_trim+0x1d0>
  }

  /* protect the heap from concurrent access */
  LWIP_MEM_FREE_PROTECT();

  mem2 = ptr_to_mem(mem->next);
 8113458:	69bb      	ldr	r3, [r7, #24]
 811345a:	881b      	ldrh	r3, [r3, #0]
 811345c:	4618      	mov	r0, r3
 811345e:	f7ff fdf9 	bl	8113054 <ptr_to_mem>
 8113462:	6138      	str	r0, [r7, #16]
  if (mem2->used == 0) {
 8113464:	693b      	ldr	r3, [r7, #16]
 8113466:	791b      	ldrb	r3, [r3, #4]
 8113468:	2b00      	cmp	r3, #0
 811346a:	d13f      	bne.n	81134ec <mem_trim+0x150>
    /* The next struct is unused, we can simply move it at little */
    mem_size_t next;
    LWIP_ASSERT("invalid next ptr", mem->next != MEM_SIZE_ALIGNED);
 811346c:	69bb      	ldr	r3, [r7, #24]
 811346e:	881b      	ldrh	r3, [r3, #0]
 8113470:	f5b3 6fc8 	cmp.w	r3, #1600	; 0x640
 8113474:	d106      	bne.n	8113484 <mem_trim+0xe8>
 8113476:	4b41      	ldr	r3, [pc, #260]	; (811357c <mem_trim+0x1e0>)
 8113478:	f240 22f5 	movw	r2, #757	; 0x2f5
 811347c:	4943      	ldr	r1, [pc, #268]	; (811358c <mem_trim+0x1f0>)
 811347e:	4841      	ldr	r0, [pc, #260]	; (8113584 <mem_trim+0x1e8>)
 8113480:	f008 f9be 	bl	811b800 <iprintf>
    /* remember the old next pointer */
    next = mem2->next;
 8113484:	693b      	ldr	r3, [r7, #16]
 8113486:	881b      	ldrh	r3, [r3, #0]
 8113488:	81bb      	strh	r3, [r7, #12]
    /* create new struct mem which is moved directly after the shrinked mem */
    ptr2 = (mem_size_t)(ptr + SIZEOF_STRUCT_MEM + newsize);
 811348a:	8afa      	ldrh	r2, [r7, #22]
 811348c:	8bfb      	ldrh	r3, [r7, #30]
 811348e:	4413      	add	r3, r2
 8113490:	b29b      	uxth	r3, r3
 8113492:	3308      	adds	r3, #8
 8113494:	81fb      	strh	r3, [r7, #14]
    if (lfree == mem2) {
 8113496:	4b3e      	ldr	r3, [pc, #248]	; (8113590 <mem_trim+0x1f4>)
 8113498:	681b      	ldr	r3, [r3, #0]
 811349a:	693a      	ldr	r2, [r7, #16]
 811349c:	429a      	cmp	r2, r3
 811349e:	d106      	bne.n	81134ae <mem_trim+0x112>
      lfree = ptr_to_mem(ptr2);
 81134a0:	89fb      	ldrh	r3, [r7, #14]
 81134a2:	4618      	mov	r0, r3
 81134a4:	f7ff fdd6 	bl	8113054 <ptr_to_mem>
 81134a8:	4603      	mov	r3, r0
 81134aa:	4a39      	ldr	r2, [pc, #228]	; (8113590 <mem_trim+0x1f4>)
 81134ac:	6013      	str	r3, [r2, #0]
    }
    mem2 = ptr_to_mem(ptr2);
 81134ae:	89fb      	ldrh	r3, [r7, #14]
 81134b0:	4618      	mov	r0, r3
 81134b2:	f7ff fdcf 	bl	8113054 <ptr_to_mem>
 81134b6:	6138      	str	r0, [r7, #16]
    mem2->used = 0;
 81134b8:	693b      	ldr	r3, [r7, #16]
 81134ba:	2200      	movs	r2, #0
 81134bc:	711a      	strb	r2, [r3, #4]
    /* restore the next pointer */
    mem2->next = next;
 81134be:	693b      	ldr	r3, [r7, #16]
 81134c0:	89ba      	ldrh	r2, [r7, #12]
 81134c2:	801a      	strh	r2, [r3, #0]
    /* link it back to mem */
    mem2->prev = ptr;
 81134c4:	693b      	ldr	r3, [r7, #16]
 81134c6:	8afa      	ldrh	r2, [r7, #22]
 81134c8:	805a      	strh	r2, [r3, #2]
    /* link mem to it */
    mem->next = ptr2;
 81134ca:	69bb      	ldr	r3, [r7, #24]
 81134cc:	89fa      	ldrh	r2, [r7, #14]
 81134ce:	801a      	strh	r2, [r3, #0]
    /* last thing to restore linked list: as we have moved mem2,
     * let 'mem2->next->prev' point to mem2 again. but only if mem2->next is not
     * the end of the heap */
    if (mem2->next != MEM_SIZE_ALIGNED) {
 81134d0:	693b      	ldr	r3, [r7, #16]
 81134d2:	881b      	ldrh	r3, [r3, #0]
 81134d4:	f5b3 6fc8 	cmp.w	r3, #1600	; 0x640
 81134d8:	d047      	beq.n	811356a <mem_trim+0x1ce>
      ptr_to_mem(mem2->next)->prev = ptr2;
 81134da:	693b      	ldr	r3, [r7, #16]
 81134dc:	881b      	ldrh	r3, [r3, #0]
 81134de:	4618      	mov	r0, r3
 81134e0:	f7ff fdb8 	bl	8113054 <ptr_to_mem>
 81134e4:	4602      	mov	r2, r0
 81134e6:	89fb      	ldrh	r3, [r7, #14]
 81134e8:	8053      	strh	r3, [r2, #2]
 81134ea:	e03e      	b.n	811356a <mem_trim+0x1ce>
    }
    MEM_STATS_DEC_USED(used, (size - newsize));
    /* no need to plug holes, we've already done that */
  } else if (newsize + SIZEOF_STRUCT_MEM + MIN_SIZE_ALIGNED <= size) {
 81134ec:	8bfb      	ldrh	r3, [r7, #30]
 81134ee:	f103 0214 	add.w	r2, r3, #20
 81134f2:	8abb      	ldrh	r3, [r7, #20]
 81134f4:	429a      	cmp	r2, r3
 81134f6:	d838      	bhi.n	811356a <mem_trim+0x1ce>
     * Old size ('size') must be big enough to contain at least 'newsize' plus a struct mem
     * ('SIZEOF_STRUCT_MEM') with some data ('MIN_SIZE_ALIGNED').
     * @todo we could leave out MIN_SIZE_ALIGNED. We would create an empty
     *       region that couldn't hold data, but when mem->next gets freed,
     *       the 2 regions would be combined, resulting in more free memory */
    ptr2 = (mem_size_t)(ptr + SIZEOF_STRUCT_MEM + newsize);
 81134f8:	8afa      	ldrh	r2, [r7, #22]
 81134fa:	8bfb      	ldrh	r3, [r7, #30]
 81134fc:	4413      	add	r3, r2
 81134fe:	b29b      	uxth	r3, r3
 8113500:	3308      	adds	r3, #8
 8113502:	81fb      	strh	r3, [r7, #14]
    LWIP_ASSERT("invalid next ptr", mem->next != MEM_SIZE_ALIGNED);
 8113504:	69bb      	ldr	r3, [r7, #24]
 8113506:	881b      	ldrh	r3, [r3, #0]
 8113508:	f5b3 6fc8 	cmp.w	r3, #1600	; 0x640
 811350c:	d106      	bne.n	811351c <mem_trim+0x180>
 811350e:	4b1b      	ldr	r3, [pc, #108]	; (811357c <mem_trim+0x1e0>)
 8113510:	f240 3216 	movw	r2, #790	; 0x316
 8113514:	491d      	ldr	r1, [pc, #116]	; (811358c <mem_trim+0x1f0>)
 8113516:	481b      	ldr	r0, [pc, #108]	; (8113584 <mem_trim+0x1e8>)
 8113518:	f008 f972 	bl	811b800 <iprintf>
    mem2 = ptr_to_mem(ptr2);
 811351c:	89fb      	ldrh	r3, [r7, #14]
 811351e:	4618      	mov	r0, r3
 8113520:	f7ff fd98 	bl	8113054 <ptr_to_mem>
 8113524:	6138      	str	r0, [r7, #16]
    if (mem2 < lfree) {
 8113526:	4b1a      	ldr	r3, [pc, #104]	; (8113590 <mem_trim+0x1f4>)
 8113528:	681b      	ldr	r3, [r3, #0]
 811352a:	693a      	ldr	r2, [r7, #16]
 811352c:	429a      	cmp	r2, r3
 811352e:	d202      	bcs.n	8113536 <mem_trim+0x19a>
      lfree = mem2;
 8113530:	4a17      	ldr	r2, [pc, #92]	; (8113590 <mem_trim+0x1f4>)
 8113532:	693b      	ldr	r3, [r7, #16]
 8113534:	6013      	str	r3, [r2, #0]
    }
    mem2->used = 0;
 8113536:	693b      	ldr	r3, [r7, #16]
 8113538:	2200      	movs	r2, #0
 811353a:	711a      	strb	r2, [r3, #4]
    mem2->next = mem->next;
 811353c:	69bb      	ldr	r3, [r7, #24]
 811353e:	881a      	ldrh	r2, [r3, #0]
 8113540:	693b      	ldr	r3, [r7, #16]
 8113542:	801a      	strh	r2, [r3, #0]
    mem2->prev = ptr;
 8113544:	693b      	ldr	r3, [r7, #16]
 8113546:	8afa      	ldrh	r2, [r7, #22]
 8113548:	805a      	strh	r2, [r3, #2]
    mem->next = ptr2;
 811354a:	69bb      	ldr	r3, [r7, #24]
 811354c:	89fa      	ldrh	r2, [r7, #14]
 811354e:	801a      	strh	r2, [r3, #0]
    if (mem2->next != MEM_SIZE_ALIGNED) {
 8113550:	693b      	ldr	r3, [r7, #16]
 8113552:	881b      	ldrh	r3, [r3, #0]
 8113554:	f5b3 6fc8 	cmp.w	r3, #1600	; 0x640
 8113558:	d007      	beq.n	811356a <mem_trim+0x1ce>
      ptr_to_mem(mem2->next)->prev = ptr2;
 811355a:	693b      	ldr	r3, [r7, #16]
 811355c:	881b      	ldrh	r3, [r3, #0]
 811355e:	4618      	mov	r0, r3
 8113560:	f7ff fd78 	bl	8113054 <ptr_to_mem>
 8113564:	4602      	mov	r2, r0
 8113566:	89fb      	ldrh	r3, [r7, #14]
 8113568:	8053      	strh	r3, [r2, #2]
  MEM_SANITY();
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  mem_free_count = 1;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_FREE_UNPROTECT();
  return rmem;
 811356a:	687b      	ldr	r3, [r7, #4]
}
 811356c:	4618      	mov	r0, r3
 811356e:	3720      	adds	r7, #32
 8113570:	46bd      	mov	sp, r7
 8113572:	bd80      	pop	{r7, pc}
 8113574:	10005514 	.word	0x10005514
 8113578:	10005518 	.word	0x10005518
 811357c:	0811d404 	.word	0x0811d404
 8113580:	0811d5a8 	.word	0x0811d5a8
 8113584:	0811d480 	.word	0x0811d480
 8113588:	0811d5c0 	.word	0x0811d5c0
 811358c:	0811d5e0 	.word	0x0811d5e0
 8113590:	1000551c 	.word	0x1000551c

08113594 <mem_malloc>:
 *
 * Note that the returned value will always be aligned (as defined by MEM_ALIGNMENT).
 */
void *
mem_malloc(mem_size_t size_in)
{
 8113594:	b580      	push	{r7, lr}
 8113596:	b088      	sub	sp, #32
 8113598:	af00      	add	r7, sp, #0
 811359a:	4603      	mov	r3, r0
 811359c:	80fb      	strh	r3, [r7, #6]
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  u8_t local_mem_free_count = 0;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_ALLOC_DECL_PROTECT();

  if (size_in == 0) {
 811359e:	88fb      	ldrh	r3, [r7, #6]
 81135a0:	2b00      	cmp	r3, #0
 81135a2:	d101      	bne.n	81135a8 <mem_malloc+0x14>
    return NULL;
 81135a4:	2300      	movs	r3, #0
 81135a6:	e0d9      	b.n	811375c <mem_malloc+0x1c8>
  }

  /* Expand the size of the allocated memory region so that we can
     adjust for alignment. */
  size = (mem_size_t)LWIP_MEM_ALIGN_SIZE(size_in);
 81135a8:	88fb      	ldrh	r3, [r7, #6]
 81135aa:	3303      	adds	r3, #3
 81135ac:	b29b      	uxth	r3, r3
 81135ae:	f023 0303 	bic.w	r3, r3, #3
 81135b2:	83bb      	strh	r3, [r7, #28]
  if (size < MIN_SIZE_ALIGNED) {
 81135b4:	8bbb      	ldrh	r3, [r7, #28]
 81135b6:	2b0b      	cmp	r3, #11
 81135b8:	d801      	bhi.n	81135be <mem_malloc+0x2a>
    /* every data block must be at least MIN_SIZE_ALIGNED long */
    size = MIN_SIZE_ALIGNED;
 81135ba:	230c      	movs	r3, #12
 81135bc:	83bb      	strh	r3, [r7, #28]
  }
#if MEM_OVERFLOW_CHECK
  size += MEM_SANITY_REGION_BEFORE_ALIGNED + MEM_SANITY_REGION_AFTER_ALIGNED;
#endif
  if ((size > MEM_SIZE_ALIGNED) || (size < size_in)) {
 81135be:	8bbb      	ldrh	r3, [r7, #28]
 81135c0:	f5b3 6fc8 	cmp.w	r3, #1600	; 0x640
 81135c4:	d803      	bhi.n	81135ce <mem_malloc+0x3a>
 81135c6:	8bba      	ldrh	r2, [r7, #28]
 81135c8:	88fb      	ldrh	r3, [r7, #6]
 81135ca:	429a      	cmp	r2, r3
 81135cc:	d201      	bcs.n	81135d2 <mem_malloc+0x3e>
    return NULL;
 81135ce:	2300      	movs	r3, #0
 81135d0:	e0c4      	b.n	811375c <mem_malloc+0x1c8>
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */

    /* Scan through the heap searching for a free block that is big enough,
     * beginning with the lowest free block.
     */
    for (ptr = mem_to_ptr(lfree); ptr < MEM_SIZE_ALIGNED - size;
 81135d2:	4b64      	ldr	r3, [pc, #400]	; (8113764 <mem_malloc+0x1d0>)
 81135d4:	681b      	ldr	r3, [r3, #0]
 81135d6:	4618      	mov	r0, r3
 81135d8:	f7ff fd4e 	bl	8113078 <mem_to_ptr>
 81135dc:	4603      	mov	r3, r0
 81135de:	83fb      	strh	r3, [r7, #30]
 81135e0:	e0b4      	b.n	811374c <mem_malloc+0x1b8>
         ptr = ptr_to_mem(ptr)->next) {
      mem = ptr_to_mem(ptr);
 81135e2:	8bfb      	ldrh	r3, [r7, #30]
 81135e4:	4618      	mov	r0, r3
 81135e6:	f7ff fd35 	bl	8113054 <ptr_to_mem>
 81135ea:	6178      	str	r0, [r7, #20]
        local_mem_free_count = 1;
        break;
      }
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */

      if ((!mem->used) &&
 81135ec:	697b      	ldr	r3, [r7, #20]
 81135ee:	791b      	ldrb	r3, [r3, #4]
 81135f0:	2b00      	cmp	r3, #0
 81135f2:	f040 80a4 	bne.w	811373e <mem_malloc+0x1aa>
          (mem->next - (ptr + SIZEOF_STRUCT_MEM)) >= size) {
 81135f6:	697b      	ldr	r3, [r7, #20]
 81135f8:	881b      	ldrh	r3, [r3, #0]
 81135fa:	461a      	mov	r2, r3
 81135fc:	8bfb      	ldrh	r3, [r7, #30]
 81135fe:	1ad3      	subs	r3, r2, r3
 8113600:	f1a3 0208 	sub.w	r2, r3, #8
 8113604:	8bbb      	ldrh	r3, [r7, #28]
      if ((!mem->used) &&
 8113606:	429a      	cmp	r2, r3
 8113608:	f0c0 8099 	bcc.w	811373e <mem_malloc+0x1aa>
        /* mem is not used and at least perfect fit is possible:
         * mem->next - (ptr + SIZEOF_STRUCT_MEM) gives us the 'user data size' of mem */

        if (mem->next - (ptr + SIZEOF_STRUCT_MEM) >= (size + SIZEOF_STRUCT_MEM + MIN_SIZE_ALIGNED)) {
 811360c:	697b      	ldr	r3, [r7, #20]
 811360e:	881b      	ldrh	r3, [r3, #0]
 8113610:	461a      	mov	r2, r3
 8113612:	8bfb      	ldrh	r3, [r7, #30]
 8113614:	1ad3      	subs	r3, r2, r3
 8113616:	f1a3 0208 	sub.w	r2, r3, #8
 811361a:	8bbb      	ldrh	r3, [r7, #28]
 811361c:	3314      	adds	r3, #20
 811361e:	429a      	cmp	r2, r3
 8113620:	d333      	bcc.n	811368a <mem_malloc+0xf6>
           * struct mem would fit in but no data between mem2 and mem2->next
           * @todo we could leave out MIN_SIZE_ALIGNED. We would create an empty
           *       region that couldn't hold data, but when mem->next gets freed,
           *       the 2 regions would be combined, resulting in more free memory
           */
          ptr2 = (mem_size_t)(ptr + SIZEOF_STRUCT_MEM + size);
 8113622:	8bfa      	ldrh	r2, [r7, #30]
 8113624:	8bbb      	ldrh	r3, [r7, #28]
 8113626:	4413      	add	r3, r2
 8113628:	b29b      	uxth	r3, r3
 811362a:	3308      	adds	r3, #8
 811362c:	827b      	strh	r3, [r7, #18]
          LWIP_ASSERT("invalid next ptr",ptr2 != MEM_SIZE_ALIGNED);
 811362e:	8a7b      	ldrh	r3, [r7, #18]
 8113630:	f5b3 6fc8 	cmp.w	r3, #1600	; 0x640
 8113634:	d106      	bne.n	8113644 <mem_malloc+0xb0>
 8113636:	4b4c      	ldr	r3, [pc, #304]	; (8113768 <mem_malloc+0x1d4>)
 8113638:	f240 3287 	movw	r2, #903	; 0x387
 811363c:	494b      	ldr	r1, [pc, #300]	; (811376c <mem_malloc+0x1d8>)
 811363e:	484c      	ldr	r0, [pc, #304]	; (8113770 <mem_malloc+0x1dc>)
 8113640:	f008 f8de 	bl	811b800 <iprintf>
          /* create mem2 struct */
          mem2 = ptr_to_mem(ptr2);
 8113644:	8a7b      	ldrh	r3, [r7, #18]
 8113646:	4618      	mov	r0, r3
 8113648:	f7ff fd04 	bl	8113054 <ptr_to_mem>
 811364c:	60f8      	str	r0, [r7, #12]
          mem2->used = 0;
 811364e:	68fb      	ldr	r3, [r7, #12]
 8113650:	2200      	movs	r2, #0
 8113652:	711a      	strb	r2, [r3, #4]
          mem2->next = mem->next;
 8113654:	697b      	ldr	r3, [r7, #20]
 8113656:	881a      	ldrh	r2, [r3, #0]
 8113658:	68fb      	ldr	r3, [r7, #12]
 811365a:	801a      	strh	r2, [r3, #0]
          mem2->prev = ptr;
 811365c:	68fb      	ldr	r3, [r7, #12]
 811365e:	8bfa      	ldrh	r2, [r7, #30]
 8113660:	805a      	strh	r2, [r3, #2]
          /* and insert it between mem and mem->next */
          mem->next = ptr2;
 8113662:	697b      	ldr	r3, [r7, #20]
 8113664:	8a7a      	ldrh	r2, [r7, #18]
 8113666:	801a      	strh	r2, [r3, #0]
          mem->used = 1;
 8113668:	697b      	ldr	r3, [r7, #20]
 811366a:	2201      	movs	r2, #1
 811366c:	711a      	strb	r2, [r3, #4]

          if (mem2->next != MEM_SIZE_ALIGNED) {
 811366e:	68fb      	ldr	r3, [r7, #12]
 8113670:	881b      	ldrh	r3, [r3, #0]
 8113672:	f5b3 6fc8 	cmp.w	r3, #1600	; 0x640
 8113676:	d00b      	beq.n	8113690 <mem_malloc+0xfc>
            ptr_to_mem(mem2->next)->prev = ptr2;
 8113678:	68fb      	ldr	r3, [r7, #12]
 811367a:	881b      	ldrh	r3, [r3, #0]
 811367c:	4618      	mov	r0, r3
 811367e:	f7ff fce9 	bl	8113054 <ptr_to_mem>
 8113682:	4602      	mov	r2, r0
 8113684:	8a7b      	ldrh	r3, [r7, #18]
 8113686:	8053      	strh	r3, [r2, #2]
 8113688:	e002      	b.n	8113690 <mem_malloc+0xfc>
           * take care of this).
           * -> near fit or exact fit: do not split, no mem2 creation
           * also can't move mem->next directly behind mem, since mem->next
           * will always be used at this point!
           */
          mem->used = 1;
 811368a:	697b      	ldr	r3, [r7, #20]
 811368c:	2201      	movs	r2, #1
 811368e:	711a      	strb	r2, [r3, #4]
          MEM_STATS_INC_USED(used, mem->next - mem_to_ptr(mem));
        }
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
mem_malloc_adjust_lfree:
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
        if (mem == lfree) {
 8113690:	4b34      	ldr	r3, [pc, #208]	; (8113764 <mem_malloc+0x1d0>)
 8113692:	681b      	ldr	r3, [r3, #0]
 8113694:	697a      	ldr	r2, [r7, #20]
 8113696:	429a      	cmp	r2, r3
 8113698:	d127      	bne.n	81136ea <mem_malloc+0x156>
          struct mem *cur = lfree;
 811369a:	4b32      	ldr	r3, [pc, #200]	; (8113764 <mem_malloc+0x1d0>)
 811369c:	681b      	ldr	r3, [r3, #0]
 811369e:	61bb      	str	r3, [r7, #24]
          /* Find next free block after mem and update lowest free pointer */
          while (cur->used && cur != ram_end) {
 81136a0:	e005      	b.n	81136ae <mem_malloc+0x11a>
              /* If mem_free or mem_trim have run, we have to restart since they
                 could have altered our current struct mem or lfree. */
              goto mem_malloc_adjust_lfree;
            }
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
            cur = ptr_to_mem(cur->next);
 81136a2:	69bb      	ldr	r3, [r7, #24]
 81136a4:	881b      	ldrh	r3, [r3, #0]
 81136a6:	4618      	mov	r0, r3
 81136a8:	f7ff fcd4 	bl	8113054 <ptr_to_mem>
 81136ac:	61b8      	str	r0, [r7, #24]
          while (cur->used && cur != ram_end) {
 81136ae:	69bb      	ldr	r3, [r7, #24]
 81136b0:	791b      	ldrb	r3, [r3, #4]
 81136b2:	2b00      	cmp	r3, #0
 81136b4:	d004      	beq.n	81136c0 <mem_malloc+0x12c>
 81136b6:	4b2f      	ldr	r3, [pc, #188]	; (8113774 <mem_malloc+0x1e0>)
 81136b8:	681b      	ldr	r3, [r3, #0]
 81136ba:	69ba      	ldr	r2, [r7, #24]
 81136bc:	429a      	cmp	r2, r3
 81136be:	d1f0      	bne.n	81136a2 <mem_malloc+0x10e>
          }
          lfree = cur;
 81136c0:	4a28      	ldr	r2, [pc, #160]	; (8113764 <mem_malloc+0x1d0>)
 81136c2:	69bb      	ldr	r3, [r7, #24]
 81136c4:	6013      	str	r3, [r2, #0]
          LWIP_ASSERT("mem_malloc: !lfree->used", ((lfree == ram_end) || (!lfree->used)));
 81136c6:	4b27      	ldr	r3, [pc, #156]	; (8113764 <mem_malloc+0x1d0>)
 81136c8:	681a      	ldr	r2, [r3, #0]
 81136ca:	4b2a      	ldr	r3, [pc, #168]	; (8113774 <mem_malloc+0x1e0>)
 81136cc:	681b      	ldr	r3, [r3, #0]
 81136ce:	429a      	cmp	r2, r3
 81136d0:	d00b      	beq.n	81136ea <mem_malloc+0x156>
 81136d2:	4b24      	ldr	r3, [pc, #144]	; (8113764 <mem_malloc+0x1d0>)
 81136d4:	681b      	ldr	r3, [r3, #0]
 81136d6:	791b      	ldrb	r3, [r3, #4]
 81136d8:	2b00      	cmp	r3, #0
 81136da:	d006      	beq.n	81136ea <mem_malloc+0x156>
 81136dc:	4b22      	ldr	r3, [pc, #136]	; (8113768 <mem_malloc+0x1d4>)
 81136de:	f240 32b5 	movw	r2, #949	; 0x3b5
 81136e2:	4925      	ldr	r1, [pc, #148]	; (8113778 <mem_malloc+0x1e4>)
 81136e4:	4822      	ldr	r0, [pc, #136]	; (8113770 <mem_malloc+0x1dc>)
 81136e6:	f008 f88b 	bl	811b800 <iprintf>
        }
        LWIP_MEM_ALLOC_UNPROTECT();
        sys_mutex_unlock(&mem_mutex);
        LWIP_ASSERT("mem_malloc: allocated memory not above ram_end.",
 81136ea:	8bba      	ldrh	r2, [r7, #28]
 81136ec:	697b      	ldr	r3, [r7, #20]
 81136ee:	4413      	add	r3, r2
 81136f0:	3308      	adds	r3, #8
 81136f2:	4a20      	ldr	r2, [pc, #128]	; (8113774 <mem_malloc+0x1e0>)
 81136f4:	6812      	ldr	r2, [r2, #0]
 81136f6:	4293      	cmp	r3, r2
 81136f8:	d906      	bls.n	8113708 <mem_malloc+0x174>
 81136fa:	4b1b      	ldr	r3, [pc, #108]	; (8113768 <mem_malloc+0x1d4>)
 81136fc:	f240 32b9 	movw	r2, #953	; 0x3b9
 8113700:	491e      	ldr	r1, [pc, #120]	; (811377c <mem_malloc+0x1e8>)
 8113702:	481b      	ldr	r0, [pc, #108]	; (8113770 <mem_malloc+0x1dc>)
 8113704:	f008 f87c 	bl	811b800 <iprintf>
                    (mem_ptr_t)mem + SIZEOF_STRUCT_MEM + size <= (mem_ptr_t)ram_end);
        LWIP_ASSERT("mem_malloc: allocated memory properly aligned.",
 8113708:	697b      	ldr	r3, [r7, #20]
 811370a:	f003 0303 	and.w	r3, r3, #3
 811370e:	2b00      	cmp	r3, #0
 8113710:	d006      	beq.n	8113720 <mem_malloc+0x18c>
 8113712:	4b15      	ldr	r3, [pc, #84]	; (8113768 <mem_malloc+0x1d4>)
 8113714:	f240 32bb 	movw	r2, #955	; 0x3bb
 8113718:	4919      	ldr	r1, [pc, #100]	; (8113780 <mem_malloc+0x1ec>)
 811371a:	4815      	ldr	r0, [pc, #84]	; (8113770 <mem_malloc+0x1dc>)
 811371c:	f008 f870 	bl	811b800 <iprintf>
                    ((mem_ptr_t)mem + SIZEOF_STRUCT_MEM) % MEM_ALIGNMENT == 0);
        LWIP_ASSERT("mem_malloc: sanity check alignment",
 8113720:	697b      	ldr	r3, [r7, #20]
 8113722:	f003 0303 	and.w	r3, r3, #3
 8113726:	2b00      	cmp	r3, #0
 8113728:	d006      	beq.n	8113738 <mem_malloc+0x1a4>
 811372a:	4b0f      	ldr	r3, [pc, #60]	; (8113768 <mem_malloc+0x1d4>)
 811372c:	f240 32bd 	movw	r2, #957	; 0x3bd
 8113730:	4914      	ldr	r1, [pc, #80]	; (8113784 <mem_malloc+0x1f0>)
 8113732:	480f      	ldr	r0, [pc, #60]	; (8113770 <mem_malloc+0x1dc>)
 8113734:	f008 f864 	bl	811b800 <iprintf>

#if MEM_OVERFLOW_CHECK
        mem_overflow_init_element(mem, size_in);
#endif
        MEM_SANITY();
        return (u8_t *)mem + SIZEOF_STRUCT_MEM + MEM_SANITY_OFFSET;
 8113738:	697b      	ldr	r3, [r7, #20]
 811373a:	3308      	adds	r3, #8
 811373c:	e00e      	b.n	811375c <mem_malloc+0x1c8>
         ptr = ptr_to_mem(ptr)->next) {
 811373e:	8bfb      	ldrh	r3, [r7, #30]
 8113740:	4618      	mov	r0, r3
 8113742:	f7ff fc87 	bl	8113054 <ptr_to_mem>
 8113746:	4603      	mov	r3, r0
 8113748:	881b      	ldrh	r3, [r3, #0]
 811374a:	83fb      	strh	r3, [r7, #30]
    for (ptr = mem_to_ptr(lfree); ptr < MEM_SIZE_ALIGNED - size;
 811374c:	8bfa      	ldrh	r2, [r7, #30]
 811374e:	8bbb      	ldrh	r3, [r7, #28]
 8113750:	f5c3 63c8 	rsb	r3, r3, #1600	; 0x640
 8113754:	429a      	cmp	r2, r3
 8113756:	f4ff af44 	bcc.w	81135e2 <mem_malloc+0x4e>
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  MEM_STATS_INC(err);
  LWIP_MEM_ALLOC_UNPROTECT();
  sys_mutex_unlock(&mem_mutex);
  LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("mem_malloc: could not allocate %"S16_F" bytes\n", (s16_t)size));
  return NULL;
 811375a:	2300      	movs	r3, #0
}
 811375c:	4618      	mov	r0, r3
 811375e:	3720      	adds	r7, #32
 8113760:	46bd      	mov	sp, r7
 8113762:	bd80      	pop	{r7, pc}
 8113764:	1000551c 	.word	0x1000551c
 8113768:	0811d404 	.word	0x0811d404
 811376c:	0811d5e0 	.word	0x0811d5e0
 8113770:	0811d480 	.word	0x0811d480
 8113774:	10005518 	.word	0x10005518
 8113778:	0811d5f4 	.word	0x0811d5f4
 811377c:	0811d610 	.word	0x0811d610
 8113780:	0811d640 	.word	0x0811d640
 8113784:	0811d670 	.word	0x0811d670

08113788 <memp_init_pool>:
 *
 * @param desc pool to initialize
 */
void
memp_init_pool(const struct memp_desc *desc)
{
 8113788:	b480      	push	{r7}
 811378a:	b085      	sub	sp, #20
 811378c:	af00      	add	r7, sp, #0
 811378e:	6078      	str	r0, [r7, #4]
  LWIP_UNUSED_ARG(desc);
#else
  int i;
  struct memp *memp;

  *desc->tab = NULL;
 8113790:	687b      	ldr	r3, [r7, #4]
 8113792:	689b      	ldr	r3, [r3, #8]
 8113794:	2200      	movs	r2, #0
 8113796:	601a      	str	r2, [r3, #0]
  memp = (struct memp *)LWIP_MEM_ALIGN(desc->base);
 8113798:	687b      	ldr	r3, [r7, #4]
 811379a:	685b      	ldr	r3, [r3, #4]
 811379c:	3303      	adds	r3, #3
 811379e:	f023 0303 	bic.w	r3, r3, #3
 81137a2:	60bb      	str	r3, [r7, #8]
                                       + MEM_SANITY_REGION_AFTER_ALIGNED
#endif
                                      ));
#endif
  /* create a linked list of memp elements */
  for (i = 0; i < desc->num; ++i) {
 81137a4:	2300      	movs	r3, #0
 81137a6:	60fb      	str	r3, [r7, #12]
 81137a8:	e011      	b.n	81137ce <memp_init_pool+0x46>
    memp->next = *desc->tab;
 81137aa:	687b      	ldr	r3, [r7, #4]
 81137ac:	689b      	ldr	r3, [r3, #8]
 81137ae:	681a      	ldr	r2, [r3, #0]
 81137b0:	68bb      	ldr	r3, [r7, #8]
 81137b2:	601a      	str	r2, [r3, #0]
    *desc->tab = memp;
 81137b4:	687b      	ldr	r3, [r7, #4]
 81137b6:	689b      	ldr	r3, [r3, #8]
 81137b8:	68ba      	ldr	r2, [r7, #8]
 81137ba:	601a      	str	r2, [r3, #0]
#if MEMP_OVERFLOW_CHECK
    memp_overflow_init_element(memp, desc);
#endif /* MEMP_OVERFLOW_CHECK */
    /* cast through void* to get rid of alignment warnings */
    memp = (struct memp *)(void *)((u8_t *)memp + MEMP_SIZE + desc->size
 81137bc:	687b      	ldr	r3, [r7, #4]
 81137be:	881b      	ldrh	r3, [r3, #0]
 81137c0:	461a      	mov	r2, r3
 81137c2:	68bb      	ldr	r3, [r7, #8]
 81137c4:	4413      	add	r3, r2
 81137c6:	60bb      	str	r3, [r7, #8]
  for (i = 0; i < desc->num; ++i) {
 81137c8:	68fb      	ldr	r3, [r7, #12]
 81137ca:	3301      	adds	r3, #1
 81137cc:	60fb      	str	r3, [r7, #12]
 81137ce:	687b      	ldr	r3, [r7, #4]
 81137d0:	885b      	ldrh	r3, [r3, #2]
 81137d2:	461a      	mov	r2, r3
 81137d4:	68fb      	ldr	r3, [r7, #12]
 81137d6:	4293      	cmp	r3, r2
 81137d8:	dbe7      	blt.n	81137aa <memp_init_pool+0x22>
#endif /* !MEMP_MEM_MALLOC */

#if MEMP_STATS && (defined(LWIP_DEBUG) || LWIP_STATS_DISPLAY)
  desc->stats->name  = desc->desc;
#endif /* MEMP_STATS && (defined(LWIP_DEBUG) || LWIP_STATS_DISPLAY) */
}
 81137da:	bf00      	nop
 81137dc:	bf00      	nop
 81137de:	3714      	adds	r7, #20
 81137e0:	46bd      	mov	sp, r7
 81137e2:	f85d 7b04 	ldr.w	r7, [sp], #4
 81137e6:	4770      	bx	lr

081137e8 <memp_init>:
 *
 * Carves out memp_memory into linked lists for each pool-type.
 */
void
memp_init(void)
{
 81137e8:	b580      	push	{r7, lr}
 81137ea:	b082      	sub	sp, #8
 81137ec:	af00      	add	r7, sp, #0
  u16_t i;

  /* for every pool: */
  for (i = 0; i < LWIP_ARRAYSIZE(memp_pools); i++) {
 81137ee:	2300      	movs	r3, #0
 81137f0:	80fb      	strh	r3, [r7, #6]
 81137f2:	e009      	b.n	8113808 <memp_init+0x20>
    memp_init_pool(memp_pools[i]);
 81137f4:	88fb      	ldrh	r3, [r7, #6]
 81137f6:	4a08      	ldr	r2, [pc, #32]	; (8113818 <memp_init+0x30>)
 81137f8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 81137fc:	4618      	mov	r0, r3
 81137fe:	f7ff ffc3 	bl	8113788 <memp_init_pool>
  for (i = 0; i < LWIP_ARRAYSIZE(memp_pools); i++) {
 8113802:	88fb      	ldrh	r3, [r7, #6]
 8113804:	3301      	adds	r3, #1
 8113806:	80fb      	strh	r3, [r7, #6]
 8113808:	88fb      	ldrh	r3, [r7, #6]
 811380a:	2b08      	cmp	r3, #8
 811380c:	d9f2      	bls.n	81137f4 <memp_init+0xc>

#if MEMP_OVERFLOW_CHECK >= 2
  /* check everything a first time to see if it worked */
  memp_overflow_check_all();
#endif /* MEMP_OVERFLOW_CHECK >= 2 */
}
 811380e:	bf00      	nop
 8113810:	bf00      	nop
 8113812:	3708      	adds	r7, #8
 8113814:	46bd      	mov	sp, r7
 8113816:	bd80      	pop	{r7, pc}
 8113818:	0811f9a8 	.word	0x0811f9a8

0811381c <do_memp_malloc_pool>:
#if !MEMP_OVERFLOW_CHECK
do_memp_malloc_pool(const struct memp_desc *desc)
#else
do_memp_malloc_pool_fn(const struct memp_desc *desc, const char *file, const int line)
#endif
{
 811381c:	b580      	push	{r7, lr}
 811381e:	b084      	sub	sp, #16
 8113820:	af00      	add	r7, sp, #0
 8113822:	6078      	str	r0, [r7, #4]
  memp = (struct memp *)mem_malloc(MEMP_SIZE + MEMP_ALIGN_SIZE(desc->size));
  SYS_ARCH_PROTECT(old_level);
#else /* MEMP_MEM_MALLOC */
  SYS_ARCH_PROTECT(old_level);

  memp = *desc->tab;
 8113824:	687b      	ldr	r3, [r7, #4]
 8113826:	689b      	ldr	r3, [r3, #8]
 8113828:	681b      	ldr	r3, [r3, #0]
 811382a:	60fb      	str	r3, [r7, #12]
#endif /* MEMP_MEM_MALLOC */

  if (memp != NULL) {
 811382c:	68fb      	ldr	r3, [r7, #12]
 811382e:	2b00      	cmp	r3, #0
 8113830:	d012      	beq.n	8113858 <do_memp_malloc_pool+0x3c>
#if !MEMP_MEM_MALLOC
#if MEMP_OVERFLOW_CHECK == 1
    memp_overflow_check_element(memp, desc);
#endif /* MEMP_OVERFLOW_CHECK */

    *desc->tab = memp->next;
 8113832:	687b      	ldr	r3, [r7, #4]
 8113834:	689b      	ldr	r3, [r3, #8]
 8113836:	68fa      	ldr	r2, [r7, #12]
 8113838:	6812      	ldr	r2, [r2, #0]
 811383a:	601a      	str	r2, [r3, #0]
    memp->line = line;
#if MEMP_MEM_MALLOC
    memp_overflow_init_element(memp, desc);
#endif /* MEMP_MEM_MALLOC */
#endif /* MEMP_OVERFLOW_CHECK */
    LWIP_ASSERT("memp_malloc: memp properly aligned",
 811383c:	68fb      	ldr	r3, [r7, #12]
 811383e:	f003 0303 	and.w	r3, r3, #3
 8113842:	2b00      	cmp	r3, #0
 8113844:	d006      	beq.n	8113854 <do_memp_malloc_pool+0x38>
 8113846:	4b07      	ldr	r3, [pc, #28]	; (8113864 <do_memp_malloc_pool+0x48>)
 8113848:	f44f 728c 	mov.w	r2, #280	; 0x118
 811384c:	4906      	ldr	r1, [pc, #24]	; (8113868 <do_memp_malloc_pool+0x4c>)
 811384e:	4807      	ldr	r0, [pc, #28]	; (811386c <do_memp_malloc_pool+0x50>)
 8113850:	f007 ffd6 	bl	811b800 <iprintf>
      desc->stats->max = desc->stats->used;
    }
#endif
    SYS_ARCH_UNPROTECT(old_level);
    /* cast through u8_t* to get rid of alignment warnings */
    return ((u8_t *)memp + MEMP_SIZE);
 8113854:	68fb      	ldr	r3, [r7, #12]
 8113856:	e000      	b.n	811385a <do_memp_malloc_pool+0x3e>
#endif
    SYS_ARCH_UNPROTECT(old_level);
    LWIP_DEBUGF(MEMP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("memp_malloc: out of memory in pool %s\n", desc->desc));
  }

  return NULL;
 8113858:	2300      	movs	r3, #0
}
 811385a:	4618      	mov	r0, r3
 811385c:	3710      	adds	r7, #16
 811385e:	46bd      	mov	sp, r7
 8113860:	bd80      	pop	{r7, pc}
 8113862:	bf00      	nop
 8113864:	0811d694 	.word	0x0811d694
 8113868:	0811d6f8 	.word	0x0811d6f8
 811386c:	0811d71c 	.word	0x0811d71c

08113870 <memp_malloc_pool>:
#if !MEMP_OVERFLOW_CHECK
memp_malloc_pool(const struct memp_desc *desc)
#else
memp_malloc_pool_fn(const struct memp_desc *desc, const char *file, const int line)
#endif
{
 8113870:	b580      	push	{r7, lr}
 8113872:	b082      	sub	sp, #8
 8113874:	af00      	add	r7, sp, #0
 8113876:	6078      	str	r0, [r7, #4]
  LWIP_ASSERT("invalid pool desc", desc != NULL);
 8113878:	687b      	ldr	r3, [r7, #4]
 811387a:	2b00      	cmp	r3, #0
 811387c:	d106      	bne.n	811388c <memp_malloc_pool+0x1c>
 811387e:	4b0a      	ldr	r3, [pc, #40]	; (81138a8 <memp_malloc_pool+0x38>)
 8113880:	f44f 729e 	mov.w	r2, #316	; 0x13c
 8113884:	4909      	ldr	r1, [pc, #36]	; (81138ac <memp_malloc_pool+0x3c>)
 8113886:	480a      	ldr	r0, [pc, #40]	; (81138b0 <memp_malloc_pool+0x40>)
 8113888:	f007 ffba 	bl	811b800 <iprintf>
  if (desc == NULL) {
 811388c:	687b      	ldr	r3, [r7, #4]
 811388e:	2b00      	cmp	r3, #0
 8113890:	d101      	bne.n	8113896 <memp_malloc_pool+0x26>
    return NULL;
 8113892:	2300      	movs	r3, #0
 8113894:	e003      	b.n	811389e <memp_malloc_pool+0x2e>
  }

#if !MEMP_OVERFLOW_CHECK
  return do_memp_malloc_pool(desc);
 8113896:	6878      	ldr	r0, [r7, #4]
 8113898:	f7ff ffc0 	bl	811381c <do_memp_malloc_pool>
 811389c:	4603      	mov	r3, r0
#else
  return do_memp_malloc_pool_fn(desc, file, line);
#endif
}
 811389e:	4618      	mov	r0, r3
 81138a0:	3708      	adds	r7, #8
 81138a2:	46bd      	mov	sp, r7
 81138a4:	bd80      	pop	{r7, pc}
 81138a6:	bf00      	nop
 81138a8:	0811d694 	.word	0x0811d694
 81138ac:	0811d744 	.word	0x0811d744
 81138b0:	0811d71c 	.word	0x0811d71c

081138b4 <memp_malloc>:
#if !MEMP_OVERFLOW_CHECK
memp_malloc(memp_t type)
#else
memp_malloc_fn(memp_t type, const char *file, const int line)
#endif
{
 81138b4:	b580      	push	{r7, lr}
 81138b6:	b084      	sub	sp, #16
 81138b8:	af00      	add	r7, sp, #0
 81138ba:	4603      	mov	r3, r0
 81138bc:	71fb      	strb	r3, [r7, #7]
  void *memp;
  LWIP_ERROR("memp_malloc: type < MEMP_MAX", (type < MEMP_MAX), return NULL;);
 81138be:	79fb      	ldrb	r3, [r7, #7]
 81138c0:	2b08      	cmp	r3, #8
 81138c2:	d908      	bls.n	81138d6 <memp_malloc+0x22>
 81138c4:	4b0a      	ldr	r3, [pc, #40]	; (81138f0 <memp_malloc+0x3c>)
 81138c6:	f240 1257 	movw	r2, #343	; 0x157
 81138ca:	490a      	ldr	r1, [pc, #40]	; (81138f4 <memp_malloc+0x40>)
 81138cc:	480a      	ldr	r0, [pc, #40]	; (81138f8 <memp_malloc+0x44>)
 81138ce:	f007 ff97 	bl	811b800 <iprintf>
 81138d2:	2300      	movs	r3, #0
 81138d4:	e008      	b.n	81138e8 <memp_malloc+0x34>
#if MEMP_OVERFLOW_CHECK >= 2
  memp_overflow_check_all();
#endif /* MEMP_OVERFLOW_CHECK >= 2 */

#if !MEMP_OVERFLOW_CHECK
  memp = do_memp_malloc_pool(memp_pools[type]);
 81138d6:	79fb      	ldrb	r3, [r7, #7]
 81138d8:	4a08      	ldr	r2, [pc, #32]	; (81138fc <memp_malloc+0x48>)
 81138da:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 81138de:	4618      	mov	r0, r3
 81138e0:	f7ff ff9c 	bl	811381c <do_memp_malloc_pool>
 81138e4:	60f8      	str	r0, [r7, #12]
#else
  memp = do_memp_malloc_pool_fn(memp_pools[type], file, line);
#endif

  return memp;
 81138e6:	68fb      	ldr	r3, [r7, #12]
}
 81138e8:	4618      	mov	r0, r3
 81138ea:	3710      	adds	r7, #16
 81138ec:	46bd      	mov	sp, r7
 81138ee:	bd80      	pop	{r7, pc}
 81138f0:	0811d694 	.word	0x0811d694
 81138f4:	0811d758 	.word	0x0811d758
 81138f8:	0811d71c 	.word	0x0811d71c
 81138fc:	0811f9a8 	.word	0x0811f9a8

08113900 <do_memp_free_pool>:

static void
do_memp_free_pool(const struct memp_desc *desc, void *mem)
{
 8113900:	b580      	push	{r7, lr}
 8113902:	b084      	sub	sp, #16
 8113904:	af00      	add	r7, sp, #0
 8113906:	6078      	str	r0, [r7, #4]
 8113908:	6039      	str	r1, [r7, #0]
  struct memp *memp;
  SYS_ARCH_DECL_PROTECT(old_level);

  LWIP_ASSERT("memp_free: mem properly aligned",
 811390a:	683b      	ldr	r3, [r7, #0]
 811390c:	f003 0303 	and.w	r3, r3, #3
 8113910:	2b00      	cmp	r3, #0
 8113912:	d006      	beq.n	8113922 <do_memp_free_pool+0x22>
 8113914:	4b0a      	ldr	r3, [pc, #40]	; (8113940 <do_memp_free_pool+0x40>)
 8113916:	f44f 72b6 	mov.w	r2, #364	; 0x16c
 811391a:	490a      	ldr	r1, [pc, #40]	; (8113944 <do_memp_free_pool+0x44>)
 811391c:	480a      	ldr	r0, [pc, #40]	; (8113948 <do_memp_free_pool+0x48>)
 811391e:	f007 ff6f 	bl	811b800 <iprintf>
              ((mem_ptr_t)mem % MEM_ALIGNMENT) == 0);

  /* cast through void* to get rid of alignment warnings */
  memp = (struct memp *)(void *)((u8_t *)mem - MEMP_SIZE);
 8113922:	683b      	ldr	r3, [r7, #0]
 8113924:	60fb      	str	r3, [r7, #12]
#if MEMP_MEM_MALLOC
  LWIP_UNUSED_ARG(desc);
  SYS_ARCH_UNPROTECT(old_level);
  mem_free(memp);
#else /* MEMP_MEM_MALLOC */
  memp->next = *desc->tab;
 8113926:	687b      	ldr	r3, [r7, #4]
 8113928:	689b      	ldr	r3, [r3, #8]
 811392a:	681a      	ldr	r2, [r3, #0]
 811392c:	68fb      	ldr	r3, [r7, #12]
 811392e:	601a      	str	r2, [r3, #0]
  *desc->tab = memp;
 8113930:	687b      	ldr	r3, [r7, #4]
 8113932:	689b      	ldr	r3, [r3, #8]
 8113934:	68fa      	ldr	r2, [r7, #12]
 8113936:	601a      	str	r2, [r3, #0]
  LWIP_ASSERT("memp sanity", memp_sanity(desc));
#endif /* MEMP_SANITY_CHECK */

  SYS_ARCH_UNPROTECT(old_level);
#endif /* !MEMP_MEM_MALLOC */
}
 8113938:	bf00      	nop
 811393a:	3710      	adds	r7, #16
 811393c:	46bd      	mov	sp, r7
 811393e:	bd80      	pop	{r7, pc}
 8113940:	0811d694 	.word	0x0811d694
 8113944:	0811d778 	.word	0x0811d778
 8113948:	0811d71c 	.word	0x0811d71c

0811394c <memp_free_pool>:
 * @param desc the pool where to put mem
 * @param mem the memp element to free
 */
void
memp_free_pool(const struct memp_desc *desc, void *mem)
{
 811394c:	b580      	push	{r7, lr}
 811394e:	b082      	sub	sp, #8
 8113950:	af00      	add	r7, sp, #0
 8113952:	6078      	str	r0, [r7, #4]
 8113954:	6039      	str	r1, [r7, #0]
  LWIP_ASSERT("invalid pool desc", desc != NULL);
 8113956:	687b      	ldr	r3, [r7, #4]
 8113958:	2b00      	cmp	r3, #0
 811395a:	d106      	bne.n	811396a <memp_free_pool+0x1e>
 811395c:	4b0a      	ldr	r3, [pc, #40]	; (8113988 <memp_free_pool+0x3c>)
 811395e:	f240 1295 	movw	r2, #405	; 0x195
 8113962:	490a      	ldr	r1, [pc, #40]	; (811398c <memp_free_pool+0x40>)
 8113964:	480a      	ldr	r0, [pc, #40]	; (8113990 <memp_free_pool+0x44>)
 8113966:	f007 ff4b 	bl	811b800 <iprintf>
  if ((desc == NULL) || (mem == NULL)) {
 811396a:	687b      	ldr	r3, [r7, #4]
 811396c:	2b00      	cmp	r3, #0
 811396e:	d007      	beq.n	8113980 <memp_free_pool+0x34>
 8113970:	683b      	ldr	r3, [r7, #0]
 8113972:	2b00      	cmp	r3, #0
 8113974:	d004      	beq.n	8113980 <memp_free_pool+0x34>
    return;
  }

  do_memp_free_pool(desc, mem);
 8113976:	6839      	ldr	r1, [r7, #0]
 8113978:	6878      	ldr	r0, [r7, #4]
 811397a:	f7ff ffc1 	bl	8113900 <do_memp_free_pool>
 811397e:	e000      	b.n	8113982 <memp_free_pool+0x36>
    return;
 8113980:	bf00      	nop
}
 8113982:	3708      	adds	r7, #8
 8113984:	46bd      	mov	sp, r7
 8113986:	bd80      	pop	{r7, pc}
 8113988:	0811d694 	.word	0x0811d694
 811398c:	0811d744 	.word	0x0811d744
 8113990:	0811d71c 	.word	0x0811d71c

08113994 <memp_free>:
 * @param type the pool where to put mem
 * @param mem the memp element to free
 */
void
memp_free(memp_t type, void *mem)
{
 8113994:	b580      	push	{r7, lr}
 8113996:	b082      	sub	sp, #8
 8113998:	af00      	add	r7, sp, #0
 811399a:	4603      	mov	r3, r0
 811399c:	6039      	str	r1, [r7, #0]
 811399e:	71fb      	strb	r3, [r7, #7]
#ifdef LWIP_HOOK_MEMP_AVAILABLE
  struct memp *old_first;
#endif

  LWIP_ERROR("memp_free: type < MEMP_MAX", (type < MEMP_MAX), return;);
 81139a0:	79fb      	ldrb	r3, [r7, #7]
 81139a2:	2b08      	cmp	r3, #8
 81139a4:	d907      	bls.n	81139b6 <memp_free+0x22>
 81139a6:	4b0c      	ldr	r3, [pc, #48]	; (81139d8 <memp_free+0x44>)
 81139a8:	f44f 72d5 	mov.w	r2, #426	; 0x1aa
 81139ac:	490b      	ldr	r1, [pc, #44]	; (81139dc <memp_free+0x48>)
 81139ae:	480c      	ldr	r0, [pc, #48]	; (81139e0 <memp_free+0x4c>)
 81139b0:	f007 ff26 	bl	811b800 <iprintf>
 81139b4:	e00c      	b.n	81139d0 <memp_free+0x3c>

  if (mem == NULL) {
 81139b6:	683b      	ldr	r3, [r7, #0]
 81139b8:	2b00      	cmp	r3, #0
 81139ba:	d008      	beq.n	81139ce <memp_free+0x3a>

#ifdef LWIP_HOOK_MEMP_AVAILABLE
  old_first = *memp_pools[type]->tab;
#endif

  do_memp_free_pool(memp_pools[type], mem);
 81139bc:	79fb      	ldrb	r3, [r7, #7]
 81139be:	4a09      	ldr	r2, [pc, #36]	; (81139e4 <memp_free+0x50>)
 81139c0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 81139c4:	6839      	ldr	r1, [r7, #0]
 81139c6:	4618      	mov	r0, r3
 81139c8:	f7ff ff9a 	bl	8113900 <do_memp_free_pool>
 81139cc:	e000      	b.n	81139d0 <memp_free+0x3c>
    return;
 81139ce:	bf00      	nop
#ifdef LWIP_HOOK_MEMP_AVAILABLE
  if (old_first == NULL) {
    LWIP_HOOK_MEMP_AVAILABLE(type);
  }
#endif
}
 81139d0:	3708      	adds	r7, #8
 81139d2:	46bd      	mov	sp, r7
 81139d4:	bd80      	pop	{r7, pc}
 81139d6:	bf00      	nop
 81139d8:	0811d694 	.word	0x0811d694
 81139dc:	0811d798 	.word	0x0811d798
 81139e0:	0811d71c 	.word	0x0811d71c
 81139e4:	0811f9a8 	.word	0x0811f9a8

081139e8 <netif_init>:
}
#endif /* LWIP_HAVE_LOOPIF */

void
netif_init(void)
{
 81139e8:	b480      	push	{r7}
 81139ea:	af00      	add	r7, sp, #0

  netif_set_link_up(&loop_netif);
  netif_set_up(&loop_netif);

#endif /* LWIP_HAVE_LOOPIF */
}
 81139ec:	bf00      	nop
 81139ee:	46bd      	mov	sp, r7
 81139f0:	f85d 7b04 	ldr.w	r7, [sp], #4
 81139f4:	4770      	bx	lr
	...

081139f8 <netif_add>:
netif_add(struct netif *netif,
#if LWIP_IPV4
          const ip4_addr_t *ipaddr, const ip4_addr_t *netmask, const ip4_addr_t *gw,
#endif /* LWIP_IPV4 */
          void *state, netif_init_fn init, netif_input_fn input)
{
 81139f8:	b580      	push	{r7, lr}
 81139fa:	b086      	sub	sp, #24
 81139fc:	af00      	add	r7, sp, #0
 81139fe:	60f8      	str	r0, [r7, #12]
 8113a00:	60b9      	str	r1, [r7, #8]
 8113a02:	607a      	str	r2, [r7, #4]
 8113a04:	603b      	str	r3, [r7, #0]
    LWIP_ASSERT("single netif already set", 0);
    return NULL;
  }
#endif

  LWIP_ERROR("netif_add: invalid netif", netif != NULL, return NULL);
 8113a06:	68fb      	ldr	r3, [r7, #12]
 8113a08:	2b00      	cmp	r3, #0
 8113a0a:	d108      	bne.n	8113a1e <netif_add+0x26>
 8113a0c:	4b5b      	ldr	r3, [pc, #364]	; (8113b7c <netif_add+0x184>)
 8113a0e:	f240 1227 	movw	r2, #295	; 0x127
 8113a12:	495b      	ldr	r1, [pc, #364]	; (8113b80 <netif_add+0x188>)
 8113a14:	485b      	ldr	r0, [pc, #364]	; (8113b84 <netif_add+0x18c>)
 8113a16:	f007 fef3 	bl	811b800 <iprintf>
 8113a1a:	2300      	movs	r3, #0
 8113a1c:	e0a9      	b.n	8113b72 <netif_add+0x17a>
  LWIP_ERROR("netif_add: No init function given", init != NULL, return NULL);
 8113a1e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8113a20:	2b00      	cmp	r3, #0
 8113a22:	d108      	bne.n	8113a36 <netif_add+0x3e>
 8113a24:	4b55      	ldr	r3, [pc, #340]	; (8113b7c <netif_add+0x184>)
 8113a26:	f44f 7294 	mov.w	r2, #296	; 0x128
 8113a2a:	4957      	ldr	r1, [pc, #348]	; (8113b88 <netif_add+0x190>)
 8113a2c:	4855      	ldr	r0, [pc, #340]	; (8113b84 <netif_add+0x18c>)
 8113a2e:	f007 fee7 	bl	811b800 <iprintf>
 8113a32:	2300      	movs	r3, #0
 8113a34:	e09d      	b.n	8113b72 <netif_add+0x17a>

#if LWIP_IPV4
  if (ipaddr == NULL) {
 8113a36:	68bb      	ldr	r3, [r7, #8]
 8113a38:	2b00      	cmp	r3, #0
 8113a3a:	d101      	bne.n	8113a40 <netif_add+0x48>
    ipaddr = ip_2_ip4(IP4_ADDR_ANY);
 8113a3c:	4b53      	ldr	r3, [pc, #332]	; (8113b8c <netif_add+0x194>)
 8113a3e:	60bb      	str	r3, [r7, #8]
  }
  if (netmask == NULL) {
 8113a40:	687b      	ldr	r3, [r7, #4]
 8113a42:	2b00      	cmp	r3, #0
 8113a44:	d101      	bne.n	8113a4a <netif_add+0x52>
    netmask = ip_2_ip4(IP4_ADDR_ANY);
 8113a46:	4b51      	ldr	r3, [pc, #324]	; (8113b8c <netif_add+0x194>)
 8113a48:	607b      	str	r3, [r7, #4]
  }
  if (gw == NULL) {
 8113a4a:	683b      	ldr	r3, [r7, #0]
 8113a4c:	2b00      	cmp	r3, #0
 8113a4e:	d101      	bne.n	8113a54 <netif_add+0x5c>
    gw = ip_2_ip4(IP4_ADDR_ANY);
 8113a50:	4b4e      	ldr	r3, [pc, #312]	; (8113b8c <netif_add+0x194>)
 8113a52:	603b      	str	r3, [r7, #0]
  }

  /* reset new interface configuration state */
  ip_addr_set_zero_ip4(&netif->ip_addr);
 8113a54:	68fb      	ldr	r3, [r7, #12]
 8113a56:	2200      	movs	r2, #0
 8113a58:	605a      	str	r2, [r3, #4]
  ip_addr_set_zero_ip4(&netif->netmask);
 8113a5a:	68fb      	ldr	r3, [r7, #12]
 8113a5c:	2200      	movs	r2, #0
 8113a5e:	609a      	str	r2, [r3, #8]
  ip_addr_set_zero_ip4(&netif->gw);
 8113a60:	68fb      	ldr	r3, [r7, #12]
 8113a62:	2200      	movs	r2, #0
 8113a64:	60da      	str	r2, [r3, #12]
  netif->output = netif_null_output_ip4;
 8113a66:	68fb      	ldr	r3, [r7, #12]
 8113a68:	4a49      	ldr	r2, [pc, #292]	; (8113b90 <netif_add+0x198>)
 8113a6a:	615a      	str	r2, [r3, #20]
#endif /* LWIP_IPV6_ADDRESS_LIFETIMES */
  }
  netif->output_ip6 = netif_null_output_ip6;
#endif /* LWIP_IPV6 */
  NETIF_SET_CHECKSUM_CTRL(netif, NETIF_CHECKSUM_ENABLE_ALL);
  netif->mtu = 0;
 8113a6c:	68fb      	ldr	r3, [r7, #12]
 8113a6e:	2200      	movs	r2, #0
 8113a70:	851a      	strh	r2, [r3, #40]	; 0x28
  netif->flags = 0;
 8113a72:	68fb      	ldr	r3, [r7, #12]
 8113a74:	2200      	movs	r2, #0
 8113a76:	f883 2031 	strb.w	r2, [r3, #49]	; 0x31
#ifdef netif_get_client_data
  memset(netif->client_data, 0, sizeof(netif->client_data));
 8113a7a:	68fb      	ldr	r3, [r7, #12]
 8113a7c:	3324      	adds	r3, #36	; 0x24
 8113a7e:	2204      	movs	r2, #4
 8113a80:	2100      	movs	r1, #0
 8113a82:	4618      	mov	r0, r3
 8113a84:	f007 fee6 	bl	811b854 <memset>
#endif /* LWIP_IPV6 */
#if LWIP_NETIF_STATUS_CALLBACK
  netif->status_callback = NULL;
#endif /* LWIP_NETIF_STATUS_CALLBACK */
#if LWIP_NETIF_LINK_CALLBACK
  netif->link_callback = NULL;
 8113a88:	68fb      	ldr	r3, [r7, #12]
 8113a8a:	2200      	movs	r2, #0
 8113a8c:	61da      	str	r2, [r3, #28]
  netif->loop_first = NULL;
  netif->loop_last = NULL;
#endif /* ENABLE_LOOPBACK */

  /* remember netif specific state information data */
  netif->state = state;
 8113a8e:	68fb      	ldr	r3, [r7, #12]
 8113a90:	6a3a      	ldr	r2, [r7, #32]
 8113a92:	621a      	str	r2, [r3, #32]
  netif->num = netif_num;
 8113a94:	4b3f      	ldr	r3, [pc, #252]	; (8113b94 <netif_add+0x19c>)
 8113a96:	781a      	ldrb	r2, [r3, #0]
 8113a98:	68fb      	ldr	r3, [r7, #12]
 8113a9a:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34
  netif->input = input;
 8113a9e:	68fb      	ldr	r3, [r7, #12]
 8113aa0:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8113aa2:	611a      	str	r2, [r3, #16]
#if ENABLE_LOOPBACK && LWIP_LOOPBACK_MAX_PBUFS
  netif->loop_cnt_current = 0;
#endif /* ENABLE_LOOPBACK && LWIP_LOOPBACK_MAX_PBUFS */

#if LWIP_IPV4
  netif_set_addr(netif, ipaddr, netmask, gw);
 8113aa4:	683b      	ldr	r3, [r7, #0]
 8113aa6:	687a      	ldr	r2, [r7, #4]
 8113aa8:	68b9      	ldr	r1, [r7, #8]
 8113aaa:	68f8      	ldr	r0, [r7, #12]
 8113aac:	f000 f914 	bl	8113cd8 <netif_set_addr>
#endif /* LWIP_IPV4 */

  /* call user specified initialization function for netif */
  if (init(netif) != ERR_OK) {
 8113ab0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8113ab2:	68f8      	ldr	r0, [r7, #12]
 8113ab4:	4798      	blx	r3
 8113ab6:	4603      	mov	r3, r0
 8113ab8:	2b00      	cmp	r3, #0
 8113aba:	d001      	beq.n	8113ac0 <netif_add+0xc8>
    return NULL;
 8113abc:	2300      	movs	r3, #0
 8113abe:	e058      	b.n	8113b72 <netif_add+0x17a>
     */
  {
    struct netif *netif2;
    int num_netifs;
    do {
      if (netif->num == 255) {
 8113ac0:	68fb      	ldr	r3, [r7, #12]
 8113ac2:	f893 3034 	ldrb.w	r3, [r3, #52]	; 0x34
 8113ac6:	2bff      	cmp	r3, #255	; 0xff
 8113ac8:	d103      	bne.n	8113ad2 <netif_add+0xda>
        netif->num = 0;
 8113aca:	68fb      	ldr	r3, [r7, #12]
 8113acc:	2200      	movs	r2, #0
 8113ace:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34
      }
      num_netifs = 0;
 8113ad2:	2300      	movs	r3, #0
 8113ad4:	613b      	str	r3, [r7, #16]
      for (netif2 = netif_list; netif2 != NULL; netif2 = netif2->next) {
 8113ad6:	4b30      	ldr	r3, [pc, #192]	; (8113b98 <netif_add+0x1a0>)
 8113ad8:	681b      	ldr	r3, [r3, #0]
 8113ada:	617b      	str	r3, [r7, #20]
 8113adc:	e02b      	b.n	8113b36 <netif_add+0x13e>
        LWIP_ASSERT("netif already added", netif2 != netif);
 8113ade:	697a      	ldr	r2, [r7, #20]
 8113ae0:	68fb      	ldr	r3, [r7, #12]
 8113ae2:	429a      	cmp	r2, r3
 8113ae4:	d106      	bne.n	8113af4 <netif_add+0xfc>
 8113ae6:	4b25      	ldr	r3, [pc, #148]	; (8113b7c <netif_add+0x184>)
 8113ae8:	f240 128b 	movw	r2, #395	; 0x18b
 8113aec:	492b      	ldr	r1, [pc, #172]	; (8113b9c <netif_add+0x1a4>)
 8113aee:	4825      	ldr	r0, [pc, #148]	; (8113b84 <netif_add+0x18c>)
 8113af0:	f007 fe86 	bl	811b800 <iprintf>
        num_netifs++;
 8113af4:	693b      	ldr	r3, [r7, #16]
 8113af6:	3301      	adds	r3, #1
 8113af8:	613b      	str	r3, [r7, #16]
        LWIP_ASSERT("too many netifs, max. supported number is 255", num_netifs <= 255);
 8113afa:	693b      	ldr	r3, [r7, #16]
 8113afc:	2bff      	cmp	r3, #255	; 0xff
 8113afe:	dd06      	ble.n	8113b0e <netif_add+0x116>
 8113b00:	4b1e      	ldr	r3, [pc, #120]	; (8113b7c <netif_add+0x184>)
 8113b02:	f240 128d 	movw	r2, #397	; 0x18d
 8113b06:	4926      	ldr	r1, [pc, #152]	; (8113ba0 <netif_add+0x1a8>)
 8113b08:	481e      	ldr	r0, [pc, #120]	; (8113b84 <netif_add+0x18c>)
 8113b0a:	f007 fe79 	bl	811b800 <iprintf>
        if (netif2->num == netif->num) {
 8113b0e:	697b      	ldr	r3, [r7, #20]
 8113b10:	f893 2034 	ldrb.w	r2, [r3, #52]	; 0x34
 8113b14:	68fb      	ldr	r3, [r7, #12]
 8113b16:	f893 3034 	ldrb.w	r3, [r3, #52]	; 0x34
 8113b1a:	429a      	cmp	r2, r3
 8113b1c:	d108      	bne.n	8113b30 <netif_add+0x138>
          netif->num++;
 8113b1e:	68fb      	ldr	r3, [r7, #12]
 8113b20:	f893 3034 	ldrb.w	r3, [r3, #52]	; 0x34
 8113b24:	3301      	adds	r3, #1
 8113b26:	b2da      	uxtb	r2, r3
 8113b28:	68fb      	ldr	r3, [r7, #12]
 8113b2a:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34
          break;
 8113b2e:	e005      	b.n	8113b3c <netif_add+0x144>
      for (netif2 = netif_list; netif2 != NULL; netif2 = netif2->next) {
 8113b30:	697b      	ldr	r3, [r7, #20]
 8113b32:	681b      	ldr	r3, [r3, #0]
 8113b34:	617b      	str	r3, [r7, #20]
 8113b36:	697b      	ldr	r3, [r7, #20]
 8113b38:	2b00      	cmp	r3, #0
 8113b3a:	d1d0      	bne.n	8113ade <netif_add+0xe6>
        }
      }
    } while (netif2 != NULL);
 8113b3c:	697b      	ldr	r3, [r7, #20]
 8113b3e:	2b00      	cmp	r3, #0
 8113b40:	d1be      	bne.n	8113ac0 <netif_add+0xc8>
  }
  if (netif->num == 254) {
 8113b42:	68fb      	ldr	r3, [r7, #12]
 8113b44:	f893 3034 	ldrb.w	r3, [r3, #52]	; 0x34
 8113b48:	2bfe      	cmp	r3, #254	; 0xfe
 8113b4a:	d103      	bne.n	8113b54 <netif_add+0x15c>
    netif_num = 0;
 8113b4c:	4b11      	ldr	r3, [pc, #68]	; (8113b94 <netif_add+0x19c>)
 8113b4e:	2200      	movs	r2, #0
 8113b50:	701a      	strb	r2, [r3, #0]
 8113b52:	e006      	b.n	8113b62 <netif_add+0x16a>
  } else {
    netif_num = (u8_t)(netif->num + 1);
 8113b54:	68fb      	ldr	r3, [r7, #12]
 8113b56:	f893 3034 	ldrb.w	r3, [r3, #52]	; 0x34
 8113b5a:	3301      	adds	r3, #1
 8113b5c:	b2da      	uxtb	r2, r3
 8113b5e:	4b0d      	ldr	r3, [pc, #52]	; (8113b94 <netif_add+0x19c>)
 8113b60:	701a      	strb	r2, [r3, #0]
  }

  /* add this netif to the list */
  netif->next = netif_list;
 8113b62:	4b0d      	ldr	r3, [pc, #52]	; (8113b98 <netif_add+0x1a0>)
 8113b64:	681a      	ldr	r2, [r3, #0]
 8113b66:	68fb      	ldr	r3, [r7, #12]
 8113b68:	601a      	str	r2, [r3, #0]
  netif_list = netif;
 8113b6a:	4a0b      	ldr	r2, [pc, #44]	; (8113b98 <netif_add+0x1a0>)
 8113b6c:	68fb      	ldr	r3, [r7, #12]
 8113b6e:	6013      	str	r3, [r2, #0]
#endif /* LWIP_IPV4 */
  LWIP_DEBUGF(NETIF_DEBUG, ("\n"));

  netif_invoke_ext_callback(netif, LWIP_NSC_NETIF_ADDED, NULL);

  return netif;
 8113b70:	68fb      	ldr	r3, [r7, #12]
}
 8113b72:	4618      	mov	r0, r3
 8113b74:	3718      	adds	r7, #24
 8113b76:	46bd      	mov	sp, r7
 8113b78:	bd80      	pop	{r7, pc}
 8113b7a:	bf00      	nop
 8113b7c:	0811d7b4 	.word	0x0811d7b4
 8113b80:	0811d878 	.word	0x0811d878
 8113b84:	0811d834 	.word	0x0811d834
 8113b88:	0811d894 	.word	0x0811d894
 8113b8c:	0811f934 	.word	0x0811f934
 8113b90:	08113fbb 	.word	0x08113fbb
 8113b94:	10008444 	.word	0x10008444
 8113b98:	1000843c 	.word	0x1000843c
 8113b9c:	0811d8b8 	.word	0x0811d8b8
 8113ba0:	0811d8cc 	.word	0x0811d8cc

08113ba4 <netif_do_ip_addr_changed>:

static void
netif_do_ip_addr_changed(const ip_addr_t *old_addr, const ip_addr_t *new_addr)
{
 8113ba4:	b580      	push	{r7, lr}
 8113ba6:	b082      	sub	sp, #8
 8113ba8:	af00      	add	r7, sp, #0
 8113baa:	6078      	str	r0, [r7, #4]
 8113bac:	6039      	str	r1, [r7, #0]
#if LWIP_TCP
  tcp_netif_ip_addr_changed(old_addr, new_addr);
 8113bae:	6839      	ldr	r1, [r7, #0]
 8113bb0:	6878      	ldr	r0, [r7, #4]
 8113bb2:	f002 fc91 	bl	81164d8 <tcp_netif_ip_addr_changed>
#endif /* LWIP_TCP */
#if LWIP_UDP
  udp_netif_ip_addr_changed(old_addr, new_addr);
 8113bb6:	6839      	ldr	r1, [r7, #0]
 8113bb8:	6878      	ldr	r0, [r7, #4]
 8113bba:	f007 f891 	bl	811ace0 <udp_netif_ip_addr_changed>
#endif /* LWIP_UDP */
#if LWIP_RAW
  raw_netif_ip_addr_changed(old_addr, new_addr);
#endif /* LWIP_RAW */
}
 8113bbe:	bf00      	nop
 8113bc0:	3708      	adds	r7, #8
 8113bc2:	46bd      	mov	sp, r7
 8113bc4:	bd80      	pop	{r7, pc}
	...

08113bc8 <netif_do_set_ipaddr>:

#if LWIP_IPV4
static int
netif_do_set_ipaddr(struct netif *netif, const ip4_addr_t *ipaddr, ip_addr_t *old_addr)
{
 8113bc8:	b580      	push	{r7, lr}
 8113bca:	b086      	sub	sp, #24
 8113bcc:	af00      	add	r7, sp, #0
 8113bce:	60f8      	str	r0, [r7, #12]
 8113bd0:	60b9      	str	r1, [r7, #8]
 8113bd2:	607a      	str	r2, [r7, #4]
  LWIP_ASSERT("invalid pointer", ipaddr != NULL);
 8113bd4:	68bb      	ldr	r3, [r7, #8]
 8113bd6:	2b00      	cmp	r3, #0
 8113bd8:	d106      	bne.n	8113be8 <netif_do_set_ipaddr+0x20>
 8113bda:	4b1d      	ldr	r3, [pc, #116]	; (8113c50 <netif_do_set_ipaddr+0x88>)
 8113bdc:	f240 12cb 	movw	r2, #459	; 0x1cb
 8113be0:	491c      	ldr	r1, [pc, #112]	; (8113c54 <netif_do_set_ipaddr+0x8c>)
 8113be2:	481d      	ldr	r0, [pc, #116]	; (8113c58 <netif_do_set_ipaddr+0x90>)
 8113be4:	f007 fe0c 	bl	811b800 <iprintf>
  LWIP_ASSERT("invalid pointer", old_addr != NULL);
 8113be8:	687b      	ldr	r3, [r7, #4]
 8113bea:	2b00      	cmp	r3, #0
 8113bec:	d106      	bne.n	8113bfc <netif_do_set_ipaddr+0x34>
 8113bee:	4b18      	ldr	r3, [pc, #96]	; (8113c50 <netif_do_set_ipaddr+0x88>)
 8113bf0:	f44f 72e6 	mov.w	r2, #460	; 0x1cc
 8113bf4:	4917      	ldr	r1, [pc, #92]	; (8113c54 <netif_do_set_ipaddr+0x8c>)
 8113bf6:	4818      	ldr	r0, [pc, #96]	; (8113c58 <netif_do_set_ipaddr+0x90>)
 8113bf8:	f007 fe02 	bl	811b800 <iprintf>

  /* address is actually being changed? */
  if (ip4_addr_cmp(ipaddr, netif_ip4_addr(netif)) == 0) {
 8113bfc:	68bb      	ldr	r3, [r7, #8]
 8113bfe:	681a      	ldr	r2, [r3, #0]
 8113c00:	68fb      	ldr	r3, [r7, #12]
 8113c02:	3304      	adds	r3, #4
 8113c04:	681b      	ldr	r3, [r3, #0]
 8113c06:	429a      	cmp	r2, r3
 8113c08:	d01c      	beq.n	8113c44 <netif_do_set_ipaddr+0x7c>
    ip_addr_t new_addr;
    *ip_2_ip4(&new_addr) = *ipaddr;
 8113c0a:	68bb      	ldr	r3, [r7, #8]
 8113c0c:	681b      	ldr	r3, [r3, #0]
 8113c0e:	617b      	str	r3, [r7, #20]
    IP_SET_TYPE_VAL(new_addr, IPADDR_TYPE_V4);

    ip_addr_copy(*old_addr, *netif_ip_addr4(netif));
 8113c10:	68fb      	ldr	r3, [r7, #12]
 8113c12:	3304      	adds	r3, #4
 8113c14:	681a      	ldr	r2, [r3, #0]
 8113c16:	687b      	ldr	r3, [r7, #4]
 8113c18:	601a      	str	r2, [r3, #0]

    LWIP_DEBUGF(NETIF_DEBUG | LWIP_DBG_STATE, ("netif_set_ipaddr: netif address being changed\n"));
    netif_do_ip_addr_changed(old_addr, &new_addr);
 8113c1a:	f107 0314 	add.w	r3, r7, #20
 8113c1e:	4619      	mov	r1, r3
 8113c20:	6878      	ldr	r0, [r7, #4]
 8113c22:	f7ff ffbf 	bl	8113ba4 <netif_do_ip_addr_changed>

    mib2_remove_ip4(netif);
    mib2_remove_route_ip4(0, netif);
    /* set new IP address to netif */
    ip4_addr_set(ip_2_ip4(&netif->ip_addr), ipaddr);
 8113c26:	68bb      	ldr	r3, [r7, #8]
 8113c28:	2b00      	cmp	r3, #0
 8113c2a:	d002      	beq.n	8113c32 <netif_do_set_ipaddr+0x6a>
 8113c2c:	68bb      	ldr	r3, [r7, #8]
 8113c2e:	681b      	ldr	r3, [r3, #0]
 8113c30:	e000      	b.n	8113c34 <netif_do_set_ipaddr+0x6c>
 8113c32:	2300      	movs	r3, #0
 8113c34:	68fa      	ldr	r2, [r7, #12]
 8113c36:	6053      	str	r3, [r2, #4]
    IP_SET_TYPE_VAL(netif->ip_addr, IPADDR_TYPE_V4);
    mib2_add_ip4(netif);
    mib2_add_route_ip4(0, netif);

    netif_issue_reports(netif, NETIF_REPORT_TYPE_IPV4);
 8113c38:	2101      	movs	r1, #1
 8113c3a:	68f8      	ldr	r0, [r7, #12]
 8113c3c:	f000 f8d2 	bl	8113de4 <netif_issue_reports>

    NETIF_STATUS_CALLBACK(netif);
    return 1; /* address changed */
 8113c40:	2301      	movs	r3, #1
 8113c42:	e000      	b.n	8113c46 <netif_do_set_ipaddr+0x7e>
  }
  return 0; /* address unchanged */
 8113c44:	2300      	movs	r3, #0
}
 8113c46:	4618      	mov	r0, r3
 8113c48:	3718      	adds	r7, #24
 8113c4a:	46bd      	mov	sp, r7
 8113c4c:	bd80      	pop	{r7, pc}
 8113c4e:	bf00      	nop
 8113c50:	0811d7b4 	.word	0x0811d7b4
 8113c54:	0811d8fc 	.word	0x0811d8fc
 8113c58:	0811d834 	.word	0x0811d834

08113c5c <netif_do_set_netmask>:
  }
}

static int
netif_do_set_netmask(struct netif *netif, const ip4_addr_t *netmask, ip_addr_t *old_nm)
{
 8113c5c:	b480      	push	{r7}
 8113c5e:	b085      	sub	sp, #20
 8113c60:	af00      	add	r7, sp, #0
 8113c62:	60f8      	str	r0, [r7, #12]
 8113c64:	60b9      	str	r1, [r7, #8]
 8113c66:	607a      	str	r2, [r7, #4]
  /* address is actually being changed? */
  if (ip4_addr_cmp(netmask, netif_ip4_netmask(netif)) == 0) {
 8113c68:	68bb      	ldr	r3, [r7, #8]
 8113c6a:	681a      	ldr	r2, [r3, #0]
 8113c6c:	68fb      	ldr	r3, [r7, #12]
 8113c6e:	3308      	adds	r3, #8
 8113c70:	681b      	ldr	r3, [r3, #0]
 8113c72:	429a      	cmp	r2, r3
 8113c74:	d00a      	beq.n	8113c8c <netif_do_set_netmask+0x30>
#else
    LWIP_UNUSED_ARG(old_nm);
#endif
    mib2_remove_route_ip4(0, netif);
    /* set new netmask to netif */
    ip4_addr_set(ip_2_ip4(&netif->netmask), netmask);
 8113c76:	68bb      	ldr	r3, [r7, #8]
 8113c78:	2b00      	cmp	r3, #0
 8113c7a:	d002      	beq.n	8113c82 <netif_do_set_netmask+0x26>
 8113c7c:	68bb      	ldr	r3, [r7, #8]
 8113c7e:	681b      	ldr	r3, [r3, #0]
 8113c80:	e000      	b.n	8113c84 <netif_do_set_netmask+0x28>
 8113c82:	2300      	movs	r3, #0
 8113c84:	68fa      	ldr	r2, [r7, #12]
 8113c86:	6093      	str	r3, [r2, #8]
                netif->name[0], netif->name[1],
                ip4_addr1_16(netif_ip4_netmask(netif)),
                ip4_addr2_16(netif_ip4_netmask(netif)),
                ip4_addr3_16(netif_ip4_netmask(netif)),
                ip4_addr4_16(netif_ip4_netmask(netif))));
    return 1; /* netmask changed */
 8113c88:	2301      	movs	r3, #1
 8113c8a:	e000      	b.n	8113c8e <netif_do_set_netmask+0x32>
  }
  return 0; /* netmask unchanged */
 8113c8c:	2300      	movs	r3, #0
}
 8113c8e:	4618      	mov	r0, r3
 8113c90:	3714      	adds	r7, #20
 8113c92:	46bd      	mov	sp, r7
 8113c94:	f85d 7b04 	ldr.w	r7, [sp], #4
 8113c98:	4770      	bx	lr

08113c9a <netif_do_set_gw>:
  }
}

static int
netif_do_set_gw(struct netif *netif, const ip4_addr_t *gw, ip_addr_t *old_gw)
{
 8113c9a:	b480      	push	{r7}
 8113c9c:	b085      	sub	sp, #20
 8113c9e:	af00      	add	r7, sp, #0
 8113ca0:	60f8      	str	r0, [r7, #12]
 8113ca2:	60b9      	str	r1, [r7, #8]
 8113ca4:	607a      	str	r2, [r7, #4]
  /* address is actually being changed? */
  if (ip4_addr_cmp(gw, netif_ip4_gw(netif)) == 0) {
 8113ca6:	68bb      	ldr	r3, [r7, #8]
 8113ca8:	681a      	ldr	r2, [r3, #0]
 8113caa:	68fb      	ldr	r3, [r7, #12]
 8113cac:	330c      	adds	r3, #12
 8113cae:	681b      	ldr	r3, [r3, #0]
 8113cb0:	429a      	cmp	r2, r3
 8113cb2:	d00a      	beq.n	8113cca <netif_do_set_gw+0x30>
    ip_addr_copy(*old_gw, *netif_ip_gw4(netif));
#else
    LWIP_UNUSED_ARG(old_gw);
#endif

    ip4_addr_set(ip_2_ip4(&netif->gw), gw);
 8113cb4:	68bb      	ldr	r3, [r7, #8]
 8113cb6:	2b00      	cmp	r3, #0
 8113cb8:	d002      	beq.n	8113cc0 <netif_do_set_gw+0x26>
 8113cba:	68bb      	ldr	r3, [r7, #8]
 8113cbc:	681b      	ldr	r3, [r3, #0]
 8113cbe:	e000      	b.n	8113cc2 <netif_do_set_gw+0x28>
 8113cc0:	2300      	movs	r3, #0
 8113cc2:	68fa      	ldr	r2, [r7, #12]
 8113cc4:	60d3      	str	r3, [r2, #12]
                netif->name[0], netif->name[1],
                ip4_addr1_16(netif_ip4_gw(netif)),
                ip4_addr2_16(netif_ip4_gw(netif)),
                ip4_addr3_16(netif_ip4_gw(netif)),
                ip4_addr4_16(netif_ip4_gw(netif))));
    return 1; /* gateway changed */
 8113cc6:	2301      	movs	r3, #1
 8113cc8:	e000      	b.n	8113ccc <netif_do_set_gw+0x32>
  }
  return 0; /* gateway unchanged */
 8113cca:	2300      	movs	r3, #0
}
 8113ccc:	4618      	mov	r0, r3
 8113cce:	3714      	adds	r7, #20
 8113cd0:	46bd      	mov	sp, r7
 8113cd2:	f85d 7b04 	ldr.w	r7, [sp], #4
 8113cd6:	4770      	bx	lr

08113cd8 <netif_set_addr>:
 * @param gw the new default gateway
 */
void
netif_set_addr(struct netif *netif, const ip4_addr_t *ipaddr, const ip4_addr_t *netmask,
               const ip4_addr_t *gw)
{
 8113cd8:	b580      	push	{r7, lr}
 8113cda:	b088      	sub	sp, #32
 8113cdc:	af00      	add	r7, sp, #0
 8113cde:	60f8      	str	r0, [r7, #12]
 8113ce0:	60b9      	str	r1, [r7, #8]
 8113ce2:	607a      	str	r2, [r7, #4]
 8113ce4:	603b      	str	r3, [r7, #0]
  ip_addr_t old_nm_val;
  ip_addr_t old_gw_val;
  ip_addr_t *old_nm = &old_nm_val;
  ip_addr_t *old_gw = &old_gw_val;
#else
  ip_addr_t *old_nm = NULL;
 8113ce6:	2300      	movs	r3, #0
 8113ce8:	61fb      	str	r3, [r7, #28]
  ip_addr_t *old_gw = NULL;
 8113cea:	2300      	movs	r3, #0
 8113cec:	61bb      	str	r3, [r7, #24]
  int remove;

  LWIP_ASSERT_CORE_LOCKED();

  /* Don't propagate NULL pointer (IPv4 ANY) to subsequent functions */
  if (ipaddr == NULL) {
 8113cee:	68bb      	ldr	r3, [r7, #8]
 8113cf0:	2b00      	cmp	r3, #0
 8113cf2:	d101      	bne.n	8113cf8 <netif_set_addr+0x20>
    ipaddr = IP4_ADDR_ANY4;
 8113cf4:	4b1c      	ldr	r3, [pc, #112]	; (8113d68 <netif_set_addr+0x90>)
 8113cf6:	60bb      	str	r3, [r7, #8]
  }
  if (netmask == NULL) {
 8113cf8:	687b      	ldr	r3, [r7, #4]
 8113cfa:	2b00      	cmp	r3, #0
 8113cfc:	d101      	bne.n	8113d02 <netif_set_addr+0x2a>
    netmask = IP4_ADDR_ANY4;
 8113cfe:	4b1a      	ldr	r3, [pc, #104]	; (8113d68 <netif_set_addr+0x90>)
 8113d00:	607b      	str	r3, [r7, #4]
  }
  if (gw == NULL) {
 8113d02:	683b      	ldr	r3, [r7, #0]
 8113d04:	2b00      	cmp	r3, #0
 8113d06:	d101      	bne.n	8113d0c <netif_set_addr+0x34>
    gw = IP4_ADDR_ANY4;
 8113d08:	4b17      	ldr	r3, [pc, #92]	; (8113d68 <netif_set_addr+0x90>)
 8113d0a:	603b      	str	r3, [r7, #0]
  }

  remove = ip4_addr_isany(ipaddr);
 8113d0c:	68bb      	ldr	r3, [r7, #8]
 8113d0e:	2b00      	cmp	r3, #0
 8113d10:	d003      	beq.n	8113d1a <netif_set_addr+0x42>
 8113d12:	68bb      	ldr	r3, [r7, #8]
 8113d14:	681b      	ldr	r3, [r3, #0]
 8113d16:	2b00      	cmp	r3, #0
 8113d18:	d101      	bne.n	8113d1e <netif_set_addr+0x46>
 8113d1a:	2301      	movs	r3, #1
 8113d1c:	e000      	b.n	8113d20 <netif_set_addr+0x48>
 8113d1e:	2300      	movs	r3, #0
 8113d20:	617b      	str	r3, [r7, #20]
  if (remove) {
 8113d22:	697b      	ldr	r3, [r7, #20]
 8113d24:	2b00      	cmp	r3, #0
 8113d26:	d006      	beq.n	8113d36 <netif_set_addr+0x5e>
    /* when removing an address, we have to remove it *before* changing netmask/gw
       to ensure that tcp RST segment can be sent correctly */
    if (netif_do_set_ipaddr(netif, ipaddr, &old_addr)) {
 8113d28:	f107 0310 	add.w	r3, r7, #16
 8113d2c:	461a      	mov	r2, r3
 8113d2e:	68b9      	ldr	r1, [r7, #8]
 8113d30:	68f8      	ldr	r0, [r7, #12]
 8113d32:	f7ff ff49 	bl	8113bc8 <netif_do_set_ipaddr>
      change_reason |= LWIP_NSC_IPV4_ADDRESS_CHANGED;
      cb_args.ipv4_changed.old_address = &old_addr;
#endif
    }
  }
  if (netif_do_set_netmask(netif, netmask, old_nm)) {
 8113d36:	69fa      	ldr	r2, [r7, #28]
 8113d38:	6879      	ldr	r1, [r7, #4]
 8113d3a:	68f8      	ldr	r0, [r7, #12]
 8113d3c:	f7ff ff8e 	bl	8113c5c <netif_do_set_netmask>
#if LWIP_NETIF_EXT_STATUS_CALLBACK
    change_reason |= LWIP_NSC_IPV4_NETMASK_CHANGED;
    cb_args.ipv4_changed.old_netmask = old_nm;
#endif
  }
  if (netif_do_set_gw(netif, gw, old_gw)) {
 8113d40:	69ba      	ldr	r2, [r7, #24]
 8113d42:	6839      	ldr	r1, [r7, #0]
 8113d44:	68f8      	ldr	r0, [r7, #12]
 8113d46:	f7ff ffa8 	bl	8113c9a <netif_do_set_gw>
#if LWIP_NETIF_EXT_STATUS_CALLBACK
    change_reason |= LWIP_NSC_IPV4_GATEWAY_CHANGED;
    cb_args.ipv4_changed.old_gw = old_gw;
#endif
  }
  if (!remove) {
 8113d4a:	697b      	ldr	r3, [r7, #20]
 8113d4c:	2b00      	cmp	r3, #0
 8113d4e:	d106      	bne.n	8113d5e <netif_set_addr+0x86>
    /* set ipaddr last to ensure netmask/gw have been set when status callback is called */
    if (netif_do_set_ipaddr(netif, ipaddr, &old_addr)) {
 8113d50:	f107 0310 	add.w	r3, r7, #16
 8113d54:	461a      	mov	r2, r3
 8113d56:	68b9      	ldr	r1, [r7, #8]
 8113d58:	68f8      	ldr	r0, [r7, #12]
 8113d5a:	f7ff ff35 	bl	8113bc8 <netif_do_set_ipaddr>
  if (change_reason != LWIP_NSC_NONE) {
    change_reason |= LWIP_NSC_IPV4_SETTINGS_CHANGED;
    netif_invoke_ext_callback(netif, change_reason, &cb_args);
  }
#endif
}
 8113d5e:	bf00      	nop
 8113d60:	3720      	adds	r7, #32
 8113d62:	46bd      	mov	sp, r7
 8113d64:	bd80      	pop	{r7, pc}
 8113d66:	bf00      	nop
 8113d68:	0811f934 	.word	0x0811f934

08113d6c <netif_set_default>:
 *
 * @param netif the default network interface
 */
void
netif_set_default(struct netif *netif)
{
 8113d6c:	b480      	push	{r7}
 8113d6e:	b083      	sub	sp, #12
 8113d70:	af00      	add	r7, sp, #0
 8113d72:	6078      	str	r0, [r7, #4]
    mib2_remove_route_ip4(1, netif);
  } else {
    /* install default route */
    mib2_add_route_ip4(1, netif);
  }
  netif_default = netif;
 8113d74:	4a04      	ldr	r2, [pc, #16]	; (8113d88 <netif_set_default+0x1c>)
 8113d76:	687b      	ldr	r3, [r7, #4]
 8113d78:	6013      	str	r3, [r2, #0]
  LWIP_DEBUGF(NETIF_DEBUG, ("netif: setting default interface %c%c\n",
                            netif ? netif->name[0] : '\'', netif ? netif->name[1] : '\''));
}
 8113d7a:	bf00      	nop
 8113d7c:	370c      	adds	r7, #12
 8113d7e:	46bd      	mov	sp, r7
 8113d80:	f85d 7b04 	ldr.w	r7, [sp], #4
 8113d84:	4770      	bx	lr
 8113d86:	bf00      	nop
 8113d88:	10008440 	.word	0x10008440

08113d8c <netif_set_up>:
 * Bring an interface up, available for processing
 * traffic.
 */
void
netif_set_up(struct netif *netif)
{
 8113d8c:	b580      	push	{r7, lr}
 8113d8e:	b082      	sub	sp, #8
 8113d90:	af00      	add	r7, sp, #0
 8113d92:	6078      	str	r0, [r7, #4]
  LWIP_ASSERT_CORE_LOCKED();

  LWIP_ERROR("netif_set_up: invalid netif", netif != NULL, return);
 8113d94:	687b      	ldr	r3, [r7, #4]
 8113d96:	2b00      	cmp	r3, #0
 8113d98:	d107      	bne.n	8113daa <netif_set_up+0x1e>
 8113d9a:	4b0f      	ldr	r3, [pc, #60]	; (8113dd8 <netif_set_up+0x4c>)
 8113d9c:	f44f 7254 	mov.w	r2, #848	; 0x350
 8113da0:	490e      	ldr	r1, [pc, #56]	; (8113ddc <netif_set_up+0x50>)
 8113da2:	480f      	ldr	r0, [pc, #60]	; (8113de0 <netif_set_up+0x54>)
 8113da4:	f007 fd2c 	bl	811b800 <iprintf>
 8113da8:	e013      	b.n	8113dd2 <netif_set_up+0x46>

  if (!(netif->flags & NETIF_FLAG_UP)) {
 8113daa:	687b      	ldr	r3, [r7, #4]
 8113dac:	f893 3031 	ldrb.w	r3, [r3, #49]	; 0x31
 8113db0:	f003 0301 	and.w	r3, r3, #1
 8113db4:	2b00      	cmp	r3, #0
 8113db6:	d10c      	bne.n	8113dd2 <netif_set_up+0x46>
    netif_set_flags(netif, NETIF_FLAG_UP);
 8113db8:	687b      	ldr	r3, [r7, #4]
 8113dba:	f893 3031 	ldrb.w	r3, [r3, #49]	; 0x31
 8113dbe:	f043 0301 	orr.w	r3, r3, #1
 8113dc2:	b2da      	uxtb	r2, r3
 8113dc4:	687b      	ldr	r3, [r7, #4]
 8113dc6:	f883 2031 	strb.w	r2, [r3, #49]	; 0x31
      args.status_changed.state = 1;
      netif_invoke_ext_callback(netif, LWIP_NSC_STATUS_CHANGED, &args);
    }
#endif

    netif_issue_reports(netif, NETIF_REPORT_TYPE_IPV4 | NETIF_REPORT_TYPE_IPV6);
 8113dca:	2103      	movs	r1, #3
 8113dcc:	6878      	ldr	r0, [r7, #4]
 8113dce:	f000 f809 	bl	8113de4 <netif_issue_reports>
#if LWIP_IPV6
    nd6_restart_netif(netif);
#endif /* LWIP_IPV6 */
  }
}
 8113dd2:	3708      	adds	r7, #8
 8113dd4:	46bd      	mov	sp, r7
 8113dd6:	bd80      	pop	{r7, pc}
 8113dd8:	0811d7b4 	.word	0x0811d7b4
 8113ddc:	0811d96c 	.word	0x0811d96c
 8113de0:	0811d834 	.word	0x0811d834

08113de4 <netif_issue_reports>:

/** Send ARP/IGMP/MLD/RS events, e.g. on link-up/netif-up or addr-change
 */
static void
netif_issue_reports(struct netif *netif, u8_t report_type)
{
 8113de4:	b580      	push	{r7, lr}
 8113de6:	b082      	sub	sp, #8
 8113de8:	af00      	add	r7, sp, #0
 8113dea:	6078      	str	r0, [r7, #4]
 8113dec:	460b      	mov	r3, r1
 8113dee:	70fb      	strb	r3, [r7, #3]
  LWIP_ASSERT("netif_issue_reports: invalid netif", netif != NULL);
 8113df0:	687b      	ldr	r3, [r7, #4]
 8113df2:	2b00      	cmp	r3, #0
 8113df4:	d106      	bne.n	8113e04 <netif_issue_reports+0x20>
 8113df6:	4b18      	ldr	r3, [pc, #96]	; (8113e58 <netif_issue_reports+0x74>)
 8113df8:	f240 326d 	movw	r2, #877	; 0x36d
 8113dfc:	4917      	ldr	r1, [pc, #92]	; (8113e5c <netif_issue_reports+0x78>)
 8113dfe:	4818      	ldr	r0, [pc, #96]	; (8113e60 <netif_issue_reports+0x7c>)
 8113e00:	f007 fcfe 	bl	811b800 <iprintf>

  /* Only send reports when both link and admin states are up */
  if (!(netif->flags & NETIF_FLAG_LINK_UP) ||
 8113e04:	687b      	ldr	r3, [r7, #4]
 8113e06:	f893 3031 	ldrb.w	r3, [r3, #49]	; 0x31
 8113e0a:	f003 0304 	and.w	r3, r3, #4
 8113e0e:	2b00      	cmp	r3, #0
 8113e10:	d01e      	beq.n	8113e50 <netif_issue_reports+0x6c>
      !(netif->flags & NETIF_FLAG_UP)) {
 8113e12:	687b      	ldr	r3, [r7, #4]
 8113e14:	f893 3031 	ldrb.w	r3, [r3, #49]	; 0x31
 8113e18:	f003 0301 	and.w	r3, r3, #1
  if (!(netif->flags & NETIF_FLAG_LINK_UP) ||
 8113e1c:	2b00      	cmp	r3, #0
 8113e1e:	d017      	beq.n	8113e50 <netif_issue_reports+0x6c>
    return;
  }

#if LWIP_IPV4
  if ((report_type & NETIF_REPORT_TYPE_IPV4) &&
 8113e20:	78fb      	ldrb	r3, [r7, #3]
 8113e22:	f003 0301 	and.w	r3, r3, #1
 8113e26:	2b00      	cmp	r3, #0
 8113e28:	d013      	beq.n	8113e52 <netif_issue_reports+0x6e>
      !ip4_addr_isany_val(*netif_ip4_addr(netif))) {
 8113e2a:	687b      	ldr	r3, [r7, #4]
 8113e2c:	3304      	adds	r3, #4
 8113e2e:	681b      	ldr	r3, [r3, #0]
  if ((report_type & NETIF_REPORT_TYPE_IPV4) &&
 8113e30:	2b00      	cmp	r3, #0
 8113e32:	d00e      	beq.n	8113e52 <netif_issue_reports+0x6e>
#if LWIP_ARP
    /* For Ethernet network interfaces, we would like to send a "gratuitous ARP" */
    if (netif->flags & (NETIF_FLAG_ETHARP)) {
 8113e34:	687b      	ldr	r3, [r7, #4]
 8113e36:	f893 3031 	ldrb.w	r3, [r3, #49]	; 0x31
 8113e3a:	f003 0308 	and.w	r3, r3, #8
 8113e3e:	2b00      	cmp	r3, #0
 8113e40:	d007      	beq.n	8113e52 <netif_issue_reports+0x6e>
      etharp_gratuitous(netif);
 8113e42:	687b      	ldr	r3, [r7, #4]
 8113e44:	3304      	adds	r3, #4
 8113e46:	4619      	mov	r1, r3
 8113e48:	6878      	ldr	r0, [r7, #4]
 8113e4a:	f7fd fc5f 	bl	811170c <etharp_request>
 8113e4e:	e000      	b.n	8113e52 <netif_issue_reports+0x6e>
    return;
 8113e50:	bf00      	nop
    /* send mld memberships */
    mld6_report_groups(netif);
#endif /* LWIP_IPV6_MLD */
  }
#endif /* LWIP_IPV6 */
}
 8113e52:	3708      	adds	r7, #8
 8113e54:	46bd      	mov	sp, r7
 8113e56:	bd80      	pop	{r7, pc}
 8113e58:	0811d7b4 	.word	0x0811d7b4
 8113e5c:	0811d988 	.word	0x0811d988
 8113e60:	0811d834 	.word	0x0811d834

08113e64 <netif_set_down>:
 * @ingroup netif
 * Bring an interface down, disabling any traffic processing.
 */
void
netif_set_down(struct netif *netif)
{
 8113e64:	b580      	push	{r7, lr}
 8113e66:	b082      	sub	sp, #8
 8113e68:	af00      	add	r7, sp, #0
 8113e6a:	6078      	str	r0, [r7, #4]
  LWIP_ASSERT_CORE_LOCKED();

  LWIP_ERROR("netif_set_down: invalid netif", netif != NULL, return);
 8113e6c:	687b      	ldr	r3, [r7, #4]
 8113e6e:	2b00      	cmp	r3, #0
 8113e70:	d107      	bne.n	8113e82 <netif_set_down+0x1e>
 8113e72:	4b12      	ldr	r3, [pc, #72]	; (8113ebc <netif_set_down+0x58>)
 8113e74:	f240 329b 	movw	r2, #923	; 0x39b
 8113e78:	4911      	ldr	r1, [pc, #68]	; (8113ec0 <netif_set_down+0x5c>)
 8113e7a:	4812      	ldr	r0, [pc, #72]	; (8113ec4 <netif_set_down+0x60>)
 8113e7c:	f007 fcc0 	bl	811b800 <iprintf>
 8113e80:	e019      	b.n	8113eb6 <netif_set_down+0x52>

  if (netif->flags & NETIF_FLAG_UP) {
 8113e82:	687b      	ldr	r3, [r7, #4]
 8113e84:	f893 3031 	ldrb.w	r3, [r3, #49]	; 0x31
 8113e88:	f003 0301 	and.w	r3, r3, #1
 8113e8c:	2b00      	cmp	r3, #0
 8113e8e:	d012      	beq.n	8113eb6 <netif_set_down+0x52>
      args.status_changed.state = 0;
      netif_invoke_ext_callback(netif, LWIP_NSC_STATUS_CHANGED, &args);
    }
#endif

    netif_clear_flags(netif, NETIF_FLAG_UP);
 8113e90:	687b      	ldr	r3, [r7, #4]
 8113e92:	f893 3031 	ldrb.w	r3, [r3, #49]	; 0x31
 8113e96:	f023 0301 	bic.w	r3, r3, #1
 8113e9a:	b2da      	uxtb	r2, r3
 8113e9c:	687b      	ldr	r3, [r7, #4]
 8113e9e:	f883 2031 	strb.w	r2, [r3, #49]	; 0x31
    MIB2_COPY_SYSUPTIME_TO(&netif->ts);

#if LWIP_IPV4 && LWIP_ARP
    if (netif->flags & NETIF_FLAG_ETHARP) {
 8113ea2:	687b      	ldr	r3, [r7, #4]
 8113ea4:	f893 3031 	ldrb.w	r3, [r3, #49]	; 0x31
 8113ea8:	f003 0308 	and.w	r3, r3, #8
 8113eac:	2b00      	cmp	r3, #0
 8113eae:	d002      	beq.n	8113eb6 <netif_set_down+0x52>
      etharp_cleanup_netif(netif);
 8113eb0:	6878      	ldr	r0, [r7, #4]
 8113eb2:	f7fc ffe5 	bl	8110e80 <etharp_cleanup_netif>
    nd6_cleanup_netif(netif);
#endif /* LWIP_IPV6 */

    NETIF_STATUS_CALLBACK(netif);
  }
}
 8113eb6:	3708      	adds	r7, #8
 8113eb8:	46bd      	mov	sp, r7
 8113eba:	bd80      	pop	{r7, pc}
 8113ebc:	0811d7b4 	.word	0x0811d7b4
 8113ec0:	0811d9ac 	.word	0x0811d9ac
 8113ec4:	0811d834 	.word	0x0811d834

08113ec8 <netif_set_link_up>:
 * @ingroup netif
 * Called by a driver when its link goes up
 */
void
netif_set_link_up(struct netif *netif)
{
 8113ec8:	b580      	push	{r7, lr}
 8113eca:	b082      	sub	sp, #8
 8113ecc:	af00      	add	r7, sp, #0
 8113ece:	6078      	str	r0, [r7, #4]
  LWIP_ASSERT_CORE_LOCKED();

  LWIP_ERROR("netif_set_link_up: invalid netif", netif != NULL, return);
 8113ed0:	687b      	ldr	r3, [r7, #4]
 8113ed2:	2b00      	cmp	r3, #0
 8113ed4:	d107      	bne.n	8113ee6 <netif_set_link_up+0x1e>
 8113ed6:	4b15      	ldr	r3, [pc, #84]	; (8113f2c <netif_set_link_up+0x64>)
 8113ed8:	f44f 7278 	mov.w	r2, #992	; 0x3e0
 8113edc:	4914      	ldr	r1, [pc, #80]	; (8113f30 <netif_set_link_up+0x68>)
 8113ede:	4815      	ldr	r0, [pc, #84]	; (8113f34 <netif_set_link_up+0x6c>)
 8113ee0:	f007 fc8e 	bl	811b800 <iprintf>
 8113ee4:	e01e      	b.n	8113f24 <netif_set_link_up+0x5c>

  if (!(netif->flags & NETIF_FLAG_LINK_UP)) {
 8113ee6:	687b      	ldr	r3, [r7, #4]
 8113ee8:	f893 3031 	ldrb.w	r3, [r3, #49]	; 0x31
 8113eec:	f003 0304 	and.w	r3, r3, #4
 8113ef0:	2b00      	cmp	r3, #0
 8113ef2:	d117      	bne.n	8113f24 <netif_set_link_up+0x5c>
    netif_set_flags(netif, NETIF_FLAG_LINK_UP);
 8113ef4:	687b      	ldr	r3, [r7, #4]
 8113ef6:	f893 3031 	ldrb.w	r3, [r3, #49]	; 0x31
 8113efa:	f043 0304 	orr.w	r3, r3, #4
 8113efe:	b2da      	uxtb	r2, r3
 8113f00:	687b      	ldr	r3, [r7, #4]
 8113f02:	f883 2031 	strb.w	r2, [r3, #49]	; 0x31

#if LWIP_DHCP
    dhcp_network_changed(netif);
 8113f06:	6878      	ldr	r0, [r7, #4]
 8113f08:	f7fa ff0c 	bl	810ed24 <dhcp_network_changed>

#if LWIP_AUTOIP
    autoip_network_changed(netif);
#endif /* LWIP_AUTOIP */

    netif_issue_reports(netif, NETIF_REPORT_TYPE_IPV4 | NETIF_REPORT_TYPE_IPV6);
 8113f0c:	2103      	movs	r1, #3
 8113f0e:	6878      	ldr	r0, [r7, #4]
 8113f10:	f7ff ff68 	bl	8113de4 <netif_issue_reports>
#if LWIP_IPV6
    nd6_restart_netif(netif);
#endif /* LWIP_IPV6 */

    NETIF_LINK_CALLBACK(netif);
 8113f14:	687b      	ldr	r3, [r7, #4]
 8113f16:	69db      	ldr	r3, [r3, #28]
 8113f18:	2b00      	cmp	r3, #0
 8113f1a:	d003      	beq.n	8113f24 <netif_set_link_up+0x5c>
 8113f1c:	687b      	ldr	r3, [r7, #4]
 8113f1e:	69db      	ldr	r3, [r3, #28]
 8113f20:	6878      	ldr	r0, [r7, #4]
 8113f22:	4798      	blx	r3
      args.link_changed.state = 1;
      netif_invoke_ext_callback(netif, LWIP_NSC_LINK_CHANGED, &args);
    }
#endif
  }
}
 8113f24:	3708      	adds	r7, #8
 8113f26:	46bd      	mov	sp, r7
 8113f28:	bd80      	pop	{r7, pc}
 8113f2a:	bf00      	nop
 8113f2c:	0811d7b4 	.word	0x0811d7b4
 8113f30:	0811d9cc 	.word	0x0811d9cc
 8113f34:	0811d834 	.word	0x0811d834

08113f38 <netif_set_link_down>:
 * @ingroup netif
 * Called by a driver when its link goes down
 */
void
netif_set_link_down(struct netif *netif)
{
 8113f38:	b580      	push	{r7, lr}
 8113f3a:	b082      	sub	sp, #8
 8113f3c:	af00      	add	r7, sp, #0
 8113f3e:	6078      	str	r0, [r7, #4]
  LWIP_ASSERT_CORE_LOCKED();

  LWIP_ERROR("netif_set_link_down: invalid netif", netif != NULL, return);
 8113f40:	687b      	ldr	r3, [r7, #4]
 8113f42:	2b00      	cmp	r3, #0
 8113f44:	d107      	bne.n	8113f56 <netif_set_link_down+0x1e>
 8113f46:	4b11      	ldr	r3, [pc, #68]	; (8113f8c <netif_set_link_down+0x54>)
 8113f48:	f240 4206 	movw	r2, #1030	; 0x406
 8113f4c:	4910      	ldr	r1, [pc, #64]	; (8113f90 <netif_set_link_down+0x58>)
 8113f4e:	4811      	ldr	r0, [pc, #68]	; (8113f94 <netif_set_link_down+0x5c>)
 8113f50:	f007 fc56 	bl	811b800 <iprintf>
 8113f54:	e017      	b.n	8113f86 <netif_set_link_down+0x4e>

  if (netif->flags & NETIF_FLAG_LINK_UP) {
 8113f56:	687b      	ldr	r3, [r7, #4]
 8113f58:	f893 3031 	ldrb.w	r3, [r3, #49]	; 0x31
 8113f5c:	f003 0304 	and.w	r3, r3, #4
 8113f60:	2b00      	cmp	r3, #0
 8113f62:	d010      	beq.n	8113f86 <netif_set_link_down+0x4e>
    netif_clear_flags(netif, NETIF_FLAG_LINK_UP);
 8113f64:	687b      	ldr	r3, [r7, #4]
 8113f66:	f893 3031 	ldrb.w	r3, [r3, #49]	; 0x31
 8113f6a:	f023 0304 	bic.w	r3, r3, #4
 8113f6e:	b2da      	uxtb	r2, r3
 8113f70:	687b      	ldr	r3, [r7, #4]
 8113f72:	f883 2031 	strb.w	r2, [r3, #49]	; 0x31
    NETIF_LINK_CALLBACK(netif);
 8113f76:	687b      	ldr	r3, [r7, #4]
 8113f78:	69db      	ldr	r3, [r3, #28]
 8113f7a:	2b00      	cmp	r3, #0
 8113f7c:	d003      	beq.n	8113f86 <netif_set_link_down+0x4e>
 8113f7e:	687b      	ldr	r3, [r7, #4]
 8113f80:	69db      	ldr	r3, [r3, #28]
 8113f82:	6878      	ldr	r0, [r7, #4]
 8113f84:	4798      	blx	r3
      args.link_changed.state = 0;
      netif_invoke_ext_callback(netif, LWIP_NSC_LINK_CHANGED, &args);
    }
#endif
  }
}
 8113f86:	3708      	adds	r7, #8
 8113f88:	46bd      	mov	sp, r7
 8113f8a:	bd80      	pop	{r7, pc}
 8113f8c:	0811d7b4 	.word	0x0811d7b4
 8113f90:	0811d9f0 	.word	0x0811d9f0
 8113f94:	0811d834 	.word	0x0811d834

08113f98 <netif_set_link_callback>:
 * @ingroup netif
 * Set callback to be called when link is brought up/down
 */
void
netif_set_link_callback(struct netif *netif, netif_status_callback_fn link_callback)
{
 8113f98:	b480      	push	{r7}
 8113f9a:	b083      	sub	sp, #12
 8113f9c:	af00      	add	r7, sp, #0
 8113f9e:	6078      	str	r0, [r7, #4]
 8113fa0:	6039      	str	r1, [r7, #0]
  LWIP_ASSERT_CORE_LOCKED();

  if (netif) {
 8113fa2:	687b      	ldr	r3, [r7, #4]
 8113fa4:	2b00      	cmp	r3, #0
 8113fa6:	d002      	beq.n	8113fae <netif_set_link_callback+0x16>
    netif->link_callback = link_callback;
 8113fa8:	687b      	ldr	r3, [r7, #4]
 8113faa:	683a      	ldr	r2, [r7, #0]
 8113fac:	61da      	str	r2, [r3, #28]
  }
}
 8113fae:	bf00      	nop
 8113fb0:	370c      	adds	r7, #12
 8113fb2:	46bd      	mov	sp, r7
 8113fb4:	f85d 7b04 	ldr.w	r7, [sp], #4
 8113fb8:	4770      	bx	lr

08113fba <netif_null_output_ip4>:
#if LWIP_IPV4
/** Dummy IPv4 output function for netifs not supporting IPv4
 */
static err_t
netif_null_output_ip4(struct netif *netif, struct pbuf *p, const ip4_addr_t *ipaddr)
{
 8113fba:	b480      	push	{r7}
 8113fbc:	b085      	sub	sp, #20
 8113fbe:	af00      	add	r7, sp, #0
 8113fc0:	60f8      	str	r0, [r7, #12]
 8113fc2:	60b9      	str	r1, [r7, #8]
 8113fc4:	607a      	str	r2, [r7, #4]
  LWIP_UNUSED_ARG(netif);
  LWIP_UNUSED_ARG(p);
  LWIP_UNUSED_ARG(ipaddr);

  return ERR_IF;
 8113fc6:	f06f 030b 	mvn.w	r3, #11
}
 8113fca:	4618      	mov	r0, r3
 8113fcc:	3714      	adds	r7, #20
 8113fce:	46bd      	mov	sp, r7
 8113fd0:	f85d 7b04 	ldr.w	r7, [sp], #4
 8113fd4:	4770      	bx	lr
	...

08113fd8 <netif_get_by_index>:
*
* @param idx index of netif to find
*/
struct netif *
netif_get_by_index(u8_t idx)
{
 8113fd8:	b480      	push	{r7}
 8113fda:	b085      	sub	sp, #20
 8113fdc:	af00      	add	r7, sp, #0
 8113fde:	4603      	mov	r3, r0
 8113fe0:	71fb      	strb	r3, [r7, #7]
  struct netif *netif;

  LWIP_ASSERT_CORE_LOCKED();

  if (idx != NETIF_NO_INDEX) {
 8113fe2:	79fb      	ldrb	r3, [r7, #7]
 8113fe4:	2b00      	cmp	r3, #0
 8113fe6:	d013      	beq.n	8114010 <netif_get_by_index+0x38>
    NETIF_FOREACH(netif) {
 8113fe8:	4b0d      	ldr	r3, [pc, #52]	; (8114020 <netif_get_by_index+0x48>)
 8113fea:	681b      	ldr	r3, [r3, #0]
 8113fec:	60fb      	str	r3, [r7, #12]
 8113fee:	e00c      	b.n	811400a <netif_get_by_index+0x32>
      if (idx == netif_get_index(netif)) {
 8113ff0:	68fb      	ldr	r3, [r7, #12]
 8113ff2:	f893 3034 	ldrb.w	r3, [r3, #52]	; 0x34
 8113ff6:	3301      	adds	r3, #1
 8113ff8:	b2db      	uxtb	r3, r3
 8113ffa:	79fa      	ldrb	r2, [r7, #7]
 8113ffc:	429a      	cmp	r2, r3
 8113ffe:	d101      	bne.n	8114004 <netif_get_by_index+0x2c>
        return netif; /* found! */
 8114000:	68fb      	ldr	r3, [r7, #12]
 8114002:	e006      	b.n	8114012 <netif_get_by_index+0x3a>
    NETIF_FOREACH(netif) {
 8114004:	68fb      	ldr	r3, [r7, #12]
 8114006:	681b      	ldr	r3, [r3, #0]
 8114008:	60fb      	str	r3, [r7, #12]
 811400a:	68fb      	ldr	r3, [r7, #12]
 811400c:	2b00      	cmp	r3, #0
 811400e:	d1ef      	bne.n	8113ff0 <netif_get_by_index+0x18>
      }
    }
  }

  return NULL;
 8114010:	2300      	movs	r3, #0
}
 8114012:	4618      	mov	r0, r3
 8114014:	3714      	adds	r7, #20
 8114016:	46bd      	mov	sp, r7
 8114018:	f85d 7b04 	ldr.w	r7, [sp], #4
 811401c:	4770      	bx	lr
 811401e:	bf00      	nop
 8114020:	1000843c 	.word	0x1000843c

08114024 <pbuf_pool_is_empty>:
#endif /* !NO_SYS */

/** Queue a call to pbuf_free_ooseq if not already queued. */
static void
pbuf_pool_is_empty(void)
{
 8114024:	b480      	push	{r7}
 8114026:	af00      	add	r7, sp, #0
#ifndef PBUF_POOL_FREE_OOSEQ_QUEUE_CALL
  SYS_ARCH_SET(pbuf_free_ooseq_pending, 1);
 8114028:	4b03      	ldr	r3, [pc, #12]	; (8114038 <pbuf_pool_is_empty+0x14>)
 811402a:	2201      	movs	r2, #1
 811402c:	701a      	strb	r2, [r3, #0]
  if (!queued) {
    /* queue a call to pbuf_free_ooseq if not already queued */
    PBUF_POOL_FREE_OOSEQ_QUEUE_CALL();
  }
#endif /* PBUF_POOL_FREE_OOSEQ_QUEUE_CALL */
}
 811402e:	bf00      	nop
 8114030:	46bd      	mov	sp, r7
 8114032:	f85d 7b04 	ldr.w	r7, [sp], #4
 8114036:	4770      	bx	lr
 8114038:	10008445 	.word	0x10008445

0811403c <pbuf_init_alloced_pbuf>:
#endif /* !LWIP_TCP || !TCP_QUEUE_OOSEQ || !PBUF_POOL_FREE_OOSEQ */

/* Initialize members of struct pbuf after allocation */
static void
pbuf_init_alloced_pbuf(struct pbuf *p, void *payload, u16_t tot_len, u16_t len, pbuf_type type, u8_t flags)
{
 811403c:	b480      	push	{r7}
 811403e:	b085      	sub	sp, #20
 8114040:	af00      	add	r7, sp, #0
 8114042:	60f8      	str	r0, [r7, #12]
 8114044:	60b9      	str	r1, [r7, #8]
 8114046:	4611      	mov	r1, r2
 8114048:	461a      	mov	r2, r3
 811404a:	460b      	mov	r3, r1
 811404c:	80fb      	strh	r3, [r7, #6]
 811404e:	4613      	mov	r3, r2
 8114050:	80bb      	strh	r3, [r7, #4]
  p->next = NULL;
 8114052:	68fb      	ldr	r3, [r7, #12]
 8114054:	2200      	movs	r2, #0
 8114056:	601a      	str	r2, [r3, #0]
  p->payload = payload;
 8114058:	68fb      	ldr	r3, [r7, #12]
 811405a:	68ba      	ldr	r2, [r7, #8]
 811405c:	605a      	str	r2, [r3, #4]
  p->tot_len = tot_len;
 811405e:	68fb      	ldr	r3, [r7, #12]
 8114060:	88fa      	ldrh	r2, [r7, #6]
 8114062:	811a      	strh	r2, [r3, #8]
  p->len = len;
 8114064:	68fb      	ldr	r3, [r7, #12]
 8114066:	88ba      	ldrh	r2, [r7, #4]
 8114068:	815a      	strh	r2, [r3, #10]
  p->type_internal = (u8_t)type;
 811406a:	8b3b      	ldrh	r3, [r7, #24]
 811406c:	b2da      	uxtb	r2, r3
 811406e:	68fb      	ldr	r3, [r7, #12]
 8114070:	731a      	strb	r2, [r3, #12]
  p->flags = flags;
 8114072:	68fb      	ldr	r3, [r7, #12]
 8114074:	7f3a      	ldrb	r2, [r7, #28]
 8114076:	735a      	strb	r2, [r3, #13]
  p->ref = 1;
 8114078:	68fb      	ldr	r3, [r7, #12]
 811407a:	2201      	movs	r2, #1
 811407c:	739a      	strb	r2, [r3, #14]
  p->if_idx = NETIF_NO_INDEX;
 811407e:	68fb      	ldr	r3, [r7, #12]
 8114080:	2200      	movs	r2, #0
 8114082:	73da      	strb	r2, [r3, #15]
}
 8114084:	bf00      	nop
 8114086:	3714      	adds	r7, #20
 8114088:	46bd      	mov	sp, r7
 811408a:	f85d 7b04 	ldr.w	r7, [sp], #4
 811408e:	4770      	bx	lr

08114090 <pbuf_alloc>:
 * @return the allocated pbuf. If multiple pbufs where allocated, this
 * is the first pbuf of a pbuf chain.
 */
struct pbuf *
pbuf_alloc(pbuf_layer layer, u16_t length, pbuf_type type)
{
 8114090:	b580      	push	{r7, lr}
 8114092:	b08c      	sub	sp, #48	; 0x30
 8114094:	af02      	add	r7, sp, #8
 8114096:	4603      	mov	r3, r0
 8114098:	71fb      	strb	r3, [r7, #7]
 811409a:	460b      	mov	r3, r1
 811409c:	80bb      	strh	r3, [r7, #4]
 811409e:	4613      	mov	r3, r2
 81140a0:	807b      	strh	r3, [r7, #2]
  struct pbuf *p;
  u16_t offset = (u16_t)layer;
 81140a2:	79fb      	ldrb	r3, [r7, #7]
 81140a4:	847b      	strh	r3, [r7, #34]	; 0x22
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_alloc(length=%"U16_F")\n", length));

  switch (type) {
 81140a6:	887b      	ldrh	r3, [r7, #2]
 81140a8:	f5b3 7f20 	cmp.w	r3, #640	; 0x280
 81140ac:	d07f      	beq.n	81141ae <pbuf_alloc+0x11e>
 81140ae:	f5b3 7f20 	cmp.w	r3, #640	; 0x280
 81140b2:	f300 80c8 	bgt.w	8114246 <pbuf_alloc+0x1b6>
 81140b6:	f5b3 7fc1 	cmp.w	r3, #386	; 0x182
 81140ba:	d010      	beq.n	81140de <pbuf_alloc+0x4e>
 81140bc:	f5b3 7fc1 	cmp.w	r3, #386	; 0x182
 81140c0:	f300 80c1 	bgt.w	8114246 <pbuf_alloc+0x1b6>
 81140c4:	2b01      	cmp	r3, #1
 81140c6:	d002      	beq.n	81140ce <pbuf_alloc+0x3e>
 81140c8:	2b41      	cmp	r3, #65	; 0x41
 81140ca:	f040 80bc 	bne.w	8114246 <pbuf_alloc+0x1b6>
    case PBUF_REF: /* fall through */
    case PBUF_ROM:
      p = pbuf_alloc_reference(NULL, length, type);
 81140ce:	887a      	ldrh	r2, [r7, #2]
 81140d0:	88bb      	ldrh	r3, [r7, #4]
 81140d2:	4619      	mov	r1, r3
 81140d4:	2000      	movs	r0, #0
 81140d6:	f000 f8d1 	bl	811427c <pbuf_alloc_reference>
 81140da:	6278      	str	r0, [r7, #36]	; 0x24
      break;
 81140dc:	e0bd      	b.n	811425a <pbuf_alloc+0x1ca>
    case PBUF_POOL: {
      struct pbuf *q, *last;
      u16_t rem_len; /* remaining length */
      p = NULL;
 81140de:	2300      	movs	r3, #0
 81140e0:	627b      	str	r3, [r7, #36]	; 0x24
      last = NULL;
 81140e2:	2300      	movs	r3, #0
 81140e4:	61fb      	str	r3, [r7, #28]
      rem_len = length;
 81140e6:	88bb      	ldrh	r3, [r7, #4]
 81140e8:	837b      	strh	r3, [r7, #26]
      do {
        u16_t qlen;
        q = (struct pbuf *)memp_malloc(MEMP_PBUF_POOL);
 81140ea:	2008      	movs	r0, #8
 81140ec:	f7ff fbe2 	bl	81138b4 <memp_malloc>
 81140f0:	6138      	str	r0, [r7, #16]
        if (q == NULL) {
 81140f2:	693b      	ldr	r3, [r7, #16]
 81140f4:	2b00      	cmp	r3, #0
 81140f6:	d109      	bne.n	811410c <pbuf_alloc+0x7c>
          PBUF_POOL_IS_EMPTY();
 81140f8:	f7ff ff94 	bl	8114024 <pbuf_pool_is_empty>
          /* free chain so far allocated */
          if (p) {
 81140fc:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 81140fe:	2b00      	cmp	r3, #0
 8114100:	d002      	beq.n	8114108 <pbuf_alloc+0x78>
            pbuf_free(p);
 8114102:	6a78      	ldr	r0, [r7, #36]	; 0x24
 8114104:	f000 faa8 	bl	8114658 <pbuf_free>
          }
          /* bail out unsuccessfully */
          return NULL;
 8114108:	2300      	movs	r3, #0
 811410a:	e0a7      	b.n	811425c <pbuf_alloc+0x1cc>
        }
        qlen = LWIP_MIN(rem_len, (u16_t)(PBUF_POOL_BUFSIZE_ALIGNED - LWIP_MEM_ALIGN_SIZE(offset)));
 811410c:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
 811410e:	3303      	adds	r3, #3
 8114110:	b29b      	uxth	r3, r3
 8114112:	f023 0303 	bic.w	r3, r3, #3
 8114116:	b29b      	uxth	r3, r3
 8114118:	f5c3 7314 	rsb	r3, r3, #592	; 0x250
 811411c:	b29b      	uxth	r3, r3
 811411e:	8b7a      	ldrh	r2, [r7, #26]
 8114120:	4293      	cmp	r3, r2
 8114122:	bf28      	it	cs
 8114124:	4613      	movcs	r3, r2
 8114126:	81fb      	strh	r3, [r7, #14]
        pbuf_init_alloced_pbuf(q, LWIP_MEM_ALIGN((void *)((u8_t *)q + SIZEOF_STRUCT_PBUF + offset)),
 8114128:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
 811412a:	3310      	adds	r3, #16
 811412c:	693a      	ldr	r2, [r7, #16]
 811412e:	4413      	add	r3, r2
 8114130:	3303      	adds	r3, #3
 8114132:	f023 0303 	bic.w	r3, r3, #3
 8114136:	4618      	mov	r0, r3
 8114138:	89f9      	ldrh	r1, [r7, #14]
 811413a:	8b7a      	ldrh	r2, [r7, #26]
 811413c:	2300      	movs	r3, #0
 811413e:	9301      	str	r3, [sp, #4]
 8114140:	887b      	ldrh	r3, [r7, #2]
 8114142:	9300      	str	r3, [sp, #0]
 8114144:	460b      	mov	r3, r1
 8114146:	4601      	mov	r1, r0
 8114148:	6938      	ldr	r0, [r7, #16]
 811414a:	f7ff ff77 	bl	811403c <pbuf_init_alloced_pbuf>
                               rem_len, qlen, type, 0);
        LWIP_ASSERT("pbuf_alloc: pbuf q->payload properly aligned",
 811414e:	693b      	ldr	r3, [r7, #16]
 8114150:	685b      	ldr	r3, [r3, #4]
 8114152:	f003 0303 	and.w	r3, r3, #3
 8114156:	2b00      	cmp	r3, #0
 8114158:	d006      	beq.n	8114168 <pbuf_alloc+0xd8>
 811415a:	4b42      	ldr	r3, [pc, #264]	; (8114264 <pbuf_alloc+0x1d4>)
 811415c:	f44f 7280 	mov.w	r2, #256	; 0x100
 8114160:	4941      	ldr	r1, [pc, #260]	; (8114268 <pbuf_alloc+0x1d8>)
 8114162:	4842      	ldr	r0, [pc, #264]	; (811426c <pbuf_alloc+0x1dc>)
 8114164:	f007 fb4c 	bl	811b800 <iprintf>
                    ((mem_ptr_t)q->payload % MEM_ALIGNMENT) == 0);
        LWIP_ASSERT("PBUF_POOL_BUFSIZE must be bigger than MEM_ALIGNMENT",
 8114168:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
 811416a:	3303      	adds	r3, #3
 811416c:	f023 0303 	bic.w	r3, r3, #3
 8114170:	f5b3 7f14 	cmp.w	r3, #592	; 0x250
 8114174:	d106      	bne.n	8114184 <pbuf_alloc+0xf4>
 8114176:	4b3b      	ldr	r3, [pc, #236]	; (8114264 <pbuf_alloc+0x1d4>)
 8114178:	f44f 7281 	mov.w	r2, #258	; 0x102
 811417c:	493c      	ldr	r1, [pc, #240]	; (8114270 <pbuf_alloc+0x1e0>)
 811417e:	483b      	ldr	r0, [pc, #236]	; (811426c <pbuf_alloc+0x1dc>)
 8114180:	f007 fb3e 	bl	811b800 <iprintf>
                    (PBUF_POOL_BUFSIZE_ALIGNED - LWIP_MEM_ALIGN_SIZE(offset)) > 0 );
        if (p == NULL) {
 8114184:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8114186:	2b00      	cmp	r3, #0
 8114188:	d102      	bne.n	8114190 <pbuf_alloc+0x100>
          /* allocated head of pbuf chain (into p) */
          p = q;
 811418a:	693b      	ldr	r3, [r7, #16]
 811418c:	627b      	str	r3, [r7, #36]	; 0x24
 811418e:	e002      	b.n	8114196 <pbuf_alloc+0x106>
        } else {
          /* make previous pbuf point to this pbuf */
          last->next = q;
 8114190:	69fb      	ldr	r3, [r7, #28]
 8114192:	693a      	ldr	r2, [r7, #16]
 8114194:	601a      	str	r2, [r3, #0]
        }
        last = q;
 8114196:	693b      	ldr	r3, [r7, #16]
 8114198:	61fb      	str	r3, [r7, #28]
        rem_len = (u16_t)(rem_len - qlen);
 811419a:	8b7a      	ldrh	r2, [r7, #26]
 811419c:	89fb      	ldrh	r3, [r7, #14]
 811419e:	1ad3      	subs	r3, r2, r3
 81141a0:	837b      	strh	r3, [r7, #26]
        offset = 0;
 81141a2:	2300      	movs	r3, #0
 81141a4:	847b      	strh	r3, [r7, #34]	; 0x22
      } while (rem_len > 0);
 81141a6:	8b7b      	ldrh	r3, [r7, #26]
 81141a8:	2b00      	cmp	r3, #0
 81141aa:	d19e      	bne.n	81140ea <pbuf_alloc+0x5a>
      break;
 81141ac:	e055      	b.n	811425a <pbuf_alloc+0x1ca>
    }
    case PBUF_RAM: {
      u16_t payload_len = (u16_t)(LWIP_MEM_ALIGN_SIZE(offset) + LWIP_MEM_ALIGN_SIZE(length));
 81141ae:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
 81141b0:	3303      	adds	r3, #3
 81141b2:	b29b      	uxth	r3, r3
 81141b4:	f023 0303 	bic.w	r3, r3, #3
 81141b8:	b29a      	uxth	r2, r3
 81141ba:	88bb      	ldrh	r3, [r7, #4]
 81141bc:	3303      	adds	r3, #3
 81141be:	b29b      	uxth	r3, r3
 81141c0:	f023 0303 	bic.w	r3, r3, #3
 81141c4:	b29b      	uxth	r3, r3
 81141c6:	4413      	add	r3, r2
 81141c8:	833b      	strh	r3, [r7, #24]
      mem_size_t alloc_len = (mem_size_t)(LWIP_MEM_ALIGN_SIZE(SIZEOF_STRUCT_PBUF) + payload_len);
 81141ca:	8b3b      	ldrh	r3, [r7, #24]
 81141cc:	3310      	adds	r3, #16
 81141ce:	82fb      	strh	r3, [r7, #22]

      /* bug #50040: Check for integer overflow when calculating alloc_len */
      if ((payload_len < LWIP_MEM_ALIGN_SIZE(length)) ||
 81141d0:	8b3a      	ldrh	r2, [r7, #24]
 81141d2:	88bb      	ldrh	r3, [r7, #4]
 81141d4:	3303      	adds	r3, #3
 81141d6:	f023 0303 	bic.w	r3, r3, #3
 81141da:	429a      	cmp	r2, r3
 81141dc:	d306      	bcc.n	81141ec <pbuf_alloc+0x15c>
          (alloc_len < LWIP_MEM_ALIGN_SIZE(length))) {
 81141de:	8afa      	ldrh	r2, [r7, #22]
 81141e0:	88bb      	ldrh	r3, [r7, #4]
 81141e2:	3303      	adds	r3, #3
 81141e4:	f023 0303 	bic.w	r3, r3, #3
      if ((payload_len < LWIP_MEM_ALIGN_SIZE(length)) ||
 81141e8:	429a      	cmp	r2, r3
 81141ea:	d201      	bcs.n	81141f0 <pbuf_alloc+0x160>
        return NULL;
 81141ec:	2300      	movs	r3, #0
 81141ee:	e035      	b.n	811425c <pbuf_alloc+0x1cc>
      }

      /* If pbuf is to be allocated in RAM, allocate memory for it. */
      p = (struct pbuf *)mem_malloc(alloc_len);
 81141f0:	8afb      	ldrh	r3, [r7, #22]
 81141f2:	4618      	mov	r0, r3
 81141f4:	f7ff f9ce 	bl	8113594 <mem_malloc>
 81141f8:	6278      	str	r0, [r7, #36]	; 0x24
      if (p == NULL) {
 81141fa:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 81141fc:	2b00      	cmp	r3, #0
 81141fe:	d101      	bne.n	8114204 <pbuf_alloc+0x174>
        return NULL;
 8114200:	2300      	movs	r3, #0
 8114202:	e02b      	b.n	811425c <pbuf_alloc+0x1cc>
      }
      pbuf_init_alloced_pbuf(p, LWIP_MEM_ALIGN((void *)((u8_t *)p + SIZEOF_STRUCT_PBUF + offset)),
 8114204:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
 8114206:	3310      	adds	r3, #16
 8114208:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 811420a:	4413      	add	r3, r2
 811420c:	3303      	adds	r3, #3
 811420e:	f023 0303 	bic.w	r3, r3, #3
 8114212:	4618      	mov	r0, r3
 8114214:	88b9      	ldrh	r1, [r7, #4]
 8114216:	88ba      	ldrh	r2, [r7, #4]
 8114218:	2300      	movs	r3, #0
 811421a:	9301      	str	r3, [sp, #4]
 811421c:	887b      	ldrh	r3, [r7, #2]
 811421e:	9300      	str	r3, [sp, #0]
 8114220:	460b      	mov	r3, r1
 8114222:	4601      	mov	r1, r0
 8114224:	6a78      	ldr	r0, [r7, #36]	; 0x24
 8114226:	f7ff ff09 	bl	811403c <pbuf_init_alloced_pbuf>
                             length, length, type, 0);
      LWIP_ASSERT("pbuf_alloc: pbuf->payload properly aligned",
 811422a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 811422c:	685b      	ldr	r3, [r3, #4]
 811422e:	f003 0303 	and.w	r3, r3, #3
 8114232:	2b00      	cmp	r3, #0
 8114234:	d010      	beq.n	8114258 <pbuf_alloc+0x1c8>
 8114236:	4b0b      	ldr	r3, [pc, #44]	; (8114264 <pbuf_alloc+0x1d4>)
 8114238:	f44f 7291 	mov.w	r2, #290	; 0x122
 811423c:	490d      	ldr	r1, [pc, #52]	; (8114274 <pbuf_alloc+0x1e4>)
 811423e:	480b      	ldr	r0, [pc, #44]	; (811426c <pbuf_alloc+0x1dc>)
 8114240:	f007 fade 	bl	811b800 <iprintf>
                  ((mem_ptr_t)p->payload % MEM_ALIGNMENT) == 0);
      break;
 8114244:	e008      	b.n	8114258 <pbuf_alloc+0x1c8>
    }
    default:
      LWIP_ASSERT("pbuf_alloc: erroneous type", 0);
 8114246:	4b07      	ldr	r3, [pc, #28]	; (8114264 <pbuf_alloc+0x1d4>)
 8114248:	f240 1227 	movw	r2, #295	; 0x127
 811424c:	490a      	ldr	r1, [pc, #40]	; (8114278 <pbuf_alloc+0x1e8>)
 811424e:	4807      	ldr	r0, [pc, #28]	; (811426c <pbuf_alloc+0x1dc>)
 8114250:	f007 fad6 	bl	811b800 <iprintf>
      return NULL;
 8114254:	2300      	movs	r3, #0
 8114256:	e001      	b.n	811425c <pbuf_alloc+0x1cc>
      break;
 8114258:	bf00      	nop
  }
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_alloc(length=%"U16_F") == %p\n", length, (void *)p));
  return p;
 811425a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
}
 811425c:	4618      	mov	r0, r3
 811425e:	3728      	adds	r7, #40	; 0x28
 8114260:	46bd      	mov	sp, r7
 8114262:	bd80      	pop	{r7, pc}
 8114264:	0811da14 	.word	0x0811da14
 8114268:	0811da78 	.word	0x0811da78
 811426c:	0811daa8 	.word	0x0811daa8
 8114270:	0811dad0 	.word	0x0811dad0
 8114274:	0811db04 	.word	0x0811db04
 8114278:	0811db30 	.word	0x0811db30

0811427c <pbuf_alloc_reference>:
 *
 * @return the allocated pbuf.
 */
struct pbuf *
pbuf_alloc_reference(void *payload, u16_t length, pbuf_type type)
{
 811427c:	b580      	push	{r7, lr}
 811427e:	b086      	sub	sp, #24
 8114280:	af02      	add	r7, sp, #8
 8114282:	6078      	str	r0, [r7, #4]
 8114284:	460b      	mov	r3, r1
 8114286:	807b      	strh	r3, [r7, #2]
 8114288:	4613      	mov	r3, r2
 811428a:	803b      	strh	r3, [r7, #0]
  struct pbuf *p;
  LWIP_ASSERT("invalid pbuf_type", (type == PBUF_REF) || (type == PBUF_ROM));
 811428c:	883b      	ldrh	r3, [r7, #0]
 811428e:	2b41      	cmp	r3, #65	; 0x41
 8114290:	d009      	beq.n	81142a6 <pbuf_alloc_reference+0x2a>
 8114292:	883b      	ldrh	r3, [r7, #0]
 8114294:	2b01      	cmp	r3, #1
 8114296:	d006      	beq.n	81142a6 <pbuf_alloc_reference+0x2a>
 8114298:	4b0f      	ldr	r3, [pc, #60]	; (81142d8 <pbuf_alloc_reference+0x5c>)
 811429a:	f44f 72a5 	mov.w	r2, #330	; 0x14a
 811429e:	490f      	ldr	r1, [pc, #60]	; (81142dc <pbuf_alloc_reference+0x60>)
 81142a0:	480f      	ldr	r0, [pc, #60]	; (81142e0 <pbuf_alloc_reference+0x64>)
 81142a2:	f007 faad 	bl	811b800 <iprintf>
  /* only allocate memory for the pbuf structure */
  p = (struct pbuf *)memp_malloc(MEMP_PBUF);
 81142a6:	2007      	movs	r0, #7
 81142a8:	f7ff fb04 	bl	81138b4 <memp_malloc>
 81142ac:	60f8      	str	r0, [r7, #12]
  if (p == NULL) {
 81142ae:	68fb      	ldr	r3, [r7, #12]
 81142b0:	2b00      	cmp	r3, #0
 81142b2:	d101      	bne.n	81142b8 <pbuf_alloc_reference+0x3c>
    LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
                ("pbuf_alloc_reference: Could not allocate MEMP_PBUF for PBUF_%s.\n",
                 (type == PBUF_ROM) ? "ROM" : "REF"));
    return NULL;
 81142b4:	2300      	movs	r3, #0
 81142b6:	e00b      	b.n	81142d0 <pbuf_alloc_reference+0x54>
  }
  pbuf_init_alloced_pbuf(p, payload, length, length, type, 0);
 81142b8:	8879      	ldrh	r1, [r7, #2]
 81142ba:	887a      	ldrh	r2, [r7, #2]
 81142bc:	2300      	movs	r3, #0
 81142be:	9301      	str	r3, [sp, #4]
 81142c0:	883b      	ldrh	r3, [r7, #0]
 81142c2:	9300      	str	r3, [sp, #0]
 81142c4:	460b      	mov	r3, r1
 81142c6:	6879      	ldr	r1, [r7, #4]
 81142c8:	68f8      	ldr	r0, [r7, #12]
 81142ca:	f7ff feb7 	bl	811403c <pbuf_init_alloced_pbuf>
  return p;
 81142ce:	68fb      	ldr	r3, [r7, #12]
}
 81142d0:	4618      	mov	r0, r3
 81142d2:	3710      	adds	r7, #16
 81142d4:	46bd      	mov	sp, r7
 81142d6:	bd80      	pop	{r7, pc}
 81142d8:	0811da14 	.word	0x0811da14
 81142dc:	0811db4c 	.word	0x0811db4c
 81142e0:	0811daa8 	.word	0x0811daa8

081142e4 <pbuf_alloced_custom>:
 *        big enough to hold 'length' plus the header size
 */
struct pbuf *
pbuf_alloced_custom(pbuf_layer l, u16_t length, pbuf_type type, struct pbuf_custom *p,
                    void *payload_mem, u16_t payload_mem_len)
{
 81142e4:	b580      	push	{r7, lr}
 81142e6:	b088      	sub	sp, #32
 81142e8:	af02      	add	r7, sp, #8
 81142ea:	607b      	str	r3, [r7, #4]
 81142ec:	4603      	mov	r3, r0
 81142ee:	73fb      	strb	r3, [r7, #15]
 81142f0:	460b      	mov	r3, r1
 81142f2:	81bb      	strh	r3, [r7, #12]
 81142f4:	4613      	mov	r3, r2
 81142f6:	817b      	strh	r3, [r7, #10]
  u16_t offset = (u16_t)l;
 81142f8:	7bfb      	ldrb	r3, [r7, #15]
 81142fa:	827b      	strh	r3, [r7, #18]
  void *payload;
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_alloced_custom(length=%"U16_F")\n", length));

  if (LWIP_MEM_ALIGN_SIZE(offset) + length > payload_mem_len) {
 81142fc:	8a7b      	ldrh	r3, [r7, #18]
 81142fe:	3303      	adds	r3, #3
 8114300:	f023 0203 	bic.w	r2, r3, #3
 8114304:	89bb      	ldrh	r3, [r7, #12]
 8114306:	441a      	add	r2, r3
 8114308:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
 811430a:	429a      	cmp	r2, r3
 811430c:	d901      	bls.n	8114312 <pbuf_alloced_custom+0x2e>
    LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_LEVEL_WARNING, ("pbuf_alloced_custom(length=%"U16_F") buffer too short\n", length));
    return NULL;
 811430e:	2300      	movs	r3, #0
 8114310:	e018      	b.n	8114344 <pbuf_alloced_custom+0x60>
  }

  if (payload_mem != NULL) {
 8114312:	6a3b      	ldr	r3, [r7, #32]
 8114314:	2b00      	cmp	r3, #0
 8114316:	d007      	beq.n	8114328 <pbuf_alloced_custom+0x44>
    payload = (u8_t *)payload_mem + LWIP_MEM_ALIGN_SIZE(offset);
 8114318:	8a7b      	ldrh	r3, [r7, #18]
 811431a:	3303      	adds	r3, #3
 811431c:	f023 0303 	bic.w	r3, r3, #3
 8114320:	6a3a      	ldr	r2, [r7, #32]
 8114322:	4413      	add	r3, r2
 8114324:	617b      	str	r3, [r7, #20]
 8114326:	e001      	b.n	811432c <pbuf_alloced_custom+0x48>
  } else {
    payload = NULL;
 8114328:	2300      	movs	r3, #0
 811432a:	617b      	str	r3, [r7, #20]
  }
  pbuf_init_alloced_pbuf(&p->pbuf, payload, length, length, type, PBUF_FLAG_IS_CUSTOM);
 811432c:	6878      	ldr	r0, [r7, #4]
 811432e:	89b9      	ldrh	r1, [r7, #12]
 8114330:	89ba      	ldrh	r2, [r7, #12]
 8114332:	2302      	movs	r3, #2
 8114334:	9301      	str	r3, [sp, #4]
 8114336:	897b      	ldrh	r3, [r7, #10]
 8114338:	9300      	str	r3, [sp, #0]
 811433a:	460b      	mov	r3, r1
 811433c:	6979      	ldr	r1, [r7, #20]
 811433e:	f7ff fe7d 	bl	811403c <pbuf_init_alloced_pbuf>
  return &p->pbuf;
 8114342:	687b      	ldr	r3, [r7, #4]
}
 8114344:	4618      	mov	r0, r3
 8114346:	3718      	adds	r7, #24
 8114348:	46bd      	mov	sp, r7
 811434a:	bd80      	pop	{r7, pc}

0811434c <pbuf_realloc>:
 *
 * @note Despite its name, pbuf_realloc cannot grow the size of a pbuf (chain).
 */
void
pbuf_realloc(struct pbuf *p, u16_t new_len)
{
 811434c:	b580      	push	{r7, lr}
 811434e:	b084      	sub	sp, #16
 8114350:	af00      	add	r7, sp, #0
 8114352:	6078      	str	r0, [r7, #4]
 8114354:	460b      	mov	r3, r1
 8114356:	807b      	strh	r3, [r7, #2]
  struct pbuf *q;
  u16_t rem_len; /* remaining length */
  u16_t shrink;

  LWIP_ASSERT("pbuf_realloc: p != NULL", p != NULL);
 8114358:	687b      	ldr	r3, [r7, #4]
 811435a:	2b00      	cmp	r3, #0
 811435c:	d106      	bne.n	811436c <pbuf_realloc+0x20>
 811435e:	4b3a      	ldr	r3, [pc, #232]	; (8114448 <pbuf_realloc+0xfc>)
 8114360:	f44f 72cc 	mov.w	r2, #408	; 0x198
 8114364:	4939      	ldr	r1, [pc, #228]	; (811444c <pbuf_realloc+0x100>)
 8114366:	483a      	ldr	r0, [pc, #232]	; (8114450 <pbuf_realloc+0x104>)
 8114368:	f007 fa4a 	bl	811b800 <iprintf>

  /* desired length larger than current length? */
  if (new_len >= p->tot_len) {
 811436c:	687b      	ldr	r3, [r7, #4]
 811436e:	891b      	ldrh	r3, [r3, #8]
 8114370:	887a      	ldrh	r2, [r7, #2]
 8114372:	429a      	cmp	r2, r3
 8114374:	d263      	bcs.n	811443e <pbuf_realloc+0xf2>
    return;
  }

  /* the pbuf chain grows by (new_len - p->tot_len) bytes
   * (which may be negative in case of shrinking) */
  shrink = (u16_t)(p->tot_len - new_len);
 8114376:	687b      	ldr	r3, [r7, #4]
 8114378:	891a      	ldrh	r2, [r3, #8]
 811437a:	887b      	ldrh	r3, [r7, #2]
 811437c:	1ad3      	subs	r3, r2, r3
 811437e:	813b      	strh	r3, [r7, #8]

  /* first, step over any pbufs that should remain in the chain */
  rem_len = new_len;
 8114380:	887b      	ldrh	r3, [r7, #2]
 8114382:	817b      	strh	r3, [r7, #10]
  q = p;
 8114384:	687b      	ldr	r3, [r7, #4]
 8114386:	60fb      	str	r3, [r7, #12]
  /* should this pbuf be kept? */
  while (rem_len > q->len) {
 8114388:	e018      	b.n	81143bc <pbuf_realloc+0x70>
    /* decrease remaining length by pbuf length */
    rem_len = (u16_t)(rem_len - q->len);
 811438a:	68fb      	ldr	r3, [r7, #12]
 811438c:	895b      	ldrh	r3, [r3, #10]
 811438e:	897a      	ldrh	r2, [r7, #10]
 8114390:	1ad3      	subs	r3, r2, r3
 8114392:	817b      	strh	r3, [r7, #10]
    /* decrease total length indicator */
    q->tot_len = (u16_t)(q->tot_len - shrink);
 8114394:	68fb      	ldr	r3, [r7, #12]
 8114396:	891a      	ldrh	r2, [r3, #8]
 8114398:	893b      	ldrh	r3, [r7, #8]
 811439a:	1ad3      	subs	r3, r2, r3
 811439c:	b29a      	uxth	r2, r3
 811439e:	68fb      	ldr	r3, [r7, #12]
 81143a0:	811a      	strh	r2, [r3, #8]
    /* proceed to next pbuf in chain */
    q = q->next;
 81143a2:	68fb      	ldr	r3, [r7, #12]
 81143a4:	681b      	ldr	r3, [r3, #0]
 81143a6:	60fb      	str	r3, [r7, #12]
    LWIP_ASSERT("pbuf_realloc: q != NULL", q != NULL);
 81143a8:	68fb      	ldr	r3, [r7, #12]
 81143aa:	2b00      	cmp	r3, #0
 81143ac:	d106      	bne.n	81143bc <pbuf_realloc+0x70>
 81143ae:	4b26      	ldr	r3, [pc, #152]	; (8114448 <pbuf_realloc+0xfc>)
 81143b0:	f240 12af 	movw	r2, #431	; 0x1af
 81143b4:	4927      	ldr	r1, [pc, #156]	; (8114454 <pbuf_realloc+0x108>)
 81143b6:	4826      	ldr	r0, [pc, #152]	; (8114450 <pbuf_realloc+0x104>)
 81143b8:	f007 fa22 	bl	811b800 <iprintf>
  while (rem_len > q->len) {
 81143bc:	68fb      	ldr	r3, [r7, #12]
 81143be:	895b      	ldrh	r3, [r3, #10]
 81143c0:	897a      	ldrh	r2, [r7, #10]
 81143c2:	429a      	cmp	r2, r3
 81143c4:	d8e1      	bhi.n	811438a <pbuf_realloc+0x3e>
  /* we have now reached the new last pbuf (in q) */
  /* rem_len == desired length for pbuf q */

  /* shrink allocated memory for PBUF_RAM */
  /* (other types merely adjust their length fields */
  if (pbuf_match_allocsrc(q, PBUF_TYPE_ALLOC_SRC_MASK_STD_HEAP) && (rem_len != q->len)
 81143c6:	68fb      	ldr	r3, [r7, #12]
 81143c8:	7b1b      	ldrb	r3, [r3, #12]
 81143ca:	f003 030f 	and.w	r3, r3, #15
 81143ce:	2b00      	cmp	r3, #0
 81143d0:	d121      	bne.n	8114416 <pbuf_realloc+0xca>
 81143d2:	68fb      	ldr	r3, [r7, #12]
 81143d4:	895b      	ldrh	r3, [r3, #10]
 81143d6:	897a      	ldrh	r2, [r7, #10]
 81143d8:	429a      	cmp	r2, r3
 81143da:	d01c      	beq.n	8114416 <pbuf_realloc+0xca>
#if LWIP_SUPPORT_CUSTOM_PBUF
      && ((q->flags & PBUF_FLAG_IS_CUSTOM) == 0)
 81143dc:	68fb      	ldr	r3, [r7, #12]
 81143de:	7b5b      	ldrb	r3, [r3, #13]
 81143e0:	f003 0302 	and.w	r3, r3, #2
 81143e4:	2b00      	cmp	r3, #0
 81143e6:	d116      	bne.n	8114416 <pbuf_realloc+0xca>
#endif /* LWIP_SUPPORT_CUSTOM_PBUF */
     ) {
    /* reallocate and adjust the length of the pbuf that will be split */
    q = (struct pbuf *)mem_trim(q, (mem_size_t)(((u8_t *)q->payload - (u8_t *)q) + rem_len));
 81143e8:	68fb      	ldr	r3, [r7, #12]
 81143ea:	685a      	ldr	r2, [r3, #4]
 81143ec:	68fb      	ldr	r3, [r7, #12]
 81143ee:	1ad3      	subs	r3, r2, r3
 81143f0:	b29a      	uxth	r2, r3
 81143f2:	897b      	ldrh	r3, [r7, #10]
 81143f4:	4413      	add	r3, r2
 81143f6:	b29b      	uxth	r3, r3
 81143f8:	4619      	mov	r1, r3
 81143fa:	68f8      	ldr	r0, [r7, #12]
 81143fc:	f7fe ffce 	bl	811339c <mem_trim>
 8114400:	60f8      	str	r0, [r7, #12]
    LWIP_ASSERT("mem_trim returned q == NULL", q != NULL);
 8114402:	68fb      	ldr	r3, [r7, #12]
 8114404:	2b00      	cmp	r3, #0
 8114406:	d106      	bne.n	8114416 <pbuf_realloc+0xca>
 8114408:	4b0f      	ldr	r3, [pc, #60]	; (8114448 <pbuf_realloc+0xfc>)
 811440a:	f240 12bd 	movw	r2, #445	; 0x1bd
 811440e:	4912      	ldr	r1, [pc, #72]	; (8114458 <pbuf_realloc+0x10c>)
 8114410:	480f      	ldr	r0, [pc, #60]	; (8114450 <pbuf_realloc+0x104>)
 8114412:	f007 f9f5 	bl	811b800 <iprintf>
  }
  /* adjust length fields for new last pbuf */
  q->len = rem_len;
 8114416:	68fb      	ldr	r3, [r7, #12]
 8114418:	897a      	ldrh	r2, [r7, #10]
 811441a:	815a      	strh	r2, [r3, #10]
  q->tot_len = q->len;
 811441c:	68fb      	ldr	r3, [r7, #12]
 811441e:	895a      	ldrh	r2, [r3, #10]
 8114420:	68fb      	ldr	r3, [r7, #12]
 8114422:	811a      	strh	r2, [r3, #8]

  /* any remaining pbufs in chain? */
  if (q->next != NULL) {
 8114424:	68fb      	ldr	r3, [r7, #12]
 8114426:	681b      	ldr	r3, [r3, #0]
 8114428:	2b00      	cmp	r3, #0
 811442a:	d004      	beq.n	8114436 <pbuf_realloc+0xea>
    /* free remaining pbufs in chain */
    pbuf_free(q->next);
 811442c:	68fb      	ldr	r3, [r7, #12]
 811442e:	681b      	ldr	r3, [r3, #0]
 8114430:	4618      	mov	r0, r3
 8114432:	f000 f911 	bl	8114658 <pbuf_free>
  }
  /* q is last packet in chain */
  q->next = NULL;
 8114436:	68fb      	ldr	r3, [r7, #12]
 8114438:	2200      	movs	r2, #0
 811443a:	601a      	str	r2, [r3, #0]
 811443c:	e000      	b.n	8114440 <pbuf_realloc+0xf4>
    return;
 811443e:	bf00      	nop

}
 8114440:	3710      	adds	r7, #16
 8114442:	46bd      	mov	sp, r7
 8114444:	bd80      	pop	{r7, pc}
 8114446:	bf00      	nop
 8114448:	0811da14 	.word	0x0811da14
 811444c:	0811db60 	.word	0x0811db60
 8114450:	0811daa8 	.word	0x0811daa8
 8114454:	0811db78 	.word	0x0811db78
 8114458:	0811db90 	.word	0x0811db90

0811445c <pbuf_add_header_impl>:
 * @return non-zero on failure, zero on success.
 *
 */
static u8_t
pbuf_add_header_impl(struct pbuf *p, size_t header_size_increment, u8_t force)
{
 811445c:	b580      	push	{r7, lr}
 811445e:	b086      	sub	sp, #24
 8114460:	af00      	add	r7, sp, #0
 8114462:	60f8      	str	r0, [r7, #12]
 8114464:	60b9      	str	r1, [r7, #8]
 8114466:	4613      	mov	r3, r2
 8114468:	71fb      	strb	r3, [r7, #7]
  u16_t type_internal;
  void *payload;
  u16_t increment_magnitude;

  LWIP_ASSERT("p != NULL", p != NULL);
 811446a:	68fb      	ldr	r3, [r7, #12]
 811446c:	2b00      	cmp	r3, #0
 811446e:	d106      	bne.n	811447e <pbuf_add_header_impl+0x22>
 8114470:	4b2b      	ldr	r3, [pc, #172]	; (8114520 <pbuf_add_header_impl+0xc4>)
 8114472:	f240 12df 	movw	r2, #479	; 0x1df
 8114476:	492b      	ldr	r1, [pc, #172]	; (8114524 <pbuf_add_header_impl+0xc8>)
 8114478:	482b      	ldr	r0, [pc, #172]	; (8114528 <pbuf_add_header_impl+0xcc>)
 811447a:	f007 f9c1 	bl	811b800 <iprintf>
  if ((p == NULL) || (header_size_increment > 0xFFFF)) {
 811447e:	68fb      	ldr	r3, [r7, #12]
 8114480:	2b00      	cmp	r3, #0
 8114482:	d003      	beq.n	811448c <pbuf_add_header_impl+0x30>
 8114484:	68bb      	ldr	r3, [r7, #8]
 8114486:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 811448a:	d301      	bcc.n	8114490 <pbuf_add_header_impl+0x34>
    return 1;
 811448c:	2301      	movs	r3, #1
 811448e:	e043      	b.n	8114518 <pbuf_add_header_impl+0xbc>
  }
  if (header_size_increment == 0) {
 8114490:	68bb      	ldr	r3, [r7, #8]
 8114492:	2b00      	cmp	r3, #0
 8114494:	d101      	bne.n	811449a <pbuf_add_header_impl+0x3e>
    return 0;
 8114496:	2300      	movs	r3, #0
 8114498:	e03e      	b.n	8114518 <pbuf_add_header_impl+0xbc>
  }

  increment_magnitude = (u16_t)header_size_increment;
 811449a:	68bb      	ldr	r3, [r7, #8]
 811449c:	827b      	strh	r3, [r7, #18]
  /* Do not allow tot_len to wrap as a result. */
  if ((u16_t)(increment_magnitude + p->tot_len) < increment_magnitude) {
 811449e:	68fb      	ldr	r3, [r7, #12]
 81144a0:	891a      	ldrh	r2, [r3, #8]
 81144a2:	8a7b      	ldrh	r3, [r7, #18]
 81144a4:	4413      	add	r3, r2
 81144a6:	b29b      	uxth	r3, r3
 81144a8:	8a7a      	ldrh	r2, [r7, #18]
 81144aa:	429a      	cmp	r2, r3
 81144ac:	d901      	bls.n	81144b2 <pbuf_add_header_impl+0x56>
    return 1;
 81144ae:	2301      	movs	r3, #1
 81144b0:	e032      	b.n	8114518 <pbuf_add_header_impl+0xbc>
  }

  type_internal = p->type_internal;
 81144b2:	68fb      	ldr	r3, [r7, #12]
 81144b4:	7b1b      	ldrb	r3, [r3, #12]
 81144b6:	823b      	strh	r3, [r7, #16]

  /* pbuf types containing payloads? */
  if (type_internal & PBUF_TYPE_FLAG_STRUCT_DATA_CONTIGUOUS) {
 81144b8:	8a3b      	ldrh	r3, [r7, #16]
 81144ba:	f003 0380 	and.w	r3, r3, #128	; 0x80
 81144be:	2b00      	cmp	r3, #0
 81144c0:	d00c      	beq.n	81144dc <pbuf_add_header_impl+0x80>
    /* set new payload pointer */
    payload = (u8_t *)p->payload - header_size_increment;
 81144c2:	68fb      	ldr	r3, [r7, #12]
 81144c4:	685a      	ldr	r2, [r3, #4]
 81144c6:	68bb      	ldr	r3, [r7, #8]
 81144c8:	425b      	negs	r3, r3
 81144ca:	4413      	add	r3, r2
 81144cc:	617b      	str	r3, [r7, #20]
    /* boundary check fails? */
    if ((u8_t *)payload < (u8_t *)p + SIZEOF_STRUCT_PBUF) {
 81144ce:	68fb      	ldr	r3, [r7, #12]
 81144d0:	3310      	adds	r3, #16
 81144d2:	697a      	ldr	r2, [r7, #20]
 81144d4:	429a      	cmp	r2, r3
 81144d6:	d20d      	bcs.n	81144f4 <pbuf_add_header_impl+0x98>
      LWIP_DEBUGF( PBUF_DEBUG | LWIP_DBG_TRACE,
                   ("pbuf_add_header: failed as %p < %p (not enough space for new header size)\n",
                    (void *)payload, (void *)((u8_t *)p + SIZEOF_STRUCT_PBUF)));
      /* bail out unsuccessfully */
      return 1;
 81144d8:	2301      	movs	r3, #1
 81144da:	e01d      	b.n	8114518 <pbuf_add_header_impl+0xbc>
    }
    /* pbuf types referring to external payloads? */
  } else {
    /* hide a header in the payload? */
    if (force) {
 81144dc:	79fb      	ldrb	r3, [r7, #7]
 81144de:	2b00      	cmp	r3, #0
 81144e0:	d006      	beq.n	81144f0 <pbuf_add_header_impl+0x94>
      payload = (u8_t *)p->payload - header_size_increment;
 81144e2:	68fb      	ldr	r3, [r7, #12]
 81144e4:	685a      	ldr	r2, [r3, #4]
 81144e6:	68bb      	ldr	r3, [r7, #8]
 81144e8:	425b      	negs	r3, r3
 81144ea:	4413      	add	r3, r2
 81144ec:	617b      	str	r3, [r7, #20]
 81144ee:	e001      	b.n	81144f4 <pbuf_add_header_impl+0x98>
    } else {
      /* cannot expand payload to front (yet!)
       * bail out unsuccessfully */
      return 1;
 81144f0:	2301      	movs	r3, #1
 81144f2:	e011      	b.n	8114518 <pbuf_add_header_impl+0xbc>
  }
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_add_header: old %p new %p (%"U16_F")\n",
              (void *)p->payload, (void *)payload, increment_magnitude));

  /* modify pbuf fields */
  p->payload = payload;
 81144f4:	68fb      	ldr	r3, [r7, #12]
 81144f6:	697a      	ldr	r2, [r7, #20]
 81144f8:	605a      	str	r2, [r3, #4]
  p->len = (u16_t)(p->len + increment_magnitude);
 81144fa:	68fb      	ldr	r3, [r7, #12]
 81144fc:	895a      	ldrh	r2, [r3, #10]
 81144fe:	8a7b      	ldrh	r3, [r7, #18]
 8114500:	4413      	add	r3, r2
 8114502:	b29a      	uxth	r2, r3
 8114504:	68fb      	ldr	r3, [r7, #12]
 8114506:	815a      	strh	r2, [r3, #10]
  p->tot_len = (u16_t)(p->tot_len + increment_magnitude);
 8114508:	68fb      	ldr	r3, [r7, #12]
 811450a:	891a      	ldrh	r2, [r3, #8]
 811450c:	8a7b      	ldrh	r3, [r7, #18]
 811450e:	4413      	add	r3, r2
 8114510:	b29a      	uxth	r2, r3
 8114512:	68fb      	ldr	r3, [r7, #12]
 8114514:	811a      	strh	r2, [r3, #8]


  return 0;
 8114516:	2300      	movs	r3, #0
}
 8114518:	4618      	mov	r0, r3
 811451a:	3718      	adds	r7, #24
 811451c:	46bd      	mov	sp, r7
 811451e:	bd80      	pop	{r7, pc}
 8114520:	0811da14 	.word	0x0811da14
 8114524:	0811dbac 	.word	0x0811dbac
 8114528:	0811daa8 	.word	0x0811daa8

0811452c <pbuf_add_header>:
 * @return non-zero on failure, zero on success.
 *
 */
u8_t
pbuf_add_header(struct pbuf *p, size_t header_size_increment)
{
 811452c:	b580      	push	{r7, lr}
 811452e:	b082      	sub	sp, #8
 8114530:	af00      	add	r7, sp, #0
 8114532:	6078      	str	r0, [r7, #4]
 8114534:	6039      	str	r1, [r7, #0]
  return pbuf_add_header_impl(p, header_size_increment, 0);
 8114536:	2200      	movs	r2, #0
 8114538:	6839      	ldr	r1, [r7, #0]
 811453a:	6878      	ldr	r0, [r7, #4]
 811453c:	f7ff ff8e 	bl	811445c <pbuf_add_header_impl>
 8114540:	4603      	mov	r3, r0
}
 8114542:	4618      	mov	r0, r3
 8114544:	3708      	adds	r7, #8
 8114546:	46bd      	mov	sp, r7
 8114548:	bd80      	pop	{r7, pc}
	...

0811454c <pbuf_remove_header>:
 * @return non-zero on failure, zero on success.
 *
 */
u8_t
pbuf_remove_header(struct pbuf *p, size_t header_size_decrement)
{
 811454c:	b580      	push	{r7, lr}
 811454e:	b084      	sub	sp, #16
 8114550:	af00      	add	r7, sp, #0
 8114552:	6078      	str	r0, [r7, #4]
 8114554:	6039      	str	r1, [r7, #0]
  void *payload;
  u16_t increment_magnitude;

  LWIP_ASSERT("p != NULL", p != NULL);
 8114556:	687b      	ldr	r3, [r7, #4]
 8114558:	2b00      	cmp	r3, #0
 811455a:	d106      	bne.n	811456a <pbuf_remove_header+0x1e>
 811455c:	4b20      	ldr	r3, [pc, #128]	; (81145e0 <pbuf_remove_header+0x94>)
 811455e:	f240 224b 	movw	r2, #587	; 0x24b
 8114562:	4920      	ldr	r1, [pc, #128]	; (81145e4 <pbuf_remove_header+0x98>)
 8114564:	4820      	ldr	r0, [pc, #128]	; (81145e8 <pbuf_remove_header+0x9c>)
 8114566:	f007 f94b 	bl	811b800 <iprintf>
  if ((p == NULL) || (header_size_decrement > 0xFFFF)) {
 811456a:	687b      	ldr	r3, [r7, #4]
 811456c:	2b00      	cmp	r3, #0
 811456e:	d003      	beq.n	8114578 <pbuf_remove_header+0x2c>
 8114570:	683b      	ldr	r3, [r7, #0]
 8114572:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 8114576:	d301      	bcc.n	811457c <pbuf_remove_header+0x30>
    return 1;
 8114578:	2301      	movs	r3, #1
 811457a:	e02c      	b.n	81145d6 <pbuf_remove_header+0x8a>
  }
  if (header_size_decrement == 0) {
 811457c:	683b      	ldr	r3, [r7, #0]
 811457e:	2b00      	cmp	r3, #0
 8114580:	d101      	bne.n	8114586 <pbuf_remove_header+0x3a>
    return 0;
 8114582:	2300      	movs	r3, #0
 8114584:	e027      	b.n	81145d6 <pbuf_remove_header+0x8a>
  }

  increment_magnitude = (u16_t)header_size_decrement;
 8114586:	683b      	ldr	r3, [r7, #0]
 8114588:	81fb      	strh	r3, [r7, #14]
  /* Check that we aren't going to move off the end of the pbuf */
  LWIP_ERROR("increment_magnitude <= p->len", (increment_magnitude <= p->len), return 1;);
 811458a:	687b      	ldr	r3, [r7, #4]
 811458c:	895b      	ldrh	r3, [r3, #10]
 811458e:	89fa      	ldrh	r2, [r7, #14]
 8114590:	429a      	cmp	r2, r3
 8114592:	d908      	bls.n	81145a6 <pbuf_remove_header+0x5a>
 8114594:	4b12      	ldr	r3, [pc, #72]	; (81145e0 <pbuf_remove_header+0x94>)
 8114596:	f240 2255 	movw	r2, #597	; 0x255
 811459a:	4914      	ldr	r1, [pc, #80]	; (81145ec <pbuf_remove_header+0xa0>)
 811459c:	4812      	ldr	r0, [pc, #72]	; (81145e8 <pbuf_remove_header+0x9c>)
 811459e:	f007 f92f 	bl	811b800 <iprintf>
 81145a2:	2301      	movs	r3, #1
 81145a4:	e017      	b.n	81145d6 <pbuf_remove_header+0x8a>

  /* remember current payload pointer */
  payload = p->payload;
 81145a6:	687b      	ldr	r3, [r7, #4]
 81145a8:	685b      	ldr	r3, [r3, #4]
 81145aa:	60bb      	str	r3, [r7, #8]
  LWIP_UNUSED_ARG(payload); /* only used in LWIP_DEBUGF below */

  /* increase payload pointer (guarded by length check above) */
  p->payload = (u8_t *)p->payload + header_size_decrement;
 81145ac:	687b      	ldr	r3, [r7, #4]
 81145ae:	685a      	ldr	r2, [r3, #4]
 81145b0:	683b      	ldr	r3, [r7, #0]
 81145b2:	441a      	add	r2, r3
 81145b4:	687b      	ldr	r3, [r7, #4]
 81145b6:	605a      	str	r2, [r3, #4]
  /* modify pbuf length fields */
  p->len = (u16_t)(p->len - increment_magnitude);
 81145b8:	687b      	ldr	r3, [r7, #4]
 81145ba:	895a      	ldrh	r2, [r3, #10]
 81145bc:	89fb      	ldrh	r3, [r7, #14]
 81145be:	1ad3      	subs	r3, r2, r3
 81145c0:	b29a      	uxth	r2, r3
 81145c2:	687b      	ldr	r3, [r7, #4]
 81145c4:	815a      	strh	r2, [r3, #10]
  p->tot_len = (u16_t)(p->tot_len - increment_magnitude);
 81145c6:	687b      	ldr	r3, [r7, #4]
 81145c8:	891a      	ldrh	r2, [r3, #8]
 81145ca:	89fb      	ldrh	r3, [r7, #14]
 81145cc:	1ad3      	subs	r3, r2, r3
 81145ce:	b29a      	uxth	r2, r3
 81145d0:	687b      	ldr	r3, [r7, #4]
 81145d2:	811a      	strh	r2, [r3, #8]

  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_remove_header: old %p new %p (%"U16_F")\n",
              (void *)payload, (void *)p->payload, increment_magnitude));

  return 0;
 81145d4:	2300      	movs	r3, #0
}
 81145d6:	4618      	mov	r0, r3
 81145d8:	3710      	adds	r7, #16
 81145da:	46bd      	mov	sp, r7
 81145dc:	bd80      	pop	{r7, pc}
 81145de:	bf00      	nop
 81145e0:	0811da14 	.word	0x0811da14
 81145e4:	0811dbac 	.word	0x0811dbac
 81145e8:	0811daa8 	.word	0x0811daa8
 81145ec:	0811dbb8 	.word	0x0811dbb8

081145f0 <pbuf_header_impl>:

static u8_t
pbuf_header_impl(struct pbuf *p, s16_t header_size_increment, u8_t force)
{
 81145f0:	b580      	push	{r7, lr}
 81145f2:	b082      	sub	sp, #8
 81145f4:	af00      	add	r7, sp, #0
 81145f6:	6078      	str	r0, [r7, #4]
 81145f8:	460b      	mov	r3, r1
 81145fa:	807b      	strh	r3, [r7, #2]
 81145fc:	4613      	mov	r3, r2
 81145fe:	707b      	strb	r3, [r7, #1]
  if (header_size_increment < 0) {
 8114600:	f9b7 3002 	ldrsh.w	r3, [r7, #2]
 8114604:	2b00      	cmp	r3, #0
 8114606:	da08      	bge.n	811461a <pbuf_header_impl+0x2a>
    return pbuf_remove_header(p, (size_t) - header_size_increment);
 8114608:	f9b7 3002 	ldrsh.w	r3, [r7, #2]
 811460c:	425b      	negs	r3, r3
 811460e:	4619      	mov	r1, r3
 8114610:	6878      	ldr	r0, [r7, #4]
 8114612:	f7ff ff9b 	bl	811454c <pbuf_remove_header>
 8114616:	4603      	mov	r3, r0
 8114618:	e007      	b.n	811462a <pbuf_header_impl+0x3a>
  } else {
    return pbuf_add_header_impl(p, (size_t)header_size_increment, force);
 811461a:	f9b7 3002 	ldrsh.w	r3, [r7, #2]
 811461e:	787a      	ldrb	r2, [r7, #1]
 8114620:	4619      	mov	r1, r3
 8114622:	6878      	ldr	r0, [r7, #4]
 8114624:	f7ff ff1a 	bl	811445c <pbuf_add_header_impl>
 8114628:	4603      	mov	r3, r0
  }
}
 811462a:	4618      	mov	r0, r3
 811462c:	3708      	adds	r7, #8
 811462e:	46bd      	mov	sp, r7
 8114630:	bd80      	pop	{r7, pc}

08114632 <pbuf_header_force>:
 * Same as pbuf_header but does not check if 'header_size > 0' is allowed.
 * This is used internally only, to allow PBUF_REF for RX.
 */
u8_t
pbuf_header_force(struct pbuf *p, s16_t header_size_increment)
{
 8114632:	b580      	push	{r7, lr}
 8114634:	b082      	sub	sp, #8
 8114636:	af00      	add	r7, sp, #0
 8114638:	6078      	str	r0, [r7, #4]
 811463a:	460b      	mov	r3, r1
 811463c:	807b      	strh	r3, [r7, #2]
  return pbuf_header_impl(p, header_size_increment, 1);
 811463e:	f9b7 3002 	ldrsh.w	r3, [r7, #2]
 8114642:	2201      	movs	r2, #1
 8114644:	4619      	mov	r1, r3
 8114646:	6878      	ldr	r0, [r7, #4]
 8114648:	f7ff ffd2 	bl	81145f0 <pbuf_header_impl>
 811464c:	4603      	mov	r3, r0
}
 811464e:	4618      	mov	r0, r3
 8114650:	3708      	adds	r7, #8
 8114652:	46bd      	mov	sp, r7
 8114654:	bd80      	pop	{r7, pc}
	...

08114658 <pbuf_free>:
 * 1->1->1 becomes .......
 *
 */
u8_t
pbuf_free(struct pbuf *p)
{
 8114658:	b580      	push	{r7, lr}
 811465a:	b086      	sub	sp, #24
 811465c:	af00      	add	r7, sp, #0
 811465e:	6078      	str	r0, [r7, #4]
  u8_t alloc_src;
  struct pbuf *q;
  u8_t count;

  if (p == NULL) {
 8114660:	687b      	ldr	r3, [r7, #4]
 8114662:	2b00      	cmp	r3, #0
 8114664:	d10b      	bne.n	811467e <pbuf_free+0x26>
    LWIP_ASSERT("p != NULL", p != NULL);
 8114666:	687b      	ldr	r3, [r7, #4]
 8114668:	2b00      	cmp	r3, #0
 811466a:	d106      	bne.n	811467a <pbuf_free+0x22>
 811466c:	4b38      	ldr	r3, [pc, #224]	; (8114750 <pbuf_free+0xf8>)
 811466e:	f44f 7237 	mov.w	r2, #732	; 0x2dc
 8114672:	4938      	ldr	r1, [pc, #224]	; (8114754 <pbuf_free+0xfc>)
 8114674:	4838      	ldr	r0, [pc, #224]	; (8114758 <pbuf_free+0x100>)
 8114676:	f007 f8c3 	bl	811b800 <iprintf>
    /* if assertions are disabled, proceed with debug output */
    LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
                ("pbuf_free(p == NULL) was called.\n"));
    return 0;
 811467a:	2300      	movs	r3, #0
 811467c:	e063      	b.n	8114746 <pbuf_free+0xee>
  }
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_free(%p)\n", (void *)p));

  PERF_START;

  count = 0;
 811467e:	2300      	movs	r3, #0
 8114680:	75fb      	strb	r3, [r7, #23]
  /* de-allocate all consecutive pbufs from the head of the chain that
   * obtain a zero reference count after decrementing*/
  while (p != NULL) {
 8114682:	e05c      	b.n	811473e <pbuf_free+0xe6>
    /* Since decrementing ref cannot be guaranteed to be a single machine operation
     * we must protect it. We put the new ref into a local variable to prevent
     * further protection. */
    SYS_ARCH_PROTECT(old_level);
    /* all pbufs in a chain are referenced at least once */
    LWIP_ASSERT("pbuf_free: p->ref > 0", p->ref > 0);
 8114684:	687b      	ldr	r3, [r7, #4]
 8114686:	7b9b      	ldrb	r3, [r3, #14]
 8114688:	2b00      	cmp	r3, #0
 811468a:	d106      	bne.n	811469a <pbuf_free+0x42>
 811468c:	4b30      	ldr	r3, [pc, #192]	; (8114750 <pbuf_free+0xf8>)
 811468e:	f240 22f1 	movw	r2, #753	; 0x2f1
 8114692:	4932      	ldr	r1, [pc, #200]	; (811475c <pbuf_free+0x104>)
 8114694:	4830      	ldr	r0, [pc, #192]	; (8114758 <pbuf_free+0x100>)
 8114696:	f007 f8b3 	bl	811b800 <iprintf>
    /* decrease reference count (number of pointers to pbuf) */
    ref = --(p->ref);
 811469a:	687b      	ldr	r3, [r7, #4]
 811469c:	7b9b      	ldrb	r3, [r3, #14]
 811469e:	3b01      	subs	r3, #1
 81146a0:	b2da      	uxtb	r2, r3
 81146a2:	687b      	ldr	r3, [r7, #4]
 81146a4:	739a      	strb	r2, [r3, #14]
 81146a6:	687b      	ldr	r3, [r7, #4]
 81146a8:	7b9b      	ldrb	r3, [r3, #14]
 81146aa:	75bb      	strb	r3, [r7, #22]
    SYS_ARCH_UNPROTECT(old_level);
    /* this pbuf is no longer referenced to? */
    if (ref == 0) {
 81146ac:	7dbb      	ldrb	r3, [r7, #22]
 81146ae:	2b00      	cmp	r3, #0
 81146b0:	d143      	bne.n	811473a <pbuf_free+0xe2>
      /* remember next pbuf in chain for next iteration */
      q = p->next;
 81146b2:	687b      	ldr	r3, [r7, #4]
 81146b4:	681b      	ldr	r3, [r3, #0]
 81146b6:	613b      	str	r3, [r7, #16]
      LWIP_DEBUGF( PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_free: deallocating %p\n", (void *)p));
      alloc_src = pbuf_get_allocsrc(p);
 81146b8:	687b      	ldr	r3, [r7, #4]
 81146ba:	7b1b      	ldrb	r3, [r3, #12]
 81146bc:	f003 030f 	and.w	r3, r3, #15
 81146c0:	73fb      	strb	r3, [r7, #15]
#if LWIP_SUPPORT_CUSTOM_PBUF
      /* is this a custom pbuf? */
      if ((p->flags & PBUF_FLAG_IS_CUSTOM) != 0) {
 81146c2:	687b      	ldr	r3, [r7, #4]
 81146c4:	7b5b      	ldrb	r3, [r3, #13]
 81146c6:	f003 0302 	and.w	r3, r3, #2
 81146ca:	2b00      	cmp	r3, #0
 81146cc:	d011      	beq.n	81146f2 <pbuf_free+0x9a>
        struct pbuf_custom *pc = (struct pbuf_custom *)p;
 81146ce:	687b      	ldr	r3, [r7, #4]
 81146d0:	60bb      	str	r3, [r7, #8]
        LWIP_ASSERT("pc->custom_free_function != NULL", pc->custom_free_function != NULL);
 81146d2:	68bb      	ldr	r3, [r7, #8]
 81146d4:	691b      	ldr	r3, [r3, #16]
 81146d6:	2b00      	cmp	r3, #0
 81146d8:	d106      	bne.n	81146e8 <pbuf_free+0x90>
 81146da:	4b1d      	ldr	r3, [pc, #116]	; (8114750 <pbuf_free+0xf8>)
 81146dc:	f240 22ff 	movw	r2, #767	; 0x2ff
 81146e0:	491f      	ldr	r1, [pc, #124]	; (8114760 <pbuf_free+0x108>)
 81146e2:	481d      	ldr	r0, [pc, #116]	; (8114758 <pbuf_free+0x100>)
 81146e4:	f007 f88c 	bl	811b800 <iprintf>
        pc->custom_free_function(p);
 81146e8:	68bb      	ldr	r3, [r7, #8]
 81146ea:	691b      	ldr	r3, [r3, #16]
 81146ec:	6878      	ldr	r0, [r7, #4]
 81146ee:	4798      	blx	r3
 81146f0:	e01d      	b.n	811472e <pbuf_free+0xd6>
      } else
#endif /* LWIP_SUPPORT_CUSTOM_PBUF */
      {
        /* is this a pbuf from the pool? */
        if (alloc_src == PBUF_TYPE_ALLOC_SRC_MASK_STD_MEMP_PBUF_POOL) {
 81146f2:	7bfb      	ldrb	r3, [r7, #15]
 81146f4:	2b02      	cmp	r3, #2
 81146f6:	d104      	bne.n	8114702 <pbuf_free+0xaa>
          memp_free(MEMP_PBUF_POOL, p);
 81146f8:	6879      	ldr	r1, [r7, #4]
 81146fa:	2008      	movs	r0, #8
 81146fc:	f7ff f94a 	bl	8113994 <memp_free>
 8114700:	e015      	b.n	811472e <pbuf_free+0xd6>
          /* is this a ROM or RAM referencing pbuf? */
        } else if (alloc_src == PBUF_TYPE_ALLOC_SRC_MASK_STD_MEMP_PBUF) {
 8114702:	7bfb      	ldrb	r3, [r7, #15]
 8114704:	2b01      	cmp	r3, #1
 8114706:	d104      	bne.n	8114712 <pbuf_free+0xba>
          memp_free(MEMP_PBUF, p);
 8114708:	6879      	ldr	r1, [r7, #4]
 811470a:	2007      	movs	r0, #7
 811470c:	f7ff f942 	bl	8113994 <memp_free>
 8114710:	e00d      	b.n	811472e <pbuf_free+0xd6>
          /* type == PBUF_RAM */
        } else if (alloc_src == PBUF_TYPE_ALLOC_SRC_MASK_STD_HEAP) {
 8114712:	7bfb      	ldrb	r3, [r7, #15]
 8114714:	2b00      	cmp	r3, #0
 8114716:	d103      	bne.n	8114720 <pbuf_free+0xc8>
          mem_free(p);
 8114718:	6878      	ldr	r0, [r7, #4]
 811471a:	f7fe fdd5 	bl	81132c8 <mem_free>
 811471e:	e006      	b.n	811472e <pbuf_free+0xd6>
        } else {
          /* @todo: support freeing other types */
          LWIP_ASSERT("invalid pbuf type", 0);
 8114720:	4b0b      	ldr	r3, [pc, #44]	; (8114750 <pbuf_free+0xf8>)
 8114722:	f240 320f 	movw	r2, #783	; 0x30f
 8114726:	490f      	ldr	r1, [pc, #60]	; (8114764 <pbuf_free+0x10c>)
 8114728:	480b      	ldr	r0, [pc, #44]	; (8114758 <pbuf_free+0x100>)
 811472a:	f007 f869 	bl	811b800 <iprintf>
        }
      }
      count++;
 811472e:	7dfb      	ldrb	r3, [r7, #23]
 8114730:	3301      	adds	r3, #1
 8114732:	75fb      	strb	r3, [r7, #23]
      /* proceed to next pbuf */
      p = q;
 8114734:	693b      	ldr	r3, [r7, #16]
 8114736:	607b      	str	r3, [r7, #4]
 8114738:	e001      	b.n	811473e <pbuf_free+0xe6>
      /* p->ref > 0, this pbuf is still referenced to */
      /* (and so the remaining pbufs in chain as well) */
    } else {
      LWIP_DEBUGF( PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_free: %p has ref %"U16_F", ending here.\n", (void *)p, (u16_t)ref));
      /* stop walking through the chain */
      p = NULL;
 811473a:	2300      	movs	r3, #0
 811473c:	607b      	str	r3, [r7, #4]
  while (p != NULL) {
 811473e:	687b      	ldr	r3, [r7, #4]
 8114740:	2b00      	cmp	r3, #0
 8114742:	d19f      	bne.n	8114684 <pbuf_free+0x2c>
    }
  }
  PERF_STOP("pbuf_free");
  /* return number of de-allocated pbufs */
  return count;
 8114744:	7dfb      	ldrb	r3, [r7, #23]
}
 8114746:	4618      	mov	r0, r3
 8114748:	3718      	adds	r7, #24
 811474a:	46bd      	mov	sp, r7
 811474c:	bd80      	pop	{r7, pc}
 811474e:	bf00      	nop
 8114750:	0811da14 	.word	0x0811da14
 8114754:	0811dbac 	.word	0x0811dbac
 8114758:	0811daa8 	.word	0x0811daa8
 811475c:	0811dbd8 	.word	0x0811dbd8
 8114760:	0811dbf0 	.word	0x0811dbf0
 8114764:	0811dc14 	.word	0x0811dc14

08114768 <pbuf_clen>:
 * @param p first pbuf of chain
 * @return the number of pbufs in a chain
 */
u16_t
pbuf_clen(const struct pbuf *p)
{
 8114768:	b480      	push	{r7}
 811476a:	b085      	sub	sp, #20
 811476c:	af00      	add	r7, sp, #0
 811476e:	6078      	str	r0, [r7, #4]
  u16_t len;

  len = 0;
 8114770:	2300      	movs	r3, #0
 8114772:	81fb      	strh	r3, [r7, #14]
  while (p != NULL) {
 8114774:	e005      	b.n	8114782 <pbuf_clen+0x1a>
    ++len;
 8114776:	89fb      	ldrh	r3, [r7, #14]
 8114778:	3301      	adds	r3, #1
 811477a:	81fb      	strh	r3, [r7, #14]
    p = p->next;
 811477c:	687b      	ldr	r3, [r7, #4]
 811477e:	681b      	ldr	r3, [r3, #0]
 8114780:	607b      	str	r3, [r7, #4]
  while (p != NULL) {
 8114782:	687b      	ldr	r3, [r7, #4]
 8114784:	2b00      	cmp	r3, #0
 8114786:	d1f6      	bne.n	8114776 <pbuf_clen+0xe>
  }
  return len;
 8114788:	89fb      	ldrh	r3, [r7, #14]
}
 811478a:	4618      	mov	r0, r3
 811478c:	3714      	adds	r7, #20
 811478e:	46bd      	mov	sp, r7
 8114790:	f85d 7b04 	ldr.w	r7, [sp], #4
 8114794:	4770      	bx	lr
	...

08114798 <pbuf_ref>:
 * @param p pbuf to increase reference counter of
 *
 */
void
pbuf_ref(struct pbuf *p)
{
 8114798:	b580      	push	{r7, lr}
 811479a:	b082      	sub	sp, #8
 811479c:	af00      	add	r7, sp, #0
 811479e:	6078      	str	r0, [r7, #4]
  /* pbuf given? */
  if (p != NULL) {
 81147a0:	687b      	ldr	r3, [r7, #4]
 81147a2:	2b00      	cmp	r3, #0
 81147a4:	d010      	beq.n	81147c8 <pbuf_ref+0x30>
    SYS_ARCH_SET(p->ref, (LWIP_PBUF_REF_T)(p->ref + 1));
 81147a6:	687b      	ldr	r3, [r7, #4]
 81147a8:	7b9b      	ldrb	r3, [r3, #14]
 81147aa:	3301      	adds	r3, #1
 81147ac:	b2da      	uxtb	r2, r3
 81147ae:	687b      	ldr	r3, [r7, #4]
 81147b0:	739a      	strb	r2, [r3, #14]
    LWIP_ASSERT("pbuf ref overflow", p->ref > 0);
 81147b2:	687b      	ldr	r3, [r7, #4]
 81147b4:	7b9b      	ldrb	r3, [r3, #14]
 81147b6:	2b00      	cmp	r3, #0
 81147b8:	d106      	bne.n	81147c8 <pbuf_ref+0x30>
 81147ba:	4b05      	ldr	r3, [pc, #20]	; (81147d0 <pbuf_ref+0x38>)
 81147bc:	f240 3242 	movw	r2, #834	; 0x342
 81147c0:	4904      	ldr	r1, [pc, #16]	; (81147d4 <pbuf_ref+0x3c>)
 81147c2:	4805      	ldr	r0, [pc, #20]	; (81147d8 <pbuf_ref+0x40>)
 81147c4:	f007 f81c 	bl	811b800 <iprintf>
  }
}
 81147c8:	bf00      	nop
 81147ca:	3708      	adds	r7, #8
 81147cc:	46bd      	mov	sp, r7
 81147ce:	bd80      	pop	{r7, pc}
 81147d0:	0811da14 	.word	0x0811da14
 81147d4:	0811dc28 	.word	0x0811dc28
 81147d8:	0811daa8 	.word	0x0811daa8

081147dc <pbuf_cat>:
 *
 * @see pbuf_chain()
 */
void
pbuf_cat(struct pbuf *h, struct pbuf *t)
{
 81147dc:	b580      	push	{r7, lr}
 81147de:	b084      	sub	sp, #16
 81147e0:	af00      	add	r7, sp, #0
 81147e2:	6078      	str	r0, [r7, #4]
 81147e4:	6039      	str	r1, [r7, #0]
  struct pbuf *p;

  LWIP_ERROR("(h != NULL) && (t != NULL) (programmer violates API)",
 81147e6:	687b      	ldr	r3, [r7, #4]
 81147e8:	2b00      	cmp	r3, #0
 81147ea:	d002      	beq.n	81147f2 <pbuf_cat+0x16>
 81147ec:	683b      	ldr	r3, [r7, #0]
 81147ee:	2b00      	cmp	r3, #0
 81147f0:	d107      	bne.n	8114802 <pbuf_cat+0x26>
 81147f2:	4b20      	ldr	r3, [pc, #128]	; (8114874 <pbuf_cat+0x98>)
 81147f4:	f240 3259 	movw	r2, #857	; 0x359
 81147f8:	491f      	ldr	r1, [pc, #124]	; (8114878 <pbuf_cat+0x9c>)
 81147fa:	4820      	ldr	r0, [pc, #128]	; (811487c <pbuf_cat+0xa0>)
 81147fc:	f007 f800 	bl	811b800 <iprintf>
 8114800:	e034      	b.n	811486c <pbuf_cat+0x90>
             ((h != NULL) && (t != NULL)), return;);

  /* proceed to last pbuf of chain */
  for (p = h; p->next != NULL; p = p->next) {
 8114802:	687b      	ldr	r3, [r7, #4]
 8114804:	60fb      	str	r3, [r7, #12]
 8114806:	e00a      	b.n	811481e <pbuf_cat+0x42>
    /* add total length of second chain to all totals of first chain */
    p->tot_len = (u16_t)(p->tot_len + t->tot_len);
 8114808:	68fb      	ldr	r3, [r7, #12]
 811480a:	891a      	ldrh	r2, [r3, #8]
 811480c:	683b      	ldr	r3, [r7, #0]
 811480e:	891b      	ldrh	r3, [r3, #8]
 8114810:	4413      	add	r3, r2
 8114812:	b29a      	uxth	r2, r3
 8114814:	68fb      	ldr	r3, [r7, #12]
 8114816:	811a      	strh	r2, [r3, #8]
  for (p = h; p->next != NULL; p = p->next) {
 8114818:	68fb      	ldr	r3, [r7, #12]
 811481a:	681b      	ldr	r3, [r3, #0]
 811481c:	60fb      	str	r3, [r7, #12]
 811481e:	68fb      	ldr	r3, [r7, #12]
 8114820:	681b      	ldr	r3, [r3, #0]
 8114822:	2b00      	cmp	r3, #0
 8114824:	d1f0      	bne.n	8114808 <pbuf_cat+0x2c>
  }
  /* { p is last pbuf of first h chain, p->next == NULL } */
  LWIP_ASSERT("p->tot_len == p->len (of last pbuf in chain)", p->tot_len == p->len);
 8114826:	68fb      	ldr	r3, [r7, #12]
 8114828:	891a      	ldrh	r2, [r3, #8]
 811482a:	68fb      	ldr	r3, [r7, #12]
 811482c:	895b      	ldrh	r3, [r3, #10]
 811482e:	429a      	cmp	r2, r3
 8114830:	d006      	beq.n	8114840 <pbuf_cat+0x64>
 8114832:	4b10      	ldr	r3, [pc, #64]	; (8114874 <pbuf_cat+0x98>)
 8114834:	f240 3262 	movw	r2, #866	; 0x362
 8114838:	4911      	ldr	r1, [pc, #68]	; (8114880 <pbuf_cat+0xa4>)
 811483a:	4810      	ldr	r0, [pc, #64]	; (811487c <pbuf_cat+0xa0>)
 811483c:	f006 ffe0 	bl	811b800 <iprintf>
  LWIP_ASSERT("p->next == NULL", p->next == NULL);
 8114840:	68fb      	ldr	r3, [r7, #12]
 8114842:	681b      	ldr	r3, [r3, #0]
 8114844:	2b00      	cmp	r3, #0
 8114846:	d006      	beq.n	8114856 <pbuf_cat+0x7a>
 8114848:	4b0a      	ldr	r3, [pc, #40]	; (8114874 <pbuf_cat+0x98>)
 811484a:	f240 3263 	movw	r2, #867	; 0x363
 811484e:	490d      	ldr	r1, [pc, #52]	; (8114884 <pbuf_cat+0xa8>)
 8114850:	480a      	ldr	r0, [pc, #40]	; (811487c <pbuf_cat+0xa0>)
 8114852:	f006 ffd5 	bl	811b800 <iprintf>
  /* add total length of second chain to last pbuf total of first chain */
  p->tot_len = (u16_t)(p->tot_len + t->tot_len);
 8114856:	68fb      	ldr	r3, [r7, #12]
 8114858:	891a      	ldrh	r2, [r3, #8]
 811485a:	683b      	ldr	r3, [r7, #0]
 811485c:	891b      	ldrh	r3, [r3, #8]
 811485e:	4413      	add	r3, r2
 8114860:	b29a      	uxth	r2, r3
 8114862:	68fb      	ldr	r3, [r7, #12]
 8114864:	811a      	strh	r2, [r3, #8]
  /* chain last pbuf of head (p) with first of tail (t) */
  p->next = t;
 8114866:	68fb      	ldr	r3, [r7, #12]
 8114868:	683a      	ldr	r2, [r7, #0]
 811486a:	601a      	str	r2, [r3, #0]
  /* p->next now references t, but the caller will drop its reference to t,
   * so netto there is no change to the reference count of t.
   */
}
 811486c:	3710      	adds	r7, #16
 811486e:	46bd      	mov	sp, r7
 8114870:	bd80      	pop	{r7, pc}
 8114872:	bf00      	nop
 8114874:	0811da14 	.word	0x0811da14
 8114878:	0811dc3c 	.word	0x0811dc3c
 811487c:	0811daa8 	.word	0x0811daa8
 8114880:	0811dc74 	.word	0x0811dc74
 8114884:	0811dca4 	.word	0x0811dca4

08114888 <pbuf_chain>:
 * The ->ref field of the first pbuf of the tail chain is adjusted.
 *
 */
void
pbuf_chain(struct pbuf *h, struct pbuf *t)
{
 8114888:	b580      	push	{r7, lr}
 811488a:	b082      	sub	sp, #8
 811488c:	af00      	add	r7, sp, #0
 811488e:	6078      	str	r0, [r7, #4]
 8114890:	6039      	str	r1, [r7, #0]
  pbuf_cat(h, t);
 8114892:	6839      	ldr	r1, [r7, #0]
 8114894:	6878      	ldr	r0, [r7, #4]
 8114896:	f7ff ffa1 	bl	81147dc <pbuf_cat>
  /* t is now referenced by h */
  pbuf_ref(t);
 811489a:	6838      	ldr	r0, [r7, #0]
 811489c:	f7ff ff7c 	bl	8114798 <pbuf_ref>
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_chain: %p references %p\n", (void *)h, (void *)t));
}
 81148a0:	bf00      	nop
 81148a2:	3708      	adds	r7, #8
 81148a4:	46bd      	mov	sp, r7
 81148a6:	bd80      	pop	{r7, pc}

081148a8 <pbuf_copy>:
 *         ERR_ARG if one of the pbufs is NULL or p_to is not big
 *                 enough to hold p_from
 */
err_t
pbuf_copy(struct pbuf *p_to, const struct pbuf *p_from)
{
 81148a8:	b580      	push	{r7, lr}
 81148aa:	b086      	sub	sp, #24
 81148ac:	af00      	add	r7, sp, #0
 81148ae:	6078      	str	r0, [r7, #4]
 81148b0:	6039      	str	r1, [r7, #0]
  size_t offset_to = 0, offset_from = 0, len;
 81148b2:	2300      	movs	r3, #0
 81148b4:	617b      	str	r3, [r7, #20]
 81148b6:	2300      	movs	r3, #0
 81148b8:	613b      	str	r3, [r7, #16]

  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_copy(%p, %p)\n",
              (const void *)p_to, (const void *)p_from));

  /* is the target big enough to hold the source? */
  LWIP_ERROR("pbuf_copy: target not big enough to hold source", ((p_to != NULL) &&
 81148ba:	687b      	ldr	r3, [r7, #4]
 81148bc:	2b00      	cmp	r3, #0
 81148be:	d008      	beq.n	81148d2 <pbuf_copy+0x2a>
 81148c0:	683b      	ldr	r3, [r7, #0]
 81148c2:	2b00      	cmp	r3, #0
 81148c4:	d005      	beq.n	81148d2 <pbuf_copy+0x2a>
 81148c6:	687b      	ldr	r3, [r7, #4]
 81148c8:	891a      	ldrh	r2, [r3, #8]
 81148ca:	683b      	ldr	r3, [r7, #0]
 81148cc:	891b      	ldrh	r3, [r3, #8]
 81148ce:	429a      	cmp	r2, r3
 81148d0:	d209      	bcs.n	81148e6 <pbuf_copy+0x3e>
 81148d2:	4b57      	ldr	r3, [pc, #348]	; (8114a30 <pbuf_copy+0x188>)
 81148d4:	f240 32c9 	movw	r2, #969	; 0x3c9
 81148d8:	4956      	ldr	r1, [pc, #344]	; (8114a34 <pbuf_copy+0x18c>)
 81148da:	4857      	ldr	r0, [pc, #348]	; (8114a38 <pbuf_copy+0x190>)
 81148dc:	f006 ff90 	bl	811b800 <iprintf>
 81148e0:	f06f 030f 	mvn.w	r3, #15
 81148e4:	e09f      	b.n	8114a26 <pbuf_copy+0x17e>
             (p_from != NULL) && (p_to->tot_len >= p_from->tot_len)), return ERR_ARG;);

  /* iterate through pbuf chain */
  do {
    /* copy one part of the original chain */
    if ((p_to->len - offset_to) >= (p_from->len - offset_from)) {
 81148e6:	687b      	ldr	r3, [r7, #4]
 81148e8:	895b      	ldrh	r3, [r3, #10]
 81148ea:	461a      	mov	r2, r3
 81148ec:	697b      	ldr	r3, [r7, #20]
 81148ee:	1ad2      	subs	r2, r2, r3
 81148f0:	683b      	ldr	r3, [r7, #0]
 81148f2:	895b      	ldrh	r3, [r3, #10]
 81148f4:	4619      	mov	r1, r3
 81148f6:	693b      	ldr	r3, [r7, #16]
 81148f8:	1acb      	subs	r3, r1, r3
 81148fa:	429a      	cmp	r2, r3
 81148fc:	d306      	bcc.n	811490c <pbuf_copy+0x64>
      /* complete current p_from fits into current p_to */
      len = p_from->len - offset_from;
 81148fe:	683b      	ldr	r3, [r7, #0]
 8114900:	895b      	ldrh	r3, [r3, #10]
 8114902:	461a      	mov	r2, r3
 8114904:	693b      	ldr	r3, [r7, #16]
 8114906:	1ad3      	subs	r3, r2, r3
 8114908:	60fb      	str	r3, [r7, #12]
 811490a:	e005      	b.n	8114918 <pbuf_copy+0x70>
    } else {
      /* current p_from does not fit into current p_to */
      len = p_to->len - offset_to;
 811490c:	687b      	ldr	r3, [r7, #4]
 811490e:	895b      	ldrh	r3, [r3, #10]
 8114910:	461a      	mov	r2, r3
 8114912:	697b      	ldr	r3, [r7, #20]
 8114914:	1ad3      	subs	r3, r2, r3
 8114916:	60fb      	str	r3, [r7, #12]
    }
    MEMCPY((u8_t *)p_to->payload + offset_to, (u8_t *)p_from->payload + offset_from, len);
 8114918:	687b      	ldr	r3, [r7, #4]
 811491a:	685a      	ldr	r2, [r3, #4]
 811491c:	697b      	ldr	r3, [r7, #20]
 811491e:	18d0      	adds	r0, r2, r3
 8114920:	683b      	ldr	r3, [r7, #0]
 8114922:	685a      	ldr	r2, [r3, #4]
 8114924:	693b      	ldr	r3, [r7, #16]
 8114926:	4413      	add	r3, r2
 8114928:	68fa      	ldr	r2, [r7, #12]
 811492a:	4619      	mov	r1, r3
 811492c:	f006 ffc0 	bl	811b8b0 <memcpy>
    offset_to += len;
 8114930:	697a      	ldr	r2, [r7, #20]
 8114932:	68fb      	ldr	r3, [r7, #12]
 8114934:	4413      	add	r3, r2
 8114936:	617b      	str	r3, [r7, #20]
    offset_from += len;
 8114938:	693a      	ldr	r2, [r7, #16]
 811493a:	68fb      	ldr	r3, [r7, #12]
 811493c:	4413      	add	r3, r2
 811493e:	613b      	str	r3, [r7, #16]
    LWIP_ASSERT("offset_to <= p_to->len", offset_to <= p_to->len);
 8114940:	687b      	ldr	r3, [r7, #4]
 8114942:	895b      	ldrh	r3, [r3, #10]
 8114944:	461a      	mov	r2, r3
 8114946:	697b      	ldr	r3, [r7, #20]
 8114948:	4293      	cmp	r3, r2
 811494a:	d906      	bls.n	811495a <pbuf_copy+0xb2>
 811494c:	4b38      	ldr	r3, [pc, #224]	; (8114a30 <pbuf_copy+0x188>)
 811494e:	f240 32d9 	movw	r2, #985	; 0x3d9
 8114952:	493a      	ldr	r1, [pc, #232]	; (8114a3c <pbuf_copy+0x194>)
 8114954:	4838      	ldr	r0, [pc, #224]	; (8114a38 <pbuf_copy+0x190>)
 8114956:	f006 ff53 	bl	811b800 <iprintf>
    LWIP_ASSERT("offset_from <= p_from->len", offset_from <= p_from->len);
 811495a:	683b      	ldr	r3, [r7, #0]
 811495c:	895b      	ldrh	r3, [r3, #10]
 811495e:	461a      	mov	r2, r3
 8114960:	693b      	ldr	r3, [r7, #16]
 8114962:	4293      	cmp	r3, r2
 8114964:	d906      	bls.n	8114974 <pbuf_copy+0xcc>
 8114966:	4b32      	ldr	r3, [pc, #200]	; (8114a30 <pbuf_copy+0x188>)
 8114968:	f240 32da 	movw	r2, #986	; 0x3da
 811496c:	4934      	ldr	r1, [pc, #208]	; (8114a40 <pbuf_copy+0x198>)
 811496e:	4832      	ldr	r0, [pc, #200]	; (8114a38 <pbuf_copy+0x190>)
 8114970:	f006 ff46 	bl	811b800 <iprintf>
    if (offset_from >= p_from->len) {
 8114974:	683b      	ldr	r3, [r7, #0]
 8114976:	895b      	ldrh	r3, [r3, #10]
 8114978:	461a      	mov	r2, r3
 811497a:	693b      	ldr	r3, [r7, #16]
 811497c:	4293      	cmp	r3, r2
 811497e:	d304      	bcc.n	811498a <pbuf_copy+0xe2>
      /* on to next p_from (if any) */
      offset_from = 0;
 8114980:	2300      	movs	r3, #0
 8114982:	613b      	str	r3, [r7, #16]
      p_from = p_from->next;
 8114984:	683b      	ldr	r3, [r7, #0]
 8114986:	681b      	ldr	r3, [r3, #0]
 8114988:	603b      	str	r3, [r7, #0]
    }
    if (offset_to == p_to->len) {
 811498a:	687b      	ldr	r3, [r7, #4]
 811498c:	895b      	ldrh	r3, [r3, #10]
 811498e:	461a      	mov	r2, r3
 8114990:	697b      	ldr	r3, [r7, #20]
 8114992:	4293      	cmp	r3, r2
 8114994:	d114      	bne.n	81149c0 <pbuf_copy+0x118>
      /* on to next p_to (if any) */
      offset_to = 0;
 8114996:	2300      	movs	r3, #0
 8114998:	617b      	str	r3, [r7, #20]
      p_to = p_to->next;
 811499a:	687b      	ldr	r3, [r7, #4]
 811499c:	681b      	ldr	r3, [r3, #0]
 811499e:	607b      	str	r3, [r7, #4]
      LWIP_ERROR("p_to != NULL", (p_to != NULL) || (p_from == NULL), return ERR_ARG;);
 81149a0:	687b      	ldr	r3, [r7, #4]
 81149a2:	2b00      	cmp	r3, #0
 81149a4:	d10c      	bne.n	81149c0 <pbuf_copy+0x118>
 81149a6:	683b      	ldr	r3, [r7, #0]
 81149a8:	2b00      	cmp	r3, #0
 81149aa:	d009      	beq.n	81149c0 <pbuf_copy+0x118>
 81149ac:	4b20      	ldr	r3, [pc, #128]	; (8114a30 <pbuf_copy+0x188>)
 81149ae:	f44f 7279 	mov.w	r2, #996	; 0x3e4
 81149b2:	4924      	ldr	r1, [pc, #144]	; (8114a44 <pbuf_copy+0x19c>)
 81149b4:	4820      	ldr	r0, [pc, #128]	; (8114a38 <pbuf_copy+0x190>)
 81149b6:	f006 ff23 	bl	811b800 <iprintf>
 81149ba:	f06f 030f 	mvn.w	r3, #15
 81149be:	e032      	b.n	8114a26 <pbuf_copy+0x17e>
    }

    if ((p_from != NULL) && (p_from->len == p_from->tot_len)) {
 81149c0:	683b      	ldr	r3, [r7, #0]
 81149c2:	2b00      	cmp	r3, #0
 81149c4:	d013      	beq.n	81149ee <pbuf_copy+0x146>
 81149c6:	683b      	ldr	r3, [r7, #0]
 81149c8:	895a      	ldrh	r2, [r3, #10]
 81149ca:	683b      	ldr	r3, [r7, #0]
 81149cc:	891b      	ldrh	r3, [r3, #8]
 81149ce:	429a      	cmp	r2, r3
 81149d0:	d10d      	bne.n	81149ee <pbuf_copy+0x146>
      /* don't copy more than one packet! */
      LWIP_ERROR("pbuf_copy() does not allow packet queues!",
 81149d2:	683b      	ldr	r3, [r7, #0]
 81149d4:	681b      	ldr	r3, [r3, #0]
 81149d6:	2b00      	cmp	r3, #0
 81149d8:	d009      	beq.n	81149ee <pbuf_copy+0x146>
 81149da:	4b15      	ldr	r3, [pc, #84]	; (8114a30 <pbuf_copy+0x188>)
 81149dc:	f240 32e9 	movw	r2, #1001	; 0x3e9
 81149e0:	4919      	ldr	r1, [pc, #100]	; (8114a48 <pbuf_copy+0x1a0>)
 81149e2:	4815      	ldr	r0, [pc, #84]	; (8114a38 <pbuf_copy+0x190>)
 81149e4:	f006 ff0c 	bl	811b800 <iprintf>
 81149e8:	f06f 0305 	mvn.w	r3, #5
 81149ec:	e01b      	b.n	8114a26 <pbuf_copy+0x17e>
                 (p_from->next == NULL), return ERR_VAL;);
    }
    if ((p_to != NULL) && (p_to->len == p_to->tot_len)) {
 81149ee:	687b      	ldr	r3, [r7, #4]
 81149f0:	2b00      	cmp	r3, #0
 81149f2:	d013      	beq.n	8114a1c <pbuf_copy+0x174>
 81149f4:	687b      	ldr	r3, [r7, #4]
 81149f6:	895a      	ldrh	r2, [r3, #10]
 81149f8:	687b      	ldr	r3, [r7, #4]
 81149fa:	891b      	ldrh	r3, [r3, #8]
 81149fc:	429a      	cmp	r2, r3
 81149fe:	d10d      	bne.n	8114a1c <pbuf_copy+0x174>
      /* don't copy more than one packet! */
      LWIP_ERROR("pbuf_copy() does not allow packet queues!",
 8114a00:	687b      	ldr	r3, [r7, #4]
 8114a02:	681b      	ldr	r3, [r3, #0]
 8114a04:	2b00      	cmp	r3, #0
 8114a06:	d009      	beq.n	8114a1c <pbuf_copy+0x174>
 8114a08:	4b09      	ldr	r3, [pc, #36]	; (8114a30 <pbuf_copy+0x188>)
 8114a0a:	f240 32ee 	movw	r2, #1006	; 0x3ee
 8114a0e:	490e      	ldr	r1, [pc, #56]	; (8114a48 <pbuf_copy+0x1a0>)
 8114a10:	4809      	ldr	r0, [pc, #36]	; (8114a38 <pbuf_copy+0x190>)
 8114a12:	f006 fef5 	bl	811b800 <iprintf>
 8114a16:	f06f 0305 	mvn.w	r3, #5
 8114a1a:	e004      	b.n	8114a26 <pbuf_copy+0x17e>
                 (p_to->next == NULL), return ERR_VAL;);
    }
  } while (p_from);
 8114a1c:	683b      	ldr	r3, [r7, #0]
 8114a1e:	2b00      	cmp	r3, #0
 8114a20:	f47f af61 	bne.w	81148e6 <pbuf_copy+0x3e>
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_copy: end of chain reached.\n"));
  return ERR_OK;
 8114a24:	2300      	movs	r3, #0
}
 8114a26:	4618      	mov	r0, r3
 8114a28:	3718      	adds	r7, #24
 8114a2a:	46bd      	mov	sp, r7
 8114a2c:	bd80      	pop	{r7, pc}
 8114a2e:	bf00      	nop
 8114a30:	0811da14 	.word	0x0811da14
 8114a34:	0811dcf0 	.word	0x0811dcf0
 8114a38:	0811daa8 	.word	0x0811daa8
 8114a3c:	0811dd20 	.word	0x0811dd20
 8114a40:	0811dd38 	.word	0x0811dd38
 8114a44:	0811dd54 	.word	0x0811dd54
 8114a48:	0811dd64 	.word	0x0811dd64

08114a4c <pbuf_copy_partial>:
 * @param offset offset into the packet buffer from where to begin copying len bytes
 * @return the number of bytes copied, or 0 on failure
 */
u16_t
pbuf_copy_partial(const struct pbuf *buf, void *dataptr, u16_t len, u16_t offset)
{
 8114a4c:	b580      	push	{r7, lr}
 8114a4e:	b088      	sub	sp, #32
 8114a50:	af00      	add	r7, sp, #0
 8114a52:	60f8      	str	r0, [r7, #12]
 8114a54:	60b9      	str	r1, [r7, #8]
 8114a56:	4611      	mov	r1, r2
 8114a58:	461a      	mov	r2, r3
 8114a5a:	460b      	mov	r3, r1
 8114a5c:	80fb      	strh	r3, [r7, #6]
 8114a5e:	4613      	mov	r3, r2
 8114a60:	80bb      	strh	r3, [r7, #4]
  const struct pbuf *p;
  u16_t left = 0;
 8114a62:	2300      	movs	r3, #0
 8114a64:	837b      	strh	r3, [r7, #26]
  u16_t buf_copy_len;
  u16_t copied_total = 0;
 8114a66:	2300      	movs	r3, #0
 8114a68:	82fb      	strh	r3, [r7, #22]

  LWIP_ERROR("pbuf_copy_partial: invalid buf", (buf != NULL), return 0;);
 8114a6a:	68fb      	ldr	r3, [r7, #12]
 8114a6c:	2b00      	cmp	r3, #0
 8114a6e:	d108      	bne.n	8114a82 <pbuf_copy_partial+0x36>
 8114a70:	4b2b      	ldr	r3, [pc, #172]	; (8114b20 <pbuf_copy_partial+0xd4>)
 8114a72:	f240 420a 	movw	r2, #1034	; 0x40a
 8114a76:	492b      	ldr	r1, [pc, #172]	; (8114b24 <pbuf_copy_partial+0xd8>)
 8114a78:	482b      	ldr	r0, [pc, #172]	; (8114b28 <pbuf_copy_partial+0xdc>)
 8114a7a:	f006 fec1 	bl	811b800 <iprintf>
 8114a7e:	2300      	movs	r3, #0
 8114a80:	e04a      	b.n	8114b18 <pbuf_copy_partial+0xcc>
  LWIP_ERROR("pbuf_copy_partial: invalid dataptr", (dataptr != NULL), return 0;);
 8114a82:	68bb      	ldr	r3, [r7, #8]
 8114a84:	2b00      	cmp	r3, #0
 8114a86:	d108      	bne.n	8114a9a <pbuf_copy_partial+0x4e>
 8114a88:	4b25      	ldr	r3, [pc, #148]	; (8114b20 <pbuf_copy_partial+0xd4>)
 8114a8a:	f240 420b 	movw	r2, #1035	; 0x40b
 8114a8e:	4927      	ldr	r1, [pc, #156]	; (8114b2c <pbuf_copy_partial+0xe0>)
 8114a90:	4825      	ldr	r0, [pc, #148]	; (8114b28 <pbuf_copy_partial+0xdc>)
 8114a92:	f006 feb5 	bl	811b800 <iprintf>
 8114a96:	2300      	movs	r3, #0
 8114a98:	e03e      	b.n	8114b18 <pbuf_copy_partial+0xcc>

  /* Note some systems use byte copy if dataptr or one of the pbuf payload pointers are unaligned. */
  for (p = buf; len != 0 && p != NULL; p = p->next) {
 8114a9a:	68fb      	ldr	r3, [r7, #12]
 8114a9c:	61fb      	str	r3, [r7, #28]
 8114a9e:	e034      	b.n	8114b0a <pbuf_copy_partial+0xbe>
    if ((offset != 0) && (offset >= p->len)) {
 8114aa0:	88bb      	ldrh	r3, [r7, #4]
 8114aa2:	2b00      	cmp	r3, #0
 8114aa4:	d00a      	beq.n	8114abc <pbuf_copy_partial+0x70>
 8114aa6:	69fb      	ldr	r3, [r7, #28]
 8114aa8:	895b      	ldrh	r3, [r3, #10]
 8114aaa:	88ba      	ldrh	r2, [r7, #4]
 8114aac:	429a      	cmp	r2, r3
 8114aae:	d305      	bcc.n	8114abc <pbuf_copy_partial+0x70>
      /* don't copy from this buffer -> on to the next */
      offset = (u16_t)(offset - p->len);
 8114ab0:	69fb      	ldr	r3, [r7, #28]
 8114ab2:	895b      	ldrh	r3, [r3, #10]
 8114ab4:	88ba      	ldrh	r2, [r7, #4]
 8114ab6:	1ad3      	subs	r3, r2, r3
 8114ab8:	80bb      	strh	r3, [r7, #4]
 8114aba:	e023      	b.n	8114b04 <pbuf_copy_partial+0xb8>
    } else {
      /* copy from this buffer. maybe only partially. */
      buf_copy_len = (u16_t)(p->len - offset);
 8114abc:	69fb      	ldr	r3, [r7, #28]
 8114abe:	895a      	ldrh	r2, [r3, #10]
 8114ac0:	88bb      	ldrh	r3, [r7, #4]
 8114ac2:	1ad3      	subs	r3, r2, r3
 8114ac4:	833b      	strh	r3, [r7, #24]
      if (buf_copy_len > len) {
 8114ac6:	8b3a      	ldrh	r2, [r7, #24]
 8114ac8:	88fb      	ldrh	r3, [r7, #6]
 8114aca:	429a      	cmp	r2, r3
 8114acc:	d901      	bls.n	8114ad2 <pbuf_copy_partial+0x86>
        buf_copy_len = len;
 8114ace:	88fb      	ldrh	r3, [r7, #6]
 8114ad0:	833b      	strh	r3, [r7, #24]
      }
      /* copy the necessary parts of the buffer */
      MEMCPY(&((char *)dataptr)[left], &((char *)p->payload)[offset], buf_copy_len);
 8114ad2:	8b7b      	ldrh	r3, [r7, #26]
 8114ad4:	68ba      	ldr	r2, [r7, #8]
 8114ad6:	18d0      	adds	r0, r2, r3
 8114ad8:	69fb      	ldr	r3, [r7, #28]
 8114ada:	685a      	ldr	r2, [r3, #4]
 8114adc:	88bb      	ldrh	r3, [r7, #4]
 8114ade:	4413      	add	r3, r2
 8114ae0:	8b3a      	ldrh	r2, [r7, #24]
 8114ae2:	4619      	mov	r1, r3
 8114ae4:	f006 fee4 	bl	811b8b0 <memcpy>
      copied_total = (u16_t)(copied_total + buf_copy_len);
 8114ae8:	8afa      	ldrh	r2, [r7, #22]
 8114aea:	8b3b      	ldrh	r3, [r7, #24]
 8114aec:	4413      	add	r3, r2
 8114aee:	82fb      	strh	r3, [r7, #22]
      left = (u16_t)(left + buf_copy_len);
 8114af0:	8b7a      	ldrh	r2, [r7, #26]
 8114af2:	8b3b      	ldrh	r3, [r7, #24]
 8114af4:	4413      	add	r3, r2
 8114af6:	837b      	strh	r3, [r7, #26]
      len = (u16_t)(len - buf_copy_len);
 8114af8:	88fa      	ldrh	r2, [r7, #6]
 8114afa:	8b3b      	ldrh	r3, [r7, #24]
 8114afc:	1ad3      	subs	r3, r2, r3
 8114afe:	80fb      	strh	r3, [r7, #6]
      offset = 0;
 8114b00:	2300      	movs	r3, #0
 8114b02:	80bb      	strh	r3, [r7, #4]
  for (p = buf; len != 0 && p != NULL; p = p->next) {
 8114b04:	69fb      	ldr	r3, [r7, #28]
 8114b06:	681b      	ldr	r3, [r3, #0]
 8114b08:	61fb      	str	r3, [r7, #28]
 8114b0a:	88fb      	ldrh	r3, [r7, #6]
 8114b0c:	2b00      	cmp	r3, #0
 8114b0e:	d002      	beq.n	8114b16 <pbuf_copy_partial+0xca>
 8114b10:	69fb      	ldr	r3, [r7, #28]
 8114b12:	2b00      	cmp	r3, #0
 8114b14:	d1c4      	bne.n	8114aa0 <pbuf_copy_partial+0x54>
    }
  }
  return copied_total;
 8114b16:	8afb      	ldrh	r3, [r7, #22]
}
 8114b18:	4618      	mov	r0, r3
 8114b1a:	3720      	adds	r7, #32
 8114b1c:	46bd      	mov	sp, r7
 8114b1e:	bd80      	pop	{r7, pc}
 8114b20:	0811da14 	.word	0x0811da14
 8114b24:	0811dd90 	.word	0x0811dd90
 8114b28:	0811daa8 	.word	0x0811daa8
 8114b2c:	0811ddb0 	.word	0x0811ddb0

08114b30 <pbuf_skip_const>:
#endif /* LWIP_TCP && TCP_QUEUE_OOSEQ && LWIP_WND_SCALE */

/* Actual implementation of pbuf_skip() but returning const pointer... */
static const struct pbuf *
pbuf_skip_const(const struct pbuf *in, u16_t in_offset, u16_t *out_offset)
{
 8114b30:	b480      	push	{r7}
 8114b32:	b087      	sub	sp, #28
 8114b34:	af00      	add	r7, sp, #0
 8114b36:	60f8      	str	r0, [r7, #12]
 8114b38:	460b      	mov	r3, r1
 8114b3a:	607a      	str	r2, [r7, #4]
 8114b3c:	817b      	strh	r3, [r7, #10]
  u16_t offset_left = in_offset;
 8114b3e:	897b      	ldrh	r3, [r7, #10]
 8114b40:	82fb      	strh	r3, [r7, #22]
  const struct pbuf *q = in;
 8114b42:	68fb      	ldr	r3, [r7, #12]
 8114b44:	613b      	str	r3, [r7, #16]

  /* get the correct pbuf */
  while ((q != NULL) && (q->len <= offset_left)) {
 8114b46:	e007      	b.n	8114b58 <pbuf_skip_const+0x28>
    offset_left = (u16_t)(offset_left - q->len);
 8114b48:	693b      	ldr	r3, [r7, #16]
 8114b4a:	895b      	ldrh	r3, [r3, #10]
 8114b4c:	8afa      	ldrh	r2, [r7, #22]
 8114b4e:	1ad3      	subs	r3, r2, r3
 8114b50:	82fb      	strh	r3, [r7, #22]
    q = q->next;
 8114b52:	693b      	ldr	r3, [r7, #16]
 8114b54:	681b      	ldr	r3, [r3, #0]
 8114b56:	613b      	str	r3, [r7, #16]
  while ((q != NULL) && (q->len <= offset_left)) {
 8114b58:	693b      	ldr	r3, [r7, #16]
 8114b5a:	2b00      	cmp	r3, #0
 8114b5c:	d004      	beq.n	8114b68 <pbuf_skip_const+0x38>
 8114b5e:	693b      	ldr	r3, [r7, #16]
 8114b60:	895b      	ldrh	r3, [r3, #10]
 8114b62:	8afa      	ldrh	r2, [r7, #22]
 8114b64:	429a      	cmp	r2, r3
 8114b66:	d2ef      	bcs.n	8114b48 <pbuf_skip_const+0x18>
  }
  if (out_offset != NULL) {
 8114b68:	687b      	ldr	r3, [r7, #4]
 8114b6a:	2b00      	cmp	r3, #0
 8114b6c:	d002      	beq.n	8114b74 <pbuf_skip_const+0x44>
    *out_offset = offset_left;
 8114b6e:	687b      	ldr	r3, [r7, #4]
 8114b70:	8afa      	ldrh	r2, [r7, #22]
 8114b72:	801a      	strh	r2, [r3, #0]
  }
  return q;
 8114b74:	693b      	ldr	r3, [r7, #16]
}
 8114b76:	4618      	mov	r0, r3
 8114b78:	371c      	adds	r7, #28
 8114b7a:	46bd      	mov	sp, r7
 8114b7c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8114b80:	4770      	bx	lr

08114b82 <pbuf_skip>:
 * @param out_offset resulting offset in the returned pbuf
 * @return the pbuf in the queue where the offset is
 */
struct pbuf *
pbuf_skip(struct pbuf *in, u16_t in_offset, u16_t *out_offset)
{
 8114b82:	b580      	push	{r7, lr}
 8114b84:	b086      	sub	sp, #24
 8114b86:	af00      	add	r7, sp, #0
 8114b88:	60f8      	str	r0, [r7, #12]
 8114b8a:	460b      	mov	r3, r1
 8114b8c:	607a      	str	r2, [r7, #4]
 8114b8e:	817b      	strh	r3, [r7, #10]
  const struct pbuf *out = pbuf_skip_const(in, in_offset, out_offset);
 8114b90:	897b      	ldrh	r3, [r7, #10]
 8114b92:	687a      	ldr	r2, [r7, #4]
 8114b94:	4619      	mov	r1, r3
 8114b96:	68f8      	ldr	r0, [r7, #12]
 8114b98:	f7ff ffca 	bl	8114b30 <pbuf_skip_const>
 8114b9c:	6178      	str	r0, [r7, #20]
  return LWIP_CONST_CAST(struct pbuf *, out);
 8114b9e:	697b      	ldr	r3, [r7, #20]
}
 8114ba0:	4618      	mov	r0, r3
 8114ba2:	3718      	adds	r7, #24
 8114ba4:	46bd      	mov	sp, r7
 8114ba6:	bd80      	pop	{r7, pc}

08114ba8 <pbuf_take>:
 *
 * @return ERR_OK if successful, ERR_MEM if the pbuf is not big enough
 */
err_t
pbuf_take(struct pbuf *buf, const void *dataptr, u16_t len)
{
 8114ba8:	b580      	push	{r7, lr}
 8114baa:	b088      	sub	sp, #32
 8114bac:	af00      	add	r7, sp, #0
 8114bae:	60f8      	str	r0, [r7, #12]
 8114bb0:	60b9      	str	r1, [r7, #8]
 8114bb2:	4613      	mov	r3, r2
 8114bb4:	80fb      	strh	r3, [r7, #6]
  struct pbuf *p;
  size_t buf_copy_len;
  size_t total_copy_len = len;
 8114bb6:	88fb      	ldrh	r3, [r7, #6]
 8114bb8:	617b      	str	r3, [r7, #20]
  size_t copied_total = 0;
 8114bba:	2300      	movs	r3, #0
 8114bbc:	613b      	str	r3, [r7, #16]

  LWIP_ERROR("pbuf_take: invalid buf", (buf != NULL), return ERR_ARG;);
 8114bbe:	68fb      	ldr	r3, [r7, #12]
 8114bc0:	2b00      	cmp	r3, #0
 8114bc2:	d109      	bne.n	8114bd8 <pbuf_take+0x30>
 8114bc4:	4b3a      	ldr	r3, [pc, #232]	; (8114cb0 <pbuf_take+0x108>)
 8114bc6:	f240 42b3 	movw	r2, #1203	; 0x4b3
 8114bca:	493a      	ldr	r1, [pc, #232]	; (8114cb4 <pbuf_take+0x10c>)
 8114bcc:	483a      	ldr	r0, [pc, #232]	; (8114cb8 <pbuf_take+0x110>)
 8114bce:	f006 fe17 	bl	811b800 <iprintf>
 8114bd2:	f06f 030f 	mvn.w	r3, #15
 8114bd6:	e067      	b.n	8114ca8 <pbuf_take+0x100>
  LWIP_ERROR("pbuf_take: invalid dataptr", (dataptr != NULL), return ERR_ARG;);
 8114bd8:	68bb      	ldr	r3, [r7, #8]
 8114bda:	2b00      	cmp	r3, #0
 8114bdc:	d109      	bne.n	8114bf2 <pbuf_take+0x4a>
 8114bde:	4b34      	ldr	r3, [pc, #208]	; (8114cb0 <pbuf_take+0x108>)
 8114be0:	f240 42b4 	movw	r2, #1204	; 0x4b4
 8114be4:	4935      	ldr	r1, [pc, #212]	; (8114cbc <pbuf_take+0x114>)
 8114be6:	4834      	ldr	r0, [pc, #208]	; (8114cb8 <pbuf_take+0x110>)
 8114be8:	f006 fe0a 	bl	811b800 <iprintf>
 8114bec:	f06f 030f 	mvn.w	r3, #15
 8114bf0:	e05a      	b.n	8114ca8 <pbuf_take+0x100>
  LWIP_ERROR("pbuf_take: buf not large enough", (buf->tot_len >= len), return ERR_MEM;);
 8114bf2:	68fb      	ldr	r3, [r7, #12]
 8114bf4:	891b      	ldrh	r3, [r3, #8]
 8114bf6:	88fa      	ldrh	r2, [r7, #6]
 8114bf8:	429a      	cmp	r2, r3
 8114bfa:	d909      	bls.n	8114c10 <pbuf_take+0x68>
 8114bfc:	4b2c      	ldr	r3, [pc, #176]	; (8114cb0 <pbuf_take+0x108>)
 8114bfe:	f240 42b5 	movw	r2, #1205	; 0x4b5
 8114c02:	492f      	ldr	r1, [pc, #188]	; (8114cc0 <pbuf_take+0x118>)
 8114c04:	482c      	ldr	r0, [pc, #176]	; (8114cb8 <pbuf_take+0x110>)
 8114c06:	f006 fdfb 	bl	811b800 <iprintf>
 8114c0a:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 8114c0e:	e04b      	b.n	8114ca8 <pbuf_take+0x100>

  if ((buf == NULL) || (dataptr == NULL) || (buf->tot_len < len)) {
 8114c10:	68fb      	ldr	r3, [r7, #12]
 8114c12:	2b00      	cmp	r3, #0
 8114c14:	d007      	beq.n	8114c26 <pbuf_take+0x7e>
 8114c16:	68bb      	ldr	r3, [r7, #8]
 8114c18:	2b00      	cmp	r3, #0
 8114c1a:	d004      	beq.n	8114c26 <pbuf_take+0x7e>
 8114c1c:	68fb      	ldr	r3, [r7, #12]
 8114c1e:	891b      	ldrh	r3, [r3, #8]
 8114c20:	88fa      	ldrh	r2, [r7, #6]
 8114c22:	429a      	cmp	r2, r3
 8114c24:	d902      	bls.n	8114c2c <pbuf_take+0x84>
    return ERR_ARG;
 8114c26:	f06f 030f 	mvn.w	r3, #15
 8114c2a:	e03d      	b.n	8114ca8 <pbuf_take+0x100>
  }

  /* Note some systems use byte copy if dataptr or one of the pbuf payload pointers are unaligned. */
  for (p = buf; total_copy_len != 0; p = p->next) {
 8114c2c:	68fb      	ldr	r3, [r7, #12]
 8114c2e:	61fb      	str	r3, [r7, #28]
 8114c30:	e028      	b.n	8114c84 <pbuf_take+0xdc>
    LWIP_ASSERT("pbuf_take: invalid pbuf", p != NULL);
 8114c32:	69fb      	ldr	r3, [r7, #28]
 8114c34:	2b00      	cmp	r3, #0
 8114c36:	d106      	bne.n	8114c46 <pbuf_take+0x9e>
 8114c38:	4b1d      	ldr	r3, [pc, #116]	; (8114cb0 <pbuf_take+0x108>)
 8114c3a:	f240 42bd 	movw	r2, #1213	; 0x4bd
 8114c3e:	4921      	ldr	r1, [pc, #132]	; (8114cc4 <pbuf_take+0x11c>)
 8114c40:	481d      	ldr	r0, [pc, #116]	; (8114cb8 <pbuf_take+0x110>)
 8114c42:	f006 fddd 	bl	811b800 <iprintf>
    buf_copy_len = total_copy_len;
 8114c46:	697b      	ldr	r3, [r7, #20]
 8114c48:	61bb      	str	r3, [r7, #24]
    if (buf_copy_len > p->len) {
 8114c4a:	69fb      	ldr	r3, [r7, #28]
 8114c4c:	895b      	ldrh	r3, [r3, #10]
 8114c4e:	461a      	mov	r2, r3
 8114c50:	69bb      	ldr	r3, [r7, #24]
 8114c52:	4293      	cmp	r3, r2
 8114c54:	d902      	bls.n	8114c5c <pbuf_take+0xb4>
      /* this pbuf cannot hold all remaining data */
      buf_copy_len = p->len;
 8114c56:	69fb      	ldr	r3, [r7, #28]
 8114c58:	895b      	ldrh	r3, [r3, #10]
 8114c5a:	61bb      	str	r3, [r7, #24]
    }
    /* copy the necessary parts of the buffer */
    MEMCPY(p->payload, &((const char *)dataptr)[copied_total], buf_copy_len);
 8114c5c:	69fb      	ldr	r3, [r7, #28]
 8114c5e:	6858      	ldr	r0, [r3, #4]
 8114c60:	68ba      	ldr	r2, [r7, #8]
 8114c62:	693b      	ldr	r3, [r7, #16]
 8114c64:	4413      	add	r3, r2
 8114c66:	69ba      	ldr	r2, [r7, #24]
 8114c68:	4619      	mov	r1, r3
 8114c6a:	f006 fe21 	bl	811b8b0 <memcpy>
    total_copy_len -= buf_copy_len;
 8114c6e:	697a      	ldr	r2, [r7, #20]
 8114c70:	69bb      	ldr	r3, [r7, #24]
 8114c72:	1ad3      	subs	r3, r2, r3
 8114c74:	617b      	str	r3, [r7, #20]
    copied_total += buf_copy_len;
 8114c76:	693a      	ldr	r2, [r7, #16]
 8114c78:	69bb      	ldr	r3, [r7, #24]
 8114c7a:	4413      	add	r3, r2
 8114c7c:	613b      	str	r3, [r7, #16]
  for (p = buf; total_copy_len != 0; p = p->next) {
 8114c7e:	69fb      	ldr	r3, [r7, #28]
 8114c80:	681b      	ldr	r3, [r3, #0]
 8114c82:	61fb      	str	r3, [r7, #28]
 8114c84:	697b      	ldr	r3, [r7, #20]
 8114c86:	2b00      	cmp	r3, #0
 8114c88:	d1d3      	bne.n	8114c32 <pbuf_take+0x8a>
  }
  LWIP_ASSERT("did not copy all data", total_copy_len == 0 && copied_total == len);
 8114c8a:	697b      	ldr	r3, [r7, #20]
 8114c8c:	2b00      	cmp	r3, #0
 8114c8e:	d103      	bne.n	8114c98 <pbuf_take+0xf0>
 8114c90:	88fb      	ldrh	r3, [r7, #6]
 8114c92:	693a      	ldr	r2, [r7, #16]
 8114c94:	429a      	cmp	r2, r3
 8114c96:	d006      	beq.n	8114ca6 <pbuf_take+0xfe>
 8114c98:	4b05      	ldr	r3, [pc, #20]	; (8114cb0 <pbuf_take+0x108>)
 8114c9a:	f44f 6299 	mov.w	r2, #1224	; 0x4c8
 8114c9e:	490a      	ldr	r1, [pc, #40]	; (8114cc8 <pbuf_take+0x120>)
 8114ca0:	4805      	ldr	r0, [pc, #20]	; (8114cb8 <pbuf_take+0x110>)
 8114ca2:	f006 fdad 	bl	811b800 <iprintf>
  return ERR_OK;
 8114ca6:	2300      	movs	r3, #0
}
 8114ca8:	4618      	mov	r0, r3
 8114caa:	3720      	adds	r7, #32
 8114cac:	46bd      	mov	sp, r7
 8114cae:	bd80      	pop	{r7, pc}
 8114cb0:	0811da14 	.word	0x0811da14
 8114cb4:	0811de20 	.word	0x0811de20
 8114cb8:	0811daa8 	.word	0x0811daa8
 8114cbc:	0811de38 	.word	0x0811de38
 8114cc0:	0811de54 	.word	0x0811de54
 8114cc4:	0811de74 	.word	0x0811de74
 8114cc8:	0811de8c 	.word	0x0811de8c

08114ccc <pbuf_take_at>:
 *
 * @return ERR_OK if successful, ERR_MEM if the pbuf is not big enough
 */
err_t
pbuf_take_at(struct pbuf *buf, const void *dataptr, u16_t len, u16_t offset)
{
 8114ccc:	b580      	push	{r7, lr}
 8114cce:	b088      	sub	sp, #32
 8114cd0:	af00      	add	r7, sp, #0
 8114cd2:	60f8      	str	r0, [r7, #12]
 8114cd4:	60b9      	str	r1, [r7, #8]
 8114cd6:	4611      	mov	r1, r2
 8114cd8:	461a      	mov	r2, r3
 8114cda:	460b      	mov	r3, r1
 8114cdc:	80fb      	strh	r3, [r7, #6]
 8114cde:	4613      	mov	r3, r2
 8114ce0:	80bb      	strh	r3, [r7, #4]
  u16_t target_offset;
  struct pbuf *q = pbuf_skip(buf, offset, &target_offset);
 8114ce2:	f107 0210 	add.w	r2, r7, #16
 8114ce6:	88bb      	ldrh	r3, [r7, #4]
 8114ce8:	4619      	mov	r1, r3
 8114cea:	68f8      	ldr	r0, [r7, #12]
 8114cec:	f7ff ff49 	bl	8114b82 <pbuf_skip>
 8114cf0:	61f8      	str	r0, [r7, #28]

  /* return requested data if pbuf is OK */
  if ((q != NULL) && (q->tot_len >= target_offset + len)) {
 8114cf2:	69fb      	ldr	r3, [r7, #28]
 8114cf4:	2b00      	cmp	r3, #0
 8114cf6:	d047      	beq.n	8114d88 <pbuf_take_at+0xbc>
 8114cf8:	69fb      	ldr	r3, [r7, #28]
 8114cfa:	891b      	ldrh	r3, [r3, #8]
 8114cfc:	461a      	mov	r2, r3
 8114cfe:	8a3b      	ldrh	r3, [r7, #16]
 8114d00:	4619      	mov	r1, r3
 8114d02:	88fb      	ldrh	r3, [r7, #6]
 8114d04:	440b      	add	r3, r1
 8114d06:	429a      	cmp	r2, r3
 8114d08:	db3e      	blt.n	8114d88 <pbuf_take_at+0xbc>
    u16_t remaining_len = len;
 8114d0a:	88fb      	ldrh	r3, [r7, #6]
 8114d0c:	837b      	strh	r3, [r7, #26]
    const u8_t *src_ptr = (const u8_t *)dataptr;
 8114d0e:	68bb      	ldr	r3, [r7, #8]
 8114d10:	617b      	str	r3, [r7, #20]
    /* copy the part that goes into the first pbuf */
    u16_t first_copy_len;
    LWIP_ASSERT("check pbuf_skip result", target_offset < q->len);
 8114d12:	69fb      	ldr	r3, [r7, #28]
 8114d14:	895a      	ldrh	r2, [r3, #10]
 8114d16:	8a3b      	ldrh	r3, [r7, #16]
 8114d18:	429a      	cmp	r2, r3
 8114d1a:	d806      	bhi.n	8114d2a <pbuf_take_at+0x5e>
 8114d1c:	4b1d      	ldr	r3, [pc, #116]	; (8114d94 <pbuf_take_at+0xc8>)
 8114d1e:	f240 42e3 	movw	r2, #1251	; 0x4e3
 8114d22:	491d      	ldr	r1, [pc, #116]	; (8114d98 <pbuf_take_at+0xcc>)
 8114d24:	481d      	ldr	r0, [pc, #116]	; (8114d9c <pbuf_take_at+0xd0>)
 8114d26:	f006 fd6b 	bl	811b800 <iprintf>
    first_copy_len = (u16_t)LWIP_MIN(q->len - target_offset, len);
 8114d2a:	69fb      	ldr	r3, [r7, #28]
 8114d2c:	895b      	ldrh	r3, [r3, #10]
 8114d2e:	461a      	mov	r2, r3
 8114d30:	8a3b      	ldrh	r3, [r7, #16]
 8114d32:	1ad2      	subs	r2, r2, r3
 8114d34:	88fb      	ldrh	r3, [r7, #6]
 8114d36:	429a      	cmp	r2, r3
 8114d38:	da05      	bge.n	8114d46 <pbuf_take_at+0x7a>
 8114d3a:	69fb      	ldr	r3, [r7, #28]
 8114d3c:	895a      	ldrh	r2, [r3, #10]
 8114d3e:	8a3b      	ldrh	r3, [r7, #16]
 8114d40:	1ad3      	subs	r3, r2, r3
 8114d42:	b29b      	uxth	r3, r3
 8114d44:	e000      	b.n	8114d48 <pbuf_take_at+0x7c>
 8114d46:	88fb      	ldrh	r3, [r7, #6]
 8114d48:	827b      	strh	r3, [r7, #18]
    MEMCPY(((u8_t *)q->payload) + target_offset, dataptr, first_copy_len);
 8114d4a:	69fb      	ldr	r3, [r7, #28]
 8114d4c:	685b      	ldr	r3, [r3, #4]
 8114d4e:	8a3a      	ldrh	r2, [r7, #16]
 8114d50:	4413      	add	r3, r2
 8114d52:	8a7a      	ldrh	r2, [r7, #18]
 8114d54:	68b9      	ldr	r1, [r7, #8]
 8114d56:	4618      	mov	r0, r3
 8114d58:	f006 fdaa 	bl	811b8b0 <memcpy>
    remaining_len = (u16_t)(remaining_len - first_copy_len);
 8114d5c:	8b7a      	ldrh	r2, [r7, #26]
 8114d5e:	8a7b      	ldrh	r3, [r7, #18]
 8114d60:	1ad3      	subs	r3, r2, r3
 8114d62:	837b      	strh	r3, [r7, #26]
    src_ptr += first_copy_len;
 8114d64:	8a7b      	ldrh	r3, [r7, #18]
 8114d66:	697a      	ldr	r2, [r7, #20]
 8114d68:	4413      	add	r3, r2
 8114d6a:	617b      	str	r3, [r7, #20]
    if (remaining_len > 0) {
 8114d6c:	8b7b      	ldrh	r3, [r7, #26]
 8114d6e:	2b00      	cmp	r3, #0
 8114d70:	d008      	beq.n	8114d84 <pbuf_take_at+0xb8>
      return pbuf_take(q->next, src_ptr, remaining_len);
 8114d72:	69fb      	ldr	r3, [r7, #28]
 8114d74:	681b      	ldr	r3, [r3, #0]
 8114d76:	8b7a      	ldrh	r2, [r7, #26]
 8114d78:	6979      	ldr	r1, [r7, #20]
 8114d7a:	4618      	mov	r0, r3
 8114d7c:	f7ff ff14 	bl	8114ba8 <pbuf_take>
 8114d80:	4603      	mov	r3, r0
 8114d82:	e003      	b.n	8114d8c <pbuf_take_at+0xc0>
    }
    return ERR_OK;
 8114d84:	2300      	movs	r3, #0
 8114d86:	e001      	b.n	8114d8c <pbuf_take_at+0xc0>
  }
  return ERR_MEM;
 8114d88:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
}
 8114d8c:	4618      	mov	r0, r3
 8114d8e:	3720      	adds	r7, #32
 8114d90:	46bd      	mov	sp, r7
 8114d92:	bd80      	pop	{r7, pc}
 8114d94:	0811da14 	.word	0x0811da14
 8114d98:	0811dea4 	.word	0x0811dea4
 8114d9c:	0811daa8 	.word	0x0811daa8

08114da0 <pbuf_clone>:
 *
 * @return a new pbuf or NULL if allocation fails
 */
struct pbuf *
pbuf_clone(pbuf_layer layer, pbuf_type type, struct pbuf *p)
{
 8114da0:	b580      	push	{r7, lr}
 8114da2:	b084      	sub	sp, #16
 8114da4:	af00      	add	r7, sp, #0
 8114da6:	4603      	mov	r3, r0
 8114da8:	603a      	str	r2, [r7, #0]
 8114daa:	71fb      	strb	r3, [r7, #7]
 8114dac:	460b      	mov	r3, r1
 8114dae:	80bb      	strh	r3, [r7, #4]
  struct pbuf *q;
  err_t err;
  q = pbuf_alloc(layer, p->tot_len, type);
 8114db0:	683b      	ldr	r3, [r7, #0]
 8114db2:	8919      	ldrh	r1, [r3, #8]
 8114db4:	88ba      	ldrh	r2, [r7, #4]
 8114db6:	79fb      	ldrb	r3, [r7, #7]
 8114db8:	4618      	mov	r0, r3
 8114dba:	f7ff f969 	bl	8114090 <pbuf_alloc>
 8114dbe:	60f8      	str	r0, [r7, #12]
  if (q == NULL) {
 8114dc0:	68fb      	ldr	r3, [r7, #12]
 8114dc2:	2b00      	cmp	r3, #0
 8114dc4:	d101      	bne.n	8114dca <pbuf_clone+0x2a>
    return NULL;
 8114dc6:	2300      	movs	r3, #0
 8114dc8:	e011      	b.n	8114dee <pbuf_clone+0x4e>
  }
  err = pbuf_copy(q, p);
 8114dca:	6839      	ldr	r1, [r7, #0]
 8114dcc:	68f8      	ldr	r0, [r7, #12]
 8114dce:	f7ff fd6b 	bl	81148a8 <pbuf_copy>
 8114dd2:	4603      	mov	r3, r0
 8114dd4:	72fb      	strb	r3, [r7, #11]
  LWIP_UNUSED_ARG(err); /* in case of LWIP_NOASSERT */
  LWIP_ASSERT("pbuf_copy failed", err == ERR_OK);
 8114dd6:	f997 300b 	ldrsb.w	r3, [r7, #11]
 8114dda:	2b00      	cmp	r3, #0
 8114ddc:	d006      	beq.n	8114dec <pbuf_clone+0x4c>
 8114dde:	4b06      	ldr	r3, [pc, #24]	; (8114df8 <pbuf_clone+0x58>)
 8114de0:	f240 5224 	movw	r2, #1316	; 0x524
 8114de4:	4905      	ldr	r1, [pc, #20]	; (8114dfc <pbuf_clone+0x5c>)
 8114de6:	4806      	ldr	r0, [pc, #24]	; (8114e00 <pbuf_clone+0x60>)
 8114de8:	f006 fd0a 	bl	811b800 <iprintf>
  return q;
 8114dec:	68fb      	ldr	r3, [r7, #12]
}
 8114dee:	4618      	mov	r0, r3
 8114df0:	3710      	adds	r7, #16
 8114df2:	46bd      	mov	sp, r7
 8114df4:	bd80      	pop	{r7, pc}
 8114df6:	bf00      	nop
 8114df8:	0811da14 	.word	0x0811da14
 8114dfc:	0811debc 	.word	0x0811debc
 8114e00:	0811daa8 	.word	0x0811daa8

08114e04 <pbuf_put_at>:
 * @param offset offset into p of the byte to write
 * @param data byte to write at an offset into p
 */
void
pbuf_put_at(struct pbuf *p, u16_t offset, u8_t data)
{
 8114e04:	b580      	push	{r7, lr}
 8114e06:	b084      	sub	sp, #16
 8114e08:	af00      	add	r7, sp, #0
 8114e0a:	6078      	str	r0, [r7, #4]
 8114e0c:	460b      	mov	r3, r1
 8114e0e:	807b      	strh	r3, [r7, #2]
 8114e10:	4613      	mov	r3, r2
 8114e12:	707b      	strb	r3, [r7, #1]
  u16_t q_idx;
  struct pbuf *q = pbuf_skip(p, offset, &q_idx);
 8114e14:	f107 020a 	add.w	r2, r7, #10
 8114e18:	887b      	ldrh	r3, [r7, #2]
 8114e1a:	4619      	mov	r1, r3
 8114e1c:	6878      	ldr	r0, [r7, #4]
 8114e1e:	f7ff feb0 	bl	8114b82 <pbuf_skip>
 8114e22:	60f8      	str	r0, [r7, #12]

  /* write requested data if pbuf is OK */
  if ((q != NULL) && (q->len > q_idx)) {
 8114e24:	68fb      	ldr	r3, [r7, #12]
 8114e26:	2b00      	cmp	r3, #0
 8114e28:	d00a      	beq.n	8114e40 <pbuf_put_at+0x3c>
 8114e2a:	68fb      	ldr	r3, [r7, #12]
 8114e2c:	895a      	ldrh	r2, [r3, #10]
 8114e2e:	897b      	ldrh	r3, [r7, #10]
 8114e30:	429a      	cmp	r2, r3
 8114e32:	d905      	bls.n	8114e40 <pbuf_put_at+0x3c>
    ((u8_t *)q->payload)[q_idx] = data;
 8114e34:	68fb      	ldr	r3, [r7, #12]
 8114e36:	685b      	ldr	r3, [r3, #4]
 8114e38:	897a      	ldrh	r2, [r7, #10]
 8114e3a:	4413      	add	r3, r2
 8114e3c:	787a      	ldrb	r2, [r7, #1]
 8114e3e:	701a      	strb	r2, [r3, #0]
  }
}
 8114e40:	bf00      	nop
 8114e42:	3710      	adds	r7, #16
 8114e44:	46bd      	mov	sp, r7
 8114e46:	bd80      	pop	{r7, pc}

08114e48 <tcp_init>:
/**
 * Initialize this module.
 */
void
tcp_init(void)
{
 8114e48:	b580      	push	{r7, lr}
 8114e4a:	af00      	add	r7, sp, #0
#ifdef LWIP_RAND
  tcp_port = TCP_ENSURE_LOCAL_PORT_RANGE(LWIP_RAND());
 8114e4c:	f006 fbea 	bl	811b624 <rand>
 8114e50:	4603      	mov	r3, r0
 8114e52:	b29b      	uxth	r3, r3
 8114e54:	f3c3 030d 	ubfx	r3, r3, #0, #14
 8114e58:	b29b      	uxth	r3, r3
 8114e5a:	f5a3 4380 	sub.w	r3, r3, #16384	; 0x4000
 8114e5e:	b29a      	uxth	r2, r3
 8114e60:	4b01      	ldr	r3, [pc, #4]	; (8114e68 <tcp_init+0x20>)
 8114e62:	801a      	strh	r2, [r3, #0]
#endif /* LWIP_RAND */
}
 8114e64:	bf00      	nop
 8114e66:	bd80      	pop	{r7, pc}
 8114e68:	10000104 	.word	0x10000104

08114e6c <tcp_free>:

/** Free a tcp pcb */
void
tcp_free(struct tcp_pcb *pcb)
{
 8114e6c:	b580      	push	{r7, lr}
 8114e6e:	b082      	sub	sp, #8
 8114e70:	af00      	add	r7, sp, #0
 8114e72:	6078      	str	r0, [r7, #4]
  LWIP_ASSERT("tcp_free: LISTEN", pcb->state != LISTEN);
 8114e74:	687b      	ldr	r3, [r7, #4]
 8114e76:	7d1b      	ldrb	r3, [r3, #20]
 8114e78:	2b01      	cmp	r3, #1
 8114e7a:	d105      	bne.n	8114e88 <tcp_free+0x1c>
 8114e7c:	4b06      	ldr	r3, [pc, #24]	; (8114e98 <tcp_free+0x2c>)
 8114e7e:	22d4      	movs	r2, #212	; 0xd4
 8114e80:	4906      	ldr	r1, [pc, #24]	; (8114e9c <tcp_free+0x30>)
 8114e82:	4807      	ldr	r0, [pc, #28]	; (8114ea0 <tcp_free+0x34>)
 8114e84:	f006 fcbc 	bl	811b800 <iprintf>
#if LWIP_TCP_PCB_NUM_EXT_ARGS
  tcp_ext_arg_invoke_callbacks_destroyed(pcb->ext_args);
#endif
  memp_free(MEMP_TCP_PCB, pcb);
 8114e88:	6879      	ldr	r1, [r7, #4]
 8114e8a:	2001      	movs	r0, #1
 8114e8c:	f7fe fd82 	bl	8113994 <memp_free>
}
 8114e90:	bf00      	nop
 8114e92:	3708      	adds	r7, #8
 8114e94:	46bd      	mov	sp, r7
 8114e96:	bd80      	pop	{r7, pc}
 8114e98:	0811df48 	.word	0x0811df48
 8114e9c:	0811dfac 	.word	0x0811dfac
 8114ea0:	0811dfc0 	.word	0x0811dfc0

08114ea4 <tcp_free_listen>:

/** Free a tcp listen pcb */
static void
tcp_free_listen(struct tcp_pcb *pcb)
{
 8114ea4:	b580      	push	{r7, lr}
 8114ea6:	b082      	sub	sp, #8
 8114ea8:	af00      	add	r7, sp, #0
 8114eaa:	6078      	str	r0, [r7, #4]
  LWIP_ASSERT("tcp_free_listen: !LISTEN", pcb->state != LISTEN);
 8114eac:	687b      	ldr	r3, [r7, #4]
 8114eae:	7d1b      	ldrb	r3, [r3, #20]
 8114eb0:	2b01      	cmp	r3, #1
 8114eb2:	d105      	bne.n	8114ec0 <tcp_free_listen+0x1c>
 8114eb4:	4b06      	ldr	r3, [pc, #24]	; (8114ed0 <tcp_free_listen+0x2c>)
 8114eb6:	22df      	movs	r2, #223	; 0xdf
 8114eb8:	4906      	ldr	r1, [pc, #24]	; (8114ed4 <tcp_free_listen+0x30>)
 8114eba:	4807      	ldr	r0, [pc, #28]	; (8114ed8 <tcp_free_listen+0x34>)
 8114ebc:	f006 fca0 	bl	811b800 <iprintf>
#if LWIP_TCP_PCB_NUM_EXT_ARGS
  tcp_ext_arg_invoke_callbacks_destroyed(pcb->ext_args);
#endif
  memp_free(MEMP_TCP_PCB_LISTEN, pcb);
 8114ec0:	6879      	ldr	r1, [r7, #4]
 8114ec2:	2002      	movs	r0, #2
 8114ec4:	f7fe fd66 	bl	8113994 <memp_free>
}
 8114ec8:	bf00      	nop
 8114eca:	3708      	adds	r7, #8
 8114ecc:	46bd      	mov	sp, r7
 8114ece:	bd80      	pop	{r7, pc}
 8114ed0:	0811df48 	.word	0x0811df48
 8114ed4:	0811dfe8 	.word	0x0811dfe8
 8114ed8:	0811dfc0 	.word	0x0811dfc0

08114edc <tcp_tmr>:
/**
 * Called periodically to dispatch TCP timers.
 */
void
tcp_tmr(void)
{
 8114edc:	b580      	push	{r7, lr}
 8114ede:	af00      	add	r7, sp, #0
  /* Call tcp_fasttmr() every 250 ms */
  tcp_fasttmr();
 8114ee0:	f000 fea2 	bl	8115c28 <tcp_fasttmr>

  if (++tcp_timer & 1) {
 8114ee4:	4b07      	ldr	r3, [pc, #28]	; (8114f04 <tcp_tmr+0x28>)
 8114ee6:	781b      	ldrb	r3, [r3, #0]
 8114ee8:	3301      	adds	r3, #1
 8114eea:	b2da      	uxtb	r2, r3
 8114eec:	4b05      	ldr	r3, [pc, #20]	; (8114f04 <tcp_tmr+0x28>)
 8114eee:	701a      	strb	r2, [r3, #0]
 8114ef0:	4b04      	ldr	r3, [pc, #16]	; (8114f04 <tcp_tmr+0x28>)
 8114ef2:	781b      	ldrb	r3, [r3, #0]
 8114ef4:	f003 0301 	and.w	r3, r3, #1
 8114ef8:	2b00      	cmp	r3, #0
 8114efa:	d001      	beq.n	8114f00 <tcp_tmr+0x24>
    /* Call tcp_slowtmr() every 500 ms, i.e., every other timer
       tcp_tmr() is called. */
    tcp_slowtmr();
 8114efc:	f000 fb54 	bl	81155a8 <tcp_slowtmr>
  }
}
 8114f00:	bf00      	nop
 8114f02:	bd80      	pop	{r7, pc}
 8114f04:	1000845d 	.word	0x1000845d

08114f08 <tcp_remove_listener>:
/** Called when a listen pcb is closed. Iterates one pcb list and removes the
 * closed listener pcb from pcb->listener if matching.
 */
static void
tcp_remove_listener(struct tcp_pcb *list, struct tcp_pcb_listen *lpcb)
{
 8114f08:	b580      	push	{r7, lr}
 8114f0a:	b084      	sub	sp, #16
 8114f0c:	af00      	add	r7, sp, #0
 8114f0e:	6078      	str	r0, [r7, #4]
 8114f10:	6039      	str	r1, [r7, #0]
  struct tcp_pcb *pcb;

  LWIP_ASSERT("tcp_remove_listener: invalid listener", lpcb != NULL);
 8114f12:	683b      	ldr	r3, [r7, #0]
 8114f14:	2b00      	cmp	r3, #0
 8114f16:	d105      	bne.n	8114f24 <tcp_remove_listener+0x1c>
 8114f18:	4b0d      	ldr	r3, [pc, #52]	; (8114f50 <tcp_remove_listener+0x48>)
 8114f1a:	22ff      	movs	r2, #255	; 0xff
 8114f1c:	490d      	ldr	r1, [pc, #52]	; (8114f54 <tcp_remove_listener+0x4c>)
 8114f1e:	480e      	ldr	r0, [pc, #56]	; (8114f58 <tcp_remove_listener+0x50>)
 8114f20:	f006 fc6e 	bl	811b800 <iprintf>

  for (pcb = list; pcb != NULL; pcb = pcb->next) {
 8114f24:	687b      	ldr	r3, [r7, #4]
 8114f26:	60fb      	str	r3, [r7, #12]
 8114f28:	e00a      	b.n	8114f40 <tcp_remove_listener+0x38>
    if (pcb->listener == lpcb) {
 8114f2a:	68fb      	ldr	r3, [r7, #12]
 8114f2c:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 8114f2e:	683a      	ldr	r2, [r7, #0]
 8114f30:	429a      	cmp	r2, r3
 8114f32:	d102      	bne.n	8114f3a <tcp_remove_listener+0x32>
      pcb->listener = NULL;
 8114f34:	68fb      	ldr	r3, [r7, #12]
 8114f36:	2200      	movs	r2, #0
 8114f38:	67da      	str	r2, [r3, #124]	; 0x7c
  for (pcb = list; pcb != NULL; pcb = pcb->next) {
 8114f3a:	68fb      	ldr	r3, [r7, #12]
 8114f3c:	68db      	ldr	r3, [r3, #12]
 8114f3e:	60fb      	str	r3, [r7, #12]
 8114f40:	68fb      	ldr	r3, [r7, #12]
 8114f42:	2b00      	cmp	r3, #0
 8114f44:	d1f1      	bne.n	8114f2a <tcp_remove_listener+0x22>
    }
  }
}
 8114f46:	bf00      	nop
 8114f48:	bf00      	nop
 8114f4a:	3710      	adds	r7, #16
 8114f4c:	46bd      	mov	sp, r7
 8114f4e:	bd80      	pop	{r7, pc}
 8114f50:	0811df48 	.word	0x0811df48
 8114f54:	0811e004 	.word	0x0811e004
 8114f58:	0811dfc0 	.word	0x0811dfc0

08114f5c <tcp_listen_closed>:
/** Called when a listen pcb is closed. Iterates all pcb lists and removes the
 * closed listener pcb from pcb->listener if matching.
 */
static void
tcp_listen_closed(struct tcp_pcb *pcb)
{
 8114f5c:	b580      	push	{r7, lr}
 8114f5e:	b084      	sub	sp, #16
 8114f60:	af00      	add	r7, sp, #0
 8114f62:	6078      	str	r0, [r7, #4]
#if LWIP_CALLBACK_API || TCP_LISTEN_BACKLOG
  size_t i;
  LWIP_ASSERT("pcb != NULL", pcb != NULL);
 8114f64:	687b      	ldr	r3, [r7, #4]
 8114f66:	2b00      	cmp	r3, #0
 8114f68:	d106      	bne.n	8114f78 <tcp_listen_closed+0x1c>
 8114f6a:	4b14      	ldr	r3, [pc, #80]	; (8114fbc <tcp_listen_closed+0x60>)
 8114f6c:	f240 1211 	movw	r2, #273	; 0x111
 8114f70:	4913      	ldr	r1, [pc, #76]	; (8114fc0 <tcp_listen_closed+0x64>)
 8114f72:	4814      	ldr	r0, [pc, #80]	; (8114fc4 <tcp_listen_closed+0x68>)
 8114f74:	f006 fc44 	bl	811b800 <iprintf>
  LWIP_ASSERT("pcb->state == LISTEN", pcb->state == LISTEN);
 8114f78:	687b      	ldr	r3, [r7, #4]
 8114f7a:	7d1b      	ldrb	r3, [r3, #20]
 8114f7c:	2b01      	cmp	r3, #1
 8114f7e:	d006      	beq.n	8114f8e <tcp_listen_closed+0x32>
 8114f80:	4b0e      	ldr	r3, [pc, #56]	; (8114fbc <tcp_listen_closed+0x60>)
 8114f82:	f44f 7289 	mov.w	r2, #274	; 0x112
 8114f86:	4910      	ldr	r1, [pc, #64]	; (8114fc8 <tcp_listen_closed+0x6c>)
 8114f88:	480e      	ldr	r0, [pc, #56]	; (8114fc4 <tcp_listen_closed+0x68>)
 8114f8a:	f006 fc39 	bl	811b800 <iprintf>
  for (i = 1; i < LWIP_ARRAYSIZE(tcp_pcb_lists); i++) {
 8114f8e:	2301      	movs	r3, #1
 8114f90:	60fb      	str	r3, [r7, #12]
 8114f92:	e00b      	b.n	8114fac <tcp_listen_closed+0x50>
    tcp_remove_listener(*tcp_pcb_lists[i], (struct tcp_pcb_listen *)pcb);
 8114f94:	4a0d      	ldr	r2, [pc, #52]	; (8114fcc <tcp_listen_closed+0x70>)
 8114f96:	68fb      	ldr	r3, [r7, #12]
 8114f98:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8114f9c:	681b      	ldr	r3, [r3, #0]
 8114f9e:	6879      	ldr	r1, [r7, #4]
 8114fa0:	4618      	mov	r0, r3
 8114fa2:	f7ff ffb1 	bl	8114f08 <tcp_remove_listener>
  for (i = 1; i < LWIP_ARRAYSIZE(tcp_pcb_lists); i++) {
 8114fa6:	68fb      	ldr	r3, [r7, #12]
 8114fa8:	3301      	adds	r3, #1
 8114faa:	60fb      	str	r3, [r7, #12]
 8114fac:	68fb      	ldr	r3, [r7, #12]
 8114fae:	2b03      	cmp	r3, #3
 8114fb0:	d9f0      	bls.n	8114f94 <tcp_listen_closed+0x38>
  }
#endif
  LWIP_UNUSED_ARG(pcb);
}
 8114fb2:	bf00      	nop
 8114fb4:	bf00      	nop
 8114fb6:	3710      	adds	r7, #16
 8114fb8:	46bd      	mov	sp, r7
 8114fba:	bd80      	pop	{r7, pc}
 8114fbc:	0811df48 	.word	0x0811df48
 8114fc0:	0811e02c 	.word	0x0811e02c
 8114fc4:	0811dfc0 	.word	0x0811dfc0
 8114fc8:	0811e038 	.word	0x0811e038
 8114fcc:	0811f9e4 	.word	0x0811f9e4

08114fd0 <tcp_close_shutdown>:
 * @return ERR_OK if connection has been closed
 *         another err_t if closing failed and pcb is not freed
 */
static err_t
tcp_close_shutdown(struct tcp_pcb *pcb, u8_t rst_on_unacked_data)
{
 8114fd0:	b5b0      	push	{r4, r5, r7, lr}
 8114fd2:	b088      	sub	sp, #32
 8114fd4:	af04      	add	r7, sp, #16
 8114fd6:	6078      	str	r0, [r7, #4]
 8114fd8:	460b      	mov	r3, r1
 8114fda:	70fb      	strb	r3, [r7, #3]
  LWIP_ASSERT("tcp_close_shutdown: invalid pcb", pcb != NULL);
 8114fdc:	687b      	ldr	r3, [r7, #4]
 8114fde:	2b00      	cmp	r3, #0
 8114fe0:	d106      	bne.n	8114ff0 <tcp_close_shutdown+0x20>
 8114fe2:	4b63      	ldr	r3, [pc, #396]	; (8115170 <tcp_close_shutdown+0x1a0>)
 8114fe4:	f44f 72af 	mov.w	r2, #350	; 0x15e
 8114fe8:	4962      	ldr	r1, [pc, #392]	; (8115174 <tcp_close_shutdown+0x1a4>)
 8114fea:	4863      	ldr	r0, [pc, #396]	; (8115178 <tcp_close_shutdown+0x1a8>)
 8114fec:	f006 fc08 	bl	811b800 <iprintf>

  if (rst_on_unacked_data && ((pcb->state == ESTABLISHED) || (pcb->state == CLOSE_WAIT))) {
 8114ff0:	78fb      	ldrb	r3, [r7, #3]
 8114ff2:	2b00      	cmp	r3, #0
 8114ff4:	d066      	beq.n	81150c4 <tcp_close_shutdown+0xf4>
 8114ff6:	687b      	ldr	r3, [r7, #4]
 8114ff8:	7d1b      	ldrb	r3, [r3, #20]
 8114ffa:	2b04      	cmp	r3, #4
 8114ffc:	d003      	beq.n	8115006 <tcp_close_shutdown+0x36>
 8114ffe:	687b      	ldr	r3, [r7, #4]
 8115000:	7d1b      	ldrb	r3, [r3, #20]
 8115002:	2b07      	cmp	r3, #7
 8115004:	d15e      	bne.n	81150c4 <tcp_close_shutdown+0xf4>
    if ((pcb->refused_data != NULL) || (pcb->rcv_wnd != TCP_WND_MAX(pcb))) {
 8115006:	687b      	ldr	r3, [r7, #4]
 8115008:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 811500a:	2b00      	cmp	r3, #0
 811500c:	d104      	bne.n	8115018 <tcp_close_shutdown+0x48>
 811500e:	687b      	ldr	r3, [r7, #4]
 8115010:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
 8115012:	f5b3 6f06 	cmp.w	r3, #2144	; 0x860
 8115016:	d055      	beq.n	81150c4 <tcp_close_shutdown+0xf4>
      /* Not all data received by application, send RST to tell the remote
         side about this. */
      LWIP_ASSERT("pcb->flags & TF_RXCLOSED", pcb->flags & TF_RXCLOSED);
 8115018:	687b      	ldr	r3, [r7, #4]
 811501a:	8b5b      	ldrh	r3, [r3, #26]
 811501c:	f003 0310 	and.w	r3, r3, #16
 8115020:	2b00      	cmp	r3, #0
 8115022:	d106      	bne.n	8115032 <tcp_close_shutdown+0x62>
 8115024:	4b52      	ldr	r3, [pc, #328]	; (8115170 <tcp_close_shutdown+0x1a0>)
 8115026:	f44f 72b2 	mov.w	r2, #356	; 0x164
 811502a:	4954      	ldr	r1, [pc, #336]	; (811517c <tcp_close_shutdown+0x1ac>)
 811502c:	4852      	ldr	r0, [pc, #328]	; (8115178 <tcp_close_shutdown+0x1a8>)
 811502e:	f006 fbe7 	bl	811b800 <iprintf>

      /* don't call tcp_abort here: we must not deallocate the pcb since
         that might not be expected when calling tcp_close */
      tcp_rst(pcb, pcb->snd_nxt, pcb->rcv_nxt, &pcb->local_ip, &pcb->remote_ip,
 8115032:	687b      	ldr	r3, [r7, #4]
 8115034:	6d18      	ldr	r0, [r3, #80]	; 0x50
 8115036:	687b      	ldr	r3, [r7, #4]
 8115038:	6a5c      	ldr	r4, [r3, #36]	; 0x24
 811503a:	687d      	ldr	r5, [r7, #4]
 811503c:	687b      	ldr	r3, [r7, #4]
 811503e:	3304      	adds	r3, #4
 8115040:	687a      	ldr	r2, [r7, #4]
 8115042:	8ad2      	ldrh	r2, [r2, #22]
 8115044:	6879      	ldr	r1, [r7, #4]
 8115046:	8b09      	ldrh	r1, [r1, #24]
 8115048:	9102      	str	r1, [sp, #8]
 811504a:	9201      	str	r2, [sp, #4]
 811504c:	9300      	str	r3, [sp, #0]
 811504e:	462b      	mov	r3, r5
 8115050:	4622      	mov	r2, r4
 8115052:	4601      	mov	r1, r0
 8115054:	6878      	ldr	r0, [r7, #4]
 8115056:	f004 fe91 	bl	8119d7c <tcp_rst>
              pcb->local_port, pcb->remote_port);

      tcp_pcb_purge(pcb);
 811505a:	6878      	ldr	r0, [r7, #4]
 811505c:	f001 f8c6 	bl	81161ec <tcp_pcb_purge>
      TCP_RMV_ACTIVE(pcb);
 8115060:	4b47      	ldr	r3, [pc, #284]	; (8115180 <tcp_close_shutdown+0x1b0>)
 8115062:	681b      	ldr	r3, [r3, #0]
 8115064:	687a      	ldr	r2, [r7, #4]
 8115066:	429a      	cmp	r2, r3
 8115068:	d105      	bne.n	8115076 <tcp_close_shutdown+0xa6>
 811506a:	4b45      	ldr	r3, [pc, #276]	; (8115180 <tcp_close_shutdown+0x1b0>)
 811506c:	681b      	ldr	r3, [r3, #0]
 811506e:	68db      	ldr	r3, [r3, #12]
 8115070:	4a43      	ldr	r2, [pc, #268]	; (8115180 <tcp_close_shutdown+0x1b0>)
 8115072:	6013      	str	r3, [r2, #0]
 8115074:	e013      	b.n	811509e <tcp_close_shutdown+0xce>
 8115076:	4b42      	ldr	r3, [pc, #264]	; (8115180 <tcp_close_shutdown+0x1b0>)
 8115078:	681b      	ldr	r3, [r3, #0]
 811507a:	60fb      	str	r3, [r7, #12]
 811507c:	e00c      	b.n	8115098 <tcp_close_shutdown+0xc8>
 811507e:	68fb      	ldr	r3, [r7, #12]
 8115080:	68db      	ldr	r3, [r3, #12]
 8115082:	687a      	ldr	r2, [r7, #4]
 8115084:	429a      	cmp	r2, r3
 8115086:	d104      	bne.n	8115092 <tcp_close_shutdown+0xc2>
 8115088:	687b      	ldr	r3, [r7, #4]
 811508a:	68da      	ldr	r2, [r3, #12]
 811508c:	68fb      	ldr	r3, [r7, #12]
 811508e:	60da      	str	r2, [r3, #12]
 8115090:	e005      	b.n	811509e <tcp_close_shutdown+0xce>
 8115092:	68fb      	ldr	r3, [r7, #12]
 8115094:	68db      	ldr	r3, [r3, #12]
 8115096:	60fb      	str	r3, [r7, #12]
 8115098:	68fb      	ldr	r3, [r7, #12]
 811509a:	2b00      	cmp	r3, #0
 811509c:	d1ef      	bne.n	811507e <tcp_close_shutdown+0xae>
 811509e:	687b      	ldr	r3, [r7, #4]
 81150a0:	2200      	movs	r2, #0
 81150a2:	60da      	str	r2, [r3, #12]
 81150a4:	4b37      	ldr	r3, [pc, #220]	; (8115184 <tcp_close_shutdown+0x1b4>)
 81150a6:	2201      	movs	r2, #1
 81150a8:	701a      	strb	r2, [r3, #0]
      /* Deallocate the pcb since we already sent a RST for it */
      if (tcp_input_pcb == pcb) {
 81150aa:	4b37      	ldr	r3, [pc, #220]	; (8115188 <tcp_close_shutdown+0x1b8>)
 81150ac:	681b      	ldr	r3, [r3, #0]
 81150ae:	687a      	ldr	r2, [r7, #4]
 81150b0:	429a      	cmp	r2, r3
 81150b2:	d102      	bne.n	81150ba <tcp_close_shutdown+0xea>
        /* prevent using a deallocated pcb: free it from tcp_input later */
        tcp_trigger_input_pcb_close();
 81150b4:	f003 fd5e 	bl	8118b74 <tcp_trigger_input_pcb_close>
 81150b8:	e002      	b.n	81150c0 <tcp_close_shutdown+0xf0>
      } else {
        tcp_free(pcb);
 81150ba:	6878      	ldr	r0, [r7, #4]
 81150bc:	f7ff fed6 	bl	8114e6c <tcp_free>
      }
      return ERR_OK;
 81150c0:	2300      	movs	r3, #0
 81150c2:	e050      	b.n	8115166 <tcp_close_shutdown+0x196>
    }
  }

  /* - states which free the pcb are handled here,
     - states which send FIN and change state are handled in tcp_close_shutdown_fin() */
  switch (pcb->state) {
 81150c4:	687b      	ldr	r3, [r7, #4]
 81150c6:	7d1b      	ldrb	r3, [r3, #20]
 81150c8:	2b02      	cmp	r3, #2
 81150ca:	d03b      	beq.n	8115144 <tcp_close_shutdown+0x174>
 81150cc:	2b02      	cmp	r3, #2
 81150ce:	dc44      	bgt.n	811515a <tcp_close_shutdown+0x18a>
 81150d0:	2b00      	cmp	r3, #0
 81150d2:	d002      	beq.n	81150da <tcp_close_shutdown+0x10a>
 81150d4:	2b01      	cmp	r3, #1
 81150d6:	d02a      	beq.n	811512e <tcp_close_shutdown+0x15e>
 81150d8:	e03f      	b.n	811515a <tcp_close_shutdown+0x18a>
       * and the user needs some way to free it should the need arise.
       * Calling tcp_close() with a pcb that has already been closed, (i.e. twice)
       * or for a pcb that has been used and then entered the CLOSED state
       * is erroneous, but this should never happen as the pcb has in those cases
       * been freed, and so any remaining handles are bogus. */
      if (pcb->local_port != 0) {
 81150da:	687b      	ldr	r3, [r7, #4]
 81150dc:	8adb      	ldrh	r3, [r3, #22]
 81150de:	2b00      	cmp	r3, #0
 81150e0:	d021      	beq.n	8115126 <tcp_close_shutdown+0x156>
        TCP_RMV(&tcp_bound_pcbs, pcb);
 81150e2:	4b2a      	ldr	r3, [pc, #168]	; (811518c <tcp_close_shutdown+0x1bc>)
 81150e4:	681b      	ldr	r3, [r3, #0]
 81150e6:	687a      	ldr	r2, [r7, #4]
 81150e8:	429a      	cmp	r2, r3
 81150ea:	d105      	bne.n	81150f8 <tcp_close_shutdown+0x128>
 81150ec:	4b27      	ldr	r3, [pc, #156]	; (811518c <tcp_close_shutdown+0x1bc>)
 81150ee:	681b      	ldr	r3, [r3, #0]
 81150f0:	68db      	ldr	r3, [r3, #12]
 81150f2:	4a26      	ldr	r2, [pc, #152]	; (811518c <tcp_close_shutdown+0x1bc>)
 81150f4:	6013      	str	r3, [r2, #0]
 81150f6:	e013      	b.n	8115120 <tcp_close_shutdown+0x150>
 81150f8:	4b24      	ldr	r3, [pc, #144]	; (811518c <tcp_close_shutdown+0x1bc>)
 81150fa:	681b      	ldr	r3, [r3, #0]
 81150fc:	60bb      	str	r3, [r7, #8]
 81150fe:	e00c      	b.n	811511a <tcp_close_shutdown+0x14a>
 8115100:	68bb      	ldr	r3, [r7, #8]
 8115102:	68db      	ldr	r3, [r3, #12]
 8115104:	687a      	ldr	r2, [r7, #4]
 8115106:	429a      	cmp	r2, r3
 8115108:	d104      	bne.n	8115114 <tcp_close_shutdown+0x144>
 811510a:	687b      	ldr	r3, [r7, #4]
 811510c:	68da      	ldr	r2, [r3, #12]
 811510e:	68bb      	ldr	r3, [r7, #8]
 8115110:	60da      	str	r2, [r3, #12]
 8115112:	e005      	b.n	8115120 <tcp_close_shutdown+0x150>
 8115114:	68bb      	ldr	r3, [r7, #8]
 8115116:	68db      	ldr	r3, [r3, #12]
 8115118:	60bb      	str	r3, [r7, #8]
 811511a:	68bb      	ldr	r3, [r7, #8]
 811511c:	2b00      	cmp	r3, #0
 811511e:	d1ef      	bne.n	8115100 <tcp_close_shutdown+0x130>
 8115120:	687b      	ldr	r3, [r7, #4]
 8115122:	2200      	movs	r2, #0
 8115124:	60da      	str	r2, [r3, #12]
      }
      tcp_free(pcb);
 8115126:	6878      	ldr	r0, [r7, #4]
 8115128:	f7ff fea0 	bl	8114e6c <tcp_free>
      break;
 811512c:	e01a      	b.n	8115164 <tcp_close_shutdown+0x194>
    case LISTEN:
      tcp_listen_closed(pcb);
 811512e:	6878      	ldr	r0, [r7, #4]
 8115130:	f7ff ff14 	bl	8114f5c <tcp_listen_closed>
      tcp_pcb_remove(&tcp_listen_pcbs.pcbs, pcb);
 8115134:	6879      	ldr	r1, [r7, #4]
 8115136:	4816      	ldr	r0, [pc, #88]	; (8115190 <tcp_close_shutdown+0x1c0>)
 8115138:	f001 f8a8 	bl	811628c <tcp_pcb_remove>
      tcp_free_listen(pcb);
 811513c:	6878      	ldr	r0, [r7, #4]
 811513e:	f7ff feb1 	bl	8114ea4 <tcp_free_listen>
      break;
 8115142:	e00f      	b.n	8115164 <tcp_close_shutdown+0x194>
    case SYN_SENT:
      TCP_PCB_REMOVE_ACTIVE(pcb);
 8115144:	6879      	ldr	r1, [r7, #4]
 8115146:	480e      	ldr	r0, [pc, #56]	; (8115180 <tcp_close_shutdown+0x1b0>)
 8115148:	f001 f8a0 	bl	811628c <tcp_pcb_remove>
 811514c:	4b0d      	ldr	r3, [pc, #52]	; (8115184 <tcp_close_shutdown+0x1b4>)
 811514e:	2201      	movs	r2, #1
 8115150:	701a      	strb	r2, [r3, #0]
      tcp_free(pcb);
 8115152:	6878      	ldr	r0, [r7, #4]
 8115154:	f7ff fe8a 	bl	8114e6c <tcp_free>
      MIB2_STATS_INC(mib2.tcpattemptfails);
      break;
 8115158:	e004      	b.n	8115164 <tcp_close_shutdown+0x194>
    default:
      return tcp_close_shutdown_fin(pcb);
 811515a:	6878      	ldr	r0, [r7, #4]
 811515c:	f000 f81a 	bl	8115194 <tcp_close_shutdown_fin>
 8115160:	4603      	mov	r3, r0
 8115162:	e000      	b.n	8115166 <tcp_close_shutdown+0x196>
  }
  return ERR_OK;
 8115164:	2300      	movs	r3, #0
}
 8115166:	4618      	mov	r0, r3
 8115168:	3710      	adds	r7, #16
 811516a:	46bd      	mov	sp, r7
 811516c:	bdb0      	pop	{r4, r5, r7, pc}
 811516e:	bf00      	nop
 8115170:	0811df48 	.word	0x0811df48
 8115174:	0811e050 	.word	0x0811e050
 8115178:	0811dfc0 	.word	0x0811dfc0
 811517c:	0811e070 	.word	0x0811e070
 8115180:	10008454 	.word	0x10008454
 8115184:	1000845c 	.word	0x1000845c
 8115188:	10008494 	.word	0x10008494
 811518c:	1000844c 	.word	0x1000844c
 8115190:	10008450 	.word	0x10008450

08115194 <tcp_close_shutdown_fin>:

static err_t
tcp_close_shutdown_fin(struct tcp_pcb *pcb)
{
 8115194:	b580      	push	{r7, lr}
 8115196:	b084      	sub	sp, #16
 8115198:	af00      	add	r7, sp, #0
 811519a:	6078      	str	r0, [r7, #4]
  err_t err;
  LWIP_ASSERT("pcb != NULL", pcb != NULL);
 811519c:	687b      	ldr	r3, [r7, #4]
 811519e:	2b00      	cmp	r3, #0
 81151a0:	d106      	bne.n	81151b0 <tcp_close_shutdown_fin+0x1c>
 81151a2:	4b2e      	ldr	r3, [pc, #184]	; (811525c <tcp_close_shutdown_fin+0xc8>)
 81151a4:	f44f 72ce 	mov.w	r2, #412	; 0x19c
 81151a8:	492d      	ldr	r1, [pc, #180]	; (8115260 <tcp_close_shutdown_fin+0xcc>)
 81151aa:	482e      	ldr	r0, [pc, #184]	; (8115264 <tcp_close_shutdown_fin+0xd0>)
 81151ac:	f006 fb28 	bl	811b800 <iprintf>

  switch (pcb->state) {
 81151b0:	687b      	ldr	r3, [r7, #4]
 81151b2:	7d1b      	ldrb	r3, [r3, #20]
 81151b4:	2b07      	cmp	r3, #7
 81151b6:	d020      	beq.n	81151fa <tcp_close_shutdown_fin+0x66>
 81151b8:	2b07      	cmp	r3, #7
 81151ba:	dc2b      	bgt.n	8115214 <tcp_close_shutdown_fin+0x80>
 81151bc:	2b03      	cmp	r3, #3
 81151be:	d002      	beq.n	81151c6 <tcp_close_shutdown_fin+0x32>
 81151c0:	2b04      	cmp	r3, #4
 81151c2:	d00d      	beq.n	81151e0 <tcp_close_shutdown_fin+0x4c>
 81151c4:	e026      	b.n	8115214 <tcp_close_shutdown_fin+0x80>
    case SYN_RCVD:
      err = tcp_send_fin(pcb);
 81151c6:	6878      	ldr	r0, [r7, #4]
 81151c8:	f003 fee6 	bl	8118f98 <tcp_send_fin>
 81151cc:	4603      	mov	r3, r0
 81151ce:	73fb      	strb	r3, [r7, #15]
      if (err == ERR_OK) {
 81151d0:	f997 300f 	ldrsb.w	r3, [r7, #15]
 81151d4:	2b00      	cmp	r3, #0
 81151d6:	d11f      	bne.n	8115218 <tcp_close_shutdown_fin+0x84>
        tcp_backlog_accepted(pcb);
        MIB2_STATS_INC(mib2.tcpattemptfails);
        pcb->state = FIN_WAIT_1;
 81151d8:	687b      	ldr	r3, [r7, #4]
 81151da:	2205      	movs	r2, #5
 81151dc:	751a      	strb	r2, [r3, #20]
      }
      break;
 81151de:	e01b      	b.n	8115218 <tcp_close_shutdown_fin+0x84>
    case ESTABLISHED:
      err = tcp_send_fin(pcb);
 81151e0:	6878      	ldr	r0, [r7, #4]
 81151e2:	f003 fed9 	bl	8118f98 <tcp_send_fin>
 81151e6:	4603      	mov	r3, r0
 81151e8:	73fb      	strb	r3, [r7, #15]
      if (err == ERR_OK) {
 81151ea:	f997 300f 	ldrsb.w	r3, [r7, #15]
 81151ee:	2b00      	cmp	r3, #0
 81151f0:	d114      	bne.n	811521c <tcp_close_shutdown_fin+0x88>
        MIB2_STATS_INC(mib2.tcpestabresets);
        pcb->state = FIN_WAIT_1;
 81151f2:	687b      	ldr	r3, [r7, #4]
 81151f4:	2205      	movs	r2, #5
 81151f6:	751a      	strb	r2, [r3, #20]
      }
      break;
 81151f8:	e010      	b.n	811521c <tcp_close_shutdown_fin+0x88>
    case CLOSE_WAIT:
      err = tcp_send_fin(pcb);
 81151fa:	6878      	ldr	r0, [r7, #4]
 81151fc:	f003 fecc 	bl	8118f98 <tcp_send_fin>
 8115200:	4603      	mov	r3, r0
 8115202:	73fb      	strb	r3, [r7, #15]
      if (err == ERR_OK) {
 8115204:	f997 300f 	ldrsb.w	r3, [r7, #15]
 8115208:	2b00      	cmp	r3, #0
 811520a:	d109      	bne.n	8115220 <tcp_close_shutdown_fin+0x8c>
        MIB2_STATS_INC(mib2.tcpestabresets);
        pcb->state = LAST_ACK;
 811520c:	687b      	ldr	r3, [r7, #4]
 811520e:	2209      	movs	r2, #9
 8115210:	751a      	strb	r2, [r3, #20]
      }
      break;
 8115212:	e005      	b.n	8115220 <tcp_close_shutdown_fin+0x8c>
    default:
      /* Has already been closed, do nothing. */
      return ERR_OK;
 8115214:	2300      	movs	r3, #0
 8115216:	e01c      	b.n	8115252 <tcp_close_shutdown_fin+0xbe>
      break;
 8115218:	bf00      	nop
 811521a:	e002      	b.n	8115222 <tcp_close_shutdown_fin+0x8e>
      break;
 811521c:	bf00      	nop
 811521e:	e000      	b.n	8115222 <tcp_close_shutdown_fin+0x8e>
      break;
 8115220:	bf00      	nop
  }

  if (err == ERR_OK) {
 8115222:	f997 300f 	ldrsb.w	r3, [r7, #15]
 8115226:	2b00      	cmp	r3, #0
 8115228:	d103      	bne.n	8115232 <tcp_close_shutdown_fin+0x9e>
    /* To ensure all data has been sent when tcp_close returns, we have
       to make sure tcp_output doesn't fail.
       Since we don't really have to ensure all data has been sent when tcp_close
       returns (unsent data is sent from tcp timer functions, also), we don't care
       for the return value of tcp_output for now. */
    tcp_output(pcb);
 811522a:	6878      	ldr	r0, [r7, #4]
 811522c:	f003 fff2 	bl	8119214 <tcp_output>
 8115230:	e00d      	b.n	811524e <tcp_close_shutdown_fin+0xba>
  } else if (err == ERR_MEM) {
 8115232:	f997 300f 	ldrsb.w	r3, [r7, #15]
 8115236:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 811523a:	d108      	bne.n	811524e <tcp_close_shutdown_fin+0xba>
    /* Mark this pcb for closing. Closing is retried from tcp_tmr. */
    tcp_set_flags(pcb, TF_CLOSEPEND);
 811523c:	687b      	ldr	r3, [r7, #4]
 811523e:	8b5b      	ldrh	r3, [r3, #26]
 8115240:	f043 0308 	orr.w	r3, r3, #8
 8115244:	b29a      	uxth	r2, r3
 8115246:	687b      	ldr	r3, [r7, #4]
 8115248:	835a      	strh	r2, [r3, #26]
    /* We have to return ERR_OK from here to indicate to the callers that this
       pcb should not be used any more as it will be freed soon via tcp_tmr.
       This is OK here since sending FIN does not guarantee a time frime for
       actually freeing the pcb, either (it is left in closure states for
       remote ACK or timeout) */
    return ERR_OK;
 811524a:	2300      	movs	r3, #0
 811524c:	e001      	b.n	8115252 <tcp_close_shutdown_fin+0xbe>
  }
  return err;
 811524e:	f997 300f 	ldrsb.w	r3, [r7, #15]
}
 8115252:	4618      	mov	r0, r3
 8115254:	3710      	adds	r7, #16
 8115256:	46bd      	mov	sp, r7
 8115258:	bd80      	pop	{r7, pc}
 811525a:	bf00      	nop
 811525c:	0811df48 	.word	0x0811df48
 8115260:	0811e02c 	.word	0x0811e02c
 8115264:	0811dfc0 	.word	0x0811dfc0

08115268 <tcp_close>:
 * @return ERR_OK if connection has been closed
 *         another err_t if closing failed and pcb is not freed
 */
err_t
tcp_close(struct tcp_pcb *pcb)
{
 8115268:	b580      	push	{r7, lr}
 811526a:	b082      	sub	sp, #8
 811526c:	af00      	add	r7, sp, #0
 811526e:	6078      	str	r0, [r7, #4]
  LWIP_ASSERT_CORE_LOCKED();

  LWIP_ERROR("tcp_close: invalid pcb", pcb != NULL, return ERR_ARG);
 8115270:	687b      	ldr	r3, [r7, #4]
 8115272:	2b00      	cmp	r3, #0
 8115274:	d109      	bne.n	811528a <tcp_close+0x22>
 8115276:	4b0f      	ldr	r3, [pc, #60]	; (81152b4 <tcp_close+0x4c>)
 8115278:	f44f 72f4 	mov.w	r2, #488	; 0x1e8
 811527c:	490e      	ldr	r1, [pc, #56]	; (81152b8 <tcp_close+0x50>)
 811527e:	480f      	ldr	r0, [pc, #60]	; (81152bc <tcp_close+0x54>)
 8115280:	f006 fabe 	bl	811b800 <iprintf>
 8115284:	f06f 030f 	mvn.w	r3, #15
 8115288:	e00f      	b.n	81152aa <tcp_close+0x42>
  LWIP_DEBUGF(TCP_DEBUG, ("tcp_close: closing in "));

  tcp_debug_print_state(pcb->state);

  if (pcb->state != LISTEN) {
 811528a:	687b      	ldr	r3, [r7, #4]
 811528c:	7d1b      	ldrb	r3, [r3, #20]
 811528e:	2b01      	cmp	r3, #1
 8115290:	d006      	beq.n	81152a0 <tcp_close+0x38>
    /* Set a flag not to receive any more data... */
    tcp_set_flags(pcb, TF_RXCLOSED);
 8115292:	687b      	ldr	r3, [r7, #4]
 8115294:	8b5b      	ldrh	r3, [r3, #26]
 8115296:	f043 0310 	orr.w	r3, r3, #16
 811529a:	b29a      	uxth	r2, r3
 811529c:	687b      	ldr	r3, [r7, #4]
 811529e:	835a      	strh	r2, [r3, #26]
  }
  /* ... and close */
  return tcp_close_shutdown(pcb, 1);
 81152a0:	2101      	movs	r1, #1
 81152a2:	6878      	ldr	r0, [r7, #4]
 81152a4:	f7ff fe94 	bl	8114fd0 <tcp_close_shutdown>
 81152a8:	4603      	mov	r3, r0
}
 81152aa:	4618      	mov	r0, r3
 81152ac:	3708      	adds	r7, #8
 81152ae:	46bd      	mov	sp, r7
 81152b0:	bd80      	pop	{r7, pc}
 81152b2:	bf00      	nop
 81152b4:	0811df48 	.word	0x0811df48
 81152b8:	0811e08c 	.word	0x0811e08c
 81152bc:	0811dfc0 	.word	0x0811dfc0

081152c0 <tcp_abandon>:
 * @param pcb the tcp_pcb to abort
 * @param reset boolean to indicate whether a reset should be sent
 */
void
tcp_abandon(struct tcp_pcb *pcb, int reset)
{
 81152c0:	b580      	push	{r7, lr}
 81152c2:	b08e      	sub	sp, #56	; 0x38
 81152c4:	af04      	add	r7, sp, #16
 81152c6:	6078      	str	r0, [r7, #4]
 81152c8:	6039      	str	r1, [r7, #0]
#endif /* LWIP_CALLBACK_API */
  void *errf_arg;

  LWIP_ASSERT_CORE_LOCKED();

  LWIP_ERROR("tcp_abandon: invalid pcb", pcb != NULL, return);
 81152ca:	687b      	ldr	r3, [r7, #4]
 81152cc:	2b00      	cmp	r3, #0
 81152ce:	d107      	bne.n	81152e0 <tcp_abandon+0x20>
 81152d0:	4b52      	ldr	r3, [pc, #328]	; (811541c <tcp_abandon+0x15c>)
 81152d2:	f240 223d 	movw	r2, #573	; 0x23d
 81152d6:	4952      	ldr	r1, [pc, #328]	; (8115420 <tcp_abandon+0x160>)
 81152d8:	4852      	ldr	r0, [pc, #328]	; (8115424 <tcp_abandon+0x164>)
 81152da:	f006 fa91 	bl	811b800 <iprintf>
 81152de:	e099      	b.n	8115414 <tcp_abandon+0x154>

  /* pcb->state LISTEN not allowed here */
  LWIP_ASSERT("don't call tcp_abort/tcp_abandon for listen-pcbs",
 81152e0:	687b      	ldr	r3, [r7, #4]
 81152e2:	7d1b      	ldrb	r3, [r3, #20]
 81152e4:	2b01      	cmp	r3, #1
 81152e6:	d106      	bne.n	81152f6 <tcp_abandon+0x36>
 81152e8:	4b4c      	ldr	r3, [pc, #304]	; (811541c <tcp_abandon+0x15c>)
 81152ea:	f44f 7210 	mov.w	r2, #576	; 0x240
 81152ee:	494e      	ldr	r1, [pc, #312]	; (8115428 <tcp_abandon+0x168>)
 81152f0:	484c      	ldr	r0, [pc, #304]	; (8115424 <tcp_abandon+0x164>)
 81152f2:	f006 fa85 	bl	811b800 <iprintf>
              pcb->state != LISTEN);
  /* Figure out on which TCP PCB list we are, and remove us. If we
     are in an active state, call the receive function associated with
     the PCB with a NULL argument, and send an RST to the remote end. */
  if (pcb->state == TIME_WAIT) {
 81152f6:	687b      	ldr	r3, [r7, #4]
 81152f8:	7d1b      	ldrb	r3, [r3, #20]
 81152fa:	2b0a      	cmp	r3, #10
 81152fc:	d107      	bne.n	811530e <tcp_abandon+0x4e>
    tcp_pcb_remove(&tcp_tw_pcbs, pcb);
 81152fe:	6879      	ldr	r1, [r7, #4]
 8115300:	484a      	ldr	r0, [pc, #296]	; (811542c <tcp_abandon+0x16c>)
 8115302:	f000 ffc3 	bl	811628c <tcp_pcb_remove>
    tcp_free(pcb);
 8115306:	6878      	ldr	r0, [r7, #4]
 8115308:	f7ff fdb0 	bl	8114e6c <tcp_free>
 811530c:	e082      	b.n	8115414 <tcp_abandon+0x154>
  } else {
    int send_rst = 0;
 811530e:	2300      	movs	r3, #0
 8115310:	627b      	str	r3, [r7, #36]	; 0x24
    u16_t local_port = 0;
 8115312:	2300      	movs	r3, #0
 8115314:	847b      	strh	r3, [r7, #34]	; 0x22
    enum tcp_state last_state;
    seqno = pcb->snd_nxt;
 8115316:	687b      	ldr	r3, [r7, #4]
 8115318:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 811531a:	61bb      	str	r3, [r7, #24]
    ackno = pcb->rcv_nxt;
 811531c:	687b      	ldr	r3, [r7, #4]
 811531e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8115320:	617b      	str	r3, [r7, #20]
#if LWIP_CALLBACK_API
    errf = pcb->errf;
 8115322:	687b      	ldr	r3, [r7, #4]
 8115324:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 8115328:	613b      	str	r3, [r7, #16]
#endif /* LWIP_CALLBACK_API */
    errf_arg = pcb->callback_arg;
 811532a:	687b      	ldr	r3, [r7, #4]
 811532c:	691b      	ldr	r3, [r3, #16]
 811532e:	60fb      	str	r3, [r7, #12]
    if (pcb->state == CLOSED) {
 8115330:	687b      	ldr	r3, [r7, #4]
 8115332:	7d1b      	ldrb	r3, [r3, #20]
 8115334:	2b00      	cmp	r3, #0
 8115336:	d126      	bne.n	8115386 <tcp_abandon+0xc6>
      if (pcb->local_port != 0) {
 8115338:	687b      	ldr	r3, [r7, #4]
 811533a:	8adb      	ldrh	r3, [r3, #22]
 811533c:	2b00      	cmp	r3, #0
 811533e:	d02e      	beq.n	811539e <tcp_abandon+0xde>
        /* bound, not yet opened */
        TCP_RMV(&tcp_bound_pcbs, pcb);
 8115340:	4b3b      	ldr	r3, [pc, #236]	; (8115430 <tcp_abandon+0x170>)
 8115342:	681b      	ldr	r3, [r3, #0]
 8115344:	687a      	ldr	r2, [r7, #4]
 8115346:	429a      	cmp	r2, r3
 8115348:	d105      	bne.n	8115356 <tcp_abandon+0x96>
 811534a:	4b39      	ldr	r3, [pc, #228]	; (8115430 <tcp_abandon+0x170>)
 811534c:	681b      	ldr	r3, [r3, #0]
 811534e:	68db      	ldr	r3, [r3, #12]
 8115350:	4a37      	ldr	r2, [pc, #220]	; (8115430 <tcp_abandon+0x170>)
 8115352:	6013      	str	r3, [r2, #0]
 8115354:	e013      	b.n	811537e <tcp_abandon+0xbe>
 8115356:	4b36      	ldr	r3, [pc, #216]	; (8115430 <tcp_abandon+0x170>)
 8115358:	681b      	ldr	r3, [r3, #0]
 811535a:	61fb      	str	r3, [r7, #28]
 811535c:	e00c      	b.n	8115378 <tcp_abandon+0xb8>
 811535e:	69fb      	ldr	r3, [r7, #28]
 8115360:	68db      	ldr	r3, [r3, #12]
 8115362:	687a      	ldr	r2, [r7, #4]
 8115364:	429a      	cmp	r2, r3
 8115366:	d104      	bne.n	8115372 <tcp_abandon+0xb2>
 8115368:	687b      	ldr	r3, [r7, #4]
 811536a:	68da      	ldr	r2, [r3, #12]
 811536c:	69fb      	ldr	r3, [r7, #28]
 811536e:	60da      	str	r2, [r3, #12]
 8115370:	e005      	b.n	811537e <tcp_abandon+0xbe>
 8115372:	69fb      	ldr	r3, [r7, #28]
 8115374:	68db      	ldr	r3, [r3, #12]
 8115376:	61fb      	str	r3, [r7, #28]
 8115378:	69fb      	ldr	r3, [r7, #28]
 811537a:	2b00      	cmp	r3, #0
 811537c:	d1ef      	bne.n	811535e <tcp_abandon+0x9e>
 811537e:	687b      	ldr	r3, [r7, #4]
 8115380:	2200      	movs	r2, #0
 8115382:	60da      	str	r2, [r3, #12]
 8115384:	e00b      	b.n	811539e <tcp_abandon+0xde>
      }
    } else {
      send_rst = reset;
 8115386:	683b      	ldr	r3, [r7, #0]
 8115388:	627b      	str	r3, [r7, #36]	; 0x24
      local_port = pcb->local_port;
 811538a:	687b      	ldr	r3, [r7, #4]
 811538c:	8adb      	ldrh	r3, [r3, #22]
 811538e:	847b      	strh	r3, [r7, #34]	; 0x22
      TCP_PCB_REMOVE_ACTIVE(pcb);
 8115390:	6879      	ldr	r1, [r7, #4]
 8115392:	4828      	ldr	r0, [pc, #160]	; (8115434 <tcp_abandon+0x174>)
 8115394:	f000 ff7a 	bl	811628c <tcp_pcb_remove>
 8115398:	4b27      	ldr	r3, [pc, #156]	; (8115438 <tcp_abandon+0x178>)
 811539a:	2201      	movs	r2, #1
 811539c:	701a      	strb	r2, [r3, #0]
    }
    if (pcb->unacked != NULL) {
 811539e:	687b      	ldr	r3, [r7, #4]
 81153a0:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 81153a2:	2b00      	cmp	r3, #0
 81153a4:	d004      	beq.n	81153b0 <tcp_abandon+0xf0>
      tcp_segs_free(pcb->unacked);
 81153a6:	687b      	ldr	r3, [r7, #4]
 81153a8:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 81153aa:	4618      	mov	r0, r3
 81153ac:	f000 fd1c 	bl	8115de8 <tcp_segs_free>
    }
    if (pcb->unsent != NULL) {
 81153b0:	687b      	ldr	r3, [r7, #4]
 81153b2:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 81153b4:	2b00      	cmp	r3, #0
 81153b6:	d004      	beq.n	81153c2 <tcp_abandon+0x102>
      tcp_segs_free(pcb->unsent);
 81153b8:	687b      	ldr	r3, [r7, #4]
 81153ba:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 81153bc:	4618      	mov	r0, r3
 81153be:	f000 fd13 	bl	8115de8 <tcp_segs_free>
    }
#if TCP_QUEUE_OOSEQ
    if (pcb->ooseq != NULL) {
 81153c2:	687b      	ldr	r3, [r7, #4]
 81153c4:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 81153c6:	2b00      	cmp	r3, #0
 81153c8:	d004      	beq.n	81153d4 <tcp_abandon+0x114>
      tcp_segs_free(pcb->ooseq);
 81153ca:	687b      	ldr	r3, [r7, #4]
 81153cc:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 81153ce:	4618      	mov	r0, r3
 81153d0:	f000 fd0a 	bl	8115de8 <tcp_segs_free>
    }
#endif /* TCP_QUEUE_OOSEQ */
    tcp_backlog_accepted(pcb);
    if (send_rst) {
 81153d4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 81153d6:	2b00      	cmp	r3, #0
 81153d8:	d00e      	beq.n	81153f8 <tcp_abandon+0x138>
      LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_abandon: sending RST\n"));
      tcp_rst(pcb, seqno, ackno, &pcb->local_ip, &pcb->remote_ip, local_port, pcb->remote_port);
 81153da:	6879      	ldr	r1, [r7, #4]
 81153dc:	687b      	ldr	r3, [r7, #4]
 81153de:	3304      	adds	r3, #4
 81153e0:	687a      	ldr	r2, [r7, #4]
 81153e2:	8b12      	ldrh	r2, [r2, #24]
 81153e4:	9202      	str	r2, [sp, #8]
 81153e6:	8c7a      	ldrh	r2, [r7, #34]	; 0x22
 81153e8:	9201      	str	r2, [sp, #4]
 81153ea:	9300      	str	r3, [sp, #0]
 81153ec:	460b      	mov	r3, r1
 81153ee:	697a      	ldr	r2, [r7, #20]
 81153f0:	69b9      	ldr	r1, [r7, #24]
 81153f2:	6878      	ldr	r0, [r7, #4]
 81153f4:	f004 fcc2 	bl	8119d7c <tcp_rst>
    }
    last_state = pcb->state;
 81153f8:	687b      	ldr	r3, [r7, #4]
 81153fa:	7d1b      	ldrb	r3, [r3, #20]
 81153fc:	72fb      	strb	r3, [r7, #11]
    tcp_free(pcb);
 81153fe:	6878      	ldr	r0, [r7, #4]
 8115400:	f7ff fd34 	bl	8114e6c <tcp_free>
    TCP_EVENT_ERR(last_state, errf, errf_arg, ERR_ABRT);
 8115404:	693b      	ldr	r3, [r7, #16]
 8115406:	2b00      	cmp	r3, #0
 8115408:	d004      	beq.n	8115414 <tcp_abandon+0x154>
 811540a:	693b      	ldr	r3, [r7, #16]
 811540c:	f06f 010c 	mvn.w	r1, #12
 8115410:	68f8      	ldr	r0, [r7, #12]
 8115412:	4798      	blx	r3
  }
}
 8115414:	3728      	adds	r7, #40	; 0x28
 8115416:	46bd      	mov	sp, r7
 8115418:	bd80      	pop	{r7, pc}
 811541a:	bf00      	nop
 811541c:	0811df48 	.word	0x0811df48
 8115420:	0811e0c0 	.word	0x0811e0c0
 8115424:	0811dfc0 	.word	0x0811dfc0
 8115428:	0811e0dc 	.word	0x0811e0dc
 811542c:	10008458 	.word	0x10008458
 8115430:	1000844c 	.word	0x1000844c
 8115434:	10008454 	.word	0x10008454
 8115438:	1000845c 	.word	0x1000845c

0811543c <tcp_abort>:
 *
 * @param pcb the tcp pcb to abort
 */
void
tcp_abort(struct tcp_pcb *pcb)
{
 811543c:	b580      	push	{r7, lr}
 811543e:	b082      	sub	sp, #8
 8115440:	af00      	add	r7, sp, #0
 8115442:	6078      	str	r0, [r7, #4]
  tcp_abandon(pcb, 1);
 8115444:	2101      	movs	r1, #1
 8115446:	6878      	ldr	r0, [r7, #4]
 8115448:	f7ff ff3a 	bl	81152c0 <tcp_abandon>
}
 811544c:	bf00      	nop
 811544e:	3708      	adds	r7, #8
 8115450:	46bd      	mov	sp, r7
 8115452:	bd80      	pop	{r7, pc}

08115454 <tcp_update_rcv_ann_wnd>:
 * Returns how much extra window would be advertised if we sent an
 * update now.
 */
u32_t
tcp_update_rcv_ann_wnd(struct tcp_pcb *pcb)
{
 8115454:	b580      	push	{r7, lr}
 8115456:	b084      	sub	sp, #16
 8115458:	af00      	add	r7, sp, #0
 811545a:	6078      	str	r0, [r7, #4]
  u32_t new_right_edge;

  LWIP_ASSERT("tcp_update_rcv_ann_wnd: invalid pcb", pcb != NULL);
 811545c:	687b      	ldr	r3, [r7, #4]
 811545e:	2b00      	cmp	r3, #0
 8115460:	d106      	bne.n	8115470 <tcp_update_rcv_ann_wnd+0x1c>
 8115462:	4b25      	ldr	r3, [pc, #148]	; (81154f8 <tcp_update_rcv_ann_wnd+0xa4>)
 8115464:	f240 32a6 	movw	r2, #934	; 0x3a6
 8115468:	4924      	ldr	r1, [pc, #144]	; (81154fc <tcp_update_rcv_ann_wnd+0xa8>)
 811546a:	4825      	ldr	r0, [pc, #148]	; (8115500 <tcp_update_rcv_ann_wnd+0xac>)
 811546c:	f006 f9c8 	bl	811b800 <iprintf>
  new_right_edge = pcb->rcv_nxt + pcb->rcv_wnd;
 8115470:	687b      	ldr	r3, [r7, #4]
 8115472:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8115474:	687a      	ldr	r2, [r7, #4]
 8115476:	8d12      	ldrh	r2, [r2, #40]	; 0x28
 8115478:	4413      	add	r3, r2
 811547a:	60fb      	str	r3, [r7, #12]

  if (TCP_SEQ_GEQ(new_right_edge, pcb->rcv_ann_right_edge + LWIP_MIN((TCP_WND / 2), pcb->mss))) {
 811547c:	687b      	ldr	r3, [r7, #4]
 811547e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8115480:	687a      	ldr	r2, [r7, #4]
 8115482:	8e52      	ldrh	r2, [r2, #50]	; 0x32
 8115484:	f5b2 6f86 	cmp.w	r2, #1072	; 0x430
 8115488:	bf28      	it	cs
 811548a:	f44f 6286 	movcs.w	r2, #1072	; 0x430
 811548e:	b292      	uxth	r2, r2
 8115490:	4413      	add	r3, r2
 8115492:	68fa      	ldr	r2, [r7, #12]
 8115494:	1ad3      	subs	r3, r2, r3
 8115496:	2b00      	cmp	r3, #0
 8115498:	db08      	blt.n	81154ac <tcp_update_rcv_ann_wnd+0x58>
    /* we can advertise more window */
    pcb->rcv_ann_wnd = pcb->rcv_wnd;
 811549a:	687b      	ldr	r3, [r7, #4]
 811549c:	8d1a      	ldrh	r2, [r3, #40]	; 0x28
 811549e:	687b      	ldr	r3, [r7, #4]
 81154a0:	855a      	strh	r2, [r3, #42]	; 0x2a
    return new_right_edge - pcb->rcv_ann_right_edge;
 81154a2:	687b      	ldr	r3, [r7, #4]
 81154a4:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 81154a6:	68fa      	ldr	r2, [r7, #12]
 81154a8:	1ad3      	subs	r3, r2, r3
 81154aa:	e020      	b.n	81154ee <tcp_update_rcv_ann_wnd+0x9a>
  } else {
    if (TCP_SEQ_GT(pcb->rcv_nxt, pcb->rcv_ann_right_edge)) {
 81154ac:	687b      	ldr	r3, [r7, #4]
 81154ae:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 81154b0:	687b      	ldr	r3, [r7, #4]
 81154b2:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 81154b4:	1ad3      	subs	r3, r2, r3
 81154b6:	2b00      	cmp	r3, #0
 81154b8:	dd03      	ble.n	81154c2 <tcp_update_rcv_ann_wnd+0x6e>
      /* Can happen due to other end sending out of advertised window,
       * but within actual available (but not yet advertised) window */
      pcb->rcv_ann_wnd = 0;
 81154ba:	687b      	ldr	r3, [r7, #4]
 81154bc:	2200      	movs	r2, #0
 81154be:	855a      	strh	r2, [r3, #42]	; 0x2a
 81154c0:	e014      	b.n	81154ec <tcp_update_rcv_ann_wnd+0x98>
    } else {
      /* keep the right edge of window constant */
      u32_t new_rcv_ann_wnd = pcb->rcv_ann_right_edge - pcb->rcv_nxt;
 81154c2:	687b      	ldr	r3, [r7, #4]
 81154c4:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 81154c6:	687b      	ldr	r3, [r7, #4]
 81154c8:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 81154ca:	1ad3      	subs	r3, r2, r3
 81154cc:	60bb      	str	r3, [r7, #8]
#if !LWIP_WND_SCALE
      LWIP_ASSERT("new_rcv_ann_wnd <= 0xffff", new_rcv_ann_wnd <= 0xffff);
 81154ce:	68bb      	ldr	r3, [r7, #8]
 81154d0:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 81154d4:	d306      	bcc.n	81154e4 <tcp_update_rcv_ann_wnd+0x90>
 81154d6:	4b08      	ldr	r3, [pc, #32]	; (81154f8 <tcp_update_rcv_ann_wnd+0xa4>)
 81154d8:	f240 32b6 	movw	r2, #950	; 0x3b6
 81154dc:	4909      	ldr	r1, [pc, #36]	; (8115504 <tcp_update_rcv_ann_wnd+0xb0>)
 81154de:	4808      	ldr	r0, [pc, #32]	; (8115500 <tcp_update_rcv_ann_wnd+0xac>)
 81154e0:	f006 f98e 	bl	811b800 <iprintf>
#endif
      pcb->rcv_ann_wnd = (tcpwnd_size_t)new_rcv_ann_wnd;
 81154e4:	68bb      	ldr	r3, [r7, #8]
 81154e6:	b29a      	uxth	r2, r3
 81154e8:	687b      	ldr	r3, [r7, #4]
 81154ea:	855a      	strh	r2, [r3, #42]	; 0x2a
    }
    return 0;
 81154ec:	2300      	movs	r3, #0
  }
}
 81154ee:	4618      	mov	r0, r3
 81154f0:	3710      	adds	r7, #16
 81154f2:	46bd      	mov	sp, r7
 81154f4:	bd80      	pop	{r7, pc}
 81154f6:	bf00      	nop
 81154f8:	0811df48 	.word	0x0811df48
 81154fc:	0811e1d8 	.word	0x0811e1d8
 8115500:	0811dfc0 	.word	0x0811dfc0
 8115504:	0811e1fc 	.word	0x0811e1fc

08115508 <tcp_recved>:
 * @param pcb the tcp_pcb for which data is read
 * @param len the amount of bytes that have been read by the application
 */
void
tcp_recved(struct tcp_pcb *pcb, u16_t len)
{
 8115508:	b580      	push	{r7, lr}
 811550a:	b084      	sub	sp, #16
 811550c:	af00      	add	r7, sp, #0
 811550e:	6078      	str	r0, [r7, #4]
 8115510:	460b      	mov	r3, r1
 8115512:	807b      	strh	r3, [r7, #2]
  u32_t wnd_inflation;
  tcpwnd_size_t rcv_wnd;

  LWIP_ASSERT_CORE_LOCKED();

  LWIP_ERROR("tcp_recved: invalid pcb", pcb != NULL, return);
 8115514:	687b      	ldr	r3, [r7, #4]
 8115516:	2b00      	cmp	r3, #0
 8115518:	d107      	bne.n	811552a <tcp_recved+0x22>
 811551a:	4b1f      	ldr	r3, [pc, #124]	; (8115598 <tcp_recved+0x90>)
 811551c:	f240 32cf 	movw	r2, #975	; 0x3cf
 8115520:	491e      	ldr	r1, [pc, #120]	; (811559c <tcp_recved+0x94>)
 8115522:	481f      	ldr	r0, [pc, #124]	; (81155a0 <tcp_recved+0x98>)
 8115524:	f006 f96c 	bl	811b800 <iprintf>
 8115528:	e032      	b.n	8115590 <tcp_recved+0x88>

  /* pcb->state LISTEN not allowed here */
  LWIP_ASSERT("don't call tcp_recved for listen-pcbs",
 811552a:	687b      	ldr	r3, [r7, #4]
 811552c:	7d1b      	ldrb	r3, [r3, #20]
 811552e:	2b01      	cmp	r3, #1
 8115530:	d106      	bne.n	8115540 <tcp_recved+0x38>
 8115532:	4b19      	ldr	r3, [pc, #100]	; (8115598 <tcp_recved+0x90>)
 8115534:	f240 32d2 	movw	r2, #978	; 0x3d2
 8115538:	491a      	ldr	r1, [pc, #104]	; (81155a4 <tcp_recved+0x9c>)
 811553a:	4819      	ldr	r0, [pc, #100]	; (81155a0 <tcp_recved+0x98>)
 811553c:	f006 f960 	bl	811b800 <iprintf>
              pcb->state != LISTEN);

  rcv_wnd = (tcpwnd_size_t)(pcb->rcv_wnd + len);
 8115540:	687b      	ldr	r3, [r7, #4]
 8115542:	8d1a      	ldrh	r2, [r3, #40]	; 0x28
 8115544:	887b      	ldrh	r3, [r7, #2]
 8115546:	4413      	add	r3, r2
 8115548:	81fb      	strh	r3, [r7, #14]
  if ((rcv_wnd > TCP_WND_MAX(pcb)) || (rcv_wnd < pcb->rcv_wnd)) {
 811554a:	89fb      	ldrh	r3, [r7, #14]
 811554c:	f5b3 6f06 	cmp.w	r3, #2144	; 0x860
 8115550:	d804      	bhi.n	811555c <tcp_recved+0x54>
 8115552:	687b      	ldr	r3, [r7, #4]
 8115554:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
 8115556:	89fa      	ldrh	r2, [r7, #14]
 8115558:	429a      	cmp	r2, r3
 811555a:	d204      	bcs.n	8115566 <tcp_recved+0x5e>
    /* window got too big or tcpwnd_size_t overflow */
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_recved: window got too big or tcpwnd_size_t overflow\n"));
    pcb->rcv_wnd = TCP_WND_MAX(pcb);
 811555c:	687b      	ldr	r3, [r7, #4]
 811555e:	f44f 6206 	mov.w	r2, #2144	; 0x860
 8115562:	851a      	strh	r2, [r3, #40]	; 0x28
 8115564:	e002      	b.n	811556c <tcp_recved+0x64>
  } else  {
    pcb->rcv_wnd = rcv_wnd;
 8115566:	687b      	ldr	r3, [r7, #4]
 8115568:	89fa      	ldrh	r2, [r7, #14]
 811556a:	851a      	strh	r2, [r3, #40]	; 0x28
  }

  wnd_inflation = tcp_update_rcv_ann_wnd(pcb);
 811556c:	6878      	ldr	r0, [r7, #4]
 811556e:	f7ff ff71 	bl	8115454 <tcp_update_rcv_ann_wnd>
 8115572:	60b8      	str	r0, [r7, #8]

  /* If the change in the right edge of window is significant (default
   * watermark is TCP_WND/4), then send an explicit update now.
   * Otherwise wait for a packet to be sent in the normal course of
   * events (or more window to be available later) */
  if (wnd_inflation >= TCP_WND_UPDATE_THRESHOLD) {
 8115574:	68bb      	ldr	r3, [r7, #8]
 8115576:	f5b3 7f06 	cmp.w	r3, #536	; 0x218
 811557a:	d309      	bcc.n	8115590 <tcp_recved+0x88>
    tcp_ack_now(pcb);
 811557c:	687b      	ldr	r3, [r7, #4]
 811557e:	8b5b      	ldrh	r3, [r3, #26]
 8115580:	f043 0302 	orr.w	r3, r3, #2
 8115584:	b29a      	uxth	r2, r3
 8115586:	687b      	ldr	r3, [r7, #4]
 8115588:	835a      	strh	r2, [r3, #26]
    tcp_output(pcb);
 811558a:	6878      	ldr	r0, [r7, #4]
 811558c:	f003 fe42 	bl	8119214 <tcp_output>
  }

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_recved: received %"U16_F" bytes, wnd %"TCPWNDSIZE_F" (%"TCPWNDSIZE_F").\n",
                          len, pcb->rcv_wnd, (u16_t)(TCP_WND_MAX(pcb) - pcb->rcv_wnd)));
}
 8115590:	3710      	adds	r7, #16
 8115592:	46bd      	mov	sp, r7
 8115594:	bd80      	pop	{r7, pc}
 8115596:	bf00      	nop
 8115598:	0811df48 	.word	0x0811df48
 811559c:	0811e218 	.word	0x0811e218
 81155a0:	0811dfc0 	.word	0x0811dfc0
 81155a4:	0811e230 	.word	0x0811e230

081155a8 <tcp_slowtmr>:
 *
 * Automatically called from tcp_tmr().
 */
void
tcp_slowtmr(void)
{
 81155a8:	b5b0      	push	{r4, r5, r7, lr}
 81155aa:	b090      	sub	sp, #64	; 0x40
 81155ac:	af04      	add	r7, sp, #16
  tcpwnd_size_t eff_wnd;
  u8_t pcb_remove;      /* flag if a PCB should be removed */
  u8_t pcb_reset;       /* flag if a RST should be sent when removing */
  err_t err;

  err = ERR_OK;
 81155ae:	2300      	movs	r3, #0
 81155b0:	f887 3025 	strb.w	r3, [r7, #37]	; 0x25

  ++tcp_ticks;
 81155b4:	4b94      	ldr	r3, [pc, #592]	; (8115808 <tcp_slowtmr+0x260>)
 81155b6:	681b      	ldr	r3, [r3, #0]
 81155b8:	3301      	adds	r3, #1
 81155ba:	4a93      	ldr	r2, [pc, #588]	; (8115808 <tcp_slowtmr+0x260>)
 81155bc:	6013      	str	r3, [r2, #0]
  ++tcp_timer_ctr;
 81155be:	4b93      	ldr	r3, [pc, #588]	; (811580c <tcp_slowtmr+0x264>)
 81155c0:	781b      	ldrb	r3, [r3, #0]
 81155c2:	3301      	adds	r3, #1
 81155c4:	b2da      	uxtb	r2, r3
 81155c6:	4b91      	ldr	r3, [pc, #580]	; (811580c <tcp_slowtmr+0x264>)
 81155c8:	701a      	strb	r2, [r3, #0]

tcp_slowtmr_start:
  /* Steps through all of the active PCBs. */
  prev = NULL;
 81155ca:	2300      	movs	r3, #0
 81155cc:	62bb      	str	r3, [r7, #40]	; 0x28
  pcb = tcp_active_pcbs;
 81155ce:	4b90      	ldr	r3, [pc, #576]	; (8115810 <tcp_slowtmr+0x268>)
 81155d0:	681b      	ldr	r3, [r3, #0]
 81155d2:	62fb      	str	r3, [r7, #44]	; 0x2c
  if (pcb == NULL) {
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: no active pcbs\n"));
  }
  while (pcb != NULL) {
 81155d4:	e29f      	b.n	8115b16 <tcp_slowtmr+0x56e>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: processing active pcb\n"));
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != CLOSED\n", pcb->state != CLOSED);
 81155d6:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 81155d8:	7d1b      	ldrb	r3, [r3, #20]
 81155da:	2b00      	cmp	r3, #0
 81155dc:	d106      	bne.n	81155ec <tcp_slowtmr+0x44>
 81155de:	4b8d      	ldr	r3, [pc, #564]	; (8115814 <tcp_slowtmr+0x26c>)
 81155e0:	f240 42be 	movw	r2, #1214	; 0x4be
 81155e4:	498c      	ldr	r1, [pc, #560]	; (8115818 <tcp_slowtmr+0x270>)
 81155e6:	488d      	ldr	r0, [pc, #564]	; (811581c <tcp_slowtmr+0x274>)
 81155e8:	f006 f90a 	bl	811b800 <iprintf>
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != LISTEN\n", pcb->state != LISTEN);
 81155ec:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 81155ee:	7d1b      	ldrb	r3, [r3, #20]
 81155f0:	2b01      	cmp	r3, #1
 81155f2:	d106      	bne.n	8115602 <tcp_slowtmr+0x5a>
 81155f4:	4b87      	ldr	r3, [pc, #540]	; (8115814 <tcp_slowtmr+0x26c>)
 81155f6:	f240 42bf 	movw	r2, #1215	; 0x4bf
 81155fa:	4989      	ldr	r1, [pc, #548]	; (8115820 <tcp_slowtmr+0x278>)
 81155fc:	4887      	ldr	r0, [pc, #540]	; (811581c <tcp_slowtmr+0x274>)
 81155fe:	f006 f8ff 	bl	811b800 <iprintf>
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != TIME-WAIT\n", pcb->state != TIME_WAIT);
 8115602:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8115604:	7d1b      	ldrb	r3, [r3, #20]
 8115606:	2b0a      	cmp	r3, #10
 8115608:	d106      	bne.n	8115618 <tcp_slowtmr+0x70>
 811560a:	4b82      	ldr	r3, [pc, #520]	; (8115814 <tcp_slowtmr+0x26c>)
 811560c:	f44f 6298 	mov.w	r2, #1216	; 0x4c0
 8115610:	4984      	ldr	r1, [pc, #528]	; (8115824 <tcp_slowtmr+0x27c>)
 8115612:	4882      	ldr	r0, [pc, #520]	; (811581c <tcp_slowtmr+0x274>)
 8115614:	f006 f8f4 	bl	811b800 <iprintf>
    if (pcb->last_timer == tcp_timer_ctr) {
 8115618:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 811561a:	7f9a      	ldrb	r2, [r3, #30]
 811561c:	4b7b      	ldr	r3, [pc, #492]	; (811580c <tcp_slowtmr+0x264>)
 811561e:	781b      	ldrb	r3, [r3, #0]
 8115620:	429a      	cmp	r2, r3
 8115622:	d105      	bne.n	8115630 <tcp_slowtmr+0x88>
      /* skip this pcb, we have already processed it */
      prev = pcb;
 8115624:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8115626:	62bb      	str	r3, [r7, #40]	; 0x28
      pcb = pcb->next;
 8115628:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 811562a:	68db      	ldr	r3, [r3, #12]
 811562c:	62fb      	str	r3, [r7, #44]	; 0x2c
      continue;
 811562e:	e272      	b.n	8115b16 <tcp_slowtmr+0x56e>
    }
    pcb->last_timer = tcp_timer_ctr;
 8115630:	4b76      	ldr	r3, [pc, #472]	; (811580c <tcp_slowtmr+0x264>)
 8115632:	781a      	ldrb	r2, [r3, #0]
 8115634:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8115636:	779a      	strb	r2, [r3, #30]

    pcb_remove = 0;
 8115638:	2300      	movs	r3, #0
 811563a:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
    pcb_reset = 0;
 811563e:	2300      	movs	r3, #0
 8115640:	f887 3026 	strb.w	r3, [r7, #38]	; 0x26

    if (pcb->state == SYN_SENT && pcb->nrtx >= TCP_SYNMAXRTX) {
 8115644:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8115646:	7d1b      	ldrb	r3, [r3, #20]
 8115648:	2b02      	cmp	r3, #2
 811564a:	d10a      	bne.n	8115662 <tcp_slowtmr+0xba>
 811564c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 811564e:	f893 3042 	ldrb.w	r3, [r3, #66]	; 0x42
 8115652:	2b05      	cmp	r3, #5
 8115654:	d905      	bls.n	8115662 <tcp_slowtmr+0xba>
      ++pcb_remove;
 8115656:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 811565a:	3301      	adds	r3, #1
 811565c:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
 8115660:	e11e      	b.n	81158a0 <tcp_slowtmr+0x2f8>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: max SYN retries reached\n"));
    } else if (pcb->nrtx >= TCP_MAXRTX) {
 8115662:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8115664:	f893 3042 	ldrb.w	r3, [r3, #66]	; 0x42
 8115668:	2b0b      	cmp	r3, #11
 811566a:	d905      	bls.n	8115678 <tcp_slowtmr+0xd0>
      ++pcb_remove;
 811566c:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 8115670:	3301      	adds	r3, #1
 8115672:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
 8115676:	e113      	b.n	81158a0 <tcp_slowtmr+0x2f8>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: max DATA retries reached\n"));
    } else {
      if (pcb->persist_backoff > 0) {
 8115678:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 811567a:	f893 3099 	ldrb.w	r3, [r3, #153]	; 0x99
 811567e:	2b00      	cmp	r3, #0
 8115680:	d075      	beq.n	811576e <tcp_slowtmr+0x1c6>
        LWIP_ASSERT("tcp_slowtimr: persist ticking with in-flight data", pcb->unacked == NULL);
 8115682:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8115684:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8115686:	2b00      	cmp	r3, #0
 8115688:	d006      	beq.n	8115698 <tcp_slowtmr+0xf0>
 811568a:	4b62      	ldr	r3, [pc, #392]	; (8115814 <tcp_slowtmr+0x26c>)
 811568c:	f240 42d4 	movw	r2, #1236	; 0x4d4
 8115690:	4965      	ldr	r1, [pc, #404]	; (8115828 <tcp_slowtmr+0x280>)
 8115692:	4862      	ldr	r0, [pc, #392]	; (811581c <tcp_slowtmr+0x274>)
 8115694:	f006 f8b4 	bl	811b800 <iprintf>
        LWIP_ASSERT("tcp_slowtimr: persist ticking with empty send buffer", pcb->unsent != NULL);
 8115698:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 811569a:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 811569c:	2b00      	cmp	r3, #0
 811569e:	d106      	bne.n	81156ae <tcp_slowtmr+0x106>
 81156a0:	4b5c      	ldr	r3, [pc, #368]	; (8115814 <tcp_slowtmr+0x26c>)
 81156a2:	f240 42d5 	movw	r2, #1237	; 0x4d5
 81156a6:	4961      	ldr	r1, [pc, #388]	; (811582c <tcp_slowtmr+0x284>)
 81156a8:	485c      	ldr	r0, [pc, #368]	; (811581c <tcp_slowtmr+0x274>)
 81156aa:	f006 f8a9 	bl	811b800 <iprintf>
        if (pcb->persist_probe >= TCP_MAXRTX) {
 81156ae:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 81156b0:	f893 309a 	ldrb.w	r3, [r3, #154]	; 0x9a
 81156b4:	2b0b      	cmp	r3, #11
 81156b6:	d905      	bls.n	81156c4 <tcp_slowtmr+0x11c>
          ++pcb_remove; /* max probes reached */
 81156b8:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 81156bc:	3301      	adds	r3, #1
 81156be:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
 81156c2:	e0ed      	b.n	81158a0 <tcp_slowtmr+0x2f8>
        } else {
          u8_t backoff_cnt = tcp_persist_backoff[pcb->persist_backoff - 1];
 81156c4:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 81156c6:	f893 3099 	ldrb.w	r3, [r3, #153]	; 0x99
 81156ca:	3b01      	subs	r3, #1
 81156cc:	4a58      	ldr	r2, [pc, #352]	; (8115830 <tcp_slowtmr+0x288>)
 81156ce:	5cd3      	ldrb	r3, [r2, r3]
 81156d0:	747b      	strb	r3, [r7, #17]
          if (pcb->persist_cnt < backoff_cnt) {
 81156d2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 81156d4:	f893 3098 	ldrb.w	r3, [r3, #152]	; 0x98
 81156d8:	7c7a      	ldrb	r2, [r7, #17]
 81156da:	429a      	cmp	r2, r3
 81156dc:	d907      	bls.n	81156ee <tcp_slowtmr+0x146>
            pcb->persist_cnt++;
 81156de:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 81156e0:	f893 3098 	ldrb.w	r3, [r3, #152]	; 0x98
 81156e4:	3301      	adds	r3, #1
 81156e6:	b2da      	uxtb	r2, r3
 81156e8:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 81156ea:	f883 2098 	strb.w	r2, [r3, #152]	; 0x98
          }
          if (pcb->persist_cnt >= backoff_cnt) {
 81156ee:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 81156f0:	f893 3098 	ldrb.w	r3, [r3, #152]	; 0x98
 81156f4:	7c7a      	ldrb	r2, [r7, #17]
 81156f6:	429a      	cmp	r2, r3
 81156f8:	f200 80d2 	bhi.w	81158a0 <tcp_slowtmr+0x2f8>
            int next_slot = 1; /* increment timer to next slot */
 81156fc:	2301      	movs	r3, #1
 81156fe:	623b      	str	r3, [r7, #32]
            /* If snd_wnd is zero, send 1 byte probes */
            if (pcb->snd_wnd == 0) {
 8115700:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8115702:	f8b3 3060 	ldrh.w	r3, [r3, #96]	; 0x60
 8115706:	2b00      	cmp	r3, #0
 8115708:	d108      	bne.n	811571c <tcp_slowtmr+0x174>
              if (tcp_zero_window_probe(pcb) != ERR_OK) {
 811570a:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 811570c:	f004 fc2a 	bl	8119f64 <tcp_zero_window_probe>
 8115710:	4603      	mov	r3, r0
 8115712:	2b00      	cmp	r3, #0
 8115714:	d014      	beq.n	8115740 <tcp_slowtmr+0x198>
                next_slot = 0; /* try probe again with current slot */
 8115716:	2300      	movs	r3, #0
 8115718:	623b      	str	r3, [r7, #32]
 811571a:	e011      	b.n	8115740 <tcp_slowtmr+0x198>
              }
              /* snd_wnd not fully closed, split unsent head and fill window */
            } else {
              if (tcp_split_unsent_seg(pcb, (u16_t)pcb->snd_wnd) == ERR_OK) {
 811571c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 811571e:	f8b3 3060 	ldrh.w	r3, [r3, #96]	; 0x60
 8115722:	4619      	mov	r1, r3
 8115724:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 8115726:	f003 faef 	bl	8118d08 <tcp_split_unsent_seg>
 811572a:	4603      	mov	r3, r0
 811572c:	2b00      	cmp	r3, #0
 811572e:	d107      	bne.n	8115740 <tcp_slowtmr+0x198>
                if (tcp_output(pcb) == ERR_OK) {
 8115730:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 8115732:	f003 fd6f 	bl	8119214 <tcp_output>
 8115736:	4603      	mov	r3, r0
 8115738:	2b00      	cmp	r3, #0
 811573a:	d101      	bne.n	8115740 <tcp_slowtmr+0x198>
                  /* sending will cancel persist timer, else retry with current slot */
                  next_slot = 0;
 811573c:	2300      	movs	r3, #0
 811573e:	623b      	str	r3, [r7, #32]
                }
              }
            }
            if (next_slot) {
 8115740:	6a3b      	ldr	r3, [r7, #32]
 8115742:	2b00      	cmp	r3, #0
 8115744:	f000 80ac 	beq.w	81158a0 <tcp_slowtmr+0x2f8>
              pcb->persist_cnt = 0;
 8115748:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 811574a:	2200      	movs	r2, #0
 811574c:	f883 2098 	strb.w	r2, [r3, #152]	; 0x98
              if (pcb->persist_backoff < sizeof(tcp_persist_backoff)) {
 8115750:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8115752:	f893 3099 	ldrb.w	r3, [r3, #153]	; 0x99
 8115756:	2b06      	cmp	r3, #6
 8115758:	f200 80a2 	bhi.w	81158a0 <tcp_slowtmr+0x2f8>
                pcb->persist_backoff++;
 811575c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 811575e:	f893 3099 	ldrb.w	r3, [r3, #153]	; 0x99
 8115762:	3301      	adds	r3, #1
 8115764:	b2da      	uxtb	r2, r3
 8115766:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8115768:	f883 2099 	strb.w	r2, [r3, #153]	; 0x99
 811576c:	e098      	b.n	81158a0 <tcp_slowtmr+0x2f8>
            }
          }
        }
      } else {
        /* Increase the retransmission timer if it is running */
        if ((pcb->rtime >= 0) && (pcb->rtime < 0x7FFF)) {
 811576e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8115770:	f9b3 3030 	ldrsh.w	r3, [r3, #48]	; 0x30
 8115774:	2b00      	cmp	r3, #0
 8115776:	db0f      	blt.n	8115798 <tcp_slowtmr+0x1f0>
 8115778:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 811577a:	f9b3 3030 	ldrsh.w	r3, [r3, #48]	; 0x30
 811577e:	f647 72ff 	movw	r2, #32767	; 0x7fff
 8115782:	4293      	cmp	r3, r2
 8115784:	d008      	beq.n	8115798 <tcp_slowtmr+0x1f0>
          ++pcb->rtime;
 8115786:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8115788:	f9b3 3030 	ldrsh.w	r3, [r3, #48]	; 0x30
 811578c:	b29b      	uxth	r3, r3
 811578e:	3301      	adds	r3, #1
 8115790:	b29b      	uxth	r3, r3
 8115792:	b21a      	sxth	r2, r3
 8115794:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8115796:	861a      	strh	r2, [r3, #48]	; 0x30
        }

        if (pcb->rtime >= pcb->rto) {
 8115798:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 811579a:	f9b3 2030 	ldrsh.w	r2, [r3, #48]	; 0x30
 811579e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 81157a0:	f9b3 3040 	ldrsh.w	r3, [r3, #64]	; 0x40
 81157a4:	429a      	cmp	r2, r3
 81157a6:	db7b      	blt.n	81158a0 <tcp_slowtmr+0x2f8>
                                      " pcb->rto %"S16_F"\n",
                                      pcb->rtime, pcb->rto));
          /* If prepare phase fails but we have unsent data but no unacked data,
             still execute the backoff calculations below, as this means we somehow
             failed to send segment. */
          if ((tcp_rexmit_rto_prepare(pcb) == ERR_OK) || ((pcb->unacked == NULL) && (pcb->unsent != NULL))) {
 81157a8:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 81157aa:	f004 f827 	bl	81197fc <tcp_rexmit_rto_prepare>
 81157ae:	4603      	mov	r3, r0
 81157b0:	2b00      	cmp	r3, #0
 81157b2:	d007      	beq.n	81157c4 <tcp_slowtmr+0x21c>
 81157b4:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 81157b6:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 81157b8:	2b00      	cmp	r3, #0
 81157ba:	d171      	bne.n	81158a0 <tcp_slowtmr+0x2f8>
 81157bc:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 81157be:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 81157c0:	2b00      	cmp	r3, #0
 81157c2:	d06d      	beq.n	81158a0 <tcp_slowtmr+0x2f8>
            /* Double retransmission time-out unless we are trying to
             * connect to somebody (i.e., we are in SYN_SENT). */
            if (pcb->state != SYN_SENT) {
 81157c4:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 81157c6:	7d1b      	ldrb	r3, [r3, #20]
 81157c8:	2b02      	cmp	r3, #2
 81157ca:	d03a      	beq.n	8115842 <tcp_slowtmr+0x29a>
              u8_t backoff_idx = LWIP_MIN(pcb->nrtx, sizeof(tcp_backoff) - 1);
 81157cc:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 81157ce:	f893 3042 	ldrb.w	r3, [r3, #66]	; 0x42
 81157d2:	2b0c      	cmp	r3, #12
 81157d4:	bf28      	it	cs
 81157d6:	230c      	movcs	r3, #12
 81157d8:	76fb      	strb	r3, [r7, #27]
              int calc_rto = ((pcb->sa >> 3) + pcb->sv) << tcp_backoff[backoff_idx];
 81157da:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 81157dc:	f9b3 303c 	ldrsh.w	r3, [r3, #60]	; 0x3c
 81157e0:	10db      	asrs	r3, r3, #3
 81157e2:	b21b      	sxth	r3, r3
 81157e4:	461a      	mov	r2, r3
 81157e6:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 81157e8:	f9b3 303e 	ldrsh.w	r3, [r3, #62]	; 0x3e
 81157ec:	4413      	add	r3, r2
 81157ee:	7efa      	ldrb	r2, [r7, #27]
 81157f0:	4910      	ldr	r1, [pc, #64]	; (8115834 <tcp_slowtmr+0x28c>)
 81157f2:	5c8a      	ldrb	r2, [r1, r2]
 81157f4:	4093      	lsls	r3, r2
 81157f6:	617b      	str	r3, [r7, #20]
              pcb->rto = (s16_t)LWIP_MIN(calc_rto, 0x7FFF);
 81157f8:	697b      	ldr	r3, [r7, #20]
 81157fa:	f647 72fe 	movw	r2, #32766	; 0x7ffe
 81157fe:	4293      	cmp	r3, r2
 8115800:	dc1a      	bgt.n	8115838 <tcp_slowtmr+0x290>
 8115802:	697b      	ldr	r3, [r7, #20]
 8115804:	b21a      	sxth	r2, r3
 8115806:	e019      	b.n	811583c <tcp_slowtmr+0x294>
 8115808:	10008448 	.word	0x10008448
 811580c:	1000845e 	.word	0x1000845e
 8115810:	10008454 	.word	0x10008454
 8115814:	0811df48 	.word	0x0811df48
 8115818:	0811e2c0 	.word	0x0811e2c0
 811581c:	0811dfc0 	.word	0x0811dfc0
 8115820:	0811e2ec 	.word	0x0811e2ec
 8115824:	0811e318 	.word	0x0811e318
 8115828:	0811e348 	.word	0x0811e348
 811582c:	0811e37c 	.word	0x0811e37c
 8115830:	0811f9dc 	.word	0x0811f9dc
 8115834:	0811f9cc 	.word	0x0811f9cc
 8115838:	f647 72ff 	movw	r2, #32767	; 0x7fff
 811583c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 811583e:	f8a3 2040 	strh.w	r2, [r3, #64]	; 0x40
            }

            /* Reset the retransmission timer. */
            pcb->rtime = 0;
 8115842:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8115844:	2200      	movs	r2, #0
 8115846:	861a      	strh	r2, [r3, #48]	; 0x30

            /* Reduce congestion window and ssthresh. */
            eff_wnd = LWIP_MIN(pcb->cwnd, pcb->snd_wnd);
 8115848:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 811584a:	f8b3 2060 	ldrh.w	r2, [r3, #96]	; 0x60
 811584e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8115850:	f8b3 3048 	ldrh.w	r3, [r3, #72]	; 0x48
 8115854:	4293      	cmp	r3, r2
 8115856:	bf28      	it	cs
 8115858:	4613      	movcs	r3, r2
 811585a:	827b      	strh	r3, [r7, #18]
            pcb->ssthresh = eff_wnd >> 1;
 811585c:	8a7b      	ldrh	r3, [r7, #18]
 811585e:	085b      	lsrs	r3, r3, #1
 8115860:	b29a      	uxth	r2, r3
 8115862:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8115864:	f8a3 204a 	strh.w	r2, [r3, #74]	; 0x4a
            if (pcb->ssthresh < (tcpwnd_size_t)(pcb->mss << 1)) {
 8115868:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 811586a:	f8b3 204a 	ldrh.w	r2, [r3, #74]	; 0x4a
 811586e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8115870:	8e5b      	ldrh	r3, [r3, #50]	; 0x32
 8115872:	005b      	lsls	r3, r3, #1
 8115874:	b29b      	uxth	r3, r3
 8115876:	429a      	cmp	r2, r3
 8115878:	d206      	bcs.n	8115888 <tcp_slowtmr+0x2e0>
              pcb->ssthresh = (tcpwnd_size_t)(pcb->mss << 1);
 811587a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 811587c:	8e5b      	ldrh	r3, [r3, #50]	; 0x32
 811587e:	005b      	lsls	r3, r3, #1
 8115880:	b29a      	uxth	r2, r3
 8115882:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8115884:	f8a3 204a 	strh.w	r2, [r3, #74]	; 0x4a
            }
            pcb->cwnd = pcb->mss;
 8115888:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 811588a:	8e5a      	ldrh	r2, [r3, #50]	; 0x32
 811588c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 811588e:	f8a3 2048 	strh.w	r2, [r3, #72]	; 0x48
            LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_slowtmr: cwnd %"TCPWNDSIZE_F
                                         " ssthresh %"TCPWNDSIZE_F"\n",
                                         pcb->cwnd, pcb->ssthresh));
            pcb->bytes_acked = 0;
 8115892:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8115894:	2200      	movs	r2, #0
 8115896:	f8a3 206a 	strh.w	r2, [r3, #106]	; 0x6a

            /* The following needs to be called AFTER cwnd is set to one
               mss - STJ */
            tcp_rexmit_rto_commit(pcb);
 811589a:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 811589c:	f004 f81e 	bl	81198dc <tcp_rexmit_rto_commit>
          }
        }
      }
    }
    /* Check if this PCB has stayed too long in FIN-WAIT-2 */
    if (pcb->state == FIN_WAIT_2) {
 81158a0:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 81158a2:	7d1b      	ldrb	r3, [r3, #20]
 81158a4:	2b06      	cmp	r3, #6
 81158a6:	d111      	bne.n	81158cc <tcp_slowtmr+0x324>
      /* If this PCB is in FIN_WAIT_2 because of SHUT_WR don't let it time out. */
      if (pcb->flags & TF_RXCLOSED) {
 81158a8:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 81158aa:	8b5b      	ldrh	r3, [r3, #26]
 81158ac:	f003 0310 	and.w	r3, r3, #16
 81158b0:	2b00      	cmp	r3, #0
 81158b2:	d00b      	beq.n	81158cc <tcp_slowtmr+0x324>
        /* PCB was fully closed (either through close() or SHUT_RDWR):
           normal FIN-WAIT timeout handling. */
        if ((u32_t)(tcp_ticks - pcb->tmr) >
 81158b4:	4b9d      	ldr	r3, [pc, #628]	; (8115b2c <tcp_slowtmr+0x584>)
 81158b6:	681a      	ldr	r2, [r3, #0]
 81158b8:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 81158ba:	6a1b      	ldr	r3, [r3, #32]
 81158bc:	1ad3      	subs	r3, r2, r3
 81158be:	2b28      	cmp	r3, #40	; 0x28
 81158c0:	d904      	bls.n	81158cc <tcp_slowtmr+0x324>
            TCP_FIN_WAIT_TIMEOUT / TCP_SLOW_INTERVAL) {
          ++pcb_remove;
 81158c2:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 81158c6:	3301      	adds	r3, #1
 81158c8:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
        }
      }
    }

    /* Check if KEEPALIVE should be sent */
    if (ip_get_option(pcb, SOF_KEEPALIVE) &&
 81158cc:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 81158ce:	7a5b      	ldrb	r3, [r3, #9]
 81158d0:	f003 0308 	and.w	r3, r3, #8
 81158d4:	2b00      	cmp	r3, #0
 81158d6:	d04c      	beq.n	8115972 <tcp_slowtmr+0x3ca>
        ((pcb->state == ESTABLISHED) ||
 81158d8:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 81158da:	7d1b      	ldrb	r3, [r3, #20]
    if (ip_get_option(pcb, SOF_KEEPALIVE) &&
 81158dc:	2b04      	cmp	r3, #4
 81158de:	d003      	beq.n	81158e8 <tcp_slowtmr+0x340>
         (pcb->state == CLOSE_WAIT))) {
 81158e0:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 81158e2:	7d1b      	ldrb	r3, [r3, #20]
        ((pcb->state == ESTABLISHED) ||
 81158e4:	2b07      	cmp	r3, #7
 81158e6:	d144      	bne.n	8115972 <tcp_slowtmr+0x3ca>
      if ((u32_t)(tcp_ticks - pcb->tmr) >
 81158e8:	4b90      	ldr	r3, [pc, #576]	; (8115b2c <tcp_slowtmr+0x584>)
 81158ea:	681a      	ldr	r2, [r3, #0]
 81158ec:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 81158ee:	6a1b      	ldr	r3, [r3, #32]
 81158f0:	1ad2      	subs	r2, r2, r3
          (pcb->keep_idle + TCP_KEEP_DUR(pcb)) / TCP_SLOW_INTERVAL) {
 81158f2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 81158f4:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 81158f8:	f503 2324 	add.w	r3, r3, #671744	; 0xa4000
 81158fc:	f603 43b8 	addw	r3, r3, #3256	; 0xcb8
 8115900:	498b      	ldr	r1, [pc, #556]	; (8115b30 <tcp_slowtmr+0x588>)
 8115902:	fba1 1303 	umull	r1, r3, r1, r3
 8115906:	095b      	lsrs	r3, r3, #5
      if ((u32_t)(tcp_ticks - pcb->tmr) >
 8115908:	429a      	cmp	r2, r3
 811590a:	d90a      	bls.n	8115922 <tcp_slowtmr+0x37a>
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: KEEPALIVE timeout. Aborting connection to "));
        ip_addr_debug_print_val(TCP_DEBUG, pcb->remote_ip);
        LWIP_DEBUGF(TCP_DEBUG, ("\n"));

        ++pcb_remove;
 811590c:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 8115910:	3301      	adds	r3, #1
 8115912:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
        ++pcb_reset;
 8115916:	f897 3026 	ldrb.w	r3, [r7, #38]	; 0x26
 811591a:	3301      	adds	r3, #1
 811591c:	f887 3026 	strb.w	r3, [r7, #38]	; 0x26
 8115920:	e027      	b.n	8115972 <tcp_slowtmr+0x3ca>
      } else if ((u32_t)(tcp_ticks - pcb->tmr) >
 8115922:	4b82      	ldr	r3, [pc, #520]	; (8115b2c <tcp_slowtmr+0x584>)
 8115924:	681a      	ldr	r2, [r3, #0]
 8115926:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8115928:	6a1b      	ldr	r3, [r3, #32]
 811592a:	1ad2      	subs	r2, r2, r3
                 (pcb->keep_idle + pcb->keep_cnt_sent * TCP_KEEP_INTVL(pcb))
 811592c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 811592e:	f8d3 1094 	ldr.w	r1, [r3, #148]	; 0x94
 8115932:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8115934:	f893 309b 	ldrb.w	r3, [r3, #155]	; 0x9b
 8115938:	4618      	mov	r0, r3
 811593a:	4b7e      	ldr	r3, [pc, #504]	; (8115b34 <tcp_slowtmr+0x58c>)
 811593c:	fb00 f303 	mul.w	r3, r0, r3
 8115940:	440b      	add	r3, r1
                 / TCP_SLOW_INTERVAL) {
 8115942:	497b      	ldr	r1, [pc, #492]	; (8115b30 <tcp_slowtmr+0x588>)
 8115944:	fba1 1303 	umull	r1, r3, r1, r3
 8115948:	095b      	lsrs	r3, r3, #5
      } else if ((u32_t)(tcp_ticks - pcb->tmr) >
 811594a:	429a      	cmp	r2, r3
 811594c:	d911      	bls.n	8115972 <tcp_slowtmr+0x3ca>
        err = tcp_keepalive(pcb);
 811594e:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 8115950:	f004 fac8 	bl	8119ee4 <tcp_keepalive>
 8115954:	4603      	mov	r3, r0
 8115956:	f887 3025 	strb.w	r3, [r7, #37]	; 0x25
        if (err == ERR_OK) {
 811595a:	f997 3025 	ldrsb.w	r3, [r7, #37]	; 0x25
 811595e:	2b00      	cmp	r3, #0
 8115960:	d107      	bne.n	8115972 <tcp_slowtmr+0x3ca>
          pcb->keep_cnt_sent++;
 8115962:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8115964:	f893 309b 	ldrb.w	r3, [r3, #155]	; 0x9b
 8115968:	3301      	adds	r3, #1
 811596a:	b2da      	uxtb	r2, r3
 811596c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 811596e:	f883 209b 	strb.w	r2, [r3, #155]	; 0x9b

    /* If this PCB has queued out of sequence data, but has been
       inactive for too long, will drop the data (it will eventually
       be retransmitted). */
#if TCP_QUEUE_OOSEQ
    if (pcb->ooseq != NULL &&
 8115972:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8115974:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 8115976:	2b00      	cmp	r3, #0
 8115978:	d011      	beq.n	811599e <tcp_slowtmr+0x3f6>
        (tcp_ticks - pcb->tmr >= (u32_t)pcb->rto * TCP_OOSEQ_TIMEOUT)) {
 811597a:	4b6c      	ldr	r3, [pc, #432]	; (8115b2c <tcp_slowtmr+0x584>)
 811597c:	681a      	ldr	r2, [r3, #0]
 811597e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8115980:	6a1b      	ldr	r3, [r3, #32]
 8115982:	1ad2      	subs	r2, r2, r3
 8115984:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8115986:	f9b3 3040 	ldrsh.w	r3, [r3, #64]	; 0x40
 811598a:	4619      	mov	r1, r3
 811598c:	460b      	mov	r3, r1
 811598e:	005b      	lsls	r3, r3, #1
 8115990:	440b      	add	r3, r1
 8115992:	005b      	lsls	r3, r3, #1
    if (pcb->ooseq != NULL &&
 8115994:	429a      	cmp	r2, r3
 8115996:	d302      	bcc.n	811599e <tcp_slowtmr+0x3f6>
      LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_slowtmr: dropping OOSEQ queued data\n"));
      tcp_free_ooseq(pcb);
 8115998:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 811599a:	f000 fddb 	bl	8116554 <tcp_free_ooseq>
    }
#endif /* TCP_QUEUE_OOSEQ */

    /* Check if this PCB has stayed too long in SYN-RCVD */
    if (pcb->state == SYN_RCVD) {
 811599e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 81159a0:	7d1b      	ldrb	r3, [r3, #20]
 81159a2:	2b03      	cmp	r3, #3
 81159a4:	d10b      	bne.n	81159be <tcp_slowtmr+0x416>
      if ((u32_t)(tcp_ticks - pcb->tmr) >
 81159a6:	4b61      	ldr	r3, [pc, #388]	; (8115b2c <tcp_slowtmr+0x584>)
 81159a8:	681a      	ldr	r2, [r3, #0]
 81159aa:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 81159ac:	6a1b      	ldr	r3, [r3, #32]
 81159ae:	1ad3      	subs	r3, r2, r3
 81159b0:	2b28      	cmp	r3, #40	; 0x28
 81159b2:	d904      	bls.n	81159be <tcp_slowtmr+0x416>
          TCP_SYN_RCVD_TIMEOUT / TCP_SLOW_INTERVAL) {
        ++pcb_remove;
 81159b4:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 81159b8:	3301      	adds	r3, #1
 81159ba:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: removing pcb stuck in SYN-RCVD\n"));
      }
    }

    /* Check if this PCB has stayed too long in LAST-ACK */
    if (pcb->state == LAST_ACK) {
 81159be:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 81159c0:	7d1b      	ldrb	r3, [r3, #20]
 81159c2:	2b09      	cmp	r3, #9
 81159c4:	d10b      	bne.n	81159de <tcp_slowtmr+0x436>
      if ((u32_t)(tcp_ticks - pcb->tmr) > 2 * TCP_MSL / TCP_SLOW_INTERVAL) {
 81159c6:	4b59      	ldr	r3, [pc, #356]	; (8115b2c <tcp_slowtmr+0x584>)
 81159c8:	681a      	ldr	r2, [r3, #0]
 81159ca:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 81159cc:	6a1b      	ldr	r3, [r3, #32]
 81159ce:	1ad3      	subs	r3, r2, r3
 81159d0:	2bf0      	cmp	r3, #240	; 0xf0
 81159d2:	d904      	bls.n	81159de <tcp_slowtmr+0x436>
        ++pcb_remove;
 81159d4:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 81159d8:	3301      	adds	r3, #1
 81159da:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: removing pcb stuck in LAST-ACK\n"));
      }
    }

    /* If the PCB should be removed, do it. */
    if (pcb_remove) {
 81159de:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 81159e2:	2b00      	cmp	r3, #0
 81159e4:	d060      	beq.n	8115aa8 <tcp_slowtmr+0x500>
      struct tcp_pcb *pcb2;
#if LWIP_CALLBACK_API
      tcp_err_fn err_fn = pcb->errf;
 81159e6:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 81159e8:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 81159ec:	60fb      	str	r3, [r7, #12]
#endif /* LWIP_CALLBACK_API */
      void *err_arg;
      enum tcp_state last_state;
      tcp_pcb_purge(pcb);
 81159ee:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 81159f0:	f000 fbfc 	bl	81161ec <tcp_pcb_purge>
      /* Remove PCB from tcp_active_pcbs list. */
      if (prev != NULL) {
 81159f4:	6abb      	ldr	r3, [r7, #40]	; 0x28
 81159f6:	2b00      	cmp	r3, #0
 81159f8:	d010      	beq.n	8115a1c <tcp_slowtmr+0x474>
        LWIP_ASSERT("tcp_slowtmr: middle tcp != tcp_active_pcbs", pcb != tcp_active_pcbs);
 81159fa:	4b4f      	ldr	r3, [pc, #316]	; (8115b38 <tcp_slowtmr+0x590>)
 81159fc:	681b      	ldr	r3, [r3, #0]
 81159fe:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8115a00:	429a      	cmp	r2, r3
 8115a02:	d106      	bne.n	8115a12 <tcp_slowtmr+0x46a>
 8115a04:	4b4d      	ldr	r3, [pc, #308]	; (8115b3c <tcp_slowtmr+0x594>)
 8115a06:	f240 526d 	movw	r2, #1389	; 0x56d
 8115a0a:	494d      	ldr	r1, [pc, #308]	; (8115b40 <tcp_slowtmr+0x598>)
 8115a0c:	484d      	ldr	r0, [pc, #308]	; (8115b44 <tcp_slowtmr+0x59c>)
 8115a0e:	f005 fef7 	bl	811b800 <iprintf>
        prev->next = pcb->next;
 8115a12:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8115a14:	68da      	ldr	r2, [r3, #12]
 8115a16:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8115a18:	60da      	str	r2, [r3, #12]
 8115a1a:	e00f      	b.n	8115a3c <tcp_slowtmr+0x494>
      } else {
        /* This PCB was the first. */
        LWIP_ASSERT("tcp_slowtmr: first pcb == tcp_active_pcbs", tcp_active_pcbs == pcb);
 8115a1c:	4b46      	ldr	r3, [pc, #280]	; (8115b38 <tcp_slowtmr+0x590>)
 8115a1e:	681b      	ldr	r3, [r3, #0]
 8115a20:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8115a22:	429a      	cmp	r2, r3
 8115a24:	d006      	beq.n	8115a34 <tcp_slowtmr+0x48c>
 8115a26:	4b45      	ldr	r3, [pc, #276]	; (8115b3c <tcp_slowtmr+0x594>)
 8115a28:	f240 5271 	movw	r2, #1393	; 0x571
 8115a2c:	4946      	ldr	r1, [pc, #280]	; (8115b48 <tcp_slowtmr+0x5a0>)
 8115a2e:	4845      	ldr	r0, [pc, #276]	; (8115b44 <tcp_slowtmr+0x59c>)
 8115a30:	f005 fee6 	bl	811b800 <iprintf>
        tcp_active_pcbs = pcb->next;
 8115a34:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8115a36:	68db      	ldr	r3, [r3, #12]
 8115a38:	4a3f      	ldr	r2, [pc, #252]	; (8115b38 <tcp_slowtmr+0x590>)
 8115a3a:	6013      	str	r3, [r2, #0]
      }

      if (pcb_reset) {
 8115a3c:	f897 3026 	ldrb.w	r3, [r7, #38]	; 0x26
 8115a40:	2b00      	cmp	r3, #0
 8115a42:	d013      	beq.n	8115a6c <tcp_slowtmr+0x4c4>
        tcp_rst(pcb, pcb->snd_nxt, pcb->rcv_nxt, &pcb->local_ip, &pcb->remote_ip,
 8115a44:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8115a46:	6d18      	ldr	r0, [r3, #80]	; 0x50
 8115a48:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8115a4a:	6a5c      	ldr	r4, [r3, #36]	; 0x24
 8115a4c:	6afd      	ldr	r5, [r7, #44]	; 0x2c
 8115a4e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8115a50:	3304      	adds	r3, #4
 8115a52:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8115a54:	8ad2      	ldrh	r2, [r2, #22]
 8115a56:	6af9      	ldr	r1, [r7, #44]	; 0x2c
 8115a58:	8b09      	ldrh	r1, [r1, #24]
 8115a5a:	9102      	str	r1, [sp, #8]
 8115a5c:	9201      	str	r2, [sp, #4]
 8115a5e:	9300      	str	r3, [sp, #0]
 8115a60:	462b      	mov	r3, r5
 8115a62:	4622      	mov	r2, r4
 8115a64:	4601      	mov	r1, r0
 8115a66:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 8115a68:	f004 f988 	bl	8119d7c <tcp_rst>
                pcb->local_port, pcb->remote_port);
      }

      err_arg = pcb->callback_arg;
 8115a6c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8115a6e:	691b      	ldr	r3, [r3, #16]
 8115a70:	60bb      	str	r3, [r7, #8]
      last_state = pcb->state;
 8115a72:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8115a74:	7d1b      	ldrb	r3, [r3, #20]
 8115a76:	71fb      	strb	r3, [r7, #7]
      pcb2 = pcb;
 8115a78:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8115a7a:	603b      	str	r3, [r7, #0]
      pcb = pcb->next;
 8115a7c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8115a7e:	68db      	ldr	r3, [r3, #12]
 8115a80:	62fb      	str	r3, [r7, #44]	; 0x2c
      tcp_free(pcb2);
 8115a82:	6838      	ldr	r0, [r7, #0]
 8115a84:	f7ff f9f2 	bl	8114e6c <tcp_free>

      tcp_active_pcbs_changed = 0;
 8115a88:	4b30      	ldr	r3, [pc, #192]	; (8115b4c <tcp_slowtmr+0x5a4>)
 8115a8a:	2200      	movs	r2, #0
 8115a8c:	701a      	strb	r2, [r3, #0]
      TCP_EVENT_ERR(last_state, err_fn, err_arg, ERR_ABRT);
 8115a8e:	68fb      	ldr	r3, [r7, #12]
 8115a90:	2b00      	cmp	r3, #0
 8115a92:	d004      	beq.n	8115a9e <tcp_slowtmr+0x4f6>
 8115a94:	68fb      	ldr	r3, [r7, #12]
 8115a96:	f06f 010c 	mvn.w	r1, #12
 8115a9a:	68b8      	ldr	r0, [r7, #8]
 8115a9c:	4798      	blx	r3
      if (tcp_active_pcbs_changed) {
 8115a9e:	4b2b      	ldr	r3, [pc, #172]	; (8115b4c <tcp_slowtmr+0x5a4>)
 8115aa0:	781b      	ldrb	r3, [r3, #0]
 8115aa2:	2b00      	cmp	r3, #0
 8115aa4:	d037      	beq.n	8115b16 <tcp_slowtmr+0x56e>
        goto tcp_slowtmr_start;
 8115aa6:	e590      	b.n	81155ca <tcp_slowtmr+0x22>
      }
    } else {
      /* get the 'next' element now and work with 'prev' below (in case of abort) */
      prev = pcb;
 8115aa8:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8115aaa:	62bb      	str	r3, [r7, #40]	; 0x28
      pcb = pcb->next;
 8115aac:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8115aae:	68db      	ldr	r3, [r3, #12]
 8115ab0:	62fb      	str	r3, [r7, #44]	; 0x2c

      /* We check if we should poll the connection. */
      ++prev->polltmr;
 8115ab2:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8115ab4:	7f1b      	ldrb	r3, [r3, #28]
 8115ab6:	3301      	adds	r3, #1
 8115ab8:	b2da      	uxtb	r2, r3
 8115aba:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8115abc:	771a      	strb	r2, [r3, #28]
      if (prev->polltmr >= prev->pollinterval) {
 8115abe:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8115ac0:	7f1a      	ldrb	r2, [r3, #28]
 8115ac2:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8115ac4:	7f5b      	ldrb	r3, [r3, #29]
 8115ac6:	429a      	cmp	r2, r3
 8115ac8:	d325      	bcc.n	8115b16 <tcp_slowtmr+0x56e>
        prev->polltmr = 0;
 8115aca:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8115acc:	2200      	movs	r2, #0
 8115ace:	771a      	strb	r2, [r3, #28]
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: polling application\n"));
        tcp_active_pcbs_changed = 0;
 8115ad0:	4b1e      	ldr	r3, [pc, #120]	; (8115b4c <tcp_slowtmr+0x5a4>)
 8115ad2:	2200      	movs	r2, #0
 8115ad4:	701a      	strb	r2, [r3, #0]
        TCP_EVENT_POLL(prev, err);
 8115ad6:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8115ad8:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 8115adc:	2b00      	cmp	r3, #0
 8115ade:	d00b      	beq.n	8115af8 <tcp_slowtmr+0x550>
 8115ae0:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8115ae2:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 8115ae6:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8115ae8:	6912      	ldr	r2, [r2, #16]
 8115aea:	6ab9      	ldr	r1, [r7, #40]	; 0x28
 8115aec:	4610      	mov	r0, r2
 8115aee:	4798      	blx	r3
 8115af0:	4603      	mov	r3, r0
 8115af2:	f887 3025 	strb.w	r3, [r7, #37]	; 0x25
 8115af6:	e002      	b.n	8115afe <tcp_slowtmr+0x556>
 8115af8:	2300      	movs	r3, #0
 8115afa:	f887 3025 	strb.w	r3, [r7, #37]	; 0x25
        if (tcp_active_pcbs_changed) {
 8115afe:	4b13      	ldr	r3, [pc, #76]	; (8115b4c <tcp_slowtmr+0x5a4>)
 8115b00:	781b      	ldrb	r3, [r3, #0]
 8115b02:	2b00      	cmp	r3, #0
 8115b04:	d000      	beq.n	8115b08 <tcp_slowtmr+0x560>
          goto tcp_slowtmr_start;
 8115b06:	e560      	b.n	81155ca <tcp_slowtmr+0x22>
        }
        /* if err == ERR_ABRT, 'prev' is already deallocated */
        if (err == ERR_OK) {
 8115b08:	f997 3025 	ldrsb.w	r3, [r7, #37]	; 0x25
 8115b0c:	2b00      	cmp	r3, #0
 8115b0e:	d102      	bne.n	8115b16 <tcp_slowtmr+0x56e>
          tcp_output(prev);
 8115b10:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 8115b12:	f003 fb7f 	bl	8119214 <tcp_output>
  while (pcb != NULL) {
 8115b16:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8115b18:	2b00      	cmp	r3, #0
 8115b1a:	f47f ad5c 	bne.w	81155d6 <tcp_slowtmr+0x2e>
    }
  }


  /* Steps through all of the TIME-WAIT PCBs. */
  prev = NULL;
 8115b1e:	2300      	movs	r3, #0
 8115b20:	62bb      	str	r3, [r7, #40]	; 0x28
  pcb = tcp_tw_pcbs;
 8115b22:	4b0b      	ldr	r3, [pc, #44]	; (8115b50 <tcp_slowtmr+0x5a8>)
 8115b24:	681b      	ldr	r3, [r3, #0]
 8115b26:	62fb      	str	r3, [r7, #44]	; 0x2c
  while (pcb != NULL) {
 8115b28:	e067      	b.n	8115bfa <tcp_slowtmr+0x652>
 8115b2a:	bf00      	nop
 8115b2c:	10008448 	.word	0x10008448
 8115b30:	10624dd3 	.word	0x10624dd3
 8115b34:	000124f8 	.word	0x000124f8
 8115b38:	10008454 	.word	0x10008454
 8115b3c:	0811df48 	.word	0x0811df48
 8115b40:	0811e3b4 	.word	0x0811e3b4
 8115b44:	0811dfc0 	.word	0x0811dfc0
 8115b48:	0811e3e0 	.word	0x0811e3e0
 8115b4c:	1000845c 	.word	0x1000845c
 8115b50:	10008458 	.word	0x10008458
    LWIP_ASSERT("tcp_slowtmr: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
 8115b54:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8115b56:	7d1b      	ldrb	r3, [r3, #20]
 8115b58:	2b0a      	cmp	r3, #10
 8115b5a:	d006      	beq.n	8115b6a <tcp_slowtmr+0x5c2>
 8115b5c:	4b2b      	ldr	r3, [pc, #172]	; (8115c0c <tcp_slowtmr+0x664>)
 8115b5e:	f240 52a1 	movw	r2, #1441	; 0x5a1
 8115b62:	492b      	ldr	r1, [pc, #172]	; (8115c10 <tcp_slowtmr+0x668>)
 8115b64:	482b      	ldr	r0, [pc, #172]	; (8115c14 <tcp_slowtmr+0x66c>)
 8115b66:	f005 fe4b 	bl	811b800 <iprintf>
    pcb_remove = 0;
 8115b6a:	2300      	movs	r3, #0
 8115b6c:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27

    /* Check if this PCB has stayed long enough in TIME-WAIT */
    if ((u32_t)(tcp_ticks - pcb->tmr) > 2 * TCP_MSL / TCP_SLOW_INTERVAL) {
 8115b70:	4b29      	ldr	r3, [pc, #164]	; (8115c18 <tcp_slowtmr+0x670>)
 8115b72:	681a      	ldr	r2, [r3, #0]
 8115b74:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8115b76:	6a1b      	ldr	r3, [r3, #32]
 8115b78:	1ad3      	subs	r3, r2, r3
 8115b7a:	2bf0      	cmp	r3, #240	; 0xf0
 8115b7c:	d904      	bls.n	8115b88 <tcp_slowtmr+0x5e0>
      ++pcb_remove;
 8115b7e:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 8115b82:	3301      	adds	r3, #1
 8115b84:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
    }

    /* If the PCB should be removed, do it. */
    if (pcb_remove) {
 8115b88:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 8115b8c:	2b00      	cmp	r3, #0
 8115b8e:	d02f      	beq.n	8115bf0 <tcp_slowtmr+0x648>
      struct tcp_pcb *pcb2;
      tcp_pcb_purge(pcb);
 8115b90:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 8115b92:	f000 fb2b 	bl	81161ec <tcp_pcb_purge>
      /* Remove PCB from tcp_tw_pcbs list. */
      if (prev != NULL) {
 8115b96:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8115b98:	2b00      	cmp	r3, #0
 8115b9a:	d010      	beq.n	8115bbe <tcp_slowtmr+0x616>
        LWIP_ASSERT("tcp_slowtmr: middle tcp != tcp_tw_pcbs", pcb != tcp_tw_pcbs);
 8115b9c:	4b1f      	ldr	r3, [pc, #124]	; (8115c1c <tcp_slowtmr+0x674>)
 8115b9e:	681b      	ldr	r3, [r3, #0]
 8115ba0:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8115ba2:	429a      	cmp	r2, r3
 8115ba4:	d106      	bne.n	8115bb4 <tcp_slowtmr+0x60c>
 8115ba6:	4b19      	ldr	r3, [pc, #100]	; (8115c0c <tcp_slowtmr+0x664>)
 8115ba8:	f240 52af 	movw	r2, #1455	; 0x5af
 8115bac:	491c      	ldr	r1, [pc, #112]	; (8115c20 <tcp_slowtmr+0x678>)
 8115bae:	4819      	ldr	r0, [pc, #100]	; (8115c14 <tcp_slowtmr+0x66c>)
 8115bb0:	f005 fe26 	bl	811b800 <iprintf>
        prev->next = pcb->next;
 8115bb4:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8115bb6:	68da      	ldr	r2, [r3, #12]
 8115bb8:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8115bba:	60da      	str	r2, [r3, #12]
 8115bbc:	e00f      	b.n	8115bde <tcp_slowtmr+0x636>
      } else {
        /* This PCB was the first. */
        LWIP_ASSERT("tcp_slowtmr: first pcb == tcp_tw_pcbs", tcp_tw_pcbs == pcb);
 8115bbe:	4b17      	ldr	r3, [pc, #92]	; (8115c1c <tcp_slowtmr+0x674>)
 8115bc0:	681b      	ldr	r3, [r3, #0]
 8115bc2:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8115bc4:	429a      	cmp	r2, r3
 8115bc6:	d006      	beq.n	8115bd6 <tcp_slowtmr+0x62e>
 8115bc8:	4b10      	ldr	r3, [pc, #64]	; (8115c0c <tcp_slowtmr+0x664>)
 8115bca:	f240 52b3 	movw	r2, #1459	; 0x5b3
 8115bce:	4915      	ldr	r1, [pc, #84]	; (8115c24 <tcp_slowtmr+0x67c>)
 8115bd0:	4810      	ldr	r0, [pc, #64]	; (8115c14 <tcp_slowtmr+0x66c>)
 8115bd2:	f005 fe15 	bl	811b800 <iprintf>
        tcp_tw_pcbs = pcb->next;
 8115bd6:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8115bd8:	68db      	ldr	r3, [r3, #12]
 8115bda:	4a10      	ldr	r2, [pc, #64]	; (8115c1c <tcp_slowtmr+0x674>)
 8115bdc:	6013      	str	r3, [r2, #0]
      }
      pcb2 = pcb;
 8115bde:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8115be0:	61fb      	str	r3, [r7, #28]
      pcb = pcb->next;
 8115be2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8115be4:	68db      	ldr	r3, [r3, #12]
 8115be6:	62fb      	str	r3, [r7, #44]	; 0x2c
      tcp_free(pcb2);
 8115be8:	69f8      	ldr	r0, [r7, #28]
 8115bea:	f7ff f93f 	bl	8114e6c <tcp_free>
 8115bee:	e004      	b.n	8115bfa <tcp_slowtmr+0x652>
    } else {
      prev = pcb;
 8115bf0:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8115bf2:	62bb      	str	r3, [r7, #40]	; 0x28
      pcb = pcb->next;
 8115bf4:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8115bf6:	68db      	ldr	r3, [r3, #12]
 8115bf8:	62fb      	str	r3, [r7, #44]	; 0x2c
  while (pcb != NULL) {
 8115bfa:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8115bfc:	2b00      	cmp	r3, #0
 8115bfe:	d1a9      	bne.n	8115b54 <tcp_slowtmr+0x5ac>
    }
  }
}
 8115c00:	bf00      	nop
 8115c02:	bf00      	nop
 8115c04:	3730      	adds	r7, #48	; 0x30
 8115c06:	46bd      	mov	sp, r7
 8115c08:	bdb0      	pop	{r4, r5, r7, pc}
 8115c0a:	bf00      	nop
 8115c0c:	0811df48 	.word	0x0811df48
 8115c10:	0811e40c 	.word	0x0811e40c
 8115c14:	0811dfc0 	.word	0x0811dfc0
 8115c18:	10008448 	.word	0x10008448
 8115c1c:	10008458 	.word	0x10008458
 8115c20:	0811e43c 	.word	0x0811e43c
 8115c24:	0811e464 	.word	0x0811e464

08115c28 <tcp_fasttmr>:
 *
 * Automatically called from tcp_tmr().
 */
void
tcp_fasttmr(void)
{
 8115c28:	b580      	push	{r7, lr}
 8115c2a:	b082      	sub	sp, #8
 8115c2c:	af00      	add	r7, sp, #0
  struct tcp_pcb *pcb;

  ++tcp_timer_ctr;
 8115c2e:	4b2d      	ldr	r3, [pc, #180]	; (8115ce4 <tcp_fasttmr+0xbc>)
 8115c30:	781b      	ldrb	r3, [r3, #0]
 8115c32:	3301      	adds	r3, #1
 8115c34:	b2da      	uxtb	r2, r3
 8115c36:	4b2b      	ldr	r3, [pc, #172]	; (8115ce4 <tcp_fasttmr+0xbc>)
 8115c38:	701a      	strb	r2, [r3, #0]

tcp_fasttmr_start:
  pcb = tcp_active_pcbs;
 8115c3a:	4b2b      	ldr	r3, [pc, #172]	; (8115ce8 <tcp_fasttmr+0xc0>)
 8115c3c:	681b      	ldr	r3, [r3, #0]
 8115c3e:	607b      	str	r3, [r7, #4]

  while (pcb != NULL) {
 8115c40:	e048      	b.n	8115cd4 <tcp_fasttmr+0xac>
    if (pcb->last_timer != tcp_timer_ctr) {
 8115c42:	687b      	ldr	r3, [r7, #4]
 8115c44:	7f9a      	ldrb	r2, [r3, #30]
 8115c46:	4b27      	ldr	r3, [pc, #156]	; (8115ce4 <tcp_fasttmr+0xbc>)
 8115c48:	781b      	ldrb	r3, [r3, #0]
 8115c4a:	429a      	cmp	r2, r3
 8115c4c:	d03f      	beq.n	8115cce <tcp_fasttmr+0xa6>
      struct tcp_pcb *next;
      pcb->last_timer = tcp_timer_ctr;
 8115c4e:	4b25      	ldr	r3, [pc, #148]	; (8115ce4 <tcp_fasttmr+0xbc>)
 8115c50:	781a      	ldrb	r2, [r3, #0]
 8115c52:	687b      	ldr	r3, [r7, #4]
 8115c54:	779a      	strb	r2, [r3, #30]
      /* send delayed ACKs */
      if (pcb->flags & TF_ACK_DELAY) {
 8115c56:	687b      	ldr	r3, [r7, #4]
 8115c58:	8b5b      	ldrh	r3, [r3, #26]
 8115c5a:	f003 0301 	and.w	r3, r3, #1
 8115c5e:	2b00      	cmp	r3, #0
 8115c60:	d010      	beq.n	8115c84 <tcp_fasttmr+0x5c>
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_fasttmr: delayed ACK\n"));
        tcp_ack_now(pcb);
 8115c62:	687b      	ldr	r3, [r7, #4]
 8115c64:	8b5b      	ldrh	r3, [r3, #26]
 8115c66:	f043 0302 	orr.w	r3, r3, #2
 8115c6a:	b29a      	uxth	r2, r3
 8115c6c:	687b      	ldr	r3, [r7, #4]
 8115c6e:	835a      	strh	r2, [r3, #26]
        tcp_output(pcb);
 8115c70:	6878      	ldr	r0, [r7, #4]
 8115c72:	f003 facf 	bl	8119214 <tcp_output>
        tcp_clear_flags(pcb, TF_ACK_DELAY | TF_ACK_NOW);
 8115c76:	687b      	ldr	r3, [r7, #4]
 8115c78:	8b5b      	ldrh	r3, [r3, #26]
 8115c7a:	f023 0303 	bic.w	r3, r3, #3
 8115c7e:	b29a      	uxth	r2, r3
 8115c80:	687b      	ldr	r3, [r7, #4]
 8115c82:	835a      	strh	r2, [r3, #26]
      }
      /* send pending FIN */
      if (pcb->flags & TF_CLOSEPEND) {
 8115c84:	687b      	ldr	r3, [r7, #4]
 8115c86:	8b5b      	ldrh	r3, [r3, #26]
 8115c88:	f003 0308 	and.w	r3, r3, #8
 8115c8c:	2b00      	cmp	r3, #0
 8115c8e:	d009      	beq.n	8115ca4 <tcp_fasttmr+0x7c>
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_fasttmr: pending FIN\n"));
        tcp_clear_flags(pcb, TF_CLOSEPEND);
 8115c90:	687b      	ldr	r3, [r7, #4]
 8115c92:	8b5b      	ldrh	r3, [r3, #26]
 8115c94:	f023 0308 	bic.w	r3, r3, #8
 8115c98:	b29a      	uxth	r2, r3
 8115c9a:	687b      	ldr	r3, [r7, #4]
 8115c9c:	835a      	strh	r2, [r3, #26]
        tcp_close_shutdown_fin(pcb);
 8115c9e:	6878      	ldr	r0, [r7, #4]
 8115ca0:	f7ff fa78 	bl	8115194 <tcp_close_shutdown_fin>
      }

      next = pcb->next;
 8115ca4:	687b      	ldr	r3, [r7, #4]
 8115ca6:	68db      	ldr	r3, [r3, #12]
 8115ca8:	603b      	str	r3, [r7, #0]

      /* If there is data which was previously "refused" by upper layer */
      if (pcb->refused_data != NULL) {
 8115caa:	687b      	ldr	r3, [r7, #4]
 8115cac:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 8115cae:	2b00      	cmp	r3, #0
 8115cb0:	d00a      	beq.n	8115cc8 <tcp_fasttmr+0xa0>
        tcp_active_pcbs_changed = 0;
 8115cb2:	4b0e      	ldr	r3, [pc, #56]	; (8115cec <tcp_fasttmr+0xc4>)
 8115cb4:	2200      	movs	r2, #0
 8115cb6:	701a      	strb	r2, [r3, #0]
        tcp_process_refused_data(pcb);
 8115cb8:	6878      	ldr	r0, [r7, #4]
 8115cba:	f000 f819 	bl	8115cf0 <tcp_process_refused_data>
        if (tcp_active_pcbs_changed) {
 8115cbe:	4b0b      	ldr	r3, [pc, #44]	; (8115cec <tcp_fasttmr+0xc4>)
 8115cc0:	781b      	ldrb	r3, [r3, #0]
 8115cc2:	2b00      	cmp	r3, #0
 8115cc4:	d000      	beq.n	8115cc8 <tcp_fasttmr+0xa0>
          /* application callback has changed the pcb list: restart the loop */
          goto tcp_fasttmr_start;
 8115cc6:	e7b8      	b.n	8115c3a <tcp_fasttmr+0x12>
        }
      }
      pcb = next;
 8115cc8:	683b      	ldr	r3, [r7, #0]
 8115cca:	607b      	str	r3, [r7, #4]
 8115ccc:	e002      	b.n	8115cd4 <tcp_fasttmr+0xac>
    } else {
      pcb = pcb->next;
 8115cce:	687b      	ldr	r3, [r7, #4]
 8115cd0:	68db      	ldr	r3, [r3, #12]
 8115cd2:	607b      	str	r3, [r7, #4]
  while (pcb != NULL) {
 8115cd4:	687b      	ldr	r3, [r7, #4]
 8115cd6:	2b00      	cmp	r3, #0
 8115cd8:	d1b3      	bne.n	8115c42 <tcp_fasttmr+0x1a>
    }
  }
}
 8115cda:	bf00      	nop
 8115cdc:	bf00      	nop
 8115cde:	3708      	adds	r7, #8
 8115ce0:	46bd      	mov	sp, r7
 8115ce2:	bd80      	pop	{r7, pc}
 8115ce4:	1000845e 	.word	0x1000845e
 8115ce8:	10008454 	.word	0x10008454
 8115cec:	1000845c 	.word	0x1000845c

08115cf0 <tcp_process_refused_data>:
}

/** Pass pcb->refused_data to the recv callback */
err_t
tcp_process_refused_data(struct tcp_pcb *pcb)
{
 8115cf0:	b590      	push	{r4, r7, lr}
 8115cf2:	b085      	sub	sp, #20
 8115cf4:	af00      	add	r7, sp, #0
 8115cf6:	6078      	str	r0, [r7, #4]
#if TCP_QUEUE_OOSEQ && LWIP_WND_SCALE
  struct pbuf *rest;
#endif /* TCP_QUEUE_OOSEQ && LWIP_WND_SCALE */

  LWIP_ERROR("tcp_process_refused_data: invalid pcb", pcb != NULL, return ERR_ARG);
 8115cf8:	687b      	ldr	r3, [r7, #4]
 8115cfa:	2b00      	cmp	r3, #0
 8115cfc:	d109      	bne.n	8115d12 <tcp_process_refused_data+0x22>
 8115cfe:	4b37      	ldr	r3, [pc, #220]	; (8115ddc <tcp_process_refused_data+0xec>)
 8115d00:	f240 6209 	movw	r2, #1545	; 0x609
 8115d04:	4936      	ldr	r1, [pc, #216]	; (8115de0 <tcp_process_refused_data+0xf0>)
 8115d06:	4837      	ldr	r0, [pc, #220]	; (8115de4 <tcp_process_refused_data+0xf4>)
 8115d08:	f005 fd7a 	bl	811b800 <iprintf>
 8115d0c:	f06f 030f 	mvn.w	r3, #15
 8115d10:	e060      	b.n	8115dd4 <tcp_process_refused_data+0xe4>
#if TCP_QUEUE_OOSEQ && LWIP_WND_SCALE
  while (pcb->refused_data != NULL)
#endif /* TCP_QUEUE_OOSEQ && LWIP_WND_SCALE */
  {
    err_t err;
    u8_t refused_flags = pcb->refused_data->flags;
 8115d12:	687b      	ldr	r3, [r7, #4]
 8115d14:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 8115d16:	7b5b      	ldrb	r3, [r3, #13]
 8115d18:	73bb      	strb	r3, [r7, #14]
    /* set pcb->refused_data to NULL in case the callback frees it and then
       closes the pcb */
    struct pbuf *refused_data = pcb->refused_data;
 8115d1a:	687b      	ldr	r3, [r7, #4]
 8115d1c:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 8115d1e:	60bb      	str	r3, [r7, #8]
#if TCP_QUEUE_OOSEQ && LWIP_WND_SCALE
    pbuf_split_64k(refused_data, &rest);
    pcb->refused_data = rest;
#else /* TCP_QUEUE_OOSEQ && LWIP_WND_SCALE */
    pcb->refused_data = NULL;
 8115d20:	687b      	ldr	r3, [r7, #4]
 8115d22:	2200      	movs	r2, #0
 8115d24:	679a      	str	r2, [r3, #120]	; 0x78
#endif /* TCP_QUEUE_OOSEQ && LWIP_WND_SCALE */
    /* Notify again application with data previously received. */
    LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: notify kept packet\n"));
    TCP_EVENT_RECV(pcb, refused_data, ERR_OK, err);
 8115d26:	687b      	ldr	r3, [r7, #4]
 8115d28:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 8115d2c:	2b00      	cmp	r3, #0
 8115d2e:	d00b      	beq.n	8115d48 <tcp_process_refused_data+0x58>
 8115d30:	687b      	ldr	r3, [r7, #4]
 8115d32:	f8d3 4084 	ldr.w	r4, [r3, #132]	; 0x84
 8115d36:	687b      	ldr	r3, [r7, #4]
 8115d38:	6918      	ldr	r0, [r3, #16]
 8115d3a:	2300      	movs	r3, #0
 8115d3c:	68ba      	ldr	r2, [r7, #8]
 8115d3e:	6879      	ldr	r1, [r7, #4]
 8115d40:	47a0      	blx	r4
 8115d42:	4603      	mov	r3, r0
 8115d44:	73fb      	strb	r3, [r7, #15]
 8115d46:	e007      	b.n	8115d58 <tcp_process_refused_data+0x68>
 8115d48:	2300      	movs	r3, #0
 8115d4a:	68ba      	ldr	r2, [r7, #8]
 8115d4c:	6879      	ldr	r1, [r7, #4]
 8115d4e:	2000      	movs	r0, #0
 8115d50:	f000 f8a4 	bl	8115e9c <tcp_recv_null>
 8115d54:	4603      	mov	r3, r0
 8115d56:	73fb      	strb	r3, [r7, #15]
    if (err == ERR_OK) {
 8115d58:	f997 300f 	ldrsb.w	r3, [r7, #15]
 8115d5c:	2b00      	cmp	r3, #0
 8115d5e:	d12a      	bne.n	8115db6 <tcp_process_refused_data+0xc6>
      /* did refused_data include a FIN? */
      if ((refused_flags & PBUF_FLAG_TCP_FIN)
 8115d60:	7bbb      	ldrb	r3, [r7, #14]
 8115d62:	f003 0320 	and.w	r3, r3, #32
 8115d66:	2b00      	cmp	r3, #0
 8115d68:	d033      	beq.n	8115dd2 <tcp_process_refused_data+0xe2>
          && (rest == NULL)
#endif /* TCP_QUEUE_OOSEQ && LWIP_WND_SCALE */
         ) {
        /* correct rcv_wnd as the application won't call tcp_recved()
           for the FIN's seqno */
        if (pcb->rcv_wnd != TCP_WND_MAX(pcb)) {
 8115d6a:	687b      	ldr	r3, [r7, #4]
 8115d6c:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
 8115d6e:	f5b3 6f06 	cmp.w	r3, #2144	; 0x860
 8115d72:	d005      	beq.n	8115d80 <tcp_process_refused_data+0x90>
          pcb->rcv_wnd++;
 8115d74:	687b      	ldr	r3, [r7, #4]
 8115d76:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
 8115d78:	3301      	adds	r3, #1
 8115d7a:	b29a      	uxth	r2, r3
 8115d7c:	687b      	ldr	r3, [r7, #4]
 8115d7e:	851a      	strh	r2, [r3, #40]	; 0x28
        }
        TCP_EVENT_CLOSED(pcb, err);
 8115d80:	687b      	ldr	r3, [r7, #4]
 8115d82:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 8115d86:	2b00      	cmp	r3, #0
 8115d88:	d00b      	beq.n	8115da2 <tcp_process_refused_data+0xb2>
 8115d8a:	687b      	ldr	r3, [r7, #4]
 8115d8c:	f8d3 4084 	ldr.w	r4, [r3, #132]	; 0x84
 8115d90:	687b      	ldr	r3, [r7, #4]
 8115d92:	6918      	ldr	r0, [r3, #16]
 8115d94:	2300      	movs	r3, #0
 8115d96:	2200      	movs	r2, #0
 8115d98:	6879      	ldr	r1, [r7, #4]
 8115d9a:	47a0      	blx	r4
 8115d9c:	4603      	mov	r3, r0
 8115d9e:	73fb      	strb	r3, [r7, #15]
 8115da0:	e001      	b.n	8115da6 <tcp_process_refused_data+0xb6>
 8115da2:	2300      	movs	r3, #0
 8115da4:	73fb      	strb	r3, [r7, #15]
        if (err == ERR_ABRT) {
 8115da6:	f997 300f 	ldrsb.w	r3, [r7, #15]
 8115daa:	f113 0f0d 	cmn.w	r3, #13
 8115dae:	d110      	bne.n	8115dd2 <tcp_process_refused_data+0xe2>
          return ERR_ABRT;
 8115db0:	f06f 030c 	mvn.w	r3, #12
 8115db4:	e00e      	b.n	8115dd4 <tcp_process_refused_data+0xe4>
        }
      }
    } else if (err == ERR_ABRT) {
 8115db6:	f997 300f 	ldrsb.w	r3, [r7, #15]
 8115dba:	f113 0f0d 	cmn.w	r3, #13
 8115dbe:	d102      	bne.n	8115dc6 <tcp_process_refused_data+0xd6>
      /* if err == ERR_ABRT, 'pcb' is already deallocated */
      /* Drop incoming packets because pcb is "full" (only if the incoming
         segment contains data). */
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: drop incoming packets, because pcb is \"full\"\n"));
      return ERR_ABRT;
 8115dc0:	f06f 030c 	mvn.w	r3, #12
 8115dc4:	e006      	b.n	8115dd4 <tcp_process_refused_data+0xe4>
#if TCP_QUEUE_OOSEQ && LWIP_WND_SCALE
      if (rest != NULL) {
        pbuf_cat(refused_data, rest);
      }
#endif /* TCP_QUEUE_OOSEQ && LWIP_WND_SCALE */
      pcb->refused_data = refused_data;
 8115dc6:	687b      	ldr	r3, [r7, #4]
 8115dc8:	68ba      	ldr	r2, [r7, #8]
 8115dca:	679a      	str	r2, [r3, #120]	; 0x78
      return ERR_INPROGRESS;
 8115dcc:	f06f 0304 	mvn.w	r3, #4
 8115dd0:	e000      	b.n	8115dd4 <tcp_process_refused_data+0xe4>
    }
  }
  return ERR_OK;
 8115dd2:	2300      	movs	r3, #0
}
 8115dd4:	4618      	mov	r0, r3
 8115dd6:	3714      	adds	r7, #20
 8115dd8:	46bd      	mov	sp, r7
 8115dda:	bd90      	pop	{r4, r7, pc}
 8115ddc:	0811df48 	.word	0x0811df48
 8115de0:	0811e48c 	.word	0x0811e48c
 8115de4:	0811dfc0 	.word	0x0811dfc0

08115de8 <tcp_segs_free>:
 *
 * @param seg tcp_seg list of TCP segments to free
 */
void
tcp_segs_free(struct tcp_seg *seg)
{
 8115de8:	b580      	push	{r7, lr}
 8115dea:	b084      	sub	sp, #16
 8115dec:	af00      	add	r7, sp, #0
 8115dee:	6078      	str	r0, [r7, #4]
  while (seg != NULL) {
 8115df0:	e007      	b.n	8115e02 <tcp_segs_free+0x1a>
    struct tcp_seg *next = seg->next;
 8115df2:	687b      	ldr	r3, [r7, #4]
 8115df4:	681b      	ldr	r3, [r3, #0]
 8115df6:	60fb      	str	r3, [r7, #12]
    tcp_seg_free(seg);
 8115df8:	6878      	ldr	r0, [r7, #4]
 8115dfa:	f000 f80a 	bl	8115e12 <tcp_seg_free>
    seg = next;
 8115dfe:	68fb      	ldr	r3, [r7, #12]
 8115e00:	607b      	str	r3, [r7, #4]
  while (seg != NULL) {
 8115e02:	687b      	ldr	r3, [r7, #4]
 8115e04:	2b00      	cmp	r3, #0
 8115e06:	d1f4      	bne.n	8115df2 <tcp_segs_free+0xa>
  }
}
 8115e08:	bf00      	nop
 8115e0a:	bf00      	nop
 8115e0c:	3710      	adds	r7, #16
 8115e0e:	46bd      	mov	sp, r7
 8115e10:	bd80      	pop	{r7, pc}

08115e12 <tcp_seg_free>:
 *
 * @param seg single tcp_seg to free
 */
void
tcp_seg_free(struct tcp_seg *seg)
{
 8115e12:	b580      	push	{r7, lr}
 8115e14:	b082      	sub	sp, #8
 8115e16:	af00      	add	r7, sp, #0
 8115e18:	6078      	str	r0, [r7, #4]
  if (seg != NULL) {
 8115e1a:	687b      	ldr	r3, [r7, #4]
 8115e1c:	2b00      	cmp	r3, #0
 8115e1e:	d00c      	beq.n	8115e3a <tcp_seg_free+0x28>
    if (seg->p != NULL) {
 8115e20:	687b      	ldr	r3, [r7, #4]
 8115e22:	685b      	ldr	r3, [r3, #4]
 8115e24:	2b00      	cmp	r3, #0
 8115e26:	d004      	beq.n	8115e32 <tcp_seg_free+0x20>
      pbuf_free(seg->p);
 8115e28:	687b      	ldr	r3, [r7, #4]
 8115e2a:	685b      	ldr	r3, [r3, #4]
 8115e2c:	4618      	mov	r0, r3
 8115e2e:	f7fe fc13 	bl	8114658 <pbuf_free>
#if TCP_DEBUG
      seg->p = NULL;
#endif /* TCP_DEBUG */
    }
    memp_free(MEMP_TCP_SEG, seg);
 8115e32:	6879      	ldr	r1, [r7, #4]
 8115e34:	2003      	movs	r0, #3
 8115e36:	f7fd fdad 	bl	8113994 <memp_free>
  }
}
 8115e3a:	bf00      	nop
 8115e3c:	3708      	adds	r7, #8
 8115e3e:	46bd      	mov	sp, r7
 8115e40:	bd80      	pop	{r7, pc}
	...

08115e44 <tcp_seg_copy>:
 * @param seg the old tcp_seg
 * @return a copy of seg
 */
struct tcp_seg *
tcp_seg_copy(struct tcp_seg *seg)
{
 8115e44:	b580      	push	{r7, lr}
 8115e46:	b084      	sub	sp, #16
 8115e48:	af00      	add	r7, sp, #0
 8115e4a:	6078      	str	r0, [r7, #4]
  struct tcp_seg *cseg;

  LWIP_ASSERT("tcp_seg_copy: invalid seg", seg != NULL);
 8115e4c:	687b      	ldr	r3, [r7, #4]
 8115e4e:	2b00      	cmp	r3, #0
 8115e50:	d106      	bne.n	8115e60 <tcp_seg_copy+0x1c>
 8115e52:	4b0f      	ldr	r3, [pc, #60]	; (8115e90 <tcp_seg_copy+0x4c>)
 8115e54:	f240 6282 	movw	r2, #1666	; 0x682
 8115e58:	490e      	ldr	r1, [pc, #56]	; (8115e94 <tcp_seg_copy+0x50>)
 8115e5a:	480f      	ldr	r0, [pc, #60]	; (8115e98 <tcp_seg_copy+0x54>)
 8115e5c:	f005 fcd0 	bl	811b800 <iprintf>

  cseg = (struct tcp_seg *)memp_malloc(MEMP_TCP_SEG);
 8115e60:	2003      	movs	r0, #3
 8115e62:	f7fd fd27 	bl	81138b4 <memp_malloc>
 8115e66:	60f8      	str	r0, [r7, #12]
  if (cseg == NULL) {
 8115e68:	68fb      	ldr	r3, [r7, #12]
 8115e6a:	2b00      	cmp	r3, #0
 8115e6c:	d101      	bne.n	8115e72 <tcp_seg_copy+0x2e>
    return NULL;
 8115e6e:	2300      	movs	r3, #0
 8115e70:	e00a      	b.n	8115e88 <tcp_seg_copy+0x44>
  }
  SMEMCPY((u8_t *)cseg, (const u8_t *)seg, sizeof(struct tcp_seg));
 8115e72:	2210      	movs	r2, #16
 8115e74:	6879      	ldr	r1, [r7, #4]
 8115e76:	68f8      	ldr	r0, [r7, #12]
 8115e78:	f005 fd1a 	bl	811b8b0 <memcpy>
  pbuf_ref(cseg->p);
 8115e7c:	68fb      	ldr	r3, [r7, #12]
 8115e7e:	685b      	ldr	r3, [r3, #4]
 8115e80:	4618      	mov	r0, r3
 8115e82:	f7fe fc89 	bl	8114798 <pbuf_ref>
  return cseg;
 8115e86:	68fb      	ldr	r3, [r7, #12]
}
 8115e88:	4618      	mov	r0, r3
 8115e8a:	3710      	adds	r7, #16
 8115e8c:	46bd      	mov	sp, r7
 8115e8e:	bd80      	pop	{r7, pc}
 8115e90:	0811df48 	.word	0x0811df48
 8115e94:	0811e4d0 	.word	0x0811e4d0
 8115e98:	0811dfc0 	.word	0x0811dfc0

08115e9c <tcp_recv_null>:
 * Default receive callback that is called if the user didn't register
 * a recv callback for the pcb.
 */
err_t
tcp_recv_null(void *arg, struct tcp_pcb *pcb, struct pbuf *p, err_t err)
{
 8115e9c:	b580      	push	{r7, lr}
 8115e9e:	b084      	sub	sp, #16
 8115ea0:	af00      	add	r7, sp, #0
 8115ea2:	60f8      	str	r0, [r7, #12]
 8115ea4:	60b9      	str	r1, [r7, #8]
 8115ea6:	607a      	str	r2, [r7, #4]
 8115ea8:	70fb      	strb	r3, [r7, #3]
  LWIP_UNUSED_ARG(arg);

  LWIP_ERROR("tcp_recv_null: invalid pcb", pcb != NULL, return ERR_ARG);
 8115eaa:	68bb      	ldr	r3, [r7, #8]
 8115eac:	2b00      	cmp	r3, #0
 8115eae:	d109      	bne.n	8115ec4 <tcp_recv_null+0x28>
 8115eb0:	4b12      	ldr	r3, [pc, #72]	; (8115efc <tcp_recv_null+0x60>)
 8115eb2:	f44f 62d3 	mov.w	r2, #1688	; 0x698
 8115eb6:	4912      	ldr	r1, [pc, #72]	; (8115f00 <tcp_recv_null+0x64>)
 8115eb8:	4812      	ldr	r0, [pc, #72]	; (8115f04 <tcp_recv_null+0x68>)
 8115eba:	f005 fca1 	bl	811b800 <iprintf>
 8115ebe:	f06f 030f 	mvn.w	r3, #15
 8115ec2:	e016      	b.n	8115ef2 <tcp_recv_null+0x56>

  if (p != NULL) {
 8115ec4:	687b      	ldr	r3, [r7, #4]
 8115ec6:	2b00      	cmp	r3, #0
 8115ec8:	d009      	beq.n	8115ede <tcp_recv_null+0x42>
    tcp_recved(pcb, p->tot_len);
 8115eca:	687b      	ldr	r3, [r7, #4]
 8115ecc:	891b      	ldrh	r3, [r3, #8]
 8115ece:	4619      	mov	r1, r3
 8115ed0:	68b8      	ldr	r0, [r7, #8]
 8115ed2:	f7ff fb19 	bl	8115508 <tcp_recved>
    pbuf_free(p);
 8115ed6:	6878      	ldr	r0, [r7, #4]
 8115ed8:	f7fe fbbe 	bl	8114658 <pbuf_free>
 8115edc:	e008      	b.n	8115ef0 <tcp_recv_null+0x54>
  } else if (err == ERR_OK) {
 8115ede:	f997 3003 	ldrsb.w	r3, [r7, #3]
 8115ee2:	2b00      	cmp	r3, #0
 8115ee4:	d104      	bne.n	8115ef0 <tcp_recv_null+0x54>
    return tcp_close(pcb);
 8115ee6:	68b8      	ldr	r0, [r7, #8]
 8115ee8:	f7ff f9be 	bl	8115268 <tcp_close>
 8115eec:	4603      	mov	r3, r0
 8115eee:	e000      	b.n	8115ef2 <tcp_recv_null+0x56>
  }
  return ERR_OK;
 8115ef0:	2300      	movs	r3, #0
}
 8115ef2:	4618      	mov	r0, r3
 8115ef4:	3710      	adds	r7, #16
 8115ef6:	46bd      	mov	sp, r7
 8115ef8:	bd80      	pop	{r7, pc}
 8115efa:	bf00      	nop
 8115efc:	0811df48 	.word	0x0811df48
 8115f00:	0811e4ec 	.word	0x0811e4ec
 8115f04:	0811dfc0 	.word	0x0811dfc0

08115f08 <tcp_kill_prio>:
 *
 * @param prio minimum priority
 */
static void
tcp_kill_prio(u8_t prio)
{
 8115f08:	b580      	push	{r7, lr}
 8115f0a:	b086      	sub	sp, #24
 8115f0c:	af00      	add	r7, sp, #0
 8115f0e:	4603      	mov	r3, r0
 8115f10:	71fb      	strb	r3, [r7, #7]
  struct tcp_pcb *pcb, *inactive;
  u32_t inactivity;
  u8_t mprio;

  mprio = LWIP_MIN(TCP_PRIO_MAX, prio);
 8115f12:	f997 3007 	ldrsb.w	r3, [r7, #7]
 8115f16:	2b00      	cmp	r3, #0
 8115f18:	db01      	blt.n	8115f1e <tcp_kill_prio+0x16>
 8115f1a:	79fb      	ldrb	r3, [r7, #7]
 8115f1c:	e000      	b.n	8115f20 <tcp_kill_prio+0x18>
 8115f1e:	237f      	movs	r3, #127	; 0x7f
 8115f20:	72fb      	strb	r3, [r7, #11]

  /* We want to kill connections with a lower prio, so bail out if 
   * supplied prio is 0 - there can never be a lower prio
   */
  if (mprio == 0) {
 8115f22:	7afb      	ldrb	r3, [r7, #11]
 8115f24:	2b00      	cmp	r3, #0
 8115f26:	d034      	beq.n	8115f92 <tcp_kill_prio+0x8a>
  /* We only want kill connections with a lower prio, so decrement prio by one 
   * and start searching for oldest connection with same or lower priority than mprio.
   * We want to find the connections with the lowest possible prio, and among
   * these the one with the longest inactivity time.
   */
  mprio--;
 8115f28:	7afb      	ldrb	r3, [r7, #11]
 8115f2a:	3b01      	subs	r3, #1
 8115f2c:	72fb      	strb	r3, [r7, #11]

  inactivity = 0;
 8115f2e:	2300      	movs	r3, #0
 8115f30:	60fb      	str	r3, [r7, #12]
  inactive = NULL;
 8115f32:	2300      	movs	r3, #0
 8115f34:	613b      	str	r3, [r7, #16]
  for (pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
 8115f36:	4b19      	ldr	r3, [pc, #100]	; (8115f9c <tcp_kill_prio+0x94>)
 8115f38:	681b      	ldr	r3, [r3, #0]
 8115f3a:	617b      	str	r3, [r7, #20]
 8115f3c:	e01f      	b.n	8115f7e <tcp_kill_prio+0x76>
        /* lower prio is always a kill candidate */
    if ((pcb->prio < mprio) ||
 8115f3e:	697b      	ldr	r3, [r7, #20]
 8115f40:	7d5b      	ldrb	r3, [r3, #21]
 8115f42:	7afa      	ldrb	r2, [r7, #11]
 8115f44:	429a      	cmp	r2, r3
 8115f46:	d80c      	bhi.n	8115f62 <tcp_kill_prio+0x5a>
        /* longer inactivity is also a kill candidate */
        ((pcb->prio == mprio) && ((u32_t)(tcp_ticks - pcb->tmr) >= inactivity))) {
 8115f48:	697b      	ldr	r3, [r7, #20]
 8115f4a:	7d5b      	ldrb	r3, [r3, #21]
    if ((pcb->prio < mprio) ||
 8115f4c:	7afa      	ldrb	r2, [r7, #11]
 8115f4e:	429a      	cmp	r2, r3
 8115f50:	d112      	bne.n	8115f78 <tcp_kill_prio+0x70>
        ((pcb->prio == mprio) && ((u32_t)(tcp_ticks - pcb->tmr) >= inactivity))) {
 8115f52:	4b13      	ldr	r3, [pc, #76]	; (8115fa0 <tcp_kill_prio+0x98>)
 8115f54:	681a      	ldr	r2, [r3, #0]
 8115f56:	697b      	ldr	r3, [r7, #20]
 8115f58:	6a1b      	ldr	r3, [r3, #32]
 8115f5a:	1ad3      	subs	r3, r2, r3
 8115f5c:	68fa      	ldr	r2, [r7, #12]
 8115f5e:	429a      	cmp	r2, r3
 8115f60:	d80a      	bhi.n	8115f78 <tcp_kill_prio+0x70>
      inactivity = tcp_ticks - pcb->tmr;
 8115f62:	4b0f      	ldr	r3, [pc, #60]	; (8115fa0 <tcp_kill_prio+0x98>)
 8115f64:	681a      	ldr	r2, [r3, #0]
 8115f66:	697b      	ldr	r3, [r7, #20]
 8115f68:	6a1b      	ldr	r3, [r3, #32]
 8115f6a:	1ad3      	subs	r3, r2, r3
 8115f6c:	60fb      	str	r3, [r7, #12]
      inactive   = pcb;
 8115f6e:	697b      	ldr	r3, [r7, #20]
 8115f70:	613b      	str	r3, [r7, #16]
      mprio      = pcb->prio;
 8115f72:	697b      	ldr	r3, [r7, #20]
 8115f74:	7d5b      	ldrb	r3, [r3, #21]
 8115f76:	72fb      	strb	r3, [r7, #11]
  for (pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
 8115f78:	697b      	ldr	r3, [r7, #20]
 8115f7a:	68db      	ldr	r3, [r3, #12]
 8115f7c:	617b      	str	r3, [r7, #20]
 8115f7e:	697b      	ldr	r3, [r7, #20]
 8115f80:	2b00      	cmp	r3, #0
 8115f82:	d1dc      	bne.n	8115f3e <tcp_kill_prio+0x36>
    }
  }
  if (inactive != NULL) {
 8115f84:	693b      	ldr	r3, [r7, #16]
 8115f86:	2b00      	cmp	r3, #0
 8115f88:	d004      	beq.n	8115f94 <tcp_kill_prio+0x8c>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_kill_prio: killing oldest PCB %p (%"S32_F")\n",
                            (void *)inactive, inactivity));
    tcp_abort(inactive);
 8115f8a:	6938      	ldr	r0, [r7, #16]
 8115f8c:	f7ff fa56 	bl	811543c <tcp_abort>
 8115f90:	e000      	b.n	8115f94 <tcp_kill_prio+0x8c>
    return;
 8115f92:	bf00      	nop
  }
}
 8115f94:	3718      	adds	r7, #24
 8115f96:	46bd      	mov	sp, r7
 8115f98:	bd80      	pop	{r7, pc}
 8115f9a:	bf00      	nop
 8115f9c:	10008454 	.word	0x10008454
 8115fa0:	10008448 	.word	0x10008448

08115fa4 <tcp_kill_state>:
 * Kills the oldest connection that is in specific state.
 * Called from tcp_alloc() for LAST_ACK and CLOSING if no more connections are available.
 */
static void
tcp_kill_state(enum tcp_state state)
{
 8115fa4:	b580      	push	{r7, lr}
 8115fa6:	b086      	sub	sp, #24
 8115fa8:	af00      	add	r7, sp, #0
 8115faa:	4603      	mov	r3, r0
 8115fac:	71fb      	strb	r3, [r7, #7]
  struct tcp_pcb *pcb, *inactive;
  u32_t inactivity;

  LWIP_ASSERT("invalid state", (state == CLOSING) || (state == LAST_ACK));
 8115fae:	79fb      	ldrb	r3, [r7, #7]
 8115fb0:	2b08      	cmp	r3, #8
 8115fb2:	d009      	beq.n	8115fc8 <tcp_kill_state+0x24>
 8115fb4:	79fb      	ldrb	r3, [r7, #7]
 8115fb6:	2b09      	cmp	r3, #9
 8115fb8:	d006      	beq.n	8115fc8 <tcp_kill_state+0x24>
 8115fba:	4b1a      	ldr	r3, [pc, #104]	; (8116024 <tcp_kill_state+0x80>)
 8115fbc:	f240 62dd 	movw	r2, #1757	; 0x6dd
 8115fc0:	4919      	ldr	r1, [pc, #100]	; (8116028 <tcp_kill_state+0x84>)
 8115fc2:	481a      	ldr	r0, [pc, #104]	; (811602c <tcp_kill_state+0x88>)
 8115fc4:	f005 fc1c 	bl	811b800 <iprintf>

  inactivity = 0;
 8115fc8:	2300      	movs	r3, #0
 8115fca:	60fb      	str	r3, [r7, #12]
  inactive = NULL;
 8115fcc:	2300      	movs	r3, #0
 8115fce:	613b      	str	r3, [r7, #16]
  /* Go through the list of active pcbs and get the oldest pcb that is in state
     CLOSING/LAST_ACK. */
  for (pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
 8115fd0:	4b17      	ldr	r3, [pc, #92]	; (8116030 <tcp_kill_state+0x8c>)
 8115fd2:	681b      	ldr	r3, [r3, #0]
 8115fd4:	617b      	str	r3, [r7, #20]
 8115fd6:	e017      	b.n	8116008 <tcp_kill_state+0x64>
    if (pcb->state == state) {
 8115fd8:	697b      	ldr	r3, [r7, #20]
 8115fda:	7d1b      	ldrb	r3, [r3, #20]
 8115fdc:	79fa      	ldrb	r2, [r7, #7]
 8115fde:	429a      	cmp	r2, r3
 8115fe0:	d10f      	bne.n	8116002 <tcp_kill_state+0x5e>
      if ((u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
 8115fe2:	4b14      	ldr	r3, [pc, #80]	; (8116034 <tcp_kill_state+0x90>)
 8115fe4:	681a      	ldr	r2, [r3, #0]
 8115fe6:	697b      	ldr	r3, [r7, #20]
 8115fe8:	6a1b      	ldr	r3, [r3, #32]
 8115fea:	1ad3      	subs	r3, r2, r3
 8115fec:	68fa      	ldr	r2, [r7, #12]
 8115fee:	429a      	cmp	r2, r3
 8115ff0:	d807      	bhi.n	8116002 <tcp_kill_state+0x5e>
        inactivity = tcp_ticks - pcb->tmr;
 8115ff2:	4b10      	ldr	r3, [pc, #64]	; (8116034 <tcp_kill_state+0x90>)
 8115ff4:	681a      	ldr	r2, [r3, #0]
 8115ff6:	697b      	ldr	r3, [r7, #20]
 8115ff8:	6a1b      	ldr	r3, [r3, #32]
 8115ffa:	1ad3      	subs	r3, r2, r3
 8115ffc:	60fb      	str	r3, [r7, #12]
        inactive = pcb;
 8115ffe:	697b      	ldr	r3, [r7, #20]
 8116000:	613b      	str	r3, [r7, #16]
  for (pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
 8116002:	697b      	ldr	r3, [r7, #20]
 8116004:	68db      	ldr	r3, [r3, #12]
 8116006:	617b      	str	r3, [r7, #20]
 8116008:	697b      	ldr	r3, [r7, #20]
 811600a:	2b00      	cmp	r3, #0
 811600c:	d1e4      	bne.n	8115fd8 <tcp_kill_state+0x34>
      }
    }
  }
  if (inactive != NULL) {
 811600e:	693b      	ldr	r3, [r7, #16]
 8116010:	2b00      	cmp	r3, #0
 8116012:	d003      	beq.n	811601c <tcp_kill_state+0x78>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_kill_closing: killing oldest %s PCB %p (%"S32_F")\n",
                            tcp_state_str[state], (void *)inactive, inactivity));
    /* Don't send a RST, since no data is lost. */
    tcp_abandon(inactive, 0);
 8116014:	2100      	movs	r1, #0
 8116016:	6938      	ldr	r0, [r7, #16]
 8116018:	f7ff f952 	bl	81152c0 <tcp_abandon>
  }
}
 811601c:	bf00      	nop
 811601e:	3718      	adds	r7, #24
 8116020:	46bd      	mov	sp, r7
 8116022:	bd80      	pop	{r7, pc}
 8116024:	0811df48 	.word	0x0811df48
 8116028:	0811e508 	.word	0x0811e508
 811602c:	0811dfc0 	.word	0x0811dfc0
 8116030:	10008454 	.word	0x10008454
 8116034:	10008448 	.word	0x10008448

08116038 <tcp_kill_timewait>:
 * Kills the oldest connection that is in TIME_WAIT state.
 * Called from tcp_alloc() if no more connections are available.
 */
static void
tcp_kill_timewait(void)
{
 8116038:	b580      	push	{r7, lr}
 811603a:	b084      	sub	sp, #16
 811603c:	af00      	add	r7, sp, #0
  struct tcp_pcb *pcb, *inactive;
  u32_t inactivity;

  inactivity = 0;
 811603e:	2300      	movs	r3, #0
 8116040:	607b      	str	r3, [r7, #4]
  inactive = NULL;
 8116042:	2300      	movs	r3, #0
 8116044:	60bb      	str	r3, [r7, #8]
  /* Go through the list of TIME_WAIT pcbs and get the oldest pcb. */
  for (pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
 8116046:	4b12      	ldr	r3, [pc, #72]	; (8116090 <tcp_kill_timewait+0x58>)
 8116048:	681b      	ldr	r3, [r3, #0]
 811604a:	60fb      	str	r3, [r7, #12]
 811604c:	e012      	b.n	8116074 <tcp_kill_timewait+0x3c>
    if ((u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
 811604e:	4b11      	ldr	r3, [pc, #68]	; (8116094 <tcp_kill_timewait+0x5c>)
 8116050:	681a      	ldr	r2, [r3, #0]
 8116052:	68fb      	ldr	r3, [r7, #12]
 8116054:	6a1b      	ldr	r3, [r3, #32]
 8116056:	1ad3      	subs	r3, r2, r3
 8116058:	687a      	ldr	r2, [r7, #4]
 811605a:	429a      	cmp	r2, r3
 811605c:	d807      	bhi.n	811606e <tcp_kill_timewait+0x36>
      inactivity = tcp_ticks - pcb->tmr;
 811605e:	4b0d      	ldr	r3, [pc, #52]	; (8116094 <tcp_kill_timewait+0x5c>)
 8116060:	681a      	ldr	r2, [r3, #0]
 8116062:	68fb      	ldr	r3, [r7, #12]
 8116064:	6a1b      	ldr	r3, [r3, #32]
 8116066:	1ad3      	subs	r3, r2, r3
 8116068:	607b      	str	r3, [r7, #4]
      inactive = pcb;
 811606a:	68fb      	ldr	r3, [r7, #12]
 811606c:	60bb      	str	r3, [r7, #8]
  for (pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
 811606e:	68fb      	ldr	r3, [r7, #12]
 8116070:	68db      	ldr	r3, [r3, #12]
 8116072:	60fb      	str	r3, [r7, #12]
 8116074:	68fb      	ldr	r3, [r7, #12]
 8116076:	2b00      	cmp	r3, #0
 8116078:	d1e9      	bne.n	811604e <tcp_kill_timewait+0x16>
    }
  }
  if (inactive != NULL) {
 811607a:	68bb      	ldr	r3, [r7, #8]
 811607c:	2b00      	cmp	r3, #0
 811607e:	d002      	beq.n	8116086 <tcp_kill_timewait+0x4e>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_kill_timewait: killing oldest TIME-WAIT PCB %p (%"S32_F")\n",
                            (void *)inactive, inactivity));
    tcp_abort(inactive);
 8116080:	68b8      	ldr	r0, [r7, #8]
 8116082:	f7ff f9db 	bl	811543c <tcp_abort>
  }
}
 8116086:	bf00      	nop
 8116088:	3710      	adds	r7, #16
 811608a:	46bd      	mov	sp, r7
 811608c:	bd80      	pop	{r7, pc}
 811608e:	bf00      	nop
 8116090:	10008458 	.word	0x10008458
 8116094:	10008448 	.word	0x10008448

08116098 <tcp_handle_closepend>:
 * now send the FIN (which failed before), the pcb might be in a state that is
 * OK for us to now free it.
 */
static void
tcp_handle_closepend(void)
{
 8116098:	b580      	push	{r7, lr}
 811609a:	b082      	sub	sp, #8
 811609c:	af00      	add	r7, sp, #0
  struct tcp_pcb *pcb = tcp_active_pcbs;
 811609e:	4b10      	ldr	r3, [pc, #64]	; (81160e0 <tcp_handle_closepend+0x48>)
 81160a0:	681b      	ldr	r3, [r3, #0]
 81160a2:	607b      	str	r3, [r7, #4]

  while (pcb != NULL) {
 81160a4:	e014      	b.n	81160d0 <tcp_handle_closepend+0x38>
    struct tcp_pcb *next = pcb->next;
 81160a6:	687b      	ldr	r3, [r7, #4]
 81160a8:	68db      	ldr	r3, [r3, #12]
 81160aa:	603b      	str	r3, [r7, #0]
    /* send pending FIN */
    if (pcb->flags & TF_CLOSEPEND) {
 81160ac:	687b      	ldr	r3, [r7, #4]
 81160ae:	8b5b      	ldrh	r3, [r3, #26]
 81160b0:	f003 0308 	and.w	r3, r3, #8
 81160b4:	2b00      	cmp	r3, #0
 81160b6:	d009      	beq.n	81160cc <tcp_handle_closepend+0x34>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_handle_closepend: pending FIN\n"));
      tcp_clear_flags(pcb, TF_CLOSEPEND);
 81160b8:	687b      	ldr	r3, [r7, #4]
 81160ba:	8b5b      	ldrh	r3, [r3, #26]
 81160bc:	f023 0308 	bic.w	r3, r3, #8
 81160c0:	b29a      	uxth	r2, r3
 81160c2:	687b      	ldr	r3, [r7, #4]
 81160c4:	835a      	strh	r2, [r3, #26]
      tcp_close_shutdown_fin(pcb);
 81160c6:	6878      	ldr	r0, [r7, #4]
 81160c8:	f7ff f864 	bl	8115194 <tcp_close_shutdown_fin>
    }
    pcb = next;
 81160cc:	683b      	ldr	r3, [r7, #0]
 81160ce:	607b      	str	r3, [r7, #4]
  while (pcb != NULL) {
 81160d0:	687b      	ldr	r3, [r7, #4]
 81160d2:	2b00      	cmp	r3, #0
 81160d4:	d1e7      	bne.n	81160a6 <tcp_handle_closepend+0xe>
  }
}
 81160d6:	bf00      	nop
 81160d8:	bf00      	nop
 81160da:	3708      	adds	r7, #8
 81160dc:	46bd      	mov	sp, r7
 81160de:	bd80      	pop	{r7, pc}
 81160e0:	10008454 	.word	0x10008454

081160e4 <tcp_alloc>:
 * @param prio priority for the new pcb
 * @return a new tcp_pcb that initially is in state CLOSED
 */
struct tcp_pcb *
tcp_alloc(u8_t prio)
{
 81160e4:	b580      	push	{r7, lr}
 81160e6:	b084      	sub	sp, #16
 81160e8:	af00      	add	r7, sp, #0
 81160ea:	4603      	mov	r3, r0
 81160ec:	71fb      	strb	r3, [r7, #7]
  struct tcp_pcb *pcb;

  LWIP_ASSERT_CORE_LOCKED();

  pcb = (struct tcp_pcb *)memp_malloc(MEMP_TCP_PCB);
 81160ee:	2001      	movs	r0, #1
 81160f0:	f7fd fbe0 	bl	81138b4 <memp_malloc>
 81160f4:	60f8      	str	r0, [r7, #12]
  if (pcb == NULL) {
 81160f6:	68fb      	ldr	r3, [r7, #12]
 81160f8:	2b00      	cmp	r3, #0
 81160fa:	d126      	bne.n	811614a <tcp_alloc+0x66>
    /* Try to send FIN for all pcbs stuck in TF_CLOSEPEND first */
    tcp_handle_closepend();
 81160fc:	f7ff ffcc 	bl	8116098 <tcp_handle_closepend>

    /* Try killing oldest connection in TIME-WAIT. */
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_alloc: killing off oldest TIME-WAIT connection\n"));
    tcp_kill_timewait();
 8116100:	f7ff ff9a 	bl	8116038 <tcp_kill_timewait>
    /* Try to allocate a tcp_pcb again. */
    pcb = (struct tcp_pcb *)memp_malloc(MEMP_TCP_PCB);
 8116104:	2001      	movs	r0, #1
 8116106:	f7fd fbd5 	bl	81138b4 <memp_malloc>
 811610a:	60f8      	str	r0, [r7, #12]
    if (pcb == NULL) {
 811610c:	68fb      	ldr	r3, [r7, #12]
 811610e:	2b00      	cmp	r3, #0
 8116110:	d11b      	bne.n	811614a <tcp_alloc+0x66>
      /* Try killing oldest connection in LAST-ACK (these wouldn't go to TIME-WAIT). */
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_alloc: killing off oldest LAST-ACK connection\n"));
      tcp_kill_state(LAST_ACK);
 8116112:	2009      	movs	r0, #9
 8116114:	f7ff ff46 	bl	8115fa4 <tcp_kill_state>
      /* Try to allocate a tcp_pcb again. */
      pcb = (struct tcp_pcb *)memp_malloc(MEMP_TCP_PCB);
 8116118:	2001      	movs	r0, #1
 811611a:	f7fd fbcb 	bl	81138b4 <memp_malloc>
 811611e:	60f8      	str	r0, [r7, #12]
      if (pcb == NULL) {
 8116120:	68fb      	ldr	r3, [r7, #12]
 8116122:	2b00      	cmp	r3, #0
 8116124:	d111      	bne.n	811614a <tcp_alloc+0x66>
        /* Try killing oldest connection in CLOSING. */
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_alloc: killing off oldest CLOSING connection\n"));
        tcp_kill_state(CLOSING);
 8116126:	2008      	movs	r0, #8
 8116128:	f7ff ff3c 	bl	8115fa4 <tcp_kill_state>
        /* Try to allocate a tcp_pcb again. */
        pcb = (struct tcp_pcb *)memp_malloc(MEMP_TCP_PCB);
 811612c:	2001      	movs	r0, #1
 811612e:	f7fd fbc1 	bl	81138b4 <memp_malloc>
 8116132:	60f8      	str	r0, [r7, #12]
        if (pcb == NULL) {
 8116134:	68fb      	ldr	r3, [r7, #12]
 8116136:	2b00      	cmp	r3, #0
 8116138:	d107      	bne.n	811614a <tcp_alloc+0x66>
          /* Try killing oldest active connection with lower priority than the new one. */
          LWIP_DEBUGF(TCP_DEBUG, ("tcp_alloc: killing oldest connection with prio lower than %d\n", prio));
          tcp_kill_prio(prio);
 811613a:	79fb      	ldrb	r3, [r7, #7]
 811613c:	4618      	mov	r0, r3
 811613e:	f7ff fee3 	bl	8115f08 <tcp_kill_prio>
          /* Try to allocate a tcp_pcb again. */
          pcb = (struct tcp_pcb *)memp_malloc(MEMP_TCP_PCB);
 8116142:	2001      	movs	r0, #1
 8116144:	f7fd fbb6 	bl	81138b4 <memp_malloc>
 8116148:	60f8      	str	r0, [r7, #12]
    if (pcb != NULL) {
      /* adjust err stats: memp_malloc failed above */
      MEMP_STATS_DEC(err, MEMP_TCP_PCB);
    }
  }
  if (pcb != NULL) {
 811614a:	68fb      	ldr	r3, [r7, #12]
 811614c:	2b00      	cmp	r3, #0
 811614e:	d03f      	beq.n	81161d0 <tcp_alloc+0xec>
    /* zero out the whole pcb, so there is no need to initialize members to zero */
    memset(pcb, 0, sizeof(struct tcp_pcb));
 8116150:	229c      	movs	r2, #156	; 0x9c
 8116152:	2100      	movs	r1, #0
 8116154:	68f8      	ldr	r0, [r7, #12]
 8116156:	f005 fb7d 	bl	811b854 <memset>
    pcb->prio = prio;
 811615a:	68fb      	ldr	r3, [r7, #12]
 811615c:	79fa      	ldrb	r2, [r7, #7]
 811615e:	755a      	strb	r2, [r3, #21]
    pcb->snd_buf = TCP_SND_BUF;
 8116160:	68fb      	ldr	r3, [r7, #12]
 8116162:	f44f 6286 	mov.w	r2, #1072	; 0x430
 8116166:	f8a3 2064 	strh.w	r2, [r3, #100]	; 0x64
    /* Start with a window that does not need scaling. When window scaling is
       enabled and used, the window is enlarged when both sides agree on scaling. */
    pcb->rcv_wnd = pcb->rcv_ann_wnd = TCPWND_MIN16(TCP_WND);
 811616a:	68fb      	ldr	r3, [r7, #12]
 811616c:	f44f 6206 	mov.w	r2, #2144	; 0x860
 8116170:	855a      	strh	r2, [r3, #42]	; 0x2a
 8116172:	68fb      	ldr	r3, [r7, #12]
 8116174:	8d5a      	ldrh	r2, [r3, #42]	; 0x2a
 8116176:	68fb      	ldr	r3, [r7, #12]
 8116178:	851a      	strh	r2, [r3, #40]	; 0x28
    pcb->ttl = TCP_TTL;
 811617a:	68fb      	ldr	r3, [r7, #12]
 811617c:	22ff      	movs	r2, #255	; 0xff
 811617e:	72da      	strb	r2, [r3, #11]
    /* As initial send MSS, we use TCP_MSS but limit it to 536.
       The send MSS is updated when an MSS option is received. */
    pcb->mss = INITIAL_MSS;
 8116180:	68fb      	ldr	r3, [r7, #12]
 8116182:	f44f 7206 	mov.w	r2, #536	; 0x218
 8116186:	865a      	strh	r2, [r3, #50]	; 0x32
    pcb->rto = 3000 / TCP_SLOW_INTERVAL;
 8116188:	68fb      	ldr	r3, [r7, #12]
 811618a:	2206      	movs	r2, #6
 811618c:	f8a3 2040 	strh.w	r2, [r3, #64]	; 0x40
    pcb->sv = 3000 / TCP_SLOW_INTERVAL;
 8116190:	68fb      	ldr	r3, [r7, #12]
 8116192:	2206      	movs	r2, #6
 8116194:	87da      	strh	r2, [r3, #62]	; 0x3e
    pcb->rtime = -1;
 8116196:	68fb      	ldr	r3, [r7, #12]
 8116198:	f64f 72ff 	movw	r2, #65535	; 0xffff
 811619c:	861a      	strh	r2, [r3, #48]	; 0x30
    pcb->cwnd = 1;
 811619e:	68fb      	ldr	r3, [r7, #12]
 81161a0:	2201      	movs	r2, #1
 81161a2:	f8a3 2048 	strh.w	r2, [r3, #72]	; 0x48
    pcb->tmr = tcp_ticks;
 81161a6:	4b0d      	ldr	r3, [pc, #52]	; (81161dc <tcp_alloc+0xf8>)
 81161a8:	681a      	ldr	r2, [r3, #0]
 81161aa:	68fb      	ldr	r3, [r7, #12]
 81161ac:	621a      	str	r2, [r3, #32]
    pcb->last_timer = tcp_timer_ctr;
 81161ae:	4b0c      	ldr	r3, [pc, #48]	; (81161e0 <tcp_alloc+0xfc>)
 81161b0:	781a      	ldrb	r2, [r3, #0]
 81161b2:	68fb      	ldr	r3, [r7, #12]
 81161b4:	779a      	strb	r2, [r3, #30]
    of using the largest advertised receive window.  We've seen complications with
    receiving TCPs that use window scaling and/or window auto-tuning where the
    initial advertised window is very small and then grows rapidly once the
    connection is established. To avoid these complications, we set ssthresh to the
    largest effective cwnd (amount of in-flight data) that the sender can have. */
    pcb->ssthresh = TCP_SND_BUF;
 81161b6:	68fb      	ldr	r3, [r7, #12]
 81161b8:	f44f 6286 	mov.w	r2, #1072	; 0x430
 81161bc:	f8a3 204a 	strh.w	r2, [r3, #74]	; 0x4a

#if LWIP_CALLBACK_API
    pcb->recv = tcp_recv_null;
 81161c0:	68fb      	ldr	r3, [r7, #12]
 81161c2:	4a08      	ldr	r2, [pc, #32]	; (81161e4 <tcp_alloc+0x100>)
 81161c4:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
#endif /* LWIP_CALLBACK_API */

    /* Init KEEPALIVE timer */
    pcb->keep_idle  = TCP_KEEPIDLE_DEFAULT;
 81161c8:	68fb      	ldr	r3, [r7, #12]
 81161ca:	4a07      	ldr	r2, [pc, #28]	; (81161e8 <tcp_alloc+0x104>)
 81161cc:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94
#if LWIP_TCP_KEEPALIVE
    pcb->keep_intvl = TCP_KEEPINTVL_DEFAULT;
    pcb->keep_cnt   = TCP_KEEPCNT_DEFAULT;
#endif /* LWIP_TCP_KEEPALIVE */
  }
  return pcb;
 81161d0:	68fb      	ldr	r3, [r7, #12]
}
 81161d2:	4618      	mov	r0, r3
 81161d4:	3710      	adds	r7, #16
 81161d6:	46bd      	mov	sp, r7
 81161d8:	bd80      	pop	{r7, pc}
 81161da:	bf00      	nop
 81161dc:	10008448 	.word	0x10008448
 81161e0:	1000845e 	.word	0x1000845e
 81161e4:	08115e9d 	.word	0x08115e9d
 81161e8:	006ddd00 	.word	0x006ddd00

081161ec <tcp_pcb_purge>:
 *
 * @param pcb tcp_pcb to purge. The pcb itself is not deallocated!
 */
void
tcp_pcb_purge(struct tcp_pcb *pcb)
{
 81161ec:	b580      	push	{r7, lr}
 81161ee:	b082      	sub	sp, #8
 81161f0:	af00      	add	r7, sp, #0
 81161f2:	6078      	str	r0, [r7, #4]
  LWIP_ERROR("tcp_pcb_purge: invalid pcb", pcb != NULL, return);
 81161f4:	687b      	ldr	r3, [r7, #4]
 81161f6:	2b00      	cmp	r3, #0
 81161f8:	d107      	bne.n	811620a <tcp_pcb_purge+0x1e>
 81161fa:	4b21      	ldr	r3, [pc, #132]	; (8116280 <tcp_pcb_purge+0x94>)
 81161fc:	f640 0251 	movw	r2, #2129	; 0x851
 8116200:	4920      	ldr	r1, [pc, #128]	; (8116284 <tcp_pcb_purge+0x98>)
 8116202:	4821      	ldr	r0, [pc, #132]	; (8116288 <tcp_pcb_purge+0x9c>)
 8116204:	f005 fafc 	bl	811b800 <iprintf>
 8116208:	e037      	b.n	811627a <tcp_pcb_purge+0x8e>

  if (pcb->state != CLOSED &&
 811620a:	687b      	ldr	r3, [r7, #4]
 811620c:	7d1b      	ldrb	r3, [r3, #20]
 811620e:	2b00      	cmp	r3, #0
 8116210:	d033      	beq.n	811627a <tcp_pcb_purge+0x8e>
      pcb->state != TIME_WAIT &&
 8116212:	687b      	ldr	r3, [r7, #4]
 8116214:	7d1b      	ldrb	r3, [r3, #20]
  if (pcb->state != CLOSED &&
 8116216:	2b0a      	cmp	r3, #10
 8116218:	d02f      	beq.n	811627a <tcp_pcb_purge+0x8e>
      pcb->state != LISTEN) {
 811621a:	687b      	ldr	r3, [r7, #4]
 811621c:	7d1b      	ldrb	r3, [r3, #20]
      pcb->state != TIME_WAIT &&
 811621e:	2b01      	cmp	r3, #1
 8116220:	d02b      	beq.n	811627a <tcp_pcb_purge+0x8e>

    LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge\n"));

    tcp_backlog_accepted(pcb);

    if (pcb->refused_data != NULL) {
 8116222:	687b      	ldr	r3, [r7, #4]
 8116224:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 8116226:	2b00      	cmp	r3, #0
 8116228:	d007      	beq.n	811623a <tcp_pcb_purge+0x4e>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge: data left on ->refused_data\n"));
      pbuf_free(pcb->refused_data);
 811622a:	687b      	ldr	r3, [r7, #4]
 811622c:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 811622e:	4618      	mov	r0, r3
 8116230:	f7fe fa12 	bl	8114658 <pbuf_free>
      pcb->refused_data = NULL;
 8116234:	687b      	ldr	r3, [r7, #4]
 8116236:	2200      	movs	r2, #0
 8116238:	679a      	str	r2, [r3, #120]	; 0x78
    }
    if (pcb->unacked != NULL) {
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge: data left on ->unacked\n"));
    }
#if TCP_QUEUE_OOSEQ
    if (pcb->ooseq != NULL) {
 811623a:	687b      	ldr	r3, [r7, #4]
 811623c:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 811623e:	2b00      	cmp	r3, #0
 8116240:	d002      	beq.n	8116248 <tcp_pcb_purge+0x5c>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge: data left on ->ooseq\n"));
      tcp_free_ooseq(pcb);
 8116242:	6878      	ldr	r0, [r7, #4]
 8116244:	f000 f986 	bl	8116554 <tcp_free_ooseq>
    }
#endif /* TCP_QUEUE_OOSEQ */

    /* Stop the retransmission timer as it will expect data on unacked
       queue if it fires */
    pcb->rtime = -1;
 8116248:	687b      	ldr	r3, [r7, #4]
 811624a:	f64f 72ff 	movw	r2, #65535	; 0xffff
 811624e:	861a      	strh	r2, [r3, #48]	; 0x30

    tcp_segs_free(pcb->unsent);
 8116250:	687b      	ldr	r3, [r7, #4]
 8116252:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 8116254:	4618      	mov	r0, r3
 8116256:	f7ff fdc7 	bl	8115de8 <tcp_segs_free>
    tcp_segs_free(pcb->unacked);
 811625a:	687b      	ldr	r3, [r7, #4]
 811625c:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 811625e:	4618      	mov	r0, r3
 8116260:	f7ff fdc2 	bl	8115de8 <tcp_segs_free>
    pcb->unacked = pcb->unsent = NULL;
 8116264:	687b      	ldr	r3, [r7, #4]
 8116266:	2200      	movs	r2, #0
 8116268:	66da      	str	r2, [r3, #108]	; 0x6c
 811626a:	687b      	ldr	r3, [r7, #4]
 811626c:	6eda      	ldr	r2, [r3, #108]	; 0x6c
 811626e:	687b      	ldr	r3, [r7, #4]
 8116270:	671a      	str	r2, [r3, #112]	; 0x70
#if TCP_OVERSIZE
    pcb->unsent_oversize = 0;
 8116272:	687b      	ldr	r3, [r7, #4]
 8116274:	2200      	movs	r2, #0
 8116276:	f8a3 2068 	strh.w	r2, [r3, #104]	; 0x68
#endif /* TCP_OVERSIZE */
  }
}
 811627a:	3708      	adds	r7, #8
 811627c:	46bd      	mov	sp, r7
 811627e:	bd80      	pop	{r7, pc}
 8116280:	0811df48 	.word	0x0811df48
 8116284:	0811e5c8 	.word	0x0811e5c8
 8116288:	0811dfc0 	.word	0x0811dfc0

0811628c <tcp_pcb_remove>:
 * @param pcblist PCB list to purge.
 * @param pcb tcp_pcb to purge. The pcb itself is NOT deallocated!
 */
void
tcp_pcb_remove(struct tcp_pcb **pcblist, struct tcp_pcb *pcb)
{
 811628c:	b580      	push	{r7, lr}
 811628e:	b084      	sub	sp, #16
 8116290:	af00      	add	r7, sp, #0
 8116292:	6078      	str	r0, [r7, #4]
 8116294:	6039      	str	r1, [r7, #0]
  LWIP_ASSERT("tcp_pcb_remove: invalid pcb", pcb != NULL);
 8116296:	683b      	ldr	r3, [r7, #0]
 8116298:	2b00      	cmp	r3, #0
 811629a:	d106      	bne.n	81162aa <tcp_pcb_remove+0x1e>
 811629c:	4b3e      	ldr	r3, [pc, #248]	; (8116398 <tcp_pcb_remove+0x10c>)
 811629e:	f640 0283 	movw	r2, #2179	; 0x883
 81162a2:	493e      	ldr	r1, [pc, #248]	; (811639c <tcp_pcb_remove+0x110>)
 81162a4:	483e      	ldr	r0, [pc, #248]	; (81163a0 <tcp_pcb_remove+0x114>)
 81162a6:	f005 faab 	bl	811b800 <iprintf>
  LWIP_ASSERT("tcp_pcb_remove: invalid pcblist", pcblist != NULL);
 81162aa:	687b      	ldr	r3, [r7, #4]
 81162ac:	2b00      	cmp	r3, #0
 81162ae:	d106      	bne.n	81162be <tcp_pcb_remove+0x32>
 81162b0:	4b39      	ldr	r3, [pc, #228]	; (8116398 <tcp_pcb_remove+0x10c>)
 81162b2:	f640 0284 	movw	r2, #2180	; 0x884
 81162b6:	493b      	ldr	r1, [pc, #236]	; (81163a4 <tcp_pcb_remove+0x118>)
 81162b8:	4839      	ldr	r0, [pc, #228]	; (81163a0 <tcp_pcb_remove+0x114>)
 81162ba:	f005 faa1 	bl	811b800 <iprintf>

  TCP_RMV(pcblist, pcb);
 81162be:	687b      	ldr	r3, [r7, #4]
 81162c0:	681b      	ldr	r3, [r3, #0]
 81162c2:	683a      	ldr	r2, [r7, #0]
 81162c4:	429a      	cmp	r2, r3
 81162c6:	d105      	bne.n	81162d4 <tcp_pcb_remove+0x48>
 81162c8:	687b      	ldr	r3, [r7, #4]
 81162ca:	681b      	ldr	r3, [r3, #0]
 81162cc:	68da      	ldr	r2, [r3, #12]
 81162ce:	687b      	ldr	r3, [r7, #4]
 81162d0:	601a      	str	r2, [r3, #0]
 81162d2:	e013      	b.n	81162fc <tcp_pcb_remove+0x70>
 81162d4:	687b      	ldr	r3, [r7, #4]
 81162d6:	681b      	ldr	r3, [r3, #0]
 81162d8:	60fb      	str	r3, [r7, #12]
 81162da:	e00c      	b.n	81162f6 <tcp_pcb_remove+0x6a>
 81162dc:	68fb      	ldr	r3, [r7, #12]
 81162de:	68db      	ldr	r3, [r3, #12]
 81162e0:	683a      	ldr	r2, [r7, #0]
 81162e2:	429a      	cmp	r2, r3
 81162e4:	d104      	bne.n	81162f0 <tcp_pcb_remove+0x64>
 81162e6:	683b      	ldr	r3, [r7, #0]
 81162e8:	68da      	ldr	r2, [r3, #12]
 81162ea:	68fb      	ldr	r3, [r7, #12]
 81162ec:	60da      	str	r2, [r3, #12]
 81162ee:	e005      	b.n	81162fc <tcp_pcb_remove+0x70>
 81162f0:	68fb      	ldr	r3, [r7, #12]
 81162f2:	68db      	ldr	r3, [r3, #12]
 81162f4:	60fb      	str	r3, [r7, #12]
 81162f6:	68fb      	ldr	r3, [r7, #12]
 81162f8:	2b00      	cmp	r3, #0
 81162fa:	d1ef      	bne.n	81162dc <tcp_pcb_remove+0x50>
 81162fc:	683b      	ldr	r3, [r7, #0]
 81162fe:	2200      	movs	r2, #0
 8116300:	60da      	str	r2, [r3, #12]

  tcp_pcb_purge(pcb);
 8116302:	6838      	ldr	r0, [r7, #0]
 8116304:	f7ff ff72 	bl	81161ec <tcp_pcb_purge>

  /* if there is an outstanding delayed ACKs, send it */
  if ((pcb->state != TIME_WAIT) &&
 8116308:	683b      	ldr	r3, [r7, #0]
 811630a:	7d1b      	ldrb	r3, [r3, #20]
 811630c:	2b0a      	cmp	r3, #10
 811630e:	d013      	beq.n	8116338 <tcp_pcb_remove+0xac>
      (pcb->state != LISTEN) &&
 8116310:	683b      	ldr	r3, [r7, #0]
 8116312:	7d1b      	ldrb	r3, [r3, #20]
  if ((pcb->state != TIME_WAIT) &&
 8116314:	2b01      	cmp	r3, #1
 8116316:	d00f      	beq.n	8116338 <tcp_pcb_remove+0xac>
      (pcb->flags & TF_ACK_DELAY)) {
 8116318:	683b      	ldr	r3, [r7, #0]
 811631a:	8b5b      	ldrh	r3, [r3, #26]
 811631c:	f003 0301 	and.w	r3, r3, #1
      (pcb->state != LISTEN) &&
 8116320:	2b00      	cmp	r3, #0
 8116322:	d009      	beq.n	8116338 <tcp_pcb_remove+0xac>
    tcp_ack_now(pcb);
 8116324:	683b      	ldr	r3, [r7, #0]
 8116326:	8b5b      	ldrh	r3, [r3, #26]
 8116328:	f043 0302 	orr.w	r3, r3, #2
 811632c:	b29a      	uxth	r2, r3
 811632e:	683b      	ldr	r3, [r7, #0]
 8116330:	835a      	strh	r2, [r3, #26]
    tcp_output(pcb);
 8116332:	6838      	ldr	r0, [r7, #0]
 8116334:	f002 ff6e 	bl	8119214 <tcp_output>
  }

  if (pcb->state != LISTEN) {
 8116338:	683b      	ldr	r3, [r7, #0]
 811633a:	7d1b      	ldrb	r3, [r3, #20]
 811633c:	2b01      	cmp	r3, #1
 811633e:	d020      	beq.n	8116382 <tcp_pcb_remove+0xf6>
    LWIP_ASSERT("unsent segments leaking", pcb->unsent == NULL);
 8116340:	683b      	ldr	r3, [r7, #0]
 8116342:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 8116344:	2b00      	cmp	r3, #0
 8116346:	d006      	beq.n	8116356 <tcp_pcb_remove+0xca>
 8116348:	4b13      	ldr	r3, [pc, #76]	; (8116398 <tcp_pcb_remove+0x10c>)
 811634a:	f640 0293 	movw	r2, #2195	; 0x893
 811634e:	4916      	ldr	r1, [pc, #88]	; (81163a8 <tcp_pcb_remove+0x11c>)
 8116350:	4813      	ldr	r0, [pc, #76]	; (81163a0 <tcp_pcb_remove+0x114>)
 8116352:	f005 fa55 	bl	811b800 <iprintf>
    LWIP_ASSERT("unacked segments leaking", pcb->unacked == NULL);
 8116356:	683b      	ldr	r3, [r7, #0]
 8116358:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 811635a:	2b00      	cmp	r3, #0
 811635c:	d006      	beq.n	811636c <tcp_pcb_remove+0xe0>
 811635e:	4b0e      	ldr	r3, [pc, #56]	; (8116398 <tcp_pcb_remove+0x10c>)
 8116360:	f640 0294 	movw	r2, #2196	; 0x894
 8116364:	4911      	ldr	r1, [pc, #68]	; (81163ac <tcp_pcb_remove+0x120>)
 8116366:	480e      	ldr	r0, [pc, #56]	; (81163a0 <tcp_pcb_remove+0x114>)
 8116368:	f005 fa4a 	bl	811b800 <iprintf>
#if TCP_QUEUE_OOSEQ
    LWIP_ASSERT("ooseq segments leaking", pcb->ooseq == NULL);
 811636c:	683b      	ldr	r3, [r7, #0]
 811636e:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 8116370:	2b00      	cmp	r3, #0
 8116372:	d006      	beq.n	8116382 <tcp_pcb_remove+0xf6>
 8116374:	4b08      	ldr	r3, [pc, #32]	; (8116398 <tcp_pcb_remove+0x10c>)
 8116376:	f640 0296 	movw	r2, #2198	; 0x896
 811637a:	490d      	ldr	r1, [pc, #52]	; (81163b0 <tcp_pcb_remove+0x124>)
 811637c:	4808      	ldr	r0, [pc, #32]	; (81163a0 <tcp_pcb_remove+0x114>)
 811637e:	f005 fa3f 	bl	811b800 <iprintf>
#endif /* TCP_QUEUE_OOSEQ */
  }

  pcb->state = CLOSED;
 8116382:	683b      	ldr	r3, [r7, #0]
 8116384:	2200      	movs	r2, #0
 8116386:	751a      	strb	r2, [r3, #20]
  /* reset the local port to prevent the pcb from being 'bound' */
  pcb->local_port = 0;
 8116388:	683b      	ldr	r3, [r7, #0]
 811638a:	2200      	movs	r2, #0
 811638c:	82da      	strh	r2, [r3, #22]

  LWIP_ASSERT("tcp_pcb_remove: tcp_pcbs_sane()", tcp_pcbs_sane());
}
 811638e:	bf00      	nop
 8116390:	3710      	adds	r7, #16
 8116392:	46bd      	mov	sp, r7
 8116394:	bd80      	pop	{r7, pc}
 8116396:	bf00      	nop
 8116398:	0811df48 	.word	0x0811df48
 811639c:	0811e5e4 	.word	0x0811e5e4
 81163a0:	0811dfc0 	.word	0x0811dfc0
 81163a4:	0811e600 	.word	0x0811e600
 81163a8:	0811e620 	.word	0x0811e620
 81163ac:	0811e638 	.word	0x0811e638
 81163b0:	0811e654 	.word	0x0811e654

081163b4 <tcp_next_iss>:
 *
 * @return u32_t pseudo random sequence number
 */
u32_t
tcp_next_iss(struct tcp_pcb *pcb)
{
 81163b4:	b580      	push	{r7, lr}
 81163b6:	b082      	sub	sp, #8
 81163b8:	af00      	add	r7, sp, #0
 81163ba:	6078      	str	r0, [r7, #4]
  LWIP_ASSERT("tcp_next_iss: invalid pcb", pcb != NULL);
  return LWIP_HOOK_TCP_ISN(&pcb->local_ip, pcb->local_port, &pcb->remote_ip, pcb->remote_port);
#else /* LWIP_HOOK_TCP_ISN */
  static u32_t iss = 6510;

  LWIP_ASSERT("tcp_next_iss: invalid pcb", pcb != NULL);
 81163bc:	687b      	ldr	r3, [r7, #4]
 81163be:	2b00      	cmp	r3, #0
 81163c0:	d106      	bne.n	81163d0 <tcp_next_iss+0x1c>
 81163c2:	4b0a      	ldr	r3, [pc, #40]	; (81163ec <tcp_next_iss+0x38>)
 81163c4:	f640 02af 	movw	r2, #2223	; 0x8af
 81163c8:	4909      	ldr	r1, [pc, #36]	; (81163f0 <tcp_next_iss+0x3c>)
 81163ca:	480a      	ldr	r0, [pc, #40]	; (81163f4 <tcp_next_iss+0x40>)
 81163cc:	f005 fa18 	bl	811b800 <iprintf>
  LWIP_UNUSED_ARG(pcb);

  iss += tcp_ticks;       /* XXX */
 81163d0:	4b09      	ldr	r3, [pc, #36]	; (81163f8 <tcp_next_iss+0x44>)
 81163d2:	681a      	ldr	r2, [r3, #0]
 81163d4:	4b09      	ldr	r3, [pc, #36]	; (81163fc <tcp_next_iss+0x48>)
 81163d6:	681b      	ldr	r3, [r3, #0]
 81163d8:	4413      	add	r3, r2
 81163da:	4a07      	ldr	r2, [pc, #28]	; (81163f8 <tcp_next_iss+0x44>)
 81163dc:	6013      	str	r3, [r2, #0]
  return iss;
 81163de:	4b06      	ldr	r3, [pc, #24]	; (81163f8 <tcp_next_iss+0x44>)
 81163e0:	681b      	ldr	r3, [r3, #0]
#endif /* LWIP_HOOK_TCP_ISN */
}
 81163e2:	4618      	mov	r0, r3
 81163e4:	3708      	adds	r7, #8
 81163e6:	46bd      	mov	sp, r7
 81163e8:	bd80      	pop	{r7, pc}
 81163ea:	bf00      	nop
 81163ec:	0811df48 	.word	0x0811df48
 81163f0:	0811e66c 	.word	0x0811e66c
 81163f4:	0811dfc0 	.word	0x0811dfc0
 81163f8:	10000108 	.word	0x10000108
 81163fc:	10008448 	.word	0x10008448

08116400 <tcp_eff_send_mss_netif>:
 * by calculating the minimum of TCP_MSS and the mtu (if set) of the target
 * netif (if not NULL).
 */
u16_t
tcp_eff_send_mss_netif(u16_t sendmss, struct netif *outif, const ip_addr_t *dest)
{
 8116400:	b580      	push	{r7, lr}
 8116402:	b086      	sub	sp, #24
 8116404:	af00      	add	r7, sp, #0
 8116406:	4603      	mov	r3, r0
 8116408:	60b9      	str	r1, [r7, #8]
 811640a:	607a      	str	r2, [r7, #4]
 811640c:	81fb      	strh	r3, [r7, #14]
  u16_t mss_s;
  u16_t mtu;

  LWIP_UNUSED_ARG(dest); /* in case IPv6 is disabled */

  LWIP_ASSERT("tcp_eff_send_mss_netif: invalid dst_ip", dest != NULL);
 811640e:	687b      	ldr	r3, [r7, #4]
 8116410:	2b00      	cmp	r3, #0
 8116412:	d106      	bne.n	8116422 <tcp_eff_send_mss_netif+0x22>
 8116414:	4b14      	ldr	r3, [pc, #80]	; (8116468 <tcp_eff_send_mss_netif+0x68>)
 8116416:	f640 02c5 	movw	r2, #2245	; 0x8c5
 811641a:	4914      	ldr	r1, [pc, #80]	; (811646c <tcp_eff_send_mss_netif+0x6c>)
 811641c:	4814      	ldr	r0, [pc, #80]	; (8116470 <tcp_eff_send_mss_netif+0x70>)
 811641e:	f005 f9ef 	bl	811b800 <iprintf>
  else
#endif /* LWIP_IPV4 */
#endif /* LWIP_IPV6 */
#if LWIP_IPV4
  {
    if (outif == NULL) {
 8116422:	68bb      	ldr	r3, [r7, #8]
 8116424:	2b00      	cmp	r3, #0
 8116426:	d101      	bne.n	811642c <tcp_eff_send_mss_netif+0x2c>
      return sendmss;
 8116428:	89fb      	ldrh	r3, [r7, #14]
 811642a:	e019      	b.n	8116460 <tcp_eff_send_mss_netif+0x60>
    }
    mtu = outif->mtu;
 811642c:	68bb      	ldr	r3, [r7, #8]
 811642e:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
 8116430:	82fb      	strh	r3, [r7, #22]
  }
#endif /* LWIP_IPV4 */

  if (mtu != 0) {
 8116432:	8afb      	ldrh	r3, [r7, #22]
 8116434:	2b00      	cmp	r3, #0
 8116436:	d012      	beq.n	811645e <tcp_eff_send_mss_netif+0x5e>
    else
#endif /* LWIP_IPV4 */
#endif /* LWIP_IPV6 */
#if LWIP_IPV4
    {
      offset = IP_HLEN + TCP_HLEN;
 8116438:	2328      	movs	r3, #40	; 0x28
 811643a:	82bb      	strh	r3, [r7, #20]
    }
#endif /* LWIP_IPV4 */
    mss_s = (mtu > offset) ? (u16_t)(mtu - offset) : 0;
 811643c:	8afa      	ldrh	r2, [r7, #22]
 811643e:	8abb      	ldrh	r3, [r7, #20]
 8116440:	429a      	cmp	r2, r3
 8116442:	d904      	bls.n	811644e <tcp_eff_send_mss_netif+0x4e>
 8116444:	8afa      	ldrh	r2, [r7, #22]
 8116446:	8abb      	ldrh	r3, [r7, #20]
 8116448:	1ad3      	subs	r3, r2, r3
 811644a:	b29b      	uxth	r3, r3
 811644c:	e000      	b.n	8116450 <tcp_eff_send_mss_netif+0x50>
 811644e:	2300      	movs	r3, #0
 8116450:	827b      	strh	r3, [r7, #18]
    /* RFC 1122, chap 4.2.2.6:
     * Eff.snd.MSS = min(SendMSS+20, MMS_S) - TCPhdrsize - IPoptionsize
     * We correct for TCP options in tcp_write(), and don't support IP options.
     */
    sendmss = LWIP_MIN(sendmss, mss_s);
 8116452:	8a7a      	ldrh	r2, [r7, #18]
 8116454:	89fb      	ldrh	r3, [r7, #14]
 8116456:	4293      	cmp	r3, r2
 8116458:	bf28      	it	cs
 811645a:	4613      	movcs	r3, r2
 811645c:	81fb      	strh	r3, [r7, #14]
  }
  return sendmss;
 811645e:	89fb      	ldrh	r3, [r7, #14]
}
 8116460:	4618      	mov	r0, r3
 8116462:	3718      	adds	r7, #24
 8116464:	46bd      	mov	sp, r7
 8116466:	bd80      	pop	{r7, pc}
 8116468:	0811df48 	.word	0x0811df48
 811646c:	0811e688 	.word	0x0811e688
 8116470:	0811dfc0 	.word	0x0811dfc0

08116474 <tcp_netif_ip_addr_changed_pcblist>:
#endif /* TCP_CALCULATE_EFF_SEND_MSS */

/** Helper function for tcp_netif_ip_addr_changed() that iterates a pcb list */
static void
tcp_netif_ip_addr_changed_pcblist(const ip_addr_t *old_addr, struct tcp_pcb *pcb_list)
{
 8116474:	b580      	push	{r7, lr}
 8116476:	b084      	sub	sp, #16
 8116478:	af00      	add	r7, sp, #0
 811647a:	6078      	str	r0, [r7, #4]
 811647c:	6039      	str	r1, [r7, #0]
  struct tcp_pcb *pcb;
  pcb = pcb_list;
 811647e:	683b      	ldr	r3, [r7, #0]
 8116480:	60fb      	str	r3, [r7, #12]

  LWIP_ASSERT("tcp_netif_ip_addr_changed_pcblist: invalid old_addr", old_addr != NULL);
 8116482:	687b      	ldr	r3, [r7, #4]
 8116484:	2b00      	cmp	r3, #0
 8116486:	d119      	bne.n	81164bc <tcp_netif_ip_addr_changed_pcblist+0x48>
 8116488:	4b10      	ldr	r3, [pc, #64]	; (81164cc <tcp_netif_ip_addr_changed_pcblist+0x58>)
 811648a:	f44f 6210 	mov.w	r2, #2304	; 0x900
 811648e:	4910      	ldr	r1, [pc, #64]	; (81164d0 <tcp_netif_ip_addr_changed_pcblist+0x5c>)
 8116490:	4810      	ldr	r0, [pc, #64]	; (81164d4 <tcp_netif_ip_addr_changed_pcblist+0x60>)
 8116492:	f005 f9b5 	bl	811b800 <iprintf>

  while (pcb != NULL) {
 8116496:	e011      	b.n	81164bc <tcp_netif_ip_addr_changed_pcblist+0x48>
    /* PCB bound to current local interface address? */
    if (ip_addr_cmp(&pcb->local_ip, old_addr)
 8116498:	68fb      	ldr	r3, [r7, #12]
 811649a:	681a      	ldr	r2, [r3, #0]
 811649c:	687b      	ldr	r3, [r7, #4]
 811649e:	681b      	ldr	r3, [r3, #0]
 81164a0:	429a      	cmp	r2, r3
 81164a2:	d108      	bne.n	81164b6 <tcp_netif_ip_addr_changed_pcblist+0x42>
        /* connections to link-local addresses must persist (RFC3927 ch. 1.9) */
        && (!IP_IS_V4_VAL(pcb->local_ip) || !ip4_addr_islinklocal(ip_2_ip4(&pcb->local_ip)))
#endif /* LWIP_AUTOIP */
       ) {
      /* this connection must be aborted */
      struct tcp_pcb *next = pcb->next;
 81164a4:	68fb      	ldr	r3, [r7, #12]
 81164a6:	68db      	ldr	r3, [r3, #12]
 81164a8:	60bb      	str	r3, [r7, #8]
      LWIP_DEBUGF(NETIF_DEBUG | LWIP_DBG_STATE, ("netif_set_ipaddr: aborting TCP pcb %p\n", (void *)pcb));
      tcp_abort(pcb);
 81164aa:	68f8      	ldr	r0, [r7, #12]
 81164ac:	f7fe ffc6 	bl	811543c <tcp_abort>
      pcb = next;
 81164b0:	68bb      	ldr	r3, [r7, #8]
 81164b2:	60fb      	str	r3, [r7, #12]
 81164b4:	e002      	b.n	81164bc <tcp_netif_ip_addr_changed_pcblist+0x48>
    } else {
      pcb = pcb->next;
 81164b6:	68fb      	ldr	r3, [r7, #12]
 81164b8:	68db      	ldr	r3, [r3, #12]
 81164ba:	60fb      	str	r3, [r7, #12]
  while (pcb != NULL) {
 81164bc:	68fb      	ldr	r3, [r7, #12]
 81164be:	2b00      	cmp	r3, #0
 81164c0:	d1ea      	bne.n	8116498 <tcp_netif_ip_addr_changed_pcblist+0x24>
    }
  }
}
 81164c2:	bf00      	nop
 81164c4:	bf00      	nop
 81164c6:	3710      	adds	r7, #16
 81164c8:	46bd      	mov	sp, r7
 81164ca:	bd80      	pop	{r7, pc}
 81164cc:	0811df48 	.word	0x0811df48
 81164d0:	0811e6b0 	.word	0x0811e6b0
 81164d4:	0811dfc0 	.word	0x0811dfc0

081164d8 <tcp_netif_ip_addr_changed>:
 * @param old_addr IP address of the netif before change
 * @param new_addr IP address of the netif after change or NULL if netif has been removed
 */
void
tcp_netif_ip_addr_changed(const ip_addr_t *old_addr, const ip_addr_t *new_addr)
{
 81164d8:	b580      	push	{r7, lr}
 81164da:	b084      	sub	sp, #16
 81164dc:	af00      	add	r7, sp, #0
 81164de:	6078      	str	r0, [r7, #4]
 81164e0:	6039      	str	r1, [r7, #0]
  struct tcp_pcb_listen *lpcb;

  if (!ip_addr_isany(old_addr)) {
 81164e2:	687b      	ldr	r3, [r7, #4]
 81164e4:	2b00      	cmp	r3, #0
 81164e6:	d02a      	beq.n	811653e <tcp_netif_ip_addr_changed+0x66>
 81164e8:	687b      	ldr	r3, [r7, #4]
 81164ea:	681b      	ldr	r3, [r3, #0]
 81164ec:	2b00      	cmp	r3, #0
 81164ee:	d026      	beq.n	811653e <tcp_netif_ip_addr_changed+0x66>
    tcp_netif_ip_addr_changed_pcblist(old_addr, tcp_active_pcbs);
 81164f0:	4b15      	ldr	r3, [pc, #84]	; (8116548 <tcp_netif_ip_addr_changed+0x70>)
 81164f2:	681b      	ldr	r3, [r3, #0]
 81164f4:	4619      	mov	r1, r3
 81164f6:	6878      	ldr	r0, [r7, #4]
 81164f8:	f7ff ffbc 	bl	8116474 <tcp_netif_ip_addr_changed_pcblist>
    tcp_netif_ip_addr_changed_pcblist(old_addr, tcp_bound_pcbs);
 81164fc:	4b13      	ldr	r3, [pc, #76]	; (811654c <tcp_netif_ip_addr_changed+0x74>)
 81164fe:	681b      	ldr	r3, [r3, #0]
 8116500:	4619      	mov	r1, r3
 8116502:	6878      	ldr	r0, [r7, #4]
 8116504:	f7ff ffb6 	bl	8116474 <tcp_netif_ip_addr_changed_pcblist>

    if (!ip_addr_isany(new_addr)) {
 8116508:	683b      	ldr	r3, [r7, #0]
 811650a:	2b00      	cmp	r3, #0
 811650c:	d017      	beq.n	811653e <tcp_netif_ip_addr_changed+0x66>
 811650e:	683b      	ldr	r3, [r7, #0]
 8116510:	681b      	ldr	r3, [r3, #0]
 8116512:	2b00      	cmp	r3, #0
 8116514:	d013      	beq.n	811653e <tcp_netif_ip_addr_changed+0x66>
      /* PCB bound to current local interface address? */
      for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
 8116516:	4b0e      	ldr	r3, [pc, #56]	; (8116550 <tcp_netif_ip_addr_changed+0x78>)
 8116518:	681b      	ldr	r3, [r3, #0]
 811651a:	60fb      	str	r3, [r7, #12]
 811651c:	e00c      	b.n	8116538 <tcp_netif_ip_addr_changed+0x60>
        /* PCB bound to current local interface address? */
        if (ip_addr_cmp(&lpcb->local_ip, old_addr)) {
 811651e:	68fb      	ldr	r3, [r7, #12]
 8116520:	681a      	ldr	r2, [r3, #0]
 8116522:	687b      	ldr	r3, [r7, #4]
 8116524:	681b      	ldr	r3, [r3, #0]
 8116526:	429a      	cmp	r2, r3
 8116528:	d103      	bne.n	8116532 <tcp_netif_ip_addr_changed+0x5a>
          /* The PCB is listening to the old ipaddr and
            * is set to listen to the new one instead */
          ip_addr_copy(lpcb->local_ip, *new_addr);
 811652a:	683b      	ldr	r3, [r7, #0]
 811652c:	681a      	ldr	r2, [r3, #0]
 811652e:	68fb      	ldr	r3, [r7, #12]
 8116530:	601a      	str	r2, [r3, #0]
      for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
 8116532:	68fb      	ldr	r3, [r7, #12]
 8116534:	68db      	ldr	r3, [r3, #12]
 8116536:	60fb      	str	r3, [r7, #12]
 8116538:	68fb      	ldr	r3, [r7, #12]
 811653a:	2b00      	cmp	r3, #0
 811653c:	d1ef      	bne.n	811651e <tcp_netif_ip_addr_changed+0x46>
        }
      }
    }
  }
}
 811653e:	bf00      	nop
 8116540:	3710      	adds	r7, #16
 8116542:	46bd      	mov	sp, r7
 8116544:	bd80      	pop	{r7, pc}
 8116546:	bf00      	nop
 8116548:	10008454 	.word	0x10008454
 811654c:	1000844c 	.word	0x1000844c
 8116550:	10008450 	.word	0x10008450

08116554 <tcp_free_ooseq>:

#if TCP_QUEUE_OOSEQ
/* Free all ooseq pbufs (and possibly reset SACK state) */
void
tcp_free_ooseq(struct tcp_pcb *pcb)
{
 8116554:	b580      	push	{r7, lr}
 8116556:	b082      	sub	sp, #8
 8116558:	af00      	add	r7, sp, #0
 811655a:	6078      	str	r0, [r7, #4]
  if (pcb->ooseq) {
 811655c:	687b      	ldr	r3, [r7, #4]
 811655e:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 8116560:	2b00      	cmp	r3, #0
 8116562:	d007      	beq.n	8116574 <tcp_free_ooseq+0x20>
    tcp_segs_free(pcb->ooseq);
 8116564:	687b      	ldr	r3, [r7, #4]
 8116566:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 8116568:	4618      	mov	r0, r3
 811656a:	f7ff fc3d 	bl	8115de8 <tcp_segs_free>
    pcb->ooseq = NULL;
 811656e:	687b      	ldr	r3, [r7, #4]
 8116570:	2200      	movs	r2, #0
 8116572:	675a      	str	r2, [r3, #116]	; 0x74
#if LWIP_TCP_SACK_OUT
    memset(pcb->rcv_sacks, 0, sizeof(pcb->rcv_sacks));
#endif /* LWIP_TCP_SACK_OUT */
  }
}
 8116574:	bf00      	nop
 8116576:	3708      	adds	r7, #8
 8116578:	46bd      	mov	sp, r7
 811657a:	bd80      	pop	{r7, pc}

0811657c <tcp_input>:
 * @param p received TCP segment to process (p->payload pointing to the TCP header)
 * @param inp network interface on which this segment was received
 */
void
tcp_input(struct pbuf *p, struct netif *inp)
{
 811657c:	b590      	push	{r4, r7, lr}
 811657e:	b08d      	sub	sp, #52	; 0x34
 8116580:	af04      	add	r7, sp, #16
 8116582:	6078      	str	r0, [r7, #4]
 8116584:	6039      	str	r1, [r7, #0]
  u8_t hdrlen_bytes;
  err_t err;

  LWIP_UNUSED_ARG(inp);
  LWIP_ASSERT_CORE_LOCKED();
  LWIP_ASSERT("tcp_input: invalid pbuf", p != NULL);
 8116586:	687b      	ldr	r3, [r7, #4]
 8116588:	2b00      	cmp	r3, #0
 811658a:	d105      	bne.n	8116598 <tcp_input+0x1c>
 811658c:	4b9b      	ldr	r3, [pc, #620]	; (81167fc <tcp_input+0x280>)
 811658e:	2283      	movs	r2, #131	; 0x83
 8116590:	499b      	ldr	r1, [pc, #620]	; (8116800 <tcp_input+0x284>)
 8116592:	489c      	ldr	r0, [pc, #624]	; (8116804 <tcp_input+0x288>)
 8116594:	f005 f934 	bl	811b800 <iprintf>
  PERF_START;

  TCP_STATS_INC(tcp.recv);
  MIB2_STATS_INC(mib2.tcpinsegs);

  tcphdr = (struct tcp_hdr *)p->payload;
 8116598:	687b      	ldr	r3, [r7, #4]
 811659a:	685b      	ldr	r3, [r3, #4]
 811659c:	4a9a      	ldr	r2, [pc, #616]	; (8116808 <tcp_input+0x28c>)
 811659e:	6013      	str	r3, [r2, #0]
#if TCP_INPUT_DEBUG
  tcp_debug_print(tcphdr);
#endif

  /* Check that TCP header fits in payload */
  if (p->len < TCP_HLEN) {
 81165a0:	687b      	ldr	r3, [r7, #4]
 81165a2:	895b      	ldrh	r3, [r3, #10]
 81165a4:	2b13      	cmp	r3, #19
 81165a6:	f240 83d1 	bls.w	8116d4c <tcp_input+0x7d0>
    TCP_STATS_INC(tcp.lenerr);
    goto dropped;
  }

  /* Don't even process incoming broadcasts/multicasts. */
  if (ip_addr_isbroadcast(ip_current_dest_addr(), ip_current_netif()) ||
 81165aa:	4b98      	ldr	r3, [pc, #608]	; (811680c <tcp_input+0x290>)
 81165ac:	695b      	ldr	r3, [r3, #20]
 81165ae:	4a97      	ldr	r2, [pc, #604]	; (811680c <tcp_input+0x290>)
 81165b0:	6812      	ldr	r2, [r2, #0]
 81165b2:	4611      	mov	r1, r2
 81165b4:	4618      	mov	r0, r3
 81165b6:	f7fb fecd 	bl	8112354 <ip4_addr_isbroadcast_u32>
 81165ba:	4603      	mov	r3, r0
 81165bc:	2b00      	cmp	r3, #0
 81165be:	f040 83c7 	bne.w	8116d50 <tcp_input+0x7d4>
      ip_addr_ismulticast(ip_current_dest_addr())) {
 81165c2:	4b92      	ldr	r3, [pc, #584]	; (811680c <tcp_input+0x290>)
 81165c4:	695b      	ldr	r3, [r3, #20]
 81165c6:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
  if (ip_addr_isbroadcast(ip_current_dest_addr(), ip_current_netif()) ||
 81165ca:	2be0      	cmp	r3, #224	; 0xe0
 81165cc:	f000 83c0 	beq.w	8116d50 <tcp_input+0x7d4>
    }
  }
#endif /* CHECKSUM_CHECK_TCP */

  /* sanity-check header length */
  hdrlen_bytes = TCPH_HDRLEN_BYTES(tcphdr);
 81165d0:	4b8d      	ldr	r3, [pc, #564]	; (8116808 <tcp_input+0x28c>)
 81165d2:	681b      	ldr	r3, [r3, #0]
 81165d4:	899b      	ldrh	r3, [r3, #12]
 81165d6:	b29b      	uxth	r3, r3
 81165d8:	4618      	mov	r0, r3
 81165da:	f7f7 ff5a 	bl	810e492 <lwip_htons>
 81165de:	4603      	mov	r3, r0
 81165e0:	0b1b      	lsrs	r3, r3, #12
 81165e2:	b29b      	uxth	r3, r3
 81165e4:	b2db      	uxtb	r3, r3
 81165e6:	009b      	lsls	r3, r3, #2
 81165e8:	74bb      	strb	r3, [r7, #18]
  if ((hdrlen_bytes < TCP_HLEN) || (hdrlen_bytes > p->tot_len)) {
 81165ea:	7cbb      	ldrb	r3, [r7, #18]
 81165ec:	2b13      	cmp	r3, #19
 81165ee:	f240 83b1 	bls.w	8116d54 <tcp_input+0x7d8>
 81165f2:	7cbb      	ldrb	r3, [r7, #18]
 81165f4:	b29a      	uxth	r2, r3
 81165f6:	687b      	ldr	r3, [r7, #4]
 81165f8:	891b      	ldrh	r3, [r3, #8]
 81165fa:	429a      	cmp	r2, r3
 81165fc:	f200 83aa 	bhi.w	8116d54 <tcp_input+0x7d8>
    goto dropped;
  }

  /* Move the payload pointer in the pbuf so that it points to the
     TCP data instead of the TCP header. */
  tcphdr_optlen = (u16_t)(hdrlen_bytes - TCP_HLEN);
 8116600:	7cbb      	ldrb	r3, [r7, #18]
 8116602:	b29b      	uxth	r3, r3
 8116604:	3b14      	subs	r3, #20
 8116606:	b29a      	uxth	r2, r3
 8116608:	4b81      	ldr	r3, [pc, #516]	; (8116810 <tcp_input+0x294>)
 811660a:	801a      	strh	r2, [r3, #0]
  tcphdr_opt2 = NULL;
 811660c:	4b81      	ldr	r3, [pc, #516]	; (8116814 <tcp_input+0x298>)
 811660e:	2200      	movs	r2, #0
 8116610:	601a      	str	r2, [r3, #0]
  if (p->len >= hdrlen_bytes) {
 8116612:	687b      	ldr	r3, [r7, #4]
 8116614:	895a      	ldrh	r2, [r3, #10]
 8116616:	7cbb      	ldrb	r3, [r7, #18]
 8116618:	b29b      	uxth	r3, r3
 811661a:	429a      	cmp	r2, r3
 811661c:	d309      	bcc.n	8116632 <tcp_input+0xb6>
    /* all options are in the first pbuf */
    tcphdr_opt1len = tcphdr_optlen;
 811661e:	4b7c      	ldr	r3, [pc, #496]	; (8116810 <tcp_input+0x294>)
 8116620:	881a      	ldrh	r2, [r3, #0]
 8116622:	4b7d      	ldr	r3, [pc, #500]	; (8116818 <tcp_input+0x29c>)
 8116624:	801a      	strh	r2, [r3, #0]
    pbuf_remove_header(p, hdrlen_bytes); /* cannot fail */
 8116626:	7cbb      	ldrb	r3, [r7, #18]
 8116628:	4619      	mov	r1, r3
 811662a:	6878      	ldr	r0, [r7, #4]
 811662c:	f7fd ff8e 	bl	811454c <pbuf_remove_header>
 8116630:	e04e      	b.n	81166d0 <tcp_input+0x154>
  } else {
    u16_t opt2len;
    /* TCP header fits into first pbuf, options don't - data is in the next pbuf */
    /* there must be a next pbuf, due to hdrlen_bytes sanity check above */
    LWIP_ASSERT("p->next != NULL", p->next != NULL);
 8116632:	687b      	ldr	r3, [r7, #4]
 8116634:	681b      	ldr	r3, [r3, #0]
 8116636:	2b00      	cmp	r3, #0
 8116638:	d105      	bne.n	8116646 <tcp_input+0xca>
 811663a:	4b70      	ldr	r3, [pc, #448]	; (81167fc <tcp_input+0x280>)
 811663c:	22c2      	movs	r2, #194	; 0xc2
 811663e:	4977      	ldr	r1, [pc, #476]	; (811681c <tcp_input+0x2a0>)
 8116640:	4870      	ldr	r0, [pc, #448]	; (8116804 <tcp_input+0x288>)
 8116642:	f005 f8dd 	bl	811b800 <iprintf>

    /* advance over the TCP header (cannot fail) */
    pbuf_remove_header(p, TCP_HLEN);
 8116646:	2114      	movs	r1, #20
 8116648:	6878      	ldr	r0, [r7, #4]
 811664a:	f7fd ff7f 	bl	811454c <pbuf_remove_header>

    /* determine how long the first and second parts of the options are */
    tcphdr_opt1len = p->len;
 811664e:	687b      	ldr	r3, [r7, #4]
 8116650:	895a      	ldrh	r2, [r3, #10]
 8116652:	4b71      	ldr	r3, [pc, #452]	; (8116818 <tcp_input+0x29c>)
 8116654:	801a      	strh	r2, [r3, #0]
    opt2len = (u16_t)(tcphdr_optlen - tcphdr_opt1len);
 8116656:	4b6e      	ldr	r3, [pc, #440]	; (8116810 <tcp_input+0x294>)
 8116658:	881a      	ldrh	r2, [r3, #0]
 811665a:	4b6f      	ldr	r3, [pc, #444]	; (8116818 <tcp_input+0x29c>)
 811665c:	881b      	ldrh	r3, [r3, #0]
 811665e:	1ad3      	subs	r3, r2, r3
 8116660:	823b      	strh	r3, [r7, #16]

    /* options continue in the next pbuf: set p to zero length and hide the
        options in the next pbuf (adjusting p->tot_len) */
    pbuf_remove_header(p, tcphdr_opt1len);
 8116662:	4b6d      	ldr	r3, [pc, #436]	; (8116818 <tcp_input+0x29c>)
 8116664:	881b      	ldrh	r3, [r3, #0]
 8116666:	4619      	mov	r1, r3
 8116668:	6878      	ldr	r0, [r7, #4]
 811666a:	f7fd ff6f 	bl	811454c <pbuf_remove_header>

    /* check that the options fit in the second pbuf */
    if (opt2len > p->next->len) {
 811666e:	687b      	ldr	r3, [r7, #4]
 8116670:	681b      	ldr	r3, [r3, #0]
 8116672:	895b      	ldrh	r3, [r3, #10]
 8116674:	8a3a      	ldrh	r2, [r7, #16]
 8116676:	429a      	cmp	r2, r3
 8116678:	f200 836e 	bhi.w	8116d58 <tcp_input+0x7dc>
      TCP_STATS_INC(tcp.lenerr);
      goto dropped;
    }

    /* remember the pointer to the second part of the options */
    tcphdr_opt2 = (u8_t *)p->next->payload;
 811667c:	687b      	ldr	r3, [r7, #4]
 811667e:	681b      	ldr	r3, [r3, #0]
 8116680:	685b      	ldr	r3, [r3, #4]
 8116682:	4a64      	ldr	r2, [pc, #400]	; (8116814 <tcp_input+0x298>)
 8116684:	6013      	str	r3, [r2, #0]

    /* advance p->next to point after the options, and manually
        adjust p->tot_len to keep it consistent with the changed p->next */
    pbuf_remove_header(p->next, opt2len);
 8116686:	687b      	ldr	r3, [r7, #4]
 8116688:	681b      	ldr	r3, [r3, #0]
 811668a:	8a3a      	ldrh	r2, [r7, #16]
 811668c:	4611      	mov	r1, r2
 811668e:	4618      	mov	r0, r3
 8116690:	f7fd ff5c 	bl	811454c <pbuf_remove_header>
    p->tot_len = (u16_t)(p->tot_len - opt2len);
 8116694:	687b      	ldr	r3, [r7, #4]
 8116696:	891a      	ldrh	r2, [r3, #8]
 8116698:	8a3b      	ldrh	r3, [r7, #16]
 811669a:	1ad3      	subs	r3, r2, r3
 811669c:	b29a      	uxth	r2, r3
 811669e:	687b      	ldr	r3, [r7, #4]
 81166a0:	811a      	strh	r2, [r3, #8]

    LWIP_ASSERT("p->len == 0", p->len == 0);
 81166a2:	687b      	ldr	r3, [r7, #4]
 81166a4:	895b      	ldrh	r3, [r3, #10]
 81166a6:	2b00      	cmp	r3, #0
 81166a8:	d005      	beq.n	81166b6 <tcp_input+0x13a>
 81166aa:	4b54      	ldr	r3, [pc, #336]	; (81167fc <tcp_input+0x280>)
 81166ac:	22df      	movs	r2, #223	; 0xdf
 81166ae:	495c      	ldr	r1, [pc, #368]	; (8116820 <tcp_input+0x2a4>)
 81166b0:	4854      	ldr	r0, [pc, #336]	; (8116804 <tcp_input+0x288>)
 81166b2:	f005 f8a5 	bl	811b800 <iprintf>
    LWIP_ASSERT("p->tot_len == p->next->tot_len", p->tot_len == p->next->tot_len);
 81166b6:	687b      	ldr	r3, [r7, #4]
 81166b8:	891a      	ldrh	r2, [r3, #8]
 81166ba:	687b      	ldr	r3, [r7, #4]
 81166bc:	681b      	ldr	r3, [r3, #0]
 81166be:	891b      	ldrh	r3, [r3, #8]
 81166c0:	429a      	cmp	r2, r3
 81166c2:	d005      	beq.n	81166d0 <tcp_input+0x154>
 81166c4:	4b4d      	ldr	r3, [pc, #308]	; (81167fc <tcp_input+0x280>)
 81166c6:	22e0      	movs	r2, #224	; 0xe0
 81166c8:	4956      	ldr	r1, [pc, #344]	; (8116824 <tcp_input+0x2a8>)
 81166ca:	484e      	ldr	r0, [pc, #312]	; (8116804 <tcp_input+0x288>)
 81166cc:	f005 f898 	bl	811b800 <iprintf>
  }

  /* Convert fields in TCP header to host byte order. */
  tcphdr->src = lwip_ntohs(tcphdr->src);
 81166d0:	4b4d      	ldr	r3, [pc, #308]	; (8116808 <tcp_input+0x28c>)
 81166d2:	681b      	ldr	r3, [r3, #0]
 81166d4:	881b      	ldrh	r3, [r3, #0]
 81166d6:	b29b      	uxth	r3, r3
 81166d8:	4a4b      	ldr	r2, [pc, #300]	; (8116808 <tcp_input+0x28c>)
 81166da:	6814      	ldr	r4, [r2, #0]
 81166dc:	4618      	mov	r0, r3
 81166de:	f7f7 fed8 	bl	810e492 <lwip_htons>
 81166e2:	4603      	mov	r3, r0
 81166e4:	8023      	strh	r3, [r4, #0]
  tcphdr->dest = lwip_ntohs(tcphdr->dest);
 81166e6:	4b48      	ldr	r3, [pc, #288]	; (8116808 <tcp_input+0x28c>)
 81166e8:	681b      	ldr	r3, [r3, #0]
 81166ea:	885b      	ldrh	r3, [r3, #2]
 81166ec:	b29b      	uxth	r3, r3
 81166ee:	4a46      	ldr	r2, [pc, #280]	; (8116808 <tcp_input+0x28c>)
 81166f0:	6814      	ldr	r4, [r2, #0]
 81166f2:	4618      	mov	r0, r3
 81166f4:	f7f7 fecd 	bl	810e492 <lwip_htons>
 81166f8:	4603      	mov	r3, r0
 81166fa:	8063      	strh	r3, [r4, #2]
  seqno = tcphdr->seqno = lwip_ntohl(tcphdr->seqno);
 81166fc:	4b42      	ldr	r3, [pc, #264]	; (8116808 <tcp_input+0x28c>)
 81166fe:	681b      	ldr	r3, [r3, #0]
 8116700:	685b      	ldr	r3, [r3, #4]
 8116702:	4a41      	ldr	r2, [pc, #260]	; (8116808 <tcp_input+0x28c>)
 8116704:	6814      	ldr	r4, [r2, #0]
 8116706:	4618      	mov	r0, r3
 8116708:	f7f7 fed8 	bl	810e4bc <lwip_htonl>
 811670c:	4603      	mov	r3, r0
 811670e:	6063      	str	r3, [r4, #4]
 8116710:	6863      	ldr	r3, [r4, #4]
 8116712:	4a45      	ldr	r2, [pc, #276]	; (8116828 <tcp_input+0x2ac>)
 8116714:	6013      	str	r3, [r2, #0]
  ackno = tcphdr->ackno = lwip_ntohl(tcphdr->ackno);
 8116716:	4b3c      	ldr	r3, [pc, #240]	; (8116808 <tcp_input+0x28c>)
 8116718:	681b      	ldr	r3, [r3, #0]
 811671a:	689b      	ldr	r3, [r3, #8]
 811671c:	4a3a      	ldr	r2, [pc, #232]	; (8116808 <tcp_input+0x28c>)
 811671e:	6814      	ldr	r4, [r2, #0]
 8116720:	4618      	mov	r0, r3
 8116722:	f7f7 fecb 	bl	810e4bc <lwip_htonl>
 8116726:	4603      	mov	r3, r0
 8116728:	60a3      	str	r3, [r4, #8]
 811672a:	68a3      	ldr	r3, [r4, #8]
 811672c:	4a3f      	ldr	r2, [pc, #252]	; (811682c <tcp_input+0x2b0>)
 811672e:	6013      	str	r3, [r2, #0]
  tcphdr->wnd = lwip_ntohs(tcphdr->wnd);
 8116730:	4b35      	ldr	r3, [pc, #212]	; (8116808 <tcp_input+0x28c>)
 8116732:	681b      	ldr	r3, [r3, #0]
 8116734:	89db      	ldrh	r3, [r3, #14]
 8116736:	b29b      	uxth	r3, r3
 8116738:	4a33      	ldr	r2, [pc, #204]	; (8116808 <tcp_input+0x28c>)
 811673a:	6814      	ldr	r4, [r2, #0]
 811673c:	4618      	mov	r0, r3
 811673e:	f7f7 fea8 	bl	810e492 <lwip_htons>
 8116742:	4603      	mov	r3, r0
 8116744:	81e3      	strh	r3, [r4, #14]

  flags = TCPH_FLAGS(tcphdr);
 8116746:	4b30      	ldr	r3, [pc, #192]	; (8116808 <tcp_input+0x28c>)
 8116748:	681b      	ldr	r3, [r3, #0]
 811674a:	899b      	ldrh	r3, [r3, #12]
 811674c:	b29b      	uxth	r3, r3
 811674e:	4618      	mov	r0, r3
 8116750:	f7f7 fe9f 	bl	810e492 <lwip_htons>
 8116754:	4603      	mov	r3, r0
 8116756:	b2db      	uxtb	r3, r3
 8116758:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 811675c:	b2da      	uxtb	r2, r3
 811675e:	4b34      	ldr	r3, [pc, #208]	; (8116830 <tcp_input+0x2b4>)
 8116760:	701a      	strb	r2, [r3, #0]
  tcplen = p->tot_len;
 8116762:	687b      	ldr	r3, [r7, #4]
 8116764:	891a      	ldrh	r2, [r3, #8]
 8116766:	4b33      	ldr	r3, [pc, #204]	; (8116834 <tcp_input+0x2b8>)
 8116768:	801a      	strh	r2, [r3, #0]
  if (flags & (TCP_FIN | TCP_SYN)) {
 811676a:	4b31      	ldr	r3, [pc, #196]	; (8116830 <tcp_input+0x2b4>)
 811676c:	781b      	ldrb	r3, [r3, #0]
 811676e:	f003 0303 	and.w	r3, r3, #3
 8116772:	2b00      	cmp	r3, #0
 8116774:	d00c      	beq.n	8116790 <tcp_input+0x214>
    tcplen++;
 8116776:	4b2f      	ldr	r3, [pc, #188]	; (8116834 <tcp_input+0x2b8>)
 8116778:	881b      	ldrh	r3, [r3, #0]
 811677a:	3301      	adds	r3, #1
 811677c:	b29a      	uxth	r2, r3
 811677e:	4b2d      	ldr	r3, [pc, #180]	; (8116834 <tcp_input+0x2b8>)
 8116780:	801a      	strh	r2, [r3, #0]
    if (tcplen < p->tot_len) {
 8116782:	687b      	ldr	r3, [r7, #4]
 8116784:	891a      	ldrh	r2, [r3, #8]
 8116786:	4b2b      	ldr	r3, [pc, #172]	; (8116834 <tcp_input+0x2b8>)
 8116788:	881b      	ldrh	r3, [r3, #0]
 811678a:	429a      	cmp	r2, r3
 811678c:	f200 82e6 	bhi.w	8116d5c <tcp_input+0x7e0>
    }
  }

  /* Demultiplex an incoming segment. First, we check if it is destined
     for an active connection. */
  prev = NULL;
 8116790:	2300      	movs	r3, #0
 8116792:	61bb      	str	r3, [r7, #24]

  for (pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
 8116794:	4b28      	ldr	r3, [pc, #160]	; (8116838 <tcp_input+0x2bc>)
 8116796:	681b      	ldr	r3, [r3, #0]
 8116798:	61fb      	str	r3, [r7, #28]
 811679a:	e09d      	b.n	81168d8 <tcp_input+0x35c>
    LWIP_ASSERT("tcp_input: active pcb->state != CLOSED", pcb->state != CLOSED);
 811679c:	69fb      	ldr	r3, [r7, #28]
 811679e:	7d1b      	ldrb	r3, [r3, #20]
 81167a0:	2b00      	cmp	r3, #0
 81167a2:	d105      	bne.n	81167b0 <tcp_input+0x234>
 81167a4:	4b15      	ldr	r3, [pc, #84]	; (81167fc <tcp_input+0x280>)
 81167a6:	22fb      	movs	r2, #251	; 0xfb
 81167a8:	4924      	ldr	r1, [pc, #144]	; (811683c <tcp_input+0x2c0>)
 81167aa:	4816      	ldr	r0, [pc, #88]	; (8116804 <tcp_input+0x288>)
 81167ac:	f005 f828 	bl	811b800 <iprintf>
    LWIP_ASSERT("tcp_input: active pcb->state != TIME-WAIT", pcb->state != TIME_WAIT);
 81167b0:	69fb      	ldr	r3, [r7, #28]
 81167b2:	7d1b      	ldrb	r3, [r3, #20]
 81167b4:	2b0a      	cmp	r3, #10
 81167b6:	d105      	bne.n	81167c4 <tcp_input+0x248>
 81167b8:	4b10      	ldr	r3, [pc, #64]	; (81167fc <tcp_input+0x280>)
 81167ba:	22fc      	movs	r2, #252	; 0xfc
 81167bc:	4920      	ldr	r1, [pc, #128]	; (8116840 <tcp_input+0x2c4>)
 81167be:	4811      	ldr	r0, [pc, #68]	; (8116804 <tcp_input+0x288>)
 81167c0:	f005 f81e 	bl	811b800 <iprintf>
    LWIP_ASSERT("tcp_input: active pcb->state != LISTEN", pcb->state != LISTEN);
 81167c4:	69fb      	ldr	r3, [r7, #28]
 81167c6:	7d1b      	ldrb	r3, [r3, #20]
 81167c8:	2b01      	cmp	r3, #1
 81167ca:	d105      	bne.n	81167d8 <tcp_input+0x25c>
 81167cc:	4b0b      	ldr	r3, [pc, #44]	; (81167fc <tcp_input+0x280>)
 81167ce:	22fd      	movs	r2, #253	; 0xfd
 81167d0:	491c      	ldr	r1, [pc, #112]	; (8116844 <tcp_input+0x2c8>)
 81167d2:	480c      	ldr	r0, [pc, #48]	; (8116804 <tcp_input+0x288>)
 81167d4:	f005 f814 	bl	811b800 <iprintf>

    /* check if PCB is bound to specific netif */
    if ((pcb->netif_idx != NETIF_NO_INDEX) &&
 81167d8:	69fb      	ldr	r3, [r7, #28]
 81167da:	7a1b      	ldrb	r3, [r3, #8]
 81167dc:	2b00      	cmp	r3, #0
 81167de:	d033      	beq.n	8116848 <tcp_input+0x2cc>
        (pcb->netif_idx != netif_get_index(ip_data.current_input_netif))) {
 81167e0:	69fb      	ldr	r3, [r7, #28]
 81167e2:	7a1a      	ldrb	r2, [r3, #8]
 81167e4:	4b09      	ldr	r3, [pc, #36]	; (811680c <tcp_input+0x290>)
 81167e6:	685b      	ldr	r3, [r3, #4]
 81167e8:	f893 3034 	ldrb.w	r3, [r3, #52]	; 0x34
 81167ec:	3301      	adds	r3, #1
 81167ee:	b2db      	uxtb	r3, r3
    if ((pcb->netif_idx != NETIF_NO_INDEX) &&
 81167f0:	429a      	cmp	r2, r3
 81167f2:	d029      	beq.n	8116848 <tcp_input+0x2cc>
      prev = pcb;
 81167f4:	69fb      	ldr	r3, [r7, #28]
 81167f6:	61bb      	str	r3, [r7, #24]
      continue;
 81167f8:	e06b      	b.n	81168d2 <tcp_input+0x356>
 81167fa:	bf00      	nop
 81167fc:	0811e6e4 	.word	0x0811e6e4
 8116800:	0811e74c 	.word	0x0811e74c
 8116804:	0811e764 	.word	0x0811e764
 8116808:	10008470 	.word	0x10008470
 811680c:	100054f0 	.word	0x100054f0
 8116810:	10008474 	.word	0x10008474
 8116814:	10008478 	.word	0x10008478
 8116818:	10008476 	.word	0x10008476
 811681c:	0811e78c 	.word	0x0811e78c
 8116820:	0811e79c 	.word	0x0811e79c
 8116824:	0811e7a8 	.word	0x0811e7a8
 8116828:	10008480 	.word	0x10008480
 811682c:	10008484 	.word	0x10008484
 8116830:	1000848c 	.word	0x1000848c
 8116834:	1000848a 	.word	0x1000848a
 8116838:	10008454 	.word	0x10008454
 811683c:	0811e7c8 	.word	0x0811e7c8
 8116840:	0811e7f0 	.word	0x0811e7f0
 8116844:	0811e81c 	.word	0x0811e81c
    }

    if (pcb->remote_port == tcphdr->src &&
 8116848:	69fb      	ldr	r3, [r7, #28]
 811684a:	8b1a      	ldrh	r2, [r3, #24]
 811684c:	4b72      	ldr	r3, [pc, #456]	; (8116a18 <tcp_input+0x49c>)
 811684e:	681b      	ldr	r3, [r3, #0]
 8116850:	881b      	ldrh	r3, [r3, #0]
 8116852:	b29b      	uxth	r3, r3
 8116854:	429a      	cmp	r2, r3
 8116856:	d13a      	bne.n	81168ce <tcp_input+0x352>
        pcb->local_port == tcphdr->dest &&
 8116858:	69fb      	ldr	r3, [r7, #28]
 811685a:	8ada      	ldrh	r2, [r3, #22]
 811685c:	4b6e      	ldr	r3, [pc, #440]	; (8116a18 <tcp_input+0x49c>)
 811685e:	681b      	ldr	r3, [r3, #0]
 8116860:	885b      	ldrh	r3, [r3, #2]
 8116862:	b29b      	uxth	r3, r3
    if (pcb->remote_port == tcphdr->src &&
 8116864:	429a      	cmp	r2, r3
 8116866:	d132      	bne.n	81168ce <tcp_input+0x352>
        ip_addr_cmp(&pcb->remote_ip, ip_current_src_addr()) &&
 8116868:	69fb      	ldr	r3, [r7, #28]
 811686a:	685a      	ldr	r2, [r3, #4]
 811686c:	4b6b      	ldr	r3, [pc, #428]	; (8116a1c <tcp_input+0x4a0>)
 811686e:	691b      	ldr	r3, [r3, #16]
        pcb->local_port == tcphdr->dest &&
 8116870:	429a      	cmp	r2, r3
 8116872:	d12c      	bne.n	81168ce <tcp_input+0x352>
        ip_addr_cmp(&pcb->local_ip, ip_current_dest_addr())) {
 8116874:	69fb      	ldr	r3, [r7, #28]
 8116876:	681a      	ldr	r2, [r3, #0]
 8116878:	4b68      	ldr	r3, [pc, #416]	; (8116a1c <tcp_input+0x4a0>)
 811687a:	695b      	ldr	r3, [r3, #20]
        ip_addr_cmp(&pcb->remote_ip, ip_current_src_addr()) &&
 811687c:	429a      	cmp	r2, r3
 811687e:	d126      	bne.n	81168ce <tcp_input+0x352>
      /* Move this PCB to the front of the list so that subsequent
         lookups will be faster (we exploit locality in TCP segment
         arrivals). */
      LWIP_ASSERT("tcp_input: pcb->next != pcb (before cache)", pcb->next != pcb);
 8116880:	69fb      	ldr	r3, [r7, #28]
 8116882:	68db      	ldr	r3, [r3, #12]
 8116884:	69fa      	ldr	r2, [r7, #28]
 8116886:	429a      	cmp	r2, r3
 8116888:	d106      	bne.n	8116898 <tcp_input+0x31c>
 811688a:	4b65      	ldr	r3, [pc, #404]	; (8116a20 <tcp_input+0x4a4>)
 811688c:	f240 120d 	movw	r2, #269	; 0x10d
 8116890:	4964      	ldr	r1, [pc, #400]	; (8116a24 <tcp_input+0x4a8>)
 8116892:	4865      	ldr	r0, [pc, #404]	; (8116a28 <tcp_input+0x4ac>)
 8116894:	f004 ffb4 	bl	811b800 <iprintf>
      if (prev != NULL) {
 8116898:	69bb      	ldr	r3, [r7, #24]
 811689a:	2b00      	cmp	r3, #0
 811689c:	d00a      	beq.n	81168b4 <tcp_input+0x338>
        prev->next = pcb->next;
 811689e:	69fb      	ldr	r3, [r7, #28]
 81168a0:	68da      	ldr	r2, [r3, #12]
 81168a2:	69bb      	ldr	r3, [r7, #24]
 81168a4:	60da      	str	r2, [r3, #12]
        pcb->next = tcp_active_pcbs;
 81168a6:	4b61      	ldr	r3, [pc, #388]	; (8116a2c <tcp_input+0x4b0>)
 81168a8:	681a      	ldr	r2, [r3, #0]
 81168aa:	69fb      	ldr	r3, [r7, #28]
 81168ac:	60da      	str	r2, [r3, #12]
        tcp_active_pcbs = pcb;
 81168ae:	4a5f      	ldr	r2, [pc, #380]	; (8116a2c <tcp_input+0x4b0>)
 81168b0:	69fb      	ldr	r3, [r7, #28]
 81168b2:	6013      	str	r3, [r2, #0]
      } else {
        TCP_STATS_INC(tcp.cachehit);
      }
      LWIP_ASSERT("tcp_input: pcb->next != pcb (after cache)", pcb->next != pcb);
 81168b4:	69fb      	ldr	r3, [r7, #28]
 81168b6:	68db      	ldr	r3, [r3, #12]
 81168b8:	69fa      	ldr	r2, [r7, #28]
 81168ba:	429a      	cmp	r2, r3
 81168bc:	d111      	bne.n	81168e2 <tcp_input+0x366>
 81168be:	4b58      	ldr	r3, [pc, #352]	; (8116a20 <tcp_input+0x4a4>)
 81168c0:	f240 1215 	movw	r2, #277	; 0x115
 81168c4:	495a      	ldr	r1, [pc, #360]	; (8116a30 <tcp_input+0x4b4>)
 81168c6:	4858      	ldr	r0, [pc, #352]	; (8116a28 <tcp_input+0x4ac>)
 81168c8:	f004 ff9a 	bl	811b800 <iprintf>
      break;
 81168cc:	e009      	b.n	81168e2 <tcp_input+0x366>
    }
    prev = pcb;
 81168ce:	69fb      	ldr	r3, [r7, #28]
 81168d0:	61bb      	str	r3, [r7, #24]
  for (pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
 81168d2:	69fb      	ldr	r3, [r7, #28]
 81168d4:	68db      	ldr	r3, [r3, #12]
 81168d6:	61fb      	str	r3, [r7, #28]
 81168d8:	69fb      	ldr	r3, [r7, #28]
 81168da:	2b00      	cmp	r3, #0
 81168dc:	f47f af5e 	bne.w	811679c <tcp_input+0x220>
 81168e0:	e000      	b.n	81168e4 <tcp_input+0x368>
      break;
 81168e2:	bf00      	nop
  }

  if (pcb == NULL) {
 81168e4:	69fb      	ldr	r3, [r7, #28]
 81168e6:	2b00      	cmp	r3, #0
 81168e8:	f040 80aa 	bne.w	8116a40 <tcp_input+0x4c4>
    /* If it did not go to an active connection, we check the connections
       in the TIME-WAIT state. */
    for (pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
 81168ec:	4b51      	ldr	r3, [pc, #324]	; (8116a34 <tcp_input+0x4b8>)
 81168ee:	681b      	ldr	r3, [r3, #0]
 81168f0:	61fb      	str	r3, [r7, #28]
 81168f2:	e03f      	b.n	8116974 <tcp_input+0x3f8>
      LWIP_ASSERT("tcp_input: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
 81168f4:	69fb      	ldr	r3, [r7, #28]
 81168f6:	7d1b      	ldrb	r3, [r3, #20]
 81168f8:	2b0a      	cmp	r3, #10
 81168fa:	d006      	beq.n	811690a <tcp_input+0x38e>
 81168fc:	4b48      	ldr	r3, [pc, #288]	; (8116a20 <tcp_input+0x4a4>)
 81168fe:	f240 121f 	movw	r2, #287	; 0x11f
 8116902:	494d      	ldr	r1, [pc, #308]	; (8116a38 <tcp_input+0x4bc>)
 8116904:	4848      	ldr	r0, [pc, #288]	; (8116a28 <tcp_input+0x4ac>)
 8116906:	f004 ff7b 	bl	811b800 <iprintf>

      /* check if PCB is bound to specific netif */
      if ((pcb->netif_idx != NETIF_NO_INDEX) &&
 811690a:	69fb      	ldr	r3, [r7, #28]
 811690c:	7a1b      	ldrb	r3, [r3, #8]
 811690e:	2b00      	cmp	r3, #0
 8116910:	d009      	beq.n	8116926 <tcp_input+0x3aa>
          (pcb->netif_idx != netif_get_index(ip_data.current_input_netif))) {
 8116912:	69fb      	ldr	r3, [r7, #28]
 8116914:	7a1a      	ldrb	r2, [r3, #8]
 8116916:	4b41      	ldr	r3, [pc, #260]	; (8116a1c <tcp_input+0x4a0>)
 8116918:	685b      	ldr	r3, [r3, #4]
 811691a:	f893 3034 	ldrb.w	r3, [r3, #52]	; 0x34
 811691e:	3301      	adds	r3, #1
 8116920:	b2db      	uxtb	r3, r3
      if ((pcb->netif_idx != NETIF_NO_INDEX) &&
 8116922:	429a      	cmp	r2, r3
 8116924:	d122      	bne.n	811696c <tcp_input+0x3f0>
        continue;
      }

      if (pcb->remote_port == tcphdr->src &&
 8116926:	69fb      	ldr	r3, [r7, #28]
 8116928:	8b1a      	ldrh	r2, [r3, #24]
 811692a:	4b3b      	ldr	r3, [pc, #236]	; (8116a18 <tcp_input+0x49c>)
 811692c:	681b      	ldr	r3, [r3, #0]
 811692e:	881b      	ldrh	r3, [r3, #0]
 8116930:	b29b      	uxth	r3, r3
 8116932:	429a      	cmp	r2, r3
 8116934:	d11b      	bne.n	811696e <tcp_input+0x3f2>
          pcb->local_port == tcphdr->dest &&
 8116936:	69fb      	ldr	r3, [r7, #28]
 8116938:	8ada      	ldrh	r2, [r3, #22]
 811693a:	4b37      	ldr	r3, [pc, #220]	; (8116a18 <tcp_input+0x49c>)
 811693c:	681b      	ldr	r3, [r3, #0]
 811693e:	885b      	ldrh	r3, [r3, #2]
 8116940:	b29b      	uxth	r3, r3
      if (pcb->remote_port == tcphdr->src &&
 8116942:	429a      	cmp	r2, r3
 8116944:	d113      	bne.n	811696e <tcp_input+0x3f2>
          ip_addr_cmp(&pcb->remote_ip, ip_current_src_addr()) &&
 8116946:	69fb      	ldr	r3, [r7, #28]
 8116948:	685a      	ldr	r2, [r3, #4]
 811694a:	4b34      	ldr	r3, [pc, #208]	; (8116a1c <tcp_input+0x4a0>)
 811694c:	691b      	ldr	r3, [r3, #16]
          pcb->local_port == tcphdr->dest &&
 811694e:	429a      	cmp	r2, r3
 8116950:	d10d      	bne.n	811696e <tcp_input+0x3f2>
          ip_addr_cmp(&pcb->local_ip, ip_current_dest_addr())) {
 8116952:	69fb      	ldr	r3, [r7, #28]
 8116954:	681a      	ldr	r2, [r3, #0]
 8116956:	4b31      	ldr	r3, [pc, #196]	; (8116a1c <tcp_input+0x4a0>)
 8116958:	695b      	ldr	r3, [r3, #20]
          ip_addr_cmp(&pcb->remote_ip, ip_current_src_addr()) &&
 811695a:	429a      	cmp	r2, r3
 811695c:	d107      	bne.n	811696e <tcp_input+0x3f2>
#ifdef LWIP_HOOK_TCP_INPACKET_PCB
        if (LWIP_HOOK_TCP_INPACKET_PCB(pcb, tcphdr, tcphdr_optlen, tcphdr_opt1len,
                                       tcphdr_opt2, p) == ERR_OK)
#endif
        {
          tcp_timewait_input(pcb);
 811695e:	69f8      	ldr	r0, [r7, #28]
 8116960:	f000 fb56 	bl	8117010 <tcp_timewait_input>
        }
        pbuf_free(p);
 8116964:	6878      	ldr	r0, [r7, #4]
 8116966:	f7fd fe77 	bl	8114658 <pbuf_free>
        return;
 811696a:	e1fd      	b.n	8116d68 <tcp_input+0x7ec>
        continue;
 811696c:	bf00      	nop
    for (pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
 811696e:	69fb      	ldr	r3, [r7, #28]
 8116970:	68db      	ldr	r3, [r3, #12]
 8116972:	61fb      	str	r3, [r7, #28]
 8116974:	69fb      	ldr	r3, [r7, #28]
 8116976:	2b00      	cmp	r3, #0
 8116978:	d1bc      	bne.n	81168f4 <tcp_input+0x378>
      }
    }

    /* Finally, if we still did not get a match, we check all PCBs that
       are LISTENing for incoming connections. */
    prev = NULL;
 811697a:	2300      	movs	r3, #0
 811697c:	61bb      	str	r3, [r7, #24]
    for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
 811697e:	4b2f      	ldr	r3, [pc, #188]	; (8116a3c <tcp_input+0x4c0>)
 8116980:	681b      	ldr	r3, [r3, #0]
 8116982:	617b      	str	r3, [r7, #20]
 8116984:	e02a      	b.n	81169dc <tcp_input+0x460>
      /* check if PCB is bound to specific netif */
      if ((lpcb->netif_idx != NETIF_NO_INDEX) &&
 8116986:	697b      	ldr	r3, [r7, #20]
 8116988:	7a1b      	ldrb	r3, [r3, #8]
 811698a:	2b00      	cmp	r3, #0
 811698c:	d00c      	beq.n	81169a8 <tcp_input+0x42c>
          (lpcb->netif_idx != netif_get_index(ip_data.current_input_netif))) {
 811698e:	697b      	ldr	r3, [r7, #20]
 8116990:	7a1a      	ldrb	r2, [r3, #8]
 8116992:	4b22      	ldr	r3, [pc, #136]	; (8116a1c <tcp_input+0x4a0>)
 8116994:	685b      	ldr	r3, [r3, #4]
 8116996:	f893 3034 	ldrb.w	r3, [r3, #52]	; 0x34
 811699a:	3301      	adds	r3, #1
 811699c:	b2db      	uxtb	r3, r3
      if ((lpcb->netif_idx != NETIF_NO_INDEX) &&
 811699e:	429a      	cmp	r2, r3
 81169a0:	d002      	beq.n	81169a8 <tcp_input+0x42c>
        prev = (struct tcp_pcb *)lpcb;
 81169a2:	697b      	ldr	r3, [r7, #20]
 81169a4:	61bb      	str	r3, [r7, #24]
        continue;
 81169a6:	e016      	b.n	81169d6 <tcp_input+0x45a>
      }

      if (lpcb->local_port == tcphdr->dest) {
 81169a8:	697b      	ldr	r3, [r7, #20]
 81169aa:	8ada      	ldrh	r2, [r3, #22]
 81169ac:	4b1a      	ldr	r3, [pc, #104]	; (8116a18 <tcp_input+0x49c>)
 81169ae:	681b      	ldr	r3, [r3, #0]
 81169b0:	885b      	ldrh	r3, [r3, #2]
 81169b2:	b29b      	uxth	r3, r3
 81169b4:	429a      	cmp	r2, r3
 81169b6:	d10c      	bne.n	81169d2 <tcp_input+0x456>
          lpcb_prev = prev;
#else /* SO_REUSE */
          break;
#endif /* SO_REUSE */
        } else if (IP_ADDR_PCB_VERSION_MATCH_EXACT(lpcb, ip_current_dest_addr())) {
          if (ip_addr_cmp(&lpcb->local_ip, ip_current_dest_addr())) {
 81169b8:	697b      	ldr	r3, [r7, #20]
 81169ba:	681a      	ldr	r2, [r3, #0]
 81169bc:	4b17      	ldr	r3, [pc, #92]	; (8116a1c <tcp_input+0x4a0>)
 81169be:	695b      	ldr	r3, [r3, #20]
 81169c0:	429a      	cmp	r2, r3
 81169c2:	d00f      	beq.n	81169e4 <tcp_input+0x468>
            /* found an exact match */
            break;
          } else if (ip_addr_isany(&lpcb->local_ip)) {
 81169c4:	697b      	ldr	r3, [r7, #20]
 81169c6:	2b00      	cmp	r3, #0
 81169c8:	d00d      	beq.n	81169e6 <tcp_input+0x46a>
 81169ca:	697b      	ldr	r3, [r7, #20]
 81169cc:	681b      	ldr	r3, [r3, #0]
 81169ce:	2b00      	cmp	r3, #0
 81169d0:	d009      	beq.n	81169e6 <tcp_input+0x46a>
            break;
#endif /* SO_REUSE */
          }
        }
      }
      prev = (struct tcp_pcb *)lpcb;
 81169d2:	697b      	ldr	r3, [r7, #20]
 81169d4:	61bb      	str	r3, [r7, #24]
    for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
 81169d6:	697b      	ldr	r3, [r7, #20]
 81169d8:	68db      	ldr	r3, [r3, #12]
 81169da:	617b      	str	r3, [r7, #20]
 81169dc:	697b      	ldr	r3, [r7, #20]
 81169de:	2b00      	cmp	r3, #0
 81169e0:	d1d1      	bne.n	8116986 <tcp_input+0x40a>
 81169e2:	e000      	b.n	81169e6 <tcp_input+0x46a>
            break;
 81169e4:	bf00      	nop
      /* only pass to ANY if no specific local IP has been found */
      lpcb = lpcb_any;
      prev = lpcb_prev;
    }
#endif /* SO_REUSE */
    if (lpcb != NULL) {
 81169e6:	697b      	ldr	r3, [r7, #20]
 81169e8:	2b00      	cmp	r3, #0
 81169ea:	d029      	beq.n	8116a40 <tcp_input+0x4c4>
      /* Move this PCB to the front of the list so that subsequent
         lookups will be faster (we exploit locality in TCP segment
         arrivals). */
      if (prev != NULL) {
 81169ec:	69bb      	ldr	r3, [r7, #24]
 81169ee:	2b00      	cmp	r3, #0
 81169f0:	d00a      	beq.n	8116a08 <tcp_input+0x48c>
        ((struct tcp_pcb_listen *)prev)->next = lpcb->next;
 81169f2:	697b      	ldr	r3, [r7, #20]
 81169f4:	68da      	ldr	r2, [r3, #12]
 81169f6:	69bb      	ldr	r3, [r7, #24]
 81169f8:	60da      	str	r2, [r3, #12]
        /* our successor is the remainder of the listening list */
        lpcb->next = tcp_listen_pcbs.listen_pcbs;
 81169fa:	4b10      	ldr	r3, [pc, #64]	; (8116a3c <tcp_input+0x4c0>)
 81169fc:	681a      	ldr	r2, [r3, #0]
 81169fe:	697b      	ldr	r3, [r7, #20]
 8116a00:	60da      	str	r2, [r3, #12]
        /* put this listening pcb at the head of the listening list */
        tcp_listen_pcbs.listen_pcbs = lpcb;
 8116a02:	4a0e      	ldr	r2, [pc, #56]	; (8116a3c <tcp_input+0x4c0>)
 8116a04:	697b      	ldr	r3, [r7, #20]
 8116a06:	6013      	str	r3, [r2, #0]
#ifdef LWIP_HOOK_TCP_INPACKET_PCB
      if (LWIP_HOOK_TCP_INPACKET_PCB((struct tcp_pcb *)lpcb, tcphdr, tcphdr_optlen,
                                     tcphdr_opt1len, tcphdr_opt2, p) == ERR_OK)
#endif
      {
        tcp_listen_input(lpcb);
 8116a08:	6978      	ldr	r0, [r7, #20]
 8116a0a:	f000 fa03 	bl	8116e14 <tcp_listen_input>
      }
      pbuf_free(p);
 8116a0e:	6878      	ldr	r0, [r7, #4]
 8116a10:	f7fd fe22 	bl	8114658 <pbuf_free>
      return;
 8116a14:	e1a8      	b.n	8116d68 <tcp_input+0x7ec>
 8116a16:	bf00      	nop
 8116a18:	10008470 	.word	0x10008470
 8116a1c:	100054f0 	.word	0x100054f0
 8116a20:	0811e6e4 	.word	0x0811e6e4
 8116a24:	0811e844 	.word	0x0811e844
 8116a28:	0811e764 	.word	0x0811e764
 8116a2c:	10008454 	.word	0x10008454
 8116a30:	0811e870 	.word	0x0811e870
 8116a34:	10008458 	.word	0x10008458
 8116a38:	0811e89c 	.word	0x0811e89c
 8116a3c:	10008450 	.word	0x10008450
      tcphdr_opt1len, tcphdr_opt2, p) != ERR_OK) {
    pbuf_free(p);
    return;
  }
#endif
  if (pcb != NULL) {
 8116a40:	69fb      	ldr	r3, [r7, #28]
 8116a42:	2b00      	cmp	r3, #0
 8116a44:	f000 8158 	beq.w	8116cf8 <tcp_input+0x77c>
#if TCP_INPUT_DEBUG
    tcp_debug_print_state(pcb->state);
#endif /* TCP_INPUT_DEBUG */

    /* Set up a tcp_seg structure. */
    inseg.next = NULL;
 8116a48:	4b95      	ldr	r3, [pc, #596]	; (8116ca0 <tcp_input+0x724>)
 8116a4a:	2200      	movs	r2, #0
 8116a4c:	601a      	str	r2, [r3, #0]
    inseg.len = p->tot_len;
 8116a4e:	687b      	ldr	r3, [r7, #4]
 8116a50:	891a      	ldrh	r2, [r3, #8]
 8116a52:	4b93      	ldr	r3, [pc, #588]	; (8116ca0 <tcp_input+0x724>)
 8116a54:	811a      	strh	r2, [r3, #8]
    inseg.p = p;
 8116a56:	4a92      	ldr	r2, [pc, #584]	; (8116ca0 <tcp_input+0x724>)
 8116a58:	687b      	ldr	r3, [r7, #4]
 8116a5a:	6053      	str	r3, [r2, #4]
    inseg.tcphdr = tcphdr;
 8116a5c:	4b91      	ldr	r3, [pc, #580]	; (8116ca4 <tcp_input+0x728>)
 8116a5e:	681b      	ldr	r3, [r3, #0]
 8116a60:	4a8f      	ldr	r2, [pc, #572]	; (8116ca0 <tcp_input+0x724>)
 8116a62:	60d3      	str	r3, [r2, #12]

    recv_data = NULL;
 8116a64:	4b90      	ldr	r3, [pc, #576]	; (8116ca8 <tcp_input+0x72c>)
 8116a66:	2200      	movs	r2, #0
 8116a68:	601a      	str	r2, [r3, #0]
    recv_flags = 0;
 8116a6a:	4b90      	ldr	r3, [pc, #576]	; (8116cac <tcp_input+0x730>)
 8116a6c:	2200      	movs	r2, #0
 8116a6e:	701a      	strb	r2, [r3, #0]
    recv_acked = 0;
 8116a70:	4b8f      	ldr	r3, [pc, #572]	; (8116cb0 <tcp_input+0x734>)
 8116a72:	2200      	movs	r2, #0
 8116a74:	801a      	strh	r2, [r3, #0]

    if (flags & TCP_PSH) {
 8116a76:	4b8f      	ldr	r3, [pc, #572]	; (8116cb4 <tcp_input+0x738>)
 8116a78:	781b      	ldrb	r3, [r3, #0]
 8116a7a:	f003 0308 	and.w	r3, r3, #8
 8116a7e:	2b00      	cmp	r3, #0
 8116a80:	d006      	beq.n	8116a90 <tcp_input+0x514>
      p->flags |= PBUF_FLAG_PUSH;
 8116a82:	687b      	ldr	r3, [r7, #4]
 8116a84:	7b5b      	ldrb	r3, [r3, #13]
 8116a86:	f043 0301 	orr.w	r3, r3, #1
 8116a8a:	b2da      	uxtb	r2, r3
 8116a8c:	687b      	ldr	r3, [r7, #4]
 8116a8e:	735a      	strb	r2, [r3, #13]
    }

    /* If there is data which was previously "refused" by upper layer */
    if (pcb->refused_data != NULL) {
 8116a90:	69fb      	ldr	r3, [r7, #28]
 8116a92:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 8116a94:	2b00      	cmp	r3, #0
 8116a96:	d017      	beq.n	8116ac8 <tcp_input+0x54c>
      if ((tcp_process_refused_data(pcb) == ERR_ABRT) ||
 8116a98:	69f8      	ldr	r0, [r7, #28]
 8116a9a:	f7ff f929 	bl	8115cf0 <tcp_process_refused_data>
 8116a9e:	4603      	mov	r3, r0
 8116aa0:	f113 0f0d 	cmn.w	r3, #13
 8116aa4:	d007      	beq.n	8116ab6 <tcp_input+0x53a>
          ((pcb->refused_data != NULL) && (tcplen > 0))) {
 8116aa6:	69fb      	ldr	r3, [r7, #28]
 8116aa8:	6f9b      	ldr	r3, [r3, #120]	; 0x78
      if ((tcp_process_refused_data(pcb) == ERR_ABRT) ||
 8116aaa:	2b00      	cmp	r3, #0
 8116aac:	d00c      	beq.n	8116ac8 <tcp_input+0x54c>
          ((pcb->refused_data != NULL) && (tcplen > 0))) {
 8116aae:	4b82      	ldr	r3, [pc, #520]	; (8116cb8 <tcp_input+0x73c>)
 8116ab0:	881b      	ldrh	r3, [r3, #0]
 8116ab2:	2b00      	cmp	r3, #0
 8116ab4:	d008      	beq.n	8116ac8 <tcp_input+0x54c>
        /* pcb has been aborted or refused data is still refused and the new
           segment contains data */
        if (pcb->rcv_ann_wnd == 0) {
 8116ab6:	69fb      	ldr	r3, [r7, #28]
 8116ab8:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
 8116aba:	2b00      	cmp	r3, #0
 8116abc:	f040 80e3 	bne.w	8116c86 <tcp_input+0x70a>
          /* this is a zero-window probe, we respond to it with current RCV.NXT
          and drop the data segment */
          tcp_send_empty_ack(pcb);
 8116ac0:	69f8      	ldr	r0, [r7, #28]
 8116ac2:	f003 f9ad 	bl	8119e20 <tcp_send_empty_ack>
        }
        TCP_STATS_INC(tcp.drop);
        MIB2_STATS_INC(mib2.tcpinerrs);
        goto aborted;
 8116ac6:	e0de      	b.n	8116c86 <tcp_input+0x70a>
      }
    }
    tcp_input_pcb = pcb;
 8116ac8:	4a7c      	ldr	r2, [pc, #496]	; (8116cbc <tcp_input+0x740>)
 8116aca:	69fb      	ldr	r3, [r7, #28]
 8116acc:	6013      	str	r3, [r2, #0]
    err = tcp_process(pcb);
 8116ace:	69f8      	ldr	r0, [r7, #28]
 8116ad0:	f000 fb18 	bl	8117104 <tcp_process>
 8116ad4:	4603      	mov	r3, r0
 8116ad6:	74fb      	strb	r3, [r7, #19]
    /* A return value of ERR_ABRT means that tcp_abort() was called
       and that the pcb has been freed. If so, we don't do anything. */
    if (err != ERR_ABRT) {
 8116ad8:	f997 3013 	ldrsb.w	r3, [r7, #19]
 8116adc:	f113 0f0d 	cmn.w	r3, #13
 8116ae0:	f000 80d3 	beq.w	8116c8a <tcp_input+0x70e>
      if (recv_flags & TF_RESET) {
 8116ae4:	4b71      	ldr	r3, [pc, #452]	; (8116cac <tcp_input+0x730>)
 8116ae6:	781b      	ldrb	r3, [r3, #0]
 8116ae8:	f003 0308 	and.w	r3, r3, #8
 8116aec:	2b00      	cmp	r3, #0
 8116aee:	d015      	beq.n	8116b1c <tcp_input+0x5a0>
        /* TF_RESET means that the connection was reset by the other
           end. We then call the error callback to inform the
           application that the connection is dead before we
           deallocate the PCB. */
        TCP_EVENT_ERR(pcb->state, pcb->errf, pcb->callback_arg, ERR_RST);
 8116af0:	69fb      	ldr	r3, [r7, #28]
 8116af2:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 8116af6:	2b00      	cmp	r3, #0
 8116af8:	d008      	beq.n	8116b0c <tcp_input+0x590>
 8116afa:	69fb      	ldr	r3, [r7, #28]
 8116afc:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 8116b00:	69fa      	ldr	r2, [r7, #28]
 8116b02:	6912      	ldr	r2, [r2, #16]
 8116b04:	f06f 010d 	mvn.w	r1, #13
 8116b08:	4610      	mov	r0, r2
 8116b0a:	4798      	blx	r3
        tcp_pcb_remove(&tcp_active_pcbs, pcb);
 8116b0c:	69f9      	ldr	r1, [r7, #28]
 8116b0e:	486c      	ldr	r0, [pc, #432]	; (8116cc0 <tcp_input+0x744>)
 8116b10:	f7ff fbbc 	bl	811628c <tcp_pcb_remove>
        tcp_free(pcb);
 8116b14:	69f8      	ldr	r0, [r7, #28]
 8116b16:	f7fe f9a9 	bl	8114e6c <tcp_free>
 8116b1a:	e0da      	b.n	8116cd2 <tcp_input+0x756>
      } else {
        err = ERR_OK;
 8116b1c:	2300      	movs	r3, #0
 8116b1e:	74fb      	strb	r3, [r7, #19]
        /* If the application has registered a "sent" function to be
           called when new send buffer space is available, we call it
           now. */
        if (recv_acked > 0) {
 8116b20:	4b63      	ldr	r3, [pc, #396]	; (8116cb0 <tcp_input+0x734>)
 8116b22:	881b      	ldrh	r3, [r3, #0]
 8116b24:	2b00      	cmp	r3, #0
 8116b26:	d01d      	beq.n	8116b64 <tcp_input+0x5e8>
          while (acked > 0) {
            acked16 = (u16_t)LWIP_MIN(acked, 0xffffu);
            acked -= acked16;
#else
          {
            acked16 = recv_acked;
 8116b28:	4b61      	ldr	r3, [pc, #388]	; (8116cb0 <tcp_input+0x734>)
 8116b2a:	881b      	ldrh	r3, [r3, #0]
 8116b2c:	81fb      	strh	r3, [r7, #14]
#endif
            TCP_EVENT_SENT(pcb, (u16_t)acked16, err);
 8116b2e:	69fb      	ldr	r3, [r7, #28]
 8116b30:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
 8116b34:	2b00      	cmp	r3, #0
 8116b36:	d00a      	beq.n	8116b4e <tcp_input+0x5d2>
 8116b38:	69fb      	ldr	r3, [r7, #28]
 8116b3a:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
 8116b3e:	69fa      	ldr	r2, [r7, #28]
 8116b40:	6910      	ldr	r0, [r2, #16]
 8116b42:	89fa      	ldrh	r2, [r7, #14]
 8116b44:	69f9      	ldr	r1, [r7, #28]
 8116b46:	4798      	blx	r3
 8116b48:	4603      	mov	r3, r0
 8116b4a:	74fb      	strb	r3, [r7, #19]
 8116b4c:	e001      	b.n	8116b52 <tcp_input+0x5d6>
 8116b4e:	2300      	movs	r3, #0
 8116b50:	74fb      	strb	r3, [r7, #19]
            if (err == ERR_ABRT) {
 8116b52:	f997 3013 	ldrsb.w	r3, [r7, #19]
 8116b56:	f113 0f0d 	cmn.w	r3, #13
 8116b5a:	f000 8098 	beq.w	8116c8e <tcp_input+0x712>
              goto aborted;
            }
          }
          recv_acked = 0;
 8116b5e:	4b54      	ldr	r3, [pc, #336]	; (8116cb0 <tcp_input+0x734>)
 8116b60:	2200      	movs	r2, #0
 8116b62:	801a      	strh	r2, [r3, #0]
        }
        if (tcp_input_delayed_close(pcb)) {
 8116b64:	69f8      	ldr	r0, [r7, #28]
 8116b66:	f000 f915 	bl	8116d94 <tcp_input_delayed_close>
 8116b6a:	4603      	mov	r3, r0
 8116b6c:	2b00      	cmp	r3, #0
 8116b6e:	f040 8090 	bne.w	8116c92 <tcp_input+0x716>
#if TCP_QUEUE_OOSEQ && LWIP_WND_SCALE
        while (recv_data != NULL) {
          struct pbuf *rest = NULL;
          pbuf_split_64k(recv_data, &rest);
#else /* TCP_QUEUE_OOSEQ && LWIP_WND_SCALE */
        if (recv_data != NULL) {
 8116b72:	4b4d      	ldr	r3, [pc, #308]	; (8116ca8 <tcp_input+0x72c>)
 8116b74:	681b      	ldr	r3, [r3, #0]
 8116b76:	2b00      	cmp	r3, #0
 8116b78:	d041      	beq.n	8116bfe <tcp_input+0x682>
#endif /* TCP_QUEUE_OOSEQ && LWIP_WND_SCALE */

          LWIP_ASSERT("pcb->refused_data == NULL", pcb->refused_data == NULL);
 8116b7a:	69fb      	ldr	r3, [r7, #28]
 8116b7c:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 8116b7e:	2b00      	cmp	r3, #0
 8116b80:	d006      	beq.n	8116b90 <tcp_input+0x614>
 8116b82:	4b50      	ldr	r3, [pc, #320]	; (8116cc4 <tcp_input+0x748>)
 8116b84:	f44f 72f3 	mov.w	r2, #486	; 0x1e6
 8116b88:	494f      	ldr	r1, [pc, #316]	; (8116cc8 <tcp_input+0x74c>)
 8116b8a:	4850      	ldr	r0, [pc, #320]	; (8116ccc <tcp_input+0x750>)
 8116b8c:	f004 fe38 	bl	811b800 <iprintf>
          if (pcb->flags & TF_RXCLOSED) {
 8116b90:	69fb      	ldr	r3, [r7, #28]
 8116b92:	8b5b      	ldrh	r3, [r3, #26]
 8116b94:	f003 0310 	and.w	r3, r3, #16
 8116b98:	2b00      	cmp	r3, #0
 8116b9a:	d008      	beq.n	8116bae <tcp_input+0x632>
            /* received data although already closed -> abort (send RST) to
               notify the remote host that not all data has been processed */
            pbuf_free(recv_data);
 8116b9c:	4b42      	ldr	r3, [pc, #264]	; (8116ca8 <tcp_input+0x72c>)
 8116b9e:	681b      	ldr	r3, [r3, #0]
 8116ba0:	4618      	mov	r0, r3
 8116ba2:	f7fd fd59 	bl	8114658 <pbuf_free>
#if TCP_QUEUE_OOSEQ && LWIP_WND_SCALE
            if (rest != NULL) {
              pbuf_free(rest);
            }
#endif /* TCP_QUEUE_OOSEQ && LWIP_WND_SCALE */
            tcp_abort(pcb);
 8116ba6:	69f8      	ldr	r0, [r7, #28]
 8116ba8:	f7fe fc48 	bl	811543c <tcp_abort>
            goto aborted;
 8116bac:	e091      	b.n	8116cd2 <tcp_input+0x756>
          }

          /* Notify application that data has been received. */
          TCP_EVENT_RECV(pcb, recv_data, ERR_OK, err);
 8116bae:	69fb      	ldr	r3, [r7, #28]
 8116bb0:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 8116bb4:	2b00      	cmp	r3, #0
 8116bb6:	d00c      	beq.n	8116bd2 <tcp_input+0x656>
 8116bb8:	69fb      	ldr	r3, [r7, #28]
 8116bba:	f8d3 4084 	ldr.w	r4, [r3, #132]	; 0x84
 8116bbe:	69fb      	ldr	r3, [r7, #28]
 8116bc0:	6918      	ldr	r0, [r3, #16]
 8116bc2:	4b39      	ldr	r3, [pc, #228]	; (8116ca8 <tcp_input+0x72c>)
 8116bc4:	681a      	ldr	r2, [r3, #0]
 8116bc6:	2300      	movs	r3, #0
 8116bc8:	69f9      	ldr	r1, [r7, #28]
 8116bca:	47a0      	blx	r4
 8116bcc:	4603      	mov	r3, r0
 8116bce:	74fb      	strb	r3, [r7, #19]
 8116bd0:	e008      	b.n	8116be4 <tcp_input+0x668>
 8116bd2:	4b35      	ldr	r3, [pc, #212]	; (8116ca8 <tcp_input+0x72c>)
 8116bd4:	681a      	ldr	r2, [r3, #0]
 8116bd6:	2300      	movs	r3, #0
 8116bd8:	69f9      	ldr	r1, [r7, #28]
 8116bda:	2000      	movs	r0, #0
 8116bdc:	f7ff f95e 	bl	8115e9c <tcp_recv_null>
 8116be0:	4603      	mov	r3, r0
 8116be2:	74fb      	strb	r3, [r7, #19]
          if (err == ERR_ABRT) {
 8116be4:	f997 3013 	ldrsb.w	r3, [r7, #19]
 8116be8:	f113 0f0d 	cmn.w	r3, #13
 8116bec:	d053      	beq.n	8116c96 <tcp_input+0x71a>
#endif /* TCP_QUEUE_OOSEQ && LWIP_WND_SCALE */
            goto aborted;
          }

          /* If the upper layer can't receive this data, store it */
          if (err != ERR_OK) {
 8116bee:	f997 3013 	ldrsb.w	r3, [r7, #19]
 8116bf2:	2b00      	cmp	r3, #0
 8116bf4:	d003      	beq.n	8116bfe <tcp_input+0x682>
#if TCP_QUEUE_OOSEQ && LWIP_WND_SCALE
            if (rest != NULL) {
              pbuf_cat(recv_data, rest);
            }
#endif /* TCP_QUEUE_OOSEQ && LWIP_WND_SCALE */
            pcb->refused_data = recv_data;
 8116bf6:	4b2c      	ldr	r3, [pc, #176]	; (8116ca8 <tcp_input+0x72c>)
 8116bf8:	681a      	ldr	r2, [r3, #0]
 8116bfa:	69fb      	ldr	r3, [r7, #28]
 8116bfc:	679a      	str	r2, [r3, #120]	; 0x78
          }
        }

        /* If a FIN segment was received, we call the callback
           function with a NULL buffer to indicate EOF. */
        if (recv_flags & TF_GOT_FIN) {
 8116bfe:	4b2b      	ldr	r3, [pc, #172]	; (8116cac <tcp_input+0x730>)
 8116c00:	781b      	ldrb	r3, [r3, #0]
 8116c02:	f003 0320 	and.w	r3, r3, #32
 8116c06:	2b00      	cmp	r3, #0
 8116c08:	d030      	beq.n	8116c6c <tcp_input+0x6f0>
          if (pcb->refused_data != NULL) {
 8116c0a:	69fb      	ldr	r3, [r7, #28]
 8116c0c:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 8116c0e:	2b00      	cmp	r3, #0
 8116c10:	d009      	beq.n	8116c26 <tcp_input+0x6aa>
            /* Delay this if we have refused data. */
            pcb->refused_data->flags |= PBUF_FLAG_TCP_FIN;
 8116c12:	69fb      	ldr	r3, [r7, #28]
 8116c14:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 8116c16:	7b5a      	ldrb	r2, [r3, #13]
 8116c18:	69fb      	ldr	r3, [r7, #28]
 8116c1a:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 8116c1c:	f042 0220 	orr.w	r2, r2, #32
 8116c20:	b2d2      	uxtb	r2, r2
 8116c22:	735a      	strb	r2, [r3, #13]
 8116c24:	e022      	b.n	8116c6c <tcp_input+0x6f0>
          } else {
            /* correct rcv_wnd as the application won't call tcp_recved()
               for the FIN's seqno */
            if (pcb->rcv_wnd != TCP_WND_MAX(pcb)) {
 8116c26:	69fb      	ldr	r3, [r7, #28]
 8116c28:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
 8116c2a:	f5b3 6f06 	cmp.w	r3, #2144	; 0x860
 8116c2e:	d005      	beq.n	8116c3c <tcp_input+0x6c0>
              pcb->rcv_wnd++;
 8116c30:	69fb      	ldr	r3, [r7, #28]
 8116c32:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
 8116c34:	3301      	adds	r3, #1
 8116c36:	b29a      	uxth	r2, r3
 8116c38:	69fb      	ldr	r3, [r7, #28]
 8116c3a:	851a      	strh	r2, [r3, #40]	; 0x28
            }
            TCP_EVENT_CLOSED(pcb, err);
 8116c3c:	69fb      	ldr	r3, [r7, #28]
 8116c3e:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 8116c42:	2b00      	cmp	r3, #0
 8116c44:	d00b      	beq.n	8116c5e <tcp_input+0x6e2>
 8116c46:	69fb      	ldr	r3, [r7, #28]
 8116c48:	f8d3 4084 	ldr.w	r4, [r3, #132]	; 0x84
 8116c4c:	69fb      	ldr	r3, [r7, #28]
 8116c4e:	6918      	ldr	r0, [r3, #16]
 8116c50:	2300      	movs	r3, #0
 8116c52:	2200      	movs	r2, #0
 8116c54:	69f9      	ldr	r1, [r7, #28]
 8116c56:	47a0      	blx	r4
 8116c58:	4603      	mov	r3, r0
 8116c5a:	74fb      	strb	r3, [r7, #19]
 8116c5c:	e001      	b.n	8116c62 <tcp_input+0x6e6>
 8116c5e:	2300      	movs	r3, #0
 8116c60:	74fb      	strb	r3, [r7, #19]
            if (err == ERR_ABRT) {
 8116c62:	f997 3013 	ldrsb.w	r3, [r7, #19]
 8116c66:	f113 0f0d 	cmn.w	r3, #13
 8116c6a:	d016      	beq.n	8116c9a <tcp_input+0x71e>
              goto aborted;
            }
          }
        }

        tcp_input_pcb = NULL;
 8116c6c:	4b13      	ldr	r3, [pc, #76]	; (8116cbc <tcp_input+0x740>)
 8116c6e:	2200      	movs	r2, #0
 8116c70:	601a      	str	r2, [r3, #0]
        if (tcp_input_delayed_close(pcb)) {
 8116c72:	69f8      	ldr	r0, [r7, #28]
 8116c74:	f000 f88e 	bl	8116d94 <tcp_input_delayed_close>
 8116c78:	4603      	mov	r3, r0
 8116c7a:	2b00      	cmp	r3, #0
 8116c7c:	d128      	bne.n	8116cd0 <tcp_input+0x754>
          goto aborted;
        }
        /* Try to send something out. */
        tcp_output(pcb);
 8116c7e:	69f8      	ldr	r0, [r7, #28]
 8116c80:	f002 fac8 	bl	8119214 <tcp_output>
 8116c84:	e025      	b.n	8116cd2 <tcp_input+0x756>
        goto aborted;
 8116c86:	bf00      	nop
 8116c88:	e023      	b.n	8116cd2 <tcp_input+0x756>
#endif /* TCP_INPUT_DEBUG */
      }
    }
    /* Jump target if pcb has been aborted in a callback (by calling tcp_abort()).
       Below this line, 'pcb' may not be dereferenced! */
aborted:
 8116c8a:	bf00      	nop
 8116c8c:	e021      	b.n	8116cd2 <tcp_input+0x756>
              goto aborted;
 8116c8e:	bf00      	nop
 8116c90:	e01f      	b.n	8116cd2 <tcp_input+0x756>
          goto aborted;
 8116c92:	bf00      	nop
 8116c94:	e01d      	b.n	8116cd2 <tcp_input+0x756>
            goto aborted;
 8116c96:	bf00      	nop
 8116c98:	e01b      	b.n	8116cd2 <tcp_input+0x756>
              goto aborted;
 8116c9a:	bf00      	nop
 8116c9c:	e019      	b.n	8116cd2 <tcp_input+0x756>
 8116c9e:	bf00      	nop
 8116ca0:	10008460 	.word	0x10008460
 8116ca4:	10008470 	.word	0x10008470
 8116ca8:	10008490 	.word	0x10008490
 8116cac:	1000848d 	.word	0x1000848d
 8116cb0:	10008488 	.word	0x10008488
 8116cb4:	1000848c 	.word	0x1000848c
 8116cb8:	1000848a 	.word	0x1000848a
 8116cbc:	10008494 	.word	0x10008494
 8116cc0:	10008454 	.word	0x10008454
 8116cc4:	0811e6e4 	.word	0x0811e6e4
 8116cc8:	0811e8cc 	.word	0x0811e8cc
 8116ccc:	0811e764 	.word	0x0811e764
          goto aborted;
 8116cd0:	bf00      	nop
    tcp_input_pcb = NULL;
 8116cd2:	4b27      	ldr	r3, [pc, #156]	; (8116d70 <tcp_input+0x7f4>)
 8116cd4:	2200      	movs	r2, #0
 8116cd6:	601a      	str	r2, [r3, #0]
    recv_data = NULL;
 8116cd8:	4b26      	ldr	r3, [pc, #152]	; (8116d74 <tcp_input+0x7f8>)
 8116cda:	2200      	movs	r2, #0
 8116cdc:	601a      	str	r2, [r3, #0]

    /* give up our reference to inseg.p */
    if (inseg.p != NULL) {
 8116cde:	4b26      	ldr	r3, [pc, #152]	; (8116d78 <tcp_input+0x7fc>)
 8116ce0:	685b      	ldr	r3, [r3, #4]
 8116ce2:	2b00      	cmp	r3, #0
 8116ce4:	d03f      	beq.n	8116d66 <tcp_input+0x7ea>
      pbuf_free(inseg.p);
 8116ce6:	4b24      	ldr	r3, [pc, #144]	; (8116d78 <tcp_input+0x7fc>)
 8116ce8:	685b      	ldr	r3, [r3, #4]
 8116cea:	4618      	mov	r0, r3
 8116cec:	f7fd fcb4 	bl	8114658 <pbuf_free>
      inseg.p = NULL;
 8116cf0:	4b21      	ldr	r3, [pc, #132]	; (8116d78 <tcp_input+0x7fc>)
 8116cf2:	2200      	movs	r2, #0
 8116cf4:	605a      	str	r2, [r3, #4]
    pbuf_free(p);
  }

  LWIP_ASSERT("tcp_input: tcp_pcbs_sane()", tcp_pcbs_sane());
  PERF_STOP("tcp_input");
  return;
 8116cf6:	e036      	b.n	8116d66 <tcp_input+0x7ea>
    if (!(TCPH_FLAGS(tcphdr) & TCP_RST)) {
 8116cf8:	4b20      	ldr	r3, [pc, #128]	; (8116d7c <tcp_input+0x800>)
 8116cfa:	681b      	ldr	r3, [r3, #0]
 8116cfc:	899b      	ldrh	r3, [r3, #12]
 8116cfe:	b29b      	uxth	r3, r3
 8116d00:	4618      	mov	r0, r3
 8116d02:	f7f7 fbc6 	bl	810e492 <lwip_htons>
 8116d06:	4603      	mov	r3, r0
 8116d08:	b2db      	uxtb	r3, r3
 8116d0a:	f003 0304 	and.w	r3, r3, #4
 8116d0e:	2b00      	cmp	r3, #0
 8116d10:	d118      	bne.n	8116d44 <tcp_input+0x7c8>
      tcp_rst(NULL, ackno, seqno + tcplen, ip_current_dest_addr(),
 8116d12:	4b1b      	ldr	r3, [pc, #108]	; (8116d80 <tcp_input+0x804>)
 8116d14:	6819      	ldr	r1, [r3, #0]
 8116d16:	4b1b      	ldr	r3, [pc, #108]	; (8116d84 <tcp_input+0x808>)
 8116d18:	881b      	ldrh	r3, [r3, #0]
 8116d1a:	461a      	mov	r2, r3
 8116d1c:	4b1a      	ldr	r3, [pc, #104]	; (8116d88 <tcp_input+0x80c>)
 8116d1e:	681b      	ldr	r3, [r3, #0]
 8116d20:	18d0      	adds	r0, r2, r3
              ip_current_src_addr(), tcphdr->dest, tcphdr->src);
 8116d22:	4b16      	ldr	r3, [pc, #88]	; (8116d7c <tcp_input+0x800>)
 8116d24:	681b      	ldr	r3, [r3, #0]
      tcp_rst(NULL, ackno, seqno + tcplen, ip_current_dest_addr(),
 8116d26:	885b      	ldrh	r3, [r3, #2]
 8116d28:	b29b      	uxth	r3, r3
              ip_current_src_addr(), tcphdr->dest, tcphdr->src);
 8116d2a:	4a14      	ldr	r2, [pc, #80]	; (8116d7c <tcp_input+0x800>)
 8116d2c:	6812      	ldr	r2, [r2, #0]
      tcp_rst(NULL, ackno, seqno + tcplen, ip_current_dest_addr(),
 8116d2e:	8812      	ldrh	r2, [r2, #0]
 8116d30:	b292      	uxth	r2, r2
 8116d32:	9202      	str	r2, [sp, #8]
 8116d34:	9301      	str	r3, [sp, #4]
 8116d36:	4b15      	ldr	r3, [pc, #84]	; (8116d8c <tcp_input+0x810>)
 8116d38:	9300      	str	r3, [sp, #0]
 8116d3a:	4b15      	ldr	r3, [pc, #84]	; (8116d90 <tcp_input+0x814>)
 8116d3c:	4602      	mov	r2, r0
 8116d3e:	2000      	movs	r0, #0
 8116d40:	f003 f81c 	bl	8119d7c <tcp_rst>
    pbuf_free(p);
 8116d44:	6878      	ldr	r0, [r7, #4]
 8116d46:	f7fd fc87 	bl	8114658 <pbuf_free>
  return;
 8116d4a:	e00c      	b.n	8116d66 <tcp_input+0x7ea>
    goto dropped;
 8116d4c:	bf00      	nop
 8116d4e:	e006      	b.n	8116d5e <tcp_input+0x7e2>
    goto dropped;
 8116d50:	bf00      	nop
 8116d52:	e004      	b.n	8116d5e <tcp_input+0x7e2>
    goto dropped;
 8116d54:	bf00      	nop
 8116d56:	e002      	b.n	8116d5e <tcp_input+0x7e2>
      goto dropped;
 8116d58:	bf00      	nop
 8116d5a:	e000      	b.n	8116d5e <tcp_input+0x7e2>
      goto dropped;
 8116d5c:	bf00      	nop
dropped:
  TCP_STATS_INC(tcp.drop);
  MIB2_STATS_INC(mib2.tcpinerrs);
  pbuf_free(p);
 8116d5e:	6878      	ldr	r0, [r7, #4]
 8116d60:	f7fd fc7a 	bl	8114658 <pbuf_free>
 8116d64:	e000      	b.n	8116d68 <tcp_input+0x7ec>
  return;
 8116d66:	bf00      	nop
}
 8116d68:	3724      	adds	r7, #36	; 0x24
 8116d6a:	46bd      	mov	sp, r7
 8116d6c:	bd90      	pop	{r4, r7, pc}
 8116d6e:	bf00      	nop
 8116d70:	10008494 	.word	0x10008494
 8116d74:	10008490 	.word	0x10008490
 8116d78:	10008460 	.word	0x10008460
 8116d7c:	10008470 	.word	0x10008470
 8116d80:	10008484 	.word	0x10008484
 8116d84:	1000848a 	.word	0x1000848a
 8116d88:	10008480 	.word	0x10008480
 8116d8c:	10005500 	.word	0x10005500
 8116d90:	10005504 	.word	0x10005504

08116d94 <tcp_input_delayed_close>:
 * any more.
 * @returns 1 if the pcb has been closed and deallocated, 0 otherwise
 */
static int
tcp_input_delayed_close(struct tcp_pcb *pcb)
{
 8116d94:	b580      	push	{r7, lr}
 8116d96:	b082      	sub	sp, #8
 8116d98:	af00      	add	r7, sp, #0
 8116d9a:	6078      	str	r0, [r7, #4]
  LWIP_ASSERT("tcp_input_delayed_close: invalid pcb", pcb != NULL);
 8116d9c:	687b      	ldr	r3, [r7, #4]
 8116d9e:	2b00      	cmp	r3, #0
 8116da0:	d106      	bne.n	8116db0 <tcp_input_delayed_close+0x1c>
 8116da2:	4b17      	ldr	r3, [pc, #92]	; (8116e00 <tcp_input_delayed_close+0x6c>)
 8116da4:	f240 225a 	movw	r2, #602	; 0x25a
 8116da8:	4916      	ldr	r1, [pc, #88]	; (8116e04 <tcp_input_delayed_close+0x70>)
 8116daa:	4817      	ldr	r0, [pc, #92]	; (8116e08 <tcp_input_delayed_close+0x74>)
 8116dac:	f004 fd28 	bl	811b800 <iprintf>

  if (recv_flags & TF_CLOSED) {
 8116db0:	4b16      	ldr	r3, [pc, #88]	; (8116e0c <tcp_input_delayed_close+0x78>)
 8116db2:	781b      	ldrb	r3, [r3, #0]
 8116db4:	f003 0310 	and.w	r3, r3, #16
 8116db8:	2b00      	cmp	r3, #0
 8116dba:	d01c      	beq.n	8116df6 <tcp_input_delayed_close+0x62>
    /* The connection has been closed and we will deallocate the
        PCB. */
    if (!(pcb->flags & TF_RXCLOSED)) {
 8116dbc:	687b      	ldr	r3, [r7, #4]
 8116dbe:	8b5b      	ldrh	r3, [r3, #26]
 8116dc0:	f003 0310 	and.w	r3, r3, #16
 8116dc4:	2b00      	cmp	r3, #0
 8116dc6:	d10d      	bne.n	8116de4 <tcp_input_delayed_close+0x50>
      /* Connection closed although the application has only shut down the
          tx side: call the PCB's err callback and indicate the closure to
          ensure the application doesn't continue using the PCB. */
      TCP_EVENT_ERR(pcb->state, pcb->errf, pcb->callback_arg, ERR_CLSD);
 8116dc8:	687b      	ldr	r3, [r7, #4]
 8116dca:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 8116dce:	2b00      	cmp	r3, #0
 8116dd0:	d008      	beq.n	8116de4 <tcp_input_delayed_close+0x50>
 8116dd2:	687b      	ldr	r3, [r7, #4]
 8116dd4:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 8116dd8:	687a      	ldr	r2, [r7, #4]
 8116dda:	6912      	ldr	r2, [r2, #16]
 8116ddc:	f06f 010e 	mvn.w	r1, #14
 8116de0:	4610      	mov	r0, r2
 8116de2:	4798      	blx	r3
    }
    tcp_pcb_remove(&tcp_active_pcbs, pcb);
 8116de4:	6879      	ldr	r1, [r7, #4]
 8116de6:	480a      	ldr	r0, [pc, #40]	; (8116e10 <tcp_input_delayed_close+0x7c>)
 8116de8:	f7ff fa50 	bl	811628c <tcp_pcb_remove>
    tcp_free(pcb);
 8116dec:	6878      	ldr	r0, [r7, #4]
 8116dee:	f7fe f83d 	bl	8114e6c <tcp_free>
    return 1;
 8116df2:	2301      	movs	r3, #1
 8116df4:	e000      	b.n	8116df8 <tcp_input_delayed_close+0x64>
  }
  return 0;
 8116df6:	2300      	movs	r3, #0
}
 8116df8:	4618      	mov	r0, r3
 8116dfa:	3708      	adds	r7, #8
 8116dfc:	46bd      	mov	sp, r7
 8116dfe:	bd80      	pop	{r7, pc}
 8116e00:	0811e6e4 	.word	0x0811e6e4
 8116e04:	0811e8e8 	.word	0x0811e8e8
 8116e08:	0811e764 	.word	0x0811e764
 8116e0c:	1000848d 	.word	0x1000848d
 8116e10:	10008454 	.word	0x10008454

08116e14 <tcp_listen_input>:
 * @note the segment which arrived is saved in global variables, therefore only the pcb
 *       involved is passed as a parameter to this function
 */
static void
tcp_listen_input(struct tcp_pcb_listen *pcb)
{
 8116e14:	b590      	push	{r4, r7, lr}
 8116e16:	b08b      	sub	sp, #44	; 0x2c
 8116e18:	af04      	add	r7, sp, #16
 8116e1a:	6078      	str	r0, [r7, #4]
  struct tcp_pcb *npcb;
  u32_t iss;
  err_t rc;

  if (flags & TCP_RST) {
 8116e1c:	4b6f      	ldr	r3, [pc, #444]	; (8116fdc <tcp_listen_input+0x1c8>)
 8116e1e:	781b      	ldrb	r3, [r3, #0]
 8116e20:	f003 0304 	and.w	r3, r3, #4
 8116e24:	2b00      	cmp	r3, #0
 8116e26:	f040 80d2 	bne.w	8116fce <tcp_listen_input+0x1ba>
    /* An incoming RST should be ignored. Return. */
    return;
  }

  LWIP_ASSERT("tcp_listen_input: invalid pcb", pcb != NULL);
 8116e2a:	687b      	ldr	r3, [r7, #4]
 8116e2c:	2b00      	cmp	r3, #0
 8116e2e:	d106      	bne.n	8116e3e <tcp_listen_input+0x2a>
 8116e30:	4b6b      	ldr	r3, [pc, #428]	; (8116fe0 <tcp_listen_input+0x1cc>)
 8116e32:	f240 2281 	movw	r2, #641	; 0x281
 8116e36:	496b      	ldr	r1, [pc, #428]	; (8116fe4 <tcp_listen_input+0x1d0>)
 8116e38:	486b      	ldr	r0, [pc, #428]	; (8116fe8 <tcp_listen_input+0x1d4>)
 8116e3a:	f004 fce1 	bl	811b800 <iprintf>

  /* In the LISTEN state, we check for incoming SYN segments,
     creates a new PCB, and responds with a SYN|ACK. */
  if (flags & TCP_ACK) {
 8116e3e:	4b67      	ldr	r3, [pc, #412]	; (8116fdc <tcp_listen_input+0x1c8>)
 8116e40:	781b      	ldrb	r3, [r3, #0]
 8116e42:	f003 0310 	and.w	r3, r3, #16
 8116e46:	2b00      	cmp	r3, #0
 8116e48:	d019      	beq.n	8116e7e <tcp_listen_input+0x6a>
    /* For incoming segments with the ACK flag set, respond with a
       RST. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_listen_input: ACK in LISTEN, sending reset\n"));
    tcp_rst((const struct tcp_pcb *)pcb, ackno, seqno + tcplen, ip_current_dest_addr(),
 8116e4a:	4b68      	ldr	r3, [pc, #416]	; (8116fec <tcp_listen_input+0x1d8>)
 8116e4c:	6819      	ldr	r1, [r3, #0]
 8116e4e:	4b68      	ldr	r3, [pc, #416]	; (8116ff0 <tcp_listen_input+0x1dc>)
 8116e50:	881b      	ldrh	r3, [r3, #0]
 8116e52:	461a      	mov	r2, r3
 8116e54:	4b67      	ldr	r3, [pc, #412]	; (8116ff4 <tcp_listen_input+0x1e0>)
 8116e56:	681b      	ldr	r3, [r3, #0]
 8116e58:	18d0      	adds	r0, r2, r3
            ip_current_src_addr(), tcphdr->dest, tcphdr->src);
 8116e5a:	4b67      	ldr	r3, [pc, #412]	; (8116ff8 <tcp_listen_input+0x1e4>)
 8116e5c:	681b      	ldr	r3, [r3, #0]
    tcp_rst((const struct tcp_pcb *)pcb, ackno, seqno + tcplen, ip_current_dest_addr(),
 8116e5e:	885b      	ldrh	r3, [r3, #2]
 8116e60:	b29b      	uxth	r3, r3
            ip_current_src_addr(), tcphdr->dest, tcphdr->src);
 8116e62:	4a65      	ldr	r2, [pc, #404]	; (8116ff8 <tcp_listen_input+0x1e4>)
 8116e64:	6812      	ldr	r2, [r2, #0]
    tcp_rst((const struct tcp_pcb *)pcb, ackno, seqno + tcplen, ip_current_dest_addr(),
 8116e66:	8812      	ldrh	r2, [r2, #0]
 8116e68:	b292      	uxth	r2, r2
 8116e6a:	9202      	str	r2, [sp, #8]
 8116e6c:	9301      	str	r3, [sp, #4]
 8116e6e:	4b63      	ldr	r3, [pc, #396]	; (8116ffc <tcp_listen_input+0x1e8>)
 8116e70:	9300      	str	r3, [sp, #0]
 8116e72:	4b63      	ldr	r3, [pc, #396]	; (8117000 <tcp_listen_input+0x1ec>)
 8116e74:	4602      	mov	r2, r0
 8116e76:	6878      	ldr	r0, [r7, #4]
 8116e78:	f002 ff80 	bl	8119d7c <tcp_rst>
      tcp_abandon(npcb, 0);
      return;
    }
    tcp_output(npcb);
  }
  return;
 8116e7c:	e0a9      	b.n	8116fd2 <tcp_listen_input+0x1be>
  } else if (flags & TCP_SYN) {
 8116e7e:	4b57      	ldr	r3, [pc, #348]	; (8116fdc <tcp_listen_input+0x1c8>)
 8116e80:	781b      	ldrb	r3, [r3, #0]
 8116e82:	f003 0302 	and.w	r3, r3, #2
 8116e86:	2b00      	cmp	r3, #0
 8116e88:	f000 80a3 	beq.w	8116fd2 <tcp_listen_input+0x1be>
    npcb = tcp_alloc(pcb->prio);
 8116e8c:	687b      	ldr	r3, [r7, #4]
 8116e8e:	7d5b      	ldrb	r3, [r3, #21]
 8116e90:	4618      	mov	r0, r3
 8116e92:	f7ff f927 	bl	81160e4 <tcp_alloc>
 8116e96:	6178      	str	r0, [r7, #20]
    if (npcb == NULL) {
 8116e98:	697b      	ldr	r3, [r7, #20]
 8116e9a:	2b00      	cmp	r3, #0
 8116e9c:	d111      	bne.n	8116ec2 <tcp_listen_input+0xae>
      TCP_EVENT_ACCEPT(pcb, NULL, pcb->callback_arg, ERR_MEM, err);
 8116e9e:	687b      	ldr	r3, [r7, #4]
 8116ea0:	699b      	ldr	r3, [r3, #24]
 8116ea2:	2b00      	cmp	r3, #0
 8116ea4:	d00a      	beq.n	8116ebc <tcp_listen_input+0xa8>
 8116ea6:	687b      	ldr	r3, [r7, #4]
 8116ea8:	699b      	ldr	r3, [r3, #24]
 8116eaa:	687a      	ldr	r2, [r7, #4]
 8116eac:	6910      	ldr	r0, [r2, #16]
 8116eae:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 8116eb2:	2100      	movs	r1, #0
 8116eb4:	4798      	blx	r3
 8116eb6:	4603      	mov	r3, r0
 8116eb8:	73bb      	strb	r3, [r7, #14]
      return;
 8116eba:	e08b      	b.n	8116fd4 <tcp_listen_input+0x1c0>
      TCP_EVENT_ACCEPT(pcb, NULL, pcb->callback_arg, ERR_MEM, err);
 8116ebc:	23f0      	movs	r3, #240	; 0xf0
 8116ebe:	73bb      	strb	r3, [r7, #14]
      return;
 8116ec0:	e088      	b.n	8116fd4 <tcp_listen_input+0x1c0>
    ip_addr_copy(npcb->local_ip, *ip_current_dest_addr());
 8116ec2:	4b50      	ldr	r3, [pc, #320]	; (8117004 <tcp_listen_input+0x1f0>)
 8116ec4:	695a      	ldr	r2, [r3, #20]
 8116ec6:	697b      	ldr	r3, [r7, #20]
 8116ec8:	601a      	str	r2, [r3, #0]
    ip_addr_copy(npcb->remote_ip, *ip_current_src_addr());
 8116eca:	4b4e      	ldr	r3, [pc, #312]	; (8117004 <tcp_listen_input+0x1f0>)
 8116ecc:	691a      	ldr	r2, [r3, #16]
 8116ece:	697b      	ldr	r3, [r7, #20]
 8116ed0:	605a      	str	r2, [r3, #4]
    npcb->local_port = pcb->local_port;
 8116ed2:	687b      	ldr	r3, [r7, #4]
 8116ed4:	8ada      	ldrh	r2, [r3, #22]
 8116ed6:	697b      	ldr	r3, [r7, #20]
 8116ed8:	82da      	strh	r2, [r3, #22]
    npcb->remote_port = tcphdr->src;
 8116eda:	4b47      	ldr	r3, [pc, #284]	; (8116ff8 <tcp_listen_input+0x1e4>)
 8116edc:	681b      	ldr	r3, [r3, #0]
 8116ede:	881b      	ldrh	r3, [r3, #0]
 8116ee0:	b29a      	uxth	r2, r3
 8116ee2:	697b      	ldr	r3, [r7, #20]
 8116ee4:	831a      	strh	r2, [r3, #24]
    npcb->state = SYN_RCVD;
 8116ee6:	697b      	ldr	r3, [r7, #20]
 8116ee8:	2203      	movs	r2, #3
 8116eea:	751a      	strb	r2, [r3, #20]
    npcb->rcv_nxt = seqno + 1;
 8116eec:	4b41      	ldr	r3, [pc, #260]	; (8116ff4 <tcp_listen_input+0x1e0>)
 8116eee:	681b      	ldr	r3, [r3, #0]
 8116ef0:	1c5a      	adds	r2, r3, #1
 8116ef2:	697b      	ldr	r3, [r7, #20]
 8116ef4:	625a      	str	r2, [r3, #36]	; 0x24
    npcb->rcv_ann_right_edge = npcb->rcv_nxt;
 8116ef6:	697b      	ldr	r3, [r7, #20]
 8116ef8:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8116efa:	697b      	ldr	r3, [r7, #20]
 8116efc:	62da      	str	r2, [r3, #44]	; 0x2c
    iss = tcp_next_iss(npcb);
 8116efe:	6978      	ldr	r0, [r7, #20]
 8116f00:	f7ff fa58 	bl	81163b4 <tcp_next_iss>
 8116f04:	6138      	str	r0, [r7, #16]
    npcb->snd_wl2 = iss;
 8116f06:	697b      	ldr	r3, [r7, #20]
 8116f08:	693a      	ldr	r2, [r7, #16]
 8116f0a:	659a      	str	r2, [r3, #88]	; 0x58
    npcb->snd_nxt = iss;
 8116f0c:	697b      	ldr	r3, [r7, #20]
 8116f0e:	693a      	ldr	r2, [r7, #16]
 8116f10:	651a      	str	r2, [r3, #80]	; 0x50
    npcb->lastack = iss;
 8116f12:	697b      	ldr	r3, [r7, #20]
 8116f14:	693a      	ldr	r2, [r7, #16]
 8116f16:	645a      	str	r2, [r3, #68]	; 0x44
    npcb->snd_lbb = iss;
 8116f18:	697b      	ldr	r3, [r7, #20]
 8116f1a:	693a      	ldr	r2, [r7, #16]
 8116f1c:	65da      	str	r2, [r3, #92]	; 0x5c
    npcb->snd_wl1 = seqno - 1;/* initialise to seqno-1 to force window update */
 8116f1e:	4b35      	ldr	r3, [pc, #212]	; (8116ff4 <tcp_listen_input+0x1e0>)
 8116f20:	681b      	ldr	r3, [r3, #0]
 8116f22:	1e5a      	subs	r2, r3, #1
 8116f24:	697b      	ldr	r3, [r7, #20]
 8116f26:	655a      	str	r2, [r3, #84]	; 0x54
    npcb->callback_arg = pcb->callback_arg;
 8116f28:	687b      	ldr	r3, [r7, #4]
 8116f2a:	691a      	ldr	r2, [r3, #16]
 8116f2c:	697b      	ldr	r3, [r7, #20]
 8116f2e:	611a      	str	r2, [r3, #16]
    npcb->listener = pcb;
 8116f30:	697b      	ldr	r3, [r7, #20]
 8116f32:	687a      	ldr	r2, [r7, #4]
 8116f34:	67da      	str	r2, [r3, #124]	; 0x7c
    npcb->so_options = pcb->so_options & SOF_INHERITED;
 8116f36:	687b      	ldr	r3, [r7, #4]
 8116f38:	7a5b      	ldrb	r3, [r3, #9]
 8116f3a:	f003 030c 	and.w	r3, r3, #12
 8116f3e:	b2da      	uxtb	r2, r3
 8116f40:	697b      	ldr	r3, [r7, #20]
 8116f42:	725a      	strb	r2, [r3, #9]
    npcb->netif_idx = pcb->netif_idx;
 8116f44:	687b      	ldr	r3, [r7, #4]
 8116f46:	7a1a      	ldrb	r2, [r3, #8]
 8116f48:	697b      	ldr	r3, [r7, #20]
 8116f4a:	721a      	strb	r2, [r3, #8]
    TCP_REG_ACTIVE(npcb);
 8116f4c:	4b2e      	ldr	r3, [pc, #184]	; (8117008 <tcp_listen_input+0x1f4>)
 8116f4e:	681a      	ldr	r2, [r3, #0]
 8116f50:	697b      	ldr	r3, [r7, #20]
 8116f52:	60da      	str	r2, [r3, #12]
 8116f54:	4a2c      	ldr	r2, [pc, #176]	; (8117008 <tcp_listen_input+0x1f4>)
 8116f56:	697b      	ldr	r3, [r7, #20]
 8116f58:	6013      	str	r3, [r2, #0]
 8116f5a:	f003 f8d1 	bl	811a100 <tcp_timer_needed>
 8116f5e:	4b2b      	ldr	r3, [pc, #172]	; (811700c <tcp_listen_input+0x1f8>)
 8116f60:	2201      	movs	r2, #1
 8116f62:	701a      	strb	r2, [r3, #0]
    tcp_parseopt(npcb);
 8116f64:	6978      	ldr	r0, [r7, #20]
 8116f66:	f001 fd8f 	bl	8118a88 <tcp_parseopt>
    npcb->snd_wnd = tcphdr->wnd;
 8116f6a:	4b23      	ldr	r3, [pc, #140]	; (8116ff8 <tcp_listen_input+0x1e4>)
 8116f6c:	681b      	ldr	r3, [r3, #0]
 8116f6e:	89db      	ldrh	r3, [r3, #14]
 8116f70:	b29a      	uxth	r2, r3
 8116f72:	697b      	ldr	r3, [r7, #20]
 8116f74:	f8a3 2060 	strh.w	r2, [r3, #96]	; 0x60
    npcb->snd_wnd_max = npcb->snd_wnd;
 8116f78:	697b      	ldr	r3, [r7, #20]
 8116f7a:	f8b3 2060 	ldrh.w	r2, [r3, #96]	; 0x60
 8116f7e:	697b      	ldr	r3, [r7, #20]
 8116f80:	f8a3 2062 	strh.w	r2, [r3, #98]	; 0x62
    npcb->mss = tcp_eff_send_mss(npcb->mss, &npcb->local_ip, &npcb->remote_ip);
 8116f84:	697b      	ldr	r3, [r7, #20]
 8116f86:	8e5c      	ldrh	r4, [r3, #50]	; 0x32
 8116f88:	697b      	ldr	r3, [r7, #20]
 8116f8a:	3304      	adds	r3, #4
 8116f8c:	4618      	mov	r0, r3
 8116f8e:	f7fa ff2d 	bl	8111dec <ip4_route>
 8116f92:	4601      	mov	r1, r0
 8116f94:	697b      	ldr	r3, [r7, #20]
 8116f96:	3304      	adds	r3, #4
 8116f98:	461a      	mov	r2, r3
 8116f9a:	4620      	mov	r0, r4
 8116f9c:	f7ff fa30 	bl	8116400 <tcp_eff_send_mss_netif>
 8116fa0:	4603      	mov	r3, r0
 8116fa2:	461a      	mov	r2, r3
 8116fa4:	697b      	ldr	r3, [r7, #20]
 8116fa6:	865a      	strh	r2, [r3, #50]	; 0x32
    rc = tcp_enqueue_flags(npcb, TCP_SYN | TCP_ACK);
 8116fa8:	2112      	movs	r1, #18
 8116faa:	6978      	ldr	r0, [r7, #20]
 8116fac:	f002 f844 	bl	8119038 <tcp_enqueue_flags>
 8116fb0:	4603      	mov	r3, r0
 8116fb2:	73fb      	strb	r3, [r7, #15]
    if (rc != ERR_OK) {
 8116fb4:	f997 300f 	ldrsb.w	r3, [r7, #15]
 8116fb8:	2b00      	cmp	r3, #0
 8116fba:	d004      	beq.n	8116fc6 <tcp_listen_input+0x1b2>
      tcp_abandon(npcb, 0);
 8116fbc:	2100      	movs	r1, #0
 8116fbe:	6978      	ldr	r0, [r7, #20]
 8116fc0:	f7fe f97e 	bl	81152c0 <tcp_abandon>
      return;
 8116fc4:	e006      	b.n	8116fd4 <tcp_listen_input+0x1c0>
    tcp_output(npcb);
 8116fc6:	6978      	ldr	r0, [r7, #20]
 8116fc8:	f002 f924 	bl	8119214 <tcp_output>
  return;
 8116fcc:	e001      	b.n	8116fd2 <tcp_listen_input+0x1be>
    return;
 8116fce:	bf00      	nop
 8116fd0:	e000      	b.n	8116fd4 <tcp_listen_input+0x1c0>
  return;
 8116fd2:	bf00      	nop
}
 8116fd4:	371c      	adds	r7, #28
 8116fd6:	46bd      	mov	sp, r7
 8116fd8:	bd90      	pop	{r4, r7, pc}
 8116fda:	bf00      	nop
 8116fdc:	1000848c 	.word	0x1000848c
 8116fe0:	0811e6e4 	.word	0x0811e6e4
 8116fe4:	0811e910 	.word	0x0811e910
 8116fe8:	0811e764 	.word	0x0811e764
 8116fec:	10008484 	.word	0x10008484
 8116ff0:	1000848a 	.word	0x1000848a
 8116ff4:	10008480 	.word	0x10008480
 8116ff8:	10008470 	.word	0x10008470
 8116ffc:	10005500 	.word	0x10005500
 8117000:	10005504 	.word	0x10005504
 8117004:	100054f0 	.word	0x100054f0
 8117008:	10008454 	.word	0x10008454
 811700c:	1000845c 	.word	0x1000845c

08117010 <tcp_timewait_input>:
 * @note the segment which arrived is saved in global variables, therefore only the pcb
 *       involved is passed as a parameter to this function
 */
static void
tcp_timewait_input(struct tcp_pcb *pcb)
{
 8117010:	b580      	push	{r7, lr}
 8117012:	b086      	sub	sp, #24
 8117014:	af04      	add	r7, sp, #16
 8117016:	6078      	str	r0, [r7, #4]
  /* RFC 1337: in TIME_WAIT, ignore RST and ACK FINs + any 'acceptable' segments */
  /* RFC 793 3.9 Event Processing - Segment Arrives:
   * - first check sequence number - we skip that one in TIME_WAIT (always
   *   acceptable since we only send ACKs)
   * - second check the RST bit (... return) */
  if (flags & TCP_RST) {
 8117018:	4b2f      	ldr	r3, [pc, #188]	; (81170d8 <tcp_timewait_input+0xc8>)
 811701a:	781b      	ldrb	r3, [r3, #0]
 811701c:	f003 0304 	and.w	r3, r3, #4
 8117020:	2b00      	cmp	r3, #0
 8117022:	d153      	bne.n	81170cc <tcp_timewait_input+0xbc>
    return;
  }

  LWIP_ASSERT("tcp_timewait_input: invalid pcb", pcb != NULL);
 8117024:	687b      	ldr	r3, [r7, #4]
 8117026:	2b00      	cmp	r3, #0
 8117028:	d106      	bne.n	8117038 <tcp_timewait_input+0x28>
 811702a:	4b2c      	ldr	r3, [pc, #176]	; (81170dc <tcp_timewait_input+0xcc>)
 811702c:	f240 22ee 	movw	r2, #750	; 0x2ee
 8117030:	492b      	ldr	r1, [pc, #172]	; (81170e0 <tcp_timewait_input+0xd0>)
 8117032:	482c      	ldr	r0, [pc, #176]	; (81170e4 <tcp_timewait_input+0xd4>)
 8117034:	f004 fbe4 	bl	811b800 <iprintf>

  /* - fourth, check the SYN bit, */
  if (flags & TCP_SYN) {
 8117038:	4b27      	ldr	r3, [pc, #156]	; (81170d8 <tcp_timewait_input+0xc8>)
 811703a:	781b      	ldrb	r3, [r3, #0]
 811703c:	f003 0302 	and.w	r3, r3, #2
 8117040:	2b00      	cmp	r3, #0
 8117042:	d02a      	beq.n	811709a <tcp_timewait_input+0x8a>
    /* If an incoming segment is not acceptable, an acknowledgment
       should be sent in reply */
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, pcb->rcv_nxt + pcb->rcv_wnd)) {
 8117044:	4b28      	ldr	r3, [pc, #160]	; (81170e8 <tcp_timewait_input+0xd8>)
 8117046:	681a      	ldr	r2, [r3, #0]
 8117048:	687b      	ldr	r3, [r7, #4]
 811704a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 811704c:	1ad3      	subs	r3, r2, r3
 811704e:	2b00      	cmp	r3, #0
 8117050:	db2d      	blt.n	81170ae <tcp_timewait_input+0x9e>
 8117052:	4b25      	ldr	r3, [pc, #148]	; (81170e8 <tcp_timewait_input+0xd8>)
 8117054:	681a      	ldr	r2, [r3, #0]
 8117056:	687b      	ldr	r3, [r7, #4]
 8117058:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 811705a:	6879      	ldr	r1, [r7, #4]
 811705c:	8d09      	ldrh	r1, [r1, #40]	; 0x28
 811705e:	440b      	add	r3, r1
 8117060:	1ad3      	subs	r3, r2, r3
 8117062:	2b00      	cmp	r3, #0
 8117064:	dc23      	bgt.n	81170ae <tcp_timewait_input+0x9e>
      /* If the SYN is in the window it is an error, send a reset */
      tcp_rst(pcb, ackno, seqno + tcplen, ip_current_dest_addr(),
 8117066:	4b21      	ldr	r3, [pc, #132]	; (81170ec <tcp_timewait_input+0xdc>)
 8117068:	6819      	ldr	r1, [r3, #0]
 811706a:	4b21      	ldr	r3, [pc, #132]	; (81170f0 <tcp_timewait_input+0xe0>)
 811706c:	881b      	ldrh	r3, [r3, #0]
 811706e:	461a      	mov	r2, r3
 8117070:	4b1d      	ldr	r3, [pc, #116]	; (81170e8 <tcp_timewait_input+0xd8>)
 8117072:	681b      	ldr	r3, [r3, #0]
 8117074:	18d0      	adds	r0, r2, r3
              ip_current_src_addr(), tcphdr->dest, tcphdr->src);
 8117076:	4b1f      	ldr	r3, [pc, #124]	; (81170f4 <tcp_timewait_input+0xe4>)
 8117078:	681b      	ldr	r3, [r3, #0]
      tcp_rst(pcb, ackno, seqno + tcplen, ip_current_dest_addr(),
 811707a:	885b      	ldrh	r3, [r3, #2]
 811707c:	b29b      	uxth	r3, r3
              ip_current_src_addr(), tcphdr->dest, tcphdr->src);
 811707e:	4a1d      	ldr	r2, [pc, #116]	; (81170f4 <tcp_timewait_input+0xe4>)
 8117080:	6812      	ldr	r2, [r2, #0]
      tcp_rst(pcb, ackno, seqno + tcplen, ip_current_dest_addr(),
 8117082:	8812      	ldrh	r2, [r2, #0]
 8117084:	b292      	uxth	r2, r2
 8117086:	9202      	str	r2, [sp, #8]
 8117088:	9301      	str	r3, [sp, #4]
 811708a:	4b1b      	ldr	r3, [pc, #108]	; (81170f8 <tcp_timewait_input+0xe8>)
 811708c:	9300      	str	r3, [sp, #0]
 811708e:	4b1b      	ldr	r3, [pc, #108]	; (81170fc <tcp_timewait_input+0xec>)
 8117090:	4602      	mov	r2, r0
 8117092:	6878      	ldr	r0, [r7, #4]
 8117094:	f002 fe72 	bl	8119d7c <tcp_rst>
      return;
 8117098:	e01b      	b.n	81170d2 <tcp_timewait_input+0xc2>
    }
  } else if (flags & TCP_FIN) {
 811709a:	4b0f      	ldr	r3, [pc, #60]	; (81170d8 <tcp_timewait_input+0xc8>)
 811709c:	781b      	ldrb	r3, [r3, #0]
 811709e:	f003 0301 	and.w	r3, r3, #1
 81170a2:	2b00      	cmp	r3, #0
 81170a4:	d003      	beq.n	81170ae <tcp_timewait_input+0x9e>
    /* - eighth, check the FIN bit: Remain in the TIME-WAIT state.
         Restart the 2 MSL time-wait timeout.*/
    pcb->tmr = tcp_ticks;
 81170a6:	4b16      	ldr	r3, [pc, #88]	; (8117100 <tcp_timewait_input+0xf0>)
 81170a8:	681a      	ldr	r2, [r3, #0]
 81170aa:	687b      	ldr	r3, [r7, #4]
 81170ac:	621a      	str	r2, [r3, #32]
  }

  if ((tcplen > 0)) {
 81170ae:	4b10      	ldr	r3, [pc, #64]	; (81170f0 <tcp_timewait_input+0xe0>)
 81170b0:	881b      	ldrh	r3, [r3, #0]
 81170b2:	2b00      	cmp	r3, #0
 81170b4:	d00c      	beq.n	81170d0 <tcp_timewait_input+0xc0>
    /* Acknowledge data, FIN or out-of-window SYN */
    tcp_ack_now(pcb);
 81170b6:	687b      	ldr	r3, [r7, #4]
 81170b8:	8b5b      	ldrh	r3, [r3, #26]
 81170ba:	f043 0302 	orr.w	r3, r3, #2
 81170be:	b29a      	uxth	r2, r3
 81170c0:	687b      	ldr	r3, [r7, #4]
 81170c2:	835a      	strh	r2, [r3, #26]
    tcp_output(pcb);
 81170c4:	6878      	ldr	r0, [r7, #4]
 81170c6:	f002 f8a5 	bl	8119214 <tcp_output>
  }
  return;
 81170ca:	e001      	b.n	81170d0 <tcp_timewait_input+0xc0>
    return;
 81170cc:	bf00      	nop
 81170ce:	e000      	b.n	81170d2 <tcp_timewait_input+0xc2>
  return;
 81170d0:	bf00      	nop
}
 81170d2:	3708      	adds	r7, #8
 81170d4:	46bd      	mov	sp, r7
 81170d6:	bd80      	pop	{r7, pc}
 81170d8:	1000848c 	.word	0x1000848c
 81170dc:	0811e6e4 	.word	0x0811e6e4
 81170e0:	0811e930 	.word	0x0811e930
 81170e4:	0811e764 	.word	0x0811e764
 81170e8:	10008480 	.word	0x10008480
 81170ec:	10008484 	.word	0x10008484
 81170f0:	1000848a 	.word	0x1000848a
 81170f4:	10008470 	.word	0x10008470
 81170f8:	10005500 	.word	0x10005500
 81170fc:	10005504 	.word	0x10005504
 8117100:	10008448 	.word	0x10008448

08117104 <tcp_process>:
 * @note the segment which arrived is saved in global variables, therefore only the pcb
 *       involved is passed as a parameter to this function
 */
static err_t
tcp_process(struct tcp_pcb *pcb)
{
 8117104:	b590      	push	{r4, r7, lr}
 8117106:	b08d      	sub	sp, #52	; 0x34
 8117108:	af04      	add	r7, sp, #16
 811710a:	6078      	str	r0, [r7, #4]
  struct tcp_seg *rseg;
  u8_t acceptable = 0;
 811710c:	2300      	movs	r3, #0
 811710e:	76fb      	strb	r3, [r7, #27]
  err_t err;

  err = ERR_OK;
 8117110:	2300      	movs	r3, #0
 8117112:	76bb      	strb	r3, [r7, #26]

  LWIP_ASSERT("tcp_process: invalid pcb", pcb != NULL);
 8117114:	687b      	ldr	r3, [r7, #4]
 8117116:	2b00      	cmp	r3, #0
 8117118:	d106      	bne.n	8117128 <tcp_process+0x24>
 811711a:	4b9d      	ldr	r3, [pc, #628]	; (8117390 <tcp_process+0x28c>)
 811711c:	f44f 7247 	mov.w	r2, #796	; 0x31c
 8117120:	499c      	ldr	r1, [pc, #624]	; (8117394 <tcp_process+0x290>)
 8117122:	489d      	ldr	r0, [pc, #628]	; (8117398 <tcp_process+0x294>)
 8117124:	f004 fb6c 	bl	811b800 <iprintf>

  /* Process incoming RST segments. */
  if (flags & TCP_RST) {
 8117128:	4b9c      	ldr	r3, [pc, #624]	; (811739c <tcp_process+0x298>)
 811712a:	781b      	ldrb	r3, [r3, #0]
 811712c:	f003 0304 	and.w	r3, r3, #4
 8117130:	2b00      	cmp	r3, #0
 8117132:	d04e      	beq.n	81171d2 <tcp_process+0xce>
    /* First, determine if the reset is acceptable. */
    if (pcb->state == SYN_SENT) {
 8117134:	687b      	ldr	r3, [r7, #4]
 8117136:	7d1b      	ldrb	r3, [r3, #20]
 8117138:	2b02      	cmp	r3, #2
 811713a:	d108      	bne.n	811714e <tcp_process+0x4a>
      /* "In the SYN-SENT state (a RST received in response to an initial SYN),
          the RST is acceptable if the ACK field acknowledges the SYN." */
      if (ackno == pcb->snd_nxt) {
 811713c:	687b      	ldr	r3, [r7, #4]
 811713e:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 8117140:	4b97      	ldr	r3, [pc, #604]	; (81173a0 <tcp_process+0x29c>)
 8117142:	681b      	ldr	r3, [r3, #0]
 8117144:	429a      	cmp	r2, r3
 8117146:	d123      	bne.n	8117190 <tcp_process+0x8c>
        acceptable = 1;
 8117148:	2301      	movs	r3, #1
 811714a:	76fb      	strb	r3, [r7, #27]
 811714c:	e020      	b.n	8117190 <tcp_process+0x8c>
      }
    } else {
      /* "In all states except SYN-SENT, all reset (RST) segments are validated
          by checking their SEQ-fields." */
      if (seqno == pcb->rcv_nxt) {
 811714e:	687b      	ldr	r3, [r7, #4]
 8117150:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8117152:	4b94      	ldr	r3, [pc, #592]	; (81173a4 <tcp_process+0x2a0>)
 8117154:	681b      	ldr	r3, [r3, #0]
 8117156:	429a      	cmp	r2, r3
 8117158:	d102      	bne.n	8117160 <tcp_process+0x5c>
        acceptable = 1;
 811715a:	2301      	movs	r3, #1
 811715c:	76fb      	strb	r3, [r7, #27]
 811715e:	e017      	b.n	8117190 <tcp_process+0x8c>
      } else  if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt,
 8117160:	4b90      	ldr	r3, [pc, #576]	; (81173a4 <tcp_process+0x2a0>)
 8117162:	681a      	ldr	r2, [r3, #0]
 8117164:	687b      	ldr	r3, [r7, #4]
 8117166:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8117168:	1ad3      	subs	r3, r2, r3
 811716a:	2b00      	cmp	r3, #0
 811716c:	db10      	blt.n	8117190 <tcp_process+0x8c>
 811716e:	4b8d      	ldr	r3, [pc, #564]	; (81173a4 <tcp_process+0x2a0>)
 8117170:	681a      	ldr	r2, [r3, #0]
 8117172:	687b      	ldr	r3, [r7, #4]
 8117174:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8117176:	6879      	ldr	r1, [r7, #4]
 8117178:	8d09      	ldrh	r1, [r1, #40]	; 0x28
 811717a:	440b      	add	r3, r1
 811717c:	1ad3      	subs	r3, r2, r3
 811717e:	2b00      	cmp	r3, #0
 8117180:	dc06      	bgt.n	8117190 <tcp_process+0x8c>
                                  pcb->rcv_nxt + pcb->rcv_wnd)) {
        /* If the sequence number is inside the window, we send a challenge ACK
           and wait for a re-send with matching sequence number.
           This follows RFC 5961 section 3.2 and addresses CVE-2004-0230
           (RST spoofing attack), which is present in RFC 793 RST handling. */
        tcp_ack_now(pcb);
 8117182:	687b      	ldr	r3, [r7, #4]
 8117184:	8b5b      	ldrh	r3, [r3, #26]
 8117186:	f043 0302 	orr.w	r3, r3, #2
 811718a:	b29a      	uxth	r2, r3
 811718c:	687b      	ldr	r3, [r7, #4]
 811718e:	835a      	strh	r2, [r3, #26]
      }
    }

    if (acceptable) {
 8117190:	7efb      	ldrb	r3, [r7, #27]
 8117192:	2b00      	cmp	r3, #0
 8117194:	d01b      	beq.n	81171ce <tcp_process+0xca>
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_process: Connection RESET\n"));
      LWIP_ASSERT("tcp_input: pcb->state != CLOSED", pcb->state != CLOSED);
 8117196:	687b      	ldr	r3, [r7, #4]
 8117198:	7d1b      	ldrb	r3, [r3, #20]
 811719a:	2b00      	cmp	r3, #0
 811719c:	d106      	bne.n	81171ac <tcp_process+0xa8>
 811719e:	4b7c      	ldr	r3, [pc, #496]	; (8117390 <tcp_process+0x28c>)
 81171a0:	f44f 724e 	mov.w	r2, #824	; 0x338
 81171a4:	4980      	ldr	r1, [pc, #512]	; (81173a8 <tcp_process+0x2a4>)
 81171a6:	487c      	ldr	r0, [pc, #496]	; (8117398 <tcp_process+0x294>)
 81171a8:	f004 fb2a 	bl	811b800 <iprintf>
      recv_flags |= TF_RESET;
 81171ac:	4b7f      	ldr	r3, [pc, #508]	; (81173ac <tcp_process+0x2a8>)
 81171ae:	781b      	ldrb	r3, [r3, #0]
 81171b0:	f043 0308 	orr.w	r3, r3, #8
 81171b4:	b2da      	uxtb	r2, r3
 81171b6:	4b7d      	ldr	r3, [pc, #500]	; (81173ac <tcp_process+0x2a8>)
 81171b8:	701a      	strb	r2, [r3, #0]
      tcp_clear_flags(pcb, TF_ACK_DELAY);
 81171ba:	687b      	ldr	r3, [r7, #4]
 81171bc:	8b5b      	ldrh	r3, [r3, #26]
 81171be:	f023 0301 	bic.w	r3, r3, #1
 81171c2:	b29a      	uxth	r2, r3
 81171c4:	687b      	ldr	r3, [r7, #4]
 81171c6:	835a      	strh	r2, [r3, #26]
      return ERR_RST;
 81171c8:	f06f 030d 	mvn.w	r3, #13
 81171cc:	e37a      	b.n	81178c4 <tcp_process+0x7c0>
    } else {
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_process: unacceptable reset seqno %"U32_F" rcv_nxt %"U32_F"\n",
                                    seqno, pcb->rcv_nxt));
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_process: unacceptable reset seqno %"U32_F" rcv_nxt %"U32_F"\n",
                              seqno, pcb->rcv_nxt));
      return ERR_OK;
 81171ce:	2300      	movs	r3, #0
 81171d0:	e378      	b.n	81178c4 <tcp_process+0x7c0>
    }
  }

  if ((flags & TCP_SYN) && (pcb->state != SYN_SENT && pcb->state != SYN_RCVD)) {
 81171d2:	4b72      	ldr	r3, [pc, #456]	; (811739c <tcp_process+0x298>)
 81171d4:	781b      	ldrb	r3, [r3, #0]
 81171d6:	f003 0302 	and.w	r3, r3, #2
 81171da:	2b00      	cmp	r3, #0
 81171dc:	d010      	beq.n	8117200 <tcp_process+0xfc>
 81171de:	687b      	ldr	r3, [r7, #4]
 81171e0:	7d1b      	ldrb	r3, [r3, #20]
 81171e2:	2b02      	cmp	r3, #2
 81171e4:	d00c      	beq.n	8117200 <tcp_process+0xfc>
 81171e6:	687b      	ldr	r3, [r7, #4]
 81171e8:	7d1b      	ldrb	r3, [r3, #20]
 81171ea:	2b03      	cmp	r3, #3
 81171ec:	d008      	beq.n	8117200 <tcp_process+0xfc>
    /* Cope with new connection attempt after remote end crashed */
    tcp_ack_now(pcb);
 81171ee:	687b      	ldr	r3, [r7, #4]
 81171f0:	8b5b      	ldrh	r3, [r3, #26]
 81171f2:	f043 0302 	orr.w	r3, r3, #2
 81171f6:	b29a      	uxth	r2, r3
 81171f8:	687b      	ldr	r3, [r7, #4]
 81171fa:	835a      	strh	r2, [r3, #26]
    return ERR_OK;
 81171fc:	2300      	movs	r3, #0
 81171fe:	e361      	b.n	81178c4 <tcp_process+0x7c0>
  }

  if ((pcb->flags & TF_RXCLOSED) == 0) {
 8117200:	687b      	ldr	r3, [r7, #4]
 8117202:	8b5b      	ldrh	r3, [r3, #26]
 8117204:	f003 0310 	and.w	r3, r3, #16
 8117208:	2b00      	cmp	r3, #0
 811720a:	d103      	bne.n	8117214 <tcp_process+0x110>
    /* Update the PCB (in)activity timer unless rx is closed (see tcp_shutdown) */
    pcb->tmr = tcp_ticks;
 811720c:	4b68      	ldr	r3, [pc, #416]	; (81173b0 <tcp_process+0x2ac>)
 811720e:	681a      	ldr	r2, [r3, #0]
 8117210:	687b      	ldr	r3, [r7, #4]
 8117212:	621a      	str	r2, [r3, #32]
  }
  pcb->keep_cnt_sent = 0;
 8117214:	687b      	ldr	r3, [r7, #4]
 8117216:	2200      	movs	r2, #0
 8117218:	f883 209b 	strb.w	r2, [r3, #155]	; 0x9b
  pcb->persist_probe = 0;
 811721c:	687b      	ldr	r3, [r7, #4]
 811721e:	2200      	movs	r2, #0
 8117220:	f883 209a 	strb.w	r2, [r3, #154]	; 0x9a

  tcp_parseopt(pcb);
 8117224:	6878      	ldr	r0, [r7, #4]
 8117226:	f001 fc2f 	bl	8118a88 <tcp_parseopt>

  /* Do different things depending on the TCP state. */
  switch (pcb->state) {
 811722a:	687b      	ldr	r3, [r7, #4]
 811722c:	7d1b      	ldrb	r3, [r3, #20]
 811722e:	3b02      	subs	r3, #2
 8117230:	2b07      	cmp	r3, #7
 8117232:	f200 8337 	bhi.w	81178a4 <tcp_process+0x7a0>
 8117236:	a201      	add	r2, pc, #4	; (adr r2, 811723c <tcp_process+0x138>)
 8117238:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 811723c:	0811725d 	.word	0x0811725d
 8117240:	0811748d 	.word	0x0811748d
 8117244:	08117605 	.word	0x08117605
 8117248:	0811762f 	.word	0x0811762f
 811724c:	08117753 	.word	0x08117753
 8117250:	08117605 	.word	0x08117605
 8117254:	081177df 	.word	0x081177df
 8117258:	0811786f 	.word	0x0811786f
    case SYN_SENT:
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("SYN-SENT: ackno %"U32_F" pcb->snd_nxt %"U32_F" unacked %"U32_F"\n", ackno,
                                    pcb->snd_nxt, lwip_ntohl(pcb->unacked->tcphdr->seqno)));
      /* received SYN ACK with expected sequence number? */
      if ((flags & TCP_ACK) && (flags & TCP_SYN)
 811725c:	4b4f      	ldr	r3, [pc, #316]	; (811739c <tcp_process+0x298>)
 811725e:	781b      	ldrb	r3, [r3, #0]
 8117260:	f003 0310 	and.w	r3, r3, #16
 8117264:	2b00      	cmp	r3, #0
 8117266:	f000 80e4 	beq.w	8117432 <tcp_process+0x32e>
 811726a:	4b4c      	ldr	r3, [pc, #304]	; (811739c <tcp_process+0x298>)
 811726c:	781b      	ldrb	r3, [r3, #0]
 811726e:	f003 0302 	and.w	r3, r3, #2
 8117272:	2b00      	cmp	r3, #0
 8117274:	f000 80dd 	beq.w	8117432 <tcp_process+0x32e>
          && (ackno == pcb->lastack + 1)) {
 8117278:	687b      	ldr	r3, [r7, #4]
 811727a:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 811727c:	1c5a      	adds	r2, r3, #1
 811727e:	4b48      	ldr	r3, [pc, #288]	; (81173a0 <tcp_process+0x29c>)
 8117280:	681b      	ldr	r3, [r3, #0]
 8117282:	429a      	cmp	r2, r3
 8117284:	f040 80d5 	bne.w	8117432 <tcp_process+0x32e>
        pcb->rcv_nxt = seqno + 1;
 8117288:	4b46      	ldr	r3, [pc, #280]	; (81173a4 <tcp_process+0x2a0>)
 811728a:	681b      	ldr	r3, [r3, #0]
 811728c:	1c5a      	adds	r2, r3, #1
 811728e:	687b      	ldr	r3, [r7, #4]
 8117290:	625a      	str	r2, [r3, #36]	; 0x24
        pcb->rcv_ann_right_edge = pcb->rcv_nxt;
 8117292:	687b      	ldr	r3, [r7, #4]
 8117294:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8117296:	687b      	ldr	r3, [r7, #4]
 8117298:	62da      	str	r2, [r3, #44]	; 0x2c
        pcb->lastack = ackno;
 811729a:	4b41      	ldr	r3, [pc, #260]	; (81173a0 <tcp_process+0x29c>)
 811729c:	681a      	ldr	r2, [r3, #0]
 811729e:	687b      	ldr	r3, [r7, #4]
 81172a0:	645a      	str	r2, [r3, #68]	; 0x44
        pcb->snd_wnd = tcphdr->wnd;
 81172a2:	4b44      	ldr	r3, [pc, #272]	; (81173b4 <tcp_process+0x2b0>)
 81172a4:	681b      	ldr	r3, [r3, #0]
 81172a6:	89db      	ldrh	r3, [r3, #14]
 81172a8:	b29a      	uxth	r2, r3
 81172aa:	687b      	ldr	r3, [r7, #4]
 81172ac:	f8a3 2060 	strh.w	r2, [r3, #96]	; 0x60
        pcb->snd_wnd_max = pcb->snd_wnd;
 81172b0:	687b      	ldr	r3, [r7, #4]
 81172b2:	f8b3 2060 	ldrh.w	r2, [r3, #96]	; 0x60
 81172b6:	687b      	ldr	r3, [r7, #4]
 81172b8:	f8a3 2062 	strh.w	r2, [r3, #98]	; 0x62
        pcb->snd_wl1 = seqno - 1; /* initialise to seqno - 1 to force window update */
 81172bc:	4b39      	ldr	r3, [pc, #228]	; (81173a4 <tcp_process+0x2a0>)
 81172be:	681b      	ldr	r3, [r3, #0]
 81172c0:	1e5a      	subs	r2, r3, #1
 81172c2:	687b      	ldr	r3, [r7, #4]
 81172c4:	655a      	str	r2, [r3, #84]	; 0x54
        pcb->state = ESTABLISHED;
 81172c6:	687b      	ldr	r3, [r7, #4]
 81172c8:	2204      	movs	r2, #4
 81172ca:	751a      	strb	r2, [r3, #20]

#if TCP_CALCULATE_EFF_SEND_MSS
        pcb->mss = tcp_eff_send_mss(pcb->mss, &pcb->local_ip, &pcb->remote_ip);
 81172cc:	687b      	ldr	r3, [r7, #4]
 81172ce:	8e5c      	ldrh	r4, [r3, #50]	; 0x32
 81172d0:	687b      	ldr	r3, [r7, #4]
 81172d2:	3304      	adds	r3, #4
 81172d4:	4618      	mov	r0, r3
 81172d6:	f7fa fd89 	bl	8111dec <ip4_route>
 81172da:	4601      	mov	r1, r0
 81172dc:	687b      	ldr	r3, [r7, #4]
 81172de:	3304      	adds	r3, #4
 81172e0:	461a      	mov	r2, r3
 81172e2:	4620      	mov	r0, r4
 81172e4:	f7ff f88c 	bl	8116400 <tcp_eff_send_mss_netif>
 81172e8:	4603      	mov	r3, r0
 81172ea:	461a      	mov	r2, r3
 81172ec:	687b      	ldr	r3, [r7, #4]
 81172ee:	865a      	strh	r2, [r3, #50]	; 0x32
#endif /* TCP_CALCULATE_EFF_SEND_MSS */

        pcb->cwnd = LWIP_TCP_CALC_INITIAL_CWND(pcb->mss);
 81172f0:	687b      	ldr	r3, [r7, #4]
 81172f2:	8e5b      	ldrh	r3, [r3, #50]	; 0x32
 81172f4:	009a      	lsls	r2, r3, #2
 81172f6:	687b      	ldr	r3, [r7, #4]
 81172f8:	8e5b      	ldrh	r3, [r3, #50]	; 0x32
 81172fa:	005b      	lsls	r3, r3, #1
 81172fc:	f241 111c 	movw	r1, #4380	; 0x111c
 8117300:	428b      	cmp	r3, r1
 8117302:	bf38      	it	cc
 8117304:	460b      	movcc	r3, r1
 8117306:	429a      	cmp	r2, r3
 8117308:	d204      	bcs.n	8117314 <tcp_process+0x210>
 811730a:	687b      	ldr	r3, [r7, #4]
 811730c:	8e5b      	ldrh	r3, [r3, #50]	; 0x32
 811730e:	009b      	lsls	r3, r3, #2
 8117310:	b29b      	uxth	r3, r3
 8117312:	e00d      	b.n	8117330 <tcp_process+0x22c>
 8117314:	687b      	ldr	r3, [r7, #4]
 8117316:	8e5b      	ldrh	r3, [r3, #50]	; 0x32
 8117318:	005b      	lsls	r3, r3, #1
 811731a:	f241 121c 	movw	r2, #4380	; 0x111c
 811731e:	4293      	cmp	r3, r2
 8117320:	d904      	bls.n	811732c <tcp_process+0x228>
 8117322:	687b      	ldr	r3, [r7, #4]
 8117324:	8e5b      	ldrh	r3, [r3, #50]	; 0x32
 8117326:	005b      	lsls	r3, r3, #1
 8117328:	b29b      	uxth	r3, r3
 811732a:	e001      	b.n	8117330 <tcp_process+0x22c>
 811732c:	f241 131c 	movw	r3, #4380	; 0x111c
 8117330:	687a      	ldr	r2, [r7, #4]
 8117332:	f8a2 3048 	strh.w	r3, [r2, #72]	; 0x48
        LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_process (SENT): cwnd %"TCPWNDSIZE_F
                                     " ssthresh %"TCPWNDSIZE_F"\n",
                                     pcb->cwnd, pcb->ssthresh));
        LWIP_ASSERT("pcb->snd_queuelen > 0", (pcb->snd_queuelen > 0));
 8117336:	687b      	ldr	r3, [r7, #4]
 8117338:	f8b3 3066 	ldrh.w	r3, [r3, #102]	; 0x66
 811733c:	2b00      	cmp	r3, #0
 811733e:	d106      	bne.n	811734e <tcp_process+0x24a>
 8117340:	4b13      	ldr	r3, [pc, #76]	; (8117390 <tcp_process+0x28c>)
 8117342:	f44f 725b 	mov.w	r2, #876	; 0x36c
 8117346:	491c      	ldr	r1, [pc, #112]	; (81173b8 <tcp_process+0x2b4>)
 8117348:	4813      	ldr	r0, [pc, #76]	; (8117398 <tcp_process+0x294>)
 811734a:	f004 fa59 	bl	811b800 <iprintf>
        --pcb->snd_queuelen;
 811734e:	687b      	ldr	r3, [r7, #4]
 8117350:	f8b3 3066 	ldrh.w	r3, [r3, #102]	; 0x66
 8117354:	3b01      	subs	r3, #1
 8117356:	b29a      	uxth	r2, r3
 8117358:	687b      	ldr	r3, [r7, #4]
 811735a:	f8a3 2066 	strh.w	r2, [r3, #102]	; 0x66
        LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_process: SYN-SENT --queuelen %"TCPWNDSIZE_F"\n", (tcpwnd_size_t)pcb->snd_queuelen));
        rseg = pcb->unacked;
 811735e:	687b      	ldr	r3, [r7, #4]
 8117360:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8117362:	61fb      	str	r3, [r7, #28]
        if (rseg == NULL) {
 8117364:	69fb      	ldr	r3, [r7, #28]
 8117366:	2b00      	cmp	r3, #0
 8117368:	d12a      	bne.n	81173c0 <tcp_process+0x2bc>
          /* might happen if tcp_output fails in tcp_rexmit_rto()
             in which case the segment is on the unsent list */
          rseg = pcb->unsent;
 811736a:	687b      	ldr	r3, [r7, #4]
 811736c:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 811736e:	61fb      	str	r3, [r7, #28]
          LWIP_ASSERT("no segment to free", rseg != NULL);
 8117370:	69fb      	ldr	r3, [r7, #28]
 8117372:	2b00      	cmp	r3, #0
 8117374:	d106      	bne.n	8117384 <tcp_process+0x280>
 8117376:	4b06      	ldr	r3, [pc, #24]	; (8117390 <tcp_process+0x28c>)
 8117378:	f44f 725d 	mov.w	r2, #884	; 0x374
 811737c:	490f      	ldr	r1, [pc, #60]	; (81173bc <tcp_process+0x2b8>)
 811737e:	4806      	ldr	r0, [pc, #24]	; (8117398 <tcp_process+0x294>)
 8117380:	f004 fa3e 	bl	811b800 <iprintf>
          pcb->unsent = rseg->next;
 8117384:	69fb      	ldr	r3, [r7, #28]
 8117386:	681a      	ldr	r2, [r3, #0]
 8117388:	687b      	ldr	r3, [r7, #4]
 811738a:	66da      	str	r2, [r3, #108]	; 0x6c
 811738c:	e01c      	b.n	81173c8 <tcp_process+0x2c4>
 811738e:	bf00      	nop
 8117390:	0811e6e4 	.word	0x0811e6e4
 8117394:	0811e950 	.word	0x0811e950
 8117398:	0811e764 	.word	0x0811e764
 811739c:	1000848c 	.word	0x1000848c
 81173a0:	10008484 	.word	0x10008484
 81173a4:	10008480 	.word	0x10008480
 81173a8:	0811e96c 	.word	0x0811e96c
 81173ac:	1000848d 	.word	0x1000848d
 81173b0:	10008448 	.word	0x10008448
 81173b4:	10008470 	.word	0x10008470
 81173b8:	0811e98c 	.word	0x0811e98c
 81173bc:	0811e9a4 	.word	0x0811e9a4
        } else {
          pcb->unacked = rseg->next;
 81173c0:	69fb      	ldr	r3, [r7, #28]
 81173c2:	681a      	ldr	r2, [r3, #0]
 81173c4:	687b      	ldr	r3, [r7, #4]
 81173c6:	671a      	str	r2, [r3, #112]	; 0x70
        }
        tcp_seg_free(rseg);
 81173c8:	69f8      	ldr	r0, [r7, #28]
 81173ca:	f7fe fd22 	bl	8115e12 <tcp_seg_free>

        /* If there's nothing left to acknowledge, stop the retransmit
           timer, otherwise reset it to start again */
        if (pcb->unacked == NULL) {
 81173ce:	687b      	ldr	r3, [r7, #4]
 81173d0:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 81173d2:	2b00      	cmp	r3, #0
 81173d4:	d104      	bne.n	81173e0 <tcp_process+0x2dc>
          pcb->rtime = -1;
 81173d6:	687b      	ldr	r3, [r7, #4]
 81173d8:	f64f 72ff 	movw	r2, #65535	; 0xffff
 81173dc:	861a      	strh	r2, [r3, #48]	; 0x30
 81173de:	e006      	b.n	81173ee <tcp_process+0x2ea>
        } else {
          pcb->rtime = 0;
 81173e0:	687b      	ldr	r3, [r7, #4]
 81173e2:	2200      	movs	r2, #0
 81173e4:	861a      	strh	r2, [r3, #48]	; 0x30
          pcb->nrtx = 0;
 81173e6:	687b      	ldr	r3, [r7, #4]
 81173e8:	2200      	movs	r2, #0
 81173ea:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
        }

        /* Call the user specified function to call when successfully
         * connected. */
        TCP_EVENT_CONNECTED(pcb, ERR_OK, err);
 81173ee:	687b      	ldr	r3, [r7, #4]
 81173f0:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 81173f4:	2b00      	cmp	r3, #0
 81173f6:	d00a      	beq.n	811740e <tcp_process+0x30a>
 81173f8:	687b      	ldr	r3, [r7, #4]
 81173fa:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 81173fe:	687a      	ldr	r2, [r7, #4]
 8117400:	6910      	ldr	r0, [r2, #16]
 8117402:	2200      	movs	r2, #0
 8117404:	6879      	ldr	r1, [r7, #4]
 8117406:	4798      	blx	r3
 8117408:	4603      	mov	r3, r0
 811740a:	76bb      	strb	r3, [r7, #26]
 811740c:	e001      	b.n	8117412 <tcp_process+0x30e>
 811740e:	2300      	movs	r3, #0
 8117410:	76bb      	strb	r3, [r7, #26]
        if (err == ERR_ABRT) {
 8117412:	f997 301a 	ldrsb.w	r3, [r7, #26]
 8117416:	f113 0f0d 	cmn.w	r3, #13
 811741a:	d102      	bne.n	8117422 <tcp_process+0x31e>
          return ERR_ABRT;
 811741c:	f06f 030c 	mvn.w	r3, #12
 8117420:	e250      	b.n	81178c4 <tcp_process+0x7c0>
        }
        tcp_ack_now(pcb);
 8117422:	687b      	ldr	r3, [r7, #4]
 8117424:	8b5b      	ldrh	r3, [r3, #26]
 8117426:	f043 0302 	orr.w	r3, r3, #2
 811742a:	b29a      	uxth	r2, r3
 811742c:	687b      	ldr	r3, [r7, #4]
 811742e:	835a      	strh	r2, [r3, #26]
        if (pcb->nrtx < TCP_SYNMAXRTX) {
          pcb->rtime = 0;
          tcp_rexmit_rto(pcb);
        }
      }
      break;
 8117430:	e23a      	b.n	81178a8 <tcp_process+0x7a4>
      else if (flags & TCP_ACK) {
 8117432:	4b98      	ldr	r3, [pc, #608]	; (8117694 <tcp_process+0x590>)
 8117434:	781b      	ldrb	r3, [r3, #0]
 8117436:	f003 0310 	and.w	r3, r3, #16
 811743a:	2b00      	cmp	r3, #0
 811743c:	f000 8234 	beq.w	81178a8 <tcp_process+0x7a4>
        tcp_rst(pcb, ackno, seqno + tcplen, ip_current_dest_addr(),
 8117440:	4b95      	ldr	r3, [pc, #596]	; (8117698 <tcp_process+0x594>)
 8117442:	6819      	ldr	r1, [r3, #0]
 8117444:	4b95      	ldr	r3, [pc, #596]	; (811769c <tcp_process+0x598>)
 8117446:	881b      	ldrh	r3, [r3, #0]
 8117448:	461a      	mov	r2, r3
 811744a:	4b95      	ldr	r3, [pc, #596]	; (81176a0 <tcp_process+0x59c>)
 811744c:	681b      	ldr	r3, [r3, #0]
 811744e:	18d0      	adds	r0, r2, r3
                ip_current_src_addr(), tcphdr->dest, tcphdr->src);
 8117450:	4b94      	ldr	r3, [pc, #592]	; (81176a4 <tcp_process+0x5a0>)
 8117452:	681b      	ldr	r3, [r3, #0]
        tcp_rst(pcb, ackno, seqno + tcplen, ip_current_dest_addr(),
 8117454:	885b      	ldrh	r3, [r3, #2]
 8117456:	b29b      	uxth	r3, r3
                ip_current_src_addr(), tcphdr->dest, tcphdr->src);
 8117458:	4a92      	ldr	r2, [pc, #584]	; (81176a4 <tcp_process+0x5a0>)
 811745a:	6812      	ldr	r2, [r2, #0]
        tcp_rst(pcb, ackno, seqno + tcplen, ip_current_dest_addr(),
 811745c:	8812      	ldrh	r2, [r2, #0]
 811745e:	b292      	uxth	r2, r2
 8117460:	9202      	str	r2, [sp, #8]
 8117462:	9301      	str	r3, [sp, #4]
 8117464:	4b90      	ldr	r3, [pc, #576]	; (81176a8 <tcp_process+0x5a4>)
 8117466:	9300      	str	r3, [sp, #0]
 8117468:	4b90      	ldr	r3, [pc, #576]	; (81176ac <tcp_process+0x5a8>)
 811746a:	4602      	mov	r2, r0
 811746c:	6878      	ldr	r0, [r7, #4]
 811746e:	f002 fc85 	bl	8119d7c <tcp_rst>
        if (pcb->nrtx < TCP_SYNMAXRTX) {
 8117472:	687b      	ldr	r3, [r7, #4]
 8117474:	f893 3042 	ldrb.w	r3, [r3, #66]	; 0x42
 8117478:	2b05      	cmp	r3, #5
 811747a:	f200 8215 	bhi.w	81178a8 <tcp_process+0x7a4>
          pcb->rtime = 0;
 811747e:	687b      	ldr	r3, [r7, #4]
 8117480:	2200      	movs	r2, #0
 8117482:	861a      	strh	r2, [r3, #48]	; 0x30
          tcp_rexmit_rto(pcb);
 8117484:	6878      	ldr	r0, [r7, #4]
 8117486:	f002 fa51 	bl	811992c <tcp_rexmit_rto>
      break;
 811748a:	e20d      	b.n	81178a8 <tcp_process+0x7a4>
    case SYN_RCVD:
      if (flags & TCP_ACK) {
 811748c:	4b81      	ldr	r3, [pc, #516]	; (8117694 <tcp_process+0x590>)
 811748e:	781b      	ldrb	r3, [r3, #0]
 8117490:	f003 0310 	and.w	r3, r3, #16
 8117494:	2b00      	cmp	r3, #0
 8117496:	f000 80a1 	beq.w	81175dc <tcp_process+0x4d8>
        /* expected ACK number? */
        if (TCP_SEQ_BETWEEN(ackno, pcb->lastack + 1, pcb->snd_nxt)) {
 811749a:	4b7f      	ldr	r3, [pc, #508]	; (8117698 <tcp_process+0x594>)
 811749c:	681a      	ldr	r2, [r3, #0]
 811749e:	687b      	ldr	r3, [r7, #4]
 81174a0:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 81174a2:	1ad3      	subs	r3, r2, r3
 81174a4:	3b01      	subs	r3, #1
 81174a6:	2b00      	cmp	r3, #0
 81174a8:	db7e      	blt.n	81175a8 <tcp_process+0x4a4>
 81174aa:	4b7b      	ldr	r3, [pc, #492]	; (8117698 <tcp_process+0x594>)
 81174ac:	681a      	ldr	r2, [r3, #0]
 81174ae:	687b      	ldr	r3, [r7, #4]
 81174b0:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 81174b2:	1ad3      	subs	r3, r2, r3
 81174b4:	2b00      	cmp	r3, #0
 81174b6:	dc77      	bgt.n	81175a8 <tcp_process+0x4a4>
          pcb->state = ESTABLISHED;
 81174b8:	687b      	ldr	r3, [r7, #4]
 81174ba:	2204      	movs	r2, #4
 81174bc:	751a      	strb	r2, [r3, #20]
          LWIP_DEBUGF(TCP_DEBUG, ("TCP connection established %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
#if LWIP_CALLBACK_API || TCP_LISTEN_BACKLOG
          if (pcb->listener == NULL) {
 81174be:	687b      	ldr	r3, [r7, #4]
 81174c0:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 81174c2:	2b00      	cmp	r3, #0
 81174c4:	d102      	bne.n	81174cc <tcp_process+0x3c8>
            /* listen pcb might be closed by now */
            err = ERR_VAL;
 81174c6:	23fa      	movs	r3, #250	; 0xfa
 81174c8:	76bb      	strb	r3, [r7, #26]
 81174ca:	e01d      	b.n	8117508 <tcp_process+0x404>
          } else
#endif /* LWIP_CALLBACK_API || TCP_LISTEN_BACKLOG */
          {
#if LWIP_CALLBACK_API
            LWIP_ASSERT("pcb->listener->accept != NULL", pcb->listener->accept != NULL);
 81174cc:	687b      	ldr	r3, [r7, #4]
 81174ce:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 81174d0:	699b      	ldr	r3, [r3, #24]
 81174d2:	2b00      	cmp	r3, #0
 81174d4:	d106      	bne.n	81174e4 <tcp_process+0x3e0>
 81174d6:	4b76      	ldr	r3, [pc, #472]	; (81176b0 <tcp_process+0x5ac>)
 81174d8:	f44f 726a 	mov.w	r2, #936	; 0x3a8
 81174dc:	4975      	ldr	r1, [pc, #468]	; (81176b4 <tcp_process+0x5b0>)
 81174de:	4876      	ldr	r0, [pc, #472]	; (81176b8 <tcp_process+0x5b4>)
 81174e0:	f004 f98e 	bl	811b800 <iprintf>
#endif
            tcp_backlog_accepted(pcb);
            /* Call the accept function. */
            TCP_EVENT_ACCEPT(pcb->listener, pcb, pcb->callback_arg, ERR_OK, err);
 81174e4:	687b      	ldr	r3, [r7, #4]
 81174e6:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 81174e8:	699b      	ldr	r3, [r3, #24]
 81174ea:	2b00      	cmp	r3, #0
 81174ec:	d00a      	beq.n	8117504 <tcp_process+0x400>
 81174ee:	687b      	ldr	r3, [r7, #4]
 81174f0:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 81174f2:	699b      	ldr	r3, [r3, #24]
 81174f4:	687a      	ldr	r2, [r7, #4]
 81174f6:	6910      	ldr	r0, [r2, #16]
 81174f8:	2200      	movs	r2, #0
 81174fa:	6879      	ldr	r1, [r7, #4]
 81174fc:	4798      	blx	r3
 81174fe:	4603      	mov	r3, r0
 8117500:	76bb      	strb	r3, [r7, #26]
 8117502:	e001      	b.n	8117508 <tcp_process+0x404>
 8117504:	23f0      	movs	r3, #240	; 0xf0
 8117506:	76bb      	strb	r3, [r7, #26]
          }
          if (err != ERR_OK) {
 8117508:	f997 301a 	ldrsb.w	r3, [r7, #26]
 811750c:	2b00      	cmp	r3, #0
 811750e:	d00a      	beq.n	8117526 <tcp_process+0x422>
            /* If the accept function returns with an error, we abort
             * the connection. */
            /* Already aborted? */
            if (err != ERR_ABRT) {
 8117510:	f997 301a 	ldrsb.w	r3, [r7, #26]
 8117514:	f113 0f0d 	cmn.w	r3, #13
 8117518:	d002      	beq.n	8117520 <tcp_process+0x41c>
              tcp_abort(pcb);
 811751a:	6878      	ldr	r0, [r7, #4]
 811751c:	f7fd ff8e 	bl	811543c <tcp_abort>
            }
            return ERR_ABRT;
 8117520:	f06f 030c 	mvn.w	r3, #12
 8117524:	e1ce      	b.n	81178c4 <tcp_process+0x7c0>
          }
          /* If there was any data contained within this ACK,
           * we'd better pass it on to the application as well. */
          tcp_receive(pcb);
 8117526:	6878      	ldr	r0, [r7, #4]
 8117528:	f000 fae0 	bl	8117aec <tcp_receive>

          /* Prevent ACK for SYN to generate a sent event */
          if (recv_acked != 0) {
 811752c:	4b63      	ldr	r3, [pc, #396]	; (81176bc <tcp_process+0x5b8>)
 811752e:	881b      	ldrh	r3, [r3, #0]
 8117530:	2b00      	cmp	r3, #0
 8117532:	d005      	beq.n	8117540 <tcp_process+0x43c>
            recv_acked--;
 8117534:	4b61      	ldr	r3, [pc, #388]	; (81176bc <tcp_process+0x5b8>)
 8117536:	881b      	ldrh	r3, [r3, #0]
 8117538:	3b01      	subs	r3, #1
 811753a:	b29a      	uxth	r2, r3
 811753c:	4b5f      	ldr	r3, [pc, #380]	; (81176bc <tcp_process+0x5b8>)
 811753e:	801a      	strh	r2, [r3, #0]
          }

          pcb->cwnd = LWIP_TCP_CALC_INITIAL_CWND(pcb->mss);
 8117540:	687b      	ldr	r3, [r7, #4]
 8117542:	8e5b      	ldrh	r3, [r3, #50]	; 0x32
 8117544:	009a      	lsls	r2, r3, #2
 8117546:	687b      	ldr	r3, [r7, #4]
 8117548:	8e5b      	ldrh	r3, [r3, #50]	; 0x32
 811754a:	005b      	lsls	r3, r3, #1
 811754c:	f241 111c 	movw	r1, #4380	; 0x111c
 8117550:	428b      	cmp	r3, r1
 8117552:	bf38      	it	cc
 8117554:	460b      	movcc	r3, r1
 8117556:	429a      	cmp	r2, r3
 8117558:	d204      	bcs.n	8117564 <tcp_process+0x460>
 811755a:	687b      	ldr	r3, [r7, #4]
 811755c:	8e5b      	ldrh	r3, [r3, #50]	; 0x32
 811755e:	009b      	lsls	r3, r3, #2
 8117560:	b29b      	uxth	r3, r3
 8117562:	e00d      	b.n	8117580 <tcp_process+0x47c>
 8117564:	687b      	ldr	r3, [r7, #4]
 8117566:	8e5b      	ldrh	r3, [r3, #50]	; 0x32
 8117568:	005b      	lsls	r3, r3, #1
 811756a:	f241 121c 	movw	r2, #4380	; 0x111c
 811756e:	4293      	cmp	r3, r2
 8117570:	d904      	bls.n	811757c <tcp_process+0x478>
 8117572:	687b      	ldr	r3, [r7, #4]
 8117574:	8e5b      	ldrh	r3, [r3, #50]	; 0x32
 8117576:	005b      	lsls	r3, r3, #1
 8117578:	b29b      	uxth	r3, r3
 811757a:	e001      	b.n	8117580 <tcp_process+0x47c>
 811757c:	f241 131c 	movw	r3, #4380	; 0x111c
 8117580:	687a      	ldr	r2, [r7, #4]
 8117582:	f8a2 3048 	strh.w	r3, [r2, #72]	; 0x48
          LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_process (SYN_RCVD): cwnd %"TCPWNDSIZE_F
                                       " ssthresh %"TCPWNDSIZE_F"\n",
                                       pcb->cwnd, pcb->ssthresh));

          if (recv_flags & TF_GOT_FIN) {
 8117586:	4b4e      	ldr	r3, [pc, #312]	; (81176c0 <tcp_process+0x5bc>)
 8117588:	781b      	ldrb	r3, [r3, #0]
 811758a:	f003 0320 	and.w	r3, r3, #32
 811758e:	2b00      	cmp	r3, #0
 8117590:	d037      	beq.n	8117602 <tcp_process+0x4fe>
            tcp_ack_now(pcb);
 8117592:	687b      	ldr	r3, [r7, #4]
 8117594:	8b5b      	ldrh	r3, [r3, #26]
 8117596:	f043 0302 	orr.w	r3, r3, #2
 811759a:	b29a      	uxth	r2, r3
 811759c:	687b      	ldr	r3, [r7, #4]
 811759e:	835a      	strh	r2, [r3, #26]
            pcb->state = CLOSE_WAIT;
 81175a0:	687b      	ldr	r3, [r7, #4]
 81175a2:	2207      	movs	r2, #7
 81175a4:	751a      	strb	r2, [r3, #20]
          if (recv_flags & TF_GOT_FIN) {
 81175a6:	e02c      	b.n	8117602 <tcp_process+0x4fe>
          }
        } else {
          /* incorrect ACK number, send RST */
          tcp_rst(pcb, ackno, seqno + tcplen, ip_current_dest_addr(),
 81175a8:	4b3b      	ldr	r3, [pc, #236]	; (8117698 <tcp_process+0x594>)
 81175aa:	6819      	ldr	r1, [r3, #0]
 81175ac:	4b3b      	ldr	r3, [pc, #236]	; (811769c <tcp_process+0x598>)
 81175ae:	881b      	ldrh	r3, [r3, #0]
 81175b0:	461a      	mov	r2, r3
 81175b2:	4b3b      	ldr	r3, [pc, #236]	; (81176a0 <tcp_process+0x59c>)
 81175b4:	681b      	ldr	r3, [r3, #0]
 81175b6:	18d0      	adds	r0, r2, r3
                  ip_current_src_addr(), tcphdr->dest, tcphdr->src);
 81175b8:	4b3a      	ldr	r3, [pc, #232]	; (81176a4 <tcp_process+0x5a0>)
 81175ba:	681b      	ldr	r3, [r3, #0]
          tcp_rst(pcb, ackno, seqno + tcplen, ip_current_dest_addr(),
 81175bc:	885b      	ldrh	r3, [r3, #2]
 81175be:	b29b      	uxth	r3, r3
                  ip_current_src_addr(), tcphdr->dest, tcphdr->src);
 81175c0:	4a38      	ldr	r2, [pc, #224]	; (81176a4 <tcp_process+0x5a0>)
 81175c2:	6812      	ldr	r2, [r2, #0]
          tcp_rst(pcb, ackno, seqno + tcplen, ip_current_dest_addr(),
 81175c4:	8812      	ldrh	r2, [r2, #0]
 81175c6:	b292      	uxth	r2, r2
 81175c8:	9202      	str	r2, [sp, #8]
 81175ca:	9301      	str	r3, [sp, #4]
 81175cc:	4b36      	ldr	r3, [pc, #216]	; (81176a8 <tcp_process+0x5a4>)
 81175ce:	9300      	str	r3, [sp, #0]
 81175d0:	4b36      	ldr	r3, [pc, #216]	; (81176ac <tcp_process+0x5a8>)
 81175d2:	4602      	mov	r2, r0
 81175d4:	6878      	ldr	r0, [r7, #4]
 81175d6:	f002 fbd1 	bl	8119d7c <tcp_rst>
        }
      } else if ((flags & TCP_SYN) && (seqno == pcb->rcv_nxt - 1)) {
        /* Looks like another copy of the SYN - retransmit our SYN-ACK */
        tcp_rexmit(pcb);
      }
      break;
 81175da:	e167      	b.n	81178ac <tcp_process+0x7a8>
      } else if ((flags & TCP_SYN) && (seqno == pcb->rcv_nxt - 1)) {
 81175dc:	4b2d      	ldr	r3, [pc, #180]	; (8117694 <tcp_process+0x590>)
 81175de:	781b      	ldrb	r3, [r3, #0]
 81175e0:	f003 0302 	and.w	r3, r3, #2
 81175e4:	2b00      	cmp	r3, #0
 81175e6:	f000 8161 	beq.w	81178ac <tcp_process+0x7a8>
 81175ea:	687b      	ldr	r3, [r7, #4]
 81175ec:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 81175ee:	1e5a      	subs	r2, r3, #1
 81175f0:	4b2b      	ldr	r3, [pc, #172]	; (81176a0 <tcp_process+0x59c>)
 81175f2:	681b      	ldr	r3, [r3, #0]
 81175f4:	429a      	cmp	r2, r3
 81175f6:	f040 8159 	bne.w	81178ac <tcp_process+0x7a8>
        tcp_rexmit(pcb);
 81175fa:	6878      	ldr	r0, [r7, #4]
 81175fc:	f002 f9b8 	bl	8119970 <tcp_rexmit>
      break;
 8117600:	e154      	b.n	81178ac <tcp_process+0x7a8>
 8117602:	e153      	b.n	81178ac <tcp_process+0x7a8>
    case CLOSE_WAIT:
    /* FALLTHROUGH */
    case ESTABLISHED:
      tcp_receive(pcb);
 8117604:	6878      	ldr	r0, [r7, #4]
 8117606:	f000 fa71 	bl	8117aec <tcp_receive>
      if (recv_flags & TF_GOT_FIN) { /* passive close */
 811760a:	4b2d      	ldr	r3, [pc, #180]	; (81176c0 <tcp_process+0x5bc>)
 811760c:	781b      	ldrb	r3, [r3, #0]
 811760e:	f003 0320 	and.w	r3, r3, #32
 8117612:	2b00      	cmp	r3, #0
 8117614:	f000 814c 	beq.w	81178b0 <tcp_process+0x7ac>
        tcp_ack_now(pcb);
 8117618:	687b      	ldr	r3, [r7, #4]
 811761a:	8b5b      	ldrh	r3, [r3, #26]
 811761c:	f043 0302 	orr.w	r3, r3, #2
 8117620:	b29a      	uxth	r2, r3
 8117622:	687b      	ldr	r3, [r7, #4]
 8117624:	835a      	strh	r2, [r3, #26]
        pcb->state = CLOSE_WAIT;
 8117626:	687b      	ldr	r3, [r7, #4]
 8117628:	2207      	movs	r2, #7
 811762a:	751a      	strb	r2, [r3, #20]
      }
      break;
 811762c:	e140      	b.n	81178b0 <tcp_process+0x7ac>
    case FIN_WAIT_1:
      tcp_receive(pcb);
 811762e:	6878      	ldr	r0, [r7, #4]
 8117630:	f000 fa5c 	bl	8117aec <tcp_receive>
      if (recv_flags & TF_GOT_FIN) {
 8117634:	4b22      	ldr	r3, [pc, #136]	; (81176c0 <tcp_process+0x5bc>)
 8117636:	781b      	ldrb	r3, [r3, #0]
 8117638:	f003 0320 	and.w	r3, r3, #32
 811763c:	2b00      	cmp	r3, #0
 811763e:	d071      	beq.n	8117724 <tcp_process+0x620>
        if ((flags & TCP_ACK) && (ackno == pcb->snd_nxt) &&
 8117640:	4b14      	ldr	r3, [pc, #80]	; (8117694 <tcp_process+0x590>)
 8117642:	781b      	ldrb	r3, [r3, #0]
 8117644:	f003 0310 	and.w	r3, r3, #16
 8117648:	2b00      	cmp	r3, #0
 811764a:	d060      	beq.n	811770e <tcp_process+0x60a>
 811764c:	687b      	ldr	r3, [r7, #4]
 811764e:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 8117650:	4b11      	ldr	r3, [pc, #68]	; (8117698 <tcp_process+0x594>)
 8117652:	681b      	ldr	r3, [r3, #0]
 8117654:	429a      	cmp	r2, r3
 8117656:	d15a      	bne.n	811770e <tcp_process+0x60a>
            pcb->unsent == NULL) {
 8117658:	687b      	ldr	r3, [r7, #4]
 811765a:	6edb      	ldr	r3, [r3, #108]	; 0x6c
        if ((flags & TCP_ACK) && (ackno == pcb->snd_nxt) &&
 811765c:	2b00      	cmp	r3, #0
 811765e:	d156      	bne.n	811770e <tcp_process+0x60a>
          LWIP_DEBUGF(TCP_DEBUG,
                      ("TCP connection closed: FIN_WAIT_1 %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
          tcp_ack_now(pcb);
 8117660:	687b      	ldr	r3, [r7, #4]
 8117662:	8b5b      	ldrh	r3, [r3, #26]
 8117664:	f043 0302 	orr.w	r3, r3, #2
 8117668:	b29a      	uxth	r2, r3
 811766a:	687b      	ldr	r3, [r7, #4]
 811766c:	835a      	strh	r2, [r3, #26]
          tcp_pcb_purge(pcb);
 811766e:	6878      	ldr	r0, [r7, #4]
 8117670:	f7fe fdbc 	bl	81161ec <tcp_pcb_purge>
          TCP_RMV_ACTIVE(pcb);
 8117674:	4b13      	ldr	r3, [pc, #76]	; (81176c4 <tcp_process+0x5c0>)
 8117676:	681b      	ldr	r3, [r3, #0]
 8117678:	687a      	ldr	r2, [r7, #4]
 811767a:	429a      	cmp	r2, r3
 811767c:	d105      	bne.n	811768a <tcp_process+0x586>
 811767e:	4b11      	ldr	r3, [pc, #68]	; (81176c4 <tcp_process+0x5c0>)
 8117680:	681b      	ldr	r3, [r3, #0]
 8117682:	68db      	ldr	r3, [r3, #12]
 8117684:	4a0f      	ldr	r2, [pc, #60]	; (81176c4 <tcp_process+0x5c0>)
 8117686:	6013      	str	r3, [r2, #0]
 8117688:	e02e      	b.n	81176e8 <tcp_process+0x5e4>
 811768a:	4b0e      	ldr	r3, [pc, #56]	; (81176c4 <tcp_process+0x5c0>)
 811768c:	681b      	ldr	r3, [r3, #0]
 811768e:	617b      	str	r3, [r7, #20]
 8117690:	e027      	b.n	81176e2 <tcp_process+0x5de>
 8117692:	bf00      	nop
 8117694:	1000848c 	.word	0x1000848c
 8117698:	10008484 	.word	0x10008484
 811769c:	1000848a 	.word	0x1000848a
 81176a0:	10008480 	.word	0x10008480
 81176a4:	10008470 	.word	0x10008470
 81176a8:	10005500 	.word	0x10005500
 81176ac:	10005504 	.word	0x10005504
 81176b0:	0811e6e4 	.word	0x0811e6e4
 81176b4:	0811e9b8 	.word	0x0811e9b8
 81176b8:	0811e764 	.word	0x0811e764
 81176bc:	10008488 	.word	0x10008488
 81176c0:	1000848d 	.word	0x1000848d
 81176c4:	10008454 	.word	0x10008454
 81176c8:	697b      	ldr	r3, [r7, #20]
 81176ca:	68db      	ldr	r3, [r3, #12]
 81176cc:	687a      	ldr	r2, [r7, #4]
 81176ce:	429a      	cmp	r2, r3
 81176d0:	d104      	bne.n	81176dc <tcp_process+0x5d8>
 81176d2:	687b      	ldr	r3, [r7, #4]
 81176d4:	68da      	ldr	r2, [r3, #12]
 81176d6:	697b      	ldr	r3, [r7, #20]
 81176d8:	60da      	str	r2, [r3, #12]
 81176da:	e005      	b.n	81176e8 <tcp_process+0x5e4>
 81176dc:	697b      	ldr	r3, [r7, #20]
 81176de:	68db      	ldr	r3, [r3, #12]
 81176e0:	617b      	str	r3, [r7, #20]
 81176e2:	697b      	ldr	r3, [r7, #20]
 81176e4:	2b00      	cmp	r3, #0
 81176e6:	d1ef      	bne.n	81176c8 <tcp_process+0x5c4>
 81176e8:	687b      	ldr	r3, [r7, #4]
 81176ea:	2200      	movs	r2, #0
 81176ec:	60da      	str	r2, [r3, #12]
 81176ee:	4b77      	ldr	r3, [pc, #476]	; (81178cc <tcp_process+0x7c8>)
 81176f0:	2201      	movs	r2, #1
 81176f2:	701a      	strb	r2, [r3, #0]
          pcb->state = TIME_WAIT;
 81176f4:	687b      	ldr	r3, [r7, #4]
 81176f6:	220a      	movs	r2, #10
 81176f8:	751a      	strb	r2, [r3, #20]
          TCP_REG(&tcp_tw_pcbs, pcb);
 81176fa:	4b75      	ldr	r3, [pc, #468]	; (81178d0 <tcp_process+0x7cc>)
 81176fc:	681a      	ldr	r2, [r3, #0]
 81176fe:	687b      	ldr	r3, [r7, #4]
 8117700:	60da      	str	r2, [r3, #12]
 8117702:	4a73      	ldr	r2, [pc, #460]	; (81178d0 <tcp_process+0x7cc>)
 8117704:	687b      	ldr	r3, [r7, #4]
 8117706:	6013      	str	r3, [r2, #0]
 8117708:	f002 fcfa 	bl	811a100 <tcp_timer_needed>
        }
      } else if ((flags & TCP_ACK) && (ackno == pcb->snd_nxt) &&
                 pcb->unsent == NULL) {
        pcb->state = FIN_WAIT_2;
      }
      break;
 811770c:	e0d2      	b.n	81178b4 <tcp_process+0x7b0>
          tcp_ack_now(pcb);
 811770e:	687b      	ldr	r3, [r7, #4]
 8117710:	8b5b      	ldrh	r3, [r3, #26]
 8117712:	f043 0302 	orr.w	r3, r3, #2
 8117716:	b29a      	uxth	r2, r3
 8117718:	687b      	ldr	r3, [r7, #4]
 811771a:	835a      	strh	r2, [r3, #26]
          pcb->state = CLOSING;
 811771c:	687b      	ldr	r3, [r7, #4]
 811771e:	2208      	movs	r2, #8
 8117720:	751a      	strb	r2, [r3, #20]
      break;
 8117722:	e0c7      	b.n	81178b4 <tcp_process+0x7b0>
      } else if ((flags & TCP_ACK) && (ackno == pcb->snd_nxt) &&
 8117724:	4b6b      	ldr	r3, [pc, #428]	; (81178d4 <tcp_process+0x7d0>)
 8117726:	781b      	ldrb	r3, [r3, #0]
 8117728:	f003 0310 	and.w	r3, r3, #16
 811772c:	2b00      	cmp	r3, #0
 811772e:	f000 80c1 	beq.w	81178b4 <tcp_process+0x7b0>
 8117732:	687b      	ldr	r3, [r7, #4]
 8117734:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 8117736:	4b68      	ldr	r3, [pc, #416]	; (81178d8 <tcp_process+0x7d4>)
 8117738:	681b      	ldr	r3, [r3, #0]
 811773a:	429a      	cmp	r2, r3
 811773c:	f040 80ba 	bne.w	81178b4 <tcp_process+0x7b0>
                 pcb->unsent == NULL) {
 8117740:	687b      	ldr	r3, [r7, #4]
 8117742:	6edb      	ldr	r3, [r3, #108]	; 0x6c
      } else if ((flags & TCP_ACK) && (ackno == pcb->snd_nxt) &&
 8117744:	2b00      	cmp	r3, #0
 8117746:	f040 80b5 	bne.w	81178b4 <tcp_process+0x7b0>
        pcb->state = FIN_WAIT_2;
 811774a:	687b      	ldr	r3, [r7, #4]
 811774c:	2206      	movs	r2, #6
 811774e:	751a      	strb	r2, [r3, #20]
      break;
 8117750:	e0b0      	b.n	81178b4 <tcp_process+0x7b0>
    case FIN_WAIT_2:
      tcp_receive(pcb);
 8117752:	6878      	ldr	r0, [r7, #4]
 8117754:	f000 f9ca 	bl	8117aec <tcp_receive>
      if (recv_flags & TF_GOT_FIN) {
 8117758:	4b60      	ldr	r3, [pc, #384]	; (81178dc <tcp_process+0x7d8>)
 811775a:	781b      	ldrb	r3, [r3, #0]
 811775c:	f003 0320 	and.w	r3, r3, #32
 8117760:	2b00      	cmp	r3, #0
 8117762:	f000 80a9 	beq.w	81178b8 <tcp_process+0x7b4>
        LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed: FIN_WAIT_2 %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
        tcp_ack_now(pcb);
 8117766:	687b      	ldr	r3, [r7, #4]
 8117768:	8b5b      	ldrh	r3, [r3, #26]
 811776a:	f043 0302 	orr.w	r3, r3, #2
 811776e:	b29a      	uxth	r2, r3
 8117770:	687b      	ldr	r3, [r7, #4]
 8117772:	835a      	strh	r2, [r3, #26]
        tcp_pcb_purge(pcb);
 8117774:	6878      	ldr	r0, [r7, #4]
 8117776:	f7fe fd39 	bl	81161ec <tcp_pcb_purge>
        TCP_RMV_ACTIVE(pcb);
 811777a:	4b59      	ldr	r3, [pc, #356]	; (81178e0 <tcp_process+0x7dc>)
 811777c:	681b      	ldr	r3, [r3, #0]
 811777e:	687a      	ldr	r2, [r7, #4]
 8117780:	429a      	cmp	r2, r3
 8117782:	d105      	bne.n	8117790 <tcp_process+0x68c>
 8117784:	4b56      	ldr	r3, [pc, #344]	; (81178e0 <tcp_process+0x7dc>)
 8117786:	681b      	ldr	r3, [r3, #0]
 8117788:	68db      	ldr	r3, [r3, #12]
 811778a:	4a55      	ldr	r2, [pc, #340]	; (81178e0 <tcp_process+0x7dc>)
 811778c:	6013      	str	r3, [r2, #0]
 811778e:	e013      	b.n	81177b8 <tcp_process+0x6b4>
 8117790:	4b53      	ldr	r3, [pc, #332]	; (81178e0 <tcp_process+0x7dc>)
 8117792:	681b      	ldr	r3, [r3, #0]
 8117794:	613b      	str	r3, [r7, #16]
 8117796:	e00c      	b.n	81177b2 <tcp_process+0x6ae>
 8117798:	693b      	ldr	r3, [r7, #16]
 811779a:	68db      	ldr	r3, [r3, #12]
 811779c:	687a      	ldr	r2, [r7, #4]
 811779e:	429a      	cmp	r2, r3
 81177a0:	d104      	bne.n	81177ac <tcp_process+0x6a8>
 81177a2:	687b      	ldr	r3, [r7, #4]
 81177a4:	68da      	ldr	r2, [r3, #12]
 81177a6:	693b      	ldr	r3, [r7, #16]
 81177a8:	60da      	str	r2, [r3, #12]
 81177aa:	e005      	b.n	81177b8 <tcp_process+0x6b4>
 81177ac:	693b      	ldr	r3, [r7, #16]
 81177ae:	68db      	ldr	r3, [r3, #12]
 81177b0:	613b      	str	r3, [r7, #16]
 81177b2:	693b      	ldr	r3, [r7, #16]
 81177b4:	2b00      	cmp	r3, #0
 81177b6:	d1ef      	bne.n	8117798 <tcp_process+0x694>
 81177b8:	687b      	ldr	r3, [r7, #4]
 81177ba:	2200      	movs	r2, #0
 81177bc:	60da      	str	r2, [r3, #12]
 81177be:	4b43      	ldr	r3, [pc, #268]	; (81178cc <tcp_process+0x7c8>)
 81177c0:	2201      	movs	r2, #1
 81177c2:	701a      	strb	r2, [r3, #0]
        pcb->state = TIME_WAIT;
 81177c4:	687b      	ldr	r3, [r7, #4]
 81177c6:	220a      	movs	r2, #10
 81177c8:	751a      	strb	r2, [r3, #20]
        TCP_REG(&tcp_tw_pcbs, pcb);
 81177ca:	4b41      	ldr	r3, [pc, #260]	; (81178d0 <tcp_process+0x7cc>)
 81177cc:	681a      	ldr	r2, [r3, #0]
 81177ce:	687b      	ldr	r3, [r7, #4]
 81177d0:	60da      	str	r2, [r3, #12]
 81177d2:	4a3f      	ldr	r2, [pc, #252]	; (81178d0 <tcp_process+0x7cc>)
 81177d4:	687b      	ldr	r3, [r7, #4]
 81177d6:	6013      	str	r3, [r2, #0]
 81177d8:	f002 fc92 	bl	811a100 <tcp_timer_needed>
      }
      break;
 81177dc:	e06c      	b.n	81178b8 <tcp_process+0x7b4>
    case CLOSING:
      tcp_receive(pcb);
 81177de:	6878      	ldr	r0, [r7, #4]
 81177e0:	f000 f984 	bl	8117aec <tcp_receive>
      if ((flags & TCP_ACK) && ackno == pcb->snd_nxt && pcb->unsent == NULL) {
 81177e4:	4b3b      	ldr	r3, [pc, #236]	; (81178d4 <tcp_process+0x7d0>)
 81177e6:	781b      	ldrb	r3, [r3, #0]
 81177e8:	f003 0310 	and.w	r3, r3, #16
 81177ec:	2b00      	cmp	r3, #0
 81177ee:	d065      	beq.n	81178bc <tcp_process+0x7b8>
 81177f0:	687b      	ldr	r3, [r7, #4]
 81177f2:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 81177f4:	4b38      	ldr	r3, [pc, #224]	; (81178d8 <tcp_process+0x7d4>)
 81177f6:	681b      	ldr	r3, [r3, #0]
 81177f8:	429a      	cmp	r2, r3
 81177fa:	d15f      	bne.n	81178bc <tcp_process+0x7b8>
 81177fc:	687b      	ldr	r3, [r7, #4]
 81177fe:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 8117800:	2b00      	cmp	r3, #0
 8117802:	d15b      	bne.n	81178bc <tcp_process+0x7b8>
        LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed: CLOSING %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
        tcp_pcb_purge(pcb);
 8117804:	6878      	ldr	r0, [r7, #4]
 8117806:	f7fe fcf1 	bl	81161ec <tcp_pcb_purge>
        TCP_RMV_ACTIVE(pcb);
 811780a:	4b35      	ldr	r3, [pc, #212]	; (81178e0 <tcp_process+0x7dc>)
 811780c:	681b      	ldr	r3, [r3, #0]
 811780e:	687a      	ldr	r2, [r7, #4]
 8117810:	429a      	cmp	r2, r3
 8117812:	d105      	bne.n	8117820 <tcp_process+0x71c>
 8117814:	4b32      	ldr	r3, [pc, #200]	; (81178e0 <tcp_process+0x7dc>)
 8117816:	681b      	ldr	r3, [r3, #0]
 8117818:	68db      	ldr	r3, [r3, #12]
 811781a:	4a31      	ldr	r2, [pc, #196]	; (81178e0 <tcp_process+0x7dc>)
 811781c:	6013      	str	r3, [r2, #0]
 811781e:	e013      	b.n	8117848 <tcp_process+0x744>
 8117820:	4b2f      	ldr	r3, [pc, #188]	; (81178e0 <tcp_process+0x7dc>)
 8117822:	681b      	ldr	r3, [r3, #0]
 8117824:	60fb      	str	r3, [r7, #12]
 8117826:	e00c      	b.n	8117842 <tcp_process+0x73e>
 8117828:	68fb      	ldr	r3, [r7, #12]
 811782a:	68db      	ldr	r3, [r3, #12]
 811782c:	687a      	ldr	r2, [r7, #4]
 811782e:	429a      	cmp	r2, r3
 8117830:	d104      	bne.n	811783c <tcp_process+0x738>
 8117832:	687b      	ldr	r3, [r7, #4]
 8117834:	68da      	ldr	r2, [r3, #12]
 8117836:	68fb      	ldr	r3, [r7, #12]
 8117838:	60da      	str	r2, [r3, #12]
 811783a:	e005      	b.n	8117848 <tcp_process+0x744>
 811783c:	68fb      	ldr	r3, [r7, #12]
 811783e:	68db      	ldr	r3, [r3, #12]
 8117840:	60fb      	str	r3, [r7, #12]
 8117842:	68fb      	ldr	r3, [r7, #12]
 8117844:	2b00      	cmp	r3, #0
 8117846:	d1ef      	bne.n	8117828 <tcp_process+0x724>
 8117848:	687b      	ldr	r3, [r7, #4]
 811784a:	2200      	movs	r2, #0
 811784c:	60da      	str	r2, [r3, #12]
 811784e:	4b1f      	ldr	r3, [pc, #124]	; (81178cc <tcp_process+0x7c8>)
 8117850:	2201      	movs	r2, #1
 8117852:	701a      	strb	r2, [r3, #0]
        pcb->state = TIME_WAIT;
 8117854:	687b      	ldr	r3, [r7, #4]
 8117856:	220a      	movs	r2, #10
 8117858:	751a      	strb	r2, [r3, #20]
        TCP_REG(&tcp_tw_pcbs, pcb);
 811785a:	4b1d      	ldr	r3, [pc, #116]	; (81178d0 <tcp_process+0x7cc>)
 811785c:	681a      	ldr	r2, [r3, #0]
 811785e:	687b      	ldr	r3, [r7, #4]
 8117860:	60da      	str	r2, [r3, #12]
 8117862:	4a1b      	ldr	r2, [pc, #108]	; (81178d0 <tcp_process+0x7cc>)
 8117864:	687b      	ldr	r3, [r7, #4]
 8117866:	6013      	str	r3, [r2, #0]
 8117868:	f002 fc4a 	bl	811a100 <tcp_timer_needed>
      }
      break;
 811786c:	e026      	b.n	81178bc <tcp_process+0x7b8>
    case LAST_ACK:
      tcp_receive(pcb);
 811786e:	6878      	ldr	r0, [r7, #4]
 8117870:	f000 f93c 	bl	8117aec <tcp_receive>
      if ((flags & TCP_ACK) && ackno == pcb->snd_nxt && pcb->unsent == NULL) {
 8117874:	4b17      	ldr	r3, [pc, #92]	; (81178d4 <tcp_process+0x7d0>)
 8117876:	781b      	ldrb	r3, [r3, #0]
 8117878:	f003 0310 	and.w	r3, r3, #16
 811787c:	2b00      	cmp	r3, #0
 811787e:	d01f      	beq.n	81178c0 <tcp_process+0x7bc>
 8117880:	687b      	ldr	r3, [r7, #4]
 8117882:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 8117884:	4b14      	ldr	r3, [pc, #80]	; (81178d8 <tcp_process+0x7d4>)
 8117886:	681b      	ldr	r3, [r3, #0]
 8117888:	429a      	cmp	r2, r3
 811788a:	d119      	bne.n	81178c0 <tcp_process+0x7bc>
 811788c:	687b      	ldr	r3, [r7, #4]
 811788e:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 8117890:	2b00      	cmp	r3, #0
 8117892:	d115      	bne.n	81178c0 <tcp_process+0x7bc>
        LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed: LAST_ACK %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
        /* bugfix #21699: don't set pcb->state to CLOSED here or we risk leaking segments */
        recv_flags |= TF_CLOSED;
 8117894:	4b11      	ldr	r3, [pc, #68]	; (81178dc <tcp_process+0x7d8>)
 8117896:	781b      	ldrb	r3, [r3, #0]
 8117898:	f043 0310 	orr.w	r3, r3, #16
 811789c:	b2da      	uxtb	r2, r3
 811789e:	4b0f      	ldr	r3, [pc, #60]	; (81178dc <tcp_process+0x7d8>)
 81178a0:	701a      	strb	r2, [r3, #0]
      }
      break;
 81178a2:	e00d      	b.n	81178c0 <tcp_process+0x7bc>
    default:
      break;
 81178a4:	bf00      	nop
 81178a6:	e00c      	b.n	81178c2 <tcp_process+0x7be>
      break;
 81178a8:	bf00      	nop
 81178aa:	e00a      	b.n	81178c2 <tcp_process+0x7be>
      break;
 81178ac:	bf00      	nop
 81178ae:	e008      	b.n	81178c2 <tcp_process+0x7be>
      break;
 81178b0:	bf00      	nop
 81178b2:	e006      	b.n	81178c2 <tcp_process+0x7be>
      break;
 81178b4:	bf00      	nop
 81178b6:	e004      	b.n	81178c2 <tcp_process+0x7be>
      break;
 81178b8:	bf00      	nop
 81178ba:	e002      	b.n	81178c2 <tcp_process+0x7be>
      break;
 81178bc:	bf00      	nop
 81178be:	e000      	b.n	81178c2 <tcp_process+0x7be>
      break;
 81178c0:	bf00      	nop
  }
  return ERR_OK;
 81178c2:	2300      	movs	r3, #0
}
 81178c4:	4618      	mov	r0, r3
 81178c6:	3724      	adds	r7, #36	; 0x24
 81178c8:	46bd      	mov	sp, r7
 81178ca:	bd90      	pop	{r4, r7, pc}
 81178cc:	1000845c 	.word	0x1000845c
 81178d0:	10008458 	.word	0x10008458
 81178d4:	1000848c 	.word	0x1000848c
 81178d8:	10008484 	.word	0x10008484
 81178dc:	1000848d 	.word	0x1000848d
 81178e0:	10008454 	.word	0x10008454

081178e4 <tcp_oos_insert_segment>:
 *
 * Called from tcp_receive()
 */
static void
tcp_oos_insert_segment(struct tcp_seg *cseg, struct tcp_seg *next)
{
 81178e4:	b590      	push	{r4, r7, lr}
 81178e6:	b085      	sub	sp, #20
 81178e8:	af00      	add	r7, sp, #0
 81178ea:	6078      	str	r0, [r7, #4]
 81178ec:	6039      	str	r1, [r7, #0]
  struct tcp_seg *old_seg;

  LWIP_ASSERT("tcp_oos_insert_segment: invalid cseg", cseg != NULL);
 81178ee:	687b      	ldr	r3, [r7, #4]
 81178f0:	2b00      	cmp	r3, #0
 81178f2:	d106      	bne.n	8117902 <tcp_oos_insert_segment+0x1e>
 81178f4:	4b3b      	ldr	r3, [pc, #236]	; (81179e4 <tcp_oos_insert_segment+0x100>)
 81178f6:	f240 421f 	movw	r2, #1055	; 0x41f
 81178fa:	493b      	ldr	r1, [pc, #236]	; (81179e8 <tcp_oos_insert_segment+0x104>)
 81178fc:	483b      	ldr	r0, [pc, #236]	; (81179ec <tcp_oos_insert_segment+0x108>)
 81178fe:	f003 ff7f 	bl	811b800 <iprintf>

  if (TCPH_FLAGS(cseg->tcphdr) & TCP_FIN) {
 8117902:	687b      	ldr	r3, [r7, #4]
 8117904:	68db      	ldr	r3, [r3, #12]
 8117906:	899b      	ldrh	r3, [r3, #12]
 8117908:	b29b      	uxth	r3, r3
 811790a:	4618      	mov	r0, r3
 811790c:	f7f6 fdc1 	bl	810e492 <lwip_htons>
 8117910:	4603      	mov	r3, r0
 8117912:	b2db      	uxtb	r3, r3
 8117914:	f003 0301 	and.w	r3, r3, #1
 8117918:	2b00      	cmp	r3, #0
 811791a:	d028      	beq.n	811796e <tcp_oos_insert_segment+0x8a>
    /* received segment overlaps all following segments */
    tcp_segs_free(next);
 811791c:	6838      	ldr	r0, [r7, #0]
 811791e:	f7fe fa63 	bl	8115de8 <tcp_segs_free>
    next = NULL;
 8117922:	2300      	movs	r3, #0
 8117924:	603b      	str	r3, [r7, #0]
 8117926:	e056      	b.n	81179d6 <tcp_oos_insert_segment+0xf2>
       oos queue may have segments with FIN flag */
    while (next &&
           TCP_SEQ_GEQ((seqno + cseg->len),
                       (next->tcphdr->seqno + next->len))) {
      /* cseg with FIN already processed */
      if (TCPH_FLAGS(next->tcphdr) & TCP_FIN) {
 8117928:	683b      	ldr	r3, [r7, #0]
 811792a:	68db      	ldr	r3, [r3, #12]
 811792c:	899b      	ldrh	r3, [r3, #12]
 811792e:	b29b      	uxth	r3, r3
 8117930:	4618      	mov	r0, r3
 8117932:	f7f6 fdae 	bl	810e492 <lwip_htons>
 8117936:	4603      	mov	r3, r0
 8117938:	b2db      	uxtb	r3, r3
 811793a:	f003 0301 	and.w	r3, r3, #1
 811793e:	2b00      	cmp	r3, #0
 8117940:	d00d      	beq.n	811795e <tcp_oos_insert_segment+0x7a>
        TCPH_SET_FLAG(cseg->tcphdr, TCP_FIN);
 8117942:	687b      	ldr	r3, [r7, #4]
 8117944:	68db      	ldr	r3, [r3, #12]
 8117946:	899b      	ldrh	r3, [r3, #12]
 8117948:	b29c      	uxth	r4, r3
 811794a:	2001      	movs	r0, #1
 811794c:	f7f6 fda1 	bl	810e492 <lwip_htons>
 8117950:	4603      	mov	r3, r0
 8117952:	461a      	mov	r2, r3
 8117954:	687b      	ldr	r3, [r7, #4]
 8117956:	68db      	ldr	r3, [r3, #12]
 8117958:	4322      	orrs	r2, r4
 811795a:	b292      	uxth	r2, r2
 811795c:	819a      	strh	r2, [r3, #12]
      }
      old_seg = next;
 811795e:	683b      	ldr	r3, [r7, #0]
 8117960:	60fb      	str	r3, [r7, #12]
      next = next->next;
 8117962:	683b      	ldr	r3, [r7, #0]
 8117964:	681b      	ldr	r3, [r3, #0]
 8117966:	603b      	str	r3, [r7, #0]
      tcp_seg_free(old_seg);
 8117968:	68f8      	ldr	r0, [r7, #12]
 811796a:	f7fe fa52 	bl	8115e12 <tcp_seg_free>
    while (next &&
 811796e:	683b      	ldr	r3, [r7, #0]
 8117970:	2b00      	cmp	r3, #0
 8117972:	d00e      	beq.n	8117992 <tcp_oos_insert_segment+0xae>
           TCP_SEQ_GEQ((seqno + cseg->len),
 8117974:	687b      	ldr	r3, [r7, #4]
 8117976:	891b      	ldrh	r3, [r3, #8]
 8117978:	461a      	mov	r2, r3
 811797a:	4b1d      	ldr	r3, [pc, #116]	; (81179f0 <tcp_oos_insert_segment+0x10c>)
 811797c:	681b      	ldr	r3, [r3, #0]
 811797e:	441a      	add	r2, r3
 8117980:	683b      	ldr	r3, [r7, #0]
 8117982:	68db      	ldr	r3, [r3, #12]
 8117984:	685b      	ldr	r3, [r3, #4]
 8117986:	6839      	ldr	r1, [r7, #0]
 8117988:	8909      	ldrh	r1, [r1, #8]
 811798a:	440b      	add	r3, r1
 811798c:	1ad3      	subs	r3, r2, r3
    while (next &&
 811798e:	2b00      	cmp	r3, #0
 8117990:	daca      	bge.n	8117928 <tcp_oos_insert_segment+0x44>
    }
    if (next &&
 8117992:	683b      	ldr	r3, [r7, #0]
 8117994:	2b00      	cmp	r3, #0
 8117996:	d01e      	beq.n	81179d6 <tcp_oos_insert_segment+0xf2>
        TCP_SEQ_GT(seqno + cseg->len, next->tcphdr->seqno)) {
 8117998:	687b      	ldr	r3, [r7, #4]
 811799a:	891b      	ldrh	r3, [r3, #8]
 811799c:	461a      	mov	r2, r3
 811799e:	4b14      	ldr	r3, [pc, #80]	; (81179f0 <tcp_oos_insert_segment+0x10c>)
 81179a0:	681b      	ldr	r3, [r3, #0]
 81179a2:	441a      	add	r2, r3
 81179a4:	683b      	ldr	r3, [r7, #0]
 81179a6:	68db      	ldr	r3, [r3, #12]
 81179a8:	685b      	ldr	r3, [r3, #4]
 81179aa:	1ad3      	subs	r3, r2, r3
    if (next &&
 81179ac:	2b00      	cmp	r3, #0
 81179ae:	dd12      	ble.n	81179d6 <tcp_oos_insert_segment+0xf2>
      /* We need to trim the incoming segment. */
      cseg->len = (u16_t)(next->tcphdr->seqno - seqno);
 81179b0:	683b      	ldr	r3, [r7, #0]
 81179b2:	68db      	ldr	r3, [r3, #12]
 81179b4:	685b      	ldr	r3, [r3, #4]
 81179b6:	b29a      	uxth	r2, r3
 81179b8:	4b0d      	ldr	r3, [pc, #52]	; (81179f0 <tcp_oos_insert_segment+0x10c>)
 81179ba:	681b      	ldr	r3, [r3, #0]
 81179bc:	b29b      	uxth	r3, r3
 81179be:	1ad3      	subs	r3, r2, r3
 81179c0:	b29a      	uxth	r2, r3
 81179c2:	687b      	ldr	r3, [r7, #4]
 81179c4:	811a      	strh	r2, [r3, #8]
      pbuf_realloc(cseg->p, cseg->len);
 81179c6:	687b      	ldr	r3, [r7, #4]
 81179c8:	685a      	ldr	r2, [r3, #4]
 81179ca:	687b      	ldr	r3, [r7, #4]
 81179cc:	891b      	ldrh	r3, [r3, #8]
 81179ce:	4619      	mov	r1, r3
 81179d0:	4610      	mov	r0, r2
 81179d2:	f7fc fcbb 	bl	811434c <pbuf_realloc>
    }
  }
  cseg->next = next;
 81179d6:	687b      	ldr	r3, [r7, #4]
 81179d8:	683a      	ldr	r2, [r7, #0]
 81179da:	601a      	str	r2, [r3, #0]
}
 81179dc:	bf00      	nop
 81179de:	3714      	adds	r7, #20
 81179e0:	46bd      	mov	sp, r7
 81179e2:	bd90      	pop	{r4, r7, pc}
 81179e4:	0811e6e4 	.word	0x0811e6e4
 81179e8:	0811e9d8 	.word	0x0811e9d8
 81179ec:	0811e764 	.word	0x0811e764
 81179f0:	10008480 	.word	0x10008480

081179f4 <tcp_free_acked_segments>:

/** Remove segments from a list if the incoming ACK acknowledges them */
static struct tcp_seg *
tcp_free_acked_segments(struct tcp_pcb *pcb, struct tcp_seg *seg_list, const char *dbg_list_name,
                        struct tcp_seg *dbg_other_seg_list)
{
 81179f4:	b5b0      	push	{r4, r5, r7, lr}
 81179f6:	b086      	sub	sp, #24
 81179f8:	af00      	add	r7, sp, #0
 81179fa:	60f8      	str	r0, [r7, #12]
 81179fc:	60b9      	str	r1, [r7, #8]
 81179fe:	607a      	str	r2, [r7, #4]
 8117a00:	603b      	str	r3, [r7, #0]
  u16_t clen;

  LWIP_UNUSED_ARG(dbg_list_name);
  LWIP_UNUSED_ARG(dbg_other_seg_list);

  while (seg_list != NULL &&
 8117a02:	e03e      	b.n	8117a82 <tcp_free_acked_segments+0x8e>
    LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: removing %"U32_F":%"U32_F" from pcb->%s\n",
                                  lwip_ntohl(seg_list->tcphdr->seqno),
                                  lwip_ntohl(seg_list->tcphdr->seqno) + TCP_TCPLEN(seg_list),
                                  dbg_list_name));

    next = seg_list;
 8117a04:	68bb      	ldr	r3, [r7, #8]
 8117a06:	617b      	str	r3, [r7, #20]
    seg_list = seg_list->next;
 8117a08:	68bb      	ldr	r3, [r7, #8]
 8117a0a:	681b      	ldr	r3, [r3, #0]
 8117a0c:	60bb      	str	r3, [r7, #8]

    clen = pbuf_clen(next->p);
 8117a0e:	697b      	ldr	r3, [r7, #20]
 8117a10:	685b      	ldr	r3, [r3, #4]
 8117a12:	4618      	mov	r0, r3
 8117a14:	f7fc fea8 	bl	8114768 <pbuf_clen>
 8117a18:	4603      	mov	r3, r0
 8117a1a:	827b      	strh	r3, [r7, #18]
    LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_receive: queuelen %"TCPWNDSIZE_F" ... ",
                                 (tcpwnd_size_t)pcb->snd_queuelen));
    LWIP_ASSERT("pcb->snd_queuelen >= pbuf_clen(next->p)", (pcb->snd_queuelen >= clen));
 8117a1c:	68fb      	ldr	r3, [r7, #12]
 8117a1e:	f8b3 3066 	ldrh.w	r3, [r3, #102]	; 0x66
 8117a22:	8a7a      	ldrh	r2, [r7, #18]
 8117a24:	429a      	cmp	r2, r3
 8117a26:	d906      	bls.n	8117a36 <tcp_free_acked_segments+0x42>
 8117a28:	4b2a      	ldr	r3, [pc, #168]	; (8117ad4 <tcp_free_acked_segments+0xe0>)
 8117a2a:	f240 4257 	movw	r2, #1111	; 0x457
 8117a2e:	492a      	ldr	r1, [pc, #168]	; (8117ad8 <tcp_free_acked_segments+0xe4>)
 8117a30:	482a      	ldr	r0, [pc, #168]	; (8117adc <tcp_free_acked_segments+0xe8>)
 8117a32:	f003 fee5 	bl	811b800 <iprintf>

    pcb->snd_queuelen = (u16_t)(pcb->snd_queuelen - clen);
 8117a36:	68fb      	ldr	r3, [r7, #12]
 8117a38:	f8b3 2066 	ldrh.w	r2, [r3, #102]	; 0x66
 8117a3c:	8a7b      	ldrh	r3, [r7, #18]
 8117a3e:	1ad3      	subs	r3, r2, r3
 8117a40:	b29a      	uxth	r2, r3
 8117a42:	68fb      	ldr	r3, [r7, #12]
 8117a44:	f8a3 2066 	strh.w	r2, [r3, #102]	; 0x66
    recv_acked = (tcpwnd_size_t)(recv_acked + next->len);
 8117a48:	697b      	ldr	r3, [r7, #20]
 8117a4a:	891a      	ldrh	r2, [r3, #8]
 8117a4c:	4b24      	ldr	r3, [pc, #144]	; (8117ae0 <tcp_free_acked_segments+0xec>)
 8117a4e:	881b      	ldrh	r3, [r3, #0]
 8117a50:	4413      	add	r3, r2
 8117a52:	b29a      	uxth	r2, r3
 8117a54:	4b22      	ldr	r3, [pc, #136]	; (8117ae0 <tcp_free_acked_segments+0xec>)
 8117a56:	801a      	strh	r2, [r3, #0]
    tcp_seg_free(next);
 8117a58:	6978      	ldr	r0, [r7, #20]
 8117a5a:	f7fe f9da 	bl	8115e12 <tcp_seg_free>

    LWIP_DEBUGF(TCP_QLEN_DEBUG, ("%"TCPWNDSIZE_F" (after freeing %s)\n",
                                 (tcpwnd_size_t)pcb->snd_queuelen,
                                 dbg_list_name));
    if (pcb->snd_queuelen != 0) {
 8117a5e:	68fb      	ldr	r3, [r7, #12]
 8117a60:	f8b3 3066 	ldrh.w	r3, [r3, #102]	; 0x66
 8117a64:	2b00      	cmp	r3, #0
 8117a66:	d00c      	beq.n	8117a82 <tcp_free_acked_segments+0x8e>
      LWIP_ASSERT("tcp_receive: valid queue length",
 8117a68:	68bb      	ldr	r3, [r7, #8]
 8117a6a:	2b00      	cmp	r3, #0
 8117a6c:	d109      	bne.n	8117a82 <tcp_free_acked_segments+0x8e>
 8117a6e:	683b      	ldr	r3, [r7, #0]
 8117a70:	2b00      	cmp	r3, #0
 8117a72:	d106      	bne.n	8117a82 <tcp_free_acked_segments+0x8e>
 8117a74:	4b17      	ldr	r3, [pc, #92]	; (8117ad4 <tcp_free_acked_segments+0xe0>)
 8117a76:	f240 4261 	movw	r2, #1121	; 0x461
 8117a7a:	491a      	ldr	r1, [pc, #104]	; (8117ae4 <tcp_free_acked_segments+0xf0>)
 8117a7c:	4817      	ldr	r0, [pc, #92]	; (8117adc <tcp_free_acked_segments+0xe8>)
 8117a7e:	f003 febf 	bl	811b800 <iprintf>
  while (seg_list != NULL &&
 8117a82:	68bb      	ldr	r3, [r7, #8]
 8117a84:	2b00      	cmp	r3, #0
 8117a86:	d020      	beq.n	8117aca <tcp_free_acked_segments+0xd6>
         TCP_SEQ_LEQ(lwip_ntohl(seg_list->tcphdr->seqno) +
 8117a88:	68bb      	ldr	r3, [r7, #8]
 8117a8a:	68db      	ldr	r3, [r3, #12]
 8117a8c:	685b      	ldr	r3, [r3, #4]
 8117a8e:	4618      	mov	r0, r3
 8117a90:	f7f6 fd14 	bl	810e4bc <lwip_htonl>
 8117a94:	4604      	mov	r4, r0
 8117a96:	68bb      	ldr	r3, [r7, #8]
 8117a98:	891b      	ldrh	r3, [r3, #8]
 8117a9a:	461d      	mov	r5, r3
 8117a9c:	68bb      	ldr	r3, [r7, #8]
 8117a9e:	68db      	ldr	r3, [r3, #12]
 8117aa0:	899b      	ldrh	r3, [r3, #12]
 8117aa2:	b29b      	uxth	r3, r3
 8117aa4:	4618      	mov	r0, r3
 8117aa6:	f7f6 fcf4 	bl	810e492 <lwip_htons>
 8117aaa:	4603      	mov	r3, r0
 8117aac:	b2db      	uxtb	r3, r3
 8117aae:	f003 0303 	and.w	r3, r3, #3
 8117ab2:	2b00      	cmp	r3, #0
 8117ab4:	d001      	beq.n	8117aba <tcp_free_acked_segments+0xc6>
 8117ab6:	2301      	movs	r3, #1
 8117ab8:	e000      	b.n	8117abc <tcp_free_acked_segments+0xc8>
 8117aba:	2300      	movs	r3, #0
 8117abc:	442b      	add	r3, r5
 8117abe:	18e2      	adds	r2, r4, r3
 8117ac0:	4b09      	ldr	r3, [pc, #36]	; (8117ae8 <tcp_free_acked_segments+0xf4>)
 8117ac2:	681b      	ldr	r3, [r3, #0]
 8117ac4:	1ad3      	subs	r3, r2, r3
  while (seg_list != NULL &&
 8117ac6:	2b00      	cmp	r3, #0
 8117ac8:	dd9c      	ble.n	8117a04 <tcp_free_acked_segments+0x10>
                  seg_list != NULL || dbg_other_seg_list != NULL);
    }
  }
  return seg_list;
 8117aca:	68bb      	ldr	r3, [r7, #8]
}
 8117acc:	4618      	mov	r0, r3
 8117ace:	3718      	adds	r7, #24
 8117ad0:	46bd      	mov	sp, r7
 8117ad2:	bdb0      	pop	{r4, r5, r7, pc}
 8117ad4:	0811e6e4 	.word	0x0811e6e4
 8117ad8:	0811ea00 	.word	0x0811ea00
 8117adc:	0811e764 	.word	0x0811e764
 8117ae0:	10008488 	.word	0x10008488
 8117ae4:	0811ea28 	.word	0x0811ea28
 8117ae8:	10008484 	.word	0x10008484

08117aec <tcp_receive>:
 *
 * Called from tcp_process().
 */
static void
tcp_receive(struct tcp_pcb *pcb)
{
 8117aec:	b5b0      	push	{r4, r5, r7, lr}
 8117aee:	b094      	sub	sp, #80	; 0x50
 8117af0:	af00      	add	r7, sp, #0
 8117af2:	6078      	str	r0, [r7, #4]
  s16_t m;
  u32_t right_wnd_edge;
  int found_dupack = 0;
 8117af4:	2300      	movs	r3, #0
 8117af6:	64bb      	str	r3, [r7, #72]	; 0x48

  LWIP_ASSERT("tcp_receive: invalid pcb", pcb != NULL);
 8117af8:	687b      	ldr	r3, [r7, #4]
 8117afa:	2b00      	cmp	r3, #0
 8117afc:	d106      	bne.n	8117b0c <tcp_receive+0x20>
 8117afe:	4b91      	ldr	r3, [pc, #580]	; (8117d44 <tcp_receive+0x258>)
 8117b00:	f240 427b 	movw	r2, #1147	; 0x47b
 8117b04:	4990      	ldr	r1, [pc, #576]	; (8117d48 <tcp_receive+0x25c>)
 8117b06:	4891      	ldr	r0, [pc, #580]	; (8117d4c <tcp_receive+0x260>)
 8117b08:	f003 fe7a 	bl	811b800 <iprintf>
  LWIP_ASSERT("tcp_receive: wrong state", pcb->state >= ESTABLISHED);
 8117b0c:	687b      	ldr	r3, [r7, #4]
 8117b0e:	7d1b      	ldrb	r3, [r3, #20]
 8117b10:	2b03      	cmp	r3, #3
 8117b12:	d806      	bhi.n	8117b22 <tcp_receive+0x36>
 8117b14:	4b8b      	ldr	r3, [pc, #556]	; (8117d44 <tcp_receive+0x258>)
 8117b16:	f240 427c 	movw	r2, #1148	; 0x47c
 8117b1a:	498d      	ldr	r1, [pc, #564]	; (8117d50 <tcp_receive+0x264>)
 8117b1c:	488b      	ldr	r0, [pc, #556]	; (8117d4c <tcp_receive+0x260>)
 8117b1e:	f003 fe6f 	bl	811b800 <iprintf>

  if (flags & TCP_ACK) {
 8117b22:	4b8c      	ldr	r3, [pc, #560]	; (8117d54 <tcp_receive+0x268>)
 8117b24:	781b      	ldrb	r3, [r3, #0]
 8117b26:	f003 0310 	and.w	r3, r3, #16
 8117b2a:	2b00      	cmp	r3, #0
 8117b2c:	f000 8264 	beq.w	8117ff8 <tcp_receive+0x50c>
    right_wnd_edge = pcb->snd_wnd + pcb->snd_wl2;
 8117b30:	687b      	ldr	r3, [r7, #4]
 8117b32:	f8b3 3060 	ldrh.w	r3, [r3, #96]	; 0x60
 8117b36:	461a      	mov	r2, r3
 8117b38:	687b      	ldr	r3, [r7, #4]
 8117b3a:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8117b3c:	4413      	add	r3, r2
 8117b3e:	633b      	str	r3, [r7, #48]	; 0x30

    /* Update window. */
    if (TCP_SEQ_LT(pcb->snd_wl1, seqno) ||
 8117b40:	687b      	ldr	r3, [r7, #4]
 8117b42:	6d5a      	ldr	r2, [r3, #84]	; 0x54
 8117b44:	4b84      	ldr	r3, [pc, #528]	; (8117d58 <tcp_receive+0x26c>)
 8117b46:	681b      	ldr	r3, [r3, #0]
 8117b48:	1ad3      	subs	r3, r2, r3
 8117b4a:	2b00      	cmp	r3, #0
 8117b4c:	db1b      	blt.n	8117b86 <tcp_receive+0x9a>
        (pcb->snd_wl1 == seqno && TCP_SEQ_LT(pcb->snd_wl2, ackno)) ||
 8117b4e:	687b      	ldr	r3, [r7, #4]
 8117b50:	6d5a      	ldr	r2, [r3, #84]	; 0x54
 8117b52:	4b81      	ldr	r3, [pc, #516]	; (8117d58 <tcp_receive+0x26c>)
 8117b54:	681b      	ldr	r3, [r3, #0]
    if (TCP_SEQ_LT(pcb->snd_wl1, seqno) ||
 8117b56:	429a      	cmp	r2, r3
 8117b58:	d106      	bne.n	8117b68 <tcp_receive+0x7c>
        (pcb->snd_wl1 == seqno && TCP_SEQ_LT(pcb->snd_wl2, ackno)) ||
 8117b5a:	687b      	ldr	r3, [r7, #4]
 8117b5c:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 8117b5e:	4b7f      	ldr	r3, [pc, #508]	; (8117d5c <tcp_receive+0x270>)
 8117b60:	681b      	ldr	r3, [r3, #0]
 8117b62:	1ad3      	subs	r3, r2, r3
 8117b64:	2b00      	cmp	r3, #0
 8117b66:	db0e      	blt.n	8117b86 <tcp_receive+0x9a>
        (pcb->snd_wl2 == ackno && (u32_t)SND_WND_SCALE(pcb, tcphdr->wnd) > pcb->snd_wnd)) {
 8117b68:	687b      	ldr	r3, [r7, #4]
 8117b6a:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 8117b6c:	4b7b      	ldr	r3, [pc, #492]	; (8117d5c <tcp_receive+0x270>)
 8117b6e:	681b      	ldr	r3, [r3, #0]
        (pcb->snd_wl1 == seqno && TCP_SEQ_LT(pcb->snd_wl2, ackno)) ||
 8117b70:	429a      	cmp	r2, r3
 8117b72:	d125      	bne.n	8117bc0 <tcp_receive+0xd4>
        (pcb->snd_wl2 == ackno && (u32_t)SND_WND_SCALE(pcb, tcphdr->wnd) > pcb->snd_wnd)) {
 8117b74:	4b7a      	ldr	r3, [pc, #488]	; (8117d60 <tcp_receive+0x274>)
 8117b76:	681b      	ldr	r3, [r3, #0]
 8117b78:	89db      	ldrh	r3, [r3, #14]
 8117b7a:	b29a      	uxth	r2, r3
 8117b7c:	687b      	ldr	r3, [r7, #4]
 8117b7e:	f8b3 3060 	ldrh.w	r3, [r3, #96]	; 0x60
 8117b82:	429a      	cmp	r2, r3
 8117b84:	d91c      	bls.n	8117bc0 <tcp_receive+0xd4>
      pcb->snd_wnd = SND_WND_SCALE(pcb, tcphdr->wnd);
 8117b86:	4b76      	ldr	r3, [pc, #472]	; (8117d60 <tcp_receive+0x274>)
 8117b88:	681b      	ldr	r3, [r3, #0]
 8117b8a:	89db      	ldrh	r3, [r3, #14]
 8117b8c:	b29a      	uxth	r2, r3
 8117b8e:	687b      	ldr	r3, [r7, #4]
 8117b90:	f8a3 2060 	strh.w	r2, [r3, #96]	; 0x60
      /* keep track of the biggest window announced by the remote host to calculate
         the maximum segment size */
      if (pcb->snd_wnd_max < pcb->snd_wnd) {
 8117b94:	687b      	ldr	r3, [r7, #4]
 8117b96:	f8b3 2062 	ldrh.w	r2, [r3, #98]	; 0x62
 8117b9a:	687b      	ldr	r3, [r7, #4]
 8117b9c:	f8b3 3060 	ldrh.w	r3, [r3, #96]	; 0x60
 8117ba0:	429a      	cmp	r2, r3
 8117ba2:	d205      	bcs.n	8117bb0 <tcp_receive+0xc4>
        pcb->snd_wnd_max = pcb->snd_wnd;
 8117ba4:	687b      	ldr	r3, [r7, #4]
 8117ba6:	f8b3 2060 	ldrh.w	r2, [r3, #96]	; 0x60
 8117baa:	687b      	ldr	r3, [r7, #4]
 8117bac:	f8a3 2062 	strh.w	r2, [r3, #98]	; 0x62
      }
      pcb->snd_wl1 = seqno;
 8117bb0:	4b69      	ldr	r3, [pc, #420]	; (8117d58 <tcp_receive+0x26c>)
 8117bb2:	681a      	ldr	r2, [r3, #0]
 8117bb4:	687b      	ldr	r3, [r7, #4]
 8117bb6:	655a      	str	r2, [r3, #84]	; 0x54
      pcb->snd_wl2 = ackno;
 8117bb8:	4b68      	ldr	r3, [pc, #416]	; (8117d5c <tcp_receive+0x270>)
 8117bba:	681a      	ldr	r2, [r3, #0]
 8117bbc:	687b      	ldr	r3, [r7, #4]
 8117bbe:	659a      	str	r2, [r3, #88]	; 0x58
     * If it only passes 1, should reset dupack counter
     *
     */

    /* Clause 1 */
    if (TCP_SEQ_LEQ(ackno, pcb->lastack)) {
 8117bc0:	4b66      	ldr	r3, [pc, #408]	; (8117d5c <tcp_receive+0x270>)
 8117bc2:	681a      	ldr	r2, [r3, #0]
 8117bc4:	687b      	ldr	r3, [r7, #4]
 8117bc6:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8117bc8:	1ad3      	subs	r3, r2, r3
 8117bca:	2b00      	cmp	r3, #0
 8117bcc:	dc58      	bgt.n	8117c80 <tcp_receive+0x194>
      /* Clause 2 */
      if (tcplen == 0) {
 8117bce:	4b65      	ldr	r3, [pc, #404]	; (8117d64 <tcp_receive+0x278>)
 8117bd0:	881b      	ldrh	r3, [r3, #0]
 8117bd2:	2b00      	cmp	r3, #0
 8117bd4:	d14b      	bne.n	8117c6e <tcp_receive+0x182>
        /* Clause 3 */
        if (pcb->snd_wl2 + pcb->snd_wnd == right_wnd_edge) {
 8117bd6:	687b      	ldr	r3, [r7, #4]
 8117bd8:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8117bda:	687a      	ldr	r2, [r7, #4]
 8117bdc:	f8b2 2060 	ldrh.w	r2, [r2, #96]	; 0x60
 8117be0:	4413      	add	r3, r2
 8117be2:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 8117be4:	429a      	cmp	r2, r3
 8117be6:	d142      	bne.n	8117c6e <tcp_receive+0x182>
          /* Clause 4 */
          if (pcb->rtime >= 0) {
 8117be8:	687b      	ldr	r3, [r7, #4]
 8117bea:	f9b3 3030 	ldrsh.w	r3, [r3, #48]	; 0x30
 8117bee:	2b00      	cmp	r3, #0
 8117bf0:	db3d      	blt.n	8117c6e <tcp_receive+0x182>
            /* Clause 5 */
            if (pcb->lastack == ackno) {
 8117bf2:	687b      	ldr	r3, [r7, #4]
 8117bf4:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 8117bf6:	4b59      	ldr	r3, [pc, #356]	; (8117d5c <tcp_receive+0x270>)
 8117bf8:	681b      	ldr	r3, [r3, #0]
 8117bfa:	429a      	cmp	r2, r3
 8117bfc:	d137      	bne.n	8117c6e <tcp_receive+0x182>
              found_dupack = 1;
 8117bfe:	2301      	movs	r3, #1
 8117c00:	64bb      	str	r3, [r7, #72]	; 0x48
              if ((u8_t)(pcb->dupacks + 1) > pcb->dupacks) {
 8117c02:	687b      	ldr	r3, [r7, #4]
 8117c04:	f893 3043 	ldrb.w	r3, [r3, #67]	; 0x43
 8117c08:	2bff      	cmp	r3, #255	; 0xff
 8117c0a:	d007      	beq.n	8117c1c <tcp_receive+0x130>
                ++pcb->dupacks;
 8117c0c:	687b      	ldr	r3, [r7, #4]
 8117c0e:	f893 3043 	ldrb.w	r3, [r3, #67]	; 0x43
 8117c12:	3301      	adds	r3, #1
 8117c14:	b2da      	uxtb	r2, r3
 8117c16:	687b      	ldr	r3, [r7, #4]
 8117c18:	f883 2043 	strb.w	r2, [r3, #67]	; 0x43
              }
              if (pcb->dupacks > 3) {
 8117c1c:	687b      	ldr	r3, [r7, #4]
 8117c1e:	f893 3043 	ldrb.w	r3, [r3, #67]	; 0x43
 8117c22:	2b03      	cmp	r3, #3
 8117c24:	d91b      	bls.n	8117c5e <tcp_receive+0x172>
                /* Inflate the congestion window */
                TCP_WND_INC(pcb->cwnd, pcb->mss);
 8117c26:	687b      	ldr	r3, [r7, #4]
 8117c28:	f8b3 2048 	ldrh.w	r2, [r3, #72]	; 0x48
 8117c2c:	687b      	ldr	r3, [r7, #4]
 8117c2e:	8e5b      	ldrh	r3, [r3, #50]	; 0x32
 8117c30:	4413      	add	r3, r2
 8117c32:	b29a      	uxth	r2, r3
 8117c34:	687b      	ldr	r3, [r7, #4]
 8117c36:	f8b3 3048 	ldrh.w	r3, [r3, #72]	; 0x48
 8117c3a:	429a      	cmp	r2, r3
 8117c3c:	d30a      	bcc.n	8117c54 <tcp_receive+0x168>
 8117c3e:	687b      	ldr	r3, [r7, #4]
 8117c40:	f8b3 2048 	ldrh.w	r2, [r3, #72]	; 0x48
 8117c44:	687b      	ldr	r3, [r7, #4]
 8117c46:	8e5b      	ldrh	r3, [r3, #50]	; 0x32
 8117c48:	4413      	add	r3, r2
 8117c4a:	b29a      	uxth	r2, r3
 8117c4c:	687b      	ldr	r3, [r7, #4]
 8117c4e:	f8a3 2048 	strh.w	r2, [r3, #72]	; 0x48
 8117c52:	e004      	b.n	8117c5e <tcp_receive+0x172>
 8117c54:	687b      	ldr	r3, [r7, #4]
 8117c56:	f64f 72ff 	movw	r2, #65535	; 0xffff
 8117c5a:	f8a3 2048 	strh.w	r2, [r3, #72]	; 0x48
              }
              if (pcb->dupacks >= 3) {
 8117c5e:	687b      	ldr	r3, [r7, #4]
 8117c60:	f893 3043 	ldrb.w	r3, [r3, #67]	; 0x43
 8117c64:	2b02      	cmp	r3, #2
 8117c66:	d902      	bls.n	8117c6e <tcp_receive+0x182>
                /* Do fast retransmit (checked via TF_INFR, not via dupacks count) */
                tcp_rexmit_fast(pcb);
 8117c68:	6878      	ldr	r0, [r7, #4]
 8117c6a:	f001 feed 	bl	8119a48 <tcp_rexmit_fast>
          }
        }
      }
      /* If Clause (1) or more is true, but not a duplicate ack, reset
       * count of consecutive duplicate acks */
      if (!found_dupack) {
 8117c6e:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8117c70:	2b00      	cmp	r3, #0
 8117c72:	f040 8161 	bne.w	8117f38 <tcp_receive+0x44c>
        pcb->dupacks = 0;
 8117c76:	687b      	ldr	r3, [r7, #4]
 8117c78:	2200      	movs	r2, #0
 8117c7a:	f883 2043 	strb.w	r2, [r3, #67]	; 0x43
 8117c7e:	e15b      	b.n	8117f38 <tcp_receive+0x44c>
      }
    } else if (TCP_SEQ_BETWEEN(ackno, pcb->lastack + 1, pcb->snd_nxt)) {
 8117c80:	4b36      	ldr	r3, [pc, #216]	; (8117d5c <tcp_receive+0x270>)
 8117c82:	681a      	ldr	r2, [r3, #0]
 8117c84:	687b      	ldr	r3, [r7, #4]
 8117c86:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8117c88:	1ad3      	subs	r3, r2, r3
 8117c8a:	3b01      	subs	r3, #1
 8117c8c:	2b00      	cmp	r3, #0
 8117c8e:	f2c0 814e 	blt.w	8117f2e <tcp_receive+0x442>
 8117c92:	4b32      	ldr	r3, [pc, #200]	; (8117d5c <tcp_receive+0x270>)
 8117c94:	681a      	ldr	r2, [r3, #0]
 8117c96:	687b      	ldr	r3, [r7, #4]
 8117c98:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8117c9a:	1ad3      	subs	r3, r2, r3
 8117c9c:	2b00      	cmp	r3, #0
 8117c9e:	f300 8146 	bgt.w	8117f2e <tcp_receive+0x442>
      tcpwnd_size_t acked;

      /* Reset the "IN Fast Retransmit" flag, since we are no longer
         in fast retransmit. Also reset the congestion window to the
         slow start threshold. */
      if (pcb->flags & TF_INFR) {
 8117ca2:	687b      	ldr	r3, [r7, #4]
 8117ca4:	8b5b      	ldrh	r3, [r3, #26]
 8117ca6:	f003 0304 	and.w	r3, r3, #4
 8117caa:	2b00      	cmp	r3, #0
 8117cac:	d010      	beq.n	8117cd0 <tcp_receive+0x1e4>
        tcp_clear_flags(pcb, TF_INFR);
 8117cae:	687b      	ldr	r3, [r7, #4]
 8117cb0:	8b5b      	ldrh	r3, [r3, #26]
 8117cb2:	f023 0304 	bic.w	r3, r3, #4
 8117cb6:	b29a      	uxth	r2, r3
 8117cb8:	687b      	ldr	r3, [r7, #4]
 8117cba:	835a      	strh	r2, [r3, #26]
        pcb->cwnd = pcb->ssthresh;
 8117cbc:	687b      	ldr	r3, [r7, #4]
 8117cbe:	f8b3 204a 	ldrh.w	r2, [r3, #74]	; 0x4a
 8117cc2:	687b      	ldr	r3, [r7, #4]
 8117cc4:	f8a3 2048 	strh.w	r2, [r3, #72]	; 0x48
        pcb->bytes_acked = 0;
 8117cc8:	687b      	ldr	r3, [r7, #4]
 8117cca:	2200      	movs	r2, #0
 8117ccc:	f8a3 206a 	strh.w	r2, [r3, #106]	; 0x6a
      }

      /* Reset the number of retransmissions. */
      pcb->nrtx = 0;
 8117cd0:	687b      	ldr	r3, [r7, #4]
 8117cd2:	2200      	movs	r2, #0
 8117cd4:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42

      /* Reset the retransmission time-out. */
      pcb->rto = (s16_t)((pcb->sa >> 3) + pcb->sv);
 8117cd8:	687b      	ldr	r3, [r7, #4]
 8117cda:	f9b3 303c 	ldrsh.w	r3, [r3, #60]	; 0x3c
 8117cde:	10db      	asrs	r3, r3, #3
 8117ce0:	b21b      	sxth	r3, r3
 8117ce2:	b29a      	uxth	r2, r3
 8117ce4:	687b      	ldr	r3, [r7, #4]
 8117ce6:	f9b3 303e 	ldrsh.w	r3, [r3, #62]	; 0x3e
 8117cea:	b29b      	uxth	r3, r3
 8117cec:	4413      	add	r3, r2
 8117cee:	b29b      	uxth	r3, r3
 8117cf0:	b21a      	sxth	r2, r3
 8117cf2:	687b      	ldr	r3, [r7, #4]
 8117cf4:	f8a3 2040 	strh.w	r2, [r3, #64]	; 0x40

      /* Record how much data this ACK acks */
      acked = (tcpwnd_size_t)(ackno - pcb->lastack);
 8117cf8:	4b18      	ldr	r3, [pc, #96]	; (8117d5c <tcp_receive+0x270>)
 8117cfa:	681b      	ldr	r3, [r3, #0]
 8117cfc:	b29a      	uxth	r2, r3
 8117cfe:	687b      	ldr	r3, [r7, #4]
 8117d00:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8117d02:	b29b      	uxth	r3, r3
 8117d04:	1ad3      	subs	r3, r2, r3
 8117d06:	85fb      	strh	r3, [r7, #46]	; 0x2e

      /* Reset the fast retransmit variables. */
      pcb->dupacks = 0;
 8117d08:	687b      	ldr	r3, [r7, #4]
 8117d0a:	2200      	movs	r2, #0
 8117d0c:	f883 2043 	strb.w	r2, [r3, #67]	; 0x43
      pcb->lastack = ackno;
 8117d10:	4b12      	ldr	r3, [pc, #72]	; (8117d5c <tcp_receive+0x270>)
 8117d12:	681a      	ldr	r2, [r3, #0]
 8117d14:	687b      	ldr	r3, [r7, #4]
 8117d16:	645a      	str	r2, [r3, #68]	; 0x44

      /* Update the congestion control variables (cwnd and
         ssthresh). */
      if (pcb->state >= ESTABLISHED) {
 8117d18:	687b      	ldr	r3, [r7, #4]
 8117d1a:	7d1b      	ldrb	r3, [r3, #20]
 8117d1c:	2b03      	cmp	r3, #3
 8117d1e:	f240 8097 	bls.w	8117e50 <tcp_receive+0x364>
        if (pcb->cwnd < pcb->ssthresh) {
 8117d22:	687b      	ldr	r3, [r7, #4]
 8117d24:	f8b3 2048 	ldrh.w	r2, [r3, #72]	; 0x48
 8117d28:	687b      	ldr	r3, [r7, #4]
 8117d2a:	f8b3 304a 	ldrh.w	r3, [r3, #74]	; 0x4a
 8117d2e:	429a      	cmp	r2, r3
 8117d30:	d245      	bcs.n	8117dbe <tcp_receive+0x2d2>
          tcpwnd_size_t increase;
          /* limit to 1 SMSS segment during period following RTO */
          u8_t num_seg = (pcb->flags & TF_RTO) ? 1 : 2;
 8117d32:	687b      	ldr	r3, [r7, #4]
 8117d34:	8b5b      	ldrh	r3, [r3, #26]
 8117d36:	f403 6300 	and.w	r3, r3, #2048	; 0x800
 8117d3a:	2b00      	cmp	r3, #0
 8117d3c:	d014      	beq.n	8117d68 <tcp_receive+0x27c>
 8117d3e:	2301      	movs	r3, #1
 8117d40:	e013      	b.n	8117d6a <tcp_receive+0x27e>
 8117d42:	bf00      	nop
 8117d44:	0811e6e4 	.word	0x0811e6e4
 8117d48:	0811ea48 	.word	0x0811ea48
 8117d4c:	0811e764 	.word	0x0811e764
 8117d50:	0811ea64 	.word	0x0811ea64
 8117d54:	1000848c 	.word	0x1000848c
 8117d58:	10008480 	.word	0x10008480
 8117d5c:	10008484 	.word	0x10008484
 8117d60:	10008470 	.word	0x10008470
 8117d64:	1000848a 	.word	0x1000848a
 8117d68:	2302      	movs	r3, #2
 8117d6a:	f887 302d 	strb.w	r3, [r7, #45]	; 0x2d
          /* RFC 3465, section 2.2 Slow Start */
          increase = LWIP_MIN(acked, (tcpwnd_size_t)(num_seg * pcb->mss));
 8117d6e:	f897 302d 	ldrb.w	r3, [r7, #45]	; 0x2d
 8117d72:	b29a      	uxth	r2, r3
 8117d74:	687b      	ldr	r3, [r7, #4]
 8117d76:	8e5b      	ldrh	r3, [r3, #50]	; 0x32
 8117d78:	fb12 f303 	smulbb	r3, r2, r3
 8117d7c:	b29b      	uxth	r3, r3
 8117d7e:	8dfa      	ldrh	r2, [r7, #46]	; 0x2e
 8117d80:	4293      	cmp	r3, r2
 8117d82:	bf28      	it	cs
 8117d84:	4613      	movcs	r3, r2
 8117d86:	857b      	strh	r3, [r7, #42]	; 0x2a
          TCP_WND_INC(pcb->cwnd, increase);
 8117d88:	687b      	ldr	r3, [r7, #4]
 8117d8a:	f8b3 2048 	ldrh.w	r2, [r3, #72]	; 0x48
 8117d8e:	8d7b      	ldrh	r3, [r7, #42]	; 0x2a
 8117d90:	4413      	add	r3, r2
 8117d92:	b29a      	uxth	r2, r3
 8117d94:	687b      	ldr	r3, [r7, #4]
 8117d96:	f8b3 3048 	ldrh.w	r3, [r3, #72]	; 0x48
 8117d9a:	429a      	cmp	r2, r3
 8117d9c:	d309      	bcc.n	8117db2 <tcp_receive+0x2c6>
 8117d9e:	687b      	ldr	r3, [r7, #4]
 8117da0:	f8b3 2048 	ldrh.w	r2, [r3, #72]	; 0x48
 8117da4:	8d7b      	ldrh	r3, [r7, #42]	; 0x2a
 8117da6:	4413      	add	r3, r2
 8117da8:	b29a      	uxth	r2, r3
 8117daa:	687b      	ldr	r3, [r7, #4]
 8117dac:	f8a3 2048 	strh.w	r2, [r3, #72]	; 0x48
 8117db0:	e04e      	b.n	8117e50 <tcp_receive+0x364>
 8117db2:	687b      	ldr	r3, [r7, #4]
 8117db4:	f64f 72ff 	movw	r2, #65535	; 0xffff
 8117db8:	f8a3 2048 	strh.w	r2, [r3, #72]	; 0x48
 8117dbc:	e048      	b.n	8117e50 <tcp_receive+0x364>
          LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_receive: slow start cwnd %"TCPWNDSIZE_F"\n", pcb->cwnd));
        } else {
          /* RFC 3465, section 2.1 Congestion Avoidance */
          TCP_WND_INC(pcb->bytes_acked, acked);
 8117dbe:	687b      	ldr	r3, [r7, #4]
 8117dc0:	f8b3 206a 	ldrh.w	r2, [r3, #106]	; 0x6a
 8117dc4:	8dfb      	ldrh	r3, [r7, #46]	; 0x2e
 8117dc6:	4413      	add	r3, r2
 8117dc8:	b29a      	uxth	r2, r3
 8117dca:	687b      	ldr	r3, [r7, #4]
 8117dcc:	f8b3 306a 	ldrh.w	r3, [r3, #106]	; 0x6a
 8117dd0:	429a      	cmp	r2, r3
 8117dd2:	d309      	bcc.n	8117de8 <tcp_receive+0x2fc>
 8117dd4:	687b      	ldr	r3, [r7, #4]
 8117dd6:	f8b3 206a 	ldrh.w	r2, [r3, #106]	; 0x6a
 8117dda:	8dfb      	ldrh	r3, [r7, #46]	; 0x2e
 8117ddc:	4413      	add	r3, r2
 8117dde:	b29a      	uxth	r2, r3
 8117de0:	687b      	ldr	r3, [r7, #4]
 8117de2:	f8a3 206a 	strh.w	r2, [r3, #106]	; 0x6a
 8117de6:	e004      	b.n	8117df2 <tcp_receive+0x306>
 8117de8:	687b      	ldr	r3, [r7, #4]
 8117dea:	f64f 72ff 	movw	r2, #65535	; 0xffff
 8117dee:	f8a3 206a 	strh.w	r2, [r3, #106]	; 0x6a
          if (pcb->bytes_acked >= pcb->cwnd) {
 8117df2:	687b      	ldr	r3, [r7, #4]
 8117df4:	f8b3 206a 	ldrh.w	r2, [r3, #106]	; 0x6a
 8117df8:	687b      	ldr	r3, [r7, #4]
 8117dfa:	f8b3 3048 	ldrh.w	r3, [r3, #72]	; 0x48
 8117dfe:	429a      	cmp	r2, r3
 8117e00:	d326      	bcc.n	8117e50 <tcp_receive+0x364>
            pcb->bytes_acked = (tcpwnd_size_t)(pcb->bytes_acked - pcb->cwnd);
 8117e02:	687b      	ldr	r3, [r7, #4]
 8117e04:	f8b3 206a 	ldrh.w	r2, [r3, #106]	; 0x6a
 8117e08:	687b      	ldr	r3, [r7, #4]
 8117e0a:	f8b3 3048 	ldrh.w	r3, [r3, #72]	; 0x48
 8117e0e:	1ad3      	subs	r3, r2, r3
 8117e10:	b29a      	uxth	r2, r3
 8117e12:	687b      	ldr	r3, [r7, #4]
 8117e14:	f8a3 206a 	strh.w	r2, [r3, #106]	; 0x6a
            TCP_WND_INC(pcb->cwnd, pcb->mss);
 8117e18:	687b      	ldr	r3, [r7, #4]
 8117e1a:	f8b3 2048 	ldrh.w	r2, [r3, #72]	; 0x48
 8117e1e:	687b      	ldr	r3, [r7, #4]
 8117e20:	8e5b      	ldrh	r3, [r3, #50]	; 0x32
 8117e22:	4413      	add	r3, r2
 8117e24:	b29a      	uxth	r2, r3
 8117e26:	687b      	ldr	r3, [r7, #4]
 8117e28:	f8b3 3048 	ldrh.w	r3, [r3, #72]	; 0x48
 8117e2c:	429a      	cmp	r2, r3
 8117e2e:	d30a      	bcc.n	8117e46 <tcp_receive+0x35a>
 8117e30:	687b      	ldr	r3, [r7, #4]
 8117e32:	f8b3 2048 	ldrh.w	r2, [r3, #72]	; 0x48
 8117e36:	687b      	ldr	r3, [r7, #4]
 8117e38:	8e5b      	ldrh	r3, [r3, #50]	; 0x32
 8117e3a:	4413      	add	r3, r2
 8117e3c:	b29a      	uxth	r2, r3
 8117e3e:	687b      	ldr	r3, [r7, #4]
 8117e40:	f8a3 2048 	strh.w	r2, [r3, #72]	; 0x48
 8117e44:	e004      	b.n	8117e50 <tcp_receive+0x364>
 8117e46:	687b      	ldr	r3, [r7, #4]
 8117e48:	f64f 72ff 	movw	r2, #65535	; 0xffff
 8117e4c:	f8a3 2048 	strh.w	r2, [r3, #72]	; 0x48
                                    pcb->unacked != NULL ?
                                    lwip_ntohl(pcb->unacked->tcphdr->seqno) + TCP_TCPLEN(pcb->unacked) : 0));

      /* Remove segment from the unacknowledged list if the incoming
         ACK acknowledges them. */
      pcb->unacked = tcp_free_acked_segments(pcb, pcb->unacked, "unacked", pcb->unsent);
 8117e50:	687b      	ldr	r3, [r7, #4]
 8117e52:	6f19      	ldr	r1, [r3, #112]	; 0x70
 8117e54:	687b      	ldr	r3, [r7, #4]
 8117e56:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 8117e58:	4a98      	ldr	r2, [pc, #608]	; (81180bc <tcp_receive+0x5d0>)
 8117e5a:	6878      	ldr	r0, [r7, #4]
 8117e5c:	f7ff fdca 	bl	81179f4 <tcp_free_acked_segments>
 8117e60:	4602      	mov	r2, r0
 8117e62:	687b      	ldr	r3, [r7, #4]
 8117e64:	671a      	str	r2, [r3, #112]	; 0x70
         on the list are acknowledged by the ACK. This may seem
         strange since an "unsent" segment shouldn't be acked. The
         rationale is that lwIP puts all outstanding segments on the
         ->unsent list after a retransmission, so these segments may
         in fact have been sent once. */
      pcb->unsent = tcp_free_acked_segments(pcb, pcb->unsent, "unsent", pcb->unacked);
 8117e66:	687b      	ldr	r3, [r7, #4]
 8117e68:	6ed9      	ldr	r1, [r3, #108]	; 0x6c
 8117e6a:	687b      	ldr	r3, [r7, #4]
 8117e6c:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8117e6e:	4a94      	ldr	r2, [pc, #592]	; (81180c0 <tcp_receive+0x5d4>)
 8117e70:	6878      	ldr	r0, [r7, #4]
 8117e72:	f7ff fdbf 	bl	81179f4 <tcp_free_acked_segments>
 8117e76:	4602      	mov	r2, r0
 8117e78:	687b      	ldr	r3, [r7, #4]
 8117e7a:	66da      	str	r2, [r3, #108]	; 0x6c

      /* If there's nothing left to acknowledge, stop the retransmit
         timer, otherwise reset it to start again */
      if (pcb->unacked == NULL) {
 8117e7c:	687b      	ldr	r3, [r7, #4]
 8117e7e:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8117e80:	2b00      	cmp	r3, #0
 8117e82:	d104      	bne.n	8117e8e <tcp_receive+0x3a2>
        pcb->rtime = -1;
 8117e84:	687b      	ldr	r3, [r7, #4]
 8117e86:	f64f 72ff 	movw	r2, #65535	; 0xffff
 8117e8a:	861a      	strh	r2, [r3, #48]	; 0x30
 8117e8c:	e002      	b.n	8117e94 <tcp_receive+0x3a8>
      } else {
        pcb->rtime = 0;
 8117e8e:	687b      	ldr	r3, [r7, #4]
 8117e90:	2200      	movs	r2, #0
 8117e92:	861a      	strh	r2, [r3, #48]	; 0x30
      }

      pcb->polltmr = 0;
 8117e94:	687b      	ldr	r3, [r7, #4]
 8117e96:	2200      	movs	r2, #0
 8117e98:	771a      	strb	r2, [r3, #28]

#if TCP_OVERSIZE
      if (pcb->unsent == NULL) {
 8117e9a:	687b      	ldr	r3, [r7, #4]
 8117e9c:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 8117e9e:	2b00      	cmp	r3, #0
 8117ea0:	d103      	bne.n	8117eaa <tcp_receive+0x3be>
        pcb->unsent_oversize = 0;
 8117ea2:	687b      	ldr	r3, [r7, #4]
 8117ea4:	2200      	movs	r2, #0
 8117ea6:	f8a3 2068 	strh.w	r2, [r3, #104]	; 0x68
        /* Inform neighbor reachability of forward progress. */
        nd6_reachability_hint(ip6_current_src_addr());
      }
#endif /* LWIP_IPV6 && LWIP_ND6_TCP_REACHABILITY_HINTS*/

      pcb->snd_buf = (tcpwnd_size_t)(pcb->snd_buf + recv_acked);
 8117eaa:	687b      	ldr	r3, [r7, #4]
 8117eac:	f8b3 2064 	ldrh.w	r2, [r3, #100]	; 0x64
 8117eb0:	4b84      	ldr	r3, [pc, #528]	; (81180c4 <tcp_receive+0x5d8>)
 8117eb2:	881b      	ldrh	r3, [r3, #0]
 8117eb4:	4413      	add	r3, r2
 8117eb6:	b29a      	uxth	r2, r3
 8117eb8:	687b      	ldr	r3, [r7, #4]
 8117eba:	f8a3 2064 	strh.w	r2, [r3, #100]	; 0x64
      /* check if this ACK ends our retransmission of in-flight data */
      if (pcb->flags & TF_RTO) {
 8117ebe:	687b      	ldr	r3, [r7, #4]
 8117ec0:	8b5b      	ldrh	r3, [r3, #26]
 8117ec2:	f403 6300 	and.w	r3, r3, #2048	; 0x800
 8117ec6:	2b00      	cmp	r3, #0
 8117ec8:	d035      	beq.n	8117f36 <tcp_receive+0x44a>
        /* RTO is done if
            1) both queues are empty or
            2) unacked is empty and unsent head contains data not part of RTO or
            3) unacked head contains data not part of RTO */
        if (pcb->unacked == NULL) {
 8117eca:	687b      	ldr	r3, [r7, #4]
 8117ecc:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8117ece:	2b00      	cmp	r3, #0
 8117ed0:	d118      	bne.n	8117f04 <tcp_receive+0x418>
          if ((pcb->unsent == NULL) ||
 8117ed2:	687b      	ldr	r3, [r7, #4]
 8117ed4:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 8117ed6:	2b00      	cmp	r3, #0
 8117ed8:	d00c      	beq.n	8117ef4 <tcp_receive+0x408>
              (TCP_SEQ_LEQ(pcb->rto_end, lwip_ntohl(pcb->unsent->tcphdr->seqno)))) {
 8117eda:	687b      	ldr	r3, [r7, #4]
 8117edc:	6cdc      	ldr	r4, [r3, #76]	; 0x4c
 8117ede:	687b      	ldr	r3, [r7, #4]
 8117ee0:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 8117ee2:	68db      	ldr	r3, [r3, #12]
 8117ee4:	685b      	ldr	r3, [r3, #4]
 8117ee6:	4618      	mov	r0, r3
 8117ee8:	f7f6 fae8 	bl	810e4bc <lwip_htonl>
 8117eec:	4603      	mov	r3, r0
 8117eee:	1ae3      	subs	r3, r4, r3
          if ((pcb->unsent == NULL) ||
 8117ef0:	2b00      	cmp	r3, #0
 8117ef2:	dc20      	bgt.n	8117f36 <tcp_receive+0x44a>
            tcp_clear_flags(pcb, TF_RTO);
 8117ef4:	687b      	ldr	r3, [r7, #4]
 8117ef6:	8b5b      	ldrh	r3, [r3, #26]
 8117ef8:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 8117efc:	b29a      	uxth	r2, r3
 8117efe:	687b      	ldr	r3, [r7, #4]
 8117f00:	835a      	strh	r2, [r3, #26]
    } else if (TCP_SEQ_BETWEEN(ackno, pcb->lastack + 1, pcb->snd_nxt)) {
 8117f02:	e018      	b.n	8117f36 <tcp_receive+0x44a>
          }
        } else if (TCP_SEQ_LEQ(pcb->rto_end, lwip_ntohl(pcb->unacked->tcphdr->seqno))) {
 8117f04:	687b      	ldr	r3, [r7, #4]
 8117f06:	6cdc      	ldr	r4, [r3, #76]	; 0x4c
 8117f08:	687b      	ldr	r3, [r7, #4]
 8117f0a:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8117f0c:	68db      	ldr	r3, [r3, #12]
 8117f0e:	685b      	ldr	r3, [r3, #4]
 8117f10:	4618      	mov	r0, r3
 8117f12:	f7f6 fad3 	bl	810e4bc <lwip_htonl>
 8117f16:	4603      	mov	r3, r0
 8117f18:	1ae3      	subs	r3, r4, r3
 8117f1a:	2b00      	cmp	r3, #0
 8117f1c:	dc0b      	bgt.n	8117f36 <tcp_receive+0x44a>
          tcp_clear_flags(pcb, TF_RTO);
 8117f1e:	687b      	ldr	r3, [r7, #4]
 8117f20:	8b5b      	ldrh	r3, [r3, #26]
 8117f22:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 8117f26:	b29a      	uxth	r2, r3
 8117f28:	687b      	ldr	r3, [r7, #4]
 8117f2a:	835a      	strh	r2, [r3, #26]
    } else if (TCP_SEQ_BETWEEN(ackno, pcb->lastack + 1, pcb->snd_nxt)) {
 8117f2c:	e003      	b.n	8117f36 <tcp_receive+0x44a>
        }
      }
      /* End of ACK for new data processing. */
    } else {
      /* Out of sequence ACK, didn't really ack anything */
      tcp_send_empty_ack(pcb);
 8117f2e:	6878      	ldr	r0, [r7, #4]
 8117f30:	f001 ff76 	bl	8119e20 <tcp_send_empty_ack>
 8117f34:	e000      	b.n	8117f38 <tcp_receive+0x44c>
    } else if (TCP_SEQ_BETWEEN(ackno, pcb->lastack + 1, pcb->snd_nxt)) {
 8117f36:	bf00      	nop
                                pcb->rttest, pcb->rtseq, ackno));

    /* RTT estimation calculations. This is done by checking if the
       incoming segment acknowledges the segment we use to take a
       round-trip time measurement. */
    if (pcb->rttest && TCP_SEQ_LT(pcb->rtseq, ackno)) {
 8117f38:	687b      	ldr	r3, [r7, #4]
 8117f3a:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8117f3c:	2b00      	cmp	r3, #0
 8117f3e:	d05b      	beq.n	8117ff8 <tcp_receive+0x50c>
 8117f40:	687b      	ldr	r3, [r7, #4]
 8117f42:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 8117f44:	4b60      	ldr	r3, [pc, #384]	; (81180c8 <tcp_receive+0x5dc>)
 8117f46:	681b      	ldr	r3, [r3, #0]
 8117f48:	1ad3      	subs	r3, r2, r3
 8117f4a:	2b00      	cmp	r3, #0
 8117f4c:	da54      	bge.n	8117ff8 <tcp_receive+0x50c>
      /* diff between this shouldn't exceed 32K since this are tcp timer ticks
         and a round-trip shouldn't be that long... */
      m = (s16_t)(tcp_ticks - pcb->rttest);
 8117f4e:	4b5f      	ldr	r3, [pc, #380]	; (81180cc <tcp_receive+0x5e0>)
 8117f50:	681b      	ldr	r3, [r3, #0]
 8117f52:	b29a      	uxth	r2, r3
 8117f54:	687b      	ldr	r3, [r7, #4]
 8117f56:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8117f58:	b29b      	uxth	r3, r3
 8117f5a:	1ad3      	subs	r3, r2, r3
 8117f5c:	b29b      	uxth	r3, r3
 8117f5e:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e

      LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_receive: experienced rtt %"U16_F" ticks (%"U16_F" msec).\n",
                                  m, (u16_t)(m * TCP_SLOW_INTERVAL)));

      /* This is taken directly from VJs original code in his paper */
      m = (s16_t)(m - (pcb->sa >> 3));
 8117f62:	f8b7 204e 	ldrh.w	r2, [r7, #78]	; 0x4e
 8117f66:	687b      	ldr	r3, [r7, #4]
 8117f68:	f9b3 303c 	ldrsh.w	r3, [r3, #60]	; 0x3c
 8117f6c:	10db      	asrs	r3, r3, #3
 8117f6e:	b21b      	sxth	r3, r3
 8117f70:	b29b      	uxth	r3, r3
 8117f72:	1ad3      	subs	r3, r2, r3
 8117f74:	b29b      	uxth	r3, r3
 8117f76:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e
      pcb->sa = (s16_t)(pcb->sa + m);
 8117f7a:	687b      	ldr	r3, [r7, #4]
 8117f7c:	f9b3 303c 	ldrsh.w	r3, [r3, #60]	; 0x3c
 8117f80:	b29a      	uxth	r2, r3
 8117f82:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
 8117f86:	4413      	add	r3, r2
 8117f88:	b29b      	uxth	r3, r3
 8117f8a:	b21a      	sxth	r2, r3
 8117f8c:	687b      	ldr	r3, [r7, #4]
 8117f8e:	879a      	strh	r2, [r3, #60]	; 0x3c
      if (m < 0) {
 8117f90:	f9b7 304e 	ldrsh.w	r3, [r7, #78]	; 0x4e
 8117f94:	2b00      	cmp	r3, #0
 8117f96:	da05      	bge.n	8117fa4 <tcp_receive+0x4b8>
        m = (s16_t) - m;
 8117f98:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
 8117f9c:	425b      	negs	r3, r3
 8117f9e:	b29b      	uxth	r3, r3
 8117fa0:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e
      }
      m = (s16_t)(m - (pcb->sv >> 2));
 8117fa4:	f8b7 204e 	ldrh.w	r2, [r7, #78]	; 0x4e
 8117fa8:	687b      	ldr	r3, [r7, #4]
 8117faa:	f9b3 303e 	ldrsh.w	r3, [r3, #62]	; 0x3e
 8117fae:	109b      	asrs	r3, r3, #2
 8117fb0:	b21b      	sxth	r3, r3
 8117fb2:	b29b      	uxth	r3, r3
 8117fb4:	1ad3      	subs	r3, r2, r3
 8117fb6:	b29b      	uxth	r3, r3
 8117fb8:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e
      pcb->sv = (s16_t)(pcb->sv + m);
 8117fbc:	687b      	ldr	r3, [r7, #4]
 8117fbe:	f9b3 303e 	ldrsh.w	r3, [r3, #62]	; 0x3e
 8117fc2:	b29a      	uxth	r2, r3
 8117fc4:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
 8117fc8:	4413      	add	r3, r2
 8117fca:	b29b      	uxth	r3, r3
 8117fcc:	b21a      	sxth	r2, r3
 8117fce:	687b      	ldr	r3, [r7, #4]
 8117fd0:	87da      	strh	r2, [r3, #62]	; 0x3e
      pcb->rto = (s16_t)((pcb->sa >> 3) + pcb->sv);
 8117fd2:	687b      	ldr	r3, [r7, #4]
 8117fd4:	f9b3 303c 	ldrsh.w	r3, [r3, #60]	; 0x3c
 8117fd8:	10db      	asrs	r3, r3, #3
 8117fda:	b21b      	sxth	r3, r3
 8117fdc:	b29a      	uxth	r2, r3
 8117fde:	687b      	ldr	r3, [r7, #4]
 8117fe0:	f9b3 303e 	ldrsh.w	r3, [r3, #62]	; 0x3e
 8117fe4:	b29b      	uxth	r3, r3
 8117fe6:	4413      	add	r3, r2
 8117fe8:	b29b      	uxth	r3, r3
 8117fea:	b21a      	sxth	r2, r3
 8117fec:	687b      	ldr	r3, [r7, #4]
 8117fee:	f8a3 2040 	strh.w	r2, [r3, #64]	; 0x40

      LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_receive: RTO %"U16_F" (%"U16_F" milliseconds)\n",
                                  pcb->rto, (u16_t)(pcb->rto * TCP_SLOW_INTERVAL)));

      pcb->rttest = 0;
 8117ff2:	687b      	ldr	r3, [r7, #4]
 8117ff4:	2200      	movs	r2, #0
 8117ff6:	635a      	str	r2, [r3, #52]	; 0x34

  /* If the incoming segment contains data, we must process it
     further unless the pcb already received a FIN.
     (RFC 793, chapter 3.9, "SEGMENT ARRIVES" in states CLOSE-WAIT, CLOSING,
     LAST-ACK and TIME-WAIT: "Ignore the segment text.") */
  if ((tcplen > 0) && (pcb->state < CLOSE_WAIT)) {
 8117ff8:	4b35      	ldr	r3, [pc, #212]	; (81180d0 <tcp_receive+0x5e4>)
 8117ffa:	881b      	ldrh	r3, [r3, #0]
 8117ffc:	2b00      	cmp	r3, #0
 8117ffe:	f000 84e2 	beq.w	81189c6 <tcp_receive+0xeda>
 8118002:	687b      	ldr	r3, [r7, #4]
 8118004:	7d1b      	ldrb	r3, [r3, #20]
 8118006:	2b06      	cmp	r3, #6
 8118008:	f200 84dd 	bhi.w	81189c6 <tcp_receive+0xeda>
       this if the sequence number of the incoming segment is less
       than rcv_nxt, and the sequence number plus the length of the
       segment is larger than rcv_nxt. */
    /*    if (TCP_SEQ_LT(seqno, pcb->rcv_nxt)) {
          if (TCP_SEQ_LT(pcb->rcv_nxt, seqno + tcplen)) {*/
    if (TCP_SEQ_BETWEEN(pcb->rcv_nxt, seqno + 1, seqno + tcplen - 1)) {
 811800c:	687b      	ldr	r3, [r7, #4]
 811800e:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8118010:	4b30      	ldr	r3, [pc, #192]	; (81180d4 <tcp_receive+0x5e8>)
 8118012:	681b      	ldr	r3, [r3, #0]
 8118014:	1ad3      	subs	r3, r2, r3
 8118016:	3b01      	subs	r3, #1
 8118018:	2b00      	cmp	r3, #0
 811801a:	f2c0 808f 	blt.w	811813c <tcp_receive+0x650>
 811801e:	687b      	ldr	r3, [r7, #4]
 8118020:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8118022:	4b2b      	ldr	r3, [pc, #172]	; (81180d0 <tcp_receive+0x5e4>)
 8118024:	881b      	ldrh	r3, [r3, #0]
 8118026:	4619      	mov	r1, r3
 8118028:	4b2a      	ldr	r3, [pc, #168]	; (81180d4 <tcp_receive+0x5e8>)
 811802a:	681b      	ldr	r3, [r3, #0]
 811802c:	440b      	add	r3, r1
 811802e:	1ad3      	subs	r3, r2, r3
 8118030:	3301      	adds	r3, #1
 8118032:	2b00      	cmp	r3, #0
 8118034:	f300 8082 	bgt.w	811813c <tcp_receive+0x650>

         After we are done with adjusting the pbuf pointers we must
         adjust the ->data pointer in the seg and the segment
         length.*/

      struct pbuf *p = inseg.p;
 8118038:	4b27      	ldr	r3, [pc, #156]	; (81180d8 <tcp_receive+0x5ec>)
 811803a:	685b      	ldr	r3, [r3, #4]
 811803c:	647b      	str	r3, [r7, #68]	; 0x44
      u32_t off32 = pcb->rcv_nxt - seqno;
 811803e:	687b      	ldr	r3, [r7, #4]
 8118040:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8118042:	4b24      	ldr	r3, [pc, #144]	; (81180d4 <tcp_receive+0x5e8>)
 8118044:	681b      	ldr	r3, [r3, #0]
 8118046:	1ad3      	subs	r3, r2, r3
 8118048:	627b      	str	r3, [r7, #36]	; 0x24
      u16_t new_tot_len, off;
      LWIP_ASSERT("inseg.p != NULL", inseg.p);
 811804a:	4b23      	ldr	r3, [pc, #140]	; (81180d8 <tcp_receive+0x5ec>)
 811804c:	685b      	ldr	r3, [r3, #4]
 811804e:	2b00      	cmp	r3, #0
 8118050:	d106      	bne.n	8118060 <tcp_receive+0x574>
 8118052:	4b22      	ldr	r3, [pc, #136]	; (81180dc <tcp_receive+0x5f0>)
 8118054:	f240 5294 	movw	r2, #1428	; 0x594
 8118058:	4921      	ldr	r1, [pc, #132]	; (81180e0 <tcp_receive+0x5f4>)
 811805a:	4822      	ldr	r0, [pc, #136]	; (81180e4 <tcp_receive+0x5f8>)
 811805c:	f003 fbd0 	bl	811b800 <iprintf>
      LWIP_ASSERT("insane offset!", (off32 < 0xffff));
 8118060:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8118062:	f64f 72fe 	movw	r2, #65534	; 0xfffe
 8118066:	4293      	cmp	r3, r2
 8118068:	d906      	bls.n	8118078 <tcp_receive+0x58c>
 811806a:	4b1c      	ldr	r3, [pc, #112]	; (81180dc <tcp_receive+0x5f0>)
 811806c:	f240 5295 	movw	r2, #1429	; 0x595
 8118070:	491d      	ldr	r1, [pc, #116]	; (81180e8 <tcp_receive+0x5fc>)
 8118072:	481c      	ldr	r0, [pc, #112]	; (81180e4 <tcp_receive+0x5f8>)
 8118074:	f003 fbc4 	bl	811b800 <iprintf>
      off = (u16_t)off32;
 8118078:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 811807a:	f8a7 3042 	strh.w	r3, [r7, #66]	; 0x42
      LWIP_ASSERT("pbuf too short!", (((s32_t)inseg.p->tot_len) >= off));
 811807e:	4b16      	ldr	r3, [pc, #88]	; (81180d8 <tcp_receive+0x5ec>)
 8118080:	685b      	ldr	r3, [r3, #4]
 8118082:	891b      	ldrh	r3, [r3, #8]
 8118084:	f8b7 2042 	ldrh.w	r2, [r7, #66]	; 0x42
 8118088:	429a      	cmp	r2, r3
 811808a:	d906      	bls.n	811809a <tcp_receive+0x5ae>
 811808c:	4b13      	ldr	r3, [pc, #76]	; (81180dc <tcp_receive+0x5f0>)
 811808e:	f240 5297 	movw	r2, #1431	; 0x597
 8118092:	4916      	ldr	r1, [pc, #88]	; (81180ec <tcp_receive+0x600>)
 8118094:	4813      	ldr	r0, [pc, #76]	; (81180e4 <tcp_receive+0x5f8>)
 8118096:	f003 fbb3 	bl	811b800 <iprintf>
      inseg.len -= off;
 811809a:	4b0f      	ldr	r3, [pc, #60]	; (81180d8 <tcp_receive+0x5ec>)
 811809c:	891a      	ldrh	r2, [r3, #8]
 811809e:	f8b7 3042 	ldrh.w	r3, [r7, #66]	; 0x42
 81180a2:	1ad3      	subs	r3, r2, r3
 81180a4:	b29a      	uxth	r2, r3
 81180a6:	4b0c      	ldr	r3, [pc, #48]	; (81180d8 <tcp_receive+0x5ec>)
 81180a8:	811a      	strh	r2, [r3, #8]
      new_tot_len = (u16_t)(inseg.p->tot_len - off);
 81180aa:	4b0b      	ldr	r3, [pc, #44]	; (81180d8 <tcp_receive+0x5ec>)
 81180ac:	685b      	ldr	r3, [r3, #4]
 81180ae:	891a      	ldrh	r2, [r3, #8]
 81180b0:	f8b7 3042 	ldrh.w	r3, [r7, #66]	; 0x42
 81180b4:	1ad3      	subs	r3, r2, r3
 81180b6:	847b      	strh	r3, [r7, #34]	; 0x22
      while (p->len < off) {
 81180b8:	e02a      	b.n	8118110 <tcp_receive+0x624>
 81180ba:	bf00      	nop
 81180bc:	0811ea80 	.word	0x0811ea80
 81180c0:	0811ea88 	.word	0x0811ea88
 81180c4:	10008488 	.word	0x10008488
 81180c8:	10008484 	.word	0x10008484
 81180cc:	10008448 	.word	0x10008448
 81180d0:	1000848a 	.word	0x1000848a
 81180d4:	10008480 	.word	0x10008480
 81180d8:	10008460 	.word	0x10008460
 81180dc:	0811e6e4 	.word	0x0811e6e4
 81180e0:	0811ea90 	.word	0x0811ea90
 81180e4:	0811e764 	.word	0x0811e764
 81180e8:	0811eaa0 	.word	0x0811eaa0
 81180ec:	0811eab0 	.word	0x0811eab0
        off -= p->len;
 81180f0:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 81180f2:	895b      	ldrh	r3, [r3, #10]
 81180f4:	f8b7 2042 	ldrh.w	r2, [r7, #66]	; 0x42
 81180f8:	1ad3      	subs	r3, r2, r3
 81180fa:	f8a7 3042 	strh.w	r3, [r7, #66]	; 0x42
        /* all pbufs up to and including this one have len==0, so tot_len is equal */
        p->tot_len = new_tot_len;
 81180fe:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8118100:	8c7a      	ldrh	r2, [r7, #34]	; 0x22
 8118102:	811a      	strh	r2, [r3, #8]
        p->len = 0;
 8118104:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8118106:	2200      	movs	r2, #0
 8118108:	815a      	strh	r2, [r3, #10]
        p = p->next;
 811810a:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 811810c:	681b      	ldr	r3, [r3, #0]
 811810e:	647b      	str	r3, [r7, #68]	; 0x44
      while (p->len < off) {
 8118110:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8118112:	895b      	ldrh	r3, [r3, #10]
 8118114:	f8b7 2042 	ldrh.w	r2, [r7, #66]	; 0x42
 8118118:	429a      	cmp	r2, r3
 811811a:	d8e9      	bhi.n	81180f0 <tcp_receive+0x604>
      }
      /* cannot fail... */
      pbuf_remove_header(p, off);
 811811c:	f8b7 3042 	ldrh.w	r3, [r7, #66]	; 0x42
 8118120:	4619      	mov	r1, r3
 8118122:	6c78      	ldr	r0, [r7, #68]	; 0x44
 8118124:	f7fc fa12 	bl	811454c <pbuf_remove_header>
      inseg.tcphdr->seqno = seqno = pcb->rcv_nxt;
 8118128:	687b      	ldr	r3, [r7, #4]
 811812a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 811812c:	4a91      	ldr	r2, [pc, #580]	; (8118374 <tcp_receive+0x888>)
 811812e:	6013      	str	r3, [r2, #0]
 8118130:	4b91      	ldr	r3, [pc, #580]	; (8118378 <tcp_receive+0x88c>)
 8118132:	68db      	ldr	r3, [r3, #12]
 8118134:	4a8f      	ldr	r2, [pc, #572]	; (8118374 <tcp_receive+0x888>)
 8118136:	6812      	ldr	r2, [r2, #0]
 8118138:	605a      	str	r2, [r3, #4]
    if (TCP_SEQ_BETWEEN(pcb->rcv_nxt, seqno + 1, seqno + tcplen - 1)) {
 811813a:	e00d      	b.n	8118158 <tcp_receive+0x66c>
    } else {
      if (TCP_SEQ_LT(seqno, pcb->rcv_nxt)) {
 811813c:	4b8d      	ldr	r3, [pc, #564]	; (8118374 <tcp_receive+0x888>)
 811813e:	681a      	ldr	r2, [r3, #0]
 8118140:	687b      	ldr	r3, [r7, #4]
 8118142:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8118144:	1ad3      	subs	r3, r2, r3
 8118146:	2b00      	cmp	r3, #0
 8118148:	da06      	bge.n	8118158 <tcp_receive+0x66c>
        /* the whole segment is < rcv_nxt */
        /* must be a duplicate of a packet that has already been correctly handled */

        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: duplicate seqno %"U32_F"\n", seqno));
        tcp_ack_now(pcb);
 811814a:	687b      	ldr	r3, [r7, #4]
 811814c:	8b5b      	ldrh	r3, [r3, #26]
 811814e:	f043 0302 	orr.w	r3, r3, #2
 8118152:	b29a      	uxth	r2, r3
 8118154:	687b      	ldr	r3, [r7, #4]
 8118156:	835a      	strh	r2, [r3, #26]
    }

    /* The sequence number must be within the window (above rcv_nxt
       and below rcv_nxt + rcv_wnd) in order to be further
       processed. */
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt,
 8118158:	4b86      	ldr	r3, [pc, #536]	; (8118374 <tcp_receive+0x888>)
 811815a:	681a      	ldr	r2, [r3, #0]
 811815c:	687b      	ldr	r3, [r7, #4]
 811815e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8118160:	1ad3      	subs	r3, r2, r3
 8118162:	2b00      	cmp	r3, #0
 8118164:	f2c0 842a 	blt.w	81189bc <tcp_receive+0xed0>
 8118168:	4b82      	ldr	r3, [pc, #520]	; (8118374 <tcp_receive+0x888>)
 811816a:	681a      	ldr	r2, [r3, #0]
 811816c:	687b      	ldr	r3, [r7, #4]
 811816e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8118170:	6879      	ldr	r1, [r7, #4]
 8118172:	8d09      	ldrh	r1, [r1, #40]	; 0x28
 8118174:	440b      	add	r3, r1
 8118176:	1ad3      	subs	r3, r2, r3
 8118178:	3301      	adds	r3, #1
 811817a:	2b00      	cmp	r3, #0
 811817c:	f300 841e 	bgt.w	81189bc <tcp_receive+0xed0>
                        pcb->rcv_nxt + pcb->rcv_wnd - 1)) {
      if (pcb->rcv_nxt == seqno) {
 8118180:	687b      	ldr	r3, [r7, #4]
 8118182:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8118184:	4b7b      	ldr	r3, [pc, #492]	; (8118374 <tcp_receive+0x888>)
 8118186:	681b      	ldr	r3, [r3, #0]
 8118188:	429a      	cmp	r2, r3
 811818a:	f040 829a 	bne.w	81186c2 <tcp_receive+0xbd6>
        /* The incoming segment is the next in sequence. We check if
           we have to trim the end of the segment and update rcv_nxt
           and pass the data to the application. */
        tcplen = TCP_TCPLEN(&inseg);
 811818e:	4b7a      	ldr	r3, [pc, #488]	; (8118378 <tcp_receive+0x88c>)
 8118190:	891c      	ldrh	r4, [r3, #8]
 8118192:	4b79      	ldr	r3, [pc, #484]	; (8118378 <tcp_receive+0x88c>)
 8118194:	68db      	ldr	r3, [r3, #12]
 8118196:	899b      	ldrh	r3, [r3, #12]
 8118198:	b29b      	uxth	r3, r3
 811819a:	4618      	mov	r0, r3
 811819c:	f7f6 f979 	bl	810e492 <lwip_htons>
 81181a0:	4603      	mov	r3, r0
 81181a2:	b2db      	uxtb	r3, r3
 81181a4:	f003 0303 	and.w	r3, r3, #3
 81181a8:	2b00      	cmp	r3, #0
 81181aa:	d001      	beq.n	81181b0 <tcp_receive+0x6c4>
 81181ac:	2301      	movs	r3, #1
 81181ae:	e000      	b.n	81181b2 <tcp_receive+0x6c6>
 81181b0:	2300      	movs	r3, #0
 81181b2:	4423      	add	r3, r4
 81181b4:	b29a      	uxth	r2, r3
 81181b6:	4b71      	ldr	r3, [pc, #452]	; (811837c <tcp_receive+0x890>)
 81181b8:	801a      	strh	r2, [r3, #0]

        if (tcplen > pcb->rcv_wnd) {
 81181ba:	687b      	ldr	r3, [r7, #4]
 81181bc:	8d1a      	ldrh	r2, [r3, #40]	; 0x28
 81181be:	4b6f      	ldr	r3, [pc, #444]	; (811837c <tcp_receive+0x890>)
 81181c0:	881b      	ldrh	r3, [r3, #0]
 81181c2:	429a      	cmp	r2, r3
 81181c4:	d275      	bcs.n	81182b2 <tcp_receive+0x7c6>
          LWIP_DEBUGF(TCP_INPUT_DEBUG,
                      ("tcp_receive: other end overran receive window"
                       "seqno %"U32_F" len %"U16_F" right edge %"U32_F"\n",
                       seqno, tcplen, pcb->rcv_nxt + pcb->rcv_wnd));
          if (TCPH_FLAGS(inseg.tcphdr) & TCP_FIN) {
 81181c6:	4b6c      	ldr	r3, [pc, #432]	; (8118378 <tcp_receive+0x88c>)
 81181c8:	68db      	ldr	r3, [r3, #12]
 81181ca:	899b      	ldrh	r3, [r3, #12]
 81181cc:	b29b      	uxth	r3, r3
 81181ce:	4618      	mov	r0, r3
 81181d0:	f7f6 f95f 	bl	810e492 <lwip_htons>
 81181d4:	4603      	mov	r3, r0
 81181d6:	b2db      	uxtb	r3, r3
 81181d8:	f003 0301 	and.w	r3, r3, #1
 81181dc:	2b00      	cmp	r3, #0
 81181de:	d01f      	beq.n	8118220 <tcp_receive+0x734>
            /* Must remove the FIN from the header as we're trimming
             * that byte of sequence-space from the packet */
            TCPH_FLAGS_SET(inseg.tcphdr, TCPH_FLAGS(inseg.tcphdr) & ~(unsigned int)TCP_FIN);
 81181e0:	4b65      	ldr	r3, [pc, #404]	; (8118378 <tcp_receive+0x88c>)
 81181e2:	68db      	ldr	r3, [r3, #12]
 81181e4:	899b      	ldrh	r3, [r3, #12]
 81181e6:	b29b      	uxth	r3, r3
 81181e8:	b21b      	sxth	r3, r3
 81181ea:	f423 537c 	bic.w	r3, r3, #16128	; 0x3f00
 81181ee:	b21c      	sxth	r4, r3
 81181f0:	4b61      	ldr	r3, [pc, #388]	; (8118378 <tcp_receive+0x88c>)
 81181f2:	68db      	ldr	r3, [r3, #12]
 81181f4:	899b      	ldrh	r3, [r3, #12]
 81181f6:	b29b      	uxth	r3, r3
 81181f8:	4618      	mov	r0, r3
 81181fa:	f7f6 f94a 	bl	810e492 <lwip_htons>
 81181fe:	4603      	mov	r3, r0
 8118200:	b2db      	uxtb	r3, r3
 8118202:	b29b      	uxth	r3, r3
 8118204:	f003 033e 	and.w	r3, r3, #62	; 0x3e
 8118208:	b29b      	uxth	r3, r3
 811820a:	4618      	mov	r0, r3
 811820c:	f7f6 f941 	bl	810e492 <lwip_htons>
 8118210:	4603      	mov	r3, r0
 8118212:	b21b      	sxth	r3, r3
 8118214:	4323      	orrs	r3, r4
 8118216:	b21a      	sxth	r2, r3
 8118218:	4b57      	ldr	r3, [pc, #348]	; (8118378 <tcp_receive+0x88c>)
 811821a:	68db      	ldr	r3, [r3, #12]
 811821c:	b292      	uxth	r2, r2
 811821e:	819a      	strh	r2, [r3, #12]
          }
          /* Adjust length of segment to fit in the window. */
          TCPWND_CHECK16(pcb->rcv_wnd);
          inseg.len = (u16_t)pcb->rcv_wnd;
 8118220:	687b      	ldr	r3, [r7, #4]
 8118222:	8d1a      	ldrh	r2, [r3, #40]	; 0x28
 8118224:	4b54      	ldr	r3, [pc, #336]	; (8118378 <tcp_receive+0x88c>)
 8118226:	811a      	strh	r2, [r3, #8]
          if (TCPH_FLAGS(inseg.tcphdr) & TCP_SYN) {
 8118228:	4b53      	ldr	r3, [pc, #332]	; (8118378 <tcp_receive+0x88c>)
 811822a:	68db      	ldr	r3, [r3, #12]
 811822c:	899b      	ldrh	r3, [r3, #12]
 811822e:	b29b      	uxth	r3, r3
 8118230:	4618      	mov	r0, r3
 8118232:	f7f6 f92e 	bl	810e492 <lwip_htons>
 8118236:	4603      	mov	r3, r0
 8118238:	b2db      	uxtb	r3, r3
 811823a:	f003 0302 	and.w	r3, r3, #2
 811823e:	2b00      	cmp	r3, #0
 8118240:	d005      	beq.n	811824e <tcp_receive+0x762>
            inseg.len -= 1;
 8118242:	4b4d      	ldr	r3, [pc, #308]	; (8118378 <tcp_receive+0x88c>)
 8118244:	891b      	ldrh	r3, [r3, #8]
 8118246:	3b01      	subs	r3, #1
 8118248:	b29a      	uxth	r2, r3
 811824a:	4b4b      	ldr	r3, [pc, #300]	; (8118378 <tcp_receive+0x88c>)
 811824c:	811a      	strh	r2, [r3, #8]
          }
          pbuf_realloc(inseg.p, inseg.len);
 811824e:	4b4a      	ldr	r3, [pc, #296]	; (8118378 <tcp_receive+0x88c>)
 8118250:	685b      	ldr	r3, [r3, #4]
 8118252:	4a49      	ldr	r2, [pc, #292]	; (8118378 <tcp_receive+0x88c>)
 8118254:	8912      	ldrh	r2, [r2, #8]
 8118256:	4611      	mov	r1, r2
 8118258:	4618      	mov	r0, r3
 811825a:	f7fc f877 	bl	811434c <pbuf_realloc>
          tcplen = TCP_TCPLEN(&inseg);
 811825e:	4b46      	ldr	r3, [pc, #280]	; (8118378 <tcp_receive+0x88c>)
 8118260:	891c      	ldrh	r4, [r3, #8]
 8118262:	4b45      	ldr	r3, [pc, #276]	; (8118378 <tcp_receive+0x88c>)
 8118264:	68db      	ldr	r3, [r3, #12]
 8118266:	899b      	ldrh	r3, [r3, #12]
 8118268:	b29b      	uxth	r3, r3
 811826a:	4618      	mov	r0, r3
 811826c:	f7f6 f911 	bl	810e492 <lwip_htons>
 8118270:	4603      	mov	r3, r0
 8118272:	b2db      	uxtb	r3, r3
 8118274:	f003 0303 	and.w	r3, r3, #3
 8118278:	2b00      	cmp	r3, #0
 811827a:	d001      	beq.n	8118280 <tcp_receive+0x794>
 811827c:	2301      	movs	r3, #1
 811827e:	e000      	b.n	8118282 <tcp_receive+0x796>
 8118280:	2300      	movs	r3, #0
 8118282:	4423      	add	r3, r4
 8118284:	b29a      	uxth	r2, r3
 8118286:	4b3d      	ldr	r3, [pc, #244]	; (811837c <tcp_receive+0x890>)
 8118288:	801a      	strh	r2, [r3, #0]
          LWIP_ASSERT("tcp_receive: segment not trimmed correctly to rcv_wnd\n",
 811828a:	4b3c      	ldr	r3, [pc, #240]	; (811837c <tcp_receive+0x890>)
 811828c:	881b      	ldrh	r3, [r3, #0]
 811828e:	461a      	mov	r2, r3
 8118290:	4b38      	ldr	r3, [pc, #224]	; (8118374 <tcp_receive+0x888>)
 8118292:	681b      	ldr	r3, [r3, #0]
 8118294:	441a      	add	r2, r3
 8118296:	687b      	ldr	r3, [r7, #4]
 8118298:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 811829a:	6879      	ldr	r1, [r7, #4]
 811829c:	8d09      	ldrh	r1, [r1, #40]	; 0x28
 811829e:	440b      	add	r3, r1
 81182a0:	429a      	cmp	r2, r3
 81182a2:	d006      	beq.n	81182b2 <tcp_receive+0x7c6>
 81182a4:	4b36      	ldr	r3, [pc, #216]	; (8118380 <tcp_receive+0x894>)
 81182a6:	f240 52cb 	movw	r2, #1483	; 0x5cb
 81182aa:	4936      	ldr	r1, [pc, #216]	; (8118384 <tcp_receive+0x898>)
 81182ac:	4836      	ldr	r0, [pc, #216]	; (8118388 <tcp_receive+0x89c>)
 81182ae:	f003 faa7 	bl	811b800 <iprintf>
        }
#if TCP_QUEUE_OOSEQ
        /* Received in-sequence data, adjust ooseq data if:
           - FIN has been received or
           - inseq overlaps with ooseq */
        if (pcb->ooseq != NULL) {
 81182b2:	687b      	ldr	r3, [r7, #4]
 81182b4:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 81182b6:	2b00      	cmp	r3, #0
 81182b8:	f000 80e7 	beq.w	811848a <tcp_receive+0x99e>
          if (TCPH_FLAGS(inseg.tcphdr) & TCP_FIN) {
 81182bc:	4b2e      	ldr	r3, [pc, #184]	; (8118378 <tcp_receive+0x88c>)
 81182be:	68db      	ldr	r3, [r3, #12]
 81182c0:	899b      	ldrh	r3, [r3, #12]
 81182c2:	b29b      	uxth	r3, r3
 81182c4:	4618      	mov	r0, r3
 81182c6:	f7f6 f8e4 	bl	810e492 <lwip_htons>
 81182ca:	4603      	mov	r3, r0
 81182cc:	b2db      	uxtb	r3, r3
 81182ce:	f003 0301 	and.w	r3, r3, #1
 81182d2:	2b00      	cmp	r3, #0
 81182d4:	d010      	beq.n	81182f8 <tcp_receive+0x80c>
            LWIP_DEBUGF(TCP_INPUT_DEBUG,
                        ("tcp_receive: received in-order FIN, binning ooseq queue\n"));
            /* Received in-order FIN means anything that was received
             * out of order must now have been received in-order, so
             * bin the ooseq queue */
            while (pcb->ooseq != NULL) {
 81182d6:	e00a      	b.n	81182ee <tcp_receive+0x802>
              struct tcp_seg *old_ooseq = pcb->ooseq;
 81182d8:	687b      	ldr	r3, [r7, #4]
 81182da:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 81182dc:	60fb      	str	r3, [r7, #12]
              pcb->ooseq = pcb->ooseq->next;
 81182de:	687b      	ldr	r3, [r7, #4]
 81182e0:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 81182e2:	681a      	ldr	r2, [r3, #0]
 81182e4:	687b      	ldr	r3, [r7, #4]
 81182e6:	675a      	str	r2, [r3, #116]	; 0x74
              tcp_seg_free(old_ooseq);
 81182e8:	68f8      	ldr	r0, [r7, #12]
 81182ea:	f7fd fd92 	bl	8115e12 <tcp_seg_free>
            while (pcb->ooseq != NULL) {
 81182ee:	687b      	ldr	r3, [r7, #4]
 81182f0:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 81182f2:	2b00      	cmp	r3, #0
 81182f4:	d1f0      	bne.n	81182d8 <tcp_receive+0x7ec>
 81182f6:	e0c8      	b.n	811848a <tcp_receive+0x99e>
            }
          } else {
            struct tcp_seg *next = pcb->ooseq;
 81182f8:	687b      	ldr	r3, [r7, #4]
 81182fa:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 81182fc:	63fb      	str	r3, [r7, #60]	; 0x3c
            /* Remove all segments on ooseq that are covered by inseg already.
             * FIN is copied from ooseq to inseg if present. */
            while (next &&
 81182fe:	e052      	b.n	81183a6 <tcp_receive+0x8ba>
                   TCP_SEQ_GEQ(seqno + tcplen,
                               next->tcphdr->seqno + next->len)) {
              struct tcp_seg *tmp;
              /* inseg cannot have FIN here (already processed above) */
              if ((TCPH_FLAGS(next->tcphdr) & TCP_FIN) != 0 &&
 8118300:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8118302:	68db      	ldr	r3, [r3, #12]
 8118304:	899b      	ldrh	r3, [r3, #12]
 8118306:	b29b      	uxth	r3, r3
 8118308:	4618      	mov	r0, r3
 811830a:	f7f6 f8c2 	bl	810e492 <lwip_htons>
 811830e:	4603      	mov	r3, r0
 8118310:	b2db      	uxtb	r3, r3
 8118312:	f003 0301 	and.w	r3, r3, #1
 8118316:	2b00      	cmp	r3, #0
 8118318:	d03d      	beq.n	8118396 <tcp_receive+0x8aa>
                  (TCPH_FLAGS(inseg.tcphdr) & TCP_SYN) == 0) {
 811831a:	4b17      	ldr	r3, [pc, #92]	; (8118378 <tcp_receive+0x88c>)
 811831c:	68db      	ldr	r3, [r3, #12]
 811831e:	899b      	ldrh	r3, [r3, #12]
 8118320:	b29b      	uxth	r3, r3
 8118322:	4618      	mov	r0, r3
 8118324:	f7f6 f8b5 	bl	810e492 <lwip_htons>
 8118328:	4603      	mov	r3, r0
 811832a:	b2db      	uxtb	r3, r3
 811832c:	f003 0302 	and.w	r3, r3, #2
              if ((TCPH_FLAGS(next->tcphdr) & TCP_FIN) != 0 &&
 8118330:	2b00      	cmp	r3, #0
 8118332:	d130      	bne.n	8118396 <tcp_receive+0x8aa>
                TCPH_SET_FLAG(inseg.tcphdr, TCP_FIN);
 8118334:	4b10      	ldr	r3, [pc, #64]	; (8118378 <tcp_receive+0x88c>)
 8118336:	68db      	ldr	r3, [r3, #12]
 8118338:	899b      	ldrh	r3, [r3, #12]
 811833a:	b29c      	uxth	r4, r3
 811833c:	2001      	movs	r0, #1
 811833e:	f7f6 f8a8 	bl	810e492 <lwip_htons>
 8118342:	4603      	mov	r3, r0
 8118344:	461a      	mov	r2, r3
 8118346:	4b0c      	ldr	r3, [pc, #48]	; (8118378 <tcp_receive+0x88c>)
 8118348:	68db      	ldr	r3, [r3, #12]
 811834a:	4322      	orrs	r2, r4
 811834c:	b292      	uxth	r2, r2
 811834e:	819a      	strh	r2, [r3, #12]
                tcplen = TCP_TCPLEN(&inseg);
 8118350:	4b09      	ldr	r3, [pc, #36]	; (8118378 <tcp_receive+0x88c>)
 8118352:	891c      	ldrh	r4, [r3, #8]
 8118354:	4b08      	ldr	r3, [pc, #32]	; (8118378 <tcp_receive+0x88c>)
 8118356:	68db      	ldr	r3, [r3, #12]
 8118358:	899b      	ldrh	r3, [r3, #12]
 811835a:	b29b      	uxth	r3, r3
 811835c:	4618      	mov	r0, r3
 811835e:	f7f6 f898 	bl	810e492 <lwip_htons>
 8118362:	4603      	mov	r3, r0
 8118364:	b2db      	uxtb	r3, r3
 8118366:	f003 0303 	and.w	r3, r3, #3
 811836a:	2b00      	cmp	r3, #0
 811836c:	d00e      	beq.n	811838c <tcp_receive+0x8a0>
 811836e:	2301      	movs	r3, #1
 8118370:	e00d      	b.n	811838e <tcp_receive+0x8a2>
 8118372:	bf00      	nop
 8118374:	10008480 	.word	0x10008480
 8118378:	10008460 	.word	0x10008460
 811837c:	1000848a 	.word	0x1000848a
 8118380:	0811e6e4 	.word	0x0811e6e4
 8118384:	0811eac0 	.word	0x0811eac0
 8118388:	0811e764 	.word	0x0811e764
 811838c:	2300      	movs	r3, #0
 811838e:	4423      	add	r3, r4
 8118390:	b29a      	uxth	r2, r3
 8118392:	4b98      	ldr	r3, [pc, #608]	; (81185f4 <tcp_receive+0xb08>)
 8118394:	801a      	strh	r2, [r3, #0]
              }
              tmp = next;
 8118396:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8118398:	613b      	str	r3, [r7, #16]
              next = next->next;
 811839a:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 811839c:	681b      	ldr	r3, [r3, #0]
 811839e:	63fb      	str	r3, [r7, #60]	; 0x3c
              tcp_seg_free(tmp);
 81183a0:	6938      	ldr	r0, [r7, #16]
 81183a2:	f7fd fd36 	bl	8115e12 <tcp_seg_free>
            while (next &&
 81183a6:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 81183a8:	2b00      	cmp	r3, #0
 81183aa:	d00e      	beq.n	81183ca <tcp_receive+0x8de>
                   TCP_SEQ_GEQ(seqno + tcplen,
 81183ac:	4b91      	ldr	r3, [pc, #580]	; (81185f4 <tcp_receive+0xb08>)
 81183ae:	881b      	ldrh	r3, [r3, #0]
 81183b0:	461a      	mov	r2, r3
 81183b2:	4b91      	ldr	r3, [pc, #580]	; (81185f8 <tcp_receive+0xb0c>)
 81183b4:	681b      	ldr	r3, [r3, #0]
 81183b6:	441a      	add	r2, r3
 81183b8:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 81183ba:	68db      	ldr	r3, [r3, #12]
 81183bc:	685b      	ldr	r3, [r3, #4]
 81183be:	6bf9      	ldr	r1, [r7, #60]	; 0x3c
 81183c0:	8909      	ldrh	r1, [r1, #8]
 81183c2:	440b      	add	r3, r1
 81183c4:	1ad3      	subs	r3, r2, r3
            while (next &&
 81183c6:	2b00      	cmp	r3, #0
 81183c8:	da9a      	bge.n	8118300 <tcp_receive+0x814>
            }
            /* Now trim right side of inseg if it overlaps with the first
             * segment on ooseq */
            if (next &&
 81183ca:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 81183cc:	2b00      	cmp	r3, #0
 81183ce:	d059      	beq.n	8118484 <tcp_receive+0x998>
                TCP_SEQ_GT(seqno + tcplen,
 81183d0:	4b88      	ldr	r3, [pc, #544]	; (81185f4 <tcp_receive+0xb08>)
 81183d2:	881b      	ldrh	r3, [r3, #0]
 81183d4:	461a      	mov	r2, r3
 81183d6:	4b88      	ldr	r3, [pc, #544]	; (81185f8 <tcp_receive+0xb0c>)
 81183d8:	681b      	ldr	r3, [r3, #0]
 81183da:	441a      	add	r2, r3
 81183dc:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 81183de:	68db      	ldr	r3, [r3, #12]
 81183e0:	685b      	ldr	r3, [r3, #4]
 81183e2:	1ad3      	subs	r3, r2, r3
            if (next &&
 81183e4:	2b00      	cmp	r3, #0
 81183e6:	dd4d      	ble.n	8118484 <tcp_receive+0x998>
                           next->tcphdr->seqno)) {
              /* inseg cannot have FIN here (already processed above) */
              inseg.len = (u16_t)(next->tcphdr->seqno - seqno);
 81183e8:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 81183ea:	68db      	ldr	r3, [r3, #12]
 81183ec:	685b      	ldr	r3, [r3, #4]
 81183ee:	b29a      	uxth	r2, r3
 81183f0:	4b81      	ldr	r3, [pc, #516]	; (81185f8 <tcp_receive+0xb0c>)
 81183f2:	681b      	ldr	r3, [r3, #0]
 81183f4:	b29b      	uxth	r3, r3
 81183f6:	1ad3      	subs	r3, r2, r3
 81183f8:	b29a      	uxth	r2, r3
 81183fa:	4b80      	ldr	r3, [pc, #512]	; (81185fc <tcp_receive+0xb10>)
 81183fc:	811a      	strh	r2, [r3, #8]
              if (TCPH_FLAGS(inseg.tcphdr) & TCP_SYN) {
 81183fe:	4b7f      	ldr	r3, [pc, #508]	; (81185fc <tcp_receive+0xb10>)
 8118400:	68db      	ldr	r3, [r3, #12]
 8118402:	899b      	ldrh	r3, [r3, #12]
 8118404:	b29b      	uxth	r3, r3
 8118406:	4618      	mov	r0, r3
 8118408:	f7f6 f843 	bl	810e492 <lwip_htons>
 811840c:	4603      	mov	r3, r0
 811840e:	b2db      	uxtb	r3, r3
 8118410:	f003 0302 	and.w	r3, r3, #2
 8118414:	2b00      	cmp	r3, #0
 8118416:	d005      	beq.n	8118424 <tcp_receive+0x938>
                inseg.len -= 1;
 8118418:	4b78      	ldr	r3, [pc, #480]	; (81185fc <tcp_receive+0xb10>)
 811841a:	891b      	ldrh	r3, [r3, #8]
 811841c:	3b01      	subs	r3, #1
 811841e:	b29a      	uxth	r2, r3
 8118420:	4b76      	ldr	r3, [pc, #472]	; (81185fc <tcp_receive+0xb10>)
 8118422:	811a      	strh	r2, [r3, #8]
              }
              pbuf_realloc(inseg.p, inseg.len);
 8118424:	4b75      	ldr	r3, [pc, #468]	; (81185fc <tcp_receive+0xb10>)
 8118426:	685b      	ldr	r3, [r3, #4]
 8118428:	4a74      	ldr	r2, [pc, #464]	; (81185fc <tcp_receive+0xb10>)
 811842a:	8912      	ldrh	r2, [r2, #8]
 811842c:	4611      	mov	r1, r2
 811842e:	4618      	mov	r0, r3
 8118430:	f7fb ff8c 	bl	811434c <pbuf_realloc>
              tcplen = TCP_TCPLEN(&inseg);
 8118434:	4b71      	ldr	r3, [pc, #452]	; (81185fc <tcp_receive+0xb10>)
 8118436:	891c      	ldrh	r4, [r3, #8]
 8118438:	4b70      	ldr	r3, [pc, #448]	; (81185fc <tcp_receive+0xb10>)
 811843a:	68db      	ldr	r3, [r3, #12]
 811843c:	899b      	ldrh	r3, [r3, #12]
 811843e:	b29b      	uxth	r3, r3
 8118440:	4618      	mov	r0, r3
 8118442:	f7f6 f826 	bl	810e492 <lwip_htons>
 8118446:	4603      	mov	r3, r0
 8118448:	b2db      	uxtb	r3, r3
 811844a:	f003 0303 	and.w	r3, r3, #3
 811844e:	2b00      	cmp	r3, #0
 8118450:	d001      	beq.n	8118456 <tcp_receive+0x96a>
 8118452:	2301      	movs	r3, #1
 8118454:	e000      	b.n	8118458 <tcp_receive+0x96c>
 8118456:	2300      	movs	r3, #0
 8118458:	4423      	add	r3, r4
 811845a:	b29a      	uxth	r2, r3
 811845c:	4b65      	ldr	r3, [pc, #404]	; (81185f4 <tcp_receive+0xb08>)
 811845e:	801a      	strh	r2, [r3, #0]
              LWIP_ASSERT("tcp_receive: segment not trimmed correctly to ooseq queue\n",
 8118460:	4b64      	ldr	r3, [pc, #400]	; (81185f4 <tcp_receive+0xb08>)
 8118462:	881b      	ldrh	r3, [r3, #0]
 8118464:	461a      	mov	r2, r3
 8118466:	4b64      	ldr	r3, [pc, #400]	; (81185f8 <tcp_receive+0xb0c>)
 8118468:	681b      	ldr	r3, [r3, #0]
 811846a:	441a      	add	r2, r3
 811846c:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 811846e:	68db      	ldr	r3, [r3, #12]
 8118470:	685b      	ldr	r3, [r3, #4]
 8118472:	429a      	cmp	r2, r3
 8118474:	d006      	beq.n	8118484 <tcp_receive+0x998>
 8118476:	4b62      	ldr	r3, [pc, #392]	; (8118600 <tcp_receive+0xb14>)
 8118478:	f240 52fc 	movw	r2, #1532	; 0x5fc
 811847c:	4961      	ldr	r1, [pc, #388]	; (8118604 <tcp_receive+0xb18>)
 811847e:	4862      	ldr	r0, [pc, #392]	; (8118608 <tcp_receive+0xb1c>)
 8118480:	f003 f9be 	bl	811b800 <iprintf>
                          (seqno + tcplen) == next->tcphdr->seqno);
            }
            pcb->ooseq = next;
 8118484:	687b      	ldr	r3, [r7, #4]
 8118486:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 8118488:	675a      	str	r2, [r3, #116]	; 0x74
          }
        }
#endif /* TCP_QUEUE_OOSEQ */

        pcb->rcv_nxt = seqno + tcplen;
 811848a:	4b5a      	ldr	r3, [pc, #360]	; (81185f4 <tcp_receive+0xb08>)
 811848c:	881b      	ldrh	r3, [r3, #0]
 811848e:	461a      	mov	r2, r3
 8118490:	4b59      	ldr	r3, [pc, #356]	; (81185f8 <tcp_receive+0xb0c>)
 8118492:	681b      	ldr	r3, [r3, #0]
 8118494:	441a      	add	r2, r3
 8118496:	687b      	ldr	r3, [r7, #4]
 8118498:	625a      	str	r2, [r3, #36]	; 0x24

        /* Update the receiver's (our) window. */
        LWIP_ASSERT("tcp_receive: tcplen > rcv_wnd\n", pcb->rcv_wnd >= tcplen);
 811849a:	687b      	ldr	r3, [r7, #4]
 811849c:	8d1a      	ldrh	r2, [r3, #40]	; 0x28
 811849e:	4b55      	ldr	r3, [pc, #340]	; (81185f4 <tcp_receive+0xb08>)
 81184a0:	881b      	ldrh	r3, [r3, #0]
 81184a2:	429a      	cmp	r2, r3
 81184a4:	d206      	bcs.n	81184b4 <tcp_receive+0x9c8>
 81184a6:	4b56      	ldr	r3, [pc, #344]	; (8118600 <tcp_receive+0xb14>)
 81184a8:	f240 6207 	movw	r2, #1543	; 0x607
 81184ac:	4957      	ldr	r1, [pc, #348]	; (811860c <tcp_receive+0xb20>)
 81184ae:	4856      	ldr	r0, [pc, #344]	; (8118608 <tcp_receive+0xb1c>)
 81184b0:	f003 f9a6 	bl	811b800 <iprintf>
        pcb->rcv_wnd -= tcplen;
 81184b4:	687b      	ldr	r3, [r7, #4]
 81184b6:	8d1a      	ldrh	r2, [r3, #40]	; 0x28
 81184b8:	4b4e      	ldr	r3, [pc, #312]	; (81185f4 <tcp_receive+0xb08>)
 81184ba:	881b      	ldrh	r3, [r3, #0]
 81184bc:	1ad3      	subs	r3, r2, r3
 81184be:	b29a      	uxth	r2, r3
 81184c0:	687b      	ldr	r3, [r7, #4]
 81184c2:	851a      	strh	r2, [r3, #40]	; 0x28

        tcp_update_rcv_ann_wnd(pcb);
 81184c4:	6878      	ldr	r0, [r7, #4]
 81184c6:	f7fc ffc5 	bl	8115454 <tcp_update_rcv_ann_wnd>
           chains its data on this pbuf as well.

           If the segment was a FIN, we set the TF_GOT_FIN flag that will
           be used to indicate to the application that the remote side has
           closed its end of the connection. */
        if (inseg.p->tot_len > 0) {
 81184ca:	4b4c      	ldr	r3, [pc, #304]	; (81185fc <tcp_receive+0xb10>)
 81184cc:	685b      	ldr	r3, [r3, #4]
 81184ce:	891b      	ldrh	r3, [r3, #8]
 81184d0:	2b00      	cmp	r3, #0
 81184d2:	d006      	beq.n	81184e2 <tcp_receive+0x9f6>
          recv_data = inseg.p;
 81184d4:	4b49      	ldr	r3, [pc, #292]	; (81185fc <tcp_receive+0xb10>)
 81184d6:	685b      	ldr	r3, [r3, #4]
 81184d8:	4a4d      	ldr	r2, [pc, #308]	; (8118610 <tcp_receive+0xb24>)
 81184da:	6013      	str	r3, [r2, #0]
          /* Since this pbuf now is the responsibility of the
             application, we delete our reference to it so that we won't
             (mistakingly) deallocate it. */
          inseg.p = NULL;
 81184dc:	4b47      	ldr	r3, [pc, #284]	; (81185fc <tcp_receive+0xb10>)
 81184de:	2200      	movs	r2, #0
 81184e0:	605a      	str	r2, [r3, #4]
        }
        if (TCPH_FLAGS(inseg.tcphdr) & TCP_FIN) {
 81184e2:	4b46      	ldr	r3, [pc, #280]	; (81185fc <tcp_receive+0xb10>)
 81184e4:	68db      	ldr	r3, [r3, #12]
 81184e6:	899b      	ldrh	r3, [r3, #12]
 81184e8:	b29b      	uxth	r3, r3
 81184ea:	4618      	mov	r0, r3
 81184ec:	f7f5 ffd1 	bl	810e492 <lwip_htons>
 81184f0:	4603      	mov	r3, r0
 81184f2:	b2db      	uxtb	r3, r3
 81184f4:	f003 0301 	and.w	r3, r3, #1
 81184f8:	2b00      	cmp	r3, #0
 81184fa:	f000 80b8 	beq.w	811866e <tcp_receive+0xb82>
          LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: received FIN.\n"));
          recv_flags |= TF_GOT_FIN;
 81184fe:	4b45      	ldr	r3, [pc, #276]	; (8118614 <tcp_receive+0xb28>)
 8118500:	781b      	ldrb	r3, [r3, #0]
 8118502:	f043 0320 	orr.w	r3, r3, #32
 8118506:	b2da      	uxtb	r2, r3
 8118508:	4b42      	ldr	r3, [pc, #264]	; (8118614 <tcp_receive+0xb28>)
 811850a:	701a      	strb	r2, [r3, #0]
        }

#if TCP_QUEUE_OOSEQ
        /* We now check if we have segments on the ->ooseq queue that
           are now in sequence. */
        while (pcb->ooseq != NULL &&
 811850c:	e0af      	b.n	811866e <tcp_receive+0xb82>
               pcb->ooseq->tcphdr->seqno == pcb->rcv_nxt) {

          struct tcp_seg *cseg = pcb->ooseq;
 811850e:	687b      	ldr	r3, [r7, #4]
 8118510:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 8118512:	60bb      	str	r3, [r7, #8]
          seqno = pcb->ooseq->tcphdr->seqno;
 8118514:	687b      	ldr	r3, [r7, #4]
 8118516:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 8118518:	68db      	ldr	r3, [r3, #12]
 811851a:	685b      	ldr	r3, [r3, #4]
 811851c:	4a36      	ldr	r2, [pc, #216]	; (81185f8 <tcp_receive+0xb0c>)
 811851e:	6013      	str	r3, [r2, #0]

          pcb->rcv_nxt += TCP_TCPLEN(cseg);
 8118520:	68bb      	ldr	r3, [r7, #8]
 8118522:	891b      	ldrh	r3, [r3, #8]
 8118524:	461c      	mov	r4, r3
 8118526:	68bb      	ldr	r3, [r7, #8]
 8118528:	68db      	ldr	r3, [r3, #12]
 811852a:	899b      	ldrh	r3, [r3, #12]
 811852c:	b29b      	uxth	r3, r3
 811852e:	4618      	mov	r0, r3
 8118530:	f7f5 ffaf 	bl	810e492 <lwip_htons>
 8118534:	4603      	mov	r3, r0
 8118536:	b2db      	uxtb	r3, r3
 8118538:	f003 0303 	and.w	r3, r3, #3
 811853c:	2b00      	cmp	r3, #0
 811853e:	d001      	beq.n	8118544 <tcp_receive+0xa58>
 8118540:	2301      	movs	r3, #1
 8118542:	e000      	b.n	8118546 <tcp_receive+0xa5a>
 8118544:	2300      	movs	r3, #0
 8118546:	191a      	adds	r2, r3, r4
 8118548:	687b      	ldr	r3, [r7, #4]
 811854a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 811854c:	441a      	add	r2, r3
 811854e:	687b      	ldr	r3, [r7, #4]
 8118550:	625a      	str	r2, [r3, #36]	; 0x24
          LWIP_ASSERT("tcp_receive: ooseq tcplen > rcv_wnd\n",
 8118552:	687b      	ldr	r3, [r7, #4]
 8118554:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
 8118556:	461c      	mov	r4, r3
 8118558:	68bb      	ldr	r3, [r7, #8]
 811855a:	891b      	ldrh	r3, [r3, #8]
 811855c:	461d      	mov	r5, r3
 811855e:	68bb      	ldr	r3, [r7, #8]
 8118560:	68db      	ldr	r3, [r3, #12]
 8118562:	899b      	ldrh	r3, [r3, #12]
 8118564:	b29b      	uxth	r3, r3
 8118566:	4618      	mov	r0, r3
 8118568:	f7f5 ff93 	bl	810e492 <lwip_htons>
 811856c:	4603      	mov	r3, r0
 811856e:	b2db      	uxtb	r3, r3
 8118570:	f003 0303 	and.w	r3, r3, #3
 8118574:	2b00      	cmp	r3, #0
 8118576:	d001      	beq.n	811857c <tcp_receive+0xa90>
 8118578:	2301      	movs	r3, #1
 811857a:	e000      	b.n	811857e <tcp_receive+0xa92>
 811857c:	2300      	movs	r3, #0
 811857e:	442b      	add	r3, r5
 8118580:	429c      	cmp	r4, r3
 8118582:	d206      	bcs.n	8118592 <tcp_receive+0xaa6>
 8118584:	4b1e      	ldr	r3, [pc, #120]	; (8118600 <tcp_receive+0xb14>)
 8118586:	f240 622b 	movw	r2, #1579	; 0x62b
 811858a:	4923      	ldr	r1, [pc, #140]	; (8118618 <tcp_receive+0xb2c>)
 811858c:	481e      	ldr	r0, [pc, #120]	; (8118608 <tcp_receive+0xb1c>)
 811858e:	f003 f937 	bl	811b800 <iprintf>
                      pcb->rcv_wnd >= TCP_TCPLEN(cseg));
          pcb->rcv_wnd -= TCP_TCPLEN(cseg);
 8118592:	68bb      	ldr	r3, [r7, #8]
 8118594:	891b      	ldrh	r3, [r3, #8]
 8118596:	461c      	mov	r4, r3
 8118598:	68bb      	ldr	r3, [r7, #8]
 811859a:	68db      	ldr	r3, [r3, #12]
 811859c:	899b      	ldrh	r3, [r3, #12]
 811859e:	b29b      	uxth	r3, r3
 81185a0:	4618      	mov	r0, r3
 81185a2:	f7f5 ff76 	bl	810e492 <lwip_htons>
 81185a6:	4603      	mov	r3, r0
 81185a8:	b2db      	uxtb	r3, r3
 81185aa:	f003 0303 	and.w	r3, r3, #3
 81185ae:	2b00      	cmp	r3, #0
 81185b0:	d001      	beq.n	81185b6 <tcp_receive+0xaca>
 81185b2:	2301      	movs	r3, #1
 81185b4:	e000      	b.n	81185b8 <tcp_receive+0xacc>
 81185b6:	2300      	movs	r3, #0
 81185b8:	1919      	adds	r1, r3, r4
 81185ba:	687b      	ldr	r3, [r7, #4]
 81185bc:	8d1a      	ldrh	r2, [r3, #40]	; 0x28
 81185be:	b28b      	uxth	r3, r1
 81185c0:	1ad3      	subs	r3, r2, r3
 81185c2:	b29a      	uxth	r2, r3
 81185c4:	687b      	ldr	r3, [r7, #4]
 81185c6:	851a      	strh	r2, [r3, #40]	; 0x28

          tcp_update_rcv_ann_wnd(pcb);
 81185c8:	6878      	ldr	r0, [r7, #4]
 81185ca:	f7fc ff43 	bl	8115454 <tcp_update_rcv_ann_wnd>

          if (cseg->p->tot_len > 0) {
 81185ce:	68bb      	ldr	r3, [r7, #8]
 81185d0:	685b      	ldr	r3, [r3, #4]
 81185d2:	891b      	ldrh	r3, [r3, #8]
 81185d4:	2b00      	cmp	r3, #0
 81185d6:	d028      	beq.n	811862a <tcp_receive+0xb3e>
            /* Chain this pbuf onto the pbuf that we will pass to
               the application. */
            /* With window scaling, this can overflow recv_data->tot_len, but
               that's not a problem since we explicitly fix that before passing
               recv_data to the application. */
            if (recv_data) {
 81185d8:	4b0d      	ldr	r3, [pc, #52]	; (8118610 <tcp_receive+0xb24>)
 81185da:	681b      	ldr	r3, [r3, #0]
 81185dc:	2b00      	cmp	r3, #0
 81185de:	d01d      	beq.n	811861c <tcp_receive+0xb30>
              pbuf_cat(recv_data, cseg->p);
 81185e0:	4b0b      	ldr	r3, [pc, #44]	; (8118610 <tcp_receive+0xb24>)
 81185e2:	681a      	ldr	r2, [r3, #0]
 81185e4:	68bb      	ldr	r3, [r7, #8]
 81185e6:	685b      	ldr	r3, [r3, #4]
 81185e8:	4619      	mov	r1, r3
 81185ea:	4610      	mov	r0, r2
 81185ec:	f7fc f8f6 	bl	81147dc <pbuf_cat>
 81185f0:	e018      	b.n	8118624 <tcp_receive+0xb38>
 81185f2:	bf00      	nop
 81185f4:	1000848a 	.word	0x1000848a
 81185f8:	10008480 	.word	0x10008480
 81185fc:	10008460 	.word	0x10008460
 8118600:	0811e6e4 	.word	0x0811e6e4
 8118604:	0811eaf8 	.word	0x0811eaf8
 8118608:	0811e764 	.word	0x0811e764
 811860c:	0811eb34 	.word	0x0811eb34
 8118610:	10008490 	.word	0x10008490
 8118614:	1000848d 	.word	0x1000848d
 8118618:	0811eb54 	.word	0x0811eb54
            } else {
              recv_data = cseg->p;
 811861c:	68bb      	ldr	r3, [r7, #8]
 811861e:	685b      	ldr	r3, [r3, #4]
 8118620:	4a70      	ldr	r2, [pc, #448]	; (81187e4 <tcp_receive+0xcf8>)
 8118622:	6013      	str	r3, [r2, #0]
            }
            cseg->p = NULL;
 8118624:	68bb      	ldr	r3, [r7, #8]
 8118626:	2200      	movs	r2, #0
 8118628:	605a      	str	r2, [r3, #4]
          }
          if (TCPH_FLAGS(cseg->tcphdr) & TCP_FIN) {
 811862a:	68bb      	ldr	r3, [r7, #8]
 811862c:	68db      	ldr	r3, [r3, #12]
 811862e:	899b      	ldrh	r3, [r3, #12]
 8118630:	b29b      	uxth	r3, r3
 8118632:	4618      	mov	r0, r3
 8118634:	f7f5 ff2d 	bl	810e492 <lwip_htons>
 8118638:	4603      	mov	r3, r0
 811863a:	b2db      	uxtb	r3, r3
 811863c:	f003 0301 	and.w	r3, r3, #1
 8118640:	2b00      	cmp	r3, #0
 8118642:	d00d      	beq.n	8118660 <tcp_receive+0xb74>
            LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: dequeued FIN.\n"));
            recv_flags |= TF_GOT_FIN;
 8118644:	4b68      	ldr	r3, [pc, #416]	; (81187e8 <tcp_receive+0xcfc>)
 8118646:	781b      	ldrb	r3, [r3, #0]
 8118648:	f043 0320 	orr.w	r3, r3, #32
 811864c:	b2da      	uxtb	r2, r3
 811864e:	4b66      	ldr	r3, [pc, #408]	; (81187e8 <tcp_receive+0xcfc>)
 8118650:	701a      	strb	r2, [r3, #0]
            if (pcb->state == ESTABLISHED) { /* force passive close or we can move to active close */
 8118652:	687b      	ldr	r3, [r7, #4]
 8118654:	7d1b      	ldrb	r3, [r3, #20]
 8118656:	2b04      	cmp	r3, #4
 8118658:	d102      	bne.n	8118660 <tcp_receive+0xb74>
              pcb->state = CLOSE_WAIT;
 811865a:	687b      	ldr	r3, [r7, #4]
 811865c:	2207      	movs	r2, #7
 811865e:	751a      	strb	r2, [r3, #20]
            }
          }

          pcb->ooseq = cseg->next;
 8118660:	68bb      	ldr	r3, [r7, #8]
 8118662:	681a      	ldr	r2, [r3, #0]
 8118664:	687b      	ldr	r3, [r7, #4]
 8118666:	675a      	str	r2, [r3, #116]	; 0x74
          tcp_seg_free(cseg);
 8118668:	68b8      	ldr	r0, [r7, #8]
 811866a:	f7fd fbd2 	bl	8115e12 <tcp_seg_free>
        while (pcb->ooseq != NULL &&
 811866e:	687b      	ldr	r3, [r7, #4]
 8118670:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 8118672:	2b00      	cmp	r3, #0
 8118674:	d008      	beq.n	8118688 <tcp_receive+0xb9c>
               pcb->ooseq->tcphdr->seqno == pcb->rcv_nxt) {
 8118676:	687b      	ldr	r3, [r7, #4]
 8118678:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 811867a:	68db      	ldr	r3, [r3, #12]
 811867c:	685a      	ldr	r2, [r3, #4]
 811867e:	687b      	ldr	r3, [r7, #4]
 8118680:	6a5b      	ldr	r3, [r3, #36]	; 0x24
        while (pcb->ooseq != NULL &&
 8118682:	429a      	cmp	r2, r3
 8118684:	f43f af43 	beq.w	811850e <tcp_receive+0xa22>
#endif /* LWIP_TCP_SACK_OUT */
#endif /* TCP_QUEUE_OOSEQ */


        /* Acknowledge the segment(s). */
        tcp_ack(pcb);
 8118688:	687b      	ldr	r3, [r7, #4]
 811868a:	8b5b      	ldrh	r3, [r3, #26]
 811868c:	f003 0301 	and.w	r3, r3, #1
 8118690:	2b00      	cmp	r3, #0
 8118692:	d00e      	beq.n	81186b2 <tcp_receive+0xbc6>
 8118694:	687b      	ldr	r3, [r7, #4]
 8118696:	8b5b      	ldrh	r3, [r3, #26]
 8118698:	f023 0301 	bic.w	r3, r3, #1
 811869c:	b29a      	uxth	r2, r3
 811869e:	687b      	ldr	r3, [r7, #4]
 81186a0:	835a      	strh	r2, [r3, #26]
 81186a2:	687b      	ldr	r3, [r7, #4]
 81186a4:	8b5b      	ldrh	r3, [r3, #26]
 81186a6:	f043 0302 	orr.w	r3, r3, #2
 81186aa:	b29a      	uxth	r2, r3
 81186ac:	687b      	ldr	r3, [r7, #4]
 81186ae:	835a      	strh	r2, [r3, #26]
      if (pcb->rcv_nxt == seqno) {
 81186b0:	e188      	b.n	81189c4 <tcp_receive+0xed8>
        tcp_ack(pcb);
 81186b2:	687b      	ldr	r3, [r7, #4]
 81186b4:	8b5b      	ldrh	r3, [r3, #26]
 81186b6:	f043 0301 	orr.w	r3, r3, #1
 81186ba:	b29a      	uxth	r2, r3
 81186bc:	687b      	ldr	r3, [r7, #4]
 81186be:	835a      	strh	r2, [r3, #26]
      if (pcb->rcv_nxt == seqno) {
 81186c0:	e180      	b.n	81189c4 <tcp_receive+0xed8>
      } else {
        /* We get here if the incoming segment is out-of-sequence. */

#if TCP_QUEUE_OOSEQ
        /* We queue the segment on the ->ooseq queue. */
        if (pcb->ooseq == NULL) {
 81186c2:	687b      	ldr	r3, [r7, #4]
 81186c4:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 81186c6:	2b00      	cmp	r3, #0
 81186c8:	d106      	bne.n	81186d8 <tcp_receive+0xbec>
          pcb->ooseq = tcp_seg_copy(&inseg);
 81186ca:	4848      	ldr	r0, [pc, #288]	; (81187ec <tcp_receive+0xd00>)
 81186cc:	f7fd fbba 	bl	8115e44 <tcp_seg_copy>
 81186d0:	4602      	mov	r2, r0
 81186d2:	687b      	ldr	r3, [r7, #4]
 81186d4:	675a      	str	r2, [r3, #116]	; 0x74
 81186d6:	e16d      	b.n	81189b4 <tcp_receive+0xec8>
#if LWIP_TCP_SACK_OUT
          /* This is the left edge of the lowest possible SACK range.
             It may start before the newly received segment (possibly adjusted below). */
          u32_t sackbeg = TCP_SEQ_LT(seqno, pcb->ooseq->tcphdr->seqno) ? seqno : pcb->ooseq->tcphdr->seqno;
#endif /* LWIP_TCP_SACK_OUT */
          struct tcp_seg *next, *prev = NULL;
 81186d8:	2300      	movs	r3, #0
 81186da:	637b      	str	r3, [r7, #52]	; 0x34
          for (next = pcb->ooseq; next != NULL; next = next->next) {
 81186dc:	687b      	ldr	r3, [r7, #4]
 81186de:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 81186e0:	63bb      	str	r3, [r7, #56]	; 0x38
 81186e2:	e157      	b.n	8118994 <tcp_receive+0xea8>
            if (seqno == next->tcphdr->seqno) {
 81186e4:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 81186e6:	68db      	ldr	r3, [r3, #12]
 81186e8:	685a      	ldr	r2, [r3, #4]
 81186ea:	4b41      	ldr	r3, [pc, #260]	; (81187f0 <tcp_receive+0xd04>)
 81186ec:	681b      	ldr	r3, [r3, #0]
 81186ee:	429a      	cmp	r2, r3
 81186f0:	d11d      	bne.n	811872e <tcp_receive+0xc42>
              /* The sequence number of the incoming segment is the
                 same as the sequence number of the segment on
                 ->ooseq. We check the lengths to see which one to
                 discard. */
              if (inseg.len > next->len) {
 81186f2:	4b3e      	ldr	r3, [pc, #248]	; (81187ec <tcp_receive+0xd00>)
 81186f4:	891a      	ldrh	r2, [r3, #8]
 81186f6:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 81186f8:	891b      	ldrh	r3, [r3, #8]
 81186fa:	429a      	cmp	r2, r3
 81186fc:	f240 814f 	bls.w	811899e <tcp_receive+0xeb2>
                /* The incoming segment is larger than the old
                   segment. We replace some segments with the new
                   one. */
                struct tcp_seg *cseg = tcp_seg_copy(&inseg);
 8118700:	483a      	ldr	r0, [pc, #232]	; (81187ec <tcp_receive+0xd00>)
 8118702:	f7fd fb9f 	bl	8115e44 <tcp_seg_copy>
 8118706:	6178      	str	r0, [r7, #20]
                if (cseg != NULL) {
 8118708:	697b      	ldr	r3, [r7, #20]
 811870a:	2b00      	cmp	r3, #0
 811870c:	f000 8149 	beq.w	81189a2 <tcp_receive+0xeb6>
                  if (prev != NULL) {
 8118710:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8118712:	2b00      	cmp	r3, #0
 8118714:	d003      	beq.n	811871e <tcp_receive+0xc32>
                    prev->next = cseg;
 8118716:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8118718:	697a      	ldr	r2, [r7, #20]
 811871a:	601a      	str	r2, [r3, #0]
 811871c:	e002      	b.n	8118724 <tcp_receive+0xc38>
                  } else {
                    pcb->ooseq = cseg;
 811871e:	687b      	ldr	r3, [r7, #4]
 8118720:	697a      	ldr	r2, [r7, #20]
 8118722:	675a      	str	r2, [r3, #116]	; 0x74
                  }
                  tcp_oos_insert_segment(cseg, next);
 8118724:	6bb9      	ldr	r1, [r7, #56]	; 0x38
 8118726:	6978      	ldr	r0, [r7, #20]
 8118728:	f7ff f8dc 	bl	81178e4 <tcp_oos_insert_segment>
                }
                break;
 811872c:	e139      	b.n	81189a2 <tcp_receive+0xeb6>
                   segment was smaller than the old one; in either
                   case, we ditch the incoming segment. */
                break;
              }
            } else {
              if (prev == NULL) {
 811872e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8118730:	2b00      	cmp	r3, #0
 8118732:	d117      	bne.n	8118764 <tcp_receive+0xc78>
                if (TCP_SEQ_LT(seqno, next->tcphdr->seqno)) {
 8118734:	4b2e      	ldr	r3, [pc, #184]	; (81187f0 <tcp_receive+0xd04>)
 8118736:	681a      	ldr	r2, [r3, #0]
 8118738:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 811873a:	68db      	ldr	r3, [r3, #12]
 811873c:	685b      	ldr	r3, [r3, #4]
 811873e:	1ad3      	subs	r3, r2, r3
 8118740:	2b00      	cmp	r3, #0
 8118742:	da57      	bge.n	81187f4 <tcp_receive+0xd08>
                  /* The sequence number of the incoming segment is lower
                     than the sequence number of the first segment on the
                     queue. We put the incoming segment first on the
                     queue. */
                  struct tcp_seg *cseg = tcp_seg_copy(&inseg);
 8118744:	4829      	ldr	r0, [pc, #164]	; (81187ec <tcp_receive+0xd00>)
 8118746:	f7fd fb7d 	bl	8115e44 <tcp_seg_copy>
 811874a:	61b8      	str	r0, [r7, #24]
                  if (cseg != NULL) {
 811874c:	69bb      	ldr	r3, [r7, #24]
 811874e:	2b00      	cmp	r3, #0
 8118750:	f000 8129 	beq.w	81189a6 <tcp_receive+0xeba>
                    pcb->ooseq = cseg;
 8118754:	687b      	ldr	r3, [r7, #4]
 8118756:	69ba      	ldr	r2, [r7, #24]
 8118758:	675a      	str	r2, [r3, #116]	; 0x74
                    tcp_oos_insert_segment(cseg, next);
 811875a:	6bb9      	ldr	r1, [r7, #56]	; 0x38
 811875c:	69b8      	ldr	r0, [r7, #24]
 811875e:	f7ff f8c1 	bl	81178e4 <tcp_oos_insert_segment>
                  }
                  break;
 8118762:	e120      	b.n	81189a6 <tcp_receive+0xeba>
                }
              } else {
                /*if (TCP_SEQ_LT(prev->tcphdr->seqno, seqno) &&
                  TCP_SEQ_LT(seqno, next->tcphdr->seqno)) {*/
                if (TCP_SEQ_BETWEEN(seqno, prev->tcphdr->seqno + 1, next->tcphdr->seqno - 1)) {
 8118764:	4b22      	ldr	r3, [pc, #136]	; (81187f0 <tcp_receive+0xd04>)
 8118766:	681a      	ldr	r2, [r3, #0]
 8118768:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 811876a:	68db      	ldr	r3, [r3, #12]
 811876c:	685b      	ldr	r3, [r3, #4]
 811876e:	1ad3      	subs	r3, r2, r3
 8118770:	3b01      	subs	r3, #1
 8118772:	2b00      	cmp	r3, #0
 8118774:	db3e      	blt.n	81187f4 <tcp_receive+0xd08>
 8118776:	4b1e      	ldr	r3, [pc, #120]	; (81187f0 <tcp_receive+0xd04>)
 8118778:	681a      	ldr	r2, [r3, #0]
 811877a:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 811877c:	68db      	ldr	r3, [r3, #12]
 811877e:	685b      	ldr	r3, [r3, #4]
 8118780:	1ad3      	subs	r3, r2, r3
 8118782:	3301      	adds	r3, #1
 8118784:	2b00      	cmp	r3, #0
 8118786:	dc35      	bgt.n	81187f4 <tcp_receive+0xd08>
                  /* The sequence number of the incoming segment is in
                     between the sequence numbers of the previous and
                     the next segment on ->ooseq. We trim trim the previous
                     segment, delete next segments that included in received segment
                     and trim received, if needed. */
                  struct tcp_seg *cseg = tcp_seg_copy(&inseg);
 8118788:	4818      	ldr	r0, [pc, #96]	; (81187ec <tcp_receive+0xd00>)
 811878a:	f7fd fb5b 	bl	8115e44 <tcp_seg_copy>
 811878e:	61f8      	str	r0, [r7, #28]
                  if (cseg != NULL) {
 8118790:	69fb      	ldr	r3, [r7, #28]
 8118792:	2b00      	cmp	r3, #0
 8118794:	f000 8109 	beq.w	81189aa <tcp_receive+0xebe>
                    if (TCP_SEQ_GT(prev->tcphdr->seqno + prev->len, seqno)) {
 8118798:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 811879a:	68db      	ldr	r3, [r3, #12]
 811879c:	685b      	ldr	r3, [r3, #4]
 811879e:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 81187a0:	8912      	ldrh	r2, [r2, #8]
 81187a2:	441a      	add	r2, r3
 81187a4:	4b12      	ldr	r3, [pc, #72]	; (81187f0 <tcp_receive+0xd04>)
 81187a6:	681b      	ldr	r3, [r3, #0]
 81187a8:	1ad3      	subs	r3, r2, r3
 81187aa:	2b00      	cmp	r3, #0
 81187ac:	dd12      	ble.n	81187d4 <tcp_receive+0xce8>
                      /* We need to trim the prev segment. */
                      prev->len = (u16_t)(seqno - prev->tcphdr->seqno);
 81187ae:	4b10      	ldr	r3, [pc, #64]	; (81187f0 <tcp_receive+0xd04>)
 81187b0:	681b      	ldr	r3, [r3, #0]
 81187b2:	b29a      	uxth	r2, r3
 81187b4:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 81187b6:	68db      	ldr	r3, [r3, #12]
 81187b8:	685b      	ldr	r3, [r3, #4]
 81187ba:	b29b      	uxth	r3, r3
 81187bc:	1ad3      	subs	r3, r2, r3
 81187be:	b29a      	uxth	r2, r3
 81187c0:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 81187c2:	811a      	strh	r2, [r3, #8]
                      pbuf_realloc(prev->p, prev->len);
 81187c4:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 81187c6:	685a      	ldr	r2, [r3, #4]
 81187c8:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 81187ca:	891b      	ldrh	r3, [r3, #8]
 81187cc:	4619      	mov	r1, r3
 81187ce:	4610      	mov	r0, r2
 81187d0:	f7fb fdbc 	bl	811434c <pbuf_realloc>
                    }
                    prev->next = cseg;
 81187d4:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 81187d6:	69fa      	ldr	r2, [r7, #28]
 81187d8:	601a      	str	r2, [r3, #0]
                    tcp_oos_insert_segment(cseg, next);
 81187da:	6bb9      	ldr	r1, [r7, #56]	; 0x38
 81187dc:	69f8      	ldr	r0, [r7, #28]
 81187de:	f7ff f881 	bl	81178e4 <tcp_oos_insert_segment>
                  }
                  break;
 81187e2:	e0e2      	b.n	81189aa <tcp_receive+0xebe>
 81187e4:	10008490 	.word	0x10008490
 81187e8:	1000848d 	.word	0x1000848d
 81187ec:	10008460 	.word	0x10008460
 81187f0:	10008480 	.word	0x10008480
#endif /* LWIP_TCP_SACK_OUT */

              /* We don't use 'prev' below, so let's set it to current 'next'.
                 This way even if we break the loop below, 'prev' will be pointing
                 at the segment right in front of the newly added one. */
              prev = next;
 81187f4:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 81187f6:	637b      	str	r3, [r7, #52]	; 0x34

              /* If the "next" segment is the last segment on the
                 ooseq queue, we add the incoming segment to the end
                 of the list. */
              if (next->next == NULL &&
 81187f8:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 81187fa:	681b      	ldr	r3, [r3, #0]
 81187fc:	2b00      	cmp	r3, #0
 81187fe:	f040 80c6 	bne.w	811898e <tcp_receive+0xea2>
                  TCP_SEQ_GT(seqno, next->tcphdr->seqno)) {
 8118802:	4b80      	ldr	r3, [pc, #512]	; (8118a04 <tcp_receive+0xf18>)
 8118804:	681a      	ldr	r2, [r3, #0]
 8118806:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8118808:	68db      	ldr	r3, [r3, #12]
 811880a:	685b      	ldr	r3, [r3, #4]
 811880c:	1ad3      	subs	r3, r2, r3
              if (next->next == NULL &&
 811880e:	2b00      	cmp	r3, #0
 8118810:	f340 80bd 	ble.w	811898e <tcp_receive+0xea2>
                if (TCPH_FLAGS(next->tcphdr) & TCP_FIN) {
 8118814:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8118816:	68db      	ldr	r3, [r3, #12]
 8118818:	899b      	ldrh	r3, [r3, #12]
 811881a:	b29b      	uxth	r3, r3
 811881c:	4618      	mov	r0, r3
 811881e:	f7f5 fe38 	bl	810e492 <lwip_htons>
 8118822:	4603      	mov	r3, r0
 8118824:	b2db      	uxtb	r3, r3
 8118826:	f003 0301 	and.w	r3, r3, #1
 811882a:	2b00      	cmp	r3, #0
 811882c:	f040 80bf 	bne.w	81189ae <tcp_receive+0xec2>
                  /* segment "next" already contains all data */
                  break;
                }
                next->next = tcp_seg_copy(&inseg);
 8118830:	4875      	ldr	r0, [pc, #468]	; (8118a08 <tcp_receive+0xf1c>)
 8118832:	f7fd fb07 	bl	8115e44 <tcp_seg_copy>
 8118836:	4602      	mov	r2, r0
 8118838:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 811883a:	601a      	str	r2, [r3, #0]
                if (next->next != NULL) {
 811883c:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 811883e:	681b      	ldr	r3, [r3, #0]
 8118840:	2b00      	cmp	r3, #0
 8118842:	f000 80b6 	beq.w	81189b2 <tcp_receive+0xec6>
                  if (TCP_SEQ_GT(next->tcphdr->seqno + next->len, seqno)) {
 8118846:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8118848:	68db      	ldr	r3, [r3, #12]
 811884a:	685b      	ldr	r3, [r3, #4]
 811884c:	6bba      	ldr	r2, [r7, #56]	; 0x38
 811884e:	8912      	ldrh	r2, [r2, #8]
 8118850:	441a      	add	r2, r3
 8118852:	4b6c      	ldr	r3, [pc, #432]	; (8118a04 <tcp_receive+0xf18>)
 8118854:	681b      	ldr	r3, [r3, #0]
 8118856:	1ad3      	subs	r3, r2, r3
 8118858:	2b00      	cmp	r3, #0
 811885a:	dd12      	ble.n	8118882 <tcp_receive+0xd96>
                    /* We need to trim the last segment. */
                    next->len = (u16_t)(seqno - next->tcphdr->seqno);
 811885c:	4b69      	ldr	r3, [pc, #420]	; (8118a04 <tcp_receive+0xf18>)
 811885e:	681b      	ldr	r3, [r3, #0]
 8118860:	b29a      	uxth	r2, r3
 8118862:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8118864:	68db      	ldr	r3, [r3, #12]
 8118866:	685b      	ldr	r3, [r3, #4]
 8118868:	b29b      	uxth	r3, r3
 811886a:	1ad3      	subs	r3, r2, r3
 811886c:	b29a      	uxth	r2, r3
 811886e:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8118870:	811a      	strh	r2, [r3, #8]
                    pbuf_realloc(next->p, next->len);
 8118872:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8118874:	685a      	ldr	r2, [r3, #4]
 8118876:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8118878:	891b      	ldrh	r3, [r3, #8]
 811887a:	4619      	mov	r1, r3
 811887c:	4610      	mov	r0, r2
 811887e:	f7fb fd65 	bl	811434c <pbuf_realloc>
                  }
                  /* check if the remote side overruns our receive window */
                  if (TCP_SEQ_GT((u32_t)tcplen + seqno, pcb->rcv_nxt + (u32_t)pcb->rcv_wnd)) {
 8118882:	4b62      	ldr	r3, [pc, #392]	; (8118a0c <tcp_receive+0xf20>)
 8118884:	881b      	ldrh	r3, [r3, #0]
 8118886:	461a      	mov	r2, r3
 8118888:	4b5e      	ldr	r3, [pc, #376]	; (8118a04 <tcp_receive+0xf18>)
 811888a:	681b      	ldr	r3, [r3, #0]
 811888c:	441a      	add	r2, r3
 811888e:	687b      	ldr	r3, [r7, #4]
 8118890:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8118892:	6879      	ldr	r1, [r7, #4]
 8118894:	8d09      	ldrh	r1, [r1, #40]	; 0x28
 8118896:	440b      	add	r3, r1
 8118898:	1ad3      	subs	r3, r2, r3
 811889a:	2b00      	cmp	r3, #0
 811889c:	f340 8089 	ble.w	81189b2 <tcp_receive+0xec6>
                    LWIP_DEBUGF(TCP_INPUT_DEBUG,
                                ("tcp_receive: other end overran receive window"
                                 "seqno %"U32_F" len %"U16_F" right edge %"U32_F"\n",
                                 seqno, tcplen, pcb->rcv_nxt + pcb->rcv_wnd));
                    if (TCPH_FLAGS(next->next->tcphdr) & TCP_FIN) {
 81188a0:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 81188a2:	681b      	ldr	r3, [r3, #0]
 81188a4:	68db      	ldr	r3, [r3, #12]
 81188a6:	899b      	ldrh	r3, [r3, #12]
 81188a8:	b29b      	uxth	r3, r3
 81188aa:	4618      	mov	r0, r3
 81188ac:	f7f5 fdf1 	bl	810e492 <lwip_htons>
 81188b0:	4603      	mov	r3, r0
 81188b2:	b2db      	uxtb	r3, r3
 81188b4:	f003 0301 	and.w	r3, r3, #1
 81188b8:	2b00      	cmp	r3, #0
 81188ba:	d022      	beq.n	8118902 <tcp_receive+0xe16>
                      /* Must remove the FIN from the header as we're trimming
                       * that byte of sequence-space from the packet */
                      TCPH_FLAGS_SET(next->next->tcphdr, TCPH_FLAGS(next->next->tcphdr) & ~TCP_FIN);
 81188bc:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 81188be:	681b      	ldr	r3, [r3, #0]
 81188c0:	68db      	ldr	r3, [r3, #12]
 81188c2:	899b      	ldrh	r3, [r3, #12]
 81188c4:	b29b      	uxth	r3, r3
 81188c6:	b21b      	sxth	r3, r3
 81188c8:	f423 537c 	bic.w	r3, r3, #16128	; 0x3f00
 81188cc:	b21c      	sxth	r4, r3
 81188ce:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 81188d0:	681b      	ldr	r3, [r3, #0]
 81188d2:	68db      	ldr	r3, [r3, #12]
 81188d4:	899b      	ldrh	r3, [r3, #12]
 81188d6:	b29b      	uxth	r3, r3
 81188d8:	4618      	mov	r0, r3
 81188da:	f7f5 fdda 	bl	810e492 <lwip_htons>
 81188de:	4603      	mov	r3, r0
 81188e0:	b2db      	uxtb	r3, r3
 81188e2:	b29b      	uxth	r3, r3
 81188e4:	f003 033e 	and.w	r3, r3, #62	; 0x3e
 81188e8:	b29b      	uxth	r3, r3
 81188ea:	4618      	mov	r0, r3
 81188ec:	f7f5 fdd1 	bl	810e492 <lwip_htons>
 81188f0:	4603      	mov	r3, r0
 81188f2:	b21b      	sxth	r3, r3
 81188f4:	4323      	orrs	r3, r4
 81188f6:	b21a      	sxth	r2, r3
 81188f8:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 81188fa:	681b      	ldr	r3, [r3, #0]
 81188fc:	68db      	ldr	r3, [r3, #12]
 81188fe:	b292      	uxth	r2, r2
 8118900:	819a      	strh	r2, [r3, #12]
                    }
                    /* Adjust length of segment to fit in the window. */
                    next->next->len = (u16_t)(pcb->rcv_nxt + pcb->rcv_wnd - seqno);
 8118902:	687b      	ldr	r3, [r7, #4]
 8118904:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8118906:	b29a      	uxth	r2, r3
 8118908:	687b      	ldr	r3, [r7, #4]
 811890a:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
 811890c:	4413      	add	r3, r2
 811890e:	b299      	uxth	r1, r3
 8118910:	4b3c      	ldr	r3, [pc, #240]	; (8118a04 <tcp_receive+0xf18>)
 8118912:	681b      	ldr	r3, [r3, #0]
 8118914:	b29a      	uxth	r2, r3
 8118916:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8118918:	681b      	ldr	r3, [r3, #0]
 811891a:	1a8a      	subs	r2, r1, r2
 811891c:	b292      	uxth	r2, r2
 811891e:	811a      	strh	r2, [r3, #8]
                    pbuf_realloc(next->next->p, next->next->len);
 8118920:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8118922:	681b      	ldr	r3, [r3, #0]
 8118924:	685a      	ldr	r2, [r3, #4]
 8118926:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8118928:	681b      	ldr	r3, [r3, #0]
 811892a:	891b      	ldrh	r3, [r3, #8]
 811892c:	4619      	mov	r1, r3
 811892e:	4610      	mov	r0, r2
 8118930:	f7fb fd0c 	bl	811434c <pbuf_realloc>
                    tcplen = TCP_TCPLEN(next->next);
 8118934:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8118936:	681b      	ldr	r3, [r3, #0]
 8118938:	891c      	ldrh	r4, [r3, #8]
 811893a:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 811893c:	681b      	ldr	r3, [r3, #0]
 811893e:	68db      	ldr	r3, [r3, #12]
 8118940:	899b      	ldrh	r3, [r3, #12]
 8118942:	b29b      	uxth	r3, r3
 8118944:	4618      	mov	r0, r3
 8118946:	f7f5 fda4 	bl	810e492 <lwip_htons>
 811894a:	4603      	mov	r3, r0
 811894c:	b2db      	uxtb	r3, r3
 811894e:	f003 0303 	and.w	r3, r3, #3
 8118952:	2b00      	cmp	r3, #0
 8118954:	d001      	beq.n	811895a <tcp_receive+0xe6e>
 8118956:	2301      	movs	r3, #1
 8118958:	e000      	b.n	811895c <tcp_receive+0xe70>
 811895a:	2300      	movs	r3, #0
 811895c:	4423      	add	r3, r4
 811895e:	b29a      	uxth	r2, r3
 8118960:	4b2a      	ldr	r3, [pc, #168]	; (8118a0c <tcp_receive+0xf20>)
 8118962:	801a      	strh	r2, [r3, #0]
                    LWIP_ASSERT("tcp_receive: segment not trimmed correctly to rcv_wnd\n",
 8118964:	4b29      	ldr	r3, [pc, #164]	; (8118a0c <tcp_receive+0xf20>)
 8118966:	881b      	ldrh	r3, [r3, #0]
 8118968:	461a      	mov	r2, r3
 811896a:	4b26      	ldr	r3, [pc, #152]	; (8118a04 <tcp_receive+0xf18>)
 811896c:	681b      	ldr	r3, [r3, #0]
 811896e:	441a      	add	r2, r3
 8118970:	687b      	ldr	r3, [r7, #4]
 8118972:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8118974:	6879      	ldr	r1, [r7, #4]
 8118976:	8d09      	ldrh	r1, [r1, #40]	; 0x28
 8118978:	440b      	add	r3, r1
 811897a:	429a      	cmp	r2, r3
 811897c:	d019      	beq.n	81189b2 <tcp_receive+0xec6>
 811897e:	4b24      	ldr	r3, [pc, #144]	; (8118a10 <tcp_receive+0xf24>)
 8118980:	f44f 62df 	mov.w	r2, #1784	; 0x6f8
 8118984:	4923      	ldr	r1, [pc, #140]	; (8118a14 <tcp_receive+0xf28>)
 8118986:	4824      	ldr	r0, [pc, #144]	; (8118a18 <tcp_receive+0xf2c>)
 8118988:	f002 ff3a 	bl	811b800 <iprintf>
                                (seqno + tcplen) == (pcb->rcv_nxt + pcb->rcv_wnd));
                  }
                }
                break;
 811898c:	e011      	b.n	81189b2 <tcp_receive+0xec6>
          for (next = pcb->ooseq; next != NULL; next = next->next) {
 811898e:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8118990:	681b      	ldr	r3, [r3, #0]
 8118992:	63bb      	str	r3, [r7, #56]	; 0x38
 8118994:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8118996:	2b00      	cmp	r3, #0
 8118998:	f47f aea4 	bne.w	81186e4 <tcp_receive+0xbf8>
 811899c:	e00a      	b.n	81189b4 <tcp_receive+0xec8>
                break;
 811899e:	bf00      	nop
 81189a0:	e008      	b.n	81189b4 <tcp_receive+0xec8>
                break;
 81189a2:	bf00      	nop
 81189a4:	e006      	b.n	81189b4 <tcp_receive+0xec8>
                  break;
 81189a6:	bf00      	nop
 81189a8:	e004      	b.n	81189b4 <tcp_receive+0xec8>
                  break;
 81189aa:	bf00      	nop
 81189ac:	e002      	b.n	81189b4 <tcp_receive+0xec8>
                  break;
 81189ae:	bf00      	nop
 81189b0:	e000      	b.n	81189b4 <tcp_receive+0xec8>
                break;
 81189b2:	bf00      	nop
#endif /* TCP_OOSEQ_BYTES_LIMIT || TCP_OOSEQ_PBUFS_LIMIT */
#endif /* TCP_QUEUE_OOSEQ */

        /* We send the ACK packet after we've (potentially) dealt with SACKs,
           so they can be included in the acknowledgment. */
        tcp_send_empty_ack(pcb);
 81189b4:	6878      	ldr	r0, [r7, #4]
 81189b6:	f001 fa33 	bl	8119e20 <tcp_send_empty_ack>
      if (pcb->rcv_nxt == seqno) {
 81189ba:	e003      	b.n	81189c4 <tcp_receive+0xed8>
      }
    } else {
      /* The incoming segment is not within the window. */
      tcp_send_empty_ack(pcb);
 81189bc:	6878      	ldr	r0, [r7, #4]
 81189be:	f001 fa2f 	bl	8119e20 <tcp_send_empty_ack>
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt,
 81189c2:	e01a      	b.n	81189fa <tcp_receive+0xf0e>
 81189c4:	e019      	b.n	81189fa <tcp_receive+0xf0e>
    }
  } else {
    /* Segments with length 0 is taken care of here. Segments that
       fall out of the window are ACKed. */
    if (!TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, pcb->rcv_nxt + pcb->rcv_wnd - 1)) {
 81189c6:	4b0f      	ldr	r3, [pc, #60]	; (8118a04 <tcp_receive+0xf18>)
 81189c8:	681a      	ldr	r2, [r3, #0]
 81189ca:	687b      	ldr	r3, [r7, #4]
 81189cc:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 81189ce:	1ad3      	subs	r3, r2, r3
 81189d0:	2b00      	cmp	r3, #0
 81189d2:	db0a      	blt.n	81189ea <tcp_receive+0xefe>
 81189d4:	4b0b      	ldr	r3, [pc, #44]	; (8118a04 <tcp_receive+0xf18>)
 81189d6:	681a      	ldr	r2, [r3, #0]
 81189d8:	687b      	ldr	r3, [r7, #4]
 81189da:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 81189dc:	6879      	ldr	r1, [r7, #4]
 81189de:	8d09      	ldrh	r1, [r1, #40]	; 0x28
 81189e0:	440b      	add	r3, r1
 81189e2:	1ad3      	subs	r3, r2, r3
 81189e4:	3301      	adds	r3, #1
 81189e6:	2b00      	cmp	r3, #0
 81189e8:	dd07      	ble.n	81189fa <tcp_receive+0xf0e>
      tcp_ack_now(pcb);
 81189ea:	687b      	ldr	r3, [r7, #4]
 81189ec:	8b5b      	ldrh	r3, [r3, #26]
 81189ee:	f043 0302 	orr.w	r3, r3, #2
 81189f2:	b29a      	uxth	r2, r3
 81189f4:	687b      	ldr	r3, [r7, #4]
 81189f6:	835a      	strh	r2, [r3, #26]
    }
  }
}
 81189f8:	e7ff      	b.n	81189fa <tcp_receive+0xf0e>
 81189fa:	bf00      	nop
 81189fc:	3750      	adds	r7, #80	; 0x50
 81189fe:	46bd      	mov	sp, r7
 8118a00:	bdb0      	pop	{r4, r5, r7, pc}
 8118a02:	bf00      	nop
 8118a04:	10008480 	.word	0x10008480
 8118a08:	10008460 	.word	0x10008460
 8118a0c:	1000848a 	.word	0x1000848a
 8118a10:	0811e6e4 	.word	0x0811e6e4
 8118a14:	0811eac0 	.word	0x0811eac0
 8118a18:	0811e764 	.word	0x0811e764

08118a1c <tcp_get_next_optbyte>:

static u8_t
tcp_get_next_optbyte(void)
{
 8118a1c:	b480      	push	{r7}
 8118a1e:	b083      	sub	sp, #12
 8118a20:	af00      	add	r7, sp, #0
  u16_t optidx = tcp_optidx++;
 8118a22:	4b15      	ldr	r3, [pc, #84]	; (8118a78 <tcp_get_next_optbyte+0x5c>)
 8118a24:	881b      	ldrh	r3, [r3, #0]
 8118a26:	1c5a      	adds	r2, r3, #1
 8118a28:	b291      	uxth	r1, r2
 8118a2a:	4a13      	ldr	r2, [pc, #76]	; (8118a78 <tcp_get_next_optbyte+0x5c>)
 8118a2c:	8011      	strh	r1, [r2, #0]
 8118a2e:	80fb      	strh	r3, [r7, #6]
  if ((tcphdr_opt2 == NULL) || (optidx < tcphdr_opt1len)) {
 8118a30:	4b12      	ldr	r3, [pc, #72]	; (8118a7c <tcp_get_next_optbyte+0x60>)
 8118a32:	681b      	ldr	r3, [r3, #0]
 8118a34:	2b00      	cmp	r3, #0
 8118a36:	d004      	beq.n	8118a42 <tcp_get_next_optbyte+0x26>
 8118a38:	4b11      	ldr	r3, [pc, #68]	; (8118a80 <tcp_get_next_optbyte+0x64>)
 8118a3a:	881b      	ldrh	r3, [r3, #0]
 8118a3c:	88fa      	ldrh	r2, [r7, #6]
 8118a3e:	429a      	cmp	r2, r3
 8118a40:	d208      	bcs.n	8118a54 <tcp_get_next_optbyte+0x38>
    u8_t *opts = (u8_t *)tcphdr + TCP_HLEN;
 8118a42:	4b10      	ldr	r3, [pc, #64]	; (8118a84 <tcp_get_next_optbyte+0x68>)
 8118a44:	681b      	ldr	r3, [r3, #0]
 8118a46:	3314      	adds	r3, #20
 8118a48:	603b      	str	r3, [r7, #0]
    return opts[optidx];
 8118a4a:	88fb      	ldrh	r3, [r7, #6]
 8118a4c:	683a      	ldr	r2, [r7, #0]
 8118a4e:	4413      	add	r3, r2
 8118a50:	781b      	ldrb	r3, [r3, #0]
 8118a52:	e00b      	b.n	8118a6c <tcp_get_next_optbyte+0x50>
  } else {
    u8_t idx = (u8_t)(optidx - tcphdr_opt1len);
 8118a54:	88fb      	ldrh	r3, [r7, #6]
 8118a56:	b2da      	uxtb	r2, r3
 8118a58:	4b09      	ldr	r3, [pc, #36]	; (8118a80 <tcp_get_next_optbyte+0x64>)
 8118a5a:	881b      	ldrh	r3, [r3, #0]
 8118a5c:	b2db      	uxtb	r3, r3
 8118a5e:	1ad3      	subs	r3, r2, r3
 8118a60:	717b      	strb	r3, [r7, #5]
    return tcphdr_opt2[idx];
 8118a62:	4b06      	ldr	r3, [pc, #24]	; (8118a7c <tcp_get_next_optbyte+0x60>)
 8118a64:	681a      	ldr	r2, [r3, #0]
 8118a66:	797b      	ldrb	r3, [r7, #5]
 8118a68:	4413      	add	r3, r2
 8118a6a:	781b      	ldrb	r3, [r3, #0]
  }
}
 8118a6c:	4618      	mov	r0, r3
 8118a6e:	370c      	adds	r7, #12
 8118a70:	46bd      	mov	sp, r7
 8118a72:	f85d 7b04 	ldr.w	r7, [sp], #4
 8118a76:	4770      	bx	lr
 8118a78:	1000847c 	.word	0x1000847c
 8118a7c:	10008478 	.word	0x10008478
 8118a80:	10008476 	.word	0x10008476
 8118a84:	10008470 	.word	0x10008470

08118a88 <tcp_parseopt>:
 *
 * @param pcb the tcp_pcb for which a segment arrived
 */
static void
tcp_parseopt(struct tcp_pcb *pcb)
{
 8118a88:	b580      	push	{r7, lr}
 8118a8a:	b084      	sub	sp, #16
 8118a8c:	af00      	add	r7, sp, #0
 8118a8e:	6078      	str	r0, [r7, #4]
  u16_t mss;
#if LWIP_TCP_TIMESTAMPS
  u32_t tsval;
#endif

  LWIP_ASSERT("tcp_parseopt: invalid pcb", pcb != NULL);
 8118a90:	687b      	ldr	r3, [r7, #4]
 8118a92:	2b00      	cmp	r3, #0
 8118a94:	d106      	bne.n	8118aa4 <tcp_parseopt+0x1c>
 8118a96:	4b32      	ldr	r3, [pc, #200]	; (8118b60 <tcp_parseopt+0xd8>)
 8118a98:	f240 727d 	movw	r2, #1917	; 0x77d
 8118a9c:	4931      	ldr	r1, [pc, #196]	; (8118b64 <tcp_parseopt+0xdc>)
 8118a9e:	4832      	ldr	r0, [pc, #200]	; (8118b68 <tcp_parseopt+0xe0>)
 8118aa0:	f002 feae 	bl	811b800 <iprintf>

  /* Parse the TCP MSS option, if present. */
  if (tcphdr_optlen != 0) {
 8118aa4:	4b31      	ldr	r3, [pc, #196]	; (8118b6c <tcp_parseopt+0xe4>)
 8118aa6:	881b      	ldrh	r3, [r3, #0]
 8118aa8:	2b00      	cmp	r3, #0
 8118aaa:	d055      	beq.n	8118b58 <tcp_parseopt+0xd0>
    for (tcp_optidx = 0; tcp_optidx < tcphdr_optlen; ) {
 8118aac:	4b30      	ldr	r3, [pc, #192]	; (8118b70 <tcp_parseopt+0xe8>)
 8118aae:	2200      	movs	r2, #0
 8118ab0:	801a      	strh	r2, [r3, #0]
 8118ab2:	e045      	b.n	8118b40 <tcp_parseopt+0xb8>
      u8_t opt = tcp_get_next_optbyte();
 8118ab4:	f7ff ffb2 	bl	8118a1c <tcp_get_next_optbyte>
 8118ab8:	4603      	mov	r3, r0
 8118aba:	73fb      	strb	r3, [r7, #15]
      switch (opt) {
 8118abc:	7bfb      	ldrb	r3, [r7, #15]
 8118abe:	2b02      	cmp	r3, #2
 8118ac0:	d006      	beq.n	8118ad0 <tcp_parseopt+0x48>
 8118ac2:	2b02      	cmp	r3, #2
 8118ac4:	dc2b      	bgt.n	8118b1e <tcp_parseopt+0x96>
 8118ac6:	2b00      	cmp	r3, #0
 8118ac8:	d041      	beq.n	8118b4e <tcp_parseopt+0xc6>
 8118aca:	2b01      	cmp	r3, #1
 8118acc:	d127      	bne.n	8118b1e <tcp_parseopt+0x96>
          LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: EOL\n"));
          return;
        case LWIP_TCP_OPT_NOP:
          /* NOP option. */
          LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: NOP\n"));
          break;
 8118ace:	e037      	b.n	8118b40 <tcp_parseopt+0xb8>
        case LWIP_TCP_OPT_MSS:
          LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: MSS\n"));
          if (tcp_get_next_optbyte() != LWIP_TCP_OPT_LEN_MSS || (tcp_optidx - 2 + LWIP_TCP_OPT_LEN_MSS) > tcphdr_optlen) {
 8118ad0:	f7ff ffa4 	bl	8118a1c <tcp_get_next_optbyte>
 8118ad4:	4603      	mov	r3, r0
 8118ad6:	2b04      	cmp	r3, #4
 8118ad8:	d13b      	bne.n	8118b52 <tcp_parseopt+0xca>
 8118ada:	4b25      	ldr	r3, [pc, #148]	; (8118b70 <tcp_parseopt+0xe8>)
 8118adc:	881b      	ldrh	r3, [r3, #0]
 8118ade:	3301      	adds	r3, #1
 8118ae0:	4a22      	ldr	r2, [pc, #136]	; (8118b6c <tcp_parseopt+0xe4>)
 8118ae2:	8812      	ldrh	r2, [r2, #0]
 8118ae4:	4293      	cmp	r3, r2
 8118ae6:	da34      	bge.n	8118b52 <tcp_parseopt+0xca>
            /* Bad length */
            LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: bad length\n"));
            return;
          }
          /* An MSS option with the right option length. */
          mss = (u16_t)(tcp_get_next_optbyte() << 8);
 8118ae8:	f7ff ff98 	bl	8118a1c <tcp_get_next_optbyte>
 8118aec:	4603      	mov	r3, r0
 8118aee:	b29b      	uxth	r3, r3
 8118af0:	021b      	lsls	r3, r3, #8
 8118af2:	81bb      	strh	r3, [r7, #12]
          mss |= tcp_get_next_optbyte();
 8118af4:	f7ff ff92 	bl	8118a1c <tcp_get_next_optbyte>
 8118af8:	4603      	mov	r3, r0
 8118afa:	b29a      	uxth	r2, r3
 8118afc:	89bb      	ldrh	r3, [r7, #12]
 8118afe:	4313      	orrs	r3, r2
 8118b00:	81bb      	strh	r3, [r7, #12]
          /* Limit the mss to the configured TCP_MSS and prevent division by zero */
          pcb->mss = ((mss > TCP_MSS) || (mss == 0)) ? TCP_MSS : mss;
 8118b02:	89bb      	ldrh	r3, [r7, #12]
 8118b04:	f5b3 7f06 	cmp.w	r3, #536	; 0x218
 8118b08:	d804      	bhi.n	8118b14 <tcp_parseopt+0x8c>
 8118b0a:	89bb      	ldrh	r3, [r7, #12]
 8118b0c:	2b00      	cmp	r3, #0
 8118b0e:	d001      	beq.n	8118b14 <tcp_parseopt+0x8c>
 8118b10:	89ba      	ldrh	r2, [r7, #12]
 8118b12:	e001      	b.n	8118b18 <tcp_parseopt+0x90>
 8118b14:	f44f 7206 	mov.w	r2, #536	; 0x218
 8118b18:	687b      	ldr	r3, [r7, #4]
 8118b1a:	865a      	strh	r2, [r3, #50]	; 0x32
          break;
 8118b1c:	e010      	b.n	8118b40 <tcp_parseopt+0xb8>
          }
          break;
#endif /* LWIP_TCP_SACK_OUT */
        default:
          LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: other\n"));
          data = tcp_get_next_optbyte();
 8118b1e:	f7ff ff7d 	bl	8118a1c <tcp_get_next_optbyte>
 8118b22:	4603      	mov	r3, r0
 8118b24:	72fb      	strb	r3, [r7, #11]
          if (data < 2) {
 8118b26:	7afb      	ldrb	r3, [r7, #11]
 8118b28:	2b01      	cmp	r3, #1
 8118b2a:	d914      	bls.n	8118b56 <tcp_parseopt+0xce>
               and we don't process them further. */
            return;
          }
          /* All other options have a length field, so that we easily
             can skip past them. */
          tcp_optidx += data - 2;
 8118b2c:	7afb      	ldrb	r3, [r7, #11]
 8118b2e:	b29a      	uxth	r2, r3
 8118b30:	4b0f      	ldr	r3, [pc, #60]	; (8118b70 <tcp_parseopt+0xe8>)
 8118b32:	881b      	ldrh	r3, [r3, #0]
 8118b34:	4413      	add	r3, r2
 8118b36:	b29b      	uxth	r3, r3
 8118b38:	3b02      	subs	r3, #2
 8118b3a:	b29a      	uxth	r2, r3
 8118b3c:	4b0c      	ldr	r3, [pc, #48]	; (8118b70 <tcp_parseopt+0xe8>)
 8118b3e:	801a      	strh	r2, [r3, #0]
    for (tcp_optidx = 0; tcp_optidx < tcphdr_optlen; ) {
 8118b40:	4b0b      	ldr	r3, [pc, #44]	; (8118b70 <tcp_parseopt+0xe8>)
 8118b42:	881a      	ldrh	r2, [r3, #0]
 8118b44:	4b09      	ldr	r3, [pc, #36]	; (8118b6c <tcp_parseopt+0xe4>)
 8118b46:	881b      	ldrh	r3, [r3, #0]
 8118b48:	429a      	cmp	r2, r3
 8118b4a:	d3b3      	bcc.n	8118ab4 <tcp_parseopt+0x2c>
 8118b4c:	e004      	b.n	8118b58 <tcp_parseopt+0xd0>
          return;
 8118b4e:	bf00      	nop
 8118b50:	e002      	b.n	8118b58 <tcp_parseopt+0xd0>
            return;
 8118b52:	bf00      	nop
 8118b54:	e000      	b.n	8118b58 <tcp_parseopt+0xd0>
            return;
 8118b56:	bf00      	nop
      }
    }
  }
}
 8118b58:	3710      	adds	r7, #16
 8118b5a:	46bd      	mov	sp, r7
 8118b5c:	bd80      	pop	{r7, pc}
 8118b5e:	bf00      	nop
 8118b60:	0811e6e4 	.word	0x0811e6e4
 8118b64:	0811eb7c 	.word	0x0811eb7c
 8118b68:	0811e764 	.word	0x0811e764
 8118b6c:	10008474 	.word	0x10008474
 8118b70:	1000847c 	.word	0x1000847c

08118b74 <tcp_trigger_input_pcb_close>:

void
tcp_trigger_input_pcb_close(void)
{
 8118b74:	b480      	push	{r7}
 8118b76:	af00      	add	r7, sp, #0
  recv_flags |= TF_CLOSED;
 8118b78:	4b05      	ldr	r3, [pc, #20]	; (8118b90 <tcp_trigger_input_pcb_close+0x1c>)
 8118b7a:	781b      	ldrb	r3, [r3, #0]
 8118b7c:	f043 0310 	orr.w	r3, r3, #16
 8118b80:	b2da      	uxtb	r2, r3
 8118b82:	4b03      	ldr	r3, [pc, #12]	; (8118b90 <tcp_trigger_input_pcb_close+0x1c>)
 8118b84:	701a      	strb	r2, [r3, #0]
}
 8118b86:	bf00      	nop
 8118b88:	46bd      	mov	sp, r7
 8118b8a:	f85d 7b04 	ldr.w	r7, [sp], #4
 8118b8e:	4770      	bx	lr
 8118b90:	1000848d 	.word	0x1000848d

08118b94 <tcp_route>:
static err_t tcp_output_segment(struct tcp_seg *seg, struct tcp_pcb *pcb, struct netif *netif);

/* tcp_route: common code that returns a fixed bound netif or calls ip_route */
static struct netif *
tcp_route(const struct tcp_pcb *pcb, const ip_addr_t *src, const ip_addr_t *dst)
{
 8118b94:	b580      	push	{r7, lr}
 8118b96:	b084      	sub	sp, #16
 8118b98:	af00      	add	r7, sp, #0
 8118b9a:	60f8      	str	r0, [r7, #12]
 8118b9c:	60b9      	str	r1, [r7, #8]
 8118b9e:	607a      	str	r2, [r7, #4]
  LWIP_UNUSED_ARG(src); /* in case IPv4-only and source-based routing is disabled */

  if ((pcb != NULL) && (pcb->netif_idx != NETIF_NO_INDEX)) {
 8118ba0:	68fb      	ldr	r3, [r7, #12]
 8118ba2:	2b00      	cmp	r3, #0
 8118ba4:	d00a      	beq.n	8118bbc <tcp_route+0x28>
 8118ba6:	68fb      	ldr	r3, [r7, #12]
 8118ba8:	7a1b      	ldrb	r3, [r3, #8]
 8118baa:	2b00      	cmp	r3, #0
 8118bac:	d006      	beq.n	8118bbc <tcp_route+0x28>
    return netif_get_by_index(pcb->netif_idx);
 8118bae:	68fb      	ldr	r3, [r7, #12]
 8118bb0:	7a1b      	ldrb	r3, [r3, #8]
 8118bb2:	4618      	mov	r0, r3
 8118bb4:	f7fb fa10 	bl	8113fd8 <netif_get_by_index>
 8118bb8:	4603      	mov	r3, r0
 8118bba:	e003      	b.n	8118bc4 <tcp_route+0x30>
  } else {
    return ip_route(src, dst);
 8118bbc:	6878      	ldr	r0, [r7, #4]
 8118bbe:	f7f9 f915 	bl	8111dec <ip4_route>
 8118bc2:	4603      	mov	r3, r0
  }
}
 8118bc4:	4618      	mov	r0, r3
 8118bc6:	3710      	adds	r7, #16
 8118bc8:	46bd      	mov	sp, r7
 8118bca:	bd80      	pop	{r7, pc}

08118bcc <tcp_create_segment>:
 * The TCP header is filled in except ackno and wnd.
 * p is freed on failure.
 */
static struct tcp_seg *
tcp_create_segment(const struct tcp_pcb *pcb, struct pbuf *p, u8_t hdrflags, u32_t seqno, u8_t optflags)
{
 8118bcc:	b590      	push	{r4, r7, lr}
 8118bce:	b087      	sub	sp, #28
 8118bd0:	af00      	add	r7, sp, #0
 8118bd2:	60f8      	str	r0, [r7, #12]
 8118bd4:	60b9      	str	r1, [r7, #8]
 8118bd6:	603b      	str	r3, [r7, #0]
 8118bd8:	4613      	mov	r3, r2
 8118bda:	71fb      	strb	r3, [r7, #7]
  struct tcp_seg *seg;
  u8_t optlen;

  LWIP_ASSERT("tcp_create_segment: invalid pcb", pcb != NULL);
 8118bdc:	68fb      	ldr	r3, [r7, #12]
 8118bde:	2b00      	cmp	r3, #0
 8118be0:	d105      	bne.n	8118bee <tcp_create_segment+0x22>
 8118be2:	4b44      	ldr	r3, [pc, #272]	; (8118cf4 <tcp_create_segment+0x128>)
 8118be4:	22a3      	movs	r2, #163	; 0xa3
 8118be6:	4944      	ldr	r1, [pc, #272]	; (8118cf8 <tcp_create_segment+0x12c>)
 8118be8:	4844      	ldr	r0, [pc, #272]	; (8118cfc <tcp_create_segment+0x130>)
 8118bea:	f002 fe09 	bl	811b800 <iprintf>
  LWIP_ASSERT("tcp_create_segment: invalid pbuf", p != NULL);
 8118bee:	68bb      	ldr	r3, [r7, #8]
 8118bf0:	2b00      	cmp	r3, #0
 8118bf2:	d105      	bne.n	8118c00 <tcp_create_segment+0x34>
 8118bf4:	4b3f      	ldr	r3, [pc, #252]	; (8118cf4 <tcp_create_segment+0x128>)
 8118bf6:	22a4      	movs	r2, #164	; 0xa4
 8118bf8:	4941      	ldr	r1, [pc, #260]	; (8118d00 <tcp_create_segment+0x134>)
 8118bfa:	4840      	ldr	r0, [pc, #256]	; (8118cfc <tcp_create_segment+0x130>)
 8118bfc:	f002 fe00 	bl	811b800 <iprintf>

  optlen = LWIP_TCP_OPT_LENGTH_SEGMENT(optflags, pcb);
 8118c00:	f897 3028 	ldrb.w	r3, [r7, #40]	; 0x28
 8118c04:	009b      	lsls	r3, r3, #2
 8118c06:	b2db      	uxtb	r3, r3
 8118c08:	f003 0304 	and.w	r3, r3, #4
 8118c0c:	75fb      	strb	r3, [r7, #23]

  if ((seg = (struct tcp_seg *)memp_malloc(MEMP_TCP_SEG)) == NULL) {
 8118c0e:	2003      	movs	r0, #3
 8118c10:	f7fa fe50 	bl	81138b4 <memp_malloc>
 8118c14:	6138      	str	r0, [r7, #16]
 8118c16:	693b      	ldr	r3, [r7, #16]
 8118c18:	2b00      	cmp	r3, #0
 8118c1a:	d104      	bne.n	8118c26 <tcp_create_segment+0x5a>
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("tcp_create_segment: no memory.\n"));
    pbuf_free(p);
 8118c1c:	68b8      	ldr	r0, [r7, #8]
 8118c1e:	f7fb fd1b 	bl	8114658 <pbuf_free>
    return NULL;
 8118c22:	2300      	movs	r3, #0
 8118c24:	e061      	b.n	8118cea <tcp_create_segment+0x11e>
  }
  seg->flags = optflags;
 8118c26:	693b      	ldr	r3, [r7, #16]
 8118c28:	f897 2028 	ldrb.w	r2, [r7, #40]	; 0x28
 8118c2c:	729a      	strb	r2, [r3, #10]
  seg->next = NULL;
 8118c2e:	693b      	ldr	r3, [r7, #16]
 8118c30:	2200      	movs	r2, #0
 8118c32:	601a      	str	r2, [r3, #0]
  seg->p = p;
 8118c34:	693b      	ldr	r3, [r7, #16]
 8118c36:	68ba      	ldr	r2, [r7, #8]
 8118c38:	605a      	str	r2, [r3, #4]
  LWIP_ASSERT("p->tot_len >= optlen", p->tot_len >= optlen);
 8118c3a:	68bb      	ldr	r3, [r7, #8]
 8118c3c:	891a      	ldrh	r2, [r3, #8]
 8118c3e:	7dfb      	ldrb	r3, [r7, #23]
 8118c40:	b29b      	uxth	r3, r3
 8118c42:	429a      	cmp	r2, r3
 8118c44:	d205      	bcs.n	8118c52 <tcp_create_segment+0x86>
 8118c46:	4b2b      	ldr	r3, [pc, #172]	; (8118cf4 <tcp_create_segment+0x128>)
 8118c48:	22b0      	movs	r2, #176	; 0xb0
 8118c4a:	492e      	ldr	r1, [pc, #184]	; (8118d04 <tcp_create_segment+0x138>)
 8118c4c:	482b      	ldr	r0, [pc, #172]	; (8118cfc <tcp_create_segment+0x130>)
 8118c4e:	f002 fdd7 	bl	811b800 <iprintf>
  seg->len = p->tot_len - optlen;
 8118c52:	68bb      	ldr	r3, [r7, #8]
 8118c54:	891a      	ldrh	r2, [r3, #8]
 8118c56:	7dfb      	ldrb	r3, [r7, #23]
 8118c58:	b29b      	uxth	r3, r3
 8118c5a:	1ad3      	subs	r3, r2, r3
 8118c5c:	b29a      	uxth	r2, r3
 8118c5e:	693b      	ldr	r3, [r7, #16]
 8118c60:	811a      	strh	r2, [r3, #8]
  LWIP_ASSERT("invalid optflags passed: TF_SEG_DATA_CHECKSUMMED",
              (optflags & TF_SEG_DATA_CHECKSUMMED) == 0);
#endif /* TCP_CHECKSUM_ON_COPY */

  /* build TCP header */
  if (pbuf_add_header(p, TCP_HLEN)) {
 8118c62:	2114      	movs	r1, #20
 8118c64:	68b8      	ldr	r0, [r7, #8]
 8118c66:	f7fb fc61 	bl	811452c <pbuf_add_header>
 8118c6a:	4603      	mov	r3, r0
 8118c6c:	2b00      	cmp	r3, #0
 8118c6e:	d004      	beq.n	8118c7a <tcp_create_segment+0xae>
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("tcp_create_segment: no room for TCP header in pbuf.\n"));
    TCP_STATS_INC(tcp.err);
    tcp_seg_free(seg);
 8118c70:	6938      	ldr	r0, [r7, #16]
 8118c72:	f7fd f8ce 	bl	8115e12 <tcp_seg_free>
    return NULL;
 8118c76:	2300      	movs	r3, #0
 8118c78:	e037      	b.n	8118cea <tcp_create_segment+0x11e>
  }
  seg->tcphdr = (struct tcp_hdr *)seg->p->payload;
 8118c7a:	693b      	ldr	r3, [r7, #16]
 8118c7c:	685b      	ldr	r3, [r3, #4]
 8118c7e:	685a      	ldr	r2, [r3, #4]
 8118c80:	693b      	ldr	r3, [r7, #16]
 8118c82:	60da      	str	r2, [r3, #12]
  seg->tcphdr->src = lwip_htons(pcb->local_port);
 8118c84:	68fb      	ldr	r3, [r7, #12]
 8118c86:	8ada      	ldrh	r2, [r3, #22]
 8118c88:	693b      	ldr	r3, [r7, #16]
 8118c8a:	68dc      	ldr	r4, [r3, #12]
 8118c8c:	4610      	mov	r0, r2
 8118c8e:	f7f5 fc00 	bl	810e492 <lwip_htons>
 8118c92:	4603      	mov	r3, r0
 8118c94:	8023      	strh	r3, [r4, #0]
  seg->tcphdr->dest = lwip_htons(pcb->remote_port);
 8118c96:	68fb      	ldr	r3, [r7, #12]
 8118c98:	8b1a      	ldrh	r2, [r3, #24]
 8118c9a:	693b      	ldr	r3, [r7, #16]
 8118c9c:	68dc      	ldr	r4, [r3, #12]
 8118c9e:	4610      	mov	r0, r2
 8118ca0:	f7f5 fbf7 	bl	810e492 <lwip_htons>
 8118ca4:	4603      	mov	r3, r0
 8118ca6:	8063      	strh	r3, [r4, #2]
  seg->tcphdr->seqno = lwip_htonl(seqno);
 8118ca8:	693b      	ldr	r3, [r7, #16]
 8118caa:	68dc      	ldr	r4, [r3, #12]
 8118cac:	6838      	ldr	r0, [r7, #0]
 8118cae:	f7f5 fc05 	bl	810e4bc <lwip_htonl>
 8118cb2:	4603      	mov	r3, r0
 8118cb4:	6063      	str	r3, [r4, #4]
  /* ackno is set in tcp_output */
  TCPH_HDRLEN_FLAGS_SET(seg->tcphdr, (5 + optlen / 4), hdrflags);
 8118cb6:	7dfb      	ldrb	r3, [r7, #23]
 8118cb8:	089b      	lsrs	r3, r3, #2
 8118cba:	b2db      	uxtb	r3, r3
 8118cbc:	b29b      	uxth	r3, r3
 8118cbe:	3305      	adds	r3, #5
 8118cc0:	b29b      	uxth	r3, r3
 8118cc2:	031b      	lsls	r3, r3, #12
 8118cc4:	b29a      	uxth	r2, r3
 8118cc6:	79fb      	ldrb	r3, [r7, #7]
 8118cc8:	b29b      	uxth	r3, r3
 8118cca:	4313      	orrs	r3, r2
 8118ccc:	b29a      	uxth	r2, r3
 8118cce:	693b      	ldr	r3, [r7, #16]
 8118cd0:	68dc      	ldr	r4, [r3, #12]
 8118cd2:	4610      	mov	r0, r2
 8118cd4:	f7f5 fbdd 	bl	810e492 <lwip_htons>
 8118cd8:	4603      	mov	r3, r0
 8118cda:	81a3      	strh	r3, [r4, #12]
  /* wnd and chksum are set in tcp_output */
  seg->tcphdr->urgp = 0;
 8118cdc:	693b      	ldr	r3, [r7, #16]
 8118cde:	68db      	ldr	r3, [r3, #12]
 8118ce0:	2200      	movs	r2, #0
 8118ce2:	749a      	strb	r2, [r3, #18]
 8118ce4:	2200      	movs	r2, #0
 8118ce6:	74da      	strb	r2, [r3, #19]
  return seg;
 8118ce8:	693b      	ldr	r3, [r7, #16]
}
 8118cea:	4618      	mov	r0, r3
 8118cec:	371c      	adds	r7, #28
 8118cee:	46bd      	mov	sp, r7
 8118cf0:	bd90      	pop	{r4, r7, pc}
 8118cf2:	bf00      	nop
 8118cf4:	0811eb98 	.word	0x0811eb98
 8118cf8:	0811ec00 	.word	0x0811ec00
 8118cfc:	0811ec20 	.word	0x0811ec20
 8118d00:	0811ec48 	.word	0x0811ec48
 8118d04:	0811ec6c 	.word	0x0811ec6c

08118d08 <tcp_split_unsent_seg>:
 * @param pcb the tcp_pcb for which to split the unsent head
 * @param split the amount of payload to remain in the head
 */
err_t
tcp_split_unsent_seg(struct tcp_pcb *pcb, u16_t split)
{
 8118d08:	b590      	push	{r4, r7, lr}
 8118d0a:	b08b      	sub	sp, #44	; 0x2c
 8118d0c:	af02      	add	r7, sp, #8
 8118d0e:	6078      	str	r0, [r7, #4]
 8118d10:	460b      	mov	r3, r1
 8118d12:	807b      	strh	r3, [r7, #2]
  struct tcp_seg *seg = NULL, *useg = NULL;
 8118d14:	2300      	movs	r3, #0
 8118d16:	61fb      	str	r3, [r7, #28]
 8118d18:	2300      	movs	r3, #0
 8118d1a:	617b      	str	r3, [r7, #20]
  struct pbuf *p = NULL;
 8118d1c:	2300      	movs	r3, #0
 8118d1e:	613b      	str	r3, [r7, #16]
  u16_t chksum = 0;
  u8_t chksum_swapped = 0;
  struct pbuf *q;
#endif /* TCP_CHECKSUM_ON_COPY */

  LWIP_ASSERT("tcp_split_unsent_seg: invalid pcb", pcb != NULL);
 8118d20:	687b      	ldr	r3, [r7, #4]
 8118d22:	2b00      	cmp	r3, #0
 8118d24:	d106      	bne.n	8118d34 <tcp_split_unsent_seg+0x2c>
 8118d26:	4b95      	ldr	r3, [pc, #596]	; (8118f7c <tcp_split_unsent_seg+0x274>)
 8118d28:	f240 324b 	movw	r2, #843	; 0x34b
 8118d2c:	4994      	ldr	r1, [pc, #592]	; (8118f80 <tcp_split_unsent_seg+0x278>)
 8118d2e:	4895      	ldr	r0, [pc, #596]	; (8118f84 <tcp_split_unsent_seg+0x27c>)
 8118d30:	f002 fd66 	bl	811b800 <iprintf>

  useg = pcb->unsent;
 8118d34:	687b      	ldr	r3, [r7, #4]
 8118d36:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 8118d38:	617b      	str	r3, [r7, #20]
  if (useg == NULL) {
 8118d3a:	697b      	ldr	r3, [r7, #20]
 8118d3c:	2b00      	cmp	r3, #0
 8118d3e:	d102      	bne.n	8118d46 <tcp_split_unsent_seg+0x3e>
    return ERR_MEM;
 8118d40:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 8118d44:	e116      	b.n	8118f74 <tcp_split_unsent_seg+0x26c>
  }

  if (split == 0) {
 8118d46:	887b      	ldrh	r3, [r7, #2]
 8118d48:	2b00      	cmp	r3, #0
 8118d4a:	d109      	bne.n	8118d60 <tcp_split_unsent_seg+0x58>
    LWIP_ASSERT("Can't split segment into length 0", 0);
 8118d4c:	4b8b      	ldr	r3, [pc, #556]	; (8118f7c <tcp_split_unsent_seg+0x274>)
 8118d4e:	f240 3253 	movw	r2, #851	; 0x353
 8118d52:	498d      	ldr	r1, [pc, #564]	; (8118f88 <tcp_split_unsent_seg+0x280>)
 8118d54:	488b      	ldr	r0, [pc, #556]	; (8118f84 <tcp_split_unsent_seg+0x27c>)
 8118d56:	f002 fd53 	bl	811b800 <iprintf>
    return ERR_VAL;
 8118d5a:	f06f 0305 	mvn.w	r3, #5
 8118d5e:	e109      	b.n	8118f74 <tcp_split_unsent_seg+0x26c>
  }

  if (useg->len <= split) {
 8118d60:	697b      	ldr	r3, [r7, #20]
 8118d62:	891b      	ldrh	r3, [r3, #8]
 8118d64:	887a      	ldrh	r2, [r7, #2]
 8118d66:	429a      	cmp	r2, r3
 8118d68:	d301      	bcc.n	8118d6e <tcp_split_unsent_seg+0x66>
    return ERR_OK;
 8118d6a:	2300      	movs	r3, #0
 8118d6c:	e102      	b.n	8118f74 <tcp_split_unsent_seg+0x26c>
  }

  LWIP_ASSERT("split <= mss", split <= pcb->mss);
 8118d6e:	687b      	ldr	r3, [r7, #4]
 8118d70:	8e5b      	ldrh	r3, [r3, #50]	; 0x32
 8118d72:	887a      	ldrh	r2, [r7, #2]
 8118d74:	429a      	cmp	r2, r3
 8118d76:	d906      	bls.n	8118d86 <tcp_split_unsent_seg+0x7e>
 8118d78:	4b80      	ldr	r3, [pc, #512]	; (8118f7c <tcp_split_unsent_seg+0x274>)
 8118d7a:	f240 325b 	movw	r2, #859	; 0x35b
 8118d7e:	4983      	ldr	r1, [pc, #524]	; (8118f8c <tcp_split_unsent_seg+0x284>)
 8118d80:	4880      	ldr	r0, [pc, #512]	; (8118f84 <tcp_split_unsent_seg+0x27c>)
 8118d82:	f002 fd3d 	bl	811b800 <iprintf>
  LWIP_ASSERT("useg->len > 0", useg->len > 0);
 8118d86:	697b      	ldr	r3, [r7, #20]
 8118d88:	891b      	ldrh	r3, [r3, #8]
 8118d8a:	2b00      	cmp	r3, #0
 8118d8c:	d106      	bne.n	8118d9c <tcp_split_unsent_seg+0x94>
 8118d8e:	4b7b      	ldr	r3, [pc, #492]	; (8118f7c <tcp_split_unsent_seg+0x274>)
 8118d90:	f44f 7257 	mov.w	r2, #860	; 0x35c
 8118d94:	497e      	ldr	r1, [pc, #504]	; (8118f90 <tcp_split_unsent_seg+0x288>)
 8118d96:	487b      	ldr	r0, [pc, #492]	; (8118f84 <tcp_split_unsent_seg+0x27c>)
 8118d98:	f002 fd32 	bl	811b800 <iprintf>
   * to split this packet so we may actually exceed the max value by
   * one!
   */
  LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_enqueue: split_unsent_seg: %u\n", (unsigned int)pcb->snd_queuelen));

  optflags = useg->flags;
 8118d9c:	697b      	ldr	r3, [r7, #20]
 8118d9e:	7a9b      	ldrb	r3, [r3, #10]
 8118da0:	73fb      	strb	r3, [r7, #15]
#if TCP_CHECKSUM_ON_COPY
  /* Remove since checksum is not stored until after tcp_create_segment() */
  optflags &= ~TF_SEG_DATA_CHECKSUMMED;
#endif /* TCP_CHECKSUM_ON_COPY */
  optlen = LWIP_TCP_OPT_LENGTH(optflags);
 8118da2:	7bfb      	ldrb	r3, [r7, #15]
 8118da4:	009b      	lsls	r3, r3, #2
 8118da6:	b2db      	uxtb	r3, r3
 8118da8:	f003 0304 	and.w	r3, r3, #4
 8118dac:	73bb      	strb	r3, [r7, #14]
  remainder = useg->len - split;
 8118dae:	697b      	ldr	r3, [r7, #20]
 8118db0:	891a      	ldrh	r2, [r3, #8]
 8118db2:	887b      	ldrh	r3, [r7, #2]
 8118db4:	1ad3      	subs	r3, r2, r3
 8118db6:	81bb      	strh	r3, [r7, #12]

  /* Create new pbuf for the remainder of the split */
  p = pbuf_alloc(PBUF_TRANSPORT, remainder + optlen, PBUF_RAM);
 8118db8:	7bbb      	ldrb	r3, [r7, #14]
 8118dba:	b29a      	uxth	r2, r3
 8118dbc:	89bb      	ldrh	r3, [r7, #12]
 8118dbe:	4413      	add	r3, r2
 8118dc0:	b29b      	uxth	r3, r3
 8118dc2:	f44f 7220 	mov.w	r2, #640	; 0x280
 8118dc6:	4619      	mov	r1, r3
 8118dc8:	2036      	movs	r0, #54	; 0x36
 8118dca:	f7fb f961 	bl	8114090 <pbuf_alloc>
 8118dce:	6138      	str	r0, [r7, #16]
  if (p == NULL) {
 8118dd0:	693b      	ldr	r3, [r7, #16]
 8118dd2:	2b00      	cmp	r3, #0
 8118dd4:	f000 80b7 	beq.w	8118f46 <tcp_split_unsent_seg+0x23e>
                ("tcp_split_unsent_seg: could not allocate memory for pbuf remainder %u\n", remainder));
    goto memerr;
  }

  /* Offset into the original pbuf is past TCP/IP headers, options, and split amount */
  offset = useg->p->tot_len - useg->len + split;
 8118dd8:	697b      	ldr	r3, [r7, #20]
 8118dda:	685b      	ldr	r3, [r3, #4]
 8118ddc:	891a      	ldrh	r2, [r3, #8]
 8118dde:	697b      	ldr	r3, [r7, #20]
 8118de0:	891b      	ldrh	r3, [r3, #8]
 8118de2:	1ad3      	subs	r3, r2, r3
 8118de4:	b29a      	uxth	r2, r3
 8118de6:	887b      	ldrh	r3, [r7, #2]
 8118de8:	4413      	add	r3, r2
 8118dea:	817b      	strh	r3, [r7, #10]
  /* Copy remainder into new pbuf, headers and options will not be filled out */
  if (pbuf_copy_partial(useg->p, (u8_t *)p->payload + optlen, remainder, offset ) != remainder) {
 8118dec:	697b      	ldr	r3, [r7, #20]
 8118dee:	6858      	ldr	r0, [r3, #4]
 8118df0:	693b      	ldr	r3, [r7, #16]
 8118df2:	685a      	ldr	r2, [r3, #4]
 8118df4:	7bbb      	ldrb	r3, [r7, #14]
 8118df6:	18d1      	adds	r1, r2, r3
 8118df8:	897b      	ldrh	r3, [r7, #10]
 8118dfa:	89ba      	ldrh	r2, [r7, #12]
 8118dfc:	f7fb fe26 	bl	8114a4c <pbuf_copy_partial>
 8118e00:	4603      	mov	r3, r0
 8118e02:	461a      	mov	r2, r3
 8118e04:	89bb      	ldrh	r3, [r7, #12]
 8118e06:	4293      	cmp	r3, r2
 8118e08:	f040 809f 	bne.w	8118f4a <tcp_split_unsent_seg+0x242>
#endif /* TCP_CHECKSUM_ON_COPY */

  /* Options are created when calling tcp_output() */

  /* Migrate flags from original segment */
  split_flags = TCPH_FLAGS(useg->tcphdr);
 8118e0c:	697b      	ldr	r3, [r7, #20]
 8118e0e:	68db      	ldr	r3, [r3, #12]
 8118e10:	899b      	ldrh	r3, [r3, #12]
 8118e12:	b29b      	uxth	r3, r3
 8118e14:	4618      	mov	r0, r3
 8118e16:	f7f5 fb3c 	bl	810e492 <lwip_htons>
 8118e1a:	4603      	mov	r3, r0
 8118e1c:	b2db      	uxtb	r3, r3
 8118e1e:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 8118e22:	76fb      	strb	r3, [r7, #27]
  remainder_flags = 0; /* ACK added in tcp_output() */
 8118e24:	2300      	movs	r3, #0
 8118e26:	76bb      	strb	r3, [r7, #26]

  if (split_flags & TCP_PSH) {
 8118e28:	7efb      	ldrb	r3, [r7, #27]
 8118e2a:	f003 0308 	and.w	r3, r3, #8
 8118e2e:	2b00      	cmp	r3, #0
 8118e30:	d007      	beq.n	8118e42 <tcp_split_unsent_seg+0x13a>
    split_flags &= ~TCP_PSH;
 8118e32:	7efb      	ldrb	r3, [r7, #27]
 8118e34:	f023 0308 	bic.w	r3, r3, #8
 8118e38:	76fb      	strb	r3, [r7, #27]
    remainder_flags |= TCP_PSH;
 8118e3a:	7ebb      	ldrb	r3, [r7, #26]
 8118e3c:	f043 0308 	orr.w	r3, r3, #8
 8118e40:	76bb      	strb	r3, [r7, #26]
  }
  if (split_flags & TCP_FIN) {
 8118e42:	7efb      	ldrb	r3, [r7, #27]
 8118e44:	f003 0301 	and.w	r3, r3, #1
 8118e48:	2b00      	cmp	r3, #0
 8118e4a:	d007      	beq.n	8118e5c <tcp_split_unsent_seg+0x154>
    split_flags &= ~TCP_FIN;
 8118e4c:	7efb      	ldrb	r3, [r7, #27]
 8118e4e:	f023 0301 	bic.w	r3, r3, #1
 8118e52:	76fb      	strb	r3, [r7, #27]
    remainder_flags |= TCP_FIN;
 8118e54:	7ebb      	ldrb	r3, [r7, #26]
 8118e56:	f043 0301 	orr.w	r3, r3, #1
 8118e5a:	76bb      	strb	r3, [r7, #26]
  }
  /* SYN should be left on split, RST should not be present with data */

  seg = tcp_create_segment(pcb, p, remainder_flags, lwip_ntohl(useg->tcphdr->seqno) + split, optflags);
 8118e5c:	697b      	ldr	r3, [r7, #20]
 8118e5e:	68db      	ldr	r3, [r3, #12]
 8118e60:	685b      	ldr	r3, [r3, #4]
 8118e62:	4618      	mov	r0, r3
 8118e64:	f7f5 fb2a 	bl	810e4bc <lwip_htonl>
 8118e68:	4602      	mov	r2, r0
 8118e6a:	887b      	ldrh	r3, [r7, #2]
 8118e6c:	18d1      	adds	r1, r2, r3
 8118e6e:	7eba      	ldrb	r2, [r7, #26]
 8118e70:	7bfb      	ldrb	r3, [r7, #15]
 8118e72:	9300      	str	r3, [sp, #0]
 8118e74:	460b      	mov	r3, r1
 8118e76:	6939      	ldr	r1, [r7, #16]
 8118e78:	6878      	ldr	r0, [r7, #4]
 8118e7a:	f7ff fea7 	bl	8118bcc <tcp_create_segment>
 8118e7e:	61f8      	str	r0, [r7, #28]
  if (seg == NULL) {
 8118e80:	69fb      	ldr	r3, [r7, #28]
 8118e82:	2b00      	cmp	r3, #0
 8118e84:	d063      	beq.n	8118f4e <tcp_split_unsent_seg+0x246>
  seg->chksum_swapped = chksum_swapped;
  seg->flags |= TF_SEG_DATA_CHECKSUMMED;
#endif /* TCP_CHECKSUM_ON_COPY */

  /* Remove this segment from the queue since trimming it may free pbufs */
  pcb->snd_queuelen -= pbuf_clen(useg->p);
 8118e86:	697b      	ldr	r3, [r7, #20]
 8118e88:	685b      	ldr	r3, [r3, #4]
 8118e8a:	4618      	mov	r0, r3
 8118e8c:	f7fb fc6c 	bl	8114768 <pbuf_clen>
 8118e90:	4603      	mov	r3, r0
 8118e92:	461a      	mov	r2, r3
 8118e94:	687b      	ldr	r3, [r7, #4]
 8118e96:	f8b3 3066 	ldrh.w	r3, [r3, #102]	; 0x66
 8118e9a:	1a9b      	subs	r3, r3, r2
 8118e9c:	b29a      	uxth	r2, r3
 8118e9e:	687b      	ldr	r3, [r7, #4]
 8118ea0:	f8a3 2066 	strh.w	r2, [r3, #102]	; 0x66

  /* Trim the original pbuf into our split size.  At this point our remainder segment must be setup
  successfully because we are modifying the original segment */
  pbuf_realloc(useg->p, useg->p->tot_len - remainder);
 8118ea4:	697b      	ldr	r3, [r7, #20]
 8118ea6:	6858      	ldr	r0, [r3, #4]
 8118ea8:	697b      	ldr	r3, [r7, #20]
 8118eaa:	685b      	ldr	r3, [r3, #4]
 8118eac:	891a      	ldrh	r2, [r3, #8]
 8118eae:	89bb      	ldrh	r3, [r7, #12]
 8118eb0:	1ad3      	subs	r3, r2, r3
 8118eb2:	b29b      	uxth	r3, r3
 8118eb4:	4619      	mov	r1, r3
 8118eb6:	f7fb fa49 	bl	811434c <pbuf_realloc>
  useg->len -= remainder;
 8118eba:	697b      	ldr	r3, [r7, #20]
 8118ebc:	891a      	ldrh	r2, [r3, #8]
 8118ebe:	89bb      	ldrh	r3, [r7, #12]
 8118ec0:	1ad3      	subs	r3, r2, r3
 8118ec2:	b29a      	uxth	r2, r3
 8118ec4:	697b      	ldr	r3, [r7, #20]
 8118ec6:	811a      	strh	r2, [r3, #8]
  TCPH_SET_FLAG(useg->tcphdr, split_flags);
 8118ec8:	697b      	ldr	r3, [r7, #20]
 8118eca:	68db      	ldr	r3, [r3, #12]
 8118ecc:	899b      	ldrh	r3, [r3, #12]
 8118ece:	b29c      	uxth	r4, r3
 8118ed0:	7efb      	ldrb	r3, [r7, #27]
 8118ed2:	b29b      	uxth	r3, r3
 8118ed4:	4618      	mov	r0, r3
 8118ed6:	f7f5 fadc 	bl	810e492 <lwip_htons>
 8118eda:	4603      	mov	r3, r0
 8118edc:	461a      	mov	r2, r3
 8118ede:	697b      	ldr	r3, [r7, #20]
 8118ee0:	68db      	ldr	r3, [r3, #12]
 8118ee2:	4322      	orrs	r2, r4
 8118ee4:	b292      	uxth	r2, r2
 8118ee6:	819a      	strh	r2, [r3, #12]
  /* By trimming, realloc may have actually shrunk the pbuf, so clear oversize_left */
  useg->oversize_left = 0;
#endif /* TCP_OVERSIZE_DBGCHECK */

  /* Add back to the queue with new trimmed pbuf */
  pcb->snd_queuelen += pbuf_clen(useg->p);
 8118ee8:	697b      	ldr	r3, [r7, #20]
 8118eea:	685b      	ldr	r3, [r3, #4]
 8118eec:	4618      	mov	r0, r3
 8118eee:	f7fb fc3b 	bl	8114768 <pbuf_clen>
 8118ef2:	4603      	mov	r3, r0
 8118ef4:	461a      	mov	r2, r3
 8118ef6:	687b      	ldr	r3, [r7, #4]
 8118ef8:	f8b3 3066 	ldrh.w	r3, [r3, #102]	; 0x66
 8118efc:	4413      	add	r3, r2
 8118efe:	b29a      	uxth	r2, r3
 8118f00:	687b      	ldr	r3, [r7, #4]
 8118f02:	f8a3 2066 	strh.w	r2, [r3, #102]	; 0x66
#endif /* TCP_CHECKSUM_ON_COPY */

  /* Update number of segments on the queues. Note that length now may
   * exceed TCP_SND_QUEUELEN! We don't have to touch pcb->snd_buf
   * because the total amount of data is constant when packet is split */
  pcb->snd_queuelen += pbuf_clen(seg->p);
 8118f06:	69fb      	ldr	r3, [r7, #28]
 8118f08:	685b      	ldr	r3, [r3, #4]
 8118f0a:	4618      	mov	r0, r3
 8118f0c:	f7fb fc2c 	bl	8114768 <pbuf_clen>
 8118f10:	4603      	mov	r3, r0
 8118f12:	461a      	mov	r2, r3
 8118f14:	687b      	ldr	r3, [r7, #4]
 8118f16:	f8b3 3066 	ldrh.w	r3, [r3, #102]	; 0x66
 8118f1a:	4413      	add	r3, r2
 8118f1c:	b29a      	uxth	r2, r3
 8118f1e:	687b      	ldr	r3, [r7, #4]
 8118f20:	f8a3 2066 	strh.w	r2, [r3, #102]	; 0x66

  /* Finally insert remainder into queue after split (which stays head) */
  seg->next = useg->next;
 8118f24:	697b      	ldr	r3, [r7, #20]
 8118f26:	681a      	ldr	r2, [r3, #0]
 8118f28:	69fb      	ldr	r3, [r7, #28]
 8118f2a:	601a      	str	r2, [r3, #0]
  useg->next = seg;
 8118f2c:	697b      	ldr	r3, [r7, #20]
 8118f2e:	69fa      	ldr	r2, [r7, #28]
 8118f30:	601a      	str	r2, [r3, #0]

#if TCP_OVERSIZE
  /* If remainder is last segment on the unsent, ensure we clear the oversize amount
   * because the remainder is always sized to the exact remaining amount */
  if (seg->next == NULL) {
 8118f32:	69fb      	ldr	r3, [r7, #28]
 8118f34:	681b      	ldr	r3, [r3, #0]
 8118f36:	2b00      	cmp	r3, #0
 8118f38:	d103      	bne.n	8118f42 <tcp_split_unsent_seg+0x23a>
    pcb->unsent_oversize = 0;
 8118f3a:	687b      	ldr	r3, [r7, #4]
 8118f3c:	2200      	movs	r2, #0
 8118f3e:	f8a3 2068 	strh.w	r2, [r3, #104]	; 0x68
  }
#endif /* TCP_OVERSIZE */

  return ERR_OK;
 8118f42:	2300      	movs	r3, #0
 8118f44:	e016      	b.n	8118f74 <tcp_split_unsent_seg+0x26c>
    goto memerr;
 8118f46:	bf00      	nop
 8118f48:	e002      	b.n	8118f50 <tcp_split_unsent_seg+0x248>
    goto memerr;
 8118f4a:	bf00      	nop
 8118f4c:	e000      	b.n	8118f50 <tcp_split_unsent_seg+0x248>
    goto memerr;
 8118f4e:	bf00      	nop
memerr:
  TCP_STATS_INC(tcp.memerr);

  LWIP_ASSERT("seg == NULL", seg == NULL);
 8118f50:	69fb      	ldr	r3, [r7, #28]
 8118f52:	2b00      	cmp	r3, #0
 8118f54:	d006      	beq.n	8118f64 <tcp_split_unsent_seg+0x25c>
 8118f56:	4b09      	ldr	r3, [pc, #36]	; (8118f7c <tcp_split_unsent_seg+0x274>)
 8118f58:	f44f 7276 	mov.w	r2, #984	; 0x3d8
 8118f5c:	490d      	ldr	r1, [pc, #52]	; (8118f94 <tcp_split_unsent_seg+0x28c>)
 8118f5e:	4809      	ldr	r0, [pc, #36]	; (8118f84 <tcp_split_unsent_seg+0x27c>)
 8118f60:	f002 fc4e 	bl	811b800 <iprintf>
  if (p != NULL) {
 8118f64:	693b      	ldr	r3, [r7, #16]
 8118f66:	2b00      	cmp	r3, #0
 8118f68:	d002      	beq.n	8118f70 <tcp_split_unsent_seg+0x268>
    pbuf_free(p);
 8118f6a:	6938      	ldr	r0, [r7, #16]
 8118f6c:	f7fb fb74 	bl	8114658 <pbuf_free>
  }

  return ERR_MEM;
 8118f70:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
}
 8118f74:	4618      	mov	r0, r3
 8118f76:	3724      	adds	r7, #36	; 0x24
 8118f78:	46bd      	mov	sp, r7
 8118f7a:	bd90      	pop	{r4, r7, pc}
 8118f7c:	0811eb98 	.word	0x0811eb98
 8118f80:	0811ef60 	.word	0x0811ef60
 8118f84:	0811ec20 	.word	0x0811ec20
 8118f88:	0811ef84 	.word	0x0811ef84
 8118f8c:	0811efa8 	.word	0x0811efa8
 8118f90:	0811efb8 	.word	0x0811efb8
 8118f94:	0811efc8 	.word	0x0811efc8

08118f98 <tcp_send_fin>:
 * @param pcb the tcp_pcb over which to send a segment
 * @return ERR_OK if sent, another err_t otherwise
 */
err_t
tcp_send_fin(struct tcp_pcb *pcb)
{
 8118f98:	b590      	push	{r4, r7, lr}
 8118f9a:	b085      	sub	sp, #20
 8118f9c:	af00      	add	r7, sp, #0
 8118f9e:	6078      	str	r0, [r7, #4]
  LWIP_ASSERT("tcp_send_fin: invalid pcb", pcb != NULL);
 8118fa0:	687b      	ldr	r3, [r7, #4]
 8118fa2:	2b00      	cmp	r3, #0
 8118fa4:	d106      	bne.n	8118fb4 <tcp_send_fin+0x1c>
 8118fa6:	4b21      	ldr	r3, [pc, #132]	; (811902c <tcp_send_fin+0x94>)
 8118fa8:	f240 32eb 	movw	r2, #1003	; 0x3eb
 8118fac:	4920      	ldr	r1, [pc, #128]	; (8119030 <tcp_send_fin+0x98>)
 8118fae:	4821      	ldr	r0, [pc, #132]	; (8119034 <tcp_send_fin+0x9c>)
 8118fb0:	f002 fc26 	bl	811b800 <iprintf>

  /* first, try to add the fin to the last unsent segment */
  if (pcb->unsent != NULL) {
 8118fb4:	687b      	ldr	r3, [r7, #4]
 8118fb6:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 8118fb8:	2b00      	cmp	r3, #0
 8118fba:	d02e      	beq.n	811901a <tcp_send_fin+0x82>
    struct tcp_seg *last_unsent;
    for (last_unsent = pcb->unsent; last_unsent->next != NULL;
 8118fbc:	687b      	ldr	r3, [r7, #4]
 8118fbe:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 8118fc0:	60fb      	str	r3, [r7, #12]
 8118fc2:	e002      	b.n	8118fca <tcp_send_fin+0x32>
         last_unsent = last_unsent->next);
 8118fc4:	68fb      	ldr	r3, [r7, #12]
 8118fc6:	681b      	ldr	r3, [r3, #0]
 8118fc8:	60fb      	str	r3, [r7, #12]
    for (last_unsent = pcb->unsent; last_unsent->next != NULL;
 8118fca:	68fb      	ldr	r3, [r7, #12]
 8118fcc:	681b      	ldr	r3, [r3, #0]
 8118fce:	2b00      	cmp	r3, #0
 8118fd0:	d1f8      	bne.n	8118fc4 <tcp_send_fin+0x2c>

    if ((TCPH_FLAGS(last_unsent->tcphdr) & (TCP_SYN | TCP_FIN | TCP_RST)) == 0) {
 8118fd2:	68fb      	ldr	r3, [r7, #12]
 8118fd4:	68db      	ldr	r3, [r3, #12]
 8118fd6:	899b      	ldrh	r3, [r3, #12]
 8118fd8:	b29b      	uxth	r3, r3
 8118fda:	4618      	mov	r0, r3
 8118fdc:	f7f5 fa59 	bl	810e492 <lwip_htons>
 8118fe0:	4603      	mov	r3, r0
 8118fe2:	b2db      	uxtb	r3, r3
 8118fe4:	f003 0307 	and.w	r3, r3, #7
 8118fe8:	2b00      	cmp	r3, #0
 8118fea:	d116      	bne.n	811901a <tcp_send_fin+0x82>
      /* no SYN/FIN/RST flag in the header, we can add the FIN flag */
      TCPH_SET_FLAG(last_unsent->tcphdr, TCP_FIN);
 8118fec:	68fb      	ldr	r3, [r7, #12]
 8118fee:	68db      	ldr	r3, [r3, #12]
 8118ff0:	899b      	ldrh	r3, [r3, #12]
 8118ff2:	b29c      	uxth	r4, r3
 8118ff4:	2001      	movs	r0, #1
 8118ff6:	f7f5 fa4c 	bl	810e492 <lwip_htons>
 8118ffa:	4603      	mov	r3, r0
 8118ffc:	461a      	mov	r2, r3
 8118ffe:	68fb      	ldr	r3, [r7, #12]
 8119000:	68db      	ldr	r3, [r3, #12]
 8119002:	4322      	orrs	r2, r4
 8119004:	b292      	uxth	r2, r2
 8119006:	819a      	strh	r2, [r3, #12]
      tcp_set_flags(pcb, TF_FIN);
 8119008:	687b      	ldr	r3, [r7, #4]
 811900a:	8b5b      	ldrh	r3, [r3, #26]
 811900c:	f043 0320 	orr.w	r3, r3, #32
 8119010:	b29a      	uxth	r2, r3
 8119012:	687b      	ldr	r3, [r7, #4]
 8119014:	835a      	strh	r2, [r3, #26]
      return ERR_OK;
 8119016:	2300      	movs	r3, #0
 8119018:	e004      	b.n	8119024 <tcp_send_fin+0x8c>
    }
  }
  /* no data, no length, flags, copy=1, no optdata */
  return tcp_enqueue_flags(pcb, TCP_FIN);
 811901a:	2101      	movs	r1, #1
 811901c:	6878      	ldr	r0, [r7, #4]
 811901e:	f000 f80b 	bl	8119038 <tcp_enqueue_flags>
 8119022:	4603      	mov	r3, r0
}
 8119024:	4618      	mov	r0, r3
 8119026:	3714      	adds	r7, #20
 8119028:	46bd      	mov	sp, r7
 811902a:	bd90      	pop	{r4, r7, pc}
 811902c:	0811eb98 	.word	0x0811eb98
 8119030:	0811efd4 	.word	0x0811efd4
 8119034:	0811ec20 	.word	0x0811ec20

08119038 <tcp_enqueue_flags>:
 * @param pcb Protocol control block for the TCP connection.
 * @param flags TCP header flags to set in the outgoing segment.
 */
err_t
tcp_enqueue_flags(struct tcp_pcb *pcb, u8_t flags)
{
 8119038:	b580      	push	{r7, lr}
 811903a:	b08a      	sub	sp, #40	; 0x28
 811903c:	af02      	add	r7, sp, #8
 811903e:	6078      	str	r0, [r7, #4]
 8119040:	460b      	mov	r3, r1
 8119042:	70fb      	strb	r3, [r7, #3]
  struct pbuf *p;
  struct tcp_seg *seg;
  u8_t optflags = 0;
 8119044:	2300      	movs	r3, #0
 8119046:	77fb      	strb	r3, [r7, #31]
  u8_t optlen = 0;
 8119048:	2300      	movs	r3, #0
 811904a:	75fb      	strb	r3, [r7, #23]

  LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_enqueue_flags: queuelen: %"U16_F"\n", (u16_t)pcb->snd_queuelen));

  LWIP_ASSERT("tcp_enqueue_flags: need either TCP_SYN or TCP_FIN in flags (programmer violates API)",
 811904c:	78fb      	ldrb	r3, [r7, #3]
 811904e:	f003 0303 	and.w	r3, r3, #3
 8119052:	2b00      	cmp	r3, #0
 8119054:	d106      	bne.n	8119064 <tcp_enqueue_flags+0x2c>
 8119056:	4b67      	ldr	r3, [pc, #412]	; (81191f4 <tcp_enqueue_flags+0x1bc>)
 8119058:	f240 4211 	movw	r2, #1041	; 0x411
 811905c:	4966      	ldr	r1, [pc, #408]	; (81191f8 <tcp_enqueue_flags+0x1c0>)
 811905e:	4867      	ldr	r0, [pc, #412]	; (81191fc <tcp_enqueue_flags+0x1c4>)
 8119060:	f002 fbce 	bl	811b800 <iprintf>
              (flags & (TCP_SYN | TCP_FIN)) != 0);
  LWIP_ASSERT("tcp_enqueue_flags: invalid pcb", pcb != NULL);
 8119064:	687b      	ldr	r3, [r7, #4]
 8119066:	2b00      	cmp	r3, #0
 8119068:	d106      	bne.n	8119078 <tcp_enqueue_flags+0x40>
 811906a:	4b62      	ldr	r3, [pc, #392]	; (81191f4 <tcp_enqueue_flags+0x1bc>)
 811906c:	f240 4213 	movw	r2, #1043	; 0x413
 8119070:	4963      	ldr	r1, [pc, #396]	; (8119200 <tcp_enqueue_flags+0x1c8>)
 8119072:	4862      	ldr	r0, [pc, #392]	; (81191fc <tcp_enqueue_flags+0x1c4>)
 8119074:	f002 fbc4 	bl	811b800 <iprintf>

  /* No need to check pcb->snd_queuelen if only SYN or FIN are allowed! */

  /* Get options for this segment. This is a special case since this is the
     only place where a SYN can be sent. */
  if (flags & TCP_SYN) {
 8119078:	78fb      	ldrb	r3, [r7, #3]
 811907a:	f003 0302 	and.w	r3, r3, #2
 811907e:	2b00      	cmp	r3, #0
 8119080:	d001      	beq.n	8119086 <tcp_enqueue_flags+0x4e>
    optflags = TF_SEG_OPTS_MSS;
 8119082:	2301      	movs	r3, #1
 8119084:	77fb      	strb	r3, [r7, #31]
    /* Make sure the timestamp option is only included in data segments if we
       agreed about it with the remote host (and in active open SYN segments). */
    optflags |= TF_SEG_OPTS_TS;
  }
#endif /* LWIP_TCP_TIMESTAMPS */
  optlen = LWIP_TCP_OPT_LENGTH_SEGMENT(optflags, pcb);
 8119086:	7ffb      	ldrb	r3, [r7, #31]
 8119088:	009b      	lsls	r3, r3, #2
 811908a:	b2db      	uxtb	r3, r3
 811908c:	f003 0304 	and.w	r3, r3, #4
 8119090:	75fb      	strb	r3, [r7, #23]

  /* Allocate pbuf with room for TCP header + options */
  if ((p = pbuf_alloc(PBUF_TRANSPORT, optlen, PBUF_RAM)) == NULL) {
 8119092:	7dfb      	ldrb	r3, [r7, #23]
 8119094:	b29b      	uxth	r3, r3
 8119096:	f44f 7220 	mov.w	r2, #640	; 0x280
 811909a:	4619      	mov	r1, r3
 811909c:	2036      	movs	r0, #54	; 0x36
 811909e:	f7fa fff7 	bl	8114090 <pbuf_alloc>
 81190a2:	6138      	str	r0, [r7, #16]
 81190a4:	693b      	ldr	r3, [r7, #16]
 81190a6:	2b00      	cmp	r3, #0
 81190a8:	d109      	bne.n	81190be <tcp_enqueue_flags+0x86>
    tcp_set_flags(pcb, TF_NAGLEMEMERR);
 81190aa:	687b      	ldr	r3, [r7, #4]
 81190ac:	8b5b      	ldrh	r3, [r3, #26]
 81190ae:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 81190b2:	b29a      	uxth	r2, r3
 81190b4:	687b      	ldr	r3, [r7, #4]
 81190b6:	835a      	strh	r2, [r3, #26]
    TCP_STATS_INC(tcp.memerr);
    return ERR_MEM;
 81190b8:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 81190bc:	e095      	b.n	81191ea <tcp_enqueue_flags+0x1b2>
  }
  LWIP_ASSERT("tcp_enqueue_flags: check that first pbuf can hold optlen",
 81190be:	693b      	ldr	r3, [r7, #16]
 81190c0:	895a      	ldrh	r2, [r3, #10]
 81190c2:	7dfb      	ldrb	r3, [r7, #23]
 81190c4:	b29b      	uxth	r3, r3
 81190c6:	429a      	cmp	r2, r3
 81190c8:	d206      	bcs.n	81190d8 <tcp_enqueue_flags+0xa0>
 81190ca:	4b4a      	ldr	r3, [pc, #296]	; (81191f4 <tcp_enqueue_flags+0x1bc>)
 81190cc:	f240 4239 	movw	r2, #1081	; 0x439
 81190d0:	494c      	ldr	r1, [pc, #304]	; (8119204 <tcp_enqueue_flags+0x1cc>)
 81190d2:	484a      	ldr	r0, [pc, #296]	; (81191fc <tcp_enqueue_flags+0x1c4>)
 81190d4:	f002 fb94 	bl	811b800 <iprintf>
              (p->len >= optlen));

  /* Allocate memory for tcp_seg, and fill in fields. */
  if ((seg = tcp_create_segment(pcb, p, flags, pcb->snd_lbb, optflags)) == NULL) {
 81190d8:	687b      	ldr	r3, [r7, #4]
 81190da:	6dd9      	ldr	r1, [r3, #92]	; 0x5c
 81190dc:	78fa      	ldrb	r2, [r7, #3]
 81190de:	7ffb      	ldrb	r3, [r7, #31]
 81190e0:	9300      	str	r3, [sp, #0]
 81190e2:	460b      	mov	r3, r1
 81190e4:	6939      	ldr	r1, [r7, #16]
 81190e6:	6878      	ldr	r0, [r7, #4]
 81190e8:	f7ff fd70 	bl	8118bcc <tcp_create_segment>
 81190ec:	60f8      	str	r0, [r7, #12]
 81190ee:	68fb      	ldr	r3, [r7, #12]
 81190f0:	2b00      	cmp	r3, #0
 81190f2:	d109      	bne.n	8119108 <tcp_enqueue_flags+0xd0>
    tcp_set_flags(pcb, TF_NAGLEMEMERR);
 81190f4:	687b      	ldr	r3, [r7, #4]
 81190f6:	8b5b      	ldrh	r3, [r3, #26]
 81190f8:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 81190fc:	b29a      	uxth	r2, r3
 81190fe:	687b      	ldr	r3, [r7, #4]
 8119100:	835a      	strh	r2, [r3, #26]
    TCP_STATS_INC(tcp.memerr);
    return ERR_MEM;
 8119102:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 8119106:	e070      	b.n	81191ea <tcp_enqueue_flags+0x1b2>
  }
  LWIP_ASSERT("seg->tcphdr not aligned", ((mem_ptr_t)seg->tcphdr % LWIP_MIN(MEM_ALIGNMENT, 4)) == 0);
 8119108:	68fb      	ldr	r3, [r7, #12]
 811910a:	68db      	ldr	r3, [r3, #12]
 811910c:	f003 0303 	and.w	r3, r3, #3
 8119110:	2b00      	cmp	r3, #0
 8119112:	d006      	beq.n	8119122 <tcp_enqueue_flags+0xea>
 8119114:	4b37      	ldr	r3, [pc, #220]	; (81191f4 <tcp_enqueue_flags+0x1bc>)
 8119116:	f240 4242 	movw	r2, #1090	; 0x442
 811911a:	493b      	ldr	r1, [pc, #236]	; (8119208 <tcp_enqueue_flags+0x1d0>)
 811911c:	4837      	ldr	r0, [pc, #220]	; (81191fc <tcp_enqueue_flags+0x1c4>)
 811911e:	f002 fb6f 	bl	811b800 <iprintf>
  LWIP_ASSERT("tcp_enqueue_flags: invalid segment length", seg->len == 0);
 8119122:	68fb      	ldr	r3, [r7, #12]
 8119124:	891b      	ldrh	r3, [r3, #8]
 8119126:	2b00      	cmp	r3, #0
 8119128:	d006      	beq.n	8119138 <tcp_enqueue_flags+0x100>
 811912a:	4b32      	ldr	r3, [pc, #200]	; (81191f4 <tcp_enqueue_flags+0x1bc>)
 811912c:	f240 4243 	movw	r2, #1091	; 0x443
 8119130:	4936      	ldr	r1, [pc, #216]	; (811920c <tcp_enqueue_flags+0x1d4>)
 8119132:	4832      	ldr	r0, [pc, #200]	; (81191fc <tcp_enqueue_flags+0x1c4>)
 8119134:	f002 fb64 	bl	811b800 <iprintf>
               lwip_ntohl(seg->tcphdr->seqno),
               lwip_ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg),
               (u16_t)flags));

  /* Now append seg to pcb->unsent queue */
  if (pcb->unsent == NULL) {
 8119138:	687b      	ldr	r3, [r7, #4]
 811913a:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 811913c:	2b00      	cmp	r3, #0
 811913e:	d103      	bne.n	8119148 <tcp_enqueue_flags+0x110>
    pcb->unsent = seg;
 8119140:	687b      	ldr	r3, [r7, #4]
 8119142:	68fa      	ldr	r2, [r7, #12]
 8119144:	66da      	str	r2, [r3, #108]	; 0x6c
 8119146:	e00d      	b.n	8119164 <tcp_enqueue_flags+0x12c>
  } else {
    struct tcp_seg *useg;
    for (useg = pcb->unsent; useg->next != NULL; useg = useg->next);
 8119148:	687b      	ldr	r3, [r7, #4]
 811914a:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 811914c:	61bb      	str	r3, [r7, #24]
 811914e:	e002      	b.n	8119156 <tcp_enqueue_flags+0x11e>
 8119150:	69bb      	ldr	r3, [r7, #24]
 8119152:	681b      	ldr	r3, [r3, #0]
 8119154:	61bb      	str	r3, [r7, #24]
 8119156:	69bb      	ldr	r3, [r7, #24]
 8119158:	681b      	ldr	r3, [r3, #0]
 811915a:	2b00      	cmp	r3, #0
 811915c:	d1f8      	bne.n	8119150 <tcp_enqueue_flags+0x118>
    useg->next = seg;
 811915e:	69bb      	ldr	r3, [r7, #24]
 8119160:	68fa      	ldr	r2, [r7, #12]
 8119162:	601a      	str	r2, [r3, #0]
  }
#if TCP_OVERSIZE
  /* The new unsent tail has no space */
  pcb->unsent_oversize = 0;
 8119164:	687b      	ldr	r3, [r7, #4]
 8119166:	2200      	movs	r2, #0
 8119168:	f8a3 2068 	strh.w	r2, [r3, #104]	; 0x68
#endif /* TCP_OVERSIZE */

  /* SYN and FIN bump the sequence number */
  if ((flags & TCP_SYN) || (flags & TCP_FIN)) {
 811916c:	78fb      	ldrb	r3, [r7, #3]
 811916e:	f003 0302 	and.w	r3, r3, #2
 8119172:	2b00      	cmp	r3, #0
 8119174:	d104      	bne.n	8119180 <tcp_enqueue_flags+0x148>
 8119176:	78fb      	ldrb	r3, [r7, #3]
 8119178:	f003 0301 	and.w	r3, r3, #1
 811917c:	2b00      	cmp	r3, #0
 811917e:	d004      	beq.n	811918a <tcp_enqueue_flags+0x152>
    pcb->snd_lbb++;
 8119180:	687b      	ldr	r3, [r7, #4]
 8119182:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 8119184:	1c5a      	adds	r2, r3, #1
 8119186:	687b      	ldr	r3, [r7, #4]
 8119188:	65da      	str	r2, [r3, #92]	; 0x5c
    /* optlen does not influence snd_buf */
  }
  if (flags & TCP_FIN) {
 811918a:	78fb      	ldrb	r3, [r7, #3]
 811918c:	f003 0301 	and.w	r3, r3, #1
 8119190:	2b00      	cmp	r3, #0
 8119192:	d006      	beq.n	81191a2 <tcp_enqueue_flags+0x16a>
    tcp_set_flags(pcb, TF_FIN);
 8119194:	687b      	ldr	r3, [r7, #4]
 8119196:	8b5b      	ldrh	r3, [r3, #26]
 8119198:	f043 0320 	orr.w	r3, r3, #32
 811919c:	b29a      	uxth	r2, r3
 811919e:	687b      	ldr	r3, [r7, #4]
 81191a0:	835a      	strh	r2, [r3, #26]
  }

  /* update number of segments on the queues */
  pcb->snd_queuelen += pbuf_clen(seg->p);
 81191a2:	68fb      	ldr	r3, [r7, #12]
 81191a4:	685b      	ldr	r3, [r3, #4]
 81191a6:	4618      	mov	r0, r3
 81191a8:	f7fb fade 	bl	8114768 <pbuf_clen>
 81191ac:	4603      	mov	r3, r0
 81191ae:	461a      	mov	r2, r3
 81191b0:	687b      	ldr	r3, [r7, #4]
 81191b2:	f8b3 3066 	ldrh.w	r3, [r3, #102]	; 0x66
 81191b6:	4413      	add	r3, r2
 81191b8:	b29a      	uxth	r2, r3
 81191ba:	687b      	ldr	r3, [r7, #4]
 81191bc:	f8a3 2066 	strh.w	r2, [r3, #102]	; 0x66
  LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_enqueue_flags: %"S16_F" (after enqueued)\n", pcb->snd_queuelen));
  if (pcb->snd_queuelen != 0) {
 81191c0:	687b      	ldr	r3, [r7, #4]
 81191c2:	f8b3 3066 	ldrh.w	r3, [r3, #102]	; 0x66
 81191c6:	2b00      	cmp	r3, #0
 81191c8:	d00e      	beq.n	81191e8 <tcp_enqueue_flags+0x1b0>
    LWIP_ASSERT("tcp_enqueue_flags: invalid queue length",
 81191ca:	687b      	ldr	r3, [r7, #4]
 81191cc:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 81191ce:	2b00      	cmp	r3, #0
 81191d0:	d10a      	bne.n	81191e8 <tcp_enqueue_flags+0x1b0>
 81191d2:	687b      	ldr	r3, [r7, #4]
 81191d4:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 81191d6:	2b00      	cmp	r3, #0
 81191d8:	d106      	bne.n	81191e8 <tcp_enqueue_flags+0x1b0>
 81191da:	4b06      	ldr	r3, [pc, #24]	; (81191f4 <tcp_enqueue_flags+0x1bc>)
 81191dc:	f240 4265 	movw	r2, #1125	; 0x465
 81191e0:	490b      	ldr	r1, [pc, #44]	; (8119210 <tcp_enqueue_flags+0x1d8>)
 81191e2:	4806      	ldr	r0, [pc, #24]	; (81191fc <tcp_enqueue_flags+0x1c4>)
 81191e4:	f002 fb0c 	bl	811b800 <iprintf>
                pcb->unacked != NULL || pcb->unsent != NULL);
  }

  return ERR_OK;
 81191e8:	2300      	movs	r3, #0
}
 81191ea:	4618      	mov	r0, r3
 81191ec:	3720      	adds	r7, #32
 81191ee:	46bd      	mov	sp, r7
 81191f0:	bd80      	pop	{r7, pc}
 81191f2:	bf00      	nop
 81191f4:	0811eb98 	.word	0x0811eb98
 81191f8:	0811eff0 	.word	0x0811eff0
 81191fc:	0811ec20 	.word	0x0811ec20
 8119200:	0811f048 	.word	0x0811f048
 8119204:	0811f068 	.word	0x0811f068
 8119208:	0811f0a4 	.word	0x0811f0a4
 811920c:	0811f0bc 	.word	0x0811f0bc
 8119210:	0811f0e8 	.word	0x0811f0e8

08119214 <tcp_output>:
 * @return ERR_OK if data has been sent or nothing to send
 *         another err_t on error
 */
err_t
tcp_output(struct tcp_pcb *pcb)
{
 8119214:	b5b0      	push	{r4, r5, r7, lr}
 8119216:	b08a      	sub	sp, #40	; 0x28
 8119218:	af00      	add	r7, sp, #0
 811921a:	6078      	str	r0, [r7, #4]
  s16_t i = 0;
#endif /* TCP_CWND_DEBUG */

  LWIP_ASSERT_CORE_LOCKED();

  LWIP_ASSERT("tcp_output: invalid pcb", pcb != NULL);
 811921c:	687b      	ldr	r3, [r7, #4]
 811921e:	2b00      	cmp	r3, #0
 8119220:	d106      	bne.n	8119230 <tcp_output+0x1c>
 8119222:	4b8a      	ldr	r3, [pc, #552]	; (811944c <tcp_output+0x238>)
 8119224:	f240 42e1 	movw	r2, #1249	; 0x4e1
 8119228:	4989      	ldr	r1, [pc, #548]	; (8119450 <tcp_output+0x23c>)
 811922a:	488a      	ldr	r0, [pc, #552]	; (8119454 <tcp_output+0x240>)
 811922c:	f002 fae8 	bl	811b800 <iprintf>
  /* pcb->state LISTEN not allowed here */
  LWIP_ASSERT("don't call tcp_output for listen-pcbs",
 8119230:	687b      	ldr	r3, [r7, #4]
 8119232:	7d1b      	ldrb	r3, [r3, #20]
 8119234:	2b01      	cmp	r3, #1
 8119236:	d106      	bne.n	8119246 <tcp_output+0x32>
 8119238:	4b84      	ldr	r3, [pc, #528]	; (811944c <tcp_output+0x238>)
 811923a:	f240 42e3 	movw	r2, #1251	; 0x4e3
 811923e:	4986      	ldr	r1, [pc, #536]	; (8119458 <tcp_output+0x244>)
 8119240:	4884      	ldr	r0, [pc, #528]	; (8119454 <tcp_output+0x240>)
 8119242:	f002 fadd 	bl	811b800 <iprintf>

  /* First, check if we are invoked by the TCP input processing
     code. If so, we do not output anything. Instead, we rely on the
     input processing code to call us when input processing is done
     with. */
  if (tcp_input_pcb == pcb) {
 8119246:	4b85      	ldr	r3, [pc, #532]	; (811945c <tcp_output+0x248>)
 8119248:	681b      	ldr	r3, [r3, #0]
 811924a:	687a      	ldr	r2, [r7, #4]
 811924c:	429a      	cmp	r2, r3
 811924e:	d101      	bne.n	8119254 <tcp_output+0x40>
    return ERR_OK;
 8119250:	2300      	movs	r3, #0
 8119252:	e1ce      	b.n	81195f2 <tcp_output+0x3de>
  }

  wnd = LWIP_MIN(pcb->snd_wnd, pcb->cwnd);
 8119254:	687b      	ldr	r3, [r7, #4]
 8119256:	f8b3 2048 	ldrh.w	r2, [r3, #72]	; 0x48
 811925a:	687b      	ldr	r3, [r7, #4]
 811925c:	f8b3 3060 	ldrh.w	r3, [r3, #96]	; 0x60
 8119260:	4293      	cmp	r3, r2
 8119262:	bf28      	it	cs
 8119264:	4613      	movcs	r3, r2
 8119266:	b29b      	uxth	r3, r3
 8119268:	61bb      	str	r3, [r7, #24]

  seg = pcb->unsent;
 811926a:	687b      	ldr	r3, [r7, #4]
 811926c:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 811926e:	627b      	str	r3, [r7, #36]	; 0x24

  if (seg == NULL) {
 8119270:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8119272:	2b00      	cmp	r3, #0
 8119274:	d10b      	bne.n	811928e <tcp_output+0x7a>
                                 ", seg == NULL, ack %"U32_F"\n",
                                 pcb->snd_wnd, pcb->cwnd, wnd, pcb->lastack));

    /* If the TF_ACK_NOW flag is set and the ->unsent queue is empty, construct
     * an empty ACK segment and send it. */
    if (pcb->flags & TF_ACK_NOW) {
 8119276:	687b      	ldr	r3, [r7, #4]
 8119278:	8b5b      	ldrh	r3, [r3, #26]
 811927a:	f003 0302 	and.w	r3, r3, #2
 811927e:	2b00      	cmp	r3, #0
 8119280:	f000 81aa 	beq.w	81195d8 <tcp_output+0x3c4>
      return tcp_send_empty_ack(pcb);
 8119284:	6878      	ldr	r0, [r7, #4]
 8119286:	f000 fdcb 	bl	8119e20 <tcp_send_empty_ack>
 811928a:	4603      	mov	r3, r0
 811928c:	e1b1      	b.n	81195f2 <tcp_output+0x3de>
                 pcb->snd_wnd, pcb->cwnd, wnd,
                 lwip_ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len,
                 lwip_ntohl(seg->tcphdr->seqno), pcb->lastack));
  }

  netif = tcp_route(pcb, &pcb->local_ip, &pcb->remote_ip);
 811928e:	6879      	ldr	r1, [r7, #4]
 8119290:	687b      	ldr	r3, [r7, #4]
 8119292:	3304      	adds	r3, #4
 8119294:	461a      	mov	r2, r3
 8119296:	6878      	ldr	r0, [r7, #4]
 8119298:	f7ff fc7c 	bl	8118b94 <tcp_route>
 811929c:	6178      	str	r0, [r7, #20]
  if (netif == NULL) {
 811929e:	697b      	ldr	r3, [r7, #20]
 81192a0:	2b00      	cmp	r3, #0
 81192a2:	d102      	bne.n	81192aa <tcp_output+0x96>
    return ERR_RTE;
 81192a4:	f06f 0303 	mvn.w	r3, #3
 81192a8:	e1a3      	b.n	81195f2 <tcp_output+0x3de>
  }

  /* If we don't have a local IP address, we get one from netif */
  if (ip_addr_isany(&pcb->local_ip)) {
 81192aa:	687b      	ldr	r3, [r7, #4]
 81192ac:	2b00      	cmp	r3, #0
 81192ae:	d003      	beq.n	81192b8 <tcp_output+0xa4>
 81192b0:	687b      	ldr	r3, [r7, #4]
 81192b2:	681b      	ldr	r3, [r3, #0]
 81192b4:	2b00      	cmp	r3, #0
 81192b6:	d111      	bne.n	81192dc <tcp_output+0xc8>
    const ip_addr_t *local_ip = ip_netif_get_local_ip(netif, &pcb->remote_ip);
 81192b8:	697b      	ldr	r3, [r7, #20]
 81192ba:	2b00      	cmp	r3, #0
 81192bc:	d002      	beq.n	81192c4 <tcp_output+0xb0>
 81192be:	697b      	ldr	r3, [r7, #20]
 81192c0:	3304      	adds	r3, #4
 81192c2:	e000      	b.n	81192c6 <tcp_output+0xb2>
 81192c4:	2300      	movs	r3, #0
 81192c6:	613b      	str	r3, [r7, #16]
    if (local_ip == NULL) {
 81192c8:	693b      	ldr	r3, [r7, #16]
 81192ca:	2b00      	cmp	r3, #0
 81192cc:	d102      	bne.n	81192d4 <tcp_output+0xc0>
      return ERR_RTE;
 81192ce:	f06f 0303 	mvn.w	r3, #3
 81192d2:	e18e      	b.n	81195f2 <tcp_output+0x3de>
    }
    ip_addr_copy(pcb->local_ip, *local_ip);
 81192d4:	693b      	ldr	r3, [r7, #16]
 81192d6:	681a      	ldr	r2, [r3, #0]
 81192d8:	687b      	ldr	r3, [r7, #4]
 81192da:	601a      	str	r2, [r3, #0]
  }

  /* Handle the current segment not fitting within the window */
  if (lwip_ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > wnd) {
 81192dc:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 81192de:	68db      	ldr	r3, [r3, #12]
 81192e0:	685b      	ldr	r3, [r3, #4]
 81192e2:	4618      	mov	r0, r3
 81192e4:	f7f5 f8ea 	bl	810e4bc <lwip_htonl>
 81192e8:	4602      	mov	r2, r0
 81192ea:	687b      	ldr	r3, [r7, #4]
 81192ec:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 81192ee:	1ad3      	subs	r3, r2, r3
 81192f0:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 81192f2:	8912      	ldrh	r2, [r2, #8]
 81192f4:	4413      	add	r3, r2
 81192f6:	69ba      	ldr	r2, [r7, #24]
 81192f8:	429a      	cmp	r2, r3
 81192fa:	d227      	bcs.n	811934c <tcp_output+0x138>
     * within the remaining (could be 0) send window and RTO timer is not running (we
     * have no in-flight data). If window is still too small after persist timer fires,
     * then we split the segment. We don't consider the congestion window since a cwnd
     * smaller than 1 SMSS implies in-flight data
     */
    if (wnd == pcb->snd_wnd && pcb->unacked == NULL && pcb->persist_backoff == 0) {
 81192fc:	687b      	ldr	r3, [r7, #4]
 81192fe:	f8b3 3060 	ldrh.w	r3, [r3, #96]	; 0x60
 8119302:	461a      	mov	r2, r3
 8119304:	69bb      	ldr	r3, [r7, #24]
 8119306:	4293      	cmp	r3, r2
 8119308:	d114      	bne.n	8119334 <tcp_output+0x120>
 811930a:	687b      	ldr	r3, [r7, #4]
 811930c:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 811930e:	2b00      	cmp	r3, #0
 8119310:	d110      	bne.n	8119334 <tcp_output+0x120>
 8119312:	687b      	ldr	r3, [r7, #4]
 8119314:	f893 3099 	ldrb.w	r3, [r3, #153]	; 0x99
 8119318:	2b00      	cmp	r3, #0
 811931a:	d10b      	bne.n	8119334 <tcp_output+0x120>
      pcb->persist_cnt = 0;
 811931c:	687b      	ldr	r3, [r7, #4]
 811931e:	2200      	movs	r2, #0
 8119320:	f883 2098 	strb.w	r2, [r3, #152]	; 0x98
      pcb->persist_backoff = 1;
 8119324:	687b      	ldr	r3, [r7, #4]
 8119326:	2201      	movs	r2, #1
 8119328:	f883 2099 	strb.w	r2, [r3, #153]	; 0x99
      pcb->persist_probe = 0;
 811932c:	687b      	ldr	r3, [r7, #4]
 811932e:	2200      	movs	r2, #0
 8119330:	f883 209a 	strb.w	r2, [r3, #154]	; 0x9a
    }
    /* We need an ACK, but can't send data now, so send an empty ACK */
    if (pcb->flags & TF_ACK_NOW) {
 8119334:	687b      	ldr	r3, [r7, #4]
 8119336:	8b5b      	ldrh	r3, [r3, #26]
 8119338:	f003 0302 	and.w	r3, r3, #2
 811933c:	2b00      	cmp	r3, #0
 811933e:	f000 814d 	beq.w	81195dc <tcp_output+0x3c8>
      return tcp_send_empty_ack(pcb);
 8119342:	6878      	ldr	r0, [r7, #4]
 8119344:	f000 fd6c 	bl	8119e20 <tcp_send_empty_ack>
 8119348:	4603      	mov	r3, r0
 811934a:	e152      	b.n	81195f2 <tcp_output+0x3de>
    }
    goto output_done;
  }
  /* Stop persist timer, above conditions are not active */
  pcb->persist_backoff = 0;
 811934c:	687b      	ldr	r3, [r7, #4]
 811934e:	2200      	movs	r2, #0
 8119350:	f883 2099 	strb.w	r2, [r3, #153]	; 0x99

  /* useg should point to last segment on unacked queue */
  useg = pcb->unacked;
 8119354:	687b      	ldr	r3, [r7, #4]
 8119356:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8119358:	623b      	str	r3, [r7, #32]
  if (useg != NULL) {
 811935a:	6a3b      	ldr	r3, [r7, #32]
 811935c:	2b00      	cmp	r3, #0
 811935e:	f000 811c 	beq.w	811959a <tcp_output+0x386>
    for (; useg->next != NULL; useg = useg->next);
 8119362:	e002      	b.n	811936a <tcp_output+0x156>
 8119364:	6a3b      	ldr	r3, [r7, #32]
 8119366:	681b      	ldr	r3, [r3, #0]
 8119368:	623b      	str	r3, [r7, #32]
 811936a:	6a3b      	ldr	r3, [r7, #32]
 811936c:	681b      	ldr	r3, [r3, #0]
 811936e:	2b00      	cmp	r3, #0
 8119370:	d1f8      	bne.n	8119364 <tcp_output+0x150>
  }
  /* data available and window allows it to be sent? */
  while (seg != NULL &&
 8119372:	e112      	b.n	811959a <tcp_output+0x386>
         lwip_ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len <= wnd) {
    LWIP_ASSERT("RST not expected here!",
 8119374:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8119376:	68db      	ldr	r3, [r3, #12]
 8119378:	899b      	ldrh	r3, [r3, #12]
 811937a:	b29b      	uxth	r3, r3
 811937c:	4618      	mov	r0, r3
 811937e:	f7f5 f888 	bl	810e492 <lwip_htons>
 8119382:	4603      	mov	r3, r0
 8119384:	b2db      	uxtb	r3, r3
 8119386:	f003 0304 	and.w	r3, r3, #4
 811938a:	2b00      	cmp	r3, #0
 811938c:	d006      	beq.n	811939c <tcp_output+0x188>
 811938e:	4b2f      	ldr	r3, [pc, #188]	; (811944c <tcp_output+0x238>)
 8119390:	f240 5236 	movw	r2, #1334	; 0x536
 8119394:	4932      	ldr	r1, [pc, #200]	; (8119460 <tcp_output+0x24c>)
 8119396:	482f      	ldr	r0, [pc, #188]	; (8119454 <tcp_output+0x240>)
 8119398:	f002 fa32 	bl	811b800 <iprintf>
     * - if tcp_write had a memory error before (prevent delayed ACK timeout) or
     * - if FIN was already enqueued for this PCB (SYN is always alone in a segment -
     *   either seg->next != NULL or pcb->unacked == NULL;
     *   RST is no sent using tcp_write/tcp_output.
     */
    if ((tcp_do_output_nagle(pcb) == 0) &&
 811939c:	687b      	ldr	r3, [r7, #4]
 811939e:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 81193a0:	2b00      	cmp	r3, #0
 81193a2:	d01f      	beq.n	81193e4 <tcp_output+0x1d0>
 81193a4:	687b      	ldr	r3, [r7, #4]
 81193a6:	8b5b      	ldrh	r3, [r3, #26]
 81193a8:	f003 0344 	and.w	r3, r3, #68	; 0x44
 81193ac:	2b00      	cmp	r3, #0
 81193ae:	d119      	bne.n	81193e4 <tcp_output+0x1d0>
 81193b0:	687b      	ldr	r3, [r7, #4]
 81193b2:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 81193b4:	2b00      	cmp	r3, #0
 81193b6:	d00b      	beq.n	81193d0 <tcp_output+0x1bc>
 81193b8:	687b      	ldr	r3, [r7, #4]
 81193ba:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 81193bc:	681b      	ldr	r3, [r3, #0]
 81193be:	2b00      	cmp	r3, #0
 81193c0:	d110      	bne.n	81193e4 <tcp_output+0x1d0>
 81193c2:	687b      	ldr	r3, [r7, #4]
 81193c4:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 81193c6:	891a      	ldrh	r2, [r3, #8]
 81193c8:	687b      	ldr	r3, [r7, #4]
 81193ca:	8e5b      	ldrh	r3, [r3, #50]	; 0x32
 81193cc:	429a      	cmp	r2, r3
 81193ce:	d209      	bcs.n	81193e4 <tcp_output+0x1d0>
 81193d0:	687b      	ldr	r3, [r7, #4]
 81193d2:	f8b3 3064 	ldrh.w	r3, [r3, #100]	; 0x64
 81193d6:	2b00      	cmp	r3, #0
 81193d8:	d004      	beq.n	81193e4 <tcp_output+0x1d0>
 81193da:	687b      	ldr	r3, [r7, #4]
 81193dc:	f8b3 3066 	ldrh.w	r3, [r3, #102]	; 0x66
 81193e0:	2b08      	cmp	r3, #8
 81193e2:	d901      	bls.n	81193e8 <tcp_output+0x1d4>
 81193e4:	2301      	movs	r3, #1
 81193e6:	e000      	b.n	81193ea <tcp_output+0x1d6>
 81193e8:	2300      	movs	r3, #0
 81193ea:	2b00      	cmp	r3, #0
 81193ec:	d106      	bne.n	81193fc <tcp_output+0x1e8>
        ((pcb->flags & (TF_NAGLEMEMERR | TF_FIN)) == 0)) {
 81193ee:	687b      	ldr	r3, [r7, #4]
 81193f0:	8b5b      	ldrh	r3, [r3, #26]
 81193f2:	f003 03a0 	and.w	r3, r3, #160	; 0xa0
    if ((tcp_do_output_nagle(pcb) == 0) &&
 81193f6:	2b00      	cmp	r3, #0
 81193f8:	f000 80e4 	beq.w	81195c4 <tcp_output+0x3b0>
                                 pcb->lastack,
                                 lwip_ntohl(seg->tcphdr->seqno), pcb->lastack, i));
    ++i;
#endif /* TCP_CWND_DEBUG */

    if (pcb->state != SYN_SENT) {
 81193fc:	687b      	ldr	r3, [r7, #4]
 81193fe:	7d1b      	ldrb	r3, [r3, #20]
 8119400:	2b02      	cmp	r3, #2
 8119402:	d00d      	beq.n	8119420 <tcp_output+0x20c>
      TCPH_SET_FLAG(seg->tcphdr, TCP_ACK);
 8119404:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8119406:	68db      	ldr	r3, [r3, #12]
 8119408:	899b      	ldrh	r3, [r3, #12]
 811940a:	b29c      	uxth	r4, r3
 811940c:	2010      	movs	r0, #16
 811940e:	f7f5 f840 	bl	810e492 <lwip_htons>
 8119412:	4603      	mov	r3, r0
 8119414:	461a      	mov	r2, r3
 8119416:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8119418:	68db      	ldr	r3, [r3, #12]
 811941a:	4322      	orrs	r2, r4
 811941c:	b292      	uxth	r2, r2
 811941e:	819a      	strh	r2, [r3, #12]
    }

    err = tcp_output_segment(seg, pcb, netif);
 8119420:	697a      	ldr	r2, [r7, #20]
 8119422:	6879      	ldr	r1, [r7, #4]
 8119424:	6a78      	ldr	r0, [r7, #36]	; 0x24
 8119426:	f000 f909 	bl	811963c <tcp_output_segment>
 811942a:	4603      	mov	r3, r0
 811942c:	73fb      	strb	r3, [r7, #15]
    if (err != ERR_OK) {
 811942e:	f997 300f 	ldrsb.w	r3, [r7, #15]
 8119432:	2b00      	cmp	r3, #0
 8119434:	d016      	beq.n	8119464 <tcp_output+0x250>
      /* segment could not be sent, for whatever reason */
      tcp_set_flags(pcb, TF_NAGLEMEMERR);
 8119436:	687b      	ldr	r3, [r7, #4]
 8119438:	8b5b      	ldrh	r3, [r3, #26]
 811943a:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 811943e:	b29a      	uxth	r2, r3
 8119440:	687b      	ldr	r3, [r7, #4]
 8119442:	835a      	strh	r2, [r3, #26]
      return err;
 8119444:	f997 300f 	ldrsb.w	r3, [r7, #15]
 8119448:	e0d3      	b.n	81195f2 <tcp_output+0x3de>
 811944a:	bf00      	nop
 811944c:	0811eb98 	.word	0x0811eb98
 8119450:	0811f110 	.word	0x0811f110
 8119454:	0811ec20 	.word	0x0811ec20
 8119458:	0811f128 	.word	0x0811f128
 811945c:	10008494 	.word	0x10008494
 8119460:	0811f150 	.word	0x0811f150
    }
#if TCP_OVERSIZE_DBGCHECK
    seg->oversize_left = 0;
#endif /* TCP_OVERSIZE_DBGCHECK */
    pcb->unsent = seg->next;
 8119464:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8119466:	681a      	ldr	r2, [r3, #0]
 8119468:	687b      	ldr	r3, [r7, #4]
 811946a:	66da      	str	r2, [r3, #108]	; 0x6c
    if (pcb->state != SYN_SENT) {
 811946c:	687b      	ldr	r3, [r7, #4]
 811946e:	7d1b      	ldrb	r3, [r3, #20]
 8119470:	2b02      	cmp	r3, #2
 8119472:	d006      	beq.n	8119482 <tcp_output+0x26e>
      tcp_clear_flags(pcb, TF_ACK_DELAY | TF_ACK_NOW);
 8119474:	687b      	ldr	r3, [r7, #4]
 8119476:	8b5b      	ldrh	r3, [r3, #26]
 8119478:	f023 0303 	bic.w	r3, r3, #3
 811947c:	b29a      	uxth	r2, r3
 811947e:	687b      	ldr	r3, [r7, #4]
 8119480:	835a      	strh	r2, [r3, #26]
    }
    snd_nxt = lwip_ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg);
 8119482:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8119484:	68db      	ldr	r3, [r3, #12]
 8119486:	685b      	ldr	r3, [r3, #4]
 8119488:	4618      	mov	r0, r3
 811948a:	f7f5 f817 	bl	810e4bc <lwip_htonl>
 811948e:	4604      	mov	r4, r0
 8119490:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8119492:	891b      	ldrh	r3, [r3, #8]
 8119494:	461d      	mov	r5, r3
 8119496:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8119498:	68db      	ldr	r3, [r3, #12]
 811949a:	899b      	ldrh	r3, [r3, #12]
 811949c:	b29b      	uxth	r3, r3
 811949e:	4618      	mov	r0, r3
 81194a0:	f7f4 fff7 	bl	810e492 <lwip_htons>
 81194a4:	4603      	mov	r3, r0
 81194a6:	b2db      	uxtb	r3, r3
 81194a8:	f003 0303 	and.w	r3, r3, #3
 81194ac:	2b00      	cmp	r3, #0
 81194ae:	d001      	beq.n	81194b4 <tcp_output+0x2a0>
 81194b0:	2301      	movs	r3, #1
 81194b2:	e000      	b.n	81194b6 <tcp_output+0x2a2>
 81194b4:	2300      	movs	r3, #0
 81194b6:	442b      	add	r3, r5
 81194b8:	4423      	add	r3, r4
 81194ba:	60bb      	str	r3, [r7, #8]
    if (TCP_SEQ_LT(pcb->snd_nxt, snd_nxt)) {
 81194bc:	687b      	ldr	r3, [r7, #4]
 81194be:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 81194c0:	68bb      	ldr	r3, [r7, #8]
 81194c2:	1ad3      	subs	r3, r2, r3
 81194c4:	2b00      	cmp	r3, #0
 81194c6:	da02      	bge.n	81194ce <tcp_output+0x2ba>
      pcb->snd_nxt = snd_nxt;
 81194c8:	687b      	ldr	r3, [r7, #4]
 81194ca:	68ba      	ldr	r2, [r7, #8]
 81194cc:	651a      	str	r2, [r3, #80]	; 0x50
    }
    /* put segment on unacknowledged list if length > 0 */
    if (TCP_TCPLEN(seg) > 0) {
 81194ce:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 81194d0:	891b      	ldrh	r3, [r3, #8]
 81194d2:	461c      	mov	r4, r3
 81194d4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 81194d6:	68db      	ldr	r3, [r3, #12]
 81194d8:	899b      	ldrh	r3, [r3, #12]
 81194da:	b29b      	uxth	r3, r3
 81194dc:	4618      	mov	r0, r3
 81194de:	f7f4 ffd8 	bl	810e492 <lwip_htons>
 81194e2:	4603      	mov	r3, r0
 81194e4:	b2db      	uxtb	r3, r3
 81194e6:	f003 0303 	and.w	r3, r3, #3
 81194ea:	2b00      	cmp	r3, #0
 81194ec:	d001      	beq.n	81194f2 <tcp_output+0x2de>
 81194ee:	2301      	movs	r3, #1
 81194f0:	e000      	b.n	81194f4 <tcp_output+0x2e0>
 81194f2:	2300      	movs	r3, #0
 81194f4:	4423      	add	r3, r4
 81194f6:	2b00      	cmp	r3, #0
 81194f8:	d049      	beq.n	811958e <tcp_output+0x37a>
      seg->next = NULL;
 81194fa:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 81194fc:	2200      	movs	r2, #0
 81194fe:	601a      	str	r2, [r3, #0]
      /* unacked list is empty? */
      if (pcb->unacked == NULL) {
 8119500:	687b      	ldr	r3, [r7, #4]
 8119502:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8119504:	2b00      	cmp	r3, #0
 8119506:	d105      	bne.n	8119514 <tcp_output+0x300>
        pcb->unacked = seg;
 8119508:	687b      	ldr	r3, [r7, #4]
 811950a:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 811950c:	671a      	str	r2, [r3, #112]	; 0x70
        useg = seg;
 811950e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8119510:	623b      	str	r3, [r7, #32]
 8119512:	e03f      	b.n	8119594 <tcp_output+0x380>
        /* unacked list is not empty? */
      } else {
        /* In the case of fast retransmit, the packet should not go to the tail
         * of the unacked queue, but rather somewhere before it. We need to check for
         * this case. -STJ Jul 27, 2004 */
        if (TCP_SEQ_LT(lwip_ntohl(seg->tcphdr->seqno), lwip_ntohl(useg->tcphdr->seqno))) {
 8119514:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8119516:	68db      	ldr	r3, [r3, #12]
 8119518:	685b      	ldr	r3, [r3, #4]
 811951a:	4618      	mov	r0, r3
 811951c:	f7f4 ffce 	bl	810e4bc <lwip_htonl>
 8119520:	4604      	mov	r4, r0
 8119522:	6a3b      	ldr	r3, [r7, #32]
 8119524:	68db      	ldr	r3, [r3, #12]
 8119526:	685b      	ldr	r3, [r3, #4]
 8119528:	4618      	mov	r0, r3
 811952a:	f7f4 ffc7 	bl	810e4bc <lwip_htonl>
 811952e:	4603      	mov	r3, r0
 8119530:	1ae3      	subs	r3, r4, r3
 8119532:	2b00      	cmp	r3, #0
 8119534:	da24      	bge.n	8119580 <tcp_output+0x36c>
          /* add segment to before tail of unacked list, keeping the list sorted */
          struct tcp_seg **cur_seg = &(pcb->unacked);
 8119536:	687b      	ldr	r3, [r7, #4]
 8119538:	3370      	adds	r3, #112	; 0x70
 811953a:	61fb      	str	r3, [r7, #28]
          while (*cur_seg &&
 811953c:	e002      	b.n	8119544 <tcp_output+0x330>
                 TCP_SEQ_LT(lwip_ntohl((*cur_seg)->tcphdr->seqno), lwip_ntohl(seg->tcphdr->seqno))) {
            cur_seg = &((*cur_seg)->next );
 811953e:	69fb      	ldr	r3, [r7, #28]
 8119540:	681b      	ldr	r3, [r3, #0]
 8119542:	61fb      	str	r3, [r7, #28]
          while (*cur_seg &&
 8119544:	69fb      	ldr	r3, [r7, #28]
 8119546:	681b      	ldr	r3, [r3, #0]
 8119548:	2b00      	cmp	r3, #0
 811954a:	d011      	beq.n	8119570 <tcp_output+0x35c>
                 TCP_SEQ_LT(lwip_ntohl((*cur_seg)->tcphdr->seqno), lwip_ntohl(seg->tcphdr->seqno))) {
 811954c:	69fb      	ldr	r3, [r7, #28]
 811954e:	681b      	ldr	r3, [r3, #0]
 8119550:	68db      	ldr	r3, [r3, #12]
 8119552:	685b      	ldr	r3, [r3, #4]
 8119554:	4618      	mov	r0, r3
 8119556:	f7f4 ffb1 	bl	810e4bc <lwip_htonl>
 811955a:	4604      	mov	r4, r0
 811955c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 811955e:	68db      	ldr	r3, [r3, #12]
 8119560:	685b      	ldr	r3, [r3, #4]
 8119562:	4618      	mov	r0, r3
 8119564:	f7f4 ffaa 	bl	810e4bc <lwip_htonl>
 8119568:	4603      	mov	r3, r0
 811956a:	1ae3      	subs	r3, r4, r3
          while (*cur_seg &&
 811956c:	2b00      	cmp	r3, #0
 811956e:	dbe6      	blt.n	811953e <tcp_output+0x32a>
          }
          seg->next = (*cur_seg);
 8119570:	69fb      	ldr	r3, [r7, #28]
 8119572:	681a      	ldr	r2, [r3, #0]
 8119574:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8119576:	601a      	str	r2, [r3, #0]
          (*cur_seg) = seg;
 8119578:	69fb      	ldr	r3, [r7, #28]
 811957a:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 811957c:	601a      	str	r2, [r3, #0]
 811957e:	e009      	b.n	8119594 <tcp_output+0x380>
        } else {
          /* add segment to tail of unacked list */
          useg->next = seg;
 8119580:	6a3b      	ldr	r3, [r7, #32]
 8119582:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8119584:	601a      	str	r2, [r3, #0]
          useg = useg->next;
 8119586:	6a3b      	ldr	r3, [r7, #32]
 8119588:	681b      	ldr	r3, [r3, #0]
 811958a:	623b      	str	r3, [r7, #32]
 811958c:	e002      	b.n	8119594 <tcp_output+0x380>
        }
      }
      /* do not queue empty segments on the unacked list */
    } else {
      tcp_seg_free(seg);
 811958e:	6a78      	ldr	r0, [r7, #36]	; 0x24
 8119590:	f7fc fc3f 	bl	8115e12 <tcp_seg_free>
    }
    seg = pcb->unsent;
 8119594:	687b      	ldr	r3, [r7, #4]
 8119596:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 8119598:	627b      	str	r3, [r7, #36]	; 0x24
  while (seg != NULL &&
 811959a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 811959c:	2b00      	cmp	r3, #0
 811959e:	d012      	beq.n	81195c6 <tcp_output+0x3b2>
         lwip_ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len <= wnd) {
 81195a0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 81195a2:	68db      	ldr	r3, [r3, #12]
 81195a4:	685b      	ldr	r3, [r3, #4]
 81195a6:	4618      	mov	r0, r3
 81195a8:	f7f4 ff88 	bl	810e4bc <lwip_htonl>
 81195ac:	4602      	mov	r2, r0
 81195ae:	687b      	ldr	r3, [r7, #4]
 81195b0:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 81195b2:	1ad3      	subs	r3, r2, r3
 81195b4:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 81195b6:	8912      	ldrh	r2, [r2, #8]
 81195b8:	4413      	add	r3, r2
  while (seg != NULL &&
 81195ba:	69ba      	ldr	r2, [r7, #24]
 81195bc:	429a      	cmp	r2, r3
 81195be:	f4bf aed9 	bcs.w	8119374 <tcp_output+0x160>
 81195c2:	e000      	b.n	81195c6 <tcp_output+0x3b2>
      break;
 81195c4:	bf00      	nop
  }
#if TCP_OVERSIZE
  if (pcb->unsent == NULL) {
 81195c6:	687b      	ldr	r3, [r7, #4]
 81195c8:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 81195ca:	2b00      	cmp	r3, #0
 81195cc:	d108      	bne.n	81195e0 <tcp_output+0x3cc>
    /* last unsent has been removed, reset unsent_oversize */
    pcb->unsent_oversize = 0;
 81195ce:	687b      	ldr	r3, [r7, #4]
 81195d0:	2200      	movs	r2, #0
 81195d2:	f8a3 2068 	strh.w	r2, [r3, #104]	; 0x68
 81195d6:	e004      	b.n	81195e2 <tcp_output+0x3ce>
    goto output_done;
 81195d8:	bf00      	nop
 81195da:	e002      	b.n	81195e2 <tcp_output+0x3ce>
    goto output_done;
 81195dc:	bf00      	nop
 81195de:	e000      	b.n	81195e2 <tcp_output+0x3ce>
  }
#endif /* TCP_OVERSIZE */

output_done:
 81195e0:	bf00      	nop
  tcp_clear_flags(pcb, TF_NAGLEMEMERR);
 81195e2:	687b      	ldr	r3, [r7, #4]
 81195e4:	8b5b      	ldrh	r3, [r3, #26]
 81195e6:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 81195ea:	b29a      	uxth	r2, r3
 81195ec:	687b      	ldr	r3, [r7, #4]
 81195ee:	835a      	strh	r2, [r3, #26]
  return ERR_OK;
 81195f0:	2300      	movs	r3, #0
}
 81195f2:	4618      	mov	r0, r3
 81195f4:	3728      	adds	r7, #40	; 0x28
 81195f6:	46bd      	mov	sp, r7
 81195f8:	bdb0      	pop	{r4, r5, r7, pc}
 81195fa:	bf00      	nop

081195fc <tcp_output_segment_busy>:
 * @arg seg the tcp segment to check
 * @return 1 if ref != 1, 0 if ref == 1
 */
static int
tcp_output_segment_busy(const struct tcp_seg *seg)
{
 81195fc:	b580      	push	{r7, lr}
 81195fe:	b082      	sub	sp, #8
 8119600:	af00      	add	r7, sp, #0
 8119602:	6078      	str	r0, [r7, #4]
  LWIP_ASSERT("tcp_output_segment_busy: invalid seg", seg != NULL);
 8119604:	687b      	ldr	r3, [r7, #4]
 8119606:	2b00      	cmp	r3, #0
 8119608:	d106      	bne.n	8119618 <tcp_output_segment_busy+0x1c>
 811960a:	4b09      	ldr	r3, [pc, #36]	; (8119630 <tcp_output_segment_busy+0x34>)
 811960c:	f240 529a 	movw	r2, #1434	; 0x59a
 8119610:	4908      	ldr	r1, [pc, #32]	; (8119634 <tcp_output_segment_busy+0x38>)
 8119612:	4809      	ldr	r0, [pc, #36]	; (8119638 <tcp_output_segment_busy+0x3c>)
 8119614:	f002 f8f4 	bl	811b800 <iprintf>

  /* We only need to check the first pbuf here:
     If a pbuf is queued for transmission, a driver calls pbuf_ref(),
     which only changes the ref count of the first pbuf */
  if (seg->p->ref != 1) {
 8119618:	687b      	ldr	r3, [r7, #4]
 811961a:	685b      	ldr	r3, [r3, #4]
 811961c:	7b9b      	ldrb	r3, [r3, #14]
 811961e:	2b01      	cmp	r3, #1
 8119620:	d001      	beq.n	8119626 <tcp_output_segment_busy+0x2a>
    /* other reference found */
    return 1;
 8119622:	2301      	movs	r3, #1
 8119624:	e000      	b.n	8119628 <tcp_output_segment_busy+0x2c>
  }
  /* no other references found */
  return 0;
 8119626:	2300      	movs	r3, #0
}
 8119628:	4618      	mov	r0, r3
 811962a:	3708      	adds	r7, #8
 811962c:	46bd      	mov	sp, r7
 811962e:	bd80      	pop	{r7, pc}
 8119630:	0811eb98 	.word	0x0811eb98
 8119634:	0811f168 	.word	0x0811f168
 8119638:	0811ec20 	.word	0x0811ec20

0811963c <tcp_output_segment>:
 * @param pcb the tcp_pcb for the TCP connection used to send the segment
 * @param netif the netif used to send the segment
 */
static err_t
tcp_output_segment(struct tcp_seg *seg, struct tcp_pcb *pcb, struct netif *netif)
{
 811963c:	b5b0      	push	{r4, r5, r7, lr}
 811963e:	b08c      	sub	sp, #48	; 0x30
 8119640:	af04      	add	r7, sp, #16
 8119642:	60f8      	str	r0, [r7, #12]
 8119644:	60b9      	str	r1, [r7, #8]
 8119646:	607a      	str	r2, [r7, #4]
  u32_t *opts;
#if TCP_CHECKSUM_ON_COPY
  int seg_chksum_was_swapped = 0;
#endif

  LWIP_ASSERT("tcp_output_segment: invalid seg", seg != NULL);
 8119648:	68fb      	ldr	r3, [r7, #12]
 811964a:	2b00      	cmp	r3, #0
 811964c:	d106      	bne.n	811965c <tcp_output_segment+0x20>
 811964e:	4b64      	ldr	r3, [pc, #400]	; (81197e0 <tcp_output_segment+0x1a4>)
 8119650:	f44f 62b7 	mov.w	r2, #1464	; 0x5b8
 8119654:	4963      	ldr	r1, [pc, #396]	; (81197e4 <tcp_output_segment+0x1a8>)
 8119656:	4864      	ldr	r0, [pc, #400]	; (81197e8 <tcp_output_segment+0x1ac>)
 8119658:	f002 f8d2 	bl	811b800 <iprintf>
  LWIP_ASSERT("tcp_output_segment: invalid pcb", pcb != NULL);
 811965c:	68bb      	ldr	r3, [r7, #8]
 811965e:	2b00      	cmp	r3, #0
 8119660:	d106      	bne.n	8119670 <tcp_output_segment+0x34>
 8119662:	4b5f      	ldr	r3, [pc, #380]	; (81197e0 <tcp_output_segment+0x1a4>)
 8119664:	f240 52b9 	movw	r2, #1465	; 0x5b9
 8119668:	4960      	ldr	r1, [pc, #384]	; (81197ec <tcp_output_segment+0x1b0>)
 811966a:	485f      	ldr	r0, [pc, #380]	; (81197e8 <tcp_output_segment+0x1ac>)
 811966c:	f002 f8c8 	bl	811b800 <iprintf>
  LWIP_ASSERT("tcp_output_segment: invalid netif", netif != NULL);
 8119670:	687b      	ldr	r3, [r7, #4]
 8119672:	2b00      	cmp	r3, #0
 8119674:	d106      	bne.n	8119684 <tcp_output_segment+0x48>
 8119676:	4b5a      	ldr	r3, [pc, #360]	; (81197e0 <tcp_output_segment+0x1a4>)
 8119678:	f240 52ba 	movw	r2, #1466	; 0x5ba
 811967c:	495c      	ldr	r1, [pc, #368]	; (81197f0 <tcp_output_segment+0x1b4>)
 811967e:	485a      	ldr	r0, [pc, #360]	; (81197e8 <tcp_output_segment+0x1ac>)
 8119680:	f002 f8be 	bl	811b800 <iprintf>

  if (tcp_output_segment_busy(seg)) {
 8119684:	68f8      	ldr	r0, [r7, #12]
 8119686:	f7ff ffb9 	bl	81195fc <tcp_output_segment_busy>
 811968a:	4603      	mov	r3, r0
 811968c:	2b00      	cmp	r3, #0
 811968e:	d001      	beq.n	8119694 <tcp_output_segment+0x58>
    /* This should not happen: rexmit functions should have checked this.
       However, since this function modifies p->len, we must not continue in this case. */
    LWIP_DEBUGF(TCP_RTO_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("tcp_output_segment: segment busy\n"));
    return ERR_OK;
 8119690:	2300      	movs	r3, #0
 8119692:	e0a1      	b.n	81197d8 <tcp_output_segment+0x19c>
  }

  /* The TCP header has already been constructed, but the ackno and
   wnd fields remain. */
  seg->tcphdr->ackno = lwip_htonl(pcb->rcv_nxt);
 8119694:	68bb      	ldr	r3, [r7, #8]
 8119696:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8119698:	68fb      	ldr	r3, [r7, #12]
 811969a:	68dc      	ldr	r4, [r3, #12]
 811969c:	4610      	mov	r0, r2
 811969e:	f7f4 ff0d 	bl	810e4bc <lwip_htonl>
 81196a2:	4603      	mov	r3, r0
 81196a4:	60a3      	str	r3, [r4, #8]
       the window scale option) is never scaled. */
    seg->tcphdr->wnd = lwip_htons(TCPWND_MIN16(pcb->rcv_ann_wnd));
  } else
#endif /* LWIP_WND_SCALE */
  {
    seg->tcphdr->wnd = lwip_htons(TCPWND_MIN16(RCV_WND_SCALE(pcb, pcb->rcv_ann_wnd)));
 81196a6:	68bb      	ldr	r3, [r7, #8]
 81196a8:	8d5a      	ldrh	r2, [r3, #42]	; 0x2a
 81196aa:	68fb      	ldr	r3, [r7, #12]
 81196ac:	68dc      	ldr	r4, [r3, #12]
 81196ae:	4610      	mov	r0, r2
 81196b0:	f7f4 feef 	bl	810e492 <lwip_htons>
 81196b4:	4603      	mov	r3, r0
 81196b6:	81e3      	strh	r3, [r4, #14]
  }

  pcb->rcv_ann_right_edge = pcb->rcv_nxt + pcb->rcv_ann_wnd;
 81196b8:	68bb      	ldr	r3, [r7, #8]
 81196ba:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 81196bc:	68ba      	ldr	r2, [r7, #8]
 81196be:	8d52      	ldrh	r2, [r2, #42]	; 0x2a
 81196c0:	441a      	add	r2, r3
 81196c2:	68bb      	ldr	r3, [r7, #8]
 81196c4:	62da      	str	r2, [r3, #44]	; 0x2c

  /* Add any requested options.  NB MSS option is only set on SYN
     packets, so ignore it here */
  /* cast through void* to get rid of alignment warnings */
  opts = (u32_t *)(void *)(seg->tcphdr + 1);
 81196c6:	68fb      	ldr	r3, [r7, #12]
 81196c8:	68db      	ldr	r3, [r3, #12]
 81196ca:	3314      	adds	r3, #20
 81196cc:	61fb      	str	r3, [r7, #28]
  if (seg->flags & TF_SEG_OPTS_MSS) {
 81196ce:	68fb      	ldr	r3, [r7, #12]
 81196d0:	7a9b      	ldrb	r3, [r3, #10]
 81196d2:	f003 0301 	and.w	r3, r3, #1
 81196d6:	2b00      	cmp	r3, #0
 81196d8:	d015      	beq.n	8119706 <tcp_output_segment+0xca>
    u16_t mss;
#if TCP_CALCULATE_EFF_SEND_MSS
    mss = tcp_eff_send_mss_netif(TCP_MSS, netif, &pcb->remote_ip);
 81196da:	68bb      	ldr	r3, [r7, #8]
 81196dc:	3304      	adds	r3, #4
 81196de:	461a      	mov	r2, r3
 81196e0:	6879      	ldr	r1, [r7, #4]
 81196e2:	f44f 7006 	mov.w	r0, #536	; 0x218
 81196e6:	f7fc fe8b 	bl	8116400 <tcp_eff_send_mss_netif>
 81196ea:	4603      	mov	r3, r0
 81196ec:	837b      	strh	r3, [r7, #26]
#else /* TCP_CALCULATE_EFF_SEND_MSS */
    mss = TCP_MSS;
#endif /* TCP_CALCULATE_EFF_SEND_MSS */
    *opts = TCP_BUILD_MSS_OPTION(mss);
 81196ee:	8b7b      	ldrh	r3, [r7, #26]
 81196f0:	f043 7301 	orr.w	r3, r3, #33816576	; 0x2040000
 81196f4:	4618      	mov	r0, r3
 81196f6:	f7f4 fee1 	bl	810e4bc <lwip_htonl>
 81196fa:	4602      	mov	r2, r0
 81196fc:	69fb      	ldr	r3, [r7, #28]
 81196fe:	601a      	str	r2, [r3, #0]
    opts += 1;
 8119700:	69fb      	ldr	r3, [r7, #28]
 8119702:	3304      	adds	r3, #4
 8119704:	61fb      	str	r3, [r7, #28]
  }
#endif

  /* Set retransmission timer running if it is not currently enabled
     This must be set before checking the route. */
  if (pcb->rtime < 0) {
 8119706:	68bb      	ldr	r3, [r7, #8]
 8119708:	f9b3 3030 	ldrsh.w	r3, [r3, #48]	; 0x30
 811970c:	2b00      	cmp	r3, #0
 811970e:	da02      	bge.n	8119716 <tcp_output_segment+0xda>
    pcb->rtime = 0;
 8119710:	68bb      	ldr	r3, [r7, #8]
 8119712:	2200      	movs	r2, #0
 8119714:	861a      	strh	r2, [r3, #48]	; 0x30
  }

  if (pcb->rttest == 0) {
 8119716:	68bb      	ldr	r3, [r7, #8]
 8119718:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 811971a:	2b00      	cmp	r3, #0
 811971c:	d10c      	bne.n	8119738 <tcp_output_segment+0xfc>
    pcb->rttest = tcp_ticks;
 811971e:	4b35      	ldr	r3, [pc, #212]	; (81197f4 <tcp_output_segment+0x1b8>)
 8119720:	681a      	ldr	r2, [r3, #0]
 8119722:	68bb      	ldr	r3, [r7, #8]
 8119724:	635a      	str	r2, [r3, #52]	; 0x34
    pcb->rtseq = lwip_ntohl(seg->tcphdr->seqno);
 8119726:	68fb      	ldr	r3, [r7, #12]
 8119728:	68db      	ldr	r3, [r3, #12]
 811972a:	685b      	ldr	r3, [r3, #4]
 811972c:	4618      	mov	r0, r3
 811972e:	f7f4 fec5 	bl	810e4bc <lwip_htonl>
 8119732:	4602      	mov	r2, r0
 8119734:	68bb      	ldr	r3, [r7, #8]
 8119736:	639a      	str	r2, [r3, #56]	; 0x38
  }
  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output_segment: %"U32_F":%"U32_F"\n",
                                 lwip_htonl(seg->tcphdr->seqno), lwip_htonl(seg->tcphdr->seqno) +
                                 seg->len));

  len = (u16_t)((u8_t *)seg->tcphdr - (u8_t *)seg->p->payload);
 8119738:	68fb      	ldr	r3, [r7, #12]
 811973a:	68da      	ldr	r2, [r3, #12]
 811973c:	68fb      	ldr	r3, [r7, #12]
 811973e:	685b      	ldr	r3, [r3, #4]
 8119740:	685b      	ldr	r3, [r3, #4]
 8119742:	1ad3      	subs	r3, r2, r3
 8119744:	833b      	strh	r3, [r7, #24]
  if (len == 0) {
    /** Exclude retransmitted segments from this count. */
    MIB2_STATS_INC(mib2.tcpoutsegs);
  }

  seg->p->len -= len;
 8119746:	68fb      	ldr	r3, [r7, #12]
 8119748:	685b      	ldr	r3, [r3, #4]
 811974a:	8959      	ldrh	r1, [r3, #10]
 811974c:	68fb      	ldr	r3, [r7, #12]
 811974e:	685b      	ldr	r3, [r3, #4]
 8119750:	8b3a      	ldrh	r2, [r7, #24]
 8119752:	1a8a      	subs	r2, r1, r2
 8119754:	b292      	uxth	r2, r2
 8119756:	815a      	strh	r2, [r3, #10]
  seg->p->tot_len -= len;
 8119758:	68fb      	ldr	r3, [r7, #12]
 811975a:	685b      	ldr	r3, [r3, #4]
 811975c:	8919      	ldrh	r1, [r3, #8]
 811975e:	68fb      	ldr	r3, [r7, #12]
 8119760:	685b      	ldr	r3, [r3, #4]
 8119762:	8b3a      	ldrh	r2, [r7, #24]
 8119764:	1a8a      	subs	r2, r1, r2
 8119766:	b292      	uxth	r2, r2
 8119768:	811a      	strh	r2, [r3, #8]

  seg->p->payload = seg->tcphdr;
 811976a:	68fb      	ldr	r3, [r7, #12]
 811976c:	685b      	ldr	r3, [r3, #4]
 811976e:	68fa      	ldr	r2, [r7, #12]
 8119770:	68d2      	ldr	r2, [r2, #12]
 8119772:	605a      	str	r2, [r3, #4]

  seg->tcphdr->chksum = 0;
 8119774:	68fb      	ldr	r3, [r7, #12]
 8119776:	68db      	ldr	r3, [r3, #12]
 8119778:	2200      	movs	r2, #0
 811977a:	741a      	strb	r2, [r3, #16]
 811977c:	2200      	movs	r2, #0
 811977e:	745a      	strb	r2, [r3, #17]

#ifdef LWIP_HOOK_TCP_OUT_ADD_TCPOPTS
  opts = LWIP_HOOK_TCP_OUT_ADD_TCPOPTS(seg->p, seg->tcphdr, pcb, opts);
#endif
  LWIP_ASSERT("options not filled", (u8_t *)opts == ((u8_t *)(seg->tcphdr + 1)) + LWIP_TCP_OPT_LENGTH_SEGMENT(seg->flags, pcb));
 8119780:	68fb      	ldr	r3, [r7, #12]
 8119782:	68da      	ldr	r2, [r3, #12]
 8119784:	68fb      	ldr	r3, [r7, #12]
 8119786:	7a9b      	ldrb	r3, [r3, #10]
 8119788:	f003 0301 	and.w	r3, r3, #1
 811978c:	2b00      	cmp	r3, #0
 811978e:	d001      	beq.n	8119794 <tcp_output_segment+0x158>
 8119790:	2318      	movs	r3, #24
 8119792:	e000      	b.n	8119796 <tcp_output_segment+0x15a>
 8119794:	2314      	movs	r3, #20
 8119796:	4413      	add	r3, r2
 8119798:	69fa      	ldr	r2, [r7, #28]
 811979a:	429a      	cmp	r2, r3
 811979c:	d006      	beq.n	81197ac <tcp_output_segment+0x170>
 811979e:	4b10      	ldr	r3, [pc, #64]	; (81197e0 <tcp_output_segment+0x1a4>)
 81197a0:	f240 621c 	movw	r2, #1564	; 0x61c
 81197a4:	4914      	ldr	r1, [pc, #80]	; (81197f8 <tcp_output_segment+0x1bc>)
 81197a6:	4810      	ldr	r0, [pc, #64]	; (81197e8 <tcp_output_segment+0x1ac>)
 81197a8:	f002 f82a 	bl	811b800 <iprintf>
  }
#endif /* CHECKSUM_GEN_TCP */
  TCP_STATS_INC(tcp.xmit);

  NETIF_SET_HINTS(netif, &(pcb->netif_hints));
  err = ip_output_if(seg->p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl,
 81197ac:	68fb      	ldr	r3, [r7, #12]
 81197ae:	6858      	ldr	r0, [r3, #4]
 81197b0:	68b9      	ldr	r1, [r7, #8]
 81197b2:	68bb      	ldr	r3, [r7, #8]
 81197b4:	1d1c      	adds	r4, r3, #4
 81197b6:	68bb      	ldr	r3, [r7, #8]
 81197b8:	7add      	ldrb	r5, [r3, #11]
 81197ba:	68bb      	ldr	r3, [r7, #8]
 81197bc:	7a9b      	ldrb	r3, [r3, #10]
 81197be:	687a      	ldr	r2, [r7, #4]
 81197c0:	9202      	str	r2, [sp, #8]
 81197c2:	2206      	movs	r2, #6
 81197c4:	9201      	str	r2, [sp, #4]
 81197c6:	9300      	str	r3, [sp, #0]
 81197c8:	462b      	mov	r3, r5
 81197ca:	4622      	mov	r2, r4
 81197cc:	f7f8 fcea 	bl	81121a4 <ip4_output_if>
 81197d0:	4603      	mov	r3, r0
 81197d2:	75fb      	strb	r3, [r7, #23]
    seg->chksum = SWAP_BYTES_IN_WORD(seg->chksum);
    seg->chksum_swapped = 1;
  }
#endif

  return err;
 81197d4:	f997 3017 	ldrsb.w	r3, [r7, #23]
}
 81197d8:	4618      	mov	r0, r3
 81197da:	3720      	adds	r7, #32
 81197dc:	46bd      	mov	sp, r7
 81197de:	bdb0      	pop	{r4, r5, r7, pc}
 81197e0:	0811eb98 	.word	0x0811eb98
 81197e4:	0811f190 	.word	0x0811f190
 81197e8:	0811ec20 	.word	0x0811ec20
 81197ec:	0811f1b0 	.word	0x0811f1b0
 81197f0:	0811f1d0 	.word	0x0811f1d0
 81197f4:	10008448 	.word	0x10008448
 81197f8:	0811f1f4 	.word	0x0811f1f4

081197fc <tcp_rexmit_rto_prepare>:
 *
 * @param pcb the tcp_pcb for which to re-enqueue all unacked segments
 */
err_t
tcp_rexmit_rto_prepare(struct tcp_pcb *pcb)
{
 81197fc:	b5b0      	push	{r4, r5, r7, lr}
 81197fe:	b084      	sub	sp, #16
 8119800:	af00      	add	r7, sp, #0
 8119802:	6078      	str	r0, [r7, #4]
  struct tcp_seg *seg;

  LWIP_ASSERT("tcp_rexmit_rto_prepare: invalid pcb", pcb != NULL);
 8119804:	687b      	ldr	r3, [r7, #4]
 8119806:	2b00      	cmp	r3, #0
 8119808:	d106      	bne.n	8119818 <tcp_rexmit_rto_prepare+0x1c>
 811980a:	4b31      	ldr	r3, [pc, #196]	; (81198d0 <tcp_rexmit_rto_prepare+0xd4>)
 811980c:	f240 6263 	movw	r2, #1635	; 0x663
 8119810:	4930      	ldr	r1, [pc, #192]	; (81198d4 <tcp_rexmit_rto_prepare+0xd8>)
 8119812:	4831      	ldr	r0, [pc, #196]	; (81198d8 <tcp_rexmit_rto_prepare+0xdc>)
 8119814:	f001 fff4 	bl	811b800 <iprintf>

  if (pcb->unacked == NULL) {
 8119818:	687b      	ldr	r3, [r7, #4]
 811981a:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 811981c:	2b00      	cmp	r3, #0
 811981e:	d102      	bne.n	8119826 <tcp_rexmit_rto_prepare+0x2a>
    return ERR_VAL;
 8119820:	f06f 0305 	mvn.w	r3, #5
 8119824:	e050      	b.n	81198c8 <tcp_rexmit_rto_prepare+0xcc>

  /* Move all unacked segments to the head of the unsent queue.
     However, give up if any of the unsent pbufs are still referenced by the
     netif driver due to deferred transmission. No point loading the link further
     if it is struggling to flush its buffered writes. */
  for (seg = pcb->unacked; seg->next != NULL; seg = seg->next) {
 8119826:	687b      	ldr	r3, [r7, #4]
 8119828:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 811982a:	60fb      	str	r3, [r7, #12]
 811982c:	e00b      	b.n	8119846 <tcp_rexmit_rto_prepare+0x4a>
    if (tcp_output_segment_busy(seg)) {
 811982e:	68f8      	ldr	r0, [r7, #12]
 8119830:	f7ff fee4 	bl	81195fc <tcp_output_segment_busy>
 8119834:	4603      	mov	r3, r0
 8119836:	2b00      	cmp	r3, #0
 8119838:	d002      	beq.n	8119840 <tcp_rexmit_rto_prepare+0x44>
      LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_rexmit_rto: segment busy\n"));
      return ERR_VAL;
 811983a:	f06f 0305 	mvn.w	r3, #5
 811983e:	e043      	b.n	81198c8 <tcp_rexmit_rto_prepare+0xcc>
  for (seg = pcb->unacked; seg->next != NULL; seg = seg->next) {
 8119840:	68fb      	ldr	r3, [r7, #12]
 8119842:	681b      	ldr	r3, [r3, #0]
 8119844:	60fb      	str	r3, [r7, #12]
 8119846:	68fb      	ldr	r3, [r7, #12]
 8119848:	681b      	ldr	r3, [r3, #0]
 811984a:	2b00      	cmp	r3, #0
 811984c:	d1ef      	bne.n	811982e <tcp_rexmit_rto_prepare+0x32>
    }
  }
  if (tcp_output_segment_busy(seg)) {
 811984e:	68f8      	ldr	r0, [r7, #12]
 8119850:	f7ff fed4 	bl	81195fc <tcp_output_segment_busy>
 8119854:	4603      	mov	r3, r0
 8119856:	2b00      	cmp	r3, #0
 8119858:	d002      	beq.n	8119860 <tcp_rexmit_rto_prepare+0x64>
    LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_rexmit_rto: segment busy\n"));
    return ERR_VAL;
 811985a:	f06f 0305 	mvn.w	r3, #5
 811985e:	e033      	b.n	81198c8 <tcp_rexmit_rto_prepare+0xcc>
  }
  /* concatenate unsent queue after unacked queue */
  seg->next = pcb->unsent;
 8119860:	687b      	ldr	r3, [r7, #4]
 8119862:	6eda      	ldr	r2, [r3, #108]	; 0x6c
 8119864:	68fb      	ldr	r3, [r7, #12]
 8119866:	601a      	str	r2, [r3, #0]
  if (pcb->unsent == NULL) {
    pcb->unsent_oversize = seg->oversize_left;
  }
#endif /* TCP_OVERSIZE_DBGCHECK */
  /* unsent queue is the concatenated queue (of unacked, unsent) */
  pcb->unsent = pcb->unacked;
 8119868:	687b      	ldr	r3, [r7, #4]
 811986a:	6f1a      	ldr	r2, [r3, #112]	; 0x70
 811986c:	687b      	ldr	r3, [r7, #4]
 811986e:	66da      	str	r2, [r3, #108]	; 0x6c
  /* unacked queue is now empty */
  pcb->unacked = NULL;
 8119870:	687b      	ldr	r3, [r7, #4]
 8119872:	2200      	movs	r2, #0
 8119874:	671a      	str	r2, [r3, #112]	; 0x70

  /* Mark RTO in-progress */
  tcp_set_flags(pcb, TF_RTO);
 8119876:	687b      	ldr	r3, [r7, #4]
 8119878:	8b5b      	ldrh	r3, [r3, #26]
 811987a:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
 811987e:	b29a      	uxth	r2, r3
 8119880:	687b      	ldr	r3, [r7, #4]
 8119882:	835a      	strh	r2, [r3, #26]
  /* Record the next byte following retransmit */
  pcb->rto_end = lwip_ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg);
 8119884:	68fb      	ldr	r3, [r7, #12]
 8119886:	68db      	ldr	r3, [r3, #12]
 8119888:	685b      	ldr	r3, [r3, #4]
 811988a:	4618      	mov	r0, r3
 811988c:	f7f4 fe16 	bl	810e4bc <lwip_htonl>
 8119890:	4604      	mov	r4, r0
 8119892:	68fb      	ldr	r3, [r7, #12]
 8119894:	891b      	ldrh	r3, [r3, #8]
 8119896:	461d      	mov	r5, r3
 8119898:	68fb      	ldr	r3, [r7, #12]
 811989a:	68db      	ldr	r3, [r3, #12]
 811989c:	899b      	ldrh	r3, [r3, #12]
 811989e:	b29b      	uxth	r3, r3
 81198a0:	4618      	mov	r0, r3
 81198a2:	f7f4 fdf6 	bl	810e492 <lwip_htons>
 81198a6:	4603      	mov	r3, r0
 81198a8:	b2db      	uxtb	r3, r3
 81198aa:	f003 0303 	and.w	r3, r3, #3
 81198ae:	2b00      	cmp	r3, #0
 81198b0:	d001      	beq.n	81198b6 <tcp_rexmit_rto_prepare+0xba>
 81198b2:	2301      	movs	r3, #1
 81198b4:	e000      	b.n	81198b8 <tcp_rexmit_rto_prepare+0xbc>
 81198b6:	2300      	movs	r3, #0
 81198b8:	442b      	add	r3, r5
 81198ba:	18e2      	adds	r2, r4, r3
 81198bc:	687b      	ldr	r3, [r7, #4]
 81198be:	64da      	str	r2, [r3, #76]	; 0x4c
  /* Don't take any RTT measurements after retransmitting. */
  pcb->rttest = 0;
 81198c0:	687b      	ldr	r3, [r7, #4]
 81198c2:	2200      	movs	r2, #0
 81198c4:	635a      	str	r2, [r3, #52]	; 0x34

  return ERR_OK;
 81198c6:	2300      	movs	r3, #0
}
 81198c8:	4618      	mov	r0, r3
 81198ca:	3710      	adds	r7, #16
 81198cc:	46bd      	mov	sp, r7
 81198ce:	bdb0      	pop	{r4, r5, r7, pc}
 81198d0:	0811eb98 	.word	0x0811eb98
 81198d4:	0811f208 	.word	0x0811f208
 81198d8:	0811ec20 	.word	0x0811ec20

081198dc <tcp_rexmit_rto_commit>:
 *
 * @param pcb the tcp_pcb for which to re-enqueue all unacked segments
 */
void
tcp_rexmit_rto_commit(struct tcp_pcb *pcb)
{
 81198dc:	b580      	push	{r7, lr}
 81198de:	b082      	sub	sp, #8
 81198e0:	af00      	add	r7, sp, #0
 81198e2:	6078      	str	r0, [r7, #4]
  LWIP_ASSERT("tcp_rexmit_rto_commit: invalid pcb", pcb != NULL);
 81198e4:	687b      	ldr	r3, [r7, #4]
 81198e6:	2b00      	cmp	r3, #0
 81198e8:	d106      	bne.n	81198f8 <tcp_rexmit_rto_commit+0x1c>
 81198ea:	4b0d      	ldr	r3, [pc, #52]	; (8119920 <tcp_rexmit_rto_commit+0x44>)
 81198ec:	f44f 62d3 	mov.w	r2, #1688	; 0x698
 81198f0:	490c      	ldr	r1, [pc, #48]	; (8119924 <tcp_rexmit_rto_commit+0x48>)
 81198f2:	480d      	ldr	r0, [pc, #52]	; (8119928 <tcp_rexmit_rto_commit+0x4c>)
 81198f4:	f001 ff84 	bl	811b800 <iprintf>

  /* increment number of retransmissions */
  if (pcb->nrtx < 0xFF) {
 81198f8:	687b      	ldr	r3, [r7, #4]
 81198fa:	f893 3042 	ldrb.w	r3, [r3, #66]	; 0x42
 81198fe:	2bff      	cmp	r3, #255	; 0xff
 8119900:	d007      	beq.n	8119912 <tcp_rexmit_rto_commit+0x36>
    ++pcb->nrtx;
 8119902:	687b      	ldr	r3, [r7, #4]
 8119904:	f893 3042 	ldrb.w	r3, [r3, #66]	; 0x42
 8119908:	3301      	adds	r3, #1
 811990a:	b2da      	uxtb	r2, r3
 811990c:	687b      	ldr	r3, [r7, #4]
 811990e:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
  }
  /* Do the actual retransmission */
  tcp_output(pcb);
 8119912:	6878      	ldr	r0, [r7, #4]
 8119914:	f7ff fc7e 	bl	8119214 <tcp_output>
}
 8119918:	bf00      	nop
 811991a:	3708      	adds	r7, #8
 811991c:	46bd      	mov	sp, r7
 811991e:	bd80      	pop	{r7, pc}
 8119920:	0811eb98 	.word	0x0811eb98
 8119924:	0811f22c 	.word	0x0811f22c
 8119928:	0811ec20 	.word	0x0811ec20

0811992c <tcp_rexmit_rto>:
 *
 * @param pcb the tcp_pcb for which to re-enqueue all unacked segments
 */
void
tcp_rexmit_rto(struct tcp_pcb *pcb)
{
 811992c:	b580      	push	{r7, lr}
 811992e:	b082      	sub	sp, #8
 8119930:	af00      	add	r7, sp, #0
 8119932:	6078      	str	r0, [r7, #4]
  LWIP_ASSERT("tcp_rexmit_rto: invalid pcb", pcb != NULL);
 8119934:	687b      	ldr	r3, [r7, #4]
 8119936:	2b00      	cmp	r3, #0
 8119938:	d106      	bne.n	8119948 <tcp_rexmit_rto+0x1c>
 811993a:	4b0a      	ldr	r3, [pc, #40]	; (8119964 <tcp_rexmit_rto+0x38>)
 811993c:	f240 62ad 	movw	r2, #1709	; 0x6ad
 8119940:	4909      	ldr	r1, [pc, #36]	; (8119968 <tcp_rexmit_rto+0x3c>)
 8119942:	480a      	ldr	r0, [pc, #40]	; (811996c <tcp_rexmit_rto+0x40>)
 8119944:	f001 ff5c 	bl	811b800 <iprintf>

  if (tcp_rexmit_rto_prepare(pcb) == ERR_OK) {
 8119948:	6878      	ldr	r0, [r7, #4]
 811994a:	f7ff ff57 	bl	81197fc <tcp_rexmit_rto_prepare>
 811994e:	4603      	mov	r3, r0
 8119950:	2b00      	cmp	r3, #0
 8119952:	d102      	bne.n	811995a <tcp_rexmit_rto+0x2e>
    tcp_rexmit_rto_commit(pcb);
 8119954:	6878      	ldr	r0, [r7, #4]
 8119956:	f7ff ffc1 	bl	81198dc <tcp_rexmit_rto_commit>
  }
}
 811995a:	bf00      	nop
 811995c:	3708      	adds	r7, #8
 811995e:	46bd      	mov	sp, r7
 8119960:	bd80      	pop	{r7, pc}
 8119962:	bf00      	nop
 8119964:	0811eb98 	.word	0x0811eb98
 8119968:	0811f250 	.word	0x0811f250
 811996c:	0811ec20 	.word	0x0811ec20

08119970 <tcp_rexmit>:
 *
 * @param pcb the tcp_pcb for which to retransmit the first unacked segment
 */
err_t
tcp_rexmit(struct tcp_pcb *pcb)
{
 8119970:	b590      	push	{r4, r7, lr}
 8119972:	b085      	sub	sp, #20
 8119974:	af00      	add	r7, sp, #0
 8119976:	6078      	str	r0, [r7, #4]
  struct tcp_seg *seg;
  struct tcp_seg **cur_seg;

  LWIP_ASSERT("tcp_rexmit: invalid pcb", pcb != NULL);
 8119978:	687b      	ldr	r3, [r7, #4]
 811997a:	2b00      	cmp	r3, #0
 811997c:	d106      	bne.n	811998c <tcp_rexmit+0x1c>
 811997e:	4b2f      	ldr	r3, [pc, #188]	; (8119a3c <tcp_rexmit+0xcc>)
 8119980:	f240 62c1 	movw	r2, #1729	; 0x6c1
 8119984:	492e      	ldr	r1, [pc, #184]	; (8119a40 <tcp_rexmit+0xd0>)
 8119986:	482f      	ldr	r0, [pc, #188]	; (8119a44 <tcp_rexmit+0xd4>)
 8119988:	f001 ff3a 	bl	811b800 <iprintf>

  if (pcb->unacked == NULL) {
 811998c:	687b      	ldr	r3, [r7, #4]
 811998e:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8119990:	2b00      	cmp	r3, #0
 8119992:	d102      	bne.n	811999a <tcp_rexmit+0x2a>
    return ERR_VAL;
 8119994:	f06f 0305 	mvn.w	r3, #5
 8119998:	e04c      	b.n	8119a34 <tcp_rexmit+0xc4>
  }

  seg = pcb->unacked;
 811999a:	687b      	ldr	r3, [r7, #4]
 811999c:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 811999e:	60bb      	str	r3, [r7, #8]

  /* Give up if the segment is still referenced by the netif driver
     due to deferred transmission. */
  if (tcp_output_segment_busy(seg)) {
 81199a0:	68b8      	ldr	r0, [r7, #8]
 81199a2:	f7ff fe2b 	bl	81195fc <tcp_output_segment_busy>
 81199a6:	4603      	mov	r3, r0
 81199a8:	2b00      	cmp	r3, #0
 81199aa:	d002      	beq.n	81199b2 <tcp_rexmit+0x42>
    LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_rexmit busy\n"));
    return ERR_VAL;
 81199ac:	f06f 0305 	mvn.w	r3, #5
 81199b0:	e040      	b.n	8119a34 <tcp_rexmit+0xc4>
  }

  /* Move the first unacked segment to the unsent queue */
  /* Keep the unsent queue sorted. */
  pcb->unacked = seg->next;
 81199b2:	68bb      	ldr	r3, [r7, #8]
 81199b4:	681a      	ldr	r2, [r3, #0]
 81199b6:	687b      	ldr	r3, [r7, #4]
 81199b8:	671a      	str	r2, [r3, #112]	; 0x70

  cur_seg = &(pcb->unsent);
 81199ba:	687b      	ldr	r3, [r7, #4]
 81199bc:	336c      	adds	r3, #108	; 0x6c
 81199be:	60fb      	str	r3, [r7, #12]
  while (*cur_seg &&
 81199c0:	e002      	b.n	81199c8 <tcp_rexmit+0x58>
         TCP_SEQ_LT(lwip_ntohl((*cur_seg)->tcphdr->seqno), lwip_ntohl(seg->tcphdr->seqno))) {
    cur_seg = &((*cur_seg)->next );
 81199c2:	68fb      	ldr	r3, [r7, #12]
 81199c4:	681b      	ldr	r3, [r3, #0]
 81199c6:	60fb      	str	r3, [r7, #12]
  while (*cur_seg &&
 81199c8:	68fb      	ldr	r3, [r7, #12]
 81199ca:	681b      	ldr	r3, [r3, #0]
 81199cc:	2b00      	cmp	r3, #0
 81199ce:	d011      	beq.n	81199f4 <tcp_rexmit+0x84>
         TCP_SEQ_LT(lwip_ntohl((*cur_seg)->tcphdr->seqno), lwip_ntohl(seg->tcphdr->seqno))) {
 81199d0:	68fb      	ldr	r3, [r7, #12]
 81199d2:	681b      	ldr	r3, [r3, #0]
 81199d4:	68db      	ldr	r3, [r3, #12]
 81199d6:	685b      	ldr	r3, [r3, #4]
 81199d8:	4618      	mov	r0, r3
 81199da:	f7f4 fd6f 	bl	810e4bc <lwip_htonl>
 81199de:	4604      	mov	r4, r0
 81199e0:	68bb      	ldr	r3, [r7, #8]
 81199e2:	68db      	ldr	r3, [r3, #12]
 81199e4:	685b      	ldr	r3, [r3, #4]
 81199e6:	4618      	mov	r0, r3
 81199e8:	f7f4 fd68 	bl	810e4bc <lwip_htonl>
 81199ec:	4603      	mov	r3, r0
 81199ee:	1ae3      	subs	r3, r4, r3
  while (*cur_seg &&
 81199f0:	2b00      	cmp	r3, #0
 81199f2:	dbe6      	blt.n	81199c2 <tcp_rexmit+0x52>
  }
  seg->next = *cur_seg;
 81199f4:	68fb      	ldr	r3, [r7, #12]
 81199f6:	681a      	ldr	r2, [r3, #0]
 81199f8:	68bb      	ldr	r3, [r7, #8]
 81199fa:	601a      	str	r2, [r3, #0]
  *cur_seg = seg;
 81199fc:	68fb      	ldr	r3, [r7, #12]
 81199fe:	68ba      	ldr	r2, [r7, #8]
 8119a00:	601a      	str	r2, [r3, #0]
#if TCP_OVERSIZE
  if (seg->next == NULL) {
 8119a02:	68bb      	ldr	r3, [r7, #8]
 8119a04:	681b      	ldr	r3, [r3, #0]
 8119a06:	2b00      	cmp	r3, #0
 8119a08:	d103      	bne.n	8119a12 <tcp_rexmit+0xa2>
    /* the retransmitted segment is last in unsent, so reset unsent_oversize */
    pcb->unsent_oversize = 0;
 8119a0a:	687b      	ldr	r3, [r7, #4]
 8119a0c:	2200      	movs	r2, #0
 8119a0e:	f8a3 2068 	strh.w	r2, [r3, #104]	; 0x68
  }
#endif /* TCP_OVERSIZE */

  if (pcb->nrtx < 0xFF) {
 8119a12:	687b      	ldr	r3, [r7, #4]
 8119a14:	f893 3042 	ldrb.w	r3, [r3, #66]	; 0x42
 8119a18:	2bff      	cmp	r3, #255	; 0xff
 8119a1a:	d007      	beq.n	8119a2c <tcp_rexmit+0xbc>
    ++pcb->nrtx;
 8119a1c:	687b      	ldr	r3, [r7, #4]
 8119a1e:	f893 3042 	ldrb.w	r3, [r3, #66]	; 0x42
 8119a22:	3301      	adds	r3, #1
 8119a24:	b2da      	uxtb	r2, r3
 8119a26:	687b      	ldr	r3, [r7, #4]
 8119a28:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
  }

  /* Don't take any rtt measurements after retransmitting. */
  pcb->rttest = 0;
 8119a2c:	687b      	ldr	r3, [r7, #4]
 8119a2e:	2200      	movs	r2, #0
 8119a30:	635a      	str	r2, [r3, #52]	; 0x34

  /* Do the actual retransmission. */
  MIB2_STATS_INC(mib2.tcpretranssegs);
  /* No need to call tcp_output: we are always called from tcp_input()
     and thus tcp_output directly returns. */
  return ERR_OK;
 8119a32:	2300      	movs	r3, #0
}
 8119a34:	4618      	mov	r0, r3
 8119a36:	3714      	adds	r7, #20
 8119a38:	46bd      	mov	sp, r7
 8119a3a:	bd90      	pop	{r4, r7, pc}
 8119a3c:	0811eb98 	.word	0x0811eb98
 8119a40:	0811f26c 	.word	0x0811f26c
 8119a44:	0811ec20 	.word	0x0811ec20

08119a48 <tcp_rexmit_fast>:
 *
 * @param pcb the tcp_pcb for which to retransmit the first unacked segment
 */
void
tcp_rexmit_fast(struct tcp_pcb *pcb)
{
 8119a48:	b580      	push	{r7, lr}
 8119a4a:	b082      	sub	sp, #8
 8119a4c:	af00      	add	r7, sp, #0
 8119a4e:	6078      	str	r0, [r7, #4]
  LWIP_ASSERT("tcp_rexmit_fast: invalid pcb", pcb != NULL);
 8119a50:	687b      	ldr	r3, [r7, #4]
 8119a52:	2b00      	cmp	r3, #0
 8119a54:	d106      	bne.n	8119a64 <tcp_rexmit_fast+0x1c>
 8119a56:	4b2a      	ldr	r3, [pc, #168]	; (8119b00 <tcp_rexmit_fast+0xb8>)
 8119a58:	f240 62f9 	movw	r2, #1785	; 0x6f9
 8119a5c:	4929      	ldr	r1, [pc, #164]	; (8119b04 <tcp_rexmit_fast+0xbc>)
 8119a5e:	482a      	ldr	r0, [pc, #168]	; (8119b08 <tcp_rexmit_fast+0xc0>)
 8119a60:	f001 fece 	bl	811b800 <iprintf>

  if (pcb->unacked != NULL && !(pcb->flags & TF_INFR)) {
 8119a64:	687b      	ldr	r3, [r7, #4]
 8119a66:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8119a68:	2b00      	cmp	r3, #0
 8119a6a:	d044      	beq.n	8119af6 <tcp_rexmit_fast+0xae>
 8119a6c:	687b      	ldr	r3, [r7, #4]
 8119a6e:	8b5b      	ldrh	r3, [r3, #26]
 8119a70:	f003 0304 	and.w	r3, r3, #4
 8119a74:	2b00      	cmp	r3, #0
 8119a76:	d13e      	bne.n	8119af6 <tcp_rexmit_fast+0xae>
    LWIP_DEBUGF(TCP_FR_DEBUG,
                ("tcp_receive: dupacks %"U16_F" (%"U32_F
                 "), fast retransmit %"U32_F"\n",
                 (u16_t)pcb->dupacks, pcb->lastack,
                 lwip_ntohl(pcb->unacked->tcphdr->seqno)));
    if (tcp_rexmit(pcb) == ERR_OK) {
 8119a78:	6878      	ldr	r0, [r7, #4]
 8119a7a:	f7ff ff79 	bl	8119970 <tcp_rexmit>
 8119a7e:	4603      	mov	r3, r0
 8119a80:	2b00      	cmp	r3, #0
 8119a82:	d138      	bne.n	8119af6 <tcp_rexmit_fast+0xae>
      /* Set ssthresh to half of the minimum of the current
       * cwnd and the advertised window */
      pcb->ssthresh = LWIP_MIN(pcb->cwnd, pcb->snd_wnd) / 2;
 8119a84:	687b      	ldr	r3, [r7, #4]
 8119a86:	f8b3 2060 	ldrh.w	r2, [r3, #96]	; 0x60
 8119a8a:	687b      	ldr	r3, [r7, #4]
 8119a8c:	f8b3 3048 	ldrh.w	r3, [r3, #72]	; 0x48
 8119a90:	4293      	cmp	r3, r2
 8119a92:	bf28      	it	cs
 8119a94:	4613      	movcs	r3, r2
 8119a96:	b29b      	uxth	r3, r3
 8119a98:	0fda      	lsrs	r2, r3, #31
 8119a9a:	4413      	add	r3, r2
 8119a9c:	105b      	asrs	r3, r3, #1
 8119a9e:	b29a      	uxth	r2, r3
 8119aa0:	687b      	ldr	r3, [r7, #4]
 8119aa2:	f8a3 204a 	strh.w	r2, [r3, #74]	; 0x4a

      /* The minimum value for ssthresh should be 2 MSS */
      if (pcb->ssthresh < (2U * pcb->mss)) {
 8119aa6:	687b      	ldr	r3, [r7, #4]
 8119aa8:	f8b3 304a 	ldrh.w	r3, [r3, #74]	; 0x4a
 8119aac:	461a      	mov	r2, r3
 8119aae:	687b      	ldr	r3, [r7, #4]
 8119ab0:	8e5b      	ldrh	r3, [r3, #50]	; 0x32
 8119ab2:	005b      	lsls	r3, r3, #1
 8119ab4:	429a      	cmp	r2, r3
 8119ab6:	d206      	bcs.n	8119ac6 <tcp_rexmit_fast+0x7e>
        LWIP_DEBUGF(TCP_FR_DEBUG,
                    ("tcp_receive: The minimum value for ssthresh %"TCPWNDSIZE_F
                     " should be min 2 mss %"U16_F"...\n",
                     pcb->ssthresh, (u16_t)(2 * pcb->mss)));
        pcb->ssthresh = 2 * pcb->mss;
 8119ab8:	687b      	ldr	r3, [r7, #4]
 8119aba:	8e5b      	ldrh	r3, [r3, #50]	; 0x32
 8119abc:	005b      	lsls	r3, r3, #1
 8119abe:	b29a      	uxth	r2, r3
 8119ac0:	687b      	ldr	r3, [r7, #4]
 8119ac2:	f8a3 204a 	strh.w	r2, [r3, #74]	; 0x4a
      }

      pcb->cwnd = pcb->ssthresh + 3 * pcb->mss;
 8119ac6:	687b      	ldr	r3, [r7, #4]
 8119ac8:	f8b3 204a 	ldrh.w	r2, [r3, #74]	; 0x4a
 8119acc:	687b      	ldr	r3, [r7, #4]
 8119ace:	8e5b      	ldrh	r3, [r3, #50]	; 0x32
 8119ad0:	4619      	mov	r1, r3
 8119ad2:	0049      	lsls	r1, r1, #1
 8119ad4:	440b      	add	r3, r1
 8119ad6:	b29b      	uxth	r3, r3
 8119ad8:	4413      	add	r3, r2
 8119ada:	b29a      	uxth	r2, r3
 8119adc:	687b      	ldr	r3, [r7, #4]
 8119ade:	f8a3 2048 	strh.w	r2, [r3, #72]	; 0x48
      tcp_set_flags(pcb, TF_INFR);
 8119ae2:	687b      	ldr	r3, [r7, #4]
 8119ae4:	8b5b      	ldrh	r3, [r3, #26]
 8119ae6:	f043 0304 	orr.w	r3, r3, #4
 8119aea:	b29a      	uxth	r2, r3
 8119aec:	687b      	ldr	r3, [r7, #4]
 8119aee:	835a      	strh	r2, [r3, #26]

      /* Reset the retransmission timer to prevent immediate rto retransmissions */
      pcb->rtime = 0;
 8119af0:	687b      	ldr	r3, [r7, #4]
 8119af2:	2200      	movs	r2, #0
 8119af4:	861a      	strh	r2, [r3, #48]	; 0x30
    }
  }
}
 8119af6:	bf00      	nop
 8119af8:	3708      	adds	r7, #8
 8119afa:	46bd      	mov	sp, r7
 8119afc:	bd80      	pop	{r7, pc}
 8119afe:	bf00      	nop
 8119b00:	0811eb98 	.word	0x0811eb98
 8119b04:	0811f284 	.word	0x0811f284
 8119b08:	0811ec20 	.word	0x0811ec20

08119b0c <tcp_output_alloc_header_common>:

static struct pbuf *
tcp_output_alloc_header_common(u32_t ackno, u16_t optlen, u16_t datalen,
                        u32_t seqno_be /* already in network byte order */,
                        u16_t src_port, u16_t dst_port, u8_t flags, u16_t wnd)
{
 8119b0c:	b580      	push	{r7, lr}
 8119b0e:	b086      	sub	sp, #24
 8119b10:	af00      	add	r7, sp, #0
 8119b12:	60f8      	str	r0, [r7, #12]
 8119b14:	607b      	str	r3, [r7, #4]
 8119b16:	460b      	mov	r3, r1
 8119b18:	817b      	strh	r3, [r7, #10]
 8119b1a:	4613      	mov	r3, r2
 8119b1c:	813b      	strh	r3, [r7, #8]
  struct tcp_hdr *tcphdr;
  struct pbuf *p;

  p = pbuf_alloc(PBUF_IP, TCP_HLEN + optlen + datalen, PBUF_RAM);
 8119b1e:	897a      	ldrh	r2, [r7, #10]
 8119b20:	893b      	ldrh	r3, [r7, #8]
 8119b22:	4413      	add	r3, r2
 8119b24:	b29b      	uxth	r3, r3
 8119b26:	3314      	adds	r3, #20
 8119b28:	b29b      	uxth	r3, r3
 8119b2a:	f44f 7220 	mov.w	r2, #640	; 0x280
 8119b2e:	4619      	mov	r1, r3
 8119b30:	2022      	movs	r0, #34	; 0x22
 8119b32:	f7fa faad 	bl	8114090 <pbuf_alloc>
 8119b36:	6178      	str	r0, [r7, #20]
  if (p != NULL) {
 8119b38:	697b      	ldr	r3, [r7, #20]
 8119b3a:	2b00      	cmp	r3, #0
 8119b3c:	d04d      	beq.n	8119bda <tcp_output_alloc_header_common+0xce>
    LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
 8119b3e:	897b      	ldrh	r3, [r7, #10]
 8119b40:	3313      	adds	r3, #19
 8119b42:	697a      	ldr	r2, [r7, #20]
 8119b44:	8952      	ldrh	r2, [r2, #10]
 8119b46:	4293      	cmp	r3, r2
 8119b48:	db06      	blt.n	8119b58 <tcp_output_alloc_header_common+0x4c>
 8119b4a:	4b26      	ldr	r3, [pc, #152]	; (8119be4 <tcp_output_alloc_header_common+0xd8>)
 8119b4c:	f240 7223 	movw	r2, #1827	; 0x723
 8119b50:	4925      	ldr	r1, [pc, #148]	; (8119be8 <tcp_output_alloc_header_common+0xdc>)
 8119b52:	4826      	ldr	r0, [pc, #152]	; (8119bec <tcp_output_alloc_header_common+0xe0>)
 8119b54:	f001 fe54 	bl	811b800 <iprintf>
                (p->len >= TCP_HLEN + optlen));
    tcphdr = (struct tcp_hdr *)p->payload;
 8119b58:	697b      	ldr	r3, [r7, #20]
 8119b5a:	685b      	ldr	r3, [r3, #4]
 8119b5c:	613b      	str	r3, [r7, #16]
    tcphdr->src = lwip_htons(src_port);
 8119b5e:	8c3b      	ldrh	r3, [r7, #32]
 8119b60:	4618      	mov	r0, r3
 8119b62:	f7f4 fc96 	bl	810e492 <lwip_htons>
 8119b66:	4603      	mov	r3, r0
 8119b68:	461a      	mov	r2, r3
 8119b6a:	693b      	ldr	r3, [r7, #16]
 8119b6c:	801a      	strh	r2, [r3, #0]
    tcphdr->dest = lwip_htons(dst_port);
 8119b6e:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
 8119b70:	4618      	mov	r0, r3
 8119b72:	f7f4 fc8e 	bl	810e492 <lwip_htons>
 8119b76:	4603      	mov	r3, r0
 8119b78:	461a      	mov	r2, r3
 8119b7a:	693b      	ldr	r3, [r7, #16]
 8119b7c:	805a      	strh	r2, [r3, #2]
    tcphdr->seqno = seqno_be;
 8119b7e:	693b      	ldr	r3, [r7, #16]
 8119b80:	687a      	ldr	r2, [r7, #4]
 8119b82:	605a      	str	r2, [r3, #4]
    tcphdr->ackno = lwip_htonl(ackno);
 8119b84:	68f8      	ldr	r0, [r7, #12]
 8119b86:	f7f4 fc99 	bl	810e4bc <lwip_htonl>
 8119b8a:	4602      	mov	r2, r0
 8119b8c:	693b      	ldr	r3, [r7, #16]
 8119b8e:	609a      	str	r2, [r3, #8]
    TCPH_HDRLEN_FLAGS_SET(tcphdr, (5 + optlen / 4), flags);
 8119b90:	897b      	ldrh	r3, [r7, #10]
 8119b92:	089b      	lsrs	r3, r3, #2
 8119b94:	b29b      	uxth	r3, r3
 8119b96:	3305      	adds	r3, #5
 8119b98:	b29b      	uxth	r3, r3
 8119b9a:	031b      	lsls	r3, r3, #12
 8119b9c:	b29a      	uxth	r2, r3
 8119b9e:	f897 3028 	ldrb.w	r3, [r7, #40]	; 0x28
 8119ba2:	b29b      	uxth	r3, r3
 8119ba4:	4313      	orrs	r3, r2
 8119ba6:	b29b      	uxth	r3, r3
 8119ba8:	4618      	mov	r0, r3
 8119baa:	f7f4 fc72 	bl	810e492 <lwip_htons>
 8119bae:	4603      	mov	r3, r0
 8119bb0:	461a      	mov	r2, r3
 8119bb2:	693b      	ldr	r3, [r7, #16]
 8119bb4:	819a      	strh	r2, [r3, #12]
    tcphdr->wnd = lwip_htons(wnd);
 8119bb6:	8dbb      	ldrh	r3, [r7, #44]	; 0x2c
 8119bb8:	4618      	mov	r0, r3
 8119bba:	f7f4 fc6a 	bl	810e492 <lwip_htons>
 8119bbe:	4603      	mov	r3, r0
 8119bc0:	461a      	mov	r2, r3
 8119bc2:	693b      	ldr	r3, [r7, #16]
 8119bc4:	81da      	strh	r2, [r3, #14]
    tcphdr->chksum = 0;
 8119bc6:	693b      	ldr	r3, [r7, #16]
 8119bc8:	2200      	movs	r2, #0
 8119bca:	741a      	strb	r2, [r3, #16]
 8119bcc:	2200      	movs	r2, #0
 8119bce:	745a      	strb	r2, [r3, #17]
    tcphdr->urgp = 0;
 8119bd0:	693b      	ldr	r3, [r7, #16]
 8119bd2:	2200      	movs	r2, #0
 8119bd4:	749a      	strb	r2, [r3, #18]
 8119bd6:	2200      	movs	r2, #0
 8119bd8:	74da      	strb	r2, [r3, #19]
  }
  return p;
 8119bda:	697b      	ldr	r3, [r7, #20]
}
 8119bdc:	4618      	mov	r0, r3
 8119bde:	3718      	adds	r7, #24
 8119be0:	46bd      	mov	sp, r7
 8119be2:	bd80      	pop	{r7, pc}
 8119be4:	0811eb98 	.word	0x0811eb98
 8119be8:	0811f2a4 	.word	0x0811f2a4
 8119bec:	0811ec20 	.word	0x0811ec20

08119bf0 <tcp_output_alloc_header>:
 * @return pbuf with p->payload being the tcp_hdr
 */
static struct pbuf *
tcp_output_alloc_header(struct tcp_pcb *pcb, u16_t optlen, u16_t datalen,
                        u32_t seqno_be /* already in network byte order */)
{
 8119bf0:	b5b0      	push	{r4, r5, r7, lr}
 8119bf2:	b08a      	sub	sp, #40	; 0x28
 8119bf4:	af04      	add	r7, sp, #16
 8119bf6:	60f8      	str	r0, [r7, #12]
 8119bf8:	607b      	str	r3, [r7, #4]
 8119bfa:	460b      	mov	r3, r1
 8119bfc:	817b      	strh	r3, [r7, #10]
 8119bfe:	4613      	mov	r3, r2
 8119c00:	813b      	strh	r3, [r7, #8]
  struct pbuf *p;

  LWIP_ASSERT("tcp_output_alloc_header: invalid pcb", pcb != NULL);
 8119c02:	68fb      	ldr	r3, [r7, #12]
 8119c04:	2b00      	cmp	r3, #0
 8119c06:	d106      	bne.n	8119c16 <tcp_output_alloc_header+0x26>
 8119c08:	4b15      	ldr	r3, [pc, #84]	; (8119c60 <tcp_output_alloc_header+0x70>)
 8119c0a:	f240 7242 	movw	r2, #1858	; 0x742
 8119c0e:	4915      	ldr	r1, [pc, #84]	; (8119c64 <tcp_output_alloc_header+0x74>)
 8119c10:	4815      	ldr	r0, [pc, #84]	; (8119c68 <tcp_output_alloc_header+0x78>)
 8119c12:	f001 fdf5 	bl	811b800 <iprintf>

  p = tcp_output_alloc_header_common(pcb->rcv_nxt, optlen, datalen,
 8119c16:	68fb      	ldr	r3, [r7, #12]
 8119c18:	6a58      	ldr	r0, [r3, #36]	; 0x24
 8119c1a:	68fb      	ldr	r3, [r7, #12]
 8119c1c:	8adb      	ldrh	r3, [r3, #22]
 8119c1e:	68fa      	ldr	r2, [r7, #12]
 8119c20:	8b12      	ldrh	r2, [r2, #24]
 8119c22:	68f9      	ldr	r1, [r7, #12]
 8119c24:	8d49      	ldrh	r1, [r1, #42]	; 0x2a
 8119c26:	893d      	ldrh	r5, [r7, #8]
 8119c28:	897c      	ldrh	r4, [r7, #10]
 8119c2a:	9103      	str	r1, [sp, #12]
 8119c2c:	2110      	movs	r1, #16
 8119c2e:	9102      	str	r1, [sp, #8]
 8119c30:	9201      	str	r2, [sp, #4]
 8119c32:	9300      	str	r3, [sp, #0]
 8119c34:	687b      	ldr	r3, [r7, #4]
 8119c36:	462a      	mov	r2, r5
 8119c38:	4621      	mov	r1, r4
 8119c3a:	f7ff ff67 	bl	8119b0c <tcp_output_alloc_header_common>
 8119c3e:	6178      	str	r0, [r7, #20]
    seqno_be, pcb->local_port, pcb->remote_port, TCP_ACK,
    TCPWND_MIN16(RCV_WND_SCALE(pcb, pcb->rcv_ann_wnd)));
  if (p != NULL) {
 8119c40:	697b      	ldr	r3, [r7, #20]
 8119c42:	2b00      	cmp	r3, #0
 8119c44:	d006      	beq.n	8119c54 <tcp_output_alloc_header+0x64>
    /* If we're sending a packet, update the announced right window edge */
    pcb->rcv_ann_right_edge = pcb->rcv_nxt + pcb->rcv_ann_wnd;
 8119c46:	68fb      	ldr	r3, [r7, #12]
 8119c48:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8119c4a:	68fa      	ldr	r2, [r7, #12]
 8119c4c:	8d52      	ldrh	r2, [r2, #42]	; 0x2a
 8119c4e:	441a      	add	r2, r3
 8119c50:	68fb      	ldr	r3, [r7, #12]
 8119c52:	62da      	str	r2, [r3, #44]	; 0x2c
  }
  return p;
 8119c54:	697b      	ldr	r3, [r7, #20]
}
 8119c56:	4618      	mov	r0, r3
 8119c58:	3718      	adds	r7, #24
 8119c5a:	46bd      	mov	sp, r7
 8119c5c:	bdb0      	pop	{r4, r5, r7, pc}
 8119c5e:	bf00      	nop
 8119c60:	0811eb98 	.word	0x0811eb98
 8119c64:	0811f2d4 	.word	0x0811f2d4
 8119c68:	0811ec20 	.word	0x0811ec20

08119c6c <tcp_output_fill_options>:

/* Fill in options for control segments */
static void
tcp_output_fill_options(const struct tcp_pcb *pcb, struct pbuf *p, u8_t optflags, u8_t num_sacks)
{
 8119c6c:	b580      	push	{r7, lr}
 8119c6e:	b088      	sub	sp, #32
 8119c70:	af00      	add	r7, sp, #0
 8119c72:	60f8      	str	r0, [r7, #12]
 8119c74:	60b9      	str	r1, [r7, #8]
 8119c76:	4611      	mov	r1, r2
 8119c78:	461a      	mov	r2, r3
 8119c7a:	460b      	mov	r3, r1
 8119c7c:	71fb      	strb	r3, [r7, #7]
 8119c7e:	4613      	mov	r3, r2
 8119c80:	71bb      	strb	r3, [r7, #6]
  struct tcp_hdr *tcphdr;
  u32_t *opts;
  u16_t sacks_len = 0;
 8119c82:	2300      	movs	r3, #0
 8119c84:	83fb      	strh	r3, [r7, #30]

  LWIP_ASSERT("tcp_output_fill_options: invalid pbuf", p != NULL);
 8119c86:	68bb      	ldr	r3, [r7, #8]
 8119c88:	2b00      	cmp	r3, #0
 8119c8a:	d106      	bne.n	8119c9a <tcp_output_fill_options+0x2e>
 8119c8c:	4b12      	ldr	r3, [pc, #72]	; (8119cd8 <tcp_output_fill_options+0x6c>)
 8119c8e:	f240 7256 	movw	r2, #1878	; 0x756
 8119c92:	4912      	ldr	r1, [pc, #72]	; (8119cdc <tcp_output_fill_options+0x70>)
 8119c94:	4812      	ldr	r0, [pc, #72]	; (8119ce0 <tcp_output_fill_options+0x74>)
 8119c96:	f001 fdb3 	bl	811b800 <iprintf>

  tcphdr = (struct tcp_hdr *)p->payload;
 8119c9a:	68bb      	ldr	r3, [r7, #8]
 8119c9c:	685b      	ldr	r3, [r3, #4]
 8119c9e:	61bb      	str	r3, [r7, #24]
  opts = (u32_t *)(void *)(tcphdr + 1);
 8119ca0:	69bb      	ldr	r3, [r7, #24]
 8119ca2:	3314      	adds	r3, #20
 8119ca4:	617b      	str	r3, [r7, #20]
  opts = LWIP_HOOK_TCP_OUT_ADD_TCPOPTS(p, tcphdr, pcb, opts);
#endif

  LWIP_UNUSED_ARG(pcb);
  LWIP_UNUSED_ARG(sacks_len);
  LWIP_ASSERT("options not filled", (u8_t *)opts == ((u8_t *)(tcphdr + 1)) + sacks_len * 4 + LWIP_TCP_OPT_LENGTH_SEGMENT(optflags, pcb));
 8119ca6:	8bfb      	ldrh	r3, [r7, #30]
 8119ca8:	009b      	lsls	r3, r3, #2
 8119caa:	461a      	mov	r2, r3
 8119cac:	79fb      	ldrb	r3, [r7, #7]
 8119cae:	009b      	lsls	r3, r3, #2
 8119cb0:	f003 0304 	and.w	r3, r3, #4
 8119cb4:	4413      	add	r3, r2
 8119cb6:	3314      	adds	r3, #20
 8119cb8:	69ba      	ldr	r2, [r7, #24]
 8119cba:	4413      	add	r3, r2
 8119cbc:	697a      	ldr	r2, [r7, #20]
 8119cbe:	429a      	cmp	r2, r3
 8119cc0:	d006      	beq.n	8119cd0 <tcp_output_fill_options+0x64>
 8119cc2:	4b05      	ldr	r3, [pc, #20]	; (8119cd8 <tcp_output_fill_options+0x6c>)
 8119cc4:	f240 7275 	movw	r2, #1909	; 0x775
 8119cc8:	4906      	ldr	r1, [pc, #24]	; (8119ce4 <tcp_output_fill_options+0x78>)
 8119cca:	4805      	ldr	r0, [pc, #20]	; (8119ce0 <tcp_output_fill_options+0x74>)
 8119ccc:	f001 fd98 	bl	811b800 <iprintf>
  LWIP_UNUSED_ARG(optflags); /* for LWIP_NOASSERT */
  LWIP_UNUSED_ARG(opts); /* for LWIP_NOASSERT */
}
 8119cd0:	bf00      	nop
 8119cd2:	3720      	adds	r7, #32
 8119cd4:	46bd      	mov	sp, r7
 8119cd6:	bd80      	pop	{r7, pc}
 8119cd8:	0811eb98 	.word	0x0811eb98
 8119cdc:	0811f2fc 	.word	0x0811f2fc
 8119ce0:	0811ec20 	.word	0x0811ec20
 8119ce4:	0811f1f4 	.word	0x0811f1f4

08119ce8 <tcp_output_control_segment>:
 * header checksum and calling ip_output_if while handling netif hints and stats.
 */
static err_t
tcp_output_control_segment(const struct tcp_pcb *pcb, struct pbuf *p,
                           const ip_addr_t *src, const ip_addr_t *dst)
{
 8119ce8:	b580      	push	{r7, lr}
 8119cea:	b08a      	sub	sp, #40	; 0x28
 8119cec:	af04      	add	r7, sp, #16
 8119cee:	60f8      	str	r0, [r7, #12]
 8119cf0:	60b9      	str	r1, [r7, #8]
 8119cf2:	607a      	str	r2, [r7, #4]
 8119cf4:	603b      	str	r3, [r7, #0]
  err_t err;
  struct netif *netif;

  LWIP_ASSERT("tcp_output_control_segment: invalid pbuf", p != NULL);
 8119cf6:	68bb      	ldr	r3, [r7, #8]
 8119cf8:	2b00      	cmp	r3, #0
 8119cfa:	d106      	bne.n	8119d0a <tcp_output_control_segment+0x22>
 8119cfc:	4b1c      	ldr	r3, [pc, #112]	; (8119d70 <tcp_output_control_segment+0x88>)
 8119cfe:	f240 7287 	movw	r2, #1927	; 0x787
 8119d02:	491c      	ldr	r1, [pc, #112]	; (8119d74 <tcp_output_control_segment+0x8c>)
 8119d04:	481c      	ldr	r0, [pc, #112]	; (8119d78 <tcp_output_control_segment+0x90>)
 8119d06:	f001 fd7b 	bl	811b800 <iprintf>

  netif = tcp_route(pcb, src, dst);
 8119d0a:	683a      	ldr	r2, [r7, #0]
 8119d0c:	6879      	ldr	r1, [r7, #4]
 8119d0e:	68f8      	ldr	r0, [r7, #12]
 8119d10:	f7fe ff40 	bl	8118b94 <tcp_route>
 8119d14:	6138      	str	r0, [r7, #16]
  if (netif == NULL) {
 8119d16:	693b      	ldr	r3, [r7, #16]
 8119d18:	2b00      	cmp	r3, #0
 8119d1a:	d102      	bne.n	8119d22 <tcp_output_control_segment+0x3a>
    err = ERR_RTE;
 8119d1c:	23fc      	movs	r3, #252	; 0xfc
 8119d1e:	75fb      	strb	r3, [r7, #23]
 8119d20:	e01c      	b.n	8119d5c <tcp_output_control_segment+0x74>
      struct tcp_hdr *tcphdr = (struct tcp_hdr *)p->payload;
      tcphdr->chksum = ip_chksum_pseudo(p, IP_PROTO_TCP, p->tot_len,
                                        src, dst);
    }
#endif
    if (pcb != NULL) {
 8119d22:	68fb      	ldr	r3, [r7, #12]
 8119d24:	2b00      	cmp	r3, #0
 8119d26:	d006      	beq.n	8119d36 <tcp_output_control_segment+0x4e>
      NETIF_SET_HINTS(netif, LWIP_CONST_CAST(struct netif_hint*, &(pcb->netif_hints)));
      ttl = pcb->ttl;
 8119d28:	68fb      	ldr	r3, [r7, #12]
 8119d2a:	7adb      	ldrb	r3, [r3, #11]
 8119d2c:	75bb      	strb	r3, [r7, #22]
      tos = pcb->tos;
 8119d2e:	68fb      	ldr	r3, [r7, #12]
 8119d30:	7a9b      	ldrb	r3, [r3, #10]
 8119d32:	757b      	strb	r3, [r7, #21]
 8119d34:	e003      	b.n	8119d3e <tcp_output_control_segment+0x56>
    } else {
      /* Send output with hardcoded TTL/HL since we have no access to the pcb */
      ttl = TCP_TTL;
 8119d36:	23ff      	movs	r3, #255	; 0xff
 8119d38:	75bb      	strb	r3, [r7, #22]
      tos = 0;
 8119d3a:	2300      	movs	r3, #0
 8119d3c:	757b      	strb	r3, [r7, #21]
    }
    TCP_STATS_INC(tcp.xmit);
    err = ip_output_if(p, src, dst, ttl, tos, IP_PROTO_TCP, netif);
 8119d3e:	7dba      	ldrb	r2, [r7, #22]
 8119d40:	693b      	ldr	r3, [r7, #16]
 8119d42:	9302      	str	r3, [sp, #8]
 8119d44:	2306      	movs	r3, #6
 8119d46:	9301      	str	r3, [sp, #4]
 8119d48:	7d7b      	ldrb	r3, [r7, #21]
 8119d4a:	9300      	str	r3, [sp, #0]
 8119d4c:	4613      	mov	r3, r2
 8119d4e:	683a      	ldr	r2, [r7, #0]
 8119d50:	6879      	ldr	r1, [r7, #4]
 8119d52:	68b8      	ldr	r0, [r7, #8]
 8119d54:	f7f8 fa26 	bl	81121a4 <ip4_output_if>
 8119d58:	4603      	mov	r3, r0
 8119d5a:	75fb      	strb	r3, [r7, #23]
    NETIF_RESET_HINTS(netif);
  }
  pbuf_free(p);
 8119d5c:	68b8      	ldr	r0, [r7, #8]
 8119d5e:	f7fa fc7b 	bl	8114658 <pbuf_free>
  return err;
 8119d62:	f997 3017 	ldrsb.w	r3, [r7, #23]
}
 8119d66:	4618      	mov	r0, r3
 8119d68:	3718      	adds	r7, #24
 8119d6a:	46bd      	mov	sp, r7
 8119d6c:	bd80      	pop	{r7, pc}
 8119d6e:	bf00      	nop
 8119d70:	0811eb98 	.word	0x0811eb98
 8119d74:	0811f324 	.word	0x0811f324
 8119d78:	0811ec20 	.word	0x0811ec20

08119d7c <tcp_rst>:
 */
void
tcp_rst(const struct tcp_pcb *pcb, u32_t seqno, u32_t ackno,
        const ip_addr_t *local_ip, const ip_addr_t *remote_ip,
        u16_t local_port, u16_t remote_port)
{
 8119d7c:	b590      	push	{r4, r7, lr}
 8119d7e:	b08b      	sub	sp, #44	; 0x2c
 8119d80:	af04      	add	r7, sp, #16
 8119d82:	60f8      	str	r0, [r7, #12]
 8119d84:	60b9      	str	r1, [r7, #8]
 8119d86:	607a      	str	r2, [r7, #4]
 8119d88:	603b      	str	r3, [r7, #0]
  struct pbuf *p;
  u16_t wnd;
  u8_t optlen;

  LWIP_ASSERT("tcp_rst: invalid local_ip", local_ip != NULL);
 8119d8a:	683b      	ldr	r3, [r7, #0]
 8119d8c:	2b00      	cmp	r3, #0
 8119d8e:	d106      	bne.n	8119d9e <tcp_rst+0x22>
 8119d90:	4b1f      	ldr	r3, [pc, #124]	; (8119e10 <tcp_rst+0x94>)
 8119d92:	f240 72c4 	movw	r2, #1988	; 0x7c4
 8119d96:	491f      	ldr	r1, [pc, #124]	; (8119e14 <tcp_rst+0x98>)
 8119d98:	481f      	ldr	r0, [pc, #124]	; (8119e18 <tcp_rst+0x9c>)
 8119d9a:	f001 fd31 	bl	811b800 <iprintf>
  LWIP_ASSERT("tcp_rst: invalid remote_ip", remote_ip != NULL);
 8119d9e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8119da0:	2b00      	cmp	r3, #0
 8119da2:	d106      	bne.n	8119db2 <tcp_rst+0x36>
 8119da4:	4b1a      	ldr	r3, [pc, #104]	; (8119e10 <tcp_rst+0x94>)
 8119da6:	f240 72c5 	movw	r2, #1989	; 0x7c5
 8119daa:	491c      	ldr	r1, [pc, #112]	; (8119e1c <tcp_rst+0xa0>)
 8119dac:	481a      	ldr	r0, [pc, #104]	; (8119e18 <tcp_rst+0x9c>)
 8119dae:	f001 fd27 	bl	811b800 <iprintf>

  optlen = LWIP_TCP_OPT_LENGTH_SEGMENT(0, pcb);
 8119db2:	2300      	movs	r3, #0
 8119db4:	75fb      	strb	r3, [r7, #23]

#if LWIP_WND_SCALE
  wnd = PP_HTONS(((TCP_WND >> TCP_RCV_SCALE) & 0xFFFF));
#else
  wnd = PP_HTONS(TCP_WND);
 8119db6:	f246 0308 	movw	r3, #24584	; 0x6008
 8119dba:	82bb      	strh	r3, [r7, #20]
#endif

  p = tcp_output_alloc_header_common(ackno, optlen, 0, lwip_htonl(seqno), local_port,
 8119dbc:	7dfb      	ldrb	r3, [r7, #23]
 8119dbe:	b29c      	uxth	r4, r3
 8119dc0:	68b8      	ldr	r0, [r7, #8]
 8119dc2:	f7f4 fb7b 	bl	810e4bc <lwip_htonl>
 8119dc6:	4602      	mov	r2, r0
 8119dc8:	8abb      	ldrh	r3, [r7, #20]
 8119dca:	9303      	str	r3, [sp, #12]
 8119dcc:	2314      	movs	r3, #20
 8119dce:	9302      	str	r3, [sp, #8]
 8119dd0:	8e3b      	ldrh	r3, [r7, #48]	; 0x30
 8119dd2:	9301      	str	r3, [sp, #4]
 8119dd4:	8dbb      	ldrh	r3, [r7, #44]	; 0x2c
 8119dd6:	9300      	str	r3, [sp, #0]
 8119dd8:	4613      	mov	r3, r2
 8119dda:	2200      	movs	r2, #0
 8119ddc:	4621      	mov	r1, r4
 8119dde:	6878      	ldr	r0, [r7, #4]
 8119de0:	f7ff fe94 	bl	8119b0c <tcp_output_alloc_header_common>
 8119de4:	6138      	str	r0, [r7, #16]
    remote_port, TCP_RST | TCP_ACK, wnd);
  if (p == NULL) {
 8119de6:	693b      	ldr	r3, [r7, #16]
 8119de8:	2b00      	cmp	r3, #0
 8119dea:	d00c      	beq.n	8119e06 <tcp_rst+0x8a>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_rst: could not allocate memory for pbuf\n"));
    return;
  }
  tcp_output_fill_options(pcb, p, 0, optlen);
 8119dec:	7dfb      	ldrb	r3, [r7, #23]
 8119dee:	2200      	movs	r2, #0
 8119df0:	6939      	ldr	r1, [r7, #16]
 8119df2:	68f8      	ldr	r0, [r7, #12]
 8119df4:	f7ff ff3a 	bl	8119c6c <tcp_output_fill_options>

  MIB2_STATS_INC(mib2.tcpoutrsts);

  tcp_output_control_segment(pcb, p, local_ip, remote_ip);
 8119df8:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8119dfa:	683a      	ldr	r2, [r7, #0]
 8119dfc:	6939      	ldr	r1, [r7, #16]
 8119dfe:	68f8      	ldr	r0, [r7, #12]
 8119e00:	f7ff ff72 	bl	8119ce8 <tcp_output_control_segment>
 8119e04:	e000      	b.n	8119e08 <tcp_rst+0x8c>
    return;
 8119e06:	bf00      	nop
  LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_rst: seqno %"U32_F" ackno %"U32_F".\n", seqno, ackno));
}
 8119e08:	371c      	adds	r7, #28
 8119e0a:	46bd      	mov	sp, r7
 8119e0c:	bd90      	pop	{r4, r7, pc}
 8119e0e:	bf00      	nop
 8119e10:	0811eb98 	.word	0x0811eb98
 8119e14:	0811f350 	.word	0x0811f350
 8119e18:	0811ec20 	.word	0x0811ec20
 8119e1c:	0811f36c 	.word	0x0811f36c

08119e20 <tcp_send_empty_ack>:
 *
 * @param pcb Protocol control block for the TCP connection to send the ACK
 */
err_t
tcp_send_empty_ack(struct tcp_pcb *pcb)
{
 8119e20:	b590      	push	{r4, r7, lr}
 8119e22:	b087      	sub	sp, #28
 8119e24:	af00      	add	r7, sp, #0
 8119e26:	6078      	str	r0, [r7, #4]
  err_t err;
  struct pbuf *p;
  u8_t optlen, optflags = 0;
 8119e28:	2300      	movs	r3, #0
 8119e2a:	75fb      	strb	r3, [r7, #23]
  u8_t num_sacks = 0;
 8119e2c:	2300      	movs	r3, #0
 8119e2e:	75bb      	strb	r3, [r7, #22]

  LWIP_ASSERT("tcp_send_empty_ack: invalid pcb", pcb != NULL);
 8119e30:	687b      	ldr	r3, [r7, #4]
 8119e32:	2b00      	cmp	r3, #0
 8119e34:	d106      	bne.n	8119e44 <tcp_send_empty_ack+0x24>
 8119e36:	4b28      	ldr	r3, [pc, #160]	; (8119ed8 <tcp_send_empty_ack+0xb8>)
 8119e38:	f240 72ea 	movw	r2, #2026	; 0x7ea
 8119e3c:	4927      	ldr	r1, [pc, #156]	; (8119edc <tcp_send_empty_ack+0xbc>)
 8119e3e:	4828      	ldr	r0, [pc, #160]	; (8119ee0 <tcp_send_empty_ack+0xc0>)
 8119e40:	f001 fcde 	bl	811b800 <iprintf>
#if LWIP_TCP_TIMESTAMPS
  if (pcb->flags & TF_TIMESTAMP) {
    optflags = TF_SEG_OPTS_TS;
  }
#endif
  optlen = LWIP_TCP_OPT_LENGTH_SEGMENT(optflags, pcb);
 8119e44:	7dfb      	ldrb	r3, [r7, #23]
 8119e46:	009b      	lsls	r3, r3, #2
 8119e48:	b2db      	uxtb	r3, r3
 8119e4a:	f003 0304 	and.w	r3, r3, #4
 8119e4e:	757b      	strb	r3, [r7, #21]
  if ((num_sacks = tcp_get_num_sacks(pcb, optlen)) > 0) {
    optlen += 4 + num_sacks * 8; /* 4 bytes for header (including 2*NOP), plus 8B for each SACK */
  }
#endif

  p = tcp_output_alloc_header(pcb, optlen, 0, lwip_htonl(pcb->snd_nxt));
 8119e50:	7d7b      	ldrb	r3, [r7, #21]
 8119e52:	b29c      	uxth	r4, r3
 8119e54:	687b      	ldr	r3, [r7, #4]
 8119e56:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8119e58:	4618      	mov	r0, r3
 8119e5a:	f7f4 fb2f 	bl	810e4bc <lwip_htonl>
 8119e5e:	4603      	mov	r3, r0
 8119e60:	2200      	movs	r2, #0
 8119e62:	4621      	mov	r1, r4
 8119e64:	6878      	ldr	r0, [r7, #4]
 8119e66:	f7ff fec3 	bl	8119bf0 <tcp_output_alloc_header>
 8119e6a:	6138      	str	r0, [r7, #16]
  if (p == NULL) {
 8119e6c:	693b      	ldr	r3, [r7, #16]
 8119e6e:	2b00      	cmp	r3, #0
 8119e70:	d109      	bne.n	8119e86 <tcp_send_empty_ack+0x66>
    /* let tcp_fasttmr retry sending this ACK */
    tcp_set_flags(pcb, TF_ACK_DELAY | TF_ACK_NOW);
 8119e72:	687b      	ldr	r3, [r7, #4]
 8119e74:	8b5b      	ldrh	r3, [r3, #26]
 8119e76:	f043 0303 	orr.w	r3, r3, #3
 8119e7a:	b29a      	uxth	r2, r3
 8119e7c:	687b      	ldr	r3, [r7, #4]
 8119e7e:	835a      	strh	r2, [r3, #26]
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output: (ACK) could not allocate pbuf\n"));
    return ERR_BUF;
 8119e80:	f06f 0301 	mvn.w	r3, #1
 8119e84:	e023      	b.n	8119ece <tcp_send_empty_ack+0xae>
  }
  tcp_output_fill_options(pcb, p, optflags, num_sacks);
 8119e86:	7dbb      	ldrb	r3, [r7, #22]
 8119e88:	7dfa      	ldrb	r2, [r7, #23]
 8119e8a:	6939      	ldr	r1, [r7, #16]
 8119e8c:	6878      	ldr	r0, [r7, #4]
 8119e8e:	f7ff feed 	bl	8119c6c <tcp_output_fill_options>
  pcb->ts_lastacksent = pcb->rcv_nxt;
#endif

  LWIP_DEBUGF(TCP_OUTPUT_DEBUG,
              ("tcp_output: sending ACK for %"U32_F"\n", pcb->rcv_nxt));
  err = tcp_output_control_segment(pcb, p, &pcb->local_ip, &pcb->remote_ip);
 8119e92:	687a      	ldr	r2, [r7, #4]
 8119e94:	687b      	ldr	r3, [r7, #4]
 8119e96:	3304      	adds	r3, #4
 8119e98:	6939      	ldr	r1, [r7, #16]
 8119e9a:	6878      	ldr	r0, [r7, #4]
 8119e9c:	f7ff ff24 	bl	8119ce8 <tcp_output_control_segment>
 8119ea0:	4603      	mov	r3, r0
 8119ea2:	73fb      	strb	r3, [r7, #15]
  if (err != ERR_OK) {
 8119ea4:	f997 300f 	ldrsb.w	r3, [r7, #15]
 8119ea8:	2b00      	cmp	r3, #0
 8119eaa:	d007      	beq.n	8119ebc <tcp_send_empty_ack+0x9c>
    /* let tcp_fasttmr retry sending this ACK */
    tcp_set_flags(pcb, TF_ACK_DELAY | TF_ACK_NOW);
 8119eac:	687b      	ldr	r3, [r7, #4]
 8119eae:	8b5b      	ldrh	r3, [r3, #26]
 8119eb0:	f043 0303 	orr.w	r3, r3, #3
 8119eb4:	b29a      	uxth	r2, r3
 8119eb6:	687b      	ldr	r3, [r7, #4]
 8119eb8:	835a      	strh	r2, [r3, #26]
 8119eba:	e006      	b.n	8119eca <tcp_send_empty_ack+0xaa>
  } else {
    /* remove ACK flags from the PCB, as we sent an empty ACK now */
    tcp_clear_flags(pcb, TF_ACK_DELAY | TF_ACK_NOW);
 8119ebc:	687b      	ldr	r3, [r7, #4]
 8119ebe:	8b5b      	ldrh	r3, [r3, #26]
 8119ec0:	f023 0303 	bic.w	r3, r3, #3
 8119ec4:	b29a      	uxth	r2, r3
 8119ec6:	687b      	ldr	r3, [r7, #4]
 8119ec8:	835a      	strh	r2, [r3, #26]
  }

  return err;
 8119eca:	f997 300f 	ldrsb.w	r3, [r7, #15]
}
 8119ece:	4618      	mov	r0, r3
 8119ed0:	371c      	adds	r7, #28
 8119ed2:	46bd      	mov	sp, r7
 8119ed4:	bd90      	pop	{r4, r7, pc}
 8119ed6:	bf00      	nop
 8119ed8:	0811eb98 	.word	0x0811eb98
 8119edc:	0811f388 	.word	0x0811f388
 8119ee0:	0811ec20 	.word	0x0811ec20

08119ee4 <tcp_keepalive>:
 *
 * @param pcb the tcp_pcb for which to send a keepalive packet
 */
err_t
tcp_keepalive(struct tcp_pcb *pcb)
{
 8119ee4:	b590      	push	{r4, r7, lr}
 8119ee6:	b087      	sub	sp, #28
 8119ee8:	af00      	add	r7, sp, #0
 8119eea:	6078      	str	r0, [r7, #4]
  err_t err;
  struct pbuf *p;
  u8_t optlen = LWIP_TCP_OPT_LENGTH_SEGMENT(0, pcb);
 8119eec:	2300      	movs	r3, #0
 8119eee:	75fb      	strb	r3, [r7, #23]

  LWIP_ASSERT("tcp_keepalive: invalid pcb", pcb != NULL);
 8119ef0:	687b      	ldr	r3, [r7, #4]
 8119ef2:	2b00      	cmp	r3, #0
 8119ef4:	d106      	bne.n	8119f04 <tcp_keepalive+0x20>
 8119ef6:	4b18      	ldr	r3, [pc, #96]	; (8119f58 <tcp_keepalive+0x74>)
 8119ef8:	f640 0224 	movw	r2, #2084	; 0x824
 8119efc:	4917      	ldr	r1, [pc, #92]	; (8119f5c <tcp_keepalive+0x78>)
 8119efe:	4818      	ldr	r0, [pc, #96]	; (8119f60 <tcp_keepalive+0x7c>)
 8119f00:	f001 fc7e 	bl	811b800 <iprintf>
  LWIP_DEBUGF(TCP_DEBUG, ("\n"));

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_keepalive: tcp_ticks %"U32_F"   pcb->tmr %"U32_F" pcb->keep_cnt_sent %"U16_F"\n",
                          tcp_ticks, pcb->tmr, (u16_t)pcb->keep_cnt_sent));

  p = tcp_output_alloc_header(pcb, optlen, 0, lwip_htonl(pcb->snd_nxt - 1));
 8119f04:	7dfb      	ldrb	r3, [r7, #23]
 8119f06:	b29c      	uxth	r4, r3
 8119f08:	687b      	ldr	r3, [r7, #4]
 8119f0a:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8119f0c:	3b01      	subs	r3, #1
 8119f0e:	4618      	mov	r0, r3
 8119f10:	f7f4 fad4 	bl	810e4bc <lwip_htonl>
 8119f14:	4603      	mov	r3, r0
 8119f16:	2200      	movs	r2, #0
 8119f18:	4621      	mov	r1, r4
 8119f1a:	6878      	ldr	r0, [r7, #4]
 8119f1c:	f7ff fe68 	bl	8119bf0 <tcp_output_alloc_header>
 8119f20:	6138      	str	r0, [r7, #16]
  if (p == NULL) {
 8119f22:	693b      	ldr	r3, [r7, #16]
 8119f24:	2b00      	cmp	r3, #0
 8119f26:	d102      	bne.n	8119f2e <tcp_keepalive+0x4a>
    LWIP_DEBUGF(TCP_DEBUG,
                ("tcp_keepalive: could not allocate memory for pbuf\n"));
    return ERR_MEM;
 8119f28:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 8119f2c:	e010      	b.n	8119f50 <tcp_keepalive+0x6c>
  }
  tcp_output_fill_options(pcb, p, 0, optlen);
 8119f2e:	7dfb      	ldrb	r3, [r7, #23]
 8119f30:	2200      	movs	r2, #0
 8119f32:	6939      	ldr	r1, [r7, #16]
 8119f34:	6878      	ldr	r0, [r7, #4]
 8119f36:	f7ff fe99 	bl	8119c6c <tcp_output_fill_options>
  err = tcp_output_control_segment(pcb, p, &pcb->local_ip, &pcb->remote_ip);
 8119f3a:	687a      	ldr	r2, [r7, #4]
 8119f3c:	687b      	ldr	r3, [r7, #4]
 8119f3e:	3304      	adds	r3, #4
 8119f40:	6939      	ldr	r1, [r7, #16]
 8119f42:	6878      	ldr	r0, [r7, #4]
 8119f44:	f7ff fed0 	bl	8119ce8 <tcp_output_control_segment>
 8119f48:	4603      	mov	r3, r0
 8119f4a:	73fb      	strb	r3, [r7, #15]

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_keepalive: seqno %"U32_F" ackno %"U32_F" err %d.\n",
                          pcb->snd_nxt - 1, pcb->rcv_nxt, (int)err));
  return err;
 8119f4c:	f997 300f 	ldrsb.w	r3, [r7, #15]
}
 8119f50:	4618      	mov	r0, r3
 8119f52:	371c      	adds	r7, #28
 8119f54:	46bd      	mov	sp, r7
 8119f56:	bd90      	pop	{r4, r7, pc}
 8119f58:	0811eb98 	.word	0x0811eb98
 8119f5c:	0811f3a8 	.word	0x0811f3a8
 8119f60:	0811ec20 	.word	0x0811ec20

08119f64 <tcp_zero_window_probe>:
 *
 * @param pcb the tcp_pcb for which to send a zero-window probe packet
 */
err_t
tcp_zero_window_probe(struct tcp_pcb *pcb)
{
 8119f64:	b590      	push	{r4, r7, lr}
 8119f66:	b08b      	sub	sp, #44	; 0x2c
 8119f68:	af00      	add	r7, sp, #0
 8119f6a:	6078      	str	r0, [r7, #4]
  struct tcp_hdr *tcphdr;
  struct tcp_seg *seg;
  u16_t len;
  u8_t is_fin;
  u32_t snd_nxt;
  u8_t optlen = LWIP_TCP_OPT_LENGTH_SEGMENT(0, pcb);
 8119f6c:	2300      	movs	r3, #0
 8119f6e:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27

  LWIP_ASSERT("tcp_zero_window_probe: invalid pcb", pcb != NULL);
 8119f72:	687b      	ldr	r3, [r7, #4]
 8119f74:	2b00      	cmp	r3, #0
 8119f76:	d106      	bne.n	8119f86 <tcp_zero_window_probe+0x22>
 8119f78:	4b4c      	ldr	r3, [pc, #304]	; (811a0ac <tcp_zero_window_probe+0x148>)
 8119f7a:	f640 024f 	movw	r2, #2127	; 0x84f
 8119f7e:	494c      	ldr	r1, [pc, #304]	; (811a0b0 <tcp_zero_window_probe+0x14c>)
 8119f80:	484c      	ldr	r0, [pc, #304]	; (811a0b4 <tcp_zero_window_probe+0x150>)
 8119f82:	f001 fc3d 	bl	811b800 <iprintf>
              ("tcp_zero_window_probe: tcp_ticks %"U32_F
               "   pcb->tmr %"U32_F" pcb->keep_cnt_sent %"U16_F"\n",
               tcp_ticks, pcb->tmr, (u16_t)pcb->keep_cnt_sent));

  /* Only consider unsent, persist timer should be off when there is data in-flight */
  seg = pcb->unsent;
 8119f86:	687b      	ldr	r3, [r7, #4]
 8119f88:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 8119f8a:	623b      	str	r3, [r7, #32]
  if (seg == NULL) {
 8119f8c:	6a3b      	ldr	r3, [r7, #32]
 8119f8e:	2b00      	cmp	r3, #0
 8119f90:	d101      	bne.n	8119f96 <tcp_zero_window_probe+0x32>
    /* Not expected, persist timer should be off when the send buffer is empty */
    return ERR_OK;
 8119f92:	2300      	movs	r3, #0
 8119f94:	e086      	b.n	811a0a4 <tcp_zero_window_probe+0x140>

  /* increment probe count. NOTE: we record probe even if it fails
     to actually transmit due to an error. This ensures memory exhaustion/
     routing problem doesn't leave a zero-window pcb as an indefinite zombie.
     RTO mechanism has similar behavior, see pcb->nrtx */
  if (pcb->persist_probe < 0xFF) {
 8119f96:	687b      	ldr	r3, [r7, #4]
 8119f98:	f893 309a 	ldrb.w	r3, [r3, #154]	; 0x9a
 8119f9c:	2bff      	cmp	r3, #255	; 0xff
 8119f9e:	d007      	beq.n	8119fb0 <tcp_zero_window_probe+0x4c>
    ++pcb->persist_probe;
 8119fa0:	687b      	ldr	r3, [r7, #4]
 8119fa2:	f893 309a 	ldrb.w	r3, [r3, #154]	; 0x9a
 8119fa6:	3301      	adds	r3, #1
 8119fa8:	b2da      	uxtb	r2, r3
 8119faa:	687b      	ldr	r3, [r7, #4]
 8119fac:	f883 209a 	strb.w	r2, [r3, #154]	; 0x9a
  }

  is_fin = ((TCPH_FLAGS(seg->tcphdr) & TCP_FIN) != 0) && (seg->len == 0);
 8119fb0:	6a3b      	ldr	r3, [r7, #32]
 8119fb2:	68db      	ldr	r3, [r3, #12]
 8119fb4:	899b      	ldrh	r3, [r3, #12]
 8119fb6:	b29b      	uxth	r3, r3
 8119fb8:	4618      	mov	r0, r3
 8119fba:	f7f4 fa6a 	bl	810e492 <lwip_htons>
 8119fbe:	4603      	mov	r3, r0
 8119fc0:	b2db      	uxtb	r3, r3
 8119fc2:	f003 0301 	and.w	r3, r3, #1
 8119fc6:	2b00      	cmp	r3, #0
 8119fc8:	d005      	beq.n	8119fd6 <tcp_zero_window_probe+0x72>
 8119fca:	6a3b      	ldr	r3, [r7, #32]
 8119fcc:	891b      	ldrh	r3, [r3, #8]
 8119fce:	2b00      	cmp	r3, #0
 8119fd0:	d101      	bne.n	8119fd6 <tcp_zero_window_probe+0x72>
 8119fd2:	2301      	movs	r3, #1
 8119fd4:	e000      	b.n	8119fd8 <tcp_zero_window_probe+0x74>
 8119fd6:	2300      	movs	r3, #0
 8119fd8:	77fb      	strb	r3, [r7, #31]
  /* we want to send one seqno: either FIN or data (no options) */
  len = is_fin ? 0 : 1;
 8119fda:	7ffb      	ldrb	r3, [r7, #31]
 8119fdc:	2b00      	cmp	r3, #0
 8119fde:	bf0c      	ite	eq
 8119fe0:	2301      	moveq	r3, #1
 8119fe2:	2300      	movne	r3, #0
 8119fe4:	b2db      	uxtb	r3, r3
 8119fe6:	83bb      	strh	r3, [r7, #28]

  p = tcp_output_alloc_header(pcb, optlen, len, seg->tcphdr->seqno);
 8119fe8:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 8119fec:	b299      	uxth	r1, r3
 8119fee:	6a3b      	ldr	r3, [r7, #32]
 8119ff0:	68db      	ldr	r3, [r3, #12]
 8119ff2:	685b      	ldr	r3, [r3, #4]
 8119ff4:	8bba      	ldrh	r2, [r7, #28]
 8119ff6:	6878      	ldr	r0, [r7, #4]
 8119ff8:	f7ff fdfa 	bl	8119bf0 <tcp_output_alloc_header>
 8119ffc:	61b8      	str	r0, [r7, #24]
  if (p == NULL) {
 8119ffe:	69bb      	ldr	r3, [r7, #24]
 811a000:	2b00      	cmp	r3, #0
 811a002:	d102      	bne.n	811a00a <tcp_zero_window_probe+0xa6>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_zero_window_probe: no memory for pbuf\n"));
    return ERR_MEM;
 811a004:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 811a008:	e04c      	b.n	811a0a4 <tcp_zero_window_probe+0x140>
  }
  tcphdr = (struct tcp_hdr *)p->payload;
 811a00a:	69bb      	ldr	r3, [r7, #24]
 811a00c:	685b      	ldr	r3, [r3, #4]
 811a00e:	617b      	str	r3, [r7, #20]

  if (is_fin) {
 811a010:	7ffb      	ldrb	r3, [r7, #31]
 811a012:	2b00      	cmp	r3, #0
 811a014:	d011      	beq.n	811a03a <tcp_zero_window_probe+0xd6>
    /* FIN segment, no data */
    TCPH_FLAGS_SET(tcphdr, TCP_ACK | TCP_FIN);
 811a016:	697b      	ldr	r3, [r7, #20]
 811a018:	899b      	ldrh	r3, [r3, #12]
 811a01a:	b29b      	uxth	r3, r3
 811a01c:	b21b      	sxth	r3, r3
 811a01e:	f423 537c 	bic.w	r3, r3, #16128	; 0x3f00
 811a022:	b21c      	sxth	r4, r3
 811a024:	2011      	movs	r0, #17
 811a026:	f7f4 fa34 	bl	810e492 <lwip_htons>
 811a02a:	4603      	mov	r3, r0
 811a02c:	b21b      	sxth	r3, r3
 811a02e:	4323      	orrs	r3, r4
 811a030:	b21b      	sxth	r3, r3
 811a032:	b29a      	uxth	r2, r3
 811a034:	697b      	ldr	r3, [r7, #20]
 811a036:	819a      	strh	r2, [r3, #12]
 811a038:	e010      	b.n	811a05c <tcp_zero_window_probe+0xf8>
  } else {
    /* Data segment, copy in one byte from the head of the unacked queue */
    char *d = ((char *)p->payload + TCP_HLEN);
 811a03a:	69bb      	ldr	r3, [r7, #24]
 811a03c:	685b      	ldr	r3, [r3, #4]
 811a03e:	3314      	adds	r3, #20
 811a040:	613b      	str	r3, [r7, #16]
    /* Depending on whether the segment has already been sent (unacked) or not
       (unsent), seg->p->payload points to the IP header or TCP header.
       Ensure we copy the first TCP data byte: */
    pbuf_copy_partial(seg->p, d, 1, seg->p->tot_len - seg->len);
 811a042:	6a3b      	ldr	r3, [r7, #32]
 811a044:	6858      	ldr	r0, [r3, #4]
 811a046:	6a3b      	ldr	r3, [r7, #32]
 811a048:	685b      	ldr	r3, [r3, #4]
 811a04a:	891a      	ldrh	r2, [r3, #8]
 811a04c:	6a3b      	ldr	r3, [r7, #32]
 811a04e:	891b      	ldrh	r3, [r3, #8]
 811a050:	1ad3      	subs	r3, r2, r3
 811a052:	b29b      	uxth	r3, r3
 811a054:	2201      	movs	r2, #1
 811a056:	6939      	ldr	r1, [r7, #16]
 811a058:	f7fa fcf8 	bl	8114a4c <pbuf_copy_partial>
  }

  /* The byte may be acknowledged without the window being opened. */
  snd_nxt = lwip_ntohl(seg->tcphdr->seqno) + 1;
 811a05c:	6a3b      	ldr	r3, [r7, #32]
 811a05e:	68db      	ldr	r3, [r3, #12]
 811a060:	685b      	ldr	r3, [r3, #4]
 811a062:	4618      	mov	r0, r3
 811a064:	f7f4 fa2a 	bl	810e4bc <lwip_htonl>
 811a068:	4603      	mov	r3, r0
 811a06a:	3301      	adds	r3, #1
 811a06c:	60fb      	str	r3, [r7, #12]
  if (TCP_SEQ_LT(pcb->snd_nxt, snd_nxt)) {
 811a06e:	687b      	ldr	r3, [r7, #4]
 811a070:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 811a072:	68fb      	ldr	r3, [r7, #12]
 811a074:	1ad3      	subs	r3, r2, r3
 811a076:	2b00      	cmp	r3, #0
 811a078:	da02      	bge.n	811a080 <tcp_zero_window_probe+0x11c>
    pcb->snd_nxt = snd_nxt;
 811a07a:	687b      	ldr	r3, [r7, #4]
 811a07c:	68fa      	ldr	r2, [r7, #12]
 811a07e:	651a      	str	r2, [r3, #80]	; 0x50
  }
  tcp_output_fill_options(pcb, p, 0, optlen);
 811a080:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 811a084:	2200      	movs	r2, #0
 811a086:	69b9      	ldr	r1, [r7, #24]
 811a088:	6878      	ldr	r0, [r7, #4]
 811a08a:	f7ff fdef 	bl	8119c6c <tcp_output_fill_options>

  err = tcp_output_control_segment(pcb, p, &pcb->local_ip, &pcb->remote_ip);
 811a08e:	687a      	ldr	r2, [r7, #4]
 811a090:	687b      	ldr	r3, [r7, #4]
 811a092:	3304      	adds	r3, #4
 811a094:	69b9      	ldr	r1, [r7, #24]
 811a096:	6878      	ldr	r0, [r7, #4]
 811a098:	f7ff fe26 	bl	8119ce8 <tcp_output_control_segment>
 811a09c:	4603      	mov	r3, r0
 811a09e:	72fb      	strb	r3, [r7, #11]

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_zero_window_probe: seqno %"U32_F
                          " ackno %"U32_F" err %d.\n",
                          pcb->snd_nxt - 1, pcb->rcv_nxt, (int)err));
  return err;
 811a0a0:	f997 300b 	ldrsb.w	r3, [r7, #11]
}
 811a0a4:	4618      	mov	r0, r3
 811a0a6:	372c      	adds	r7, #44	; 0x2c
 811a0a8:	46bd      	mov	sp, r7
 811a0aa:	bd90      	pop	{r4, r7, pc}
 811a0ac:	0811eb98 	.word	0x0811eb98
 811a0b0:	0811f3c4 	.word	0x0811f3c4
 811a0b4:	0811ec20 	.word	0x0811ec20

0811a0b8 <tcpip_tcp_timer>:
 *
 * @param arg unused argument
 */
static void
tcpip_tcp_timer(void *arg)
{
 811a0b8:	b580      	push	{r7, lr}
 811a0ba:	b082      	sub	sp, #8
 811a0bc:	af00      	add	r7, sp, #0
 811a0be:	6078      	str	r0, [r7, #4]
  LWIP_UNUSED_ARG(arg);

  /* call TCP timer handler */
  tcp_tmr();
 811a0c0:	f7fa ff0c 	bl	8114edc <tcp_tmr>
  /* timer still needed? */
  if (tcp_active_pcbs || tcp_tw_pcbs) {
 811a0c4:	4b0a      	ldr	r3, [pc, #40]	; (811a0f0 <tcpip_tcp_timer+0x38>)
 811a0c6:	681b      	ldr	r3, [r3, #0]
 811a0c8:	2b00      	cmp	r3, #0
 811a0ca:	d103      	bne.n	811a0d4 <tcpip_tcp_timer+0x1c>
 811a0cc:	4b09      	ldr	r3, [pc, #36]	; (811a0f4 <tcpip_tcp_timer+0x3c>)
 811a0ce:	681b      	ldr	r3, [r3, #0]
 811a0d0:	2b00      	cmp	r3, #0
 811a0d2:	d005      	beq.n	811a0e0 <tcpip_tcp_timer+0x28>
    /* restart timer */
    sys_timeout(TCP_TMR_INTERVAL, tcpip_tcp_timer, NULL);
 811a0d4:	2200      	movs	r2, #0
 811a0d6:	4908      	ldr	r1, [pc, #32]	; (811a0f8 <tcpip_tcp_timer+0x40>)
 811a0d8:	20fa      	movs	r0, #250	; 0xfa
 811a0da:	f000 f8f3 	bl	811a2c4 <sys_timeout>
 811a0de:	e003      	b.n	811a0e8 <tcpip_tcp_timer+0x30>
  } else {
    /* disable timer */
    tcpip_tcp_timer_active = 0;
 811a0e0:	4b06      	ldr	r3, [pc, #24]	; (811a0fc <tcpip_tcp_timer+0x44>)
 811a0e2:	2200      	movs	r2, #0
 811a0e4:	601a      	str	r2, [r3, #0]
  }
}
 811a0e6:	bf00      	nop
 811a0e8:	bf00      	nop
 811a0ea:	3708      	adds	r7, #8
 811a0ec:	46bd      	mov	sp, r7
 811a0ee:	bd80      	pop	{r7, pc}
 811a0f0:	10008454 	.word	0x10008454
 811a0f4:	10008458 	.word	0x10008458
 811a0f8:	0811a0b9 	.word	0x0811a0b9
 811a0fc:	100084a0 	.word	0x100084a0

0811a100 <tcp_timer_needed>:
 * the reason is to have the TCP timer only running when
 * there are active (or time-wait) PCBs.
 */
void
tcp_timer_needed(void)
{
 811a100:	b580      	push	{r7, lr}
 811a102:	af00      	add	r7, sp, #0
  LWIP_ASSERT_CORE_LOCKED();

  /* timer is off but needed again? */
  if (!tcpip_tcp_timer_active && (tcp_active_pcbs || tcp_tw_pcbs)) {
 811a104:	4b0a      	ldr	r3, [pc, #40]	; (811a130 <tcp_timer_needed+0x30>)
 811a106:	681b      	ldr	r3, [r3, #0]
 811a108:	2b00      	cmp	r3, #0
 811a10a:	d10f      	bne.n	811a12c <tcp_timer_needed+0x2c>
 811a10c:	4b09      	ldr	r3, [pc, #36]	; (811a134 <tcp_timer_needed+0x34>)
 811a10e:	681b      	ldr	r3, [r3, #0]
 811a110:	2b00      	cmp	r3, #0
 811a112:	d103      	bne.n	811a11c <tcp_timer_needed+0x1c>
 811a114:	4b08      	ldr	r3, [pc, #32]	; (811a138 <tcp_timer_needed+0x38>)
 811a116:	681b      	ldr	r3, [r3, #0]
 811a118:	2b00      	cmp	r3, #0
 811a11a:	d007      	beq.n	811a12c <tcp_timer_needed+0x2c>
    /* enable and start timer */
    tcpip_tcp_timer_active = 1;
 811a11c:	4b04      	ldr	r3, [pc, #16]	; (811a130 <tcp_timer_needed+0x30>)
 811a11e:	2201      	movs	r2, #1
 811a120:	601a      	str	r2, [r3, #0]
    sys_timeout(TCP_TMR_INTERVAL, tcpip_tcp_timer, NULL);
 811a122:	2200      	movs	r2, #0
 811a124:	4905      	ldr	r1, [pc, #20]	; (811a13c <tcp_timer_needed+0x3c>)
 811a126:	20fa      	movs	r0, #250	; 0xfa
 811a128:	f000 f8cc 	bl	811a2c4 <sys_timeout>
  }
}
 811a12c:	bf00      	nop
 811a12e:	bd80      	pop	{r7, pc}
 811a130:	100084a0 	.word	0x100084a0
 811a134:	10008454 	.word	0x10008454
 811a138:	10008458 	.word	0x10008458
 811a13c:	0811a0b9 	.word	0x0811a0b9

0811a140 <sys_timeout_abs>:
#if LWIP_DEBUG_TIMERNAMES
sys_timeout_abs(u32_t abs_time, sys_timeout_handler handler, void *arg, const char *handler_name)
#else /* LWIP_DEBUG_TIMERNAMES */
sys_timeout_abs(u32_t abs_time, sys_timeout_handler handler, void *arg)
#endif
{
 811a140:	b580      	push	{r7, lr}
 811a142:	b086      	sub	sp, #24
 811a144:	af00      	add	r7, sp, #0
 811a146:	60f8      	str	r0, [r7, #12]
 811a148:	60b9      	str	r1, [r7, #8]
 811a14a:	607a      	str	r2, [r7, #4]
  struct sys_timeo *timeout, *t;

  timeout = (struct sys_timeo *)memp_malloc(MEMP_SYS_TIMEOUT);
 811a14c:	2006      	movs	r0, #6
 811a14e:	f7f9 fbb1 	bl	81138b4 <memp_malloc>
 811a152:	6138      	str	r0, [r7, #16]
  if (timeout == NULL) {
 811a154:	693b      	ldr	r3, [r7, #16]
 811a156:	2b00      	cmp	r3, #0
 811a158:	d109      	bne.n	811a16e <sys_timeout_abs+0x2e>
    LWIP_ASSERT("sys_timeout: timeout != NULL, pool MEMP_SYS_TIMEOUT is empty", timeout != NULL);
 811a15a:	693b      	ldr	r3, [r7, #16]
 811a15c:	2b00      	cmp	r3, #0
 811a15e:	d151      	bne.n	811a204 <sys_timeout_abs+0xc4>
 811a160:	4b2a      	ldr	r3, [pc, #168]	; (811a20c <sys_timeout_abs+0xcc>)
 811a162:	22be      	movs	r2, #190	; 0xbe
 811a164:	492a      	ldr	r1, [pc, #168]	; (811a210 <sys_timeout_abs+0xd0>)
 811a166:	482b      	ldr	r0, [pc, #172]	; (811a214 <sys_timeout_abs+0xd4>)
 811a168:	f001 fb4a 	bl	811b800 <iprintf>
    return;
 811a16c:	e04a      	b.n	811a204 <sys_timeout_abs+0xc4>
  }

  timeout->next = NULL;
 811a16e:	693b      	ldr	r3, [r7, #16]
 811a170:	2200      	movs	r2, #0
 811a172:	601a      	str	r2, [r3, #0]
  timeout->h = handler;
 811a174:	693b      	ldr	r3, [r7, #16]
 811a176:	68ba      	ldr	r2, [r7, #8]
 811a178:	609a      	str	r2, [r3, #8]
  timeout->arg = arg;
 811a17a:	693b      	ldr	r3, [r7, #16]
 811a17c:	687a      	ldr	r2, [r7, #4]
 811a17e:	60da      	str	r2, [r3, #12]
  timeout->time = abs_time;
 811a180:	693b      	ldr	r3, [r7, #16]
 811a182:	68fa      	ldr	r2, [r7, #12]
 811a184:	605a      	str	r2, [r3, #4]
  timeout->handler_name = handler_name;
  LWIP_DEBUGF(TIMERS_DEBUG, ("sys_timeout: %p abs_time=%"U32_F" handler=%s arg=%p\n",
                             (void *)timeout, abs_time, handler_name, (void *)arg));
#endif /* LWIP_DEBUG_TIMERNAMES */

  if (next_timeout == NULL) {
 811a186:	4b24      	ldr	r3, [pc, #144]	; (811a218 <sys_timeout_abs+0xd8>)
 811a188:	681b      	ldr	r3, [r3, #0]
 811a18a:	2b00      	cmp	r3, #0
 811a18c:	d103      	bne.n	811a196 <sys_timeout_abs+0x56>
    next_timeout = timeout;
 811a18e:	4a22      	ldr	r2, [pc, #136]	; (811a218 <sys_timeout_abs+0xd8>)
 811a190:	693b      	ldr	r3, [r7, #16]
 811a192:	6013      	str	r3, [r2, #0]
    return;
 811a194:	e037      	b.n	811a206 <sys_timeout_abs+0xc6>
  }
  if (TIME_LESS_THAN(timeout->time, next_timeout->time)) {
 811a196:	693b      	ldr	r3, [r7, #16]
 811a198:	685a      	ldr	r2, [r3, #4]
 811a19a:	4b1f      	ldr	r3, [pc, #124]	; (811a218 <sys_timeout_abs+0xd8>)
 811a19c:	681b      	ldr	r3, [r3, #0]
 811a19e:	685b      	ldr	r3, [r3, #4]
 811a1a0:	1ad3      	subs	r3, r2, r3
 811a1a2:	0fdb      	lsrs	r3, r3, #31
 811a1a4:	f003 0301 	and.w	r3, r3, #1
 811a1a8:	b2db      	uxtb	r3, r3
 811a1aa:	2b00      	cmp	r3, #0
 811a1ac:	d007      	beq.n	811a1be <sys_timeout_abs+0x7e>
    timeout->next = next_timeout;
 811a1ae:	4b1a      	ldr	r3, [pc, #104]	; (811a218 <sys_timeout_abs+0xd8>)
 811a1b0:	681a      	ldr	r2, [r3, #0]
 811a1b2:	693b      	ldr	r3, [r7, #16]
 811a1b4:	601a      	str	r2, [r3, #0]
    next_timeout = timeout;
 811a1b6:	4a18      	ldr	r2, [pc, #96]	; (811a218 <sys_timeout_abs+0xd8>)
 811a1b8:	693b      	ldr	r3, [r7, #16]
 811a1ba:	6013      	str	r3, [r2, #0]
 811a1bc:	e023      	b.n	811a206 <sys_timeout_abs+0xc6>
  } else {
    for (t = next_timeout; t != NULL; t = t->next) {
 811a1be:	4b16      	ldr	r3, [pc, #88]	; (811a218 <sys_timeout_abs+0xd8>)
 811a1c0:	681b      	ldr	r3, [r3, #0]
 811a1c2:	617b      	str	r3, [r7, #20]
 811a1c4:	e01a      	b.n	811a1fc <sys_timeout_abs+0xbc>
      if ((t->next == NULL) || TIME_LESS_THAN(timeout->time, t->next->time)) {
 811a1c6:	697b      	ldr	r3, [r7, #20]
 811a1c8:	681b      	ldr	r3, [r3, #0]
 811a1ca:	2b00      	cmp	r3, #0
 811a1cc:	d00b      	beq.n	811a1e6 <sys_timeout_abs+0xa6>
 811a1ce:	693b      	ldr	r3, [r7, #16]
 811a1d0:	685a      	ldr	r2, [r3, #4]
 811a1d2:	697b      	ldr	r3, [r7, #20]
 811a1d4:	681b      	ldr	r3, [r3, #0]
 811a1d6:	685b      	ldr	r3, [r3, #4]
 811a1d8:	1ad3      	subs	r3, r2, r3
 811a1da:	0fdb      	lsrs	r3, r3, #31
 811a1dc:	f003 0301 	and.w	r3, r3, #1
 811a1e0:	b2db      	uxtb	r3, r3
 811a1e2:	2b00      	cmp	r3, #0
 811a1e4:	d007      	beq.n	811a1f6 <sys_timeout_abs+0xb6>
        timeout->next = t->next;
 811a1e6:	697b      	ldr	r3, [r7, #20]
 811a1e8:	681a      	ldr	r2, [r3, #0]
 811a1ea:	693b      	ldr	r3, [r7, #16]
 811a1ec:	601a      	str	r2, [r3, #0]
        t->next = timeout;
 811a1ee:	697b      	ldr	r3, [r7, #20]
 811a1f0:	693a      	ldr	r2, [r7, #16]
 811a1f2:	601a      	str	r2, [r3, #0]
        break;
 811a1f4:	e007      	b.n	811a206 <sys_timeout_abs+0xc6>
    for (t = next_timeout; t != NULL; t = t->next) {
 811a1f6:	697b      	ldr	r3, [r7, #20]
 811a1f8:	681b      	ldr	r3, [r3, #0]
 811a1fa:	617b      	str	r3, [r7, #20]
 811a1fc:	697b      	ldr	r3, [r7, #20]
 811a1fe:	2b00      	cmp	r3, #0
 811a200:	d1e1      	bne.n	811a1c6 <sys_timeout_abs+0x86>
 811a202:	e000      	b.n	811a206 <sys_timeout_abs+0xc6>
    return;
 811a204:	bf00      	nop
      }
    }
  }
}
 811a206:	3718      	adds	r7, #24
 811a208:	46bd      	mov	sp, r7
 811a20a:	bd80      	pop	{r7, pc}
 811a20c:	0811f3e8 	.word	0x0811f3e8
 811a210:	0811f450 	.word	0x0811f450
 811a214:	0811f490 	.word	0x0811f490
 811a218:	10008498 	.word	0x10008498

0811a21c <lwip_cyclic_timer>:
#if !LWIP_TESTMODE
static
#endif
void
lwip_cyclic_timer(void *arg)
{
 811a21c:	b580      	push	{r7, lr}
 811a21e:	b086      	sub	sp, #24
 811a220:	af00      	add	r7, sp, #0
 811a222:	6078      	str	r0, [r7, #4]
  u32_t now;
  u32_t next_timeout_time;
  const struct lwip_cyclic_timer *cyclic = (const struct lwip_cyclic_timer *)arg;
 811a224:	687b      	ldr	r3, [r7, #4]
 811a226:	617b      	str	r3, [r7, #20]

#if LWIP_DEBUG_TIMERNAMES
  LWIP_DEBUGF(TIMERS_DEBUG, ("tcpip: %s()\n", cyclic->handler_name));
#endif
  cyclic->handler();
 811a228:	697b      	ldr	r3, [r7, #20]
 811a22a:	685b      	ldr	r3, [r3, #4]
 811a22c:	4798      	blx	r3

  now = sys_now();
 811a22e:	f7f2 f9f9 	bl	810c624 <sys_now>
 811a232:	6138      	str	r0, [r7, #16]
  next_timeout_time = (u32_t)(current_timeout_due_time + cyclic->interval_ms);  /* overflow handled by TIME_LESS_THAN macro */ 
 811a234:	697b      	ldr	r3, [r7, #20]
 811a236:	681a      	ldr	r2, [r3, #0]
 811a238:	4b0f      	ldr	r3, [pc, #60]	; (811a278 <lwip_cyclic_timer+0x5c>)
 811a23a:	681b      	ldr	r3, [r3, #0]
 811a23c:	4413      	add	r3, r2
 811a23e:	60fb      	str	r3, [r7, #12]
  if (TIME_LESS_THAN(next_timeout_time, now)) {
 811a240:	68fa      	ldr	r2, [r7, #12]
 811a242:	693b      	ldr	r3, [r7, #16]
 811a244:	1ad3      	subs	r3, r2, r3
 811a246:	0fdb      	lsrs	r3, r3, #31
 811a248:	f003 0301 	and.w	r3, r3, #1
 811a24c:	b2db      	uxtb	r3, r3
 811a24e:	2b00      	cmp	r3, #0
 811a250:	d009      	beq.n	811a266 <lwip_cyclic_timer+0x4a>
    /* timer would immediately expire again -> "overload" -> restart without any correction */
#if LWIP_DEBUG_TIMERNAMES
    sys_timeout_abs((u32_t)(now + cyclic->interval_ms), lwip_cyclic_timer, arg, cyclic->handler_name);
#else
    sys_timeout_abs((u32_t)(now + cyclic->interval_ms), lwip_cyclic_timer, arg);
 811a252:	697b      	ldr	r3, [r7, #20]
 811a254:	681a      	ldr	r2, [r3, #0]
 811a256:	693b      	ldr	r3, [r7, #16]
 811a258:	4413      	add	r3, r2
 811a25a:	687a      	ldr	r2, [r7, #4]
 811a25c:	4907      	ldr	r1, [pc, #28]	; (811a27c <lwip_cyclic_timer+0x60>)
 811a25e:	4618      	mov	r0, r3
 811a260:	f7ff ff6e 	bl	811a140 <sys_timeout_abs>
    sys_timeout_abs(next_timeout_time, lwip_cyclic_timer, arg, cyclic->handler_name);
#else
    sys_timeout_abs(next_timeout_time, lwip_cyclic_timer, arg);
#endif
  }
}
 811a264:	e004      	b.n	811a270 <lwip_cyclic_timer+0x54>
    sys_timeout_abs(next_timeout_time, lwip_cyclic_timer, arg);
 811a266:	687a      	ldr	r2, [r7, #4]
 811a268:	4904      	ldr	r1, [pc, #16]	; (811a27c <lwip_cyclic_timer+0x60>)
 811a26a:	68f8      	ldr	r0, [r7, #12]
 811a26c:	f7ff ff68 	bl	811a140 <sys_timeout_abs>
}
 811a270:	bf00      	nop
 811a272:	3718      	adds	r7, #24
 811a274:	46bd      	mov	sp, r7
 811a276:	bd80      	pop	{r7, pc}
 811a278:	1000849c 	.word	0x1000849c
 811a27c:	0811a21d 	.word	0x0811a21d

0811a280 <sys_timeouts_init>:

/** Initialize this module */
void sys_timeouts_init(void)
{
 811a280:	b580      	push	{r7, lr}
 811a282:	b082      	sub	sp, #8
 811a284:	af00      	add	r7, sp, #0
  size_t i;
  /* tcp_tmr() at index 0 is started on demand */
  for (i = (LWIP_TCP ? 1 : 0); i < LWIP_ARRAYSIZE(lwip_cyclic_timers); i++) {
 811a286:	2301      	movs	r3, #1
 811a288:	607b      	str	r3, [r7, #4]
 811a28a:	e00e      	b.n	811a2aa <sys_timeouts_init+0x2a>
    /* we have to cast via size_t to get rid of const warning
      (this is OK as cyclic_timer() casts back to const* */
    sys_timeout(lwip_cyclic_timers[i].interval_ms, lwip_cyclic_timer, LWIP_CONST_CAST(void *, &lwip_cyclic_timers[i]));
 811a28c:	4a0b      	ldr	r2, [pc, #44]	; (811a2bc <sys_timeouts_init+0x3c>)
 811a28e:	687b      	ldr	r3, [r7, #4]
 811a290:	f852 0033 	ldr.w	r0, [r2, r3, lsl #3]
 811a294:	687b      	ldr	r3, [r7, #4]
 811a296:	00db      	lsls	r3, r3, #3
 811a298:	4a08      	ldr	r2, [pc, #32]	; (811a2bc <sys_timeouts_init+0x3c>)
 811a29a:	4413      	add	r3, r2
 811a29c:	461a      	mov	r2, r3
 811a29e:	4908      	ldr	r1, [pc, #32]	; (811a2c0 <sys_timeouts_init+0x40>)
 811a2a0:	f000 f810 	bl	811a2c4 <sys_timeout>
  for (i = (LWIP_TCP ? 1 : 0); i < LWIP_ARRAYSIZE(lwip_cyclic_timers); i++) {
 811a2a4:	687b      	ldr	r3, [r7, #4]
 811a2a6:	3301      	adds	r3, #1
 811a2a8:	607b      	str	r3, [r7, #4]
 811a2aa:	687b      	ldr	r3, [r7, #4]
 811a2ac:	2b05      	cmp	r3, #5
 811a2ae:	d9ed      	bls.n	811a28c <sys_timeouts_init+0xc>
  }
}
 811a2b0:	bf00      	nop
 811a2b2:	bf00      	nop
 811a2b4:	3708      	adds	r7, #8
 811a2b6:	46bd      	mov	sp, r7
 811a2b8:	bd80      	pop	{r7, pc}
 811a2ba:	bf00      	nop
 811a2bc:	0811f9f4 	.word	0x0811f9f4
 811a2c0:	0811a21d 	.word	0x0811a21d

0811a2c4 <sys_timeout>:
sys_timeout_debug(u32_t msecs, sys_timeout_handler handler, void *arg, const char *handler_name)
#else /* LWIP_DEBUG_TIMERNAMES */
void
sys_timeout(u32_t msecs, sys_timeout_handler handler, void *arg)
#endif /* LWIP_DEBUG_TIMERNAMES */
{
 811a2c4:	b580      	push	{r7, lr}
 811a2c6:	b086      	sub	sp, #24
 811a2c8:	af00      	add	r7, sp, #0
 811a2ca:	60f8      	str	r0, [r7, #12]
 811a2cc:	60b9      	str	r1, [r7, #8]
 811a2ce:	607a      	str	r2, [r7, #4]
  u32_t next_timeout_time;

  LWIP_ASSERT_CORE_LOCKED();

  LWIP_ASSERT("Timeout time too long, max is LWIP_UINT32_MAX/4 msecs", msecs <= (LWIP_UINT32_MAX / 4));
 811a2d0:	68fb      	ldr	r3, [r7, #12]
 811a2d2:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
 811a2d6:	d306      	bcc.n	811a2e6 <sys_timeout+0x22>
 811a2d8:	4b0a      	ldr	r3, [pc, #40]	; (811a304 <sys_timeout+0x40>)
 811a2da:	f240 1229 	movw	r2, #297	; 0x129
 811a2de:	490a      	ldr	r1, [pc, #40]	; (811a308 <sys_timeout+0x44>)
 811a2e0:	480a      	ldr	r0, [pc, #40]	; (811a30c <sys_timeout+0x48>)
 811a2e2:	f001 fa8d 	bl	811b800 <iprintf>

  next_timeout_time = (u32_t)(sys_now() + msecs); /* overflow handled by TIME_LESS_THAN macro */ 
 811a2e6:	f7f2 f99d 	bl	810c624 <sys_now>
 811a2ea:	4602      	mov	r2, r0
 811a2ec:	68fb      	ldr	r3, [r7, #12]
 811a2ee:	4413      	add	r3, r2
 811a2f0:	617b      	str	r3, [r7, #20]

#if LWIP_DEBUG_TIMERNAMES
  sys_timeout_abs(next_timeout_time, handler, arg, handler_name);
#else
  sys_timeout_abs(next_timeout_time, handler, arg);
 811a2f2:	687a      	ldr	r2, [r7, #4]
 811a2f4:	68b9      	ldr	r1, [r7, #8]
 811a2f6:	6978      	ldr	r0, [r7, #20]
 811a2f8:	f7ff ff22 	bl	811a140 <sys_timeout_abs>
#endif
}
 811a2fc:	bf00      	nop
 811a2fe:	3718      	adds	r7, #24
 811a300:	46bd      	mov	sp, r7
 811a302:	bd80      	pop	{r7, pc}
 811a304:	0811f3e8 	.word	0x0811f3e8
 811a308:	0811f4b8 	.word	0x0811f4b8
 811a30c:	0811f490 	.word	0x0811f490

0811a310 <udp_init>:
/**
 * Initialize this module.
 */
void
udp_init(void)
{
 811a310:	b580      	push	{r7, lr}
 811a312:	af00      	add	r7, sp, #0
#ifdef LWIP_RAND
  udp_port = UDP_ENSURE_LOCAL_PORT_RANGE(LWIP_RAND());
 811a314:	f001 f986 	bl	811b624 <rand>
 811a318:	4603      	mov	r3, r0
 811a31a:	b29b      	uxth	r3, r3
 811a31c:	f3c3 030d 	ubfx	r3, r3, #0, #14
 811a320:	b29b      	uxth	r3, r3
 811a322:	f5a3 4380 	sub.w	r3, r3, #16384	; 0x4000
 811a326:	b29a      	uxth	r2, r3
 811a328:	4b01      	ldr	r3, [pc, #4]	; (811a330 <udp_init+0x20>)
 811a32a:	801a      	strh	r2, [r3, #0]
#endif /* LWIP_RAND */
}
 811a32c:	bf00      	nop
 811a32e:	bd80      	pop	{r7, pc}
 811a330:	1000010c 	.word	0x1000010c

0811a334 <udp_new_port>:
 *
 * @return a new (free) local UDP port number
 */
static u16_t
udp_new_port(void)
{
 811a334:	b480      	push	{r7}
 811a336:	b083      	sub	sp, #12
 811a338:	af00      	add	r7, sp, #0
  u16_t n = 0;
 811a33a:	2300      	movs	r3, #0
 811a33c:	80fb      	strh	r3, [r7, #6]
  struct udp_pcb *pcb;

again:
  if (udp_port++ == UDP_LOCAL_PORT_RANGE_END) {
 811a33e:	4b17      	ldr	r3, [pc, #92]	; (811a39c <udp_new_port+0x68>)
 811a340:	881b      	ldrh	r3, [r3, #0]
 811a342:	1c5a      	adds	r2, r3, #1
 811a344:	b291      	uxth	r1, r2
 811a346:	4a15      	ldr	r2, [pc, #84]	; (811a39c <udp_new_port+0x68>)
 811a348:	8011      	strh	r1, [r2, #0]
 811a34a:	f64f 72ff 	movw	r2, #65535	; 0xffff
 811a34e:	4293      	cmp	r3, r2
 811a350:	d103      	bne.n	811a35a <udp_new_port+0x26>
    udp_port = UDP_LOCAL_PORT_RANGE_START;
 811a352:	4b12      	ldr	r3, [pc, #72]	; (811a39c <udp_new_port+0x68>)
 811a354:	f44f 4240 	mov.w	r2, #49152	; 0xc000
 811a358:	801a      	strh	r2, [r3, #0]
  }
  /* Check all PCBs. */
  for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
 811a35a:	4b11      	ldr	r3, [pc, #68]	; (811a3a0 <udp_new_port+0x6c>)
 811a35c:	681b      	ldr	r3, [r3, #0]
 811a35e:	603b      	str	r3, [r7, #0]
 811a360:	e011      	b.n	811a386 <udp_new_port+0x52>
    if (pcb->local_port == udp_port) {
 811a362:	683b      	ldr	r3, [r7, #0]
 811a364:	8a5a      	ldrh	r2, [r3, #18]
 811a366:	4b0d      	ldr	r3, [pc, #52]	; (811a39c <udp_new_port+0x68>)
 811a368:	881b      	ldrh	r3, [r3, #0]
 811a36a:	429a      	cmp	r2, r3
 811a36c:	d108      	bne.n	811a380 <udp_new_port+0x4c>
      if (++n > (UDP_LOCAL_PORT_RANGE_END - UDP_LOCAL_PORT_RANGE_START)) {
 811a36e:	88fb      	ldrh	r3, [r7, #6]
 811a370:	3301      	adds	r3, #1
 811a372:	80fb      	strh	r3, [r7, #6]
 811a374:	88fb      	ldrh	r3, [r7, #6]
 811a376:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
 811a37a:	d3e0      	bcc.n	811a33e <udp_new_port+0xa>
        return 0;
 811a37c:	2300      	movs	r3, #0
 811a37e:	e007      	b.n	811a390 <udp_new_port+0x5c>
  for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
 811a380:	683b      	ldr	r3, [r7, #0]
 811a382:	68db      	ldr	r3, [r3, #12]
 811a384:	603b      	str	r3, [r7, #0]
 811a386:	683b      	ldr	r3, [r7, #0]
 811a388:	2b00      	cmp	r3, #0
 811a38a:	d1ea      	bne.n	811a362 <udp_new_port+0x2e>
      }
      goto again;
    }
  }
  return udp_port;
 811a38c:	4b03      	ldr	r3, [pc, #12]	; (811a39c <udp_new_port+0x68>)
 811a38e:	881b      	ldrh	r3, [r3, #0]
}
 811a390:	4618      	mov	r0, r3
 811a392:	370c      	adds	r7, #12
 811a394:	46bd      	mov	sp, r7
 811a396:	f85d 7b04 	ldr.w	r7, [sp], #4
 811a39a:	4770      	bx	lr
 811a39c:	1000010c 	.word	0x1000010c
 811a3a0:	100084a4 	.word	0x100084a4

0811a3a4 <udp_input_local_match>:
 * @param broadcast 1 if his is an IPv4 broadcast (global or subnet-only), 0 otherwise (only used for IPv4)
 * @return 1 on match, 0 otherwise
 */
static u8_t
udp_input_local_match(struct udp_pcb *pcb, struct netif *inp, u8_t broadcast)
{
 811a3a4:	b580      	push	{r7, lr}
 811a3a6:	b084      	sub	sp, #16
 811a3a8:	af00      	add	r7, sp, #0
 811a3aa:	60f8      	str	r0, [r7, #12]
 811a3ac:	60b9      	str	r1, [r7, #8]
 811a3ae:	4613      	mov	r3, r2
 811a3b0:	71fb      	strb	r3, [r7, #7]
  LWIP_UNUSED_ARG(inp);       /* in IPv6 only case */
  LWIP_UNUSED_ARG(broadcast); /* in IPv6 only case */

  LWIP_ASSERT("udp_input_local_match: invalid pcb", pcb != NULL);
 811a3b2:	68fb      	ldr	r3, [r7, #12]
 811a3b4:	2b00      	cmp	r3, #0
 811a3b6:	d105      	bne.n	811a3c4 <udp_input_local_match+0x20>
 811a3b8:	4b27      	ldr	r3, [pc, #156]	; (811a458 <udp_input_local_match+0xb4>)
 811a3ba:	2287      	movs	r2, #135	; 0x87
 811a3bc:	4927      	ldr	r1, [pc, #156]	; (811a45c <udp_input_local_match+0xb8>)
 811a3be:	4828      	ldr	r0, [pc, #160]	; (811a460 <udp_input_local_match+0xbc>)
 811a3c0:	f001 fa1e 	bl	811b800 <iprintf>
  LWIP_ASSERT("udp_input_local_match: invalid netif", inp != NULL);
 811a3c4:	68bb      	ldr	r3, [r7, #8]
 811a3c6:	2b00      	cmp	r3, #0
 811a3c8:	d105      	bne.n	811a3d6 <udp_input_local_match+0x32>
 811a3ca:	4b23      	ldr	r3, [pc, #140]	; (811a458 <udp_input_local_match+0xb4>)
 811a3cc:	2288      	movs	r2, #136	; 0x88
 811a3ce:	4925      	ldr	r1, [pc, #148]	; (811a464 <udp_input_local_match+0xc0>)
 811a3d0:	4823      	ldr	r0, [pc, #140]	; (811a460 <udp_input_local_match+0xbc>)
 811a3d2:	f001 fa15 	bl	811b800 <iprintf>

  /* check if PCB is bound to specific netif */
  if ((pcb->netif_idx != NETIF_NO_INDEX) &&
 811a3d6:	68fb      	ldr	r3, [r7, #12]
 811a3d8:	7a1b      	ldrb	r3, [r3, #8]
 811a3da:	2b00      	cmp	r3, #0
 811a3dc:	d00b      	beq.n	811a3f6 <udp_input_local_match+0x52>
      (pcb->netif_idx != netif_get_index(ip_data.current_input_netif))) {
 811a3de:	68fb      	ldr	r3, [r7, #12]
 811a3e0:	7a1a      	ldrb	r2, [r3, #8]
 811a3e2:	4b21      	ldr	r3, [pc, #132]	; (811a468 <udp_input_local_match+0xc4>)
 811a3e4:	685b      	ldr	r3, [r3, #4]
 811a3e6:	f893 3034 	ldrb.w	r3, [r3, #52]	; 0x34
 811a3ea:	3301      	adds	r3, #1
 811a3ec:	b2db      	uxtb	r3, r3
  if ((pcb->netif_idx != NETIF_NO_INDEX) &&
 811a3ee:	429a      	cmp	r2, r3
 811a3f0:	d001      	beq.n	811a3f6 <udp_input_local_match+0x52>
    return 0;
 811a3f2:	2300      	movs	r3, #0
 811a3f4:	e02b      	b.n	811a44e <udp_input_local_match+0xaa>
  /* Only need to check PCB if incoming IP version matches PCB IP version */
  if (IP_ADDR_PCB_VERSION_MATCH_EXACT(pcb, ip_current_dest_addr())) {
#if LWIP_IPV4
    /* Special case: IPv4 broadcast: all or broadcasts in my subnet
     * Note: broadcast variable can only be 1 if it is an IPv4 broadcast */
    if (broadcast != 0) {
 811a3f6:	79fb      	ldrb	r3, [r7, #7]
 811a3f8:	2b00      	cmp	r3, #0
 811a3fa:	d018      	beq.n	811a42e <udp_input_local_match+0x8a>
#if IP_SOF_BROADCAST_RECV
      if (ip_get_option(pcb, SOF_BROADCAST))
#endif /* IP_SOF_BROADCAST_RECV */
      {
        if (ip4_addr_isany(ip_2_ip4(&pcb->local_ip)) ||
 811a3fc:	68fb      	ldr	r3, [r7, #12]
 811a3fe:	2b00      	cmp	r3, #0
 811a400:	d013      	beq.n	811a42a <udp_input_local_match+0x86>
 811a402:	68fb      	ldr	r3, [r7, #12]
 811a404:	681b      	ldr	r3, [r3, #0]
 811a406:	2b00      	cmp	r3, #0
 811a408:	d00f      	beq.n	811a42a <udp_input_local_match+0x86>
            ((ip4_current_dest_addr()->addr == IPADDR_BROADCAST)) ||
 811a40a:	4b17      	ldr	r3, [pc, #92]	; (811a468 <udp_input_local_match+0xc4>)
 811a40c:	695b      	ldr	r3, [r3, #20]
        if (ip4_addr_isany(ip_2_ip4(&pcb->local_ip)) ||
 811a40e:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 811a412:	d00a      	beq.n	811a42a <udp_input_local_match+0x86>
            ip4_addr_netcmp(ip_2_ip4(&pcb->local_ip), ip4_current_dest_addr(), netif_ip4_netmask(inp))) {
 811a414:	68fb      	ldr	r3, [r7, #12]
 811a416:	681a      	ldr	r2, [r3, #0]
 811a418:	4b13      	ldr	r3, [pc, #76]	; (811a468 <udp_input_local_match+0xc4>)
 811a41a:	695b      	ldr	r3, [r3, #20]
 811a41c:	405a      	eors	r2, r3
 811a41e:	68bb      	ldr	r3, [r7, #8]
 811a420:	3308      	adds	r3, #8
 811a422:	681b      	ldr	r3, [r3, #0]
 811a424:	4013      	ands	r3, r2
            ((ip4_current_dest_addr()->addr == IPADDR_BROADCAST)) ||
 811a426:	2b00      	cmp	r3, #0
 811a428:	d110      	bne.n	811a44c <udp_input_local_match+0xa8>
          return 1;
 811a42a:	2301      	movs	r3, #1
 811a42c:	e00f      	b.n	811a44e <udp_input_local_match+0xaa>
        }
      }
    } else
#endif /* LWIP_IPV4 */
      /* Handle IPv4 and IPv6: all or exact match */
      if (ip_addr_isany(&pcb->local_ip) || ip_addr_cmp(&pcb->local_ip, ip_current_dest_addr())) {
 811a42e:	68fb      	ldr	r3, [r7, #12]
 811a430:	2b00      	cmp	r3, #0
 811a432:	d009      	beq.n	811a448 <udp_input_local_match+0xa4>
 811a434:	68fb      	ldr	r3, [r7, #12]
 811a436:	681b      	ldr	r3, [r3, #0]
 811a438:	2b00      	cmp	r3, #0
 811a43a:	d005      	beq.n	811a448 <udp_input_local_match+0xa4>
 811a43c:	68fb      	ldr	r3, [r7, #12]
 811a43e:	681a      	ldr	r2, [r3, #0]
 811a440:	4b09      	ldr	r3, [pc, #36]	; (811a468 <udp_input_local_match+0xc4>)
 811a442:	695b      	ldr	r3, [r3, #20]
 811a444:	429a      	cmp	r2, r3
 811a446:	d101      	bne.n	811a44c <udp_input_local_match+0xa8>
        return 1;
 811a448:	2301      	movs	r3, #1
 811a44a:	e000      	b.n	811a44e <udp_input_local_match+0xaa>
      }
  }

  return 0;
 811a44c:	2300      	movs	r3, #0
}
 811a44e:	4618      	mov	r0, r3
 811a450:	3710      	adds	r7, #16
 811a452:	46bd      	mov	sp, r7
 811a454:	bd80      	pop	{r7, pc}
 811a456:	bf00      	nop
 811a458:	0811f504 	.word	0x0811f504
 811a45c:	0811f568 	.word	0x0811f568
 811a460:	0811f58c 	.word	0x0811f58c
 811a464:	0811f5b4 	.word	0x0811f5b4
 811a468:	100054f0 	.word	0x100054f0

0811a46c <udp_input>:
 * @param inp network interface on which the datagram was received.
 *
 */
void
udp_input(struct pbuf *p, struct netif *inp)
{
 811a46c:	b590      	push	{r4, r7, lr}
 811a46e:	b08d      	sub	sp, #52	; 0x34
 811a470:	af02      	add	r7, sp, #8
 811a472:	6078      	str	r0, [r7, #4]
 811a474:	6039      	str	r1, [r7, #0]
  struct udp_hdr *udphdr;
  struct udp_pcb *pcb, *prev;
  struct udp_pcb *uncon_pcb;
  u16_t src, dest;
  u8_t broadcast;
  u8_t for_us = 0;
 811a476:	2300      	movs	r3, #0
 811a478:	76fb      	strb	r3, [r7, #27]

  LWIP_UNUSED_ARG(inp);

  LWIP_ASSERT_CORE_LOCKED();

  LWIP_ASSERT("udp_input: invalid pbuf", p != NULL);
 811a47a:	687b      	ldr	r3, [r7, #4]
 811a47c:	2b00      	cmp	r3, #0
 811a47e:	d105      	bne.n	811a48c <udp_input+0x20>
 811a480:	4b7c      	ldr	r3, [pc, #496]	; (811a674 <udp_input+0x208>)
 811a482:	22cf      	movs	r2, #207	; 0xcf
 811a484:	497c      	ldr	r1, [pc, #496]	; (811a678 <udp_input+0x20c>)
 811a486:	487d      	ldr	r0, [pc, #500]	; (811a67c <udp_input+0x210>)
 811a488:	f001 f9ba 	bl	811b800 <iprintf>
  LWIP_ASSERT("udp_input: invalid netif", inp != NULL);
 811a48c:	683b      	ldr	r3, [r7, #0]
 811a48e:	2b00      	cmp	r3, #0
 811a490:	d105      	bne.n	811a49e <udp_input+0x32>
 811a492:	4b78      	ldr	r3, [pc, #480]	; (811a674 <udp_input+0x208>)
 811a494:	22d0      	movs	r2, #208	; 0xd0
 811a496:	497a      	ldr	r1, [pc, #488]	; (811a680 <udp_input+0x214>)
 811a498:	4878      	ldr	r0, [pc, #480]	; (811a67c <udp_input+0x210>)
 811a49a:	f001 f9b1 	bl	811b800 <iprintf>
  PERF_START;

  UDP_STATS_INC(udp.recv);

  /* Check minimum length (UDP header) */
  if (p->len < UDP_HLEN) {
 811a49e:	687b      	ldr	r3, [r7, #4]
 811a4a0:	895b      	ldrh	r3, [r3, #10]
 811a4a2:	2b07      	cmp	r3, #7
 811a4a4:	d803      	bhi.n	811a4ae <udp_input+0x42>
    LWIP_DEBUGF(UDP_DEBUG,
                ("udp_input: short UDP datagram (%"U16_F" bytes) discarded\n", p->tot_len));
    UDP_STATS_INC(udp.lenerr);
    UDP_STATS_INC(udp.drop);
    MIB2_STATS_INC(mib2.udpinerrors);
    pbuf_free(p);
 811a4a6:	6878      	ldr	r0, [r7, #4]
 811a4a8:	f7fa f8d6 	bl	8114658 <pbuf_free>
    goto end;
 811a4ac:	e0de      	b.n	811a66c <udp_input+0x200>
  }

  udphdr = (struct udp_hdr *)p->payload;
 811a4ae:	687b      	ldr	r3, [r7, #4]
 811a4b0:	685b      	ldr	r3, [r3, #4]
 811a4b2:	617b      	str	r3, [r7, #20]

  /* is broadcast packet ? */
  broadcast = ip_addr_isbroadcast(ip_current_dest_addr(), ip_current_netif());
 811a4b4:	4b73      	ldr	r3, [pc, #460]	; (811a684 <udp_input+0x218>)
 811a4b6:	695b      	ldr	r3, [r3, #20]
 811a4b8:	4a72      	ldr	r2, [pc, #456]	; (811a684 <udp_input+0x218>)
 811a4ba:	6812      	ldr	r2, [r2, #0]
 811a4bc:	4611      	mov	r1, r2
 811a4be:	4618      	mov	r0, r3
 811a4c0:	f7f7 ff48 	bl	8112354 <ip4_addr_isbroadcast_u32>
 811a4c4:	4603      	mov	r3, r0
 811a4c6:	74fb      	strb	r3, [r7, #19]

  LWIP_DEBUGF(UDP_DEBUG, ("udp_input: received datagram of length %"U16_F"\n", p->tot_len));

  /* convert src and dest ports to host byte order */
  src = lwip_ntohs(udphdr->src);
 811a4c8:	697b      	ldr	r3, [r7, #20]
 811a4ca:	881b      	ldrh	r3, [r3, #0]
 811a4cc:	b29b      	uxth	r3, r3
 811a4ce:	4618      	mov	r0, r3
 811a4d0:	f7f3 ffdf 	bl	810e492 <lwip_htons>
 811a4d4:	4603      	mov	r3, r0
 811a4d6:	823b      	strh	r3, [r7, #16]
  dest = lwip_ntohs(udphdr->dest);
 811a4d8:	697b      	ldr	r3, [r7, #20]
 811a4da:	885b      	ldrh	r3, [r3, #2]
 811a4dc:	b29b      	uxth	r3, r3
 811a4de:	4618      	mov	r0, r3
 811a4e0:	f7f3 ffd7 	bl	810e492 <lwip_htons>
 811a4e4:	4603      	mov	r3, r0
 811a4e6:	81fb      	strh	r3, [r7, #14]
  ip_addr_debug_print_val(UDP_DEBUG, *ip_current_dest_addr());
  LWIP_DEBUGF(UDP_DEBUG, (", %"U16_F") <-- (", lwip_ntohs(udphdr->dest)));
  ip_addr_debug_print_val(UDP_DEBUG, *ip_current_src_addr());
  LWIP_DEBUGF(UDP_DEBUG, (", %"U16_F")\n", lwip_ntohs(udphdr->src)));

  pcb = NULL;
 811a4e8:	2300      	movs	r3, #0
 811a4ea:	627b      	str	r3, [r7, #36]	; 0x24
  prev = NULL;
 811a4ec:	2300      	movs	r3, #0
 811a4ee:	623b      	str	r3, [r7, #32]
  uncon_pcb = NULL;
 811a4f0:	2300      	movs	r3, #0
 811a4f2:	61fb      	str	r3, [r7, #28]
  /* Iterate through the UDP pcb list for a matching pcb.
   * 'Perfect match' pcbs (connected to the remote port & ip address) are
   * preferred. If no perfect match is found, the first unconnected pcb that
   * matches the local port and ip address gets the datagram. */
  for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
 811a4f4:	4b64      	ldr	r3, [pc, #400]	; (811a688 <udp_input+0x21c>)
 811a4f6:	681b      	ldr	r3, [r3, #0]
 811a4f8:	627b      	str	r3, [r7, #36]	; 0x24
 811a4fa:	e054      	b.n	811a5a6 <udp_input+0x13a>
    LWIP_DEBUGF(UDP_DEBUG, (", %"U16_F") <-- (", pcb->local_port));
    ip_addr_debug_print_val(UDP_DEBUG, pcb->remote_ip);
    LWIP_DEBUGF(UDP_DEBUG, (", %"U16_F")\n", pcb->remote_port));

    /* compare PCB local addr+port to UDP destination addr+port */
    if ((pcb->local_port == dest) &&
 811a4fc:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 811a4fe:	8a5b      	ldrh	r3, [r3, #18]
 811a500:	89fa      	ldrh	r2, [r7, #14]
 811a502:	429a      	cmp	r2, r3
 811a504:	d14a      	bne.n	811a59c <udp_input+0x130>
        (udp_input_local_match(pcb, inp, broadcast) != 0)) {
 811a506:	7cfb      	ldrb	r3, [r7, #19]
 811a508:	461a      	mov	r2, r3
 811a50a:	6839      	ldr	r1, [r7, #0]
 811a50c:	6a78      	ldr	r0, [r7, #36]	; 0x24
 811a50e:	f7ff ff49 	bl	811a3a4 <udp_input_local_match>
 811a512:	4603      	mov	r3, r0
    if ((pcb->local_port == dest) &&
 811a514:	2b00      	cmp	r3, #0
 811a516:	d041      	beq.n	811a59c <udp_input+0x130>
      if ((pcb->flags & UDP_FLAGS_CONNECTED) == 0) {
 811a518:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 811a51a:	7c1b      	ldrb	r3, [r3, #16]
 811a51c:	f003 0304 	and.w	r3, r3, #4
 811a520:	2b00      	cmp	r3, #0
 811a522:	d11d      	bne.n	811a560 <udp_input+0xf4>
        if (uncon_pcb == NULL) {
 811a524:	69fb      	ldr	r3, [r7, #28]
 811a526:	2b00      	cmp	r3, #0
 811a528:	d102      	bne.n	811a530 <udp_input+0xc4>
          /* the first unconnected matching PCB */
          uncon_pcb = pcb;
 811a52a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 811a52c:	61fb      	str	r3, [r7, #28]
 811a52e:	e017      	b.n	811a560 <udp_input+0xf4>
#if LWIP_IPV4
        } else if (broadcast && ip4_current_dest_addr()->addr == IPADDR_BROADCAST) {
 811a530:	7cfb      	ldrb	r3, [r7, #19]
 811a532:	2b00      	cmp	r3, #0
 811a534:	d014      	beq.n	811a560 <udp_input+0xf4>
 811a536:	4b53      	ldr	r3, [pc, #332]	; (811a684 <udp_input+0x218>)
 811a538:	695b      	ldr	r3, [r3, #20]
 811a53a:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 811a53e:	d10f      	bne.n	811a560 <udp_input+0xf4>
          /* global broadcast address (only valid for IPv4; match was checked before) */
          if (!IP_IS_V4_VAL(uncon_pcb->local_ip) || !ip4_addr_cmp(ip_2_ip4(&uncon_pcb->local_ip), netif_ip4_addr(inp))) {
 811a540:	69fb      	ldr	r3, [r7, #28]
 811a542:	681a      	ldr	r2, [r3, #0]
 811a544:	683b      	ldr	r3, [r7, #0]
 811a546:	3304      	adds	r3, #4
 811a548:	681b      	ldr	r3, [r3, #0]
 811a54a:	429a      	cmp	r2, r3
 811a54c:	d008      	beq.n	811a560 <udp_input+0xf4>
            /* uncon_pcb does not match the input netif, check this pcb */
            if (IP_IS_V4_VAL(pcb->local_ip) && ip4_addr_cmp(ip_2_ip4(&pcb->local_ip), netif_ip4_addr(inp))) {
 811a54e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 811a550:	681a      	ldr	r2, [r3, #0]
 811a552:	683b      	ldr	r3, [r7, #0]
 811a554:	3304      	adds	r3, #4
 811a556:	681b      	ldr	r3, [r3, #0]
 811a558:	429a      	cmp	r2, r3
 811a55a:	d101      	bne.n	811a560 <udp_input+0xf4>
              /* better match */
              uncon_pcb = pcb;
 811a55c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 811a55e:	61fb      	str	r3, [r7, #28]
        }
#endif /* SO_REUSE */
      }

      /* compare PCB remote addr+port to UDP source addr+port */
      if ((pcb->remote_port == src) &&
 811a560:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 811a562:	8a9b      	ldrh	r3, [r3, #20]
 811a564:	8a3a      	ldrh	r2, [r7, #16]
 811a566:	429a      	cmp	r2, r3
 811a568:	d118      	bne.n	811a59c <udp_input+0x130>
          (ip_addr_isany_val(pcb->remote_ip) ||
 811a56a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 811a56c:	685b      	ldr	r3, [r3, #4]
      if ((pcb->remote_port == src) &&
 811a56e:	2b00      	cmp	r3, #0
 811a570:	d005      	beq.n	811a57e <udp_input+0x112>
           ip_addr_cmp(&pcb->remote_ip, ip_current_src_addr()))) {
 811a572:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 811a574:	685a      	ldr	r2, [r3, #4]
 811a576:	4b43      	ldr	r3, [pc, #268]	; (811a684 <udp_input+0x218>)
 811a578:	691b      	ldr	r3, [r3, #16]
          (ip_addr_isany_val(pcb->remote_ip) ||
 811a57a:	429a      	cmp	r2, r3
 811a57c:	d10e      	bne.n	811a59c <udp_input+0x130>
        /* the first fully matching PCB */
        if (prev != NULL) {
 811a57e:	6a3b      	ldr	r3, [r7, #32]
 811a580:	2b00      	cmp	r3, #0
 811a582:	d014      	beq.n	811a5ae <udp_input+0x142>
          /* move the pcb to the front of udp_pcbs so that is
             found faster next time */
          prev->next = pcb->next;
 811a584:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 811a586:	68da      	ldr	r2, [r3, #12]
 811a588:	6a3b      	ldr	r3, [r7, #32]
 811a58a:	60da      	str	r2, [r3, #12]
          pcb->next = udp_pcbs;
 811a58c:	4b3e      	ldr	r3, [pc, #248]	; (811a688 <udp_input+0x21c>)
 811a58e:	681a      	ldr	r2, [r3, #0]
 811a590:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 811a592:	60da      	str	r2, [r3, #12]
          udp_pcbs = pcb;
 811a594:	4a3c      	ldr	r2, [pc, #240]	; (811a688 <udp_input+0x21c>)
 811a596:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 811a598:	6013      	str	r3, [r2, #0]
        } else {
          UDP_STATS_INC(udp.cachehit);
        }
        break;
 811a59a:	e008      	b.n	811a5ae <udp_input+0x142>
      }
    }

    prev = pcb;
 811a59c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 811a59e:	623b      	str	r3, [r7, #32]
  for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
 811a5a0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 811a5a2:	68db      	ldr	r3, [r3, #12]
 811a5a4:	627b      	str	r3, [r7, #36]	; 0x24
 811a5a6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 811a5a8:	2b00      	cmp	r3, #0
 811a5aa:	d1a7      	bne.n	811a4fc <udp_input+0x90>
 811a5ac:	e000      	b.n	811a5b0 <udp_input+0x144>
        break;
 811a5ae:	bf00      	nop
  }
  /* no fully matching pcb found? then look for an unconnected pcb */
  if (pcb == NULL) {
 811a5b0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 811a5b2:	2b00      	cmp	r3, #0
 811a5b4:	d101      	bne.n	811a5ba <udp_input+0x14e>
    pcb = uncon_pcb;
 811a5b6:	69fb      	ldr	r3, [r7, #28]
 811a5b8:	627b      	str	r3, [r7, #36]	; 0x24
  }

  /* Check checksum if this is a match or if it was directed at us. */
  if (pcb != NULL) {
 811a5ba:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 811a5bc:	2b00      	cmp	r3, #0
 811a5be:	d002      	beq.n	811a5c6 <udp_input+0x15a>
    for_us = 1;
 811a5c0:	2301      	movs	r3, #1
 811a5c2:	76fb      	strb	r3, [r7, #27]
 811a5c4:	e00a      	b.n	811a5dc <udp_input+0x170>
      for_us = netif_get_ip6_addr_match(inp, ip6_current_dest_addr()) >= 0;
    }
#endif /* LWIP_IPV6 */
#if LWIP_IPV4
    if (!ip_current_is_v6()) {
      for_us = ip4_addr_cmp(netif_ip4_addr(inp), ip4_current_dest_addr());
 811a5c6:	683b      	ldr	r3, [r7, #0]
 811a5c8:	3304      	adds	r3, #4
 811a5ca:	681a      	ldr	r2, [r3, #0]
 811a5cc:	4b2d      	ldr	r3, [pc, #180]	; (811a684 <udp_input+0x218>)
 811a5ce:	695b      	ldr	r3, [r3, #20]
 811a5d0:	429a      	cmp	r2, r3
 811a5d2:	bf0c      	ite	eq
 811a5d4:	2301      	moveq	r3, #1
 811a5d6:	2300      	movne	r3, #0
 811a5d8:	b2db      	uxtb	r3, r3
 811a5da:	76fb      	strb	r3, [r7, #27]
    }
#endif /* LWIP_IPV4 */
  }

  if (for_us) {
 811a5dc:	7efb      	ldrb	r3, [r7, #27]
 811a5de:	2b00      	cmp	r3, #0
 811a5e0:	d041      	beq.n	811a666 <udp_input+0x1fa>
          }
        }
      }
    }
#endif /* CHECKSUM_CHECK_UDP */
    if (pbuf_remove_header(p, UDP_HLEN)) {
 811a5e2:	2108      	movs	r1, #8
 811a5e4:	6878      	ldr	r0, [r7, #4]
 811a5e6:	f7f9 ffb1 	bl	811454c <pbuf_remove_header>
 811a5ea:	4603      	mov	r3, r0
 811a5ec:	2b00      	cmp	r3, #0
 811a5ee:	d00a      	beq.n	811a606 <udp_input+0x19a>
      /* Can we cope with this failing? Just assert for now */
      LWIP_ASSERT("pbuf_remove_header failed\n", 0);
 811a5f0:	4b20      	ldr	r3, [pc, #128]	; (811a674 <udp_input+0x208>)
 811a5f2:	f44f 72b8 	mov.w	r2, #368	; 0x170
 811a5f6:	4925      	ldr	r1, [pc, #148]	; (811a68c <udp_input+0x220>)
 811a5f8:	4820      	ldr	r0, [pc, #128]	; (811a67c <udp_input+0x210>)
 811a5fa:	f001 f901 	bl	811b800 <iprintf>
      UDP_STATS_INC(udp.drop);
      MIB2_STATS_INC(mib2.udpinerrors);
      pbuf_free(p);
 811a5fe:	6878      	ldr	r0, [r7, #4]
 811a600:	f7fa f82a 	bl	8114658 <pbuf_free>
      goto end;
 811a604:	e032      	b.n	811a66c <udp_input+0x200>
    }

    if (pcb != NULL) {
 811a606:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 811a608:	2b00      	cmp	r3, #0
 811a60a:	d012      	beq.n	811a632 <udp_input+0x1c6>
          }
        }
      }
#endif /* SO_REUSE && SO_REUSE_RXTOALL */
      /* callback */
      if (pcb->recv != NULL) {
 811a60c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 811a60e:	699b      	ldr	r3, [r3, #24]
 811a610:	2b00      	cmp	r3, #0
 811a612:	d00a      	beq.n	811a62a <udp_input+0x1be>
        /* now the recv function is responsible for freeing p */
        pcb->recv(pcb->recv_arg, pcb, p, ip_current_src_addr(), src);
 811a614:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 811a616:	699c      	ldr	r4, [r3, #24]
 811a618:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 811a61a:	69d8      	ldr	r0, [r3, #28]
 811a61c:	8a3b      	ldrh	r3, [r7, #16]
 811a61e:	9300      	str	r3, [sp, #0]
 811a620:	4b1b      	ldr	r3, [pc, #108]	; (811a690 <udp_input+0x224>)
 811a622:	687a      	ldr	r2, [r7, #4]
 811a624:	6a79      	ldr	r1, [r7, #36]	; 0x24
 811a626:	47a0      	blx	r4
  } else {
    pbuf_free(p);
  }
end:
  PERF_STOP("udp_input");
  return;
 811a628:	e021      	b.n	811a66e <udp_input+0x202>
        pbuf_free(p);
 811a62a:	6878      	ldr	r0, [r7, #4]
 811a62c:	f7fa f814 	bl	8114658 <pbuf_free>
        goto end;
 811a630:	e01c      	b.n	811a66c <udp_input+0x200>
      if (!broadcast && !ip_addr_ismulticast(ip_current_dest_addr())) {
 811a632:	7cfb      	ldrb	r3, [r7, #19]
 811a634:	2b00      	cmp	r3, #0
 811a636:	d112      	bne.n	811a65e <udp_input+0x1f2>
 811a638:	4b12      	ldr	r3, [pc, #72]	; (811a684 <udp_input+0x218>)
 811a63a:	695b      	ldr	r3, [r3, #20]
 811a63c:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 811a640:	2be0      	cmp	r3, #224	; 0xe0
 811a642:	d00c      	beq.n	811a65e <udp_input+0x1f2>
        pbuf_header_force(p, (s16_t)(ip_current_header_tot_len() + UDP_HLEN));
 811a644:	4b0f      	ldr	r3, [pc, #60]	; (811a684 <udp_input+0x218>)
 811a646:	899b      	ldrh	r3, [r3, #12]
 811a648:	3308      	adds	r3, #8
 811a64a:	b29b      	uxth	r3, r3
 811a64c:	b21b      	sxth	r3, r3
 811a64e:	4619      	mov	r1, r3
 811a650:	6878      	ldr	r0, [r7, #4]
 811a652:	f7f9 ffee 	bl	8114632 <pbuf_header_force>
        icmp_port_unreach(ip_current_is_v6(), p);
 811a656:	2103      	movs	r1, #3
 811a658:	6878      	ldr	r0, [r7, #4]
 811a65a:	f7f7 fa5f 	bl	8111b1c <icmp_dest_unreach>
      pbuf_free(p);
 811a65e:	6878      	ldr	r0, [r7, #4]
 811a660:	f7f9 fffa 	bl	8114658 <pbuf_free>
  return;
 811a664:	e003      	b.n	811a66e <udp_input+0x202>
    pbuf_free(p);
 811a666:	6878      	ldr	r0, [r7, #4]
 811a668:	f7f9 fff6 	bl	8114658 <pbuf_free>
  return;
 811a66c:	bf00      	nop
  UDP_STATS_INC(udp.drop);
  MIB2_STATS_INC(mib2.udpinerrors);
  pbuf_free(p);
  PERF_STOP("udp_input");
#endif /* CHECKSUM_CHECK_UDP */
}
 811a66e:	372c      	adds	r7, #44	; 0x2c
 811a670:	46bd      	mov	sp, r7
 811a672:	bd90      	pop	{r4, r7, pc}
 811a674:	0811f504 	.word	0x0811f504
 811a678:	0811f5dc 	.word	0x0811f5dc
 811a67c:	0811f58c 	.word	0x0811f58c
 811a680:	0811f5f4 	.word	0x0811f5f4
 811a684:	100054f0 	.word	0x100054f0
 811a688:	100084a4 	.word	0x100084a4
 811a68c:	0811f610 	.word	0x0811f610
 811a690:	10005500 	.word	0x10005500

0811a694 <udp_sendto>:
 * @see udp_disconnect() udp_send()
 */
err_t
udp_sendto(struct udp_pcb *pcb, struct pbuf *p,
           const ip_addr_t *dst_ip, u16_t dst_port)
{
 811a694:	b580      	push	{r7, lr}
 811a696:	b088      	sub	sp, #32
 811a698:	af02      	add	r7, sp, #8
 811a69a:	60f8      	str	r0, [r7, #12]
 811a69c:	60b9      	str	r1, [r7, #8]
 811a69e:	607a      	str	r2, [r7, #4]
 811a6a0:	807b      	strh	r3, [r7, #2]
                  u16_t dst_port, u8_t have_chksum, u16_t chksum)
{
#endif /* LWIP_CHECKSUM_ON_COPY && CHECKSUM_GEN_UDP */
  struct netif *netif;

  LWIP_ERROR("udp_sendto: invalid pcb", pcb != NULL, return ERR_ARG);
 811a6a2:	68fb      	ldr	r3, [r7, #12]
 811a6a4:	2b00      	cmp	r3, #0
 811a6a6:	d109      	bne.n	811a6bc <udp_sendto+0x28>
 811a6a8:	4b23      	ldr	r3, [pc, #140]	; (811a738 <udp_sendto+0xa4>)
 811a6aa:	f44f 7206 	mov.w	r2, #536	; 0x218
 811a6ae:	4923      	ldr	r1, [pc, #140]	; (811a73c <udp_sendto+0xa8>)
 811a6b0:	4823      	ldr	r0, [pc, #140]	; (811a740 <udp_sendto+0xac>)
 811a6b2:	f001 f8a5 	bl	811b800 <iprintf>
 811a6b6:	f06f 030f 	mvn.w	r3, #15
 811a6ba:	e038      	b.n	811a72e <udp_sendto+0x9a>
  LWIP_ERROR("udp_sendto: invalid pbuf", p != NULL, return ERR_ARG);
 811a6bc:	68bb      	ldr	r3, [r7, #8]
 811a6be:	2b00      	cmp	r3, #0
 811a6c0:	d109      	bne.n	811a6d6 <udp_sendto+0x42>
 811a6c2:	4b1d      	ldr	r3, [pc, #116]	; (811a738 <udp_sendto+0xa4>)
 811a6c4:	f240 2219 	movw	r2, #537	; 0x219
 811a6c8:	491e      	ldr	r1, [pc, #120]	; (811a744 <udp_sendto+0xb0>)
 811a6ca:	481d      	ldr	r0, [pc, #116]	; (811a740 <udp_sendto+0xac>)
 811a6cc:	f001 f898 	bl	811b800 <iprintf>
 811a6d0:	f06f 030f 	mvn.w	r3, #15
 811a6d4:	e02b      	b.n	811a72e <udp_sendto+0x9a>
  LWIP_ERROR("udp_sendto: invalid dst_ip", dst_ip != NULL, return ERR_ARG);
 811a6d6:	687b      	ldr	r3, [r7, #4]
 811a6d8:	2b00      	cmp	r3, #0
 811a6da:	d109      	bne.n	811a6f0 <udp_sendto+0x5c>
 811a6dc:	4b16      	ldr	r3, [pc, #88]	; (811a738 <udp_sendto+0xa4>)
 811a6de:	f240 221a 	movw	r2, #538	; 0x21a
 811a6e2:	4919      	ldr	r1, [pc, #100]	; (811a748 <udp_sendto+0xb4>)
 811a6e4:	4816      	ldr	r0, [pc, #88]	; (811a740 <udp_sendto+0xac>)
 811a6e6:	f001 f88b 	bl	811b800 <iprintf>
 811a6ea:	f06f 030f 	mvn.w	r3, #15
 811a6ee:	e01e      	b.n	811a72e <udp_sendto+0x9a>
    return ERR_VAL;
  }

  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, ("udp_send\n"));

  if (pcb->netif_idx != NETIF_NO_INDEX) {
 811a6f0:	68fb      	ldr	r3, [r7, #12]
 811a6f2:	7a1b      	ldrb	r3, [r3, #8]
 811a6f4:	2b00      	cmp	r3, #0
 811a6f6:	d006      	beq.n	811a706 <udp_sendto+0x72>
    netif = netif_get_by_index(pcb->netif_idx);
 811a6f8:	68fb      	ldr	r3, [r7, #12]
 811a6fa:	7a1b      	ldrb	r3, [r3, #8]
 811a6fc:	4618      	mov	r0, r3
 811a6fe:	f7f9 fc6b 	bl	8113fd8 <netif_get_by_index>
 811a702:	6178      	str	r0, [r7, #20]
 811a704:	e003      	b.n	811a70e <udp_sendto+0x7a>

    if (netif == NULL)
#endif /* LWIP_MULTICAST_TX_OPTIONS */
    {
      /* find the outgoing network interface for this packet */
      netif = ip_route(&pcb->local_ip, dst_ip);
 811a706:	6878      	ldr	r0, [r7, #4]
 811a708:	f7f7 fb70 	bl	8111dec <ip4_route>
 811a70c:	6178      	str	r0, [r7, #20]
    }
  }

  /* no outgoing network interface could be found? */
  if (netif == NULL) {
 811a70e:	697b      	ldr	r3, [r7, #20]
 811a710:	2b00      	cmp	r3, #0
 811a712:	d102      	bne.n	811a71a <udp_sendto+0x86>
    LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("udp_send: No route to "));
    ip_addr_debug_print(UDP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, dst_ip);
    LWIP_DEBUGF(UDP_DEBUG, ("\n"));
    UDP_STATS_INC(udp.rterr);
    return ERR_RTE;
 811a714:	f06f 0303 	mvn.w	r3, #3
 811a718:	e009      	b.n	811a72e <udp_sendto+0x9a>
  }
#if LWIP_CHECKSUM_ON_COPY && CHECKSUM_GEN_UDP
  return udp_sendto_if_chksum(pcb, p, dst_ip, dst_port, netif, have_chksum, chksum);
#else /* LWIP_CHECKSUM_ON_COPY && CHECKSUM_GEN_UDP */
  return udp_sendto_if(pcb, p, dst_ip, dst_port, netif);
 811a71a:	887a      	ldrh	r2, [r7, #2]
 811a71c:	697b      	ldr	r3, [r7, #20]
 811a71e:	9300      	str	r3, [sp, #0]
 811a720:	4613      	mov	r3, r2
 811a722:	687a      	ldr	r2, [r7, #4]
 811a724:	68b9      	ldr	r1, [r7, #8]
 811a726:	68f8      	ldr	r0, [r7, #12]
 811a728:	f000 f810 	bl	811a74c <udp_sendto_if>
 811a72c:	4603      	mov	r3, r0
#endif /* LWIP_CHECKSUM_ON_COPY && CHECKSUM_GEN_UDP */
}
 811a72e:	4618      	mov	r0, r3
 811a730:	3718      	adds	r7, #24
 811a732:	46bd      	mov	sp, r7
 811a734:	bd80      	pop	{r7, pc}
 811a736:	bf00      	nop
 811a738:	0811f504 	.word	0x0811f504
 811a73c:	0811f65c 	.word	0x0811f65c
 811a740:	0811f58c 	.word	0x0811f58c
 811a744:	0811f674 	.word	0x0811f674
 811a748:	0811f690 	.word	0x0811f690

0811a74c <udp_sendto_if>:
 * @see udp_disconnect() udp_send()
 */
err_t
udp_sendto_if(struct udp_pcb *pcb, struct pbuf *p,
              const ip_addr_t *dst_ip, u16_t dst_port, struct netif *netif)
{
 811a74c:	b580      	push	{r7, lr}
 811a74e:	b088      	sub	sp, #32
 811a750:	af02      	add	r7, sp, #8
 811a752:	60f8      	str	r0, [r7, #12]
 811a754:	60b9      	str	r1, [r7, #8]
 811a756:	607a      	str	r2, [r7, #4]
 811a758:	807b      	strh	r3, [r7, #2]
                     u16_t chksum)
{
#endif /* LWIP_CHECKSUM_ON_COPY && CHECKSUM_GEN_UDP */
  const ip_addr_t *src_ip;

  LWIP_ERROR("udp_sendto_if: invalid pcb", pcb != NULL, return ERR_ARG);
 811a75a:	68fb      	ldr	r3, [r7, #12]
 811a75c:	2b00      	cmp	r3, #0
 811a75e:	d109      	bne.n	811a774 <udp_sendto_if+0x28>
 811a760:	4b2e      	ldr	r3, [pc, #184]	; (811a81c <udp_sendto_if+0xd0>)
 811a762:	f44f 7220 	mov.w	r2, #640	; 0x280
 811a766:	492e      	ldr	r1, [pc, #184]	; (811a820 <udp_sendto_if+0xd4>)
 811a768:	482e      	ldr	r0, [pc, #184]	; (811a824 <udp_sendto_if+0xd8>)
 811a76a:	f001 f849 	bl	811b800 <iprintf>
 811a76e:	f06f 030f 	mvn.w	r3, #15
 811a772:	e04f      	b.n	811a814 <udp_sendto_if+0xc8>
  LWIP_ERROR("udp_sendto_if: invalid pbuf", p != NULL, return ERR_ARG);
 811a774:	68bb      	ldr	r3, [r7, #8]
 811a776:	2b00      	cmp	r3, #0
 811a778:	d109      	bne.n	811a78e <udp_sendto_if+0x42>
 811a77a:	4b28      	ldr	r3, [pc, #160]	; (811a81c <udp_sendto_if+0xd0>)
 811a77c:	f240 2281 	movw	r2, #641	; 0x281
 811a780:	4929      	ldr	r1, [pc, #164]	; (811a828 <udp_sendto_if+0xdc>)
 811a782:	4828      	ldr	r0, [pc, #160]	; (811a824 <udp_sendto_if+0xd8>)
 811a784:	f001 f83c 	bl	811b800 <iprintf>
 811a788:	f06f 030f 	mvn.w	r3, #15
 811a78c:	e042      	b.n	811a814 <udp_sendto_if+0xc8>
  LWIP_ERROR("udp_sendto_if: invalid dst_ip", dst_ip != NULL, return ERR_ARG);
 811a78e:	687b      	ldr	r3, [r7, #4]
 811a790:	2b00      	cmp	r3, #0
 811a792:	d109      	bne.n	811a7a8 <udp_sendto_if+0x5c>
 811a794:	4b21      	ldr	r3, [pc, #132]	; (811a81c <udp_sendto_if+0xd0>)
 811a796:	f240 2282 	movw	r2, #642	; 0x282
 811a79a:	4924      	ldr	r1, [pc, #144]	; (811a82c <udp_sendto_if+0xe0>)
 811a79c:	4821      	ldr	r0, [pc, #132]	; (811a824 <udp_sendto_if+0xd8>)
 811a79e:	f001 f82f 	bl	811b800 <iprintf>
 811a7a2:	f06f 030f 	mvn.w	r3, #15
 811a7a6:	e035      	b.n	811a814 <udp_sendto_if+0xc8>
  LWIP_ERROR("udp_sendto_if: invalid netif", netif != NULL, return ERR_ARG);
 811a7a8:	6a3b      	ldr	r3, [r7, #32]
 811a7aa:	2b00      	cmp	r3, #0
 811a7ac:	d109      	bne.n	811a7c2 <udp_sendto_if+0x76>
 811a7ae:	4b1b      	ldr	r3, [pc, #108]	; (811a81c <udp_sendto_if+0xd0>)
 811a7b0:	f240 2283 	movw	r2, #643	; 0x283
 811a7b4:	491e      	ldr	r1, [pc, #120]	; (811a830 <udp_sendto_if+0xe4>)
 811a7b6:	481b      	ldr	r0, [pc, #108]	; (811a824 <udp_sendto_if+0xd8>)
 811a7b8:	f001 f822 	bl	811b800 <iprintf>
 811a7bc:	f06f 030f 	mvn.w	r3, #15
 811a7c0:	e028      	b.n	811a814 <udp_sendto_if+0xc8>
#endif /* LWIP_IPV6 */
#if LWIP_IPV4 && LWIP_IPV6
  else
#endif /* LWIP_IPV4 && LWIP_IPV6 */
#if LWIP_IPV4
    if (ip4_addr_isany(ip_2_ip4(&pcb->local_ip)) ||
 811a7c2:	68fb      	ldr	r3, [r7, #12]
 811a7c4:	2b00      	cmp	r3, #0
 811a7c6:	d009      	beq.n	811a7dc <udp_sendto_if+0x90>
 811a7c8:	68fb      	ldr	r3, [r7, #12]
 811a7ca:	681b      	ldr	r3, [r3, #0]
 811a7cc:	2b00      	cmp	r3, #0
 811a7ce:	d005      	beq.n	811a7dc <udp_sendto_if+0x90>
        ip4_addr_ismulticast(ip_2_ip4(&pcb->local_ip))) {
 811a7d0:	68fb      	ldr	r3, [r7, #12]
 811a7d2:	681b      	ldr	r3, [r3, #0]
 811a7d4:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
    if (ip4_addr_isany(ip_2_ip4(&pcb->local_ip)) ||
 811a7d8:	2be0      	cmp	r3, #224	; 0xe0
 811a7da:	d103      	bne.n	811a7e4 <udp_sendto_if+0x98>
      /* if the local_ip is any or multicast
       * use the outgoing network interface IP address as source address */
      src_ip = netif_ip_addr4(netif);
 811a7dc:	6a3b      	ldr	r3, [r7, #32]
 811a7de:	3304      	adds	r3, #4
 811a7e0:	617b      	str	r3, [r7, #20]
 811a7e2:	e00b      	b.n	811a7fc <udp_sendto_if+0xb0>
    } else {
      /* check if UDP PCB local IP address is correct
       * this could be an old address if netif->ip_addr has changed */
      if (!ip4_addr_cmp(ip_2_ip4(&(pcb->local_ip)), netif_ip4_addr(netif))) {
 811a7e4:	68fb      	ldr	r3, [r7, #12]
 811a7e6:	681a      	ldr	r2, [r3, #0]
 811a7e8:	6a3b      	ldr	r3, [r7, #32]
 811a7ea:	3304      	adds	r3, #4
 811a7ec:	681b      	ldr	r3, [r3, #0]
 811a7ee:	429a      	cmp	r2, r3
 811a7f0:	d002      	beq.n	811a7f8 <udp_sendto_if+0xac>
        /* local_ip doesn't match, drop the packet */
        return ERR_RTE;
 811a7f2:	f06f 0303 	mvn.w	r3, #3
 811a7f6:	e00d      	b.n	811a814 <udp_sendto_if+0xc8>
      }
      /* use UDP PCB local IP address as source address */
      src_ip = &pcb->local_ip;
 811a7f8:	68fb      	ldr	r3, [r7, #12]
 811a7fa:	617b      	str	r3, [r7, #20]
    }
#endif /* LWIP_IPV4 */
#if LWIP_CHECKSUM_ON_COPY && CHECKSUM_GEN_UDP
  return udp_sendto_if_src_chksum(pcb, p, dst_ip, dst_port, netif, have_chksum, chksum, src_ip);
#else /* LWIP_CHECKSUM_ON_COPY && CHECKSUM_GEN_UDP */
  return udp_sendto_if_src(pcb, p, dst_ip, dst_port, netif, src_ip);
 811a7fc:	887a      	ldrh	r2, [r7, #2]
 811a7fe:	697b      	ldr	r3, [r7, #20]
 811a800:	9301      	str	r3, [sp, #4]
 811a802:	6a3b      	ldr	r3, [r7, #32]
 811a804:	9300      	str	r3, [sp, #0]
 811a806:	4613      	mov	r3, r2
 811a808:	687a      	ldr	r2, [r7, #4]
 811a80a:	68b9      	ldr	r1, [r7, #8]
 811a80c:	68f8      	ldr	r0, [r7, #12]
 811a80e:	f000 f811 	bl	811a834 <udp_sendto_if_src>
 811a812:	4603      	mov	r3, r0
#endif /* LWIP_CHECKSUM_ON_COPY && CHECKSUM_GEN_UDP */
}
 811a814:	4618      	mov	r0, r3
 811a816:	3718      	adds	r7, #24
 811a818:	46bd      	mov	sp, r7
 811a81a:	bd80      	pop	{r7, pc}
 811a81c:	0811f504 	.word	0x0811f504
 811a820:	0811f6ac 	.word	0x0811f6ac
 811a824:	0811f58c 	.word	0x0811f58c
 811a828:	0811f6c8 	.word	0x0811f6c8
 811a82c:	0811f6e4 	.word	0x0811f6e4
 811a830:	0811f704 	.word	0x0811f704

0811a834 <udp_sendto_if_src>:
/** @ingroup udp_raw
 * Same as @ref udp_sendto_if, but with source address */
err_t
udp_sendto_if_src(struct udp_pcb *pcb, struct pbuf *p,
                  const ip_addr_t *dst_ip, u16_t dst_port, struct netif *netif, const ip_addr_t *src_ip)
{
 811a834:	b580      	push	{r7, lr}
 811a836:	b08c      	sub	sp, #48	; 0x30
 811a838:	af04      	add	r7, sp, #16
 811a83a:	60f8      	str	r0, [r7, #12]
 811a83c:	60b9      	str	r1, [r7, #8]
 811a83e:	607a      	str	r2, [r7, #4]
 811a840:	807b      	strh	r3, [r7, #2]
  u8_t ip_proto;
  u8_t ttl;

  LWIP_ASSERT_CORE_LOCKED();

  LWIP_ERROR("udp_sendto_if_src: invalid pcb", pcb != NULL, return ERR_ARG);
 811a842:	68fb      	ldr	r3, [r7, #12]
 811a844:	2b00      	cmp	r3, #0
 811a846:	d109      	bne.n	811a85c <udp_sendto_if_src+0x28>
 811a848:	4b65      	ldr	r3, [pc, #404]	; (811a9e0 <udp_sendto_if_src+0x1ac>)
 811a84a:	f240 22d1 	movw	r2, #721	; 0x2d1
 811a84e:	4965      	ldr	r1, [pc, #404]	; (811a9e4 <udp_sendto_if_src+0x1b0>)
 811a850:	4865      	ldr	r0, [pc, #404]	; (811a9e8 <udp_sendto_if_src+0x1b4>)
 811a852:	f000 ffd5 	bl	811b800 <iprintf>
 811a856:	f06f 030f 	mvn.w	r3, #15
 811a85a:	e0bc      	b.n	811a9d6 <udp_sendto_if_src+0x1a2>
  LWIP_ERROR("udp_sendto_if_src: invalid pbuf", p != NULL, return ERR_ARG);
 811a85c:	68bb      	ldr	r3, [r7, #8]
 811a85e:	2b00      	cmp	r3, #0
 811a860:	d109      	bne.n	811a876 <udp_sendto_if_src+0x42>
 811a862:	4b5f      	ldr	r3, [pc, #380]	; (811a9e0 <udp_sendto_if_src+0x1ac>)
 811a864:	f240 22d2 	movw	r2, #722	; 0x2d2
 811a868:	4960      	ldr	r1, [pc, #384]	; (811a9ec <udp_sendto_if_src+0x1b8>)
 811a86a:	485f      	ldr	r0, [pc, #380]	; (811a9e8 <udp_sendto_if_src+0x1b4>)
 811a86c:	f000 ffc8 	bl	811b800 <iprintf>
 811a870:	f06f 030f 	mvn.w	r3, #15
 811a874:	e0af      	b.n	811a9d6 <udp_sendto_if_src+0x1a2>
  LWIP_ERROR("udp_sendto_if_src: invalid dst_ip", dst_ip != NULL, return ERR_ARG);
 811a876:	687b      	ldr	r3, [r7, #4]
 811a878:	2b00      	cmp	r3, #0
 811a87a:	d109      	bne.n	811a890 <udp_sendto_if_src+0x5c>
 811a87c:	4b58      	ldr	r3, [pc, #352]	; (811a9e0 <udp_sendto_if_src+0x1ac>)
 811a87e:	f240 22d3 	movw	r2, #723	; 0x2d3
 811a882:	495b      	ldr	r1, [pc, #364]	; (811a9f0 <udp_sendto_if_src+0x1bc>)
 811a884:	4858      	ldr	r0, [pc, #352]	; (811a9e8 <udp_sendto_if_src+0x1b4>)
 811a886:	f000 ffbb 	bl	811b800 <iprintf>
 811a88a:	f06f 030f 	mvn.w	r3, #15
 811a88e:	e0a2      	b.n	811a9d6 <udp_sendto_if_src+0x1a2>
  LWIP_ERROR("udp_sendto_if_src: invalid src_ip", src_ip != NULL, return ERR_ARG);
 811a890:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 811a892:	2b00      	cmp	r3, #0
 811a894:	d109      	bne.n	811a8aa <udp_sendto_if_src+0x76>
 811a896:	4b52      	ldr	r3, [pc, #328]	; (811a9e0 <udp_sendto_if_src+0x1ac>)
 811a898:	f44f 7235 	mov.w	r2, #724	; 0x2d4
 811a89c:	4955      	ldr	r1, [pc, #340]	; (811a9f4 <udp_sendto_if_src+0x1c0>)
 811a89e:	4852      	ldr	r0, [pc, #328]	; (811a9e8 <udp_sendto_if_src+0x1b4>)
 811a8a0:	f000 ffae 	bl	811b800 <iprintf>
 811a8a4:	f06f 030f 	mvn.w	r3, #15
 811a8a8:	e095      	b.n	811a9d6 <udp_sendto_if_src+0x1a2>
  LWIP_ERROR("udp_sendto_if_src: invalid netif", netif != NULL, return ERR_ARG);
 811a8aa:	6abb      	ldr	r3, [r7, #40]	; 0x28
 811a8ac:	2b00      	cmp	r3, #0
 811a8ae:	d109      	bne.n	811a8c4 <udp_sendto_if_src+0x90>
 811a8b0:	4b4b      	ldr	r3, [pc, #300]	; (811a9e0 <udp_sendto_if_src+0x1ac>)
 811a8b2:	f240 22d5 	movw	r2, #725	; 0x2d5
 811a8b6:	4950      	ldr	r1, [pc, #320]	; (811a9f8 <udp_sendto_if_src+0x1c4>)
 811a8b8:	484b      	ldr	r0, [pc, #300]	; (811a9e8 <udp_sendto_if_src+0x1b4>)
 811a8ba:	f000 ffa1 	bl	811b800 <iprintf>
 811a8be:	f06f 030f 	mvn.w	r3, #15
 811a8c2:	e088      	b.n	811a9d6 <udp_sendto_if_src+0x1a2>
    return ERR_VAL;
  }
#endif /* LWIP_IPV4 && IP_SOF_BROADCAST */

  /* if the PCB is not yet bound to a port, bind it here */
  if (pcb->local_port == 0) {
 811a8c4:	68fb      	ldr	r3, [r7, #12]
 811a8c6:	8a5b      	ldrh	r3, [r3, #18]
 811a8c8:	2b00      	cmp	r3, #0
 811a8ca:	d10f      	bne.n	811a8ec <udp_sendto_if_src+0xb8>
    LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, ("udp_send: not yet bound to a port, binding now\n"));
    err = udp_bind(pcb, &pcb->local_ip, pcb->local_port);
 811a8cc:	68f9      	ldr	r1, [r7, #12]
 811a8ce:	68fb      	ldr	r3, [r7, #12]
 811a8d0:	8a5b      	ldrh	r3, [r3, #18]
 811a8d2:	461a      	mov	r2, r3
 811a8d4:	68f8      	ldr	r0, [r7, #12]
 811a8d6:	f000 f893 	bl	811aa00 <udp_bind>
 811a8da:	4603      	mov	r3, r0
 811a8dc:	76fb      	strb	r3, [r7, #27]
    if (err != ERR_OK) {
 811a8de:	f997 301b 	ldrsb.w	r3, [r7, #27]
 811a8e2:	2b00      	cmp	r3, #0
 811a8e4:	d002      	beq.n	811a8ec <udp_sendto_if_src+0xb8>
      LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("udp_send: forced port bind failed\n"));
      return err;
 811a8e6:	f997 301b 	ldrsb.w	r3, [r7, #27]
 811a8ea:	e074      	b.n	811a9d6 <udp_sendto_if_src+0x1a2>
    }
  }

  /* packet too large to add a UDP header without causing an overflow? */
  if ((u16_t)(p->tot_len + UDP_HLEN) < p->tot_len) {
 811a8ec:	68bb      	ldr	r3, [r7, #8]
 811a8ee:	891b      	ldrh	r3, [r3, #8]
 811a8f0:	f64f 72f7 	movw	r2, #65527	; 0xfff7
 811a8f4:	4293      	cmp	r3, r2
 811a8f6:	d902      	bls.n	811a8fe <udp_sendto_if_src+0xca>
    return ERR_MEM;
 811a8f8:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 811a8fc:	e06b      	b.n	811a9d6 <udp_sendto_if_src+0x1a2>
  }
  /* not enough space to add an UDP header to first pbuf in given p chain? */
  if (pbuf_add_header(p, UDP_HLEN)) {
 811a8fe:	2108      	movs	r1, #8
 811a900:	68b8      	ldr	r0, [r7, #8]
 811a902:	f7f9 fe13 	bl	811452c <pbuf_add_header>
 811a906:	4603      	mov	r3, r0
 811a908:	2b00      	cmp	r3, #0
 811a90a:	d015      	beq.n	811a938 <udp_sendto_if_src+0x104>
    /* allocate header in a separate new pbuf */
    q = pbuf_alloc(PBUF_IP, UDP_HLEN, PBUF_RAM);
 811a90c:	f44f 7220 	mov.w	r2, #640	; 0x280
 811a910:	2108      	movs	r1, #8
 811a912:	2022      	movs	r0, #34	; 0x22
 811a914:	f7f9 fbbc 	bl	8114090 <pbuf_alloc>
 811a918:	61f8      	str	r0, [r7, #28]
    /* new header pbuf could not be allocated? */
    if (q == NULL) {
 811a91a:	69fb      	ldr	r3, [r7, #28]
 811a91c:	2b00      	cmp	r3, #0
 811a91e:	d102      	bne.n	811a926 <udp_sendto_if_src+0xf2>
      LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("udp_send: could not allocate header\n"));
      return ERR_MEM;
 811a920:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 811a924:	e057      	b.n	811a9d6 <udp_sendto_if_src+0x1a2>
    }
    if (p->tot_len != 0) {
 811a926:	68bb      	ldr	r3, [r7, #8]
 811a928:	891b      	ldrh	r3, [r3, #8]
 811a92a:	2b00      	cmp	r3, #0
 811a92c:	d006      	beq.n	811a93c <udp_sendto_if_src+0x108>
      /* chain header q in front of given pbuf p (only if p contains data) */
      pbuf_chain(q, p);
 811a92e:	68b9      	ldr	r1, [r7, #8]
 811a930:	69f8      	ldr	r0, [r7, #28]
 811a932:	f7f9 ffa9 	bl	8114888 <pbuf_chain>
 811a936:	e001      	b.n	811a93c <udp_sendto_if_src+0x108>
    LWIP_DEBUGF(UDP_DEBUG,
                ("udp_send: added header pbuf %p before given pbuf %p\n", (void *)q, (void *)p));
  } else {
    /* adding space for header within p succeeded */
    /* first pbuf q equals given pbuf */
    q = p;
 811a938:	68bb      	ldr	r3, [r7, #8]
 811a93a:	61fb      	str	r3, [r7, #28]
    LWIP_DEBUGF(UDP_DEBUG, ("udp_send: added header in given pbuf %p\n", (void *)p));
  }
  LWIP_ASSERT("check that first pbuf can hold struct udp_hdr",
 811a93c:	69fb      	ldr	r3, [r7, #28]
 811a93e:	895b      	ldrh	r3, [r3, #10]
 811a940:	2b07      	cmp	r3, #7
 811a942:	d806      	bhi.n	811a952 <udp_sendto_if_src+0x11e>
 811a944:	4b26      	ldr	r3, [pc, #152]	; (811a9e0 <udp_sendto_if_src+0x1ac>)
 811a946:	f240 320d 	movw	r2, #781	; 0x30d
 811a94a:	492c      	ldr	r1, [pc, #176]	; (811a9fc <udp_sendto_if_src+0x1c8>)
 811a94c:	4826      	ldr	r0, [pc, #152]	; (811a9e8 <udp_sendto_if_src+0x1b4>)
 811a94e:	f000 ff57 	bl	811b800 <iprintf>
              (q->len >= sizeof(struct udp_hdr)));
  /* q now represents the packet to be sent */
  udphdr = (struct udp_hdr *)q->payload;
 811a952:	69fb      	ldr	r3, [r7, #28]
 811a954:	685b      	ldr	r3, [r3, #4]
 811a956:	617b      	str	r3, [r7, #20]
  udphdr->src = lwip_htons(pcb->local_port);
 811a958:	68fb      	ldr	r3, [r7, #12]
 811a95a:	8a5b      	ldrh	r3, [r3, #18]
 811a95c:	4618      	mov	r0, r3
 811a95e:	f7f3 fd98 	bl	810e492 <lwip_htons>
 811a962:	4603      	mov	r3, r0
 811a964:	461a      	mov	r2, r3
 811a966:	697b      	ldr	r3, [r7, #20]
 811a968:	801a      	strh	r2, [r3, #0]
  udphdr->dest = lwip_htons(dst_port);
 811a96a:	887b      	ldrh	r3, [r7, #2]
 811a96c:	4618      	mov	r0, r3
 811a96e:	f7f3 fd90 	bl	810e492 <lwip_htons>
 811a972:	4603      	mov	r3, r0
 811a974:	461a      	mov	r2, r3
 811a976:	697b      	ldr	r3, [r7, #20]
 811a978:	805a      	strh	r2, [r3, #2]
  /* in UDP, 0 checksum means 'no checksum' */
  udphdr->chksum = 0x0000;
 811a97a:	697b      	ldr	r3, [r7, #20]
 811a97c:	2200      	movs	r2, #0
 811a97e:	719a      	strb	r2, [r3, #6]
 811a980:	2200      	movs	r2, #0
 811a982:	71da      	strb	r2, [r3, #7]
    ip_proto = IP_PROTO_UDPLITE;
  } else
#endif /* LWIP_UDPLITE */
  {      /* UDP */
    LWIP_DEBUGF(UDP_DEBUG, ("udp_send: UDP packet length %"U16_F"\n", q->tot_len));
    udphdr->len = lwip_htons(q->tot_len);
 811a984:	69fb      	ldr	r3, [r7, #28]
 811a986:	891b      	ldrh	r3, [r3, #8]
 811a988:	4618      	mov	r0, r3
 811a98a:	f7f3 fd82 	bl	810e492 <lwip_htons>
 811a98e:	4603      	mov	r3, r0
 811a990:	461a      	mov	r2, r3
 811a992:	697b      	ldr	r3, [r7, #20]
 811a994:	809a      	strh	r2, [r3, #4]
        }
        udphdr->chksum = udpchksum;
      }
    }
#endif /* CHECKSUM_GEN_UDP */
    ip_proto = IP_PROTO_UDP;
 811a996:	2311      	movs	r3, #17
 811a998:	74fb      	strb	r3, [r7, #19]

  /* Determine TTL to use */
#if LWIP_MULTICAST_TX_OPTIONS
  ttl = (ip_addr_ismulticast(dst_ip) ? udp_get_multicast_ttl(pcb) : pcb->ttl);
#else /* LWIP_MULTICAST_TX_OPTIONS */
  ttl = pcb->ttl;
 811a99a:	68fb      	ldr	r3, [r7, #12]
 811a99c:	7adb      	ldrb	r3, [r3, #11]
 811a99e:	74bb      	strb	r3, [r7, #18]

  LWIP_DEBUGF(UDP_DEBUG, ("udp_send: UDP checksum 0x%04"X16_F"\n", udphdr->chksum));
  LWIP_DEBUGF(UDP_DEBUG, ("udp_send: ip_output_if (,,,,0x%02"X16_F",)\n", (u16_t)ip_proto));
  /* output to IP */
  NETIF_SET_HINTS(netif, &(pcb->netif_hints));
  err = ip_output_if_src(q, src_ip, dst_ip, ttl, pcb->tos, ip_proto, netif);
 811a9a0:	68fb      	ldr	r3, [r7, #12]
 811a9a2:	7a9b      	ldrb	r3, [r3, #10]
 811a9a4:	7cb9      	ldrb	r1, [r7, #18]
 811a9a6:	6aba      	ldr	r2, [r7, #40]	; 0x28
 811a9a8:	9202      	str	r2, [sp, #8]
 811a9aa:	7cfa      	ldrb	r2, [r7, #19]
 811a9ac:	9201      	str	r2, [sp, #4]
 811a9ae:	9300      	str	r3, [sp, #0]
 811a9b0:	460b      	mov	r3, r1
 811a9b2:	687a      	ldr	r2, [r7, #4]
 811a9b4:	6af9      	ldr	r1, [r7, #44]	; 0x2c
 811a9b6:	69f8      	ldr	r0, [r7, #28]
 811a9b8:	f7f7 fc1e 	bl	81121f8 <ip4_output_if_src>
 811a9bc:	4603      	mov	r3, r0
 811a9be:	76fb      	strb	r3, [r7, #27]

  /* @todo: must this be increased even if error occurred? */
  MIB2_STATS_INC(mib2.udpoutdatagrams);

  /* did we chain a separate header pbuf earlier? */
  if (q != p) {
 811a9c0:	69fa      	ldr	r2, [r7, #28]
 811a9c2:	68bb      	ldr	r3, [r7, #8]
 811a9c4:	429a      	cmp	r2, r3
 811a9c6:	d004      	beq.n	811a9d2 <udp_sendto_if_src+0x19e>
    /* free the header pbuf */
    pbuf_free(q);
 811a9c8:	69f8      	ldr	r0, [r7, #28]
 811a9ca:	f7f9 fe45 	bl	8114658 <pbuf_free>
    q = NULL;
 811a9ce:	2300      	movs	r3, #0
 811a9d0:	61fb      	str	r3, [r7, #28]
    /* p is still referenced by the caller, and will live on */
  }

  UDP_STATS_INC(udp.xmit);
  return err;
 811a9d2:	f997 301b 	ldrsb.w	r3, [r7, #27]
}
 811a9d6:	4618      	mov	r0, r3
 811a9d8:	3720      	adds	r7, #32
 811a9da:	46bd      	mov	sp, r7
 811a9dc:	bd80      	pop	{r7, pc}
 811a9de:	bf00      	nop
 811a9e0:	0811f504 	.word	0x0811f504
 811a9e4:	0811f724 	.word	0x0811f724
 811a9e8:	0811f58c 	.word	0x0811f58c
 811a9ec:	0811f744 	.word	0x0811f744
 811a9f0:	0811f764 	.word	0x0811f764
 811a9f4:	0811f788 	.word	0x0811f788
 811a9f8:	0811f7ac 	.word	0x0811f7ac
 811a9fc:	0811f7d0 	.word	0x0811f7d0

0811aa00 <udp_bind>:
 *
 * @see udp_disconnect()
 */
err_t
udp_bind(struct udp_pcb *pcb, const ip_addr_t *ipaddr, u16_t port)
{
 811aa00:	b580      	push	{r7, lr}
 811aa02:	b086      	sub	sp, #24
 811aa04:	af00      	add	r7, sp, #0
 811aa06:	60f8      	str	r0, [r7, #12]
 811aa08:	60b9      	str	r1, [r7, #8]
 811aa0a:	4613      	mov	r3, r2
 811aa0c:	80fb      	strh	r3, [r7, #6]

  LWIP_ASSERT_CORE_LOCKED();

#if LWIP_IPV4
  /* Don't propagate NULL pointer (IPv4 ANY) to subsequent functions */
  if (ipaddr == NULL) {
 811aa0e:	68bb      	ldr	r3, [r7, #8]
 811aa10:	2b00      	cmp	r3, #0
 811aa12:	d101      	bne.n	811aa18 <udp_bind+0x18>
    ipaddr = IP4_ADDR_ANY;
 811aa14:	4b39      	ldr	r3, [pc, #228]	; (811aafc <udp_bind+0xfc>)
 811aa16:	60bb      	str	r3, [r7, #8]
  }
#else /* LWIP_IPV4 */
  LWIP_ERROR("udp_bind: invalid ipaddr", ipaddr != NULL, return ERR_ARG);
#endif /* LWIP_IPV4 */

  LWIP_ERROR("udp_bind: invalid pcb", pcb != NULL, return ERR_ARG);
 811aa18:	68fb      	ldr	r3, [r7, #12]
 811aa1a:	2b00      	cmp	r3, #0
 811aa1c:	d109      	bne.n	811aa32 <udp_bind+0x32>
 811aa1e:	4b38      	ldr	r3, [pc, #224]	; (811ab00 <udp_bind+0x100>)
 811aa20:	f240 32b7 	movw	r2, #951	; 0x3b7
 811aa24:	4937      	ldr	r1, [pc, #220]	; (811ab04 <udp_bind+0x104>)
 811aa26:	4838      	ldr	r0, [pc, #224]	; (811ab08 <udp_bind+0x108>)
 811aa28:	f000 feea 	bl	811b800 <iprintf>
 811aa2c:	f06f 030f 	mvn.w	r3, #15
 811aa30:	e060      	b.n	811aaf4 <udp_bind+0xf4>

  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, ("udp_bind(ipaddr = "));
  ip_addr_debug_print(UDP_DEBUG | LWIP_DBG_TRACE, ipaddr);
  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, (", port = %"U16_F")\n", port));

  rebind = 0;
 811aa32:	2300      	movs	r3, #0
 811aa34:	74fb      	strb	r3, [r7, #19]
  /* Check for double bind and rebind of the same pcb */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
 811aa36:	4b35      	ldr	r3, [pc, #212]	; (811ab0c <udp_bind+0x10c>)
 811aa38:	681b      	ldr	r3, [r3, #0]
 811aa3a:	617b      	str	r3, [r7, #20]
 811aa3c:	e009      	b.n	811aa52 <udp_bind+0x52>
    /* is this UDP PCB already on active list? */
    if (pcb == ipcb) {
 811aa3e:	68fa      	ldr	r2, [r7, #12]
 811aa40:	697b      	ldr	r3, [r7, #20]
 811aa42:	429a      	cmp	r2, r3
 811aa44:	d102      	bne.n	811aa4c <udp_bind+0x4c>
      rebind = 1;
 811aa46:	2301      	movs	r3, #1
 811aa48:	74fb      	strb	r3, [r7, #19]
      break;
 811aa4a:	e005      	b.n	811aa58 <udp_bind+0x58>
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
 811aa4c:	697b      	ldr	r3, [r7, #20]
 811aa4e:	68db      	ldr	r3, [r3, #12]
 811aa50:	617b      	str	r3, [r7, #20]
 811aa52:	697b      	ldr	r3, [r7, #20]
 811aa54:	2b00      	cmp	r3, #0
 811aa56:	d1f2      	bne.n	811aa3e <udp_bind+0x3e>
    ipaddr = &zoned_ipaddr;
  }
#endif /* LWIP_IPV6 && LWIP_IPV6_SCOPES */

  /* no port specified? */
  if (port == 0) {
 811aa58:	88fb      	ldrh	r3, [r7, #6]
 811aa5a:	2b00      	cmp	r3, #0
 811aa5c:	d109      	bne.n	811aa72 <udp_bind+0x72>
    port = udp_new_port();
 811aa5e:	f7ff fc69 	bl	811a334 <udp_new_port>
 811aa62:	4603      	mov	r3, r0
 811aa64:	80fb      	strh	r3, [r7, #6]
    if (port == 0) {
 811aa66:	88fb      	ldrh	r3, [r7, #6]
 811aa68:	2b00      	cmp	r3, #0
 811aa6a:	d12c      	bne.n	811aac6 <udp_bind+0xc6>
      /* no more ports available in local range */
      LWIP_DEBUGF(UDP_DEBUG, ("udp_bind: out of free UDP ports\n"));
      return ERR_USE;
 811aa6c:	f06f 0307 	mvn.w	r3, #7
 811aa70:	e040      	b.n	811aaf4 <udp_bind+0xf4>
    }
  } else {
    for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
 811aa72:	4b26      	ldr	r3, [pc, #152]	; (811ab0c <udp_bind+0x10c>)
 811aa74:	681b      	ldr	r3, [r3, #0]
 811aa76:	617b      	str	r3, [r7, #20]
 811aa78:	e022      	b.n	811aac0 <udp_bind+0xc0>
      if (pcb != ipcb) {
 811aa7a:	68fa      	ldr	r2, [r7, #12]
 811aa7c:	697b      	ldr	r3, [r7, #20]
 811aa7e:	429a      	cmp	r2, r3
 811aa80:	d01b      	beq.n	811aaba <udp_bind+0xba>
        if (!ip_get_option(pcb, SOF_REUSEADDR) ||
            !ip_get_option(ipcb, SOF_REUSEADDR))
#endif /* SO_REUSE */
        {
          /* port matches that of PCB in list and REUSEADDR not set -> reject */
          if ((ipcb->local_port == port) &&
 811aa82:	697b      	ldr	r3, [r7, #20]
 811aa84:	8a5b      	ldrh	r3, [r3, #18]
 811aa86:	88fa      	ldrh	r2, [r7, #6]
 811aa88:	429a      	cmp	r2, r3
 811aa8a:	d116      	bne.n	811aaba <udp_bind+0xba>
              /* IP address matches or any IP used? */
              (ip_addr_cmp(&ipcb->local_ip, ipaddr) || ip_addr_isany(ipaddr) ||
 811aa8c:	697b      	ldr	r3, [r7, #20]
 811aa8e:	681a      	ldr	r2, [r3, #0]
 811aa90:	68bb      	ldr	r3, [r7, #8]
 811aa92:	681b      	ldr	r3, [r3, #0]
          if ((ipcb->local_port == port) &&
 811aa94:	429a      	cmp	r2, r3
 811aa96:	d00d      	beq.n	811aab4 <udp_bind+0xb4>
              (ip_addr_cmp(&ipcb->local_ip, ipaddr) || ip_addr_isany(ipaddr) ||
 811aa98:	68bb      	ldr	r3, [r7, #8]
 811aa9a:	2b00      	cmp	r3, #0
 811aa9c:	d00a      	beq.n	811aab4 <udp_bind+0xb4>
 811aa9e:	68bb      	ldr	r3, [r7, #8]
 811aaa0:	681b      	ldr	r3, [r3, #0]
 811aaa2:	2b00      	cmp	r3, #0
 811aaa4:	d006      	beq.n	811aab4 <udp_bind+0xb4>
              ip_addr_isany(&ipcb->local_ip))) {
 811aaa6:	697b      	ldr	r3, [r7, #20]
              (ip_addr_cmp(&ipcb->local_ip, ipaddr) || ip_addr_isany(ipaddr) ||
 811aaa8:	2b00      	cmp	r3, #0
 811aaaa:	d003      	beq.n	811aab4 <udp_bind+0xb4>
              ip_addr_isany(&ipcb->local_ip))) {
 811aaac:	697b      	ldr	r3, [r7, #20]
 811aaae:	681b      	ldr	r3, [r3, #0]
 811aab0:	2b00      	cmp	r3, #0
 811aab2:	d102      	bne.n	811aaba <udp_bind+0xba>
            /* other PCB already binds to this local IP and port */
            LWIP_DEBUGF(UDP_DEBUG,
                        ("udp_bind: local port %"U16_F" already bound by another pcb\n", port));
            return ERR_USE;
 811aab4:	f06f 0307 	mvn.w	r3, #7
 811aab8:	e01c      	b.n	811aaf4 <udp_bind+0xf4>
    for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
 811aaba:	697b      	ldr	r3, [r7, #20]
 811aabc:	68db      	ldr	r3, [r3, #12]
 811aabe:	617b      	str	r3, [r7, #20]
 811aac0:	697b      	ldr	r3, [r7, #20]
 811aac2:	2b00      	cmp	r3, #0
 811aac4:	d1d9      	bne.n	811aa7a <udp_bind+0x7a>
        }
      }
    }
  }

  ip_addr_set_ipaddr(&pcb->local_ip, ipaddr);
 811aac6:	68bb      	ldr	r3, [r7, #8]
 811aac8:	2b00      	cmp	r3, #0
 811aaca:	d002      	beq.n	811aad2 <udp_bind+0xd2>
 811aacc:	68bb      	ldr	r3, [r7, #8]
 811aace:	681b      	ldr	r3, [r3, #0]
 811aad0:	e000      	b.n	811aad4 <udp_bind+0xd4>
 811aad2:	2300      	movs	r3, #0
 811aad4:	68fa      	ldr	r2, [r7, #12]
 811aad6:	6013      	str	r3, [r2, #0]

  pcb->local_port = port;
 811aad8:	68fb      	ldr	r3, [r7, #12]
 811aada:	88fa      	ldrh	r2, [r7, #6]
 811aadc:	825a      	strh	r2, [r3, #18]
  mib2_udp_bind(pcb);
  /* pcb not active yet? */
  if (rebind == 0) {
 811aade:	7cfb      	ldrb	r3, [r7, #19]
 811aae0:	2b00      	cmp	r3, #0
 811aae2:	d106      	bne.n	811aaf2 <udp_bind+0xf2>
    /* place the PCB on the active list if not already there */
    pcb->next = udp_pcbs;
 811aae4:	4b09      	ldr	r3, [pc, #36]	; (811ab0c <udp_bind+0x10c>)
 811aae6:	681a      	ldr	r2, [r3, #0]
 811aae8:	68fb      	ldr	r3, [r7, #12]
 811aaea:	60da      	str	r2, [r3, #12]
    udp_pcbs = pcb;
 811aaec:	4a07      	ldr	r2, [pc, #28]	; (811ab0c <udp_bind+0x10c>)
 811aaee:	68fb      	ldr	r3, [r7, #12]
 811aaf0:	6013      	str	r3, [r2, #0]
  }
  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("udp_bind: bound to "));
  ip_addr_debug_print_val(UDP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, pcb->local_ip);
  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, (", port %"U16_F")\n", pcb->local_port));
  return ERR_OK;
 811aaf2:	2300      	movs	r3, #0
}
 811aaf4:	4618      	mov	r0, r3
 811aaf6:	3718      	adds	r7, #24
 811aaf8:	46bd      	mov	sp, r7
 811aafa:	bd80      	pop	{r7, pc}
 811aafc:	0811f934 	.word	0x0811f934
 811ab00:	0811f504 	.word	0x0811f504
 811ab04:	0811f800 	.word	0x0811f800
 811ab08:	0811f58c 	.word	0x0811f58c
 811ab0c:	100084a4 	.word	0x100084a4

0811ab10 <udp_connect>:
 *
 * @see udp_disconnect()
 */
err_t
udp_connect(struct udp_pcb *pcb, const ip_addr_t *ipaddr, u16_t port)
{
 811ab10:	b580      	push	{r7, lr}
 811ab12:	b086      	sub	sp, #24
 811ab14:	af00      	add	r7, sp, #0
 811ab16:	60f8      	str	r0, [r7, #12]
 811ab18:	60b9      	str	r1, [r7, #8]
 811ab1a:	4613      	mov	r3, r2
 811ab1c:	80fb      	strh	r3, [r7, #6]
  struct udp_pcb *ipcb;

  LWIP_ASSERT_CORE_LOCKED();

  LWIP_ERROR("udp_connect: invalid pcb", pcb != NULL, return ERR_ARG);
 811ab1e:	68fb      	ldr	r3, [r7, #12]
 811ab20:	2b00      	cmp	r3, #0
 811ab22:	d109      	bne.n	811ab38 <udp_connect+0x28>
 811ab24:	4b2c      	ldr	r3, [pc, #176]	; (811abd8 <udp_connect+0xc8>)
 811ab26:	f240 4235 	movw	r2, #1077	; 0x435
 811ab2a:	492c      	ldr	r1, [pc, #176]	; (811abdc <udp_connect+0xcc>)
 811ab2c:	482c      	ldr	r0, [pc, #176]	; (811abe0 <udp_connect+0xd0>)
 811ab2e:	f000 fe67 	bl	811b800 <iprintf>
 811ab32:	f06f 030f 	mvn.w	r3, #15
 811ab36:	e04b      	b.n	811abd0 <udp_connect+0xc0>
  LWIP_ERROR("udp_connect: invalid ipaddr", ipaddr != NULL, return ERR_ARG);
 811ab38:	68bb      	ldr	r3, [r7, #8]
 811ab3a:	2b00      	cmp	r3, #0
 811ab3c:	d109      	bne.n	811ab52 <udp_connect+0x42>
 811ab3e:	4b26      	ldr	r3, [pc, #152]	; (811abd8 <udp_connect+0xc8>)
 811ab40:	f240 4236 	movw	r2, #1078	; 0x436
 811ab44:	4927      	ldr	r1, [pc, #156]	; (811abe4 <udp_connect+0xd4>)
 811ab46:	4826      	ldr	r0, [pc, #152]	; (811abe0 <udp_connect+0xd0>)
 811ab48:	f000 fe5a 	bl	811b800 <iprintf>
 811ab4c:	f06f 030f 	mvn.w	r3, #15
 811ab50:	e03e      	b.n	811abd0 <udp_connect+0xc0>

  if (pcb->local_port == 0) {
 811ab52:	68fb      	ldr	r3, [r7, #12]
 811ab54:	8a5b      	ldrh	r3, [r3, #18]
 811ab56:	2b00      	cmp	r3, #0
 811ab58:	d10f      	bne.n	811ab7a <udp_connect+0x6a>
    err_t err = udp_bind(pcb, &pcb->local_ip, pcb->local_port);
 811ab5a:	68f9      	ldr	r1, [r7, #12]
 811ab5c:	68fb      	ldr	r3, [r7, #12]
 811ab5e:	8a5b      	ldrh	r3, [r3, #18]
 811ab60:	461a      	mov	r2, r3
 811ab62:	68f8      	ldr	r0, [r7, #12]
 811ab64:	f7ff ff4c 	bl	811aa00 <udp_bind>
 811ab68:	4603      	mov	r3, r0
 811ab6a:	74fb      	strb	r3, [r7, #19]
    if (err != ERR_OK) {
 811ab6c:	f997 3013 	ldrsb.w	r3, [r7, #19]
 811ab70:	2b00      	cmp	r3, #0
 811ab72:	d002      	beq.n	811ab7a <udp_connect+0x6a>
      return err;
 811ab74:	f997 3013 	ldrsb.w	r3, [r7, #19]
 811ab78:	e02a      	b.n	811abd0 <udp_connect+0xc0>
    }
  }

  ip_addr_set_ipaddr(&pcb->remote_ip, ipaddr);
 811ab7a:	68bb      	ldr	r3, [r7, #8]
 811ab7c:	2b00      	cmp	r3, #0
 811ab7e:	d002      	beq.n	811ab86 <udp_connect+0x76>
 811ab80:	68bb      	ldr	r3, [r7, #8]
 811ab82:	681b      	ldr	r3, [r3, #0]
 811ab84:	e000      	b.n	811ab88 <udp_connect+0x78>
 811ab86:	2300      	movs	r3, #0
 811ab88:	68fa      	ldr	r2, [r7, #12]
 811ab8a:	6053      	str	r3, [r2, #4]
      ip6_addr_lacks_zone(ip_2_ip6(&pcb->remote_ip), IP6_UNKNOWN)) {
    ip6_addr_select_zone(ip_2_ip6(&pcb->remote_ip), ip_2_ip6(&pcb->local_ip));
  }
#endif /* LWIP_IPV6 && LWIP_IPV6_SCOPES */

  pcb->remote_port = port;
 811ab8c:	68fb      	ldr	r3, [r7, #12]
 811ab8e:	88fa      	ldrh	r2, [r7, #6]
 811ab90:	829a      	strh	r2, [r3, #20]
  pcb->flags |= UDP_FLAGS_CONNECTED;
 811ab92:	68fb      	ldr	r3, [r7, #12]
 811ab94:	7c1b      	ldrb	r3, [r3, #16]
 811ab96:	f043 0304 	orr.w	r3, r3, #4
 811ab9a:	b2da      	uxtb	r2, r3
 811ab9c:	68fb      	ldr	r3, [r7, #12]
 811ab9e:	741a      	strb	r2, [r3, #16]
  ip_addr_debug_print_val(UDP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE,
                          pcb->remote_ip);
  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, (", port %"U16_F")\n", pcb->remote_port));

  /* Insert UDP PCB into the list of active UDP PCBs. */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
 811aba0:	4b11      	ldr	r3, [pc, #68]	; (811abe8 <udp_connect+0xd8>)
 811aba2:	681b      	ldr	r3, [r3, #0]
 811aba4:	617b      	str	r3, [r7, #20]
 811aba6:	e008      	b.n	811abba <udp_connect+0xaa>
    if (pcb == ipcb) {
 811aba8:	68fa      	ldr	r2, [r7, #12]
 811abaa:	697b      	ldr	r3, [r7, #20]
 811abac:	429a      	cmp	r2, r3
 811abae:	d101      	bne.n	811abb4 <udp_connect+0xa4>
      /* already on the list, just return */
      return ERR_OK;
 811abb0:	2300      	movs	r3, #0
 811abb2:	e00d      	b.n	811abd0 <udp_connect+0xc0>
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
 811abb4:	697b      	ldr	r3, [r7, #20]
 811abb6:	68db      	ldr	r3, [r3, #12]
 811abb8:	617b      	str	r3, [r7, #20]
 811abba:	697b      	ldr	r3, [r7, #20]
 811abbc:	2b00      	cmp	r3, #0
 811abbe:	d1f3      	bne.n	811aba8 <udp_connect+0x98>
    }
  }
  /* PCB not yet on the list, add PCB now */
  pcb->next = udp_pcbs;
 811abc0:	4b09      	ldr	r3, [pc, #36]	; (811abe8 <udp_connect+0xd8>)
 811abc2:	681a      	ldr	r2, [r3, #0]
 811abc4:	68fb      	ldr	r3, [r7, #12]
 811abc6:	60da      	str	r2, [r3, #12]
  udp_pcbs = pcb;
 811abc8:	4a07      	ldr	r2, [pc, #28]	; (811abe8 <udp_connect+0xd8>)
 811abca:	68fb      	ldr	r3, [r7, #12]
 811abcc:	6013      	str	r3, [r2, #0]
  return ERR_OK;
 811abce:	2300      	movs	r3, #0
}
 811abd0:	4618      	mov	r0, r3
 811abd2:	3718      	adds	r7, #24
 811abd4:	46bd      	mov	sp, r7
 811abd6:	bd80      	pop	{r7, pc}
 811abd8:	0811f504 	.word	0x0811f504
 811abdc:	0811f818 	.word	0x0811f818
 811abe0:	0811f58c 	.word	0x0811f58c
 811abe4:	0811f834 	.word	0x0811f834
 811abe8:	100084a4 	.word	0x100084a4

0811abec <udp_recv>:
 * @param recv function pointer of the callback function
 * @param recv_arg additional argument to pass to the callback function
 */
void
udp_recv(struct udp_pcb *pcb, udp_recv_fn recv, void *recv_arg)
{
 811abec:	b580      	push	{r7, lr}
 811abee:	b084      	sub	sp, #16
 811abf0:	af00      	add	r7, sp, #0
 811abf2:	60f8      	str	r0, [r7, #12]
 811abf4:	60b9      	str	r1, [r7, #8]
 811abf6:	607a      	str	r2, [r7, #4]
  LWIP_ASSERT_CORE_LOCKED();

  LWIP_ERROR("udp_recv: invalid pcb", pcb != NULL, return);
 811abf8:	68fb      	ldr	r3, [r7, #12]
 811abfa:	2b00      	cmp	r3, #0
 811abfc:	d107      	bne.n	811ac0e <udp_recv+0x22>
 811abfe:	4b08      	ldr	r3, [pc, #32]	; (811ac20 <udp_recv+0x34>)
 811ac00:	f240 428a 	movw	r2, #1162	; 0x48a
 811ac04:	4907      	ldr	r1, [pc, #28]	; (811ac24 <udp_recv+0x38>)
 811ac06:	4808      	ldr	r0, [pc, #32]	; (811ac28 <udp_recv+0x3c>)
 811ac08:	f000 fdfa 	bl	811b800 <iprintf>
 811ac0c:	e005      	b.n	811ac1a <udp_recv+0x2e>

  /* remember recv() callback and user data */
  pcb->recv = recv;
 811ac0e:	68fb      	ldr	r3, [r7, #12]
 811ac10:	68ba      	ldr	r2, [r7, #8]
 811ac12:	619a      	str	r2, [r3, #24]
  pcb->recv_arg = recv_arg;
 811ac14:	68fb      	ldr	r3, [r7, #12]
 811ac16:	687a      	ldr	r2, [r7, #4]
 811ac18:	61da      	str	r2, [r3, #28]
}
 811ac1a:	3710      	adds	r7, #16
 811ac1c:	46bd      	mov	sp, r7
 811ac1e:	bd80      	pop	{r7, pc}
 811ac20:	0811f504 	.word	0x0811f504
 811ac24:	0811f86c 	.word	0x0811f86c
 811ac28:	0811f58c 	.word	0x0811f58c

0811ac2c <udp_remove>:
 *
 * @see udp_new()
 */
void
udp_remove(struct udp_pcb *pcb)
{
 811ac2c:	b580      	push	{r7, lr}
 811ac2e:	b084      	sub	sp, #16
 811ac30:	af00      	add	r7, sp, #0
 811ac32:	6078      	str	r0, [r7, #4]
  struct udp_pcb *pcb2;

  LWIP_ASSERT_CORE_LOCKED();

  LWIP_ERROR("udp_remove: invalid pcb", pcb != NULL, return);
 811ac34:	687b      	ldr	r3, [r7, #4]
 811ac36:	2b00      	cmp	r3, #0
 811ac38:	d107      	bne.n	811ac4a <udp_remove+0x1e>
 811ac3a:	4b19      	ldr	r3, [pc, #100]	; (811aca0 <udp_remove+0x74>)
 811ac3c:	f240 42a1 	movw	r2, #1185	; 0x4a1
 811ac40:	4918      	ldr	r1, [pc, #96]	; (811aca4 <udp_remove+0x78>)
 811ac42:	4819      	ldr	r0, [pc, #100]	; (811aca8 <udp_remove+0x7c>)
 811ac44:	f000 fddc 	bl	811b800 <iprintf>
 811ac48:	e026      	b.n	811ac98 <udp_remove+0x6c>

  mib2_udp_unbind(pcb);
  /* pcb to be removed is first in list? */
  if (udp_pcbs == pcb) {
 811ac4a:	4b18      	ldr	r3, [pc, #96]	; (811acac <udp_remove+0x80>)
 811ac4c:	681b      	ldr	r3, [r3, #0]
 811ac4e:	687a      	ldr	r2, [r7, #4]
 811ac50:	429a      	cmp	r2, r3
 811ac52:	d105      	bne.n	811ac60 <udp_remove+0x34>
    /* make list start at 2nd pcb */
    udp_pcbs = udp_pcbs->next;
 811ac54:	4b15      	ldr	r3, [pc, #84]	; (811acac <udp_remove+0x80>)
 811ac56:	681b      	ldr	r3, [r3, #0]
 811ac58:	68db      	ldr	r3, [r3, #12]
 811ac5a:	4a14      	ldr	r2, [pc, #80]	; (811acac <udp_remove+0x80>)
 811ac5c:	6013      	str	r3, [r2, #0]
 811ac5e:	e017      	b.n	811ac90 <udp_remove+0x64>
    /* pcb not 1st in list */
  } else {
    for (pcb2 = udp_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
 811ac60:	4b12      	ldr	r3, [pc, #72]	; (811acac <udp_remove+0x80>)
 811ac62:	681b      	ldr	r3, [r3, #0]
 811ac64:	60fb      	str	r3, [r7, #12]
 811ac66:	e010      	b.n	811ac8a <udp_remove+0x5e>
      /* find pcb in udp_pcbs list */
      if (pcb2->next != NULL && pcb2->next == pcb) {
 811ac68:	68fb      	ldr	r3, [r7, #12]
 811ac6a:	68db      	ldr	r3, [r3, #12]
 811ac6c:	2b00      	cmp	r3, #0
 811ac6e:	d009      	beq.n	811ac84 <udp_remove+0x58>
 811ac70:	68fb      	ldr	r3, [r7, #12]
 811ac72:	68db      	ldr	r3, [r3, #12]
 811ac74:	687a      	ldr	r2, [r7, #4]
 811ac76:	429a      	cmp	r2, r3
 811ac78:	d104      	bne.n	811ac84 <udp_remove+0x58>
        /* remove pcb from list */
        pcb2->next = pcb->next;
 811ac7a:	687b      	ldr	r3, [r7, #4]
 811ac7c:	68da      	ldr	r2, [r3, #12]
 811ac7e:	68fb      	ldr	r3, [r7, #12]
 811ac80:	60da      	str	r2, [r3, #12]
        break;
 811ac82:	e005      	b.n	811ac90 <udp_remove+0x64>
    for (pcb2 = udp_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
 811ac84:	68fb      	ldr	r3, [r7, #12]
 811ac86:	68db      	ldr	r3, [r3, #12]
 811ac88:	60fb      	str	r3, [r7, #12]
 811ac8a:	68fb      	ldr	r3, [r7, #12]
 811ac8c:	2b00      	cmp	r3, #0
 811ac8e:	d1eb      	bne.n	811ac68 <udp_remove+0x3c>
      }
    }
  }
  memp_free(MEMP_UDP_PCB, pcb);
 811ac90:	6879      	ldr	r1, [r7, #4]
 811ac92:	2000      	movs	r0, #0
 811ac94:	f7f8 fe7e 	bl	8113994 <memp_free>
}
 811ac98:	3710      	adds	r7, #16
 811ac9a:	46bd      	mov	sp, r7
 811ac9c:	bd80      	pop	{r7, pc}
 811ac9e:	bf00      	nop
 811aca0:	0811f504 	.word	0x0811f504
 811aca4:	0811f884 	.word	0x0811f884
 811aca8:	0811f58c 	.word	0x0811f58c
 811acac:	100084a4 	.word	0x100084a4

0811acb0 <udp_new>:
 *
 * @see udp_remove()
 */
struct udp_pcb *
udp_new(void)
{
 811acb0:	b580      	push	{r7, lr}
 811acb2:	b082      	sub	sp, #8
 811acb4:	af00      	add	r7, sp, #0
  struct udp_pcb *pcb;

  LWIP_ASSERT_CORE_LOCKED();

  pcb = (struct udp_pcb *)memp_malloc(MEMP_UDP_PCB);
 811acb6:	2000      	movs	r0, #0
 811acb8:	f7f8 fdfc 	bl	81138b4 <memp_malloc>
 811acbc:	6078      	str	r0, [r7, #4]
  /* could allocate UDP PCB? */
  if (pcb != NULL) {
 811acbe:	687b      	ldr	r3, [r7, #4]
 811acc0:	2b00      	cmp	r3, #0
 811acc2:	d007      	beq.n	811acd4 <udp_new+0x24>
    /* UDP Lite: by initializing to all zeroes, chksum_len is set to 0
     * which means checksum is generated over the whole datagram per default
     * (recommended as default by RFC 3828). */
    /* initialize PCB to all zeroes */
    memset(pcb, 0, sizeof(struct udp_pcb));
 811acc4:	2220      	movs	r2, #32
 811acc6:	2100      	movs	r1, #0
 811acc8:	6878      	ldr	r0, [r7, #4]
 811acca:	f000 fdc3 	bl	811b854 <memset>
    pcb->ttl = UDP_TTL;
 811acce:	687b      	ldr	r3, [r7, #4]
 811acd0:	22ff      	movs	r2, #255	; 0xff
 811acd2:	72da      	strb	r2, [r3, #11]
#if LWIP_MULTICAST_TX_OPTIONS
    udp_set_multicast_ttl(pcb, UDP_TTL);
#endif /* LWIP_MULTICAST_TX_OPTIONS */
  }
  return pcb;
 811acd4:	687b      	ldr	r3, [r7, #4]
}
 811acd6:	4618      	mov	r0, r3
 811acd8:	3708      	adds	r7, #8
 811acda:	46bd      	mov	sp, r7
 811acdc:	bd80      	pop	{r7, pc}
	...

0811ace0 <udp_netif_ip_addr_changed>:
 *
 * @param old_addr IP address of the netif before change
 * @param new_addr IP address of the netif after change
 */
void udp_netif_ip_addr_changed(const ip_addr_t *old_addr, const ip_addr_t *new_addr)
{
 811ace0:	b480      	push	{r7}
 811ace2:	b085      	sub	sp, #20
 811ace4:	af00      	add	r7, sp, #0
 811ace6:	6078      	str	r0, [r7, #4]
 811ace8:	6039      	str	r1, [r7, #0]
  struct udp_pcb *upcb;

  if (!ip_addr_isany(old_addr) && !ip_addr_isany(new_addr)) {
 811acea:	687b      	ldr	r3, [r7, #4]
 811acec:	2b00      	cmp	r3, #0
 811acee:	d01e      	beq.n	811ad2e <udp_netif_ip_addr_changed+0x4e>
 811acf0:	687b      	ldr	r3, [r7, #4]
 811acf2:	681b      	ldr	r3, [r3, #0]
 811acf4:	2b00      	cmp	r3, #0
 811acf6:	d01a      	beq.n	811ad2e <udp_netif_ip_addr_changed+0x4e>
 811acf8:	683b      	ldr	r3, [r7, #0]
 811acfa:	2b00      	cmp	r3, #0
 811acfc:	d017      	beq.n	811ad2e <udp_netif_ip_addr_changed+0x4e>
 811acfe:	683b      	ldr	r3, [r7, #0]
 811ad00:	681b      	ldr	r3, [r3, #0]
 811ad02:	2b00      	cmp	r3, #0
 811ad04:	d013      	beq.n	811ad2e <udp_netif_ip_addr_changed+0x4e>
    for (upcb = udp_pcbs; upcb != NULL; upcb = upcb->next) {
 811ad06:	4b0d      	ldr	r3, [pc, #52]	; (811ad3c <udp_netif_ip_addr_changed+0x5c>)
 811ad08:	681b      	ldr	r3, [r3, #0]
 811ad0a:	60fb      	str	r3, [r7, #12]
 811ad0c:	e00c      	b.n	811ad28 <udp_netif_ip_addr_changed+0x48>
      /* PCB bound to current local interface address? */
      if (ip_addr_cmp(&upcb->local_ip, old_addr)) {
 811ad0e:	68fb      	ldr	r3, [r7, #12]
 811ad10:	681a      	ldr	r2, [r3, #0]
 811ad12:	687b      	ldr	r3, [r7, #4]
 811ad14:	681b      	ldr	r3, [r3, #0]
 811ad16:	429a      	cmp	r2, r3
 811ad18:	d103      	bne.n	811ad22 <udp_netif_ip_addr_changed+0x42>
        /* The PCB is bound to the old ipaddr and
         * is set to bound to the new one instead */
        ip_addr_copy(upcb->local_ip, *new_addr);
 811ad1a:	683b      	ldr	r3, [r7, #0]
 811ad1c:	681a      	ldr	r2, [r3, #0]
 811ad1e:	68fb      	ldr	r3, [r7, #12]
 811ad20:	601a      	str	r2, [r3, #0]
    for (upcb = udp_pcbs; upcb != NULL; upcb = upcb->next) {
 811ad22:	68fb      	ldr	r3, [r7, #12]
 811ad24:	68db      	ldr	r3, [r3, #12]
 811ad26:	60fb      	str	r3, [r7, #12]
 811ad28:	68fb      	ldr	r3, [r7, #12]
 811ad2a:	2b00      	cmp	r3, #0
 811ad2c:	d1ef      	bne.n	811ad0e <udp_netif_ip_addr_changed+0x2e>
      }
    }
  }
}
 811ad2e:	bf00      	nop
 811ad30:	3714      	adds	r7, #20
 811ad32:	46bd      	mov	sp, r7
 811ad34:	f85d 7b04 	ldr.w	r7, [sp], #4
 811ad38:	4770      	bx	lr
 811ad3a:	bf00      	nop
 811ad3c:	100084a4 	.word	0x100084a4

0811ad40 <MX_USB_DEVICE_Init>:
/**
  * Init USB device Library, add supported class and start the library
  * @retval None
  */
void MX_USB_DEVICE_Init(void)
{
 811ad40:	b580      	push	{r7, lr}
 811ad42:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN USB_DEVICE_Init_PreTreatment */
  /* USER CODE END USB_DEVICE_Init_PreTreatment */

  /* Init Device Library, add supported class and start the library. */
  if (USBD_Init(&hUsbDeviceFS, &FS_Desc, DEVICE_FS) != USBD_OK)
 811ad44:	2200      	movs	r2, #0
 811ad46:	490f      	ldr	r1, [pc, #60]	; (811ad84 <MX_USB_DEVICE_Init+0x44>)
 811ad48:	480f      	ldr	r0, [pc, #60]	; (811ad88 <MX_USB_DEVICE_Init+0x48>)
 811ad4a:	f7f1 fe4b 	bl	810c9e4 <USBD_Init>
 811ad4e:	4603      	mov	r3, r0
 811ad50:	2b00      	cmp	r3, #0
 811ad52:	d001      	beq.n	811ad58 <MX_USB_DEVICE_Init+0x18>
  {
    Error_Handler();
 811ad54:	f7e5 fe88 	bl	8100a68 <Error_Handler>
  }
  if (USBD_RegisterClass(&hUsbDeviceFS, &USBD_HID) != USBD_OK)
 811ad58:	490c      	ldr	r1, [pc, #48]	; (811ad8c <MX_USB_DEVICE_Init+0x4c>)
 811ad5a:	480b      	ldr	r0, [pc, #44]	; (811ad88 <MX_USB_DEVICE_Init+0x48>)
 811ad5c:	f7f1 fe80 	bl	810ca60 <USBD_RegisterClass>
 811ad60:	4603      	mov	r3, r0
 811ad62:	2b00      	cmp	r3, #0
 811ad64:	d001      	beq.n	811ad6a <MX_USB_DEVICE_Init+0x2a>
  {
    Error_Handler();
 811ad66:	f7e5 fe7f 	bl	8100a68 <Error_Handler>
  }
  if (USBD_Start(&hUsbDeviceFS) != USBD_OK)
 811ad6a:	4807      	ldr	r0, [pc, #28]	; (811ad88 <MX_USB_DEVICE_Init+0x48>)
 811ad6c:	f7f1 febc 	bl	810cae8 <USBD_Start>
 811ad70:	4603      	mov	r3, r0
 811ad72:	2b00      	cmp	r3, #0
 811ad74:	d001      	beq.n	811ad7a <MX_USB_DEVICE_Init+0x3a>
  {
    Error_Handler();
 811ad76:	f7e5 fe77 	bl	8100a68 <Error_Handler>
  }

  /* USER CODE BEGIN USB_DEVICE_Init_PostTreatment */
  HAL_PWREx_EnableUSBVoltageDetector();
 811ad7a:	f7ec f813 	bl	8106da4 <HAL_PWREx_EnableUSBVoltageDetector>

  /* USER CODE END USB_DEVICE_Init_PostTreatment */
}
 811ad7e:	bf00      	nop
 811ad80:	bd80      	pop	{r7, pc}
 811ad82:	bf00      	nop
 811ad84:	10000110 	.word	0x10000110
 811ad88:	100084a8 	.word	0x100084a8
 811ad8c:	10000040 	.word	0x10000040

0811ad90 <USBD_FS_DeviceDescriptor>:
  * @param  speed : Current device speed
  * @param  length : Pointer to data length variable
  * @retval Pointer to descriptor buffer
  */
uint8_t * USBD_FS_DeviceDescriptor(USBD_SpeedTypeDef speed, uint16_t *length)
{
 811ad90:	b480      	push	{r7}
 811ad92:	b083      	sub	sp, #12
 811ad94:	af00      	add	r7, sp, #0
 811ad96:	4603      	mov	r3, r0
 811ad98:	6039      	str	r1, [r7, #0]
 811ad9a:	71fb      	strb	r3, [r7, #7]
  UNUSED(speed);
  *length = sizeof(USBD_FS_DeviceDesc);
 811ad9c:	683b      	ldr	r3, [r7, #0]
 811ad9e:	2212      	movs	r2, #18
 811ada0:	801a      	strh	r2, [r3, #0]
  return USBD_FS_DeviceDesc;
 811ada2:	4b03      	ldr	r3, [pc, #12]	; (811adb0 <USBD_FS_DeviceDescriptor+0x20>)
}
 811ada4:	4618      	mov	r0, r3
 811ada6:	370c      	adds	r7, #12
 811ada8:	46bd      	mov	sp, r7
 811adaa:	f85d 7b04 	ldr.w	r7, [sp], #4
 811adae:	4770      	bx	lr
 811adb0:	10000130 	.word	0x10000130

0811adb4 <USBD_FS_LangIDStrDescriptor>:
  * @param  speed : Current device speed
  * @param  length : Pointer to data length variable
  * @retval Pointer to descriptor buffer
  */
uint8_t * USBD_FS_LangIDStrDescriptor(USBD_SpeedTypeDef speed, uint16_t *length)
{
 811adb4:	b480      	push	{r7}
 811adb6:	b083      	sub	sp, #12
 811adb8:	af00      	add	r7, sp, #0
 811adba:	4603      	mov	r3, r0
 811adbc:	6039      	str	r1, [r7, #0]
 811adbe:	71fb      	strb	r3, [r7, #7]
  UNUSED(speed);
  *length = sizeof(USBD_LangIDDesc);
 811adc0:	683b      	ldr	r3, [r7, #0]
 811adc2:	2204      	movs	r2, #4
 811adc4:	801a      	strh	r2, [r3, #0]
  return USBD_LangIDDesc;
 811adc6:	4b03      	ldr	r3, [pc, #12]	; (811add4 <USBD_FS_LangIDStrDescriptor+0x20>)
}
 811adc8:	4618      	mov	r0, r3
 811adca:	370c      	adds	r7, #12
 811adcc:	46bd      	mov	sp, r7
 811adce:	f85d 7b04 	ldr.w	r7, [sp], #4
 811add2:	4770      	bx	lr
 811add4:	10000144 	.word	0x10000144

0811add8 <USBD_FS_ProductStrDescriptor>:
  * @param  speed : Current device speed
  * @param  length : Pointer to data length variable
  * @retval Pointer to descriptor buffer
  */
uint8_t * USBD_FS_ProductStrDescriptor(USBD_SpeedTypeDef speed, uint16_t *length)
{
 811add8:	b580      	push	{r7, lr}
 811adda:	b082      	sub	sp, #8
 811addc:	af00      	add	r7, sp, #0
 811adde:	4603      	mov	r3, r0
 811ade0:	6039      	str	r1, [r7, #0]
 811ade2:	71fb      	strb	r3, [r7, #7]
  if(speed == 0)
 811ade4:	79fb      	ldrb	r3, [r7, #7]
 811ade6:	2b00      	cmp	r3, #0
 811ade8:	d105      	bne.n	811adf6 <USBD_FS_ProductStrDescriptor+0x1e>
  {
    USBD_GetString((uint8_t *)USBD_PRODUCT_STRING_FS, USBD_StrDesc, length);
 811adea:	683a      	ldr	r2, [r7, #0]
 811adec:	4907      	ldr	r1, [pc, #28]	; (811ae0c <USBD_FS_ProductStrDescriptor+0x34>)
 811adee:	4808      	ldr	r0, [pc, #32]	; (811ae10 <USBD_FS_ProductStrDescriptor+0x38>)
 811adf0:	f7f3 f856 	bl	810dea0 <USBD_GetString>
 811adf4:	e004      	b.n	811ae00 <USBD_FS_ProductStrDescriptor+0x28>
  }
  else
  {
    USBD_GetString((uint8_t *)USBD_PRODUCT_STRING_FS, USBD_StrDesc, length);
 811adf6:	683a      	ldr	r2, [r7, #0]
 811adf8:	4904      	ldr	r1, [pc, #16]	; (811ae0c <USBD_FS_ProductStrDescriptor+0x34>)
 811adfa:	4805      	ldr	r0, [pc, #20]	; (811ae10 <USBD_FS_ProductStrDescriptor+0x38>)
 811adfc:	f7f3 f850 	bl	810dea0 <USBD_GetString>
  }
  return USBD_StrDesc;
 811ae00:	4b02      	ldr	r3, [pc, #8]	; (811ae0c <USBD_FS_ProductStrDescriptor+0x34>)
}
 811ae02:	4618      	mov	r0, r3
 811ae04:	3708      	adds	r7, #8
 811ae06:	46bd      	mov	sp, r7
 811ae08:	bd80      	pop	{r7, pc}
 811ae0a:	bf00      	nop
 811ae0c:	10008784 	.word	0x10008784
 811ae10:	0811f89c 	.word	0x0811f89c

0811ae14 <USBD_FS_ManufacturerStrDescriptor>:
  * @param  speed : Current device speed
  * @param  length : Pointer to data length variable
  * @retval Pointer to descriptor buffer
  */
uint8_t * USBD_FS_ManufacturerStrDescriptor(USBD_SpeedTypeDef speed, uint16_t *length)
{
 811ae14:	b580      	push	{r7, lr}
 811ae16:	b082      	sub	sp, #8
 811ae18:	af00      	add	r7, sp, #0
 811ae1a:	4603      	mov	r3, r0
 811ae1c:	6039      	str	r1, [r7, #0]
 811ae1e:	71fb      	strb	r3, [r7, #7]
  UNUSED(speed);
  USBD_GetString((uint8_t *)USBD_MANUFACTURER_STRING, USBD_StrDesc, length);
 811ae20:	683a      	ldr	r2, [r7, #0]
 811ae22:	4904      	ldr	r1, [pc, #16]	; (811ae34 <USBD_FS_ManufacturerStrDescriptor+0x20>)
 811ae24:	4804      	ldr	r0, [pc, #16]	; (811ae38 <USBD_FS_ManufacturerStrDescriptor+0x24>)
 811ae26:	f7f3 f83b 	bl	810dea0 <USBD_GetString>
  return USBD_StrDesc;
 811ae2a:	4b02      	ldr	r3, [pc, #8]	; (811ae34 <USBD_FS_ManufacturerStrDescriptor+0x20>)
}
 811ae2c:	4618      	mov	r0, r3
 811ae2e:	3708      	adds	r7, #8
 811ae30:	46bd      	mov	sp, r7
 811ae32:	bd80      	pop	{r7, pc}
 811ae34:	10008784 	.word	0x10008784
 811ae38:	0811f8b4 	.word	0x0811f8b4

0811ae3c <USBD_FS_SerialStrDescriptor>:
  * @param  speed : Current device speed
  * @param  length : Pointer to data length variable
  * @retval Pointer to descriptor buffer
  */
uint8_t * USBD_FS_SerialStrDescriptor(USBD_SpeedTypeDef speed, uint16_t *length)
{
 811ae3c:	b580      	push	{r7, lr}
 811ae3e:	b082      	sub	sp, #8
 811ae40:	af00      	add	r7, sp, #0
 811ae42:	4603      	mov	r3, r0
 811ae44:	6039      	str	r1, [r7, #0]
 811ae46:	71fb      	strb	r3, [r7, #7]
  UNUSED(speed);
  *length = USB_SIZ_STRING_SERIAL;
 811ae48:	683b      	ldr	r3, [r7, #0]
 811ae4a:	221a      	movs	r2, #26
 811ae4c:	801a      	strh	r2, [r3, #0]

  /* Update the serial number string descriptor with the data from the unique
   * ID */
  Get_SerialNum();
 811ae4e:	f000 f843 	bl	811aed8 <Get_SerialNum>
  /* USER CODE BEGIN USBD_FS_SerialStrDescriptor */

  /* USER CODE END USBD_FS_SerialStrDescriptor */
  return (uint8_t *) USBD_StringSerial;
 811ae52:	4b02      	ldr	r3, [pc, #8]	; (811ae5c <USBD_FS_SerialStrDescriptor+0x20>)
}
 811ae54:	4618      	mov	r0, r3
 811ae56:	3708      	adds	r7, #8
 811ae58:	46bd      	mov	sp, r7
 811ae5a:	bd80      	pop	{r7, pc}
 811ae5c:	10000148 	.word	0x10000148

0811ae60 <USBD_FS_ConfigStrDescriptor>:
  * @param  speed : Current device speed
  * @param  length : Pointer to data length variable
  * @retval Pointer to descriptor buffer
  */
uint8_t * USBD_FS_ConfigStrDescriptor(USBD_SpeedTypeDef speed, uint16_t *length)
{
 811ae60:	b580      	push	{r7, lr}
 811ae62:	b082      	sub	sp, #8
 811ae64:	af00      	add	r7, sp, #0
 811ae66:	4603      	mov	r3, r0
 811ae68:	6039      	str	r1, [r7, #0]
 811ae6a:	71fb      	strb	r3, [r7, #7]
  if(speed == USBD_SPEED_HIGH)
 811ae6c:	79fb      	ldrb	r3, [r7, #7]
 811ae6e:	2b00      	cmp	r3, #0
 811ae70:	d105      	bne.n	811ae7e <USBD_FS_ConfigStrDescriptor+0x1e>
  {
    USBD_GetString((uint8_t *)USBD_CONFIGURATION_STRING_FS, USBD_StrDesc, length);
 811ae72:	683a      	ldr	r2, [r7, #0]
 811ae74:	4907      	ldr	r1, [pc, #28]	; (811ae94 <USBD_FS_ConfigStrDescriptor+0x34>)
 811ae76:	4808      	ldr	r0, [pc, #32]	; (811ae98 <USBD_FS_ConfigStrDescriptor+0x38>)
 811ae78:	f7f3 f812 	bl	810dea0 <USBD_GetString>
 811ae7c:	e004      	b.n	811ae88 <USBD_FS_ConfigStrDescriptor+0x28>
  }
  else
  {
    USBD_GetString((uint8_t *)USBD_CONFIGURATION_STRING_FS, USBD_StrDesc, length);
 811ae7e:	683a      	ldr	r2, [r7, #0]
 811ae80:	4904      	ldr	r1, [pc, #16]	; (811ae94 <USBD_FS_ConfigStrDescriptor+0x34>)
 811ae82:	4805      	ldr	r0, [pc, #20]	; (811ae98 <USBD_FS_ConfigStrDescriptor+0x38>)
 811ae84:	f7f3 f80c 	bl	810dea0 <USBD_GetString>
  }
  return USBD_StrDesc;
 811ae88:	4b02      	ldr	r3, [pc, #8]	; (811ae94 <USBD_FS_ConfigStrDescriptor+0x34>)
}
 811ae8a:	4618      	mov	r0, r3
 811ae8c:	3708      	adds	r7, #8
 811ae8e:	46bd      	mov	sp, r7
 811ae90:	bd80      	pop	{r7, pc}
 811ae92:	bf00      	nop
 811ae94:	10008784 	.word	0x10008784
 811ae98:	0811f8c8 	.word	0x0811f8c8

0811ae9c <USBD_FS_InterfaceStrDescriptor>:
  * @param  speed : Current device speed
  * @param  length : Pointer to data length variable
  * @retval Pointer to descriptor buffer
  */
uint8_t * USBD_FS_InterfaceStrDescriptor(USBD_SpeedTypeDef speed, uint16_t *length)
{
 811ae9c:	b580      	push	{r7, lr}
 811ae9e:	b082      	sub	sp, #8
 811aea0:	af00      	add	r7, sp, #0
 811aea2:	4603      	mov	r3, r0
 811aea4:	6039      	str	r1, [r7, #0]
 811aea6:	71fb      	strb	r3, [r7, #7]
  if(speed == 0)
 811aea8:	79fb      	ldrb	r3, [r7, #7]
 811aeaa:	2b00      	cmp	r3, #0
 811aeac:	d105      	bne.n	811aeba <USBD_FS_InterfaceStrDescriptor+0x1e>
  {
    USBD_GetString((uint8_t *)USBD_INTERFACE_STRING_FS, USBD_StrDesc, length);
 811aeae:	683a      	ldr	r2, [r7, #0]
 811aeb0:	4907      	ldr	r1, [pc, #28]	; (811aed0 <USBD_FS_InterfaceStrDescriptor+0x34>)
 811aeb2:	4808      	ldr	r0, [pc, #32]	; (811aed4 <USBD_FS_InterfaceStrDescriptor+0x38>)
 811aeb4:	f7f2 fff4 	bl	810dea0 <USBD_GetString>
 811aeb8:	e004      	b.n	811aec4 <USBD_FS_InterfaceStrDescriptor+0x28>
  }
  else
  {
    USBD_GetString((uint8_t *)USBD_INTERFACE_STRING_FS, USBD_StrDesc, length);
 811aeba:	683a      	ldr	r2, [r7, #0]
 811aebc:	4904      	ldr	r1, [pc, #16]	; (811aed0 <USBD_FS_InterfaceStrDescriptor+0x34>)
 811aebe:	4805      	ldr	r0, [pc, #20]	; (811aed4 <USBD_FS_InterfaceStrDescriptor+0x38>)
 811aec0:	f7f2 ffee 	bl	810dea0 <USBD_GetString>
  }
  return USBD_StrDesc;
 811aec4:	4b02      	ldr	r3, [pc, #8]	; (811aed0 <USBD_FS_InterfaceStrDescriptor+0x34>)
}
 811aec6:	4618      	mov	r0, r3
 811aec8:	3708      	adds	r7, #8
 811aeca:	46bd      	mov	sp, r7
 811aecc:	bd80      	pop	{r7, pc}
 811aece:	bf00      	nop
 811aed0:	10008784 	.word	0x10008784
 811aed4:	0811f8d4 	.word	0x0811f8d4

0811aed8 <Get_SerialNum>:
  * @brief  Create the serial number string descriptor
  * @param  None
  * @retval None
  */
static void Get_SerialNum(void)
{
 811aed8:	b580      	push	{r7, lr}
 811aeda:	b084      	sub	sp, #16
 811aedc:	af00      	add	r7, sp, #0
  uint32_t deviceserial1;
  uint32_t deviceserial2;

/* USER CODE BEGIN SerialNum */

  deviceserial0 = DEVICE_SERIAL0;
 811aede:	4b0f      	ldr	r3, [pc, #60]	; (811af1c <Get_SerialNum+0x44>)
 811aee0:	681b      	ldr	r3, [r3, #0]
 811aee2:	60fb      	str	r3, [r7, #12]
  deviceserial1 = DEVICE_SERIAL1;
 811aee4:	4b0e      	ldr	r3, [pc, #56]	; (811af20 <Get_SerialNum+0x48>)
 811aee6:	681b      	ldr	r3, [r3, #0]
 811aee8:	60bb      	str	r3, [r7, #8]
  deviceserial2 = DEVICE_SERIAL2;
 811aeea:	4b0e      	ldr	r3, [pc, #56]	; (811af24 <Get_SerialNum+0x4c>)
 811aeec:	681b      	ldr	r3, [r3, #0]
 811aeee:	607b      	str	r3, [r7, #4]

/* USER CODE END SerialNum */

  deviceserial0 += deviceserial2;
 811aef0:	68fa      	ldr	r2, [r7, #12]
 811aef2:	687b      	ldr	r3, [r7, #4]
 811aef4:	4413      	add	r3, r2
 811aef6:	60fb      	str	r3, [r7, #12]

  if (deviceserial0 != 0)
 811aef8:	68fb      	ldr	r3, [r7, #12]
 811aefa:	2b00      	cmp	r3, #0
 811aefc:	d009      	beq.n	811af12 <Get_SerialNum+0x3a>
  {
    IntToUnicode(deviceserial0, &USBD_StringSerial[2], 8);
 811aefe:	2208      	movs	r2, #8
 811af00:	4909      	ldr	r1, [pc, #36]	; (811af28 <Get_SerialNum+0x50>)
 811af02:	68f8      	ldr	r0, [r7, #12]
 811af04:	f000 f814 	bl	811af30 <IntToUnicode>
    IntToUnicode(deviceserial1, &USBD_StringSerial[18], 4);
 811af08:	2204      	movs	r2, #4
 811af0a:	4908      	ldr	r1, [pc, #32]	; (811af2c <Get_SerialNum+0x54>)
 811af0c:	68b8      	ldr	r0, [r7, #8]
 811af0e:	f000 f80f 	bl	811af30 <IntToUnicode>
  }
}
 811af12:	bf00      	nop
 811af14:	3710      	adds	r7, #16
 811af16:	46bd      	mov	sp, r7
 811af18:	bd80      	pop	{r7, pc}
 811af1a:	bf00      	nop
 811af1c:	11223344 	.word	0x11223344
 811af20:	55667788 	.word	0x55667788
 811af24:	12345678 	.word	0x12345678
 811af28:	1000014a 	.word	0x1000014a
 811af2c:	1000015a 	.word	0x1000015a

0811af30 <IntToUnicode>:
  * @param  pbuf: pointer to the buffer
  * @param  len: buffer length
  * @retval None
  */
static void IntToUnicode(uint32_t value, uint8_t * pbuf, uint8_t len)
{
 811af30:	b480      	push	{r7}
 811af32:	b087      	sub	sp, #28
 811af34:	af00      	add	r7, sp, #0
 811af36:	60f8      	str	r0, [r7, #12]
 811af38:	60b9      	str	r1, [r7, #8]
 811af3a:	4613      	mov	r3, r2
 811af3c:	71fb      	strb	r3, [r7, #7]
  uint8_t idx = 0;
 811af3e:	2300      	movs	r3, #0
 811af40:	75fb      	strb	r3, [r7, #23]

  for (idx = 0; idx < len; idx++)
 811af42:	2300      	movs	r3, #0
 811af44:	75fb      	strb	r3, [r7, #23]
 811af46:	e027      	b.n	811af98 <IntToUnicode+0x68>
  {
    if (((value >> 28)) < 0xA)
 811af48:	68fb      	ldr	r3, [r7, #12]
 811af4a:	0f1b      	lsrs	r3, r3, #28
 811af4c:	2b09      	cmp	r3, #9
 811af4e:	d80b      	bhi.n	811af68 <IntToUnicode+0x38>
    {
      pbuf[2 * idx] = (value >> 28) + '0';
 811af50:	68fb      	ldr	r3, [r7, #12]
 811af52:	0f1b      	lsrs	r3, r3, #28
 811af54:	b2da      	uxtb	r2, r3
 811af56:	7dfb      	ldrb	r3, [r7, #23]
 811af58:	005b      	lsls	r3, r3, #1
 811af5a:	4619      	mov	r1, r3
 811af5c:	68bb      	ldr	r3, [r7, #8]
 811af5e:	440b      	add	r3, r1
 811af60:	3230      	adds	r2, #48	; 0x30
 811af62:	b2d2      	uxtb	r2, r2
 811af64:	701a      	strb	r2, [r3, #0]
 811af66:	e00a      	b.n	811af7e <IntToUnicode+0x4e>
    }
    else
    {
      pbuf[2 * idx] = (value >> 28) + 'A' - 10;
 811af68:	68fb      	ldr	r3, [r7, #12]
 811af6a:	0f1b      	lsrs	r3, r3, #28
 811af6c:	b2da      	uxtb	r2, r3
 811af6e:	7dfb      	ldrb	r3, [r7, #23]
 811af70:	005b      	lsls	r3, r3, #1
 811af72:	4619      	mov	r1, r3
 811af74:	68bb      	ldr	r3, [r7, #8]
 811af76:	440b      	add	r3, r1
 811af78:	3237      	adds	r2, #55	; 0x37
 811af7a:	b2d2      	uxtb	r2, r2
 811af7c:	701a      	strb	r2, [r3, #0]
    }

    value = value << 4;
 811af7e:	68fb      	ldr	r3, [r7, #12]
 811af80:	011b      	lsls	r3, r3, #4
 811af82:	60fb      	str	r3, [r7, #12]

    pbuf[2 * idx + 1] = 0;
 811af84:	7dfb      	ldrb	r3, [r7, #23]
 811af86:	005b      	lsls	r3, r3, #1
 811af88:	3301      	adds	r3, #1
 811af8a:	68ba      	ldr	r2, [r7, #8]
 811af8c:	4413      	add	r3, r2
 811af8e:	2200      	movs	r2, #0
 811af90:	701a      	strb	r2, [r3, #0]
  for (idx = 0; idx < len; idx++)
 811af92:	7dfb      	ldrb	r3, [r7, #23]
 811af94:	3301      	adds	r3, #1
 811af96:	75fb      	strb	r3, [r7, #23]
 811af98:	7dfa      	ldrb	r2, [r7, #23]
 811af9a:	79fb      	ldrb	r3, [r7, #7]
 811af9c:	429a      	cmp	r2, r3
 811af9e:	d3d3      	bcc.n	811af48 <IntToUnicode+0x18>
  }
}
 811afa0:	bf00      	nop
 811afa2:	bf00      	nop
 811afa4:	371c      	adds	r7, #28
 811afa6:	46bd      	mov	sp, r7
 811afa8:	f85d 7b04 	ldr.w	r7, [sp], #4
 811afac:	4770      	bx	lr
	...

0811afb0 <HAL_PCD_MspInit>:
                       LL Driver Callbacks (PCD -> USB Device Library)
*******************************************************************************/
/* MSP Init */

void HAL_PCD_MspInit(PCD_HandleTypeDef* pcdHandle)
{
 811afb0:	b580      	push	{r7, lr}
 811afb2:	b0ba      	sub	sp, #232	; 0xe8
 811afb4:	af00      	add	r7, sp, #0
 811afb6:	6078      	str	r0, [r7, #4]
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 811afb8:	f107 03d4 	add.w	r3, r7, #212	; 0xd4
 811afbc:	2200      	movs	r2, #0
 811afbe:	601a      	str	r2, [r3, #0]
 811afc0:	605a      	str	r2, [r3, #4]
 811afc2:	609a      	str	r2, [r3, #8]
 811afc4:	60da      	str	r2, [r3, #12]
 811afc6:	611a      	str	r2, [r3, #16]
  RCC_PeriphCLKInitTypeDef PeriphClkInitStruct = {0};
 811afc8:	f107 0310 	add.w	r3, r7, #16
 811afcc:	22c0      	movs	r2, #192	; 0xc0
 811afce:	2100      	movs	r1, #0
 811afd0:	4618      	mov	r0, r3
 811afd2:	f000 fc3f 	bl	811b854 <memset>
  if(pcdHandle->Instance==USB_OTG_FS)
 811afd6:	687b      	ldr	r3, [r7, #4]
 811afd8:	681b      	ldr	r3, [r3, #0]
 811afda:	4a35      	ldr	r2, [pc, #212]	; (811b0b0 <HAL_PCD_MspInit+0x100>)
 811afdc:	4293      	cmp	r3, r2
 811afde:	d163      	bne.n	811b0a8 <HAL_PCD_MspInit+0xf8>

  /* USER CODE END USB_OTG_FS_MspInit 0 */

  /** Initializes the peripherals clock
  */
    PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_USB;
 811afe0:	f44f 2280 	mov.w	r2, #262144	; 0x40000
 811afe4:	f04f 0300 	mov.w	r3, #0
 811afe8:	e9c7 2304 	strd	r2, r3, [r7, #16]
    PeriphClkInitStruct.UsbClockSelection = RCC_USBCLKSOURCE_HSI48;
 811afec:	f44f 1340 	mov.w	r3, #3145728	; 0x300000
 811aff0:	f8c7 3098 	str.w	r3, [r7, #152]	; 0x98
    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
 811aff4:	f107 0310 	add.w	r3, r7, #16
 811aff8:	4618      	mov	r0, r3
 811affa:	f7ec f8bb 	bl	8107174 <HAL_RCCEx_PeriphCLKConfig>
 811affe:	4603      	mov	r3, r0
 811b000:	2b00      	cmp	r3, #0
 811b002:	d001      	beq.n	811b008 <HAL_PCD_MspInit+0x58>
    {
      Error_Handler();
 811b004:	f7e5 fd30 	bl	8100a68 <Error_Handler>
    }

  /** Enable USB Voltage detector
  */
    HAL_PWREx_EnableUSBVoltageDetector();
 811b008:	f7eb fecc 	bl	8106da4 <HAL_PWREx_EnableUSBVoltageDetector>

    __HAL_RCC_GPIOA_CLK_ENABLE();
 811b00c:	4b29      	ldr	r3, [pc, #164]	; (811b0b4 <HAL_PCD_MspInit+0x104>)
 811b00e:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
 811b012:	4a28      	ldr	r2, [pc, #160]	; (811b0b4 <HAL_PCD_MspInit+0x104>)
 811b014:	f043 0301 	orr.w	r3, r3, #1
 811b018:	f8c2 30e0 	str.w	r3, [r2, #224]	; 0xe0
 811b01c:	4b25      	ldr	r3, [pc, #148]	; (811b0b4 <HAL_PCD_MspInit+0x104>)
 811b01e:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
 811b022:	f003 0301 	and.w	r3, r3, #1
 811b026:	60fb      	str	r3, [r7, #12]
 811b028:	68fb      	ldr	r3, [r7, #12]
    PA8     ------> USB_OTG_FS_SOF
    PA9     ------> USB_OTG_FS_VBUS
    PA11     ------> USB_OTG_FS_DM
    PA12     ------> USB_OTG_FS_DP
    */
    GPIO_InitStruct.Pin = GPIO_PIN_8|GPIO_PIN_11|GPIO_PIN_12;
 811b02a:	f44f 53c8 	mov.w	r3, #6400	; 0x1900
 811b02e:	f8c7 30d4 	str.w	r3, [r7, #212]	; 0xd4
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 811b032:	2302      	movs	r3, #2
 811b034:	f8c7 30d8 	str.w	r3, [r7, #216]	; 0xd8
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 811b038:	2300      	movs	r3, #0
 811b03a:	f8c7 30dc 	str.w	r3, [r7, #220]	; 0xdc
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 811b03e:	2300      	movs	r3, #0
 811b040:	f8c7 30e0 	str.w	r3, [r7, #224]	; 0xe0
    GPIO_InitStruct.Alternate = GPIO_AF10_OTG1_FS;
 811b044:	230a      	movs	r3, #10
 811b046:	f8c7 30e4 	str.w	r3, [r7, #228]	; 0xe4
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 811b04a:	f107 03d4 	add.w	r3, r7, #212	; 0xd4
 811b04e:	4619      	mov	r1, r3
 811b050:	4819      	ldr	r0, [pc, #100]	; (811b0b8 <HAL_PCD_MspInit+0x108>)
 811b052:	f7ea f9bd 	bl	81053d0 <HAL_GPIO_Init>

    /* Peripheral clock enable */
    __HAL_RCC_USB_OTG_FS_CLK_ENABLE();
 811b056:	4b17      	ldr	r3, [pc, #92]	; (811b0b4 <HAL_PCD_MspInit+0x104>)
 811b058:	f8d3 30d8 	ldr.w	r3, [r3, #216]	; 0xd8
 811b05c:	4a15      	ldr	r2, [pc, #84]	; (811b0b4 <HAL_PCD_MspInit+0x104>)
 811b05e:	f043 6300 	orr.w	r3, r3, #134217728	; 0x8000000
 811b062:	f8c2 30d8 	str.w	r3, [r2, #216]	; 0xd8
 811b066:	4b13      	ldr	r3, [pc, #76]	; (811b0b4 <HAL_PCD_MspInit+0x104>)
 811b068:	f8d3 30d8 	ldr.w	r3, [r3, #216]	; 0xd8
 811b06c:	f003 6300 	and.w	r3, r3, #134217728	; 0x8000000
 811b070:	60bb      	str	r3, [r7, #8]
 811b072:	68bb      	ldr	r3, [r7, #8]

    /* Peripheral interrupt init */
    HAL_NVIC_SetPriority(OTG_FS_IRQn, 0, 0);
 811b074:	2200      	movs	r2, #0
 811b076:	2100      	movs	r1, #0
 811b078:	2065      	movs	r0, #101	; 0x65
 811b07a:	f7e8 fa60 	bl	810353e <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(OTG_FS_IRQn);
 811b07e:	2065      	movs	r0, #101	; 0x65
 811b080:	f7e8 fa77 	bl	8103572 <HAL_NVIC_EnableIRQ>
    if(pcdHandle->Init.low_power_enable == 1)
 811b084:	687b      	ldr	r3, [r7, #4]
 811b086:	7adb      	ldrb	r3, [r3, #11]
 811b088:	2b01      	cmp	r3, #1
 811b08a:	d10d      	bne.n	811b0a8 <HAL_PCD_MspInit+0xf8>
    {
      /* Enable EXTI Line 18 for USB wakeup */
      __HAL_USB_OTG_FS_WAKEUP_EXTI_ENABLE_IT();
 811b08c:	4b0b      	ldr	r3, [pc, #44]	; (811b0bc <HAL_PCD_MspInit+0x10c>)
 811b08e:	691b      	ldr	r3, [r3, #16]
 811b090:	4a0a      	ldr	r2, [pc, #40]	; (811b0bc <HAL_PCD_MspInit+0x10c>)
 811b092:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
 811b096:	6113      	str	r3, [r2, #16]
      HAL_NVIC_SetPriority(OTG_FS_WKUP_IRQn, 0, 0);
 811b098:	2200      	movs	r2, #0
 811b09a:	2100      	movs	r1, #0
 811b09c:	2064      	movs	r0, #100	; 0x64
 811b09e:	f7e8 fa4e 	bl	810353e <HAL_NVIC_SetPriority>
      HAL_NVIC_EnableIRQ(OTG_FS_WKUP_IRQn);
 811b0a2:	2064      	movs	r0, #100	; 0x64
 811b0a4:	f7e8 fa65 	bl	8103572 <HAL_NVIC_EnableIRQ>
    }
  /* USER CODE BEGIN USB_OTG_FS_MspInit 1 */

  /* USER CODE END USB_OTG_FS_MspInit 1 */
  }
}
 811b0a8:	bf00      	nop
 811b0aa:	37e8      	adds	r7, #232	; 0xe8
 811b0ac:	46bd      	mov	sp, r7
 811b0ae:	bd80      	pop	{r7, pc}
 811b0b0:	40080000 	.word	0x40080000
 811b0b4:	58024400 	.word	0x58024400
 811b0b8:	58020000 	.word	0x58020000
 811b0bc:	58000080 	.word	0x58000080

0811b0c0 <HAL_PCD_SetupStageCallback>:
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
static void PCD_SetupStageCallback(PCD_HandleTypeDef *hpcd)
#else
void HAL_PCD_SetupStageCallback(PCD_HandleTypeDef *hpcd)
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
{
 811b0c0:	b580      	push	{r7, lr}
 811b0c2:	b082      	sub	sp, #8
 811b0c4:	af00      	add	r7, sp, #0
 811b0c6:	6078      	str	r0, [r7, #4]
  USBD_LL_SetupStage((USBD_HandleTypeDef*)hpcd->pData, (uint8_t *)hpcd->Setup);
 811b0c8:	687b      	ldr	r3, [r7, #4]
 811b0ca:	f8d3 24e0 	ldr.w	r2, [r3, #1248]	; 0x4e0
 811b0ce:	687b      	ldr	r3, [r7, #4]
 811b0d0:	f203 439c 	addw	r3, r3, #1180	; 0x49c
 811b0d4:	4619      	mov	r1, r3
 811b0d6:	4610      	mov	r0, r2
 811b0d8:	f7f1 fd53 	bl	810cb82 <USBD_LL_SetupStage>
}
 811b0dc:	bf00      	nop
 811b0de:	3708      	adds	r7, #8
 811b0e0:	46bd      	mov	sp, r7
 811b0e2:	bd80      	pop	{r7, pc}

0811b0e4 <HAL_PCD_DataOutStageCallback>:
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
static void PCD_DataOutStageCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
#else
void HAL_PCD_DataOutStageCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
{
 811b0e4:	b580      	push	{r7, lr}
 811b0e6:	b082      	sub	sp, #8
 811b0e8:	af00      	add	r7, sp, #0
 811b0ea:	6078      	str	r0, [r7, #4]
 811b0ec:	460b      	mov	r3, r1
 811b0ee:	70fb      	strb	r3, [r7, #3]
  USBD_LL_DataOutStage((USBD_HandleTypeDef*)hpcd->pData, epnum, hpcd->OUT_ep[epnum].xfer_buff);
 811b0f0:	687b      	ldr	r3, [r7, #4]
 811b0f2:	f8d3 04e0 	ldr.w	r0, [r3, #1248]	; 0x4e0
 811b0f6:	78fa      	ldrb	r2, [r7, #3]
 811b0f8:	6879      	ldr	r1, [r7, #4]
 811b0fa:	4613      	mov	r3, r2
 811b0fc:	00db      	lsls	r3, r3, #3
 811b0fe:	4413      	add	r3, r2
 811b100:	009b      	lsls	r3, r3, #2
 811b102:	440b      	add	r3, r1
 811b104:	f503 7318 	add.w	r3, r3, #608	; 0x260
 811b108:	681a      	ldr	r2, [r3, #0]
 811b10a:	78fb      	ldrb	r3, [r7, #3]
 811b10c:	4619      	mov	r1, r3
 811b10e:	f7f1 fd8d 	bl	810cc2c <USBD_LL_DataOutStage>
}
 811b112:	bf00      	nop
 811b114:	3708      	adds	r7, #8
 811b116:	46bd      	mov	sp, r7
 811b118:	bd80      	pop	{r7, pc}

0811b11a <HAL_PCD_DataInStageCallback>:
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
static void PCD_DataInStageCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
#else
void HAL_PCD_DataInStageCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
{
 811b11a:	b580      	push	{r7, lr}
 811b11c:	b082      	sub	sp, #8
 811b11e:	af00      	add	r7, sp, #0
 811b120:	6078      	str	r0, [r7, #4]
 811b122:	460b      	mov	r3, r1
 811b124:	70fb      	strb	r3, [r7, #3]
  USBD_LL_DataInStage((USBD_HandleTypeDef*)hpcd->pData, epnum, hpcd->IN_ep[epnum].xfer_buff);
 811b126:	687b      	ldr	r3, [r7, #4]
 811b128:	f8d3 04e0 	ldr.w	r0, [r3, #1248]	; 0x4e0
 811b12c:	78fa      	ldrb	r2, [r7, #3]
 811b12e:	6879      	ldr	r1, [r7, #4]
 811b130:	4613      	mov	r3, r2
 811b132:	00db      	lsls	r3, r3, #3
 811b134:	4413      	add	r3, r2
 811b136:	009b      	lsls	r3, r3, #2
 811b138:	440b      	add	r3, r1
 811b13a:	3320      	adds	r3, #32
 811b13c:	681a      	ldr	r2, [r3, #0]
 811b13e:	78fb      	ldrb	r3, [r7, #3]
 811b140:	4619      	mov	r1, r3
 811b142:	f7f1 fe26 	bl	810cd92 <USBD_LL_DataInStage>
}
 811b146:	bf00      	nop
 811b148:	3708      	adds	r7, #8
 811b14a:	46bd      	mov	sp, r7
 811b14c:	bd80      	pop	{r7, pc}

0811b14e <HAL_PCD_SOFCallback>:
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
static void PCD_SOFCallback(PCD_HandleTypeDef *hpcd)
#else
void HAL_PCD_SOFCallback(PCD_HandleTypeDef *hpcd)
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
{
 811b14e:	b580      	push	{r7, lr}
 811b150:	b082      	sub	sp, #8
 811b152:	af00      	add	r7, sp, #0
 811b154:	6078      	str	r0, [r7, #4]
  USBD_LL_SOF((USBD_HandleTypeDef*)hpcd->pData);
 811b156:	687b      	ldr	r3, [r7, #4]
 811b158:	f8d3 34e0 	ldr.w	r3, [r3, #1248]	; 0x4e0
 811b15c:	4618      	mov	r0, r3
 811b15e:	f7f1 ff60 	bl	810d022 <USBD_LL_SOF>
}
 811b162:	bf00      	nop
 811b164:	3708      	adds	r7, #8
 811b166:	46bd      	mov	sp, r7
 811b168:	bd80      	pop	{r7, pc}

0811b16a <HAL_PCD_ResetCallback>:
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
static void PCD_ResetCallback(PCD_HandleTypeDef *hpcd)
#else
void HAL_PCD_ResetCallback(PCD_HandleTypeDef *hpcd)
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
{
 811b16a:	b580      	push	{r7, lr}
 811b16c:	b084      	sub	sp, #16
 811b16e:	af00      	add	r7, sp, #0
 811b170:	6078      	str	r0, [r7, #4]
  USBD_SpeedTypeDef speed = USBD_SPEED_FULL;
 811b172:	2301      	movs	r3, #1
 811b174:	73fb      	strb	r3, [r7, #15]

  if ( hpcd->Init.speed == PCD_SPEED_HIGH)
 811b176:	687b      	ldr	r3, [r7, #4]
 811b178:	79db      	ldrb	r3, [r3, #7]
 811b17a:	2b00      	cmp	r3, #0
 811b17c:	d102      	bne.n	811b184 <HAL_PCD_ResetCallback+0x1a>
  {
    speed = USBD_SPEED_HIGH;
 811b17e:	2300      	movs	r3, #0
 811b180:	73fb      	strb	r3, [r7, #15]
 811b182:	e008      	b.n	811b196 <HAL_PCD_ResetCallback+0x2c>
  }
  else if ( hpcd->Init.speed == PCD_SPEED_FULL)
 811b184:	687b      	ldr	r3, [r7, #4]
 811b186:	79db      	ldrb	r3, [r3, #7]
 811b188:	2b02      	cmp	r3, #2
 811b18a:	d102      	bne.n	811b192 <HAL_PCD_ResetCallback+0x28>
  {
    speed = USBD_SPEED_FULL;
 811b18c:	2301      	movs	r3, #1
 811b18e:	73fb      	strb	r3, [r7, #15]
 811b190:	e001      	b.n	811b196 <HAL_PCD_ResetCallback+0x2c>
  }
  else
  {
    Error_Handler();
 811b192:	f7e5 fc69 	bl	8100a68 <Error_Handler>
  }
    /* Set Speed. */
  USBD_LL_SetSpeed((USBD_HandleTypeDef*)hpcd->pData, speed);
 811b196:	687b      	ldr	r3, [r7, #4]
 811b198:	f8d3 34e0 	ldr.w	r3, [r3, #1248]	; 0x4e0
 811b19c:	7bfa      	ldrb	r2, [r7, #15]
 811b19e:	4611      	mov	r1, r2
 811b1a0:	4618      	mov	r0, r3
 811b1a2:	f7f1 fefa 	bl	810cf9a <USBD_LL_SetSpeed>

  /* Reset Device. */
  USBD_LL_Reset((USBD_HandleTypeDef*)hpcd->pData);
 811b1a6:	687b      	ldr	r3, [r7, #4]
 811b1a8:	f8d3 34e0 	ldr.w	r3, [r3, #1248]	; 0x4e0
 811b1ac:	4618      	mov	r0, r3
 811b1ae:	f7f1 fea2 	bl	810cef6 <USBD_LL_Reset>
}
 811b1b2:	bf00      	nop
 811b1b4:	3710      	adds	r7, #16
 811b1b6:	46bd      	mov	sp, r7
 811b1b8:	bd80      	pop	{r7, pc}
	...

0811b1bc <HAL_PCD_SuspendCallback>:
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
static void PCD_SuspendCallback(PCD_HandleTypeDef *hpcd)
#else
void HAL_PCD_SuspendCallback(PCD_HandleTypeDef *hpcd)
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
{
 811b1bc:	b580      	push	{r7, lr}
 811b1be:	b082      	sub	sp, #8
 811b1c0:	af00      	add	r7, sp, #0
 811b1c2:	6078      	str	r0, [r7, #4]
  /* Inform USB library that core enters in suspend Mode. */
  USBD_LL_Suspend((USBD_HandleTypeDef*)hpcd->pData);
 811b1c4:	687b      	ldr	r3, [r7, #4]
 811b1c6:	f8d3 34e0 	ldr.w	r3, [r3, #1248]	; 0x4e0
 811b1ca:	4618      	mov	r0, r3
 811b1cc:	f7f1 fef5 	bl	810cfba <USBD_LL_Suspend>
  __HAL_PCD_GATE_PHYCLOCK(hpcd);
 811b1d0:	687b      	ldr	r3, [r7, #4]
 811b1d2:	681b      	ldr	r3, [r3, #0]
 811b1d4:	f503 6360 	add.w	r3, r3, #3584	; 0xe00
 811b1d8:	681b      	ldr	r3, [r3, #0]
 811b1da:	687a      	ldr	r2, [r7, #4]
 811b1dc:	6812      	ldr	r2, [r2, #0]
 811b1de:	f502 6260 	add.w	r2, r2, #3584	; 0xe00
 811b1e2:	f043 0301 	orr.w	r3, r3, #1
 811b1e6:	6013      	str	r3, [r2, #0]
  /* Enter in STOP mode. */
  /* USER CODE BEGIN 2 */
  if (hpcd->Init.low_power_enable)
 811b1e8:	687b      	ldr	r3, [r7, #4]
 811b1ea:	7adb      	ldrb	r3, [r3, #11]
 811b1ec:	2b00      	cmp	r3, #0
 811b1ee:	d005      	beq.n	811b1fc <HAL_PCD_SuspendCallback+0x40>
  {
    /* Set SLEEPDEEP bit and SleepOnExit of Cortex System Control Register. */
    SCB->SCR |= (uint32_t)((uint32_t)(SCB_SCR_SLEEPDEEP_Msk | SCB_SCR_SLEEPONEXIT_Msk));
 811b1f0:	4b04      	ldr	r3, [pc, #16]	; (811b204 <HAL_PCD_SuspendCallback+0x48>)
 811b1f2:	691b      	ldr	r3, [r3, #16]
 811b1f4:	4a03      	ldr	r2, [pc, #12]	; (811b204 <HAL_PCD_SuspendCallback+0x48>)
 811b1f6:	f043 0306 	orr.w	r3, r3, #6
 811b1fa:	6113      	str	r3, [r2, #16]
  }
  /* USER CODE END 2 */
}
 811b1fc:	bf00      	nop
 811b1fe:	3708      	adds	r7, #8
 811b200:	46bd      	mov	sp, r7
 811b202:	bd80      	pop	{r7, pc}
 811b204:	e000ed00 	.word	0xe000ed00

0811b208 <HAL_PCD_ResumeCallback>:
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
static void PCD_ResumeCallback(PCD_HandleTypeDef *hpcd)
#else
void HAL_PCD_ResumeCallback(PCD_HandleTypeDef *hpcd)
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
{
 811b208:	b580      	push	{r7, lr}
 811b20a:	b082      	sub	sp, #8
 811b20c:	af00      	add	r7, sp, #0
 811b20e:	6078      	str	r0, [r7, #4]
  /* USER CODE BEGIN 3 */

  /* USER CODE END 3 */
  USBD_LL_Resume((USBD_HandleTypeDef*)hpcd->pData);
 811b210:	687b      	ldr	r3, [r7, #4]
 811b212:	f8d3 34e0 	ldr.w	r3, [r3, #1248]	; 0x4e0
 811b216:	4618      	mov	r0, r3
 811b218:	f7f1 feeb 	bl	810cff2 <USBD_LL_Resume>
}
 811b21c:	bf00      	nop
 811b21e:	3708      	adds	r7, #8
 811b220:	46bd      	mov	sp, r7
 811b222:	bd80      	pop	{r7, pc}

0811b224 <HAL_PCD_ISOOUTIncompleteCallback>:
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
static void PCD_ISOOUTIncompleteCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
#else
void HAL_PCD_ISOOUTIncompleteCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
{
 811b224:	b580      	push	{r7, lr}
 811b226:	b082      	sub	sp, #8
 811b228:	af00      	add	r7, sp, #0
 811b22a:	6078      	str	r0, [r7, #4]
 811b22c:	460b      	mov	r3, r1
 811b22e:	70fb      	strb	r3, [r7, #3]
  USBD_LL_IsoOUTIncomplete((USBD_HandleTypeDef*)hpcd->pData, epnum);
 811b230:	687b      	ldr	r3, [r7, #4]
 811b232:	f8d3 34e0 	ldr.w	r3, [r3, #1248]	; 0x4e0
 811b236:	78fa      	ldrb	r2, [r7, #3]
 811b238:	4611      	mov	r1, r2
 811b23a:	4618      	mov	r0, r3
 811b23c:	f7f1 ff43 	bl	810d0c6 <USBD_LL_IsoOUTIncomplete>
}
 811b240:	bf00      	nop
 811b242:	3708      	adds	r7, #8
 811b244:	46bd      	mov	sp, r7
 811b246:	bd80      	pop	{r7, pc}

0811b248 <HAL_PCD_ISOINIncompleteCallback>:
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
static void PCD_ISOINIncompleteCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
#else
void HAL_PCD_ISOINIncompleteCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
{
 811b248:	b580      	push	{r7, lr}
 811b24a:	b082      	sub	sp, #8
 811b24c:	af00      	add	r7, sp, #0
 811b24e:	6078      	str	r0, [r7, #4]
 811b250:	460b      	mov	r3, r1
 811b252:	70fb      	strb	r3, [r7, #3]
  USBD_LL_IsoINIncomplete((USBD_HandleTypeDef*)hpcd->pData, epnum);
 811b254:	687b      	ldr	r3, [r7, #4]
 811b256:	f8d3 34e0 	ldr.w	r3, [r3, #1248]	; 0x4e0
 811b25a:	78fa      	ldrb	r2, [r7, #3]
 811b25c:	4611      	mov	r1, r2
 811b25e:	4618      	mov	r0, r3
 811b260:	f7f1 feff 	bl	810d062 <USBD_LL_IsoINIncomplete>
}
 811b264:	bf00      	nop
 811b266:	3708      	adds	r7, #8
 811b268:	46bd      	mov	sp, r7
 811b26a:	bd80      	pop	{r7, pc}

0811b26c <HAL_PCD_ConnectCallback>:
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
static void PCD_ConnectCallback(PCD_HandleTypeDef *hpcd)
#else
void HAL_PCD_ConnectCallback(PCD_HandleTypeDef *hpcd)
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
{
 811b26c:	b580      	push	{r7, lr}
 811b26e:	b082      	sub	sp, #8
 811b270:	af00      	add	r7, sp, #0
 811b272:	6078      	str	r0, [r7, #4]
  USBD_LL_DevConnected((USBD_HandleTypeDef*)hpcd->pData);
 811b274:	687b      	ldr	r3, [r7, #4]
 811b276:	f8d3 34e0 	ldr.w	r3, [r3, #1248]	; 0x4e0
 811b27a:	4618      	mov	r0, r3
 811b27c:	f7f1 ff55 	bl	810d12a <USBD_LL_DevConnected>
}
 811b280:	bf00      	nop
 811b282:	3708      	adds	r7, #8
 811b284:	46bd      	mov	sp, r7
 811b286:	bd80      	pop	{r7, pc}

0811b288 <HAL_PCD_DisconnectCallback>:
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
static void PCD_DisconnectCallback(PCD_HandleTypeDef *hpcd)
#else
void HAL_PCD_DisconnectCallback(PCD_HandleTypeDef *hpcd)
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
{
 811b288:	b580      	push	{r7, lr}
 811b28a:	b082      	sub	sp, #8
 811b28c:	af00      	add	r7, sp, #0
 811b28e:	6078      	str	r0, [r7, #4]
  USBD_LL_DevDisconnected((USBD_HandleTypeDef*)hpcd->pData);
 811b290:	687b      	ldr	r3, [r7, #4]
 811b292:	f8d3 34e0 	ldr.w	r3, [r3, #1248]	; 0x4e0
 811b296:	4618      	mov	r0, r3
 811b298:	f7f1 ff52 	bl	810d140 <USBD_LL_DevDisconnected>
}
 811b29c:	bf00      	nop
 811b29e:	3708      	adds	r7, #8
 811b2a0:	46bd      	mov	sp, r7
 811b2a2:	bd80      	pop	{r7, pc}

0811b2a4 <USBD_LL_Init>:
  * @brief  Initializes the low level portion of the device driver.
  * @param  pdev: Device handle
  * @retval USBD status
  */
USBD_StatusTypeDef USBD_LL_Init(USBD_HandleTypeDef *pdev)
{
 811b2a4:	b580      	push	{r7, lr}
 811b2a6:	b082      	sub	sp, #8
 811b2a8:	af00      	add	r7, sp, #0
 811b2aa:	6078      	str	r0, [r7, #4]
  /* Init USB Ip. */
  if (pdev->id == DEVICE_FS) {
 811b2ac:	687b      	ldr	r3, [r7, #4]
 811b2ae:	781b      	ldrb	r3, [r3, #0]
 811b2b0:	2b00      	cmp	r3, #0
 811b2b2:	d13e      	bne.n	811b332 <USBD_LL_Init+0x8e>
  /* Link the driver to the stack. */
  hpcd_USB_OTG_FS.pData = pdev;
 811b2b4:	4a21      	ldr	r2, [pc, #132]	; (811b33c <USBD_LL_Init+0x98>)
 811b2b6:	687b      	ldr	r3, [r7, #4]
 811b2b8:	f8c2 34e0 	str.w	r3, [r2, #1248]	; 0x4e0
  pdev->pData = &hpcd_USB_OTG_FS;
 811b2bc:	687b      	ldr	r3, [r7, #4]
 811b2be:	4a1f      	ldr	r2, [pc, #124]	; (811b33c <USBD_LL_Init+0x98>)
 811b2c0:	f8c3 22c8 	str.w	r2, [r3, #712]	; 0x2c8

  hpcd_USB_OTG_FS.Instance = USB_OTG_FS;
 811b2c4:	4b1d      	ldr	r3, [pc, #116]	; (811b33c <USBD_LL_Init+0x98>)
 811b2c6:	4a1e      	ldr	r2, [pc, #120]	; (811b340 <USBD_LL_Init+0x9c>)
 811b2c8:	601a      	str	r2, [r3, #0]
  hpcd_USB_OTG_FS.Init.dev_endpoints = 9;
 811b2ca:	4b1c      	ldr	r3, [pc, #112]	; (811b33c <USBD_LL_Init+0x98>)
 811b2cc:	2209      	movs	r2, #9
 811b2ce:	711a      	strb	r2, [r3, #4]
  hpcd_USB_OTG_FS.Init.speed = PCD_SPEED_FULL;
 811b2d0:	4b1a      	ldr	r3, [pc, #104]	; (811b33c <USBD_LL_Init+0x98>)
 811b2d2:	2202      	movs	r2, #2
 811b2d4:	71da      	strb	r2, [r3, #7]
  hpcd_USB_OTG_FS.Init.dma_enable = ENABLE;
 811b2d6:	4b19      	ldr	r3, [pc, #100]	; (811b33c <USBD_LL_Init+0x98>)
 811b2d8:	2201      	movs	r2, #1
 811b2da:	719a      	strb	r2, [r3, #6]
  hpcd_USB_OTG_FS.Init.phy_itface = PCD_PHY_EMBEDDED;
 811b2dc:	4b17      	ldr	r3, [pc, #92]	; (811b33c <USBD_LL_Init+0x98>)
 811b2de:	2202      	movs	r2, #2
 811b2e0:	725a      	strb	r2, [r3, #9]
  hpcd_USB_OTG_FS.Init.Sof_enable = DISABLE;
 811b2e2:	4b16      	ldr	r3, [pc, #88]	; (811b33c <USBD_LL_Init+0x98>)
 811b2e4:	2200      	movs	r2, #0
 811b2e6:	729a      	strb	r2, [r3, #10]
  hpcd_USB_OTG_FS.Init.low_power_enable = ENABLE;
 811b2e8:	4b14      	ldr	r3, [pc, #80]	; (811b33c <USBD_LL_Init+0x98>)
 811b2ea:	2201      	movs	r2, #1
 811b2ec:	72da      	strb	r2, [r3, #11]
  hpcd_USB_OTG_FS.Init.lpm_enable = ENABLE;
 811b2ee:	4b13      	ldr	r3, [pc, #76]	; (811b33c <USBD_LL_Init+0x98>)
 811b2f0:	2201      	movs	r2, #1
 811b2f2:	731a      	strb	r2, [r3, #12]
  hpcd_USB_OTG_FS.Init.battery_charging_enable = ENABLE;
 811b2f4:	4b11      	ldr	r3, [pc, #68]	; (811b33c <USBD_LL_Init+0x98>)
 811b2f6:	2201      	movs	r2, #1
 811b2f8:	735a      	strb	r2, [r3, #13]
  hpcd_USB_OTG_FS.Init.vbus_sensing_enable = DISABLE;
 811b2fa:	4b10      	ldr	r3, [pc, #64]	; (811b33c <USBD_LL_Init+0x98>)
 811b2fc:	2200      	movs	r2, #0
 811b2fe:	739a      	strb	r2, [r3, #14]
  hpcd_USB_OTG_FS.Init.use_dedicated_ep1 = DISABLE;
 811b300:	4b0e      	ldr	r3, [pc, #56]	; (811b33c <USBD_LL_Init+0x98>)
 811b302:	2200      	movs	r2, #0
 811b304:	73da      	strb	r2, [r3, #15]
  if (HAL_PCD_Init(&hpcd_USB_OTG_FS) != HAL_OK)
 811b306:	480d      	ldr	r0, [pc, #52]	; (811b33c <USBD_LL_Init+0x98>)
 811b308:	f7ea fa3e 	bl	8105788 <HAL_PCD_Init>
 811b30c:	4603      	mov	r3, r0
 811b30e:	2b00      	cmp	r3, #0
 811b310:	d001      	beq.n	811b316 <USBD_LL_Init+0x72>
  {
    Error_Handler( );
 811b312:	f7e5 fba9 	bl	8100a68 <Error_Handler>
  HAL_PCD_RegisterDataInStageCallback(&hpcd_USB_OTG_FS, PCD_DataInStageCallback);
  HAL_PCD_RegisterIsoOutIncpltCallback(&hpcd_USB_OTG_FS, PCD_ISOOUTIncompleteCallback);
  HAL_PCD_RegisterIsoInIncpltCallback(&hpcd_USB_OTG_FS, PCD_ISOINIncompleteCallback);
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
  /* USER CODE BEGIN TxRx_Configuration */
  HAL_PCDEx_SetRxFiFo(&hpcd_USB_OTG_FS, 0x80);
 811b316:	2180      	movs	r1, #128	; 0x80
 811b318:	4808      	ldr	r0, [pc, #32]	; (811b33c <USBD_LL_Init+0x98>)
 811b31a:	f7eb fc7a 	bl	8106c12 <HAL_PCDEx_SetRxFiFo>
  HAL_PCDEx_SetTxFiFo(&hpcd_USB_OTG_FS, 0, 0x40);
 811b31e:	2240      	movs	r2, #64	; 0x40
 811b320:	2100      	movs	r1, #0
 811b322:	4806      	ldr	r0, [pc, #24]	; (811b33c <USBD_LL_Init+0x98>)
 811b324:	f7eb fc2e 	bl	8106b84 <HAL_PCDEx_SetTxFiFo>
  HAL_PCDEx_SetTxFiFo(&hpcd_USB_OTG_FS, 1, 0x80);
 811b328:	2280      	movs	r2, #128	; 0x80
 811b32a:	2101      	movs	r1, #1
 811b32c:	4803      	ldr	r0, [pc, #12]	; (811b33c <USBD_LL_Init+0x98>)
 811b32e:	f7eb fc29 	bl	8106b84 <HAL_PCDEx_SetTxFiFo>
  /* USER CODE END TxRx_Configuration */
  }
  return USBD_OK;
 811b332:	2300      	movs	r3, #0
}
 811b334:	4618      	mov	r0, r3
 811b336:	3708      	adds	r7, #8
 811b338:	46bd      	mov	sp, r7
 811b33a:	bd80      	pop	{r7, pc}
 811b33c:	10008984 	.word	0x10008984
 811b340:	40080000 	.word	0x40080000

0811b344 <USBD_LL_Start>:
  * @brief  Starts the low level portion of the device driver.
  * @param  pdev: Device handle
  * @retval USBD status
  */
USBD_StatusTypeDef USBD_LL_Start(USBD_HandleTypeDef *pdev)
{
 811b344:	b580      	push	{r7, lr}
 811b346:	b084      	sub	sp, #16
 811b348:	af00      	add	r7, sp, #0
 811b34a:	6078      	str	r0, [r7, #4]
  HAL_StatusTypeDef hal_status = HAL_OK;
 811b34c:	2300      	movs	r3, #0
 811b34e:	73fb      	strb	r3, [r7, #15]
  USBD_StatusTypeDef usb_status = USBD_OK;
 811b350:	2300      	movs	r3, #0
 811b352:	73bb      	strb	r3, [r7, #14]

  hal_status = HAL_PCD_Start(pdev->pData);
 811b354:	687b      	ldr	r3, [r7, #4]
 811b356:	f8d3 32c8 	ldr.w	r3, [r3, #712]	; 0x2c8
 811b35a:	4618      	mov	r0, r3
 811b35c:	f7ea fb20 	bl	81059a0 <HAL_PCD_Start>
 811b360:	4603      	mov	r3, r0
 811b362:	73fb      	strb	r3, [r7, #15]

  usb_status =  USBD_Get_USB_Status(hal_status);
 811b364:	7bfb      	ldrb	r3, [r7, #15]
 811b366:	4618      	mov	r0, r3
 811b368:	f000 f930 	bl	811b5cc <USBD_Get_USB_Status>
 811b36c:	4603      	mov	r3, r0
 811b36e:	73bb      	strb	r3, [r7, #14]

  return usb_status;
 811b370:	7bbb      	ldrb	r3, [r7, #14]
}
 811b372:	4618      	mov	r0, r3
 811b374:	3710      	adds	r7, #16
 811b376:	46bd      	mov	sp, r7
 811b378:	bd80      	pop	{r7, pc}

0811b37a <USBD_LL_OpenEP>:
  * @param  ep_type: Endpoint type
  * @param  ep_mps: Endpoint max packet size
  * @retval USBD status
  */
USBD_StatusTypeDef USBD_LL_OpenEP(USBD_HandleTypeDef *pdev, uint8_t ep_addr, uint8_t ep_type, uint16_t ep_mps)
{
 811b37a:	b580      	push	{r7, lr}
 811b37c:	b084      	sub	sp, #16
 811b37e:	af00      	add	r7, sp, #0
 811b380:	6078      	str	r0, [r7, #4]
 811b382:	4608      	mov	r0, r1
 811b384:	4611      	mov	r1, r2
 811b386:	461a      	mov	r2, r3
 811b388:	4603      	mov	r3, r0
 811b38a:	70fb      	strb	r3, [r7, #3]
 811b38c:	460b      	mov	r3, r1
 811b38e:	70bb      	strb	r3, [r7, #2]
 811b390:	4613      	mov	r3, r2
 811b392:	803b      	strh	r3, [r7, #0]
  HAL_StatusTypeDef hal_status = HAL_OK;
 811b394:	2300      	movs	r3, #0
 811b396:	73fb      	strb	r3, [r7, #15]
  USBD_StatusTypeDef usb_status = USBD_OK;
 811b398:	2300      	movs	r3, #0
 811b39a:	73bb      	strb	r3, [r7, #14]

  hal_status = HAL_PCD_EP_Open(pdev->pData, ep_addr, ep_mps, ep_type);
 811b39c:	687b      	ldr	r3, [r7, #4]
 811b39e:	f8d3 02c8 	ldr.w	r0, [r3, #712]	; 0x2c8
 811b3a2:	78bb      	ldrb	r3, [r7, #2]
 811b3a4:	883a      	ldrh	r2, [r7, #0]
 811b3a6:	78f9      	ldrb	r1, [r7, #3]
 811b3a8:	f7eb f821 	bl	81063ee <HAL_PCD_EP_Open>
 811b3ac:	4603      	mov	r3, r0
 811b3ae:	73fb      	strb	r3, [r7, #15]

  usb_status =  USBD_Get_USB_Status(hal_status);
 811b3b0:	7bfb      	ldrb	r3, [r7, #15]
 811b3b2:	4618      	mov	r0, r3
 811b3b4:	f000 f90a 	bl	811b5cc <USBD_Get_USB_Status>
 811b3b8:	4603      	mov	r3, r0
 811b3ba:	73bb      	strb	r3, [r7, #14]

  return usb_status;
 811b3bc:	7bbb      	ldrb	r3, [r7, #14]
}
 811b3be:	4618      	mov	r0, r3
 811b3c0:	3710      	adds	r7, #16
 811b3c2:	46bd      	mov	sp, r7
 811b3c4:	bd80      	pop	{r7, pc}

0811b3c6 <USBD_LL_CloseEP>:
  * @param  pdev: Device handle
  * @param  ep_addr: Endpoint number
  * @retval USBD status
  */
USBD_StatusTypeDef USBD_LL_CloseEP(USBD_HandleTypeDef *pdev, uint8_t ep_addr)
{
 811b3c6:	b580      	push	{r7, lr}
 811b3c8:	b084      	sub	sp, #16
 811b3ca:	af00      	add	r7, sp, #0
 811b3cc:	6078      	str	r0, [r7, #4]
 811b3ce:	460b      	mov	r3, r1
 811b3d0:	70fb      	strb	r3, [r7, #3]
  HAL_StatusTypeDef hal_status = HAL_OK;
 811b3d2:	2300      	movs	r3, #0
 811b3d4:	73fb      	strb	r3, [r7, #15]
  USBD_StatusTypeDef usb_status = USBD_OK;
 811b3d6:	2300      	movs	r3, #0
 811b3d8:	73bb      	strb	r3, [r7, #14]

  hal_status = HAL_PCD_EP_Close(pdev->pData, ep_addr);
 811b3da:	687b      	ldr	r3, [r7, #4]
 811b3dc:	f8d3 32c8 	ldr.w	r3, [r3, #712]	; 0x2c8
 811b3e0:	78fa      	ldrb	r2, [r7, #3]
 811b3e2:	4611      	mov	r1, r2
 811b3e4:	4618      	mov	r0, r3
 811b3e6:	f7eb f86a 	bl	81064be <HAL_PCD_EP_Close>
 811b3ea:	4603      	mov	r3, r0
 811b3ec:	73fb      	strb	r3, [r7, #15]

  usb_status =  USBD_Get_USB_Status(hal_status);
 811b3ee:	7bfb      	ldrb	r3, [r7, #15]
 811b3f0:	4618      	mov	r0, r3
 811b3f2:	f000 f8eb 	bl	811b5cc <USBD_Get_USB_Status>
 811b3f6:	4603      	mov	r3, r0
 811b3f8:	73bb      	strb	r3, [r7, #14]

  return usb_status;
 811b3fa:	7bbb      	ldrb	r3, [r7, #14]
}
 811b3fc:	4618      	mov	r0, r3
 811b3fe:	3710      	adds	r7, #16
 811b400:	46bd      	mov	sp, r7
 811b402:	bd80      	pop	{r7, pc}

0811b404 <USBD_LL_StallEP>:
  * @param  pdev: Device handle
  * @param  ep_addr: Endpoint number
  * @retval USBD status
  */
USBD_StatusTypeDef USBD_LL_StallEP(USBD_HandleTypeDef *pdev, uint8_t ep_addr)
{
 811b404:	b580      	push	{r7, lr}
 811b406:	b084      	sub	sp, #16
 811b408:	af00      	add	r7, sp, #0
 811b40a:	6078      	str	r0, [r7, #4]
 811b40c:	460b      	mov	r3, r1
 811b40e:	70fb      	strb	r3, [r7, #3]
  HAL_StatusTypeDef hal_status = HAL_OK;
 811b410:	2300      	movs	r3, #0
 811b412:	73fb      	strb	r3, [r7, #15]
  USBD_StatusTypeDef usb_status = USBD_OK;
 811b414:	2300      	movs	r3, #0
 811b416:	73bb      	strb	r3, [r7, #14]

  hal_status = HAL_PCD_EP_SetStall(pdev->pData, ep_addr);
 811b418:	687b      	ldr	r3, [r7, #4]
 811b41a:	f8d3 32c8 	ldr.w	r3, [r3, #712]	; 0x2c8
 811b41e:	78fa      	ldrb	r2, [r7, #3]
 811b420:	4611      	mov	r1, r2
 811b422:	4618      	mov	r0, r3
 811b424:	f7eb f90a 	bl	810663c <HAL_PCD_EP_SetStall>
 811b428:	4603      	mov	r3, r0
 811b42a:	73fb      	strb	r3, [r7, #15]

  usb_status =  USBD_Get_USB_Status(hal_status);
 811b42c:	7bfb      	ldrb	r3, [r7, #15]
 811b42e:	4618      	mov	r0, r3
 811b430:	f000 f8cc 	bl	811b5cc <USBD_Get_USB_Status>
 811b434:	4603      	mov	r3, r0
 811b436:	73bb      	strb	r3, [r7, #14]

  return usb_status;
 811b438:	7bbb      	ldrb	r3, [r7, #14]
}
 811b43a:	4618      	mov	r0, r3
 811b43c:	3710      	adds	r7, #16
 811b43e:	46bd      	mov	sp, r7
 811b440:	bd80      	pop	{r7, pc}

0811b442 <USBD_LL_ClearStallEP>:
  * @param  pdev: Device handle
  * @param  ep_addr: Endpoint number
  * @retval USBD status
  */
USBD_StatusTypeDef USBD_LL_ClearStallEP(USBD_HandleTypeDef *pdev, uint8_t ep_addr)
{
 811b442:	b580      	push	{r7, lr}
 811b444:	b084      	sub	sp, #16
 811b446:	af00      	add	r7, sp, #0
 811b448:	6078      	str	r0, [r7, #4]
 811b44a:	460b      	mov	r3, r1
 811b44c:	70fb      	strb	r3, [r7, #3]
  HAL_StatusTypeDef hal_status = HAL_OK;
 811b44e:	2300      	movs	r3, #0
 811b450:	73fb      	strb	r3, [r7, #15]
  USBD_StatusTypeDef usb_status = USBD_OK;
 811b452:	2300      	movs	r3, #0
 811b454:	73bb      	strb	r3, [r7, #14]

  hal_status = HAL_PCD_EP_ClrStall(pdev->pData, ep_addr);
 811b456:	687b      	ldr	r3, [r7, #4]
 811b458:	f8d3 32c8 	ldr.w	r3, [r3, #712]	; 0x2c8
 811b45c:	78fa      	ldrb	r2, [r7, #3]
 811b45e:	4611      	mov	r1, r2
 811b460:	4618      	mov	r0, r3
 811b462:	f7eb f94e 	bl	8106702 <HAL_PCD_EP_ClrStall>
 811b466:	4603      	mov	r3, r0
 811b468:	73fb      	strb	r3, [r7, #15]

  usb_status =  USBD_Get_USB_Status(hal_status);
 811b46a:	7bfb      	ldrb	r3, [r7, #15]
 811b46c:	4618      	mov	r0, r3
 811b46e:	f000 f8ad 	bl	811b5cc <USBD_Get_USB_Status>
 811b472:	4603      	mov	r3, r0
 811b474:	73bb      	strb	r3, [r7, #14]

  return usb_status;
 811b476:	7bbb      	ldrb	r3, [r7, #14]
}
 811b478:	4618      	mov	r0, r3
 811b47a:	3710      	adds	r7, #16
 811b47c:	46bd      	mov	sp, r7
 811b47e:	bd80      	pop	{r7, pc}

0811b480 <USBD_LL_IsStallEP>:
  * @param  pdev: Device handle
  * @param  ep_addr: Endpoint number
  * @retval Stall (1: Yes, 0: No)
  */
uint8_t USBD_LL_IsStallEP(USBD_HandleTypeDef *pdev, uint8_t ep_addr)
{
 811b480:	b480      	push	{r7}
 811b482:	b085      	sub	sp, #20
 811b484:	af00      	add	r7, sp, #0
 811b486:	6078      	str	r0, [r7, #4]
 811b488:	460b      	mov	r3, r1
 811b48a:	70fb      	strb	r3, [r7, #3]
  PCD_HandleTypeDef *hpcd = (PCD_HandleTypeDef*) pdev->pData;
 811b48c:	687b      	ldr	r3, [r7, #4]
 811b48e:	f8d3 32c8 	ldr.w	r3, [r3, #712]	; 0x2c8
 811b492:	60fb      	str	r3, [r7, #12]

  if((ep_addr & 0x80) == 0x80)
 811b494:	f997 3003 	ldrsb.w	r3, [r7, #3]
 811b498:	2b00      	cmp	r3, #0
 811b49a:	da0b      	bge.n	811b4b4 <USBD_LL_IsStallEP+0x34>
  {
    return hpcd->IN_ep[ep_addr & 0x7F].is_stall;
 811b49c:	78fb      	ldrb	r3, [r7, #3]
 811b49e:	f003 027f 	and.w	r2, r3, #127	; 0x7f
 811b4a2:	68f9      	ldr	r1, [r7, #12]
 811b4a4:	4613      	mov	r3, r2
 811b4a6:	00db      	lsls	r3, r3, #3
 811b4a8:	4413      	add	r3, r2
 811b4aa:	009b      	lsls	r3, r3, #2
 811b4ac:	440b      	add	r3, r1
 811b4ae:	3316      	adds	r3, #22
 811b4b0:	781b      	ldrb	r3, [r3, #0]
 811b4b2:	e00b      	b.n	811b4cc <USBD_LL_IsStallEP+0x4c>
  }
  else
  {
    return hpcd->OUT_ep[ep_addr & 0x7F].is_stall;
 811b4b4:	78fb      	ldrb	r3, [r7, #3]
 811b4b6:	f003 027f 	and.w	r2, r3, #127	; 0x7f
 811b4ba:	68f9      	ldr	r1, [r7, #12]
 811b4bc:	4613      	mov	r3, r2
 811b4be:	00db      	lsls	r3, r3, #3
 811b4c0:	4413      	add	r3, r2
 811b4c2:	009b      	lsls	r3, r3, #2
 811b4c4:	440b      	add	r3, r1
 811b4c6:	f203 2356 	addw	r3, r3, #598	; 0x256
 811b4ca:	781b      	ldrb	r3, [r3, #0]
  }
}
 811b4cc:	4618      	mov	r0, r3
 811b4ce:	3714      	adds	r7, #20
 811b4d0:	46bd      	mov	sp, r7
 811b4d2:	f85d 7b04 	ldr.w	r7, [sp], #4
 811b4d6:	4770      	bx	lr

0811b4d8 <USBD_LL_SetUSBAddress>:
  * @param  pdev: Device handle
  * @param  dev_addr: Device address
  * @retval USBD status
  */
USBD_StatusTypeDef USBD_LL_SetUSBAddress(USBD_HandleTypeDef *pdev, uint8_t dev_addr)
{
 811b4d8:	b580      	push	{r7, lr}
 811b4da:	b084      	sub	sp, #16
 811b4dc:	af00      	add	r7, sp, #0
 811b4de:	6078      	str	r0, [r7, #4]
 811b4e0:	460b      	mov	r3, r1
 811b4e2:	70fb      	strb	r3, [r7, #3]
  HAL_StatusTypeDef hal_status = HAL_OK;
 811b4e4:	2300      	movs	r3, #0
 811b4e6:	73fb      	strb	r3, [r7, #15]
  USBD_StatusTypeDef usb_status = USBD_OK;
 811b4e8:	2300      	movs	r3, #0
 811b4ea:	73bb      	strb	r3, [r7, #14]

  hal_status = HAL_PCD_SetAddress(pdev->pData, dev_addr);
 811b4ec:	687b      	ldr	r3, [r7, #4]
 811b4ee:	f8d3 32c8 	ldr.w	r3, [r3, #712]	; 0x2c8
 811b4f2:	78fa      	ldrb	r2, [r7, #3]
 811b4f4:	4611      	mov	r1, r2
 811b4f6:	4618      	mov	r0, r3
 811b4f8:	f7ea ff55 	bl	81063a6 <HAL_PCD_SetAddress>
 811b4fc:	4603      	mov	r3, r0
 811b4fe:	73fb      	strb	r3, [r7, #15]

  usb_status =  USBD_Get_USB_Status(hal_status);
 811b500:	7bfb      	ldrb	r3, [r7, #15]
 811b502:	4618      	mov	r0, r3
 811b504:	f000 f862 	bl	811b5cc <USBD_Get_USB_Status>
 811b508:	4603      	mov	r3, r0
 811b50a:	73bb      	strb	r3, [r7, #14]

  return usb_status;
 811b50c:	7bbb      	ldrb	r3, [r7, #14]
}
 811b50e:	4618      	mov	r0, r3
 811b510:	3710      	adds	r7, #16
 811b512:	46bd      	mov	sp, r7
 811b514:	bd80      	pop	{r7, pc}

0811b516 <USBD_LL_Transmit>:
  * @param  pbuf: Pointer to data to be sent
  * @param  size: Data size
  * @retval USBD status
  */
USBD_StatusTypeDef USBD_LL_Transmit(USBD_HandleTypeDef *pdev, uint8_t ep_addr, uint8_t *pbuf, uint32_t size)
{
 811b516:	b580      	push	{r7, lr}
 811b518:	b086      	sub	sp, #24
 811b51a:	af00      	add	r7, sp, #0
 811b51c:	60f8      	str	r0, [r7, #12]
 811b51e:	607a      	str	r2, [r7, #4]
 811b520:	603b      	str	r3, [r7, #0]
 811b522:	460b      	mov	r3, r1
 811b524:	72fb      	strb	r3, [r7, #11]
  HAL_StatusTypeDef hal_status = HAL_OK;
 811b526:	2300      	movs	r3, #0
 811b528:	75fb      	strb	r3, [r7, #23]
  USBD_StatusTypeDef usb_status = USBD_OK;
 811b52a:	2300      	movs	r3, #0
 811b52c:	75bb      	strb	r3, [r7, #22]

  hal_status = HAL_PCD_EP_Transmit(pdev->pData, ep_addr, pbuf, size);
 811b52e:	68fb      	ldr	r3, [r7, #12]
 811b530:	f8d3 02c8 	ldr.w	r0, [r3, #712]	; 0x2c8
 811b534:	7af9      	ldrb	r1, [r7, #11]
 811b536:	683b      	ldr	r3, [r7, #0]
 811b538:	687a      	ldr	r2, [r7, #4]
 811b53a:	f7eb f845 	bl	81065c8 <HAL_PCD_EP_Transmit>
 811b53e:	4603      	mov	r3, r0
 811b540:	75fb      	strb	r3, [r7, #23]

  usb_status =  USBD_Get_USB_Status(hal_status);
 811b542:	7dfb      	ldrb	r3, [r7, #23]
 811b544:	4618      	mov	r0, r3
 811b546:	f000 f841 	bl	811b5cc <USBD_Get_USB_Status>
 811b54a:	4603      	mov	r3, r0
 811b54c:	75bb      	strb	r3, [r7, #22]

  return usb_status;
 811b54e:	7dbb      	ldrb	r3, [r7, #22]
}
 811b550:	4618      	mov	r0, r3
 811b552:	3718      	adds	r7, #24
 811b554:	46bd      	mov	sp, r7
 811b556:	bd80      	pop	{r7, pc}

0811b558 <USBD_LL_PrepareReceive>:
  * @param  pbuf: Pointer to data to be received
  * @param  size: Data size
  * @retval USBD status
  */
USBD_StatusTypeDef USBD_LL_PrepareReceive(USBD_HandleTypeDef *pdev, uint8_t ep_addr, uint8_t *pbuf, uint32_t size)
{
 811b558:	b580      	push	{r7, lr}
 811b55a:	b086      	sub	sp, #24
 811b55c:	af00      	add	r7, sp, #0
 811b55e:	60f8      	str	r0, [r7, #12]
 811b560:	607a      	str	r2, [r7, #4]
 811b562:	603b      	str	r3, [r7, #0]
 811b564:	460b      	mov	r3, r1
 811b566:	72fb      	strb	r3, [r7, #11]
  HAL_StatusTypeDef hal_status = HAL_OK;
 811b568:	2300      	movs	r3, #0
 811b56a:	75fb      	strb	r3, [r7, #23]
  USBD_StatusTypeDef usb_status = USBD_OK;
 811b56c:	2300      	movs	r3, #0
 811b56e:	75bb      	strb	r3, [r7, #22]

  hal_status = HAL_PCD_EP_Receive(pdev->pData, ep_addr, pbuf, size);
 811b570:	68fb      	ldr	r3, [r7, #12]
 811b572:	f8d3 02c8 	ldr.w	r0, [r3, #712]	; 0x2c8
 811b576:	7af9      	ldrb	r1, [r7, #11]
 811b578:	683b      	ldr	r3, [r7, #0]
 811b57a:	687a      	ldr	r2, [r7, #4]
 811b57c:	f7ea ffe9 	bl	8106552 <HAL_PCD_EP_Receive>
 811b580:	4603      	mov	r3, r0
 811b582:	75fb      	strb	r3, [r7, #23]

  usb_status =  USBD_Get_USB_Status(hal_status);
 811b584:	7dfb      	ldrb	r3, [r7, #23]
 811b586:	4618      	mov	r0, r3
 811b588:	f000 f820 	bl	811b5cc <USBD_Get_USB_Status>
 811b58c:	4603      	mov	r3, r0
 811b58e:	75bb      	strb	r3, [r7, #22]

  return usb_status;
 811b590:	7dbb      	ldrb	r3, [r7, #22]
}
 811b592:	4618      	mov	r0, r3
 811b594:	3718      	adds	r7, #24
 811b596:	46bd      	mov	sp, r7
 811b598:	bd80      	pop	{r7, pc}
	...

0811b59c <USBD_static_malloc>:
  * @brief  Static single allocation.
  * @param  size: Size of allocated memory
  * @retval None
  */
void *USBD_static_malloc(uint32_t size)
{
 811b59c:	b480      	push	{r7}
 811b59e:	b083      	sub	sp, #12
 811b5a0:	af00      	add	r7, sp, #0
 811b5a2:	6078      	str	r0, [r7, #4]
  UNUSED(size);
  static uint32_t mem[(sizeof(USBD_HID_HandleTypeDef)/4)+1];/* On 32-bit boundary */
  return mem;
 811b5a4:	4b03      	ldr	r3, [pc, #12]	; (811b5b4 <USBD_static_malloc+0x18>)
}
 811b5a6:	4618      	mov	r0, r3
 811b5a8:	370c      	adds	r7, #12
 811b5aa:	46bd      	mov	sp, r7
 811b5ac:	f85d 7b04 	ldr.w	r7, [sp], #4
 811b5b0:	4770      	bx	lr
 811b5b2:	bf00      	nop
 811b5b4:	10008e68 	.word	0x10008e68

0811b5b8 <USBD_static_free>:
  * @brief  Dummy memory free
  * @param  p: Pointer to allocated  memory address
  * @retval None
  */
void USBD_static_free(void *p)
{
 811b5b8:	b480      	push	{r7}
 811b5ba:	b083      	sub	sp, #12
 811b5bc:	af00      	add	r7, sp, #0
 811b5be:	6078      	str	r0, [r7, #4]
  UNUSED(p);
}
 811b5c0:	bf00      	nop
 811b5c2:	370c      	adds	r7, #12
 811b5c4:	46bd      	mov	sp, r7
 811b5c6:	f85d 7b04 	ldr.w	r7, [sp], #4
 811b5ca:	4770      	bx	lr

0811b5cc <USBD_Get_USB_Status>:
  * @brief  Returns the USB status depending on the HAL status:
  * @param  hal_status: HAL status
  * @retval USB status
  */
USBD_StatusTypeDef USBD_Get_USB_Status(HAL_StatusTypeDef hal_status)
{
 811b5cc:	b480      	push	{r7}
 811b5ce:	b085      	sub	sp, #20
 811b5d0:	af00      	add	r7, sp, #0
 811b5d2:	4603      	mov	r3, r0
 811b5d4:	71fb      	strb	r3, [r7, #7]
  USBD_StatusTypeDef usb_status = USBD_OK;
 811b5d6:	2300      	movs	r3, #0
 811b5d8:	73fb      	strb	r3, [r7, #15]

  switch (hal_status)
 811b5da:	79fb      	ldrb	r3, [r7, #7]
 811b5dc:	2b03      	cmp	r3, #3
 811b5de:	d817      	bhi.n	811b610 <USBD_Get_USB_Status+0x44>
 811b5e0:	a201      	add	r2, pc, #4	; (adr r2, 811b5e8 <USBD_Get_USB_Status+0x1c>)
 811b5e2:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 811b5e6:	bf00      	nop
 811b5e8:	0811b5f9 	.word	0x0811b5f9
 811b5ec:	0811b5ff 	.word	0x0811b5ff
 811b5f0:	0811b605 	.word	0x0811b605
 811b5f4:	0811b60b 	.word	0x0811b60b
  {
    case HAL_OK :
      usb_status = USBD_OK;
 811b5f8:	2300      	movs	r3, #0
 811b5fa:	73fb      	strb	r3, [r7, #15]
    break;
 811b5fc:	e00b      	b.n	811b616 <USBD_Get_USB_Status+0x4a>
    case HAL_ERROR :
      usb_status = USBD_FAIL;
 811b5fe:	2303      	movs	r3, #3
 811b600:	73fb      	strb	r3, [r7, #15]
    break;
 811b602:	e008      	b.n	811b616 <USBD_Get_USB_Status+0x4a>
    case HAL_BUSY :
      usb_status = USBD_BUSY;
 811b604:	2301      	movs	r3, #1
 811b606:	73fb      	strb	r3, [r7, #15]
    break;
 811b608:	e005      	b.n	811b616 <USBD_Get_USB_Status+0x4a>
    case HAL_TIMEOUT :
      usb_status = USBD_FAIL;
 811b60a:	2303      	movs	r3, #3
 811b60c:	73fb      	strb	r3, [r7, #15]
    break;
 811b60e:	e002      	b.n	811b616 <USBD_Get_USB_Status+0x4a>
    default :
      usb_status = USBD_FAIL;
 811b610:	2303      	movs	r3, #3
 811b612:	73fb      	strb	r3, [r7, #15]
    break;
 811b614:	bf00      	nop
  }
  return usb_status;
 811b616:	7bfb      	ldrb	r3, [r7, #15]
}
 811b618:	4618      	mov	r0, r3
 811b61a:	3714      	adds	r7, #20
 811b61c:	46bd      	mov	sp, r7
 811b61e:	f85d 7b04 	ldr.w	r7, [sp], #4
 811b622:	4770      	bx	lr

0811b624 <rand>:
 811b624:	4b16      	ldr	r3, [pc, #88]	; (811b680 <rand+0x5c>)
 811b626:	b510      	push	{r4, lr}
 811b628:	681c      	ldr	r4, [r3, #0]
 811b62a:	6b23      	ldr	r3, [r4, #48]	; 0x30
 811b62c:	b9b3      	cbnz	r3, 811b65c <rand+0x38>
 811b62e:	2018      	movs	r0, #24
 811b630:	f000 fafa 	bl	811bc28 <malloc>
 811b634:	4602      	mov	r2, r0
 811b636:	6320      	str	r0, [r4, #48]	; 0x30
 811b638:	b920      	cbnz	r0, 811b644 <rand+0x20>
 811b63a:	4b12      	ldr	r3, [pc, #72]	; (811b684 <rand+0x60>)
 811b63c:	4812      	ldr	r0, [pc, #72]	; (811b688 <rand+0x64>)
 811b63e:	2152      	movs	r1, #82	; 0x52
 811b640:	f000 f944 	bl	811b8cc <__assert_func>
 811b644:	4911      	ldr	r1, [pc, #68]	; (811b68c <rand+0x68>)
 811b646:	4b12      	ldr	r3, [pc, #72]	; (811b690 <rand+0x6c>)
 811b648:	e9c0 1300 	strd	r1, r3, [r0]
 811b64c:	4b11      	ldr	r3, [pc, #68]	; (811b694 <rand+0x70>)
 811b64e:	6083      	str	r3, [r0, #8]
 811b650:	230b      	movs	r3, #11
 811b652:	8183      	strh	r3, [r0, #12]
 811b654:	2100      	movs	r1, #0
 811b656:	2001      	movs	r0, #1
 811b658:	e9c2 0104 	strd	r0, r1, [r2, #16]
 811b65c:	6b21      	ldr	r1, [r4, #48]	; 0x30
 811b65e:	480e      	ldr	r0, [pc, #56]	; (811b698 <rand+0x74>)
 811b660:	690b      	ldr	r3, [r1, #16]
 811b662:	694c      	ldr	r4, [r1, #20]
 811b664:	4a0d      	ldr	r2, [pc, #52]	; (811b69c <rand+0x78>)
 811b666:	4358      	muls	r0, r3
 811b668:	fb02 0004 	mla	r0, r2, r4, r0
 811b66c:	fba3 3202 	umull	r3, r2, r3, r2
 811b670:	3301      	adds	r3, #1
 811b672:	eb40 0002 	adc.w	r0, r0, r2
 811b676:	e9c1 3004 	strd	r3, r0, [r1, #16]
 811b67a:	f020 4000 	bic.w	r0, r0, #2147483648	; 0x80000000
 811b67e:	bd10      	pop	{r4, pc}
 811b680:	100001bc 	.word	0x100001bc
 811b684:	0811fa24 	.word	0x0811fa24
 811b688:	0811fa3b 	.word	0x0811fa3b
 811b68c:	abcd330e 	.word	0xabcd330e
 811b690:	e66d1234 	.word	0xe66d1234
 811b694:	0005deec 	.word	0x0005deec
 811b698:	5851f42d 	.word	0x5851f42d
 811b69c:	4c957f2d 	.word	0x4c957f2d

0811b6a0 <std>:
 811b6a0:	2300      	movs	r3, #0
 811b6a2:	b510      	push	{r4, lr}
 811b6a4:	4604      	mov	r4, r0
 811b6a6:	e9c0 3300 	strd	r3, r3, [r0]
 811b6aa:	e9c0 3304 	strd	r3, r3, [r0, #16]
 811b6ae:	6083      	str	r3, [r0, #8]
 811b6b0:	8181      	strh	r1, [r0, #12]
 811b6b2:	6643      	str	r3, [r0, #100]	; 0x64
 811b6b4:	81c2      	strh	r2, [r0, #14]
 811b6b6:	6183      	str	r3, [r0, #24]
 811b6b8:	4619      	mov	r1, r3
 811b6ba:	2208      	movs	r2, #8
 811b6bc:	305c      	adds	r0, #92	; 0x5c
 811b6be:	f000 f8c9 	bl	811b854 <memset>
 811b6c2:	4b05      	ldr	r3, [pc, #20]	; (811b6d8 <std+0x38>)
 811b6c4:	6263      	str	r3, [r4, #36]	; 0x24
 811b6c6:	4b05      	ldr	r3, [pc, #20]	; (811b6dc <std+0x3c>)
 811b6c8:	62a3      	str	r3, [r4, #40]	; 0x28
 811b6ca:	4b05      	ldr	r3, [pc, #20]	; (811b6e0 <std+0x40>)
 811b6cc:	62e3      	str	r3, [r4, #44]	; 0x2c
 811b6ce:	4b05      	ldr	r3, [pc, #20]	; (811b6e4 <std+0x44>)
 811b6d0:	6224      	str	r4, [r4, #32]
 811b6d2:	6323      	str	r3, [r4, #48]	; 0x30
 811b6d4:	bd10      	pop	{r4, pc}
 811b6d6:	bf00      	nop
 811b6d8:	0811c20d 	.word	0x0811c20d
 811b6dc:	0811c22f 	.word	0x0811c22f
 811b6e0:	0811c267 	.word	0x0811c267
 811b6e4:	0811c28b 	.word	0x0811c28b

0811b6e8 <stdio_exit_handler>:
 811b6e8:	4a02      	ldr	r2, [pc, #8]	; (811b6f4 <stdio_exit_handler+0xc>)
 811b6ea:	4903      	ldr	r1, [pc, #12]	; (811b6f8 <stdio_exit_handler+0x10>)
 811b6ec:	4803      	ldr	r0, [pc, #12]	; (811b6fc <stdio_exit_handler+0x14>)
 811b6ee:	f000 b869 	b.w	811b7c4 <_fwalk_sglue>
 811b6f2:	bf00      	nop
 811b6f4:	10000164 	.word	0x10000164
 811b6f8:	0811c1a5 	.word	0x0811c1a5
 811b6fc:	10000170 	.word	0x10000170

0811b700 <cleanup_stdio>:
 811b700:	6841      	ldr	r1, [r0, #4]
 811b702:	4b0c      	ldr	r3, [pc, #48]	; (811b734 <cleanup_stdio+0x34>)
 811b704:	4299      	cmp	r1, r3
 811b706:	b510      	push	{r4, lr}
 811b708:	4604      	mov	r4, r0
 811b70a:	d001      	beq.n	811b710 <cleanup_stdio+0x10>
 811b70c:	f000 fd4a 	bl	811c1a4 <_fflush_r>
 811b710:	68a1      	ldr	r1, [r4, #8]
 811b712:	4b09      	ldr	r3, [pc, #36]	; (811b738 <cleanup_stdio+0x38>)
 811b714:	4299      	cmp	r1, r3
 811b716:	d002      	beq.n	811b71e <cleanup_stdio+0x1e>
 811b718:	4620      	mov	r0, r4
 811b71a:	f000 fd43 	bl	811c1a4 <_fflush_r>
 811b71e:	68e1      	ldr	r1, [r4, #12]
 811b720:	4b06      	ldr	r3, [pc, #24]	; (811b73c <cleanup_stdio+0x3c>)
 811b722:	4299      	cmp	r1, r3
 811b724:	d004      	beq.n	811b730 <cleanup_stdio+0x30>
 811b726:	4620      	mov	r0, r4
 811b728:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 811b72c:	f000 bd3a 	b.w	811c1a4 <_fflush_r>
 811b730:	bd10      	pop	{r4, pc}
 811b732:	bf00      	nop
 811b734:	10008e7c 	.word	0x10008e7c
 811b738:	10008ee4 	.word	0x10008ee4
 811b73c:	10008f4c 	.word	0x10008f4c

0811b740 <global_stdio_init.part.0>:
 811b740:	b510      	push	{r4, lr}
 811b742:	4b0b      	ldr	r3, [pc, #44]	; (811b770 <global_stdio_init.part.0+0x30>)
 811b744:	4c0b      	ldr	r4, [pc, #44]	; (811b774 <global_stdio_init.part.0+0x34>)
 811b746:	4a0c      	ldr	r2, [pc, #48]	; (811b778 <global_stdio_init.part.0+0x38>)
 811b748:	601a      	str	r2, [r3, #0]
 811b74a:	4620      	mov	r0, r4
 811b74c:	2200      	movs	r2, #0
 811b74e:	2104      	movs	r1, #4
 811b750:	f7ff ffa6 	bl	811b6a0 <std>
 811b754:	f104 0068 	add.w	r0, r4, #104	; 0x68
 811b758:	2201      	movs	r2, #1
 811b75a:	2109      	movs	r1, #9
 811b75c:	f7ff ffa0 	bl	811b6a0 <std>
 811b760:	f104 00d0 	add.w	r0, r4, #208	; 0xd0
 811b764:	2202      	movs	r2, #2
 811b766:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 811b76a:	2112      	movs	r1, #18
 811b76c:	f7ff bf98 	b.w	811b6a0 <std>
 811b770:	10008fb4 	.word	0x10008fb4
 811b774:	10008e7c 	.word	0x10008e7c
 811b778:	0811b6e9 	.word	0x0811b6e9

0811b77c <__sfp_lock_acquire>:
 811b77c:	4801      	ldr	r0, [pc, #4]	; (811b784 <__sfp_lock_acquire+0x8>)
 811b77e:	f000 b895 	b.w	811b8ac <__retarget_lock_acquire_recursive>
 811b782:	bf00      	nop
 811b784:	10008fbd 	.word	0x10008fbd

0811b788 <__sfp_lock_release>:
 811b788:	4801      	ldr	r0, [pc, #4]	; (811b790 <__sfp_lock_release+0x8>)
 811b78a:	f000 b890 	b.w	811b8ae <__retarget_lock_release_recursive>
 811b78e:	bf00      	nop
 811b790:	10008fbd 	.word	0x10008fbd

0811b794 <__sinit>:
 811b794:	b510      	push	{r4, lr}
 811b796:	4604      	mov	r4, r0
 811b798:	f7ff fff0 	bl	811b77c <__sfp_lock_acquire>
 811b79c:	6a23      	ldr	r3, [r4, #32]
 811b79e:	b11b      	cbz	r3, 811b7a8 <__sinit+0x14>
 811b7a0:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 811b7a4:	f7ff bff0 	b.w	811b788 <__sfp_lock_release>
 811b7a8:	4b04      	ldr	r3, [pc, #16]	; (811b7bc <__sinit+0x28>)
 811b7aa:	6223      	str	r3, [r4, #32]
 811b7ac:	4b04      	ldr	r3, [pc, #16]	; (811b7c0 <__sinit+0x2c>)
 811b7ae:	681b      	ldr	r3, [r3, #0]
 811b7b0:	2b00      	cmp	r3, #0
 811b7b2:	d1f5      	bne.n	811b7a0 <__sinit+0xc>
 811b7b4:	f7ff ffc4 	bl	811b740 <global_stdio_init.part.0>
 811b7b8:	e7f2      	b.n	811b7a0 <__sinit+0xc>
 811b7ba:	bf00      	nop
 811b7bc:	0811b701 	.word	0x0811b701
 811b7c0:	10008fb4 	.word	0x10008fb4

0811b7c4 <_fwalk_sglue>:
 811b7c4:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 811b7c8:	4607      	mov	r7, r0
 811b7ca:	4688      	mov	r8, r1
 811b7cc:	4614      	mov	r4, r2
 811b7ce:	2600      	movs	r6, #0
 811b7d0:	e9d4 9501 	ldrd	r9, r5, [r4, #4]
 811b7d4:	f1b9 0901 	subs.w	r9, r9, #1
 811b7d8:	d505      	bpl.n	811b7e6 <_fwalk_sglue+0x22>
 811b7da:	6824      	ldr	r4, [r4, #0]
 811b7dc:	2c00      	cmp	r4, #0
 811b7de:	d1f7      	bne.n	811b7d0 <_fwalk_sglue+0xc>
 811b7e0:	4630      	mov	r0, r6
 811b7e2:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 811b7e6:	89ab      	ldrh	r3, [r5, #12]
 811b7e8:	2b01      	cmp	r3, #1
 811b7ea:	d907      	bls.n	811b7fc <_fwalk_sglue+0x38>
 811b7ec:	f9b5 300e 	ldrsh.w	r3, [r5, #14]
 811b7f0:	3301      	adds	r3, #1
 811b7f2:	d003      	beq.n	811b7fc <_fwalk_sglue+0x38>
 811b7f4:	4629      	mov	r1, r5
 811b7f6:	4638      	mov	r0, r7
 811b7f8:	47c0      	blx	r8
 811b7fa:	4306      	orrs	r6, r0
 811b7fc:	3568      	adds	r5, #104	; 0x68
 811b7fe:	e7e9      	b.n	811b7d4 <_fwalk_sglue+0x10>

0811b800 <iprintf>:
 811b800:	b40f      	push	{r0, r1, r2, r3}
 811b802:	b507      	push	{r0, r1, r2, lr}
 811b804:	4906      	ldr	r1, [pc, #24]	; (811b820 <iprintf+0x20>)
 811b806:	ab04      	add	r3, sp, #16
 811b808:	6808      	ldr	r0, [r1, #0]
 811b80a:	f853 2b04 	ldr.w	r2, [r3], #4
 811b80e:	6881      	ldr	r1, [r0, #8]
 811b810:	9301      	str	r3, [sp, #4]
 811b812:	f000 f8ef 	bl	811b9f4 <_vfiprintf_r>
 811b816:	b003      	add	sp, #12
 811b818:	f85d eb04 	ldr.w	lr, [sp], #4
 811b81c:	b004      	add	sp, #16
 811b81e:	4770      	bx	lr
 811b820:	100001bc 	.word	0x100001bc

0811b824 <putchar>:
 811b824:	4b02      	ldr	r3, [pc, #8]	; (811b830 <putchar+0xc>)
 811b826:	4601      	mov	r1, r0
 811b828:	6818      	ldr	r0, [r3, #0]
 811b82a:	6882      	ldr	r2, [r0, #8]
 811b82c:	f000 be3c 	b.w	811c4a8 <_putc_r>
 811b830:	100001bc 	.word	0x100001bc

0811b834 <memcmp>:
 811b834:	b510      	push	{r4, lr}
 811b836:	3901      	subs	r1, #1
 811b838:	4402      	add	r2, r0
 811b83a:	4290      	cmp	r0, r2
 811b83c:	d101      	bne.n	811b842 <memcmp+0xe>
 811b83e:	2000      	movs	r0, #0
 811b840:	e005      	b.n	811b84e <memcmp+0x1a>
 811b842:	7803      	ldrb	r3, [r0, #0]
 811b844:	f811 4f01 	ldrb.w	r4, [r1, #1]!
 811b848:	42a3      	cmp	r3, r4
 811b84a:	d001      	beq.n	811b850 <memcmp+0x1c>
 811b84c:	1b18      	subs	r0, r3, r4
 811b84e:	bd10      	pop	{r4, pc}
 811b850:	3001      	adds	r0, #1
 811b852:	e7f2      	b.n	811b83a <memcmp+0x6>

0811b854 <memset>:
 811b854:	4402      	add	r2, r0
 811b856:	4603      	mov	r3, r0
 811b858:	4293      	cmp	r3, r2
 811b85a:	d100      	bne.n	811b85e <memset+0xa>
 811b85c:	4770      	bx	lr
 811b85e:	f803 1b01 	strb.w	r1, [r3], #1
 811b862:	e7f9      	b.n	811b858 <memset+0x4>

0811b864 <__libc_init_array>:
 811b864:	b570      	push	{r4, r5, r6, lr}
 811b866:	4d0d      	ldr	r5, [pc, #52]	; (811b89c <__libc_init_array+0x38>)
 811b868:	4c0d      	ldr	r4, [pc, #52]	; (811b8a0 <__libc_init_array+0x3c>)
 811b86a:	1b64      	subs	r4, r4, r5
 811b86c:	10a4      	asrs	r4, r4, #2
 811b86e:	2600      	movs	r6, #0
 811b870:	42a6      	cmp	r6, r4
 811b872:	d109      	bne.n	811b888 <__libc_init_array+0x24>
 811b874:	4d0b      	ldr	r5, [pc, #44]	; (811b8a4 <__libc_init_array+0x40>)
 811b876:	4c0c      	ldr	r4, [pc, #48]	; (811b8a8 <__libc_init_array+0x44>)
 811b878:	f000 ff0e 	bl	811c698 <_init>
 811b87c:	1b64      	subs	r4, r4, r5
 811b87e:	10a4      	asrs	r4, r4, #2
 811b880:	2600      	movs	r6, #0
 811b882:	42a6      	cmp	r6, r4
 811b884:	d105      	bne.n	811b892 <__libc_init_array+0x2e>
 811b886:	bd70      	pop	{r4, r5, r6, pc}
 811b888:	f855 3b04 	ldr.w	r3, [r5], #4
 811b88c:	4798      	blx	r3
 811b88e:	3601      	adds	r6, #1
 811b890:	e7ee      	b.n	811b870 <__libc_init_array+0xc>
 811b892:	f855 3b04 	ldr.w	r3, [r5], #4
 811b896:	4798      	blx	r3
 811b898:	3601      	adds	r6, #1
 811b89a:	e7f2      	b.n	811b882 <__libc_init_array+0x1e>
 811b89c:	0811fb0c 	.word	0x0811fb0c
 811b8a0:	0811fb0c 	.word	0x0811fb0c
 811b8a4:	0811fb0c 	.word	0x0811fb0c
 811b8a8:	0811fb10 	.word	0x0811fb10

0811b8ac <__retarget_lock_acquire_recursive>:
 811b8ac:	4770      	bx	lr

0811b8ae <__retarget_lock_release_recursive>:
 811b8ae:	4770      	bx	lr

0811b8b0 <memcpy>:
 811b8b0:	440a      	add	r2, r1
 811b8b2:	4291      	cmp	r1, r2
 811b8b4:	f100 33ff 	add.w	r3, r0, #4294967295	; 0xffffffff
 811b8b8:	d100      	bne.n	811b8bc <memcpy+0xc>
 811b8ba:	4770      	bx	lr
 811b8bc:	b510      	push	{r4, lr}
 811b8be:	f811 4b01 	ldrb.w	r4, [r1], #1
 811b8c2:	f803 4f01 	strb.w	r4, [r3, #1]!
 811b8c6:	4291      	cmp	r1, r2
 811b8c8:	d1f9      	bne.n	811b8be <memcpy+0xe>
 811b8ca:	bd10      	pop	{r4, pc}

0811b8cc <__assert_func>:
 811b8cc:	b51f      	push	{r0, r1, r2, r3, r4, lr}
 811b8ce:	4614      	mov	r4, r2
 811b8d0:	461a      	mov	r2, r3
 811b8d2:	4b09      	ldr	r3, [pc, #36]	; (811b8f8 <__assert_func+0x2c>)
 811b8d4:	681b      	ldr	r3, [r3, #0]
 811b8d6:	4605      	mov	r5, r0
 811b8d8:	68d8      	ldr	r0, [r3, #12]
 811b8da:	b14c      	cbz	r4, 811b8f0 <__assert_func+0x24>
 811b8dc:	4b07      	ldr	r3, [pc, #28]	; (811b8fc <__assert_func+0x30>)
 811b8de:	9100      	str	r1, [sp, #0]
 811b8e0:	e9cd 3401 	strd	r3, r4, [sp, #4]
 811b8e4:	4906      	ldr	r1, [pc, #24]	; (811b900 <__assert_func+0x34>)
 811b8e6:	462b      	mov	r3, r5
 811b8e8:	f000 fcd4 	bl	811c294 <fiprintf>
 811b8ec:	f000 fe88 	bl	811c600 <abort>
 811b8f0:	4b04      	ldr	r3, [pc, #16]	; (811b904 <__assert_func+0x38>)
 811b8f2:	461c      	mov	r4, r3
 811b8f4:	e7f3      	b.n	811b8de <__assert_func+0x12>
 811b8f6:	bf00      	nop
 811b8f8:	100001bc 	.word	0x100001bc
 811b8fc:	0811fa93 	.word	0x0811fa93
 811b900:	0811faa0 	.word	0x0811faa0
 811b904:	0811face 	.word	0x0811face

0811b908 <_free_r>:
 811b908:	b537      	push	{r0, r1, r2, r4, r5, lr}
 811b90a:	2900      	cmp	r1, #0
 811b90c:	d044      	beq.n	811b998 <_free_r+0x90>
 811b90e:	f851 3c04 	ldr.w	r3, [r1, #-4]
 811b912:	9001      	str	r0, [sp, #4]
 811b914:	2b00      	cmp	r3, #0
 811b916:	f1a1 0404 	sub.w	r4, r1, #4
 811b91a:	bfb8      	it	lt
 811b91c:	18e4      	addlt	r4, r4, r3
 811b91e:	f000 fc69 	bl	811c1f4 <__malloc_lock>
 811b922:	4a1e      	ldr	r2, [pc, #120]	; (811b99c <_free_r+0x94>)
 811b924:	9801      	ldr	r0, [sp, #4]
 811b926:	6813      	ldr	r3, [r2, #0]
 811b928:	b933      	cbnz	r3, 811b938 <_free_r+0x30>
 811b92a:	6063      	str	r3, [r4, #4]
 811b92c:	6014      	str	r4, [r2, #0]
 811b92e:	b003      	add	sp, #12
 811b930:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
 811b934:	f000 bc64 	b.w	811c200 <__malloc_unlock>
 811b938:	42a3      	cmp	r3, r4
 811b93a:	d908      	bls.n	811b94e <_free_r+0x46>
 811b93c:	6825      	ldr	r5, [r4, #0]
 811b93e:	1961      	adds	r1, r4, r5
 811b940:	428b      	cmp	r3, r1
 811b942:	bf01      	itttt	eq
 811b944:	6819      	ldreq	r1, [r3, #0]
 811b946:	685b      	ldreq	r3, [r3, #4]
 811b948:	1949      	addeq	r1, r1, r5
 811b94a:	6021      	streq	r1, [r4, #0]
 811b94c:	e7ed      	b.n	811b92a <_free_r+0x22>
 811b94e:	461a      	mov	r2, r3
 811b950:	685b      	ldr	r3, [r3, #4]
 811b952:	b10b      	cbz	r3, 811b958 <_free_r+0x50>
 811b954:	42a3      	cmp	r3, r4
 811b956:	d9fa      	bls.n	811b94e <_free_r+0x46>
 811b958:	6811      	ldr	r1, [r2, #0]
 811b95a:	1855      	adds	r5, r2, r1
 811b95c:	42a5      	cmp	r5, r4
 811b95e:	d10b      	bne.n	811b978 <_free_r+0x70>
 811b960:	6824      	ldr	r4, [r4, #0]
 811b962:	4421      	add	r1, r4
 811b964:	1854      	adds	r4, r2, r1
 811b966:	42a3      	cmp	r3, r4
 811b968:	6011      	str	r1, [r2, #0]
 811b96a:	d1e0      	bne.n	811b92e <_free_r+0x26>
 811b96c:	681c      	ldr	r4, [r3, #0]
 811b96e:	685b      	ldr	r3, [r3, #4]
 811b970:	6053      	str	r3, [r2, #4]
 811b972:	440c      	add	r4, r1
 811b974:	6014      	str	r4, [r2, #0]
 811b976:	e7da      	b.n	811b92e <_free_r+0x26>
 811b978:	d902      	bls.n	811b980 <_free_r+0x78>
 811b97a:	230c      	movs	r3, #12
 811b97c:	6003      	str	r3, [r0, #0]
 811b97e:	e7d6      	b.n	811b92e <_free_r+0x26>
 811b980:	6825      	ldr	r5, [r4, #0]
 811b982:	1961      	adds	r1, r4, r5
 811b984:	428b      	cmp	r3, r1
 811b986:	bf04      	itt	eq
 811b988:	6819      	ldreq	r1, [r3, #0]
 811b98a:	685b      	ldreq	r3, [r3, #4]
 811b98c:	6063      	str	r3, [r4, #4]
 811b98e:	bf04      	itt	eq
 811b990:	1949      	addeq	r1, r1, r5
 811b992:	6021      	streq	r1, [r4, #0]
 811b994:	6054      	str	r4, [r2, #4]
 811b996:	e7ca      	b.n	811b92e <_free_r+0x26>
 811b998:	b003      	add	sp, #12
 811b99a:	bd30      	pop	{r4, r5, pc}
 811b99c:	10008fc0 	.word	0x10008fc0

0811b9a0 <__sfputc_r>:
 811b9a0:	6893      	ldr	r3, [r2, #8]
 811b9a2:	3b01      	subs	r3, #1
 811b9a4:	2b00      	cmp	r3, #0
 811b9a6:	b410      	push	{r4}
 811b9a8:	6093      	str	r3, [r2, #8]
 811b9aa:	da08      	bge.n	811b9be <__sfputc_r+0x1e>
 811b9ac:	6994      	ldr	r4, [r2, #24]
 811b9ae:	42a3      	cmp	r3, r4
 811b9b0:	db01      	blt.n	811b9b6 <__sfputc_r+0x16>
 811b9b2:	290a      	cmp	r1, #10
 811b9b4:	d103      	bne.n	811b9be <__sfputc_r+0x1e>
 811b9b6:	f85d 4b04 	ldr.w	r4, [sp], #4
 811b9ba:	f000 bc7d 	b.w	811c2b8 <__swbuf_r>
 811b9be:	6813      	ldr	r3, [r2, #0]
 811b9c0:	1c58      	adds	r0, r3, #1
 811b9c2:	6010      	str	r0, [r2, #0]
 811b9c4:	7019      	strb	r1, [r3, #0]
 811b9c6:	4608      	mov	r0, r1
 811b9c8:	f85d 4b04 	ldr.w	r4, [sp], #4
 811b9cc:	4770      	bx	lr

0811b9ce <__sfputs_r>:
 811b9ce:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 811b9d0:	4606      	mov	r6, r0
 811b9d2:	460f      	mov	r7, r1
 811b9d4:	4614      	mov	r4, r2
 811b9d6:	18d5      	adds	r5, r2, r3
 811b9d8:	42ac      	cmp	r4, r5
 811b9da:	d101      	bne.n	811b9e0 <__sfputs_r+0x12>
 811b9dc:	2000      	movs	r0, #0
 811b9de:	e007      	b.n	811b9f0 <__sfputs_r+0x22>
 811b9e0:	f814 1b01 	ldrb.w	r1, [r4], #1
 811b9e4:	463a      	mov	r2, r7
 811b9e6:	4630      	mov	r0, r6
 811b9e8:	f7ff ffda 	bl	811b9a0 <__sfputc_r>
 811b9ec:	1c43      	adds	r3, r0, #1
 811b9ee:	d1f3      	bne.n	811b9d8 <__sfputs_r+0xa>
 811b9f0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	...

0811b9f4 <_vfiprintf_r>:
 811b9f4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 811b9f8:	460d      	mov	r5, r1
 811b9fa:	b09d      	sub	sp, #116	; 0x74
 811b9fc:	4614      	mov	r4, r2
 811b9fe:	4698      	mov	r8, r3
 811ba00:	4606      	mov	r6, r0
 811ba02:	b118      	cbz	r0, 811ba0c <_vfiprintf_r+0x18>
 811ba04:	6a03      	ldr	r3, [r0, #32]
 811ba06:	b90b      	cbnz	r3, 811ba0c <_vfiprintf_r+0x18>
 811ba08:	f7ff fec4 	bl	811b794 <__sinit>
 811ba0c:	6e6b      	ldr	r3, [r5, #100]	; 0x64
 811ba0e:	07d9      	lsls	r1, r3, #31
 811ba10:	d405      	bmi.n	811ba1e <_vfiprintf_r+0x2a>
 811ba12:	89ab      	ldrh	r3, [r5, #12]
 811ba14:	059a      	lsls	r2, r3, #22
 811ba16:	d402      	bmi.n	811ba1e <_vfiprintf_r+0x2a>
 811ba18:	6da8      	ldr	r0, [r5, #88]	; 0x58
 811ba1a:	f7ff ff47 	bl	811b8ac <__retarget_lock_acquire_recursive>
 811ba1e:	89ab      	ldrh	r3, [r5, #12]
 811ba20:	071b      	lsls	r3, r3, #28
 811ba22:	d501      	bpl.n	811ba28 <_vfiprintf_r+0x34>
 811ba24:	692b      	ldr	r3, [r5, #16]
 811ba26:	b99b      	cbnz	r3, 811ba50 <_vfiprintf_r+0x5c>
 811ba28:	4629      	mov	r1, r5
 811ba2a:	4630      	mov	r0, r6
 811ba2c:	f000 fc82 	bl	811c334 <__swsetup_r>
 811ba30:	b170      	cbz	r0, 811ba50 <_vfiprintf_r+0x5c>
 811ba32:	6e6b      	ldr	r3, [r5, #100]	; 0x64
 811ba34:	07dc      	lsls	r4, r3, #31
 811ba36:	d504      	bpl.n	811ba42 <_vfiprintf_r+0x4e>
 811ba38:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 811ba3c:	b01d      	add	sp, #116	; 0x74
 811ba3e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 811ba42:	89ab      	ldrh	r3, [r5, #12]
 811ba44:	0598      	lsls	r0, r3, #22
 811ba46:	d4f7      	bmi.n	811ba38 <_vfiprintf_r+0x44>
 811ba48:	6da8      	ldr	r0, [r5, #88]	; 0x58
 811ba4a:	f7ff ff30 	bl	811b8ae <__retarget_lock_release_recursive>
 811ba4e:	e7f3      	b.n	811ba38 <_vfiprintf_r+0x44>
 811ba50:	2300      	movs	r3, #0
 811ba52:	9309      	str	r3, [sp, #36]	; 0x24
 811ba54:	2320      	movs	r3, #32
 811ba56:	f88d 3029 	strb.w	r3, [sp, #41]	; 0x29
 811ba5a:	f8cd 800c 	str.w	r8, [sp, #12]
 811ba5e:	2330      	movs	r3, #48	; 0x30
 811ba60:	f8df 81b0 	ldr.w	r8, [pc, #432]	; 811bc14 <_vfiprintf_r+0x220>
 811ba64:	f88d 302a 	strb.w	r3, [sp, #42]	; 0x2a
 811ba68:	f04f 0901 	mov.w	r9, #1
 811ba6c:	4623      	mov	r3, r4
 811ba6e:	469a      	mov	sl, r3
 811ba70:	f813 2b01 	ldrb.w	r2, [r3], #1
 811ba74:	b10a      	cbz	r2, 811ba7a <_vfiprintf_r+0x86>
 811ba76:	2a25      	cmp	r2, #37	; 0x25
 811ba78:	d1f9      	bne.n	811ba6e <_vfiprintf_r+0x7a>
 811ba7a:	ebba 0b04 	subs.w	fp, sl, r4
 811ba7e:	d00b      	beq.n	811ba98 <_vfiprintf_r+0xa4>
 811ba80:	465b      	mov	r3, fp
 811ba82:	4622      	mov	r2, r4
 811ba84:	4629      	mov	r1, r5
 811ba86:	4630      	mov	r0, r6
 811ba88:	f7ff ffa1 	bl	811b9ce <__sfputs_r>
 811ba8c:	3001      	adds	r0, #1
 811ba8e:	f000 80a9 	beq.w	811bbe4 <_vfiprintf_r+0x1f0>
 811ba92:	9a09      	ldr	r2, [sp, #36]	; 0x24
 811ba94:	445a      	add	r2, fp
 811ba96:	9209      	str	r2, [sp, #36]	; 0x24
 811ba98:	f89a 3000 	ldrb.w	r3, [sl]
 811ba9c:	2b00      	cmp	r3, #0
 811ba9e:	f000 80a1 	beq.w	811bbe4 <_vfiprintf_r+0x1f0>
 811baa2:	2300      	movs	r3, #0
 811baa4:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 811baa8:	e9cd 2305 	strd	r2, r3, [sp, #20]
 811baac:	f10a 0a01 	add.w	sl, sl, #1
 811bab0:	9304      	str	r3, [sp, #16]
 811bab2:	9307      	str	r3, [sp, #28]
 811bab4:	f88d 3053 	strb.w	r3, [sp, #83]	; 0x53
 811bab8:	931a      	str	r3, [sp, #104]	; 0x68
 811baba:	4654      	mov	r4, sl
 811babc:	2205      	movs	r2, #5
 811babe:	f814 1b01 	ldrb.w	r1, [r4], #1
 811bac2:	4854      	ldr	r0, [pc, #336]	; (811bc14 <_vfiprintf_r+0x220>)
 811bac4:	f7e4 fc14 	bl	81002f0 <memchr>
 811bac8:	9a04      	ldr	r2, [sp, #16]
 811baca:	b9d8      	cbnz	r0, 811bb04 <_vfiprintf_r+0x110>
 811bacc:	06d1      	lsls	r1, r2, #27
 811bace:	bf44      	itt	mi
 811bad0:	2320      	movmi	r3, #32
 811bad2:	f88d 3053 	strbmi.w	r3, [sp, #83]	; 0x53
 811bad6:	0713      	lsls	r3, r2, #28
 811bad8:	bf44      	itt	mi
 811bada:	232b      	movmi	r3, #43	; 0x2b
 811badc:	f88d 3053 	strbmi.w	r3, [sp, #83]	; 0x53
 811bae0:	f89a 3000 	ldrb.w	r3, [sl]
 811bae4:	2b2a      	cmp	r3, #42	; 0x2a
 811bae6:	d015      	beq.n	811bb14 <_vfiprintf_r+0x120>
 811bae8:	9a07      	ldr	r2, [sp, #28]
 811baea:	4654      	mov	r4, sl
 811baec:	2000      	movs	r0, #0
 811baee:	f04f 0c0a 	mov.w	ip, #10
 811baf2:	4621      	mov	r1, r4
 811baf4:	f811 3b01 	ldrb.w	r3, [r1], #1
 811baf8:	3b30      	subs	r3, #48	; 0x30
 811bafa:	2b09      	cmp	r3, #9
 811bafc:	d94d      	bls.n	811bb9a <_vfiprintf_r+0x1a6>
 811bafe:	b1b0      	cbz	r0, 811bb2e <_vfiprintf_r+0x13a>
 811bb00:	9207      	str	r2, [sp, #28]
 811bb02:	e014      	b.n	811bb2e <_vfiprintf_r+0x13a>
 811bb04:	eba0 0308 	sub.w	r3, r0, r8
 811bb08:	fa09 f303 	lsl.w	r3, r9, r3
 811bb0c:	4313      	orrs	r3, r2
 811bb0e:	9304      	str	r3, [sp, #16]
 811bb10:	46a2      	mov	sl, r4
 811bb12:	e7d2      	b.n	811baba <_vfiprintf_r+0xc6>
 811bb14:	9b03      	ldr	r3, [sp, #12]
 811bb16:	1d19      	adds	r1, r3, #4
 811bb18:	681b      	ldr	r3, [r3, #0]
 811bb1a:	9103      	str	r1, [sp, #12]
 811bb1c:	2b00      	cmp	r3, #0
 811bb1e:	bfbb      	ittet	lt
 811bb20:	425b      	neglt	r3, r3
 811bb22:	f042 0202 	orrlt.w	r2, r2, #2
 811bb26:	9307      	strge	r3, [sp, #28]
 811bb28:	9307      	strlt	r3, [sp, #28]
 811bb2a:	bfb8      	it	lt
 811bb2c:	9204      	strlt	r2, [sp, #16]
 811bb2e:	7823      	ldrb	r3, [r4, #0]
 811bb30:	2b2e      	cmp	r3, #46	; 0x2e
 811bb32:	d10c      	bne.n	811bb4e <_vfiprintf_r+0x15a>
 811bb34:	7863      	ldrb	r3, [r4, #1]
 811bb36:	2b2a      	cmp	r3, #42	; 0x2a
 811bb38:	d134      	bne.n	811bba4 <_vfiprintf_r+0x1b0>
 811bb3a:	9b03      	ldr	r3, [sp, #12]
 811bb3c:	1d1a      	adds	r2, r3, #4
 811bb3e:	681b      	ldr	r3, [r3, #0]
 811bb40:	9203      	str	r2, [sp, #12]
 811bb42:	2b00      	cmp	r3, #0
 811bb44:	bfb8      	it	lt
 811bb46:	f04f 33ff 	movlt.w	r3, #4294967295	; 0xffffffff
 811bb4a:	3402      	adds	r4, #2
 811bb4c:	9305      	str	r3, [sp, #20]
 811bb4e:	f8df a0d4 	ldr.w	sl, [pc, #212]	; 811bc24 <_vfiprintf_r+0x230>
 811bb52:	7821      	ldrb	r1, [r4, #0]
 811bb54:	2203      	movs	r2, #3
 811bb56:	4650      	mov	r0, sl
 811bb58:	f7e4 fbca 	bl	81002f0 <memchr>
 811bb5c:	b138      	cbz	r0, 811bb6e <_vfiprintf_r+0x17a>
 811bb5e:	9b04      	ldr	r3, [sp, #16]
 811bb60:	eba0 000a 	sub.w	r0, r0, sl
 811bb64:	2240      	movs	r2, #64	; 0x40
 811bb66:	4082      	lsls	r2, r0
 811bb68:	4313      	orrs	r3, r2
 811bb6a:	3401      	adds	r4, #1
 811bb6c:	9304      	str	r3, [sp, #16]
 811bb6e:	f814 1b01 	ldrb.w	r1, [r4], #1
 811bb72:	4829      	ldr	r0, [pc, #164]	; (811bc18 <_vfiprintf_r+0x224>)
 811bb74:	f88d 1028 	strb.w	r1, [sp, #40]	; 0x28
 811bb78:	2206      	movs	r2, #6
 811bb7a:	f7e4 fbb9 	bl	81002f0 <memchr>
 811bb7e:	2800      	cmp	r0, #0
 811bb80:	d03f      	beq.n	811bc02 <_vfiprintf_r+0x20e>
 811bb82:	4b26      	ldr	r3, [pc, #152]	; (811bc1c <_vfiprintf_r+0x228>)
 811bb84:	bb1b      	cbnz	r3, 811bbce <_vfiprintf_r+0x1da>
 811bb86:	9b03      	ldr	r3, [sp, #12]
 811bb88:	3307      	adds	r3, #7
 811bb8a:	f023 0307 	bic.w	r3, r3, #7
 811bb8e:	3308      	adds	r3, #8
 811bb90:	9303      	str	r3, [sp, #12]
 811bb92:	9b09      	ldr	r3, [sp, #36]	; 0x24
 811bb94:	443b      	add	r3, r7
 811bb96:	9309      	str	r3, [sp, #36]	; 0x24
 811bb98:	e768      	b.n	811ba6c <_vfiprintf_r+0x78>
 811bb9a:	fb0c 3202 	mla	r2, ip, r2, r3
 811bb9e:	460c      	mov	r4, r1
 811bba0:	2001      	movs	r0, #1
 811bba2:	e7a6      	b.n	811baf2 <_vfiprintf_r+0xfe>
 811bba4:	2300      	movs	r3, #0
 811bba6:	3401      	adds	r4, #1
 811bba8:	9305      	str	r3, [sp, #20]
 811bbaa:	4619      	mov	r1, r3
 811bbac:	f04f 0c0a 	mov.w	ip, #10
 811bbb0:	4620      	mov	r0, r4
 811bbb2:	f810 2b01 	ldrb.w	r2, [r0], #1
 811bbb6:	3a30      	subs	r2, #48	; 0x30
 811bbb8:	2a09      	cmp	r2, #9
 811bbba:	d903      	bls.n	811bbc4 <_vfiprintf_r+0x1d0>
 811bbbc:	2b00      	cmp	r3, #0
 811bbbe:	d0c6      	beq.n	811bb4e <_vfiprintf_r+0x15a>
 811bbc0:	9105      	str	r1, [sp, #20]
 811bbc2:	e7c4      	b.n	811bb4e <_vfiprintf_r+0x15a>
 811bbc4:	fb0c 2101 	mla	r1, ip, r1, r2
 811bbc8:	4604      	mov	r4, r0
 811bbca:	2301      	movs	r3, #1
 811bbcc:	e7f0      	b.n	811bbb0 <_vfiprintf_r+0x1bc>
 811bbce:	ab03      	add	r3, sp, #12
 811bbd0:	9300      	str	r3, [sp, #0]
 811bbd2:	462a      	mov	r2, r5
 811bbd4:	4b12      	ldr	r3, [pc, #72]	; (811bc20 <_vfiprintf_r+0x22c>)
 811bbd6:	a904      	add	r1, sp, #16
 811bbd8:	4630      	mov	r0, r6
 811bbda:	f3af 8000 	nop.w
 811bbde:	4607      	mov	r7, r0
 811bbe0:	1c78      	adds	r0, r7, #1
 811bbe2:	d1d6      	bne.n	811bb92 <_vfiprintf_r+0x19e>
 811bbe4:	6e6b      	ldr	r3, [r5, #100]	; 0x64
 811bbe6:	07d9      	lsls	r1, r3, #31
 811bbe8:	d405      	bmi.n	811bbf6 <_vfiprintf_r+0x202>
 811bbea:	89ab      	ldrh	r3, [r5, #12]
 811bbec:	059a      	lsls	r2, r3, #22
 811bbee:	d402      	bmi.n	811bbf6 <_vfiprintf_r+0x202>
 811bbf0:	6da8      	ldr	r0, [r5, #88]	; 0x58
 811bbf2:	f7ff fe5c 	bl	811b8ae <__retarget_lock_release_recursive>
 811bbf6:	89ab      	ldrh	r3, [r5, #12]
 811bbf8:	065b      	lsls	r3, r3, #25
 811bbfa:	f53f af1d 	bmi.w	811ba38 <_vfiprintf_r+0x44>
 811bbfe:	9809      	ldr	r0, [sp, #36]	; 0x24
 811bc00:	e71c      	b.n	811ba3c <_vfiprintf_r+0x48>
 811bc02:	ab03      	add	r3, sp, #12
 811bc04:	9300      	str	r3, [sp, #0]
 811bc06:	462a      	mov	r2, r5
 811bc08:	4b05      	ldr	r3, [pc, #20]	; (811bc20 <_vfiprintf_r+0x22c>)
 811bc0a:	a904      	add	r1, sp, #16
 811bc0c:	4630      	mov	r0, r6
 811bc0e:	f000 f921 	bl	811be54 <_printf_i>
 811bc12:	e7e4      	b.n	811bbde <_vfiprintf_r+0x1ea>
 811bc14:	0811facf 	.word	0x0811facf
 811bc18:	0811fad9 	.word	0x0811fad9
 811bc1c:	00000000 	.word	0x00000000
 811bc20:	0811b9cf 	.word	0x0811b9cf
 811bc24:	0811fad5 	.word	0x0811fad5

0811bc28 <malloc>:
 811bc28:	4b02      	ldr	r3, [pc, #8]	; (811bc34 <malloc+0xc>)
 811bc2a:	4601      	mov	r1, r0
 811bc2c:	6818      	ldr	r0, [r3, #0]
 811bc2e:	f000 b823 	b.w	811bc78 <_malloc_r>
 811bc32:	bf00      	nop
 811bc34:	100001bc 	.word	0x100001bc

0811bc38 <sbrk_aligned>:
 811bc38:	b570      	push	{r4, r5, r6, lr}
 811bc3a:	4e0e      	ldr	r6, [pc, #56]	; (811bc74 <sbrk_aligned+0x3c>)
 811bc3c:	460c      	mov	r4, r1
 811bc3e:	6831      	ldr	r1, [r6, #0]
 811bc40:	4605      	mov	r5, r0
 811bc42:	b911      	cbnz	r1, 811bc4a <sbrk_aligned+0x12>
 811bc44:	f000 fcba 	bl	811c5bc <_sbrk_r>
 811bc48:	6030      	str	r0, [r6, #0]
 811bc4a:	4621      	mov	r1, r4
 811bc4c:	4628      	mov	r0, r5
 811bc4e:	f000 fcb5 	bl	811c5bc <_sbrk_r>
 811bc52:	1c43      	adds	r3, r0, #1
 811bc54:	d00a      	beq.n	811bc6c <sbrk_aligned+0x34>
 811bc56:	1cc4      	adds	r4, r0, #3
 811bc58:	f024 0403 	bic.w	r4, r4, #3
 811bc5c:	42a0      	cmp	r0, r4
 811bc5e:	d007      	beq.n	811bc70 <sbrk_aligned+0x38>
 811bc60:	1a21      	subs	r1, r4, r0
 811bc62:	4628      	mov	r0, r5
 811bc64:	f000 fcaa 	bl	811c5bc <_sbrk_r>
 811bc68:	3001      	adds	r0, #1
 811bc6a:	d101      	bne.n	811bc70 <sbrk_aligned+0x38>
 811bc6c:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
 811bc70:	4620      	mov	r0, r4
 811bc72:	bd70      	pop	{r4, r5, r6, pc}
 811bc74:	10008fc4 	.word	0x10008fc4

0811bc78 <_malloc_r>:
 811bc78:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 811bc7c:	1ccd      	adds	r5, r1, #3
 811bc7e:	f025 0503 	bic.w	r5, r5, #3
 811bc82:	3508      	adds	r5, #8
 811bc84:	2d0c      	cmp	r5, #12
 811bc86:	bf38      	it	cc
 811bc88:	250c      	movcc	r5, #12
 811bc8a:	2d00      	cmp	r5, #0
 811bc8c:	4607      	mov	r7, r0
 811bc8e:	db01      	blt.n	811bc94 <_malloc_r+0x1c>
 811bc90:	42a9      	cmp	r1, r5
 811bc92:	d905      	bls.n	811bca0 <_malloc_r+0x28>
 811bc94:	230c      	movs	r3, #12
 811bc96:	603b      	str	r3, [r7, #0]
 811bc98:	2600      	movs	r6, #0
 811bc9a:	4630      	mov	r0, r6
 811bc9c:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 811bca0:	f8df 80d0 	ldr.w	r8, [pc, #208]	; 811bd74 <_malloc_r+0xfc>
 811bca4:	f000 faa6 	bl	811c1f4 <__malloc_lock>
 811bca8:	f8d8 3000 	ldr.w	r3, [r8]
 811bcac:	461c      	mov	r4, r3
 811bcae:	bb5c      	cbnz	r4, 811bd08 <_malloc_r+0x90>
 811bcb0:	4629      	mov	r1, r5
 811bcb2:	4638      	mov	r0, r7
 811bcb4:	f7ff ffc0 	bl	811bc38 <sbrk_aligned>
 811bcb8:	1c43      	adds	r3, r0, #1
 811bcba:	4604      	mov	r4, r0
 811bcbc:	d155      	bne.n	811bd6a <_malloc_r+0xf2>
 811bcbe:	f8d8 4000 	ldr.w	r4, [r8]
 811bcc2:	4626      	mov	r6, r4
 811bcc4:	2e00      	cmp	r6, #0
 811bcc6:	d145      	bne.n	811bd54 <_malloc_r+0xdc>
 811bcc8:	2c00      	cmp	r4, #0
 811bcca:	d048      	beq.n	811bd5e <_malloc_r+0xe6>
 811bccc:	6823      	ldr	r3, [r4, #0]
 811bcce:	4631      	mov	r1, r6
 811bcd0:	4638      	mov	r0, r7
 811bcd2:	eb04 0903 	add.w	r9, r4, r3
 811bcd6:	f000 fc71 	bl	811c5bc <_sbrk_r>
 811bcda:	4581      	cmp	r9, r0
 811bcdc:	d13f      	bne.n	811bd5e <_malloc_r+0xe6>
 811bcde:	6821      	ldr	r1, [r4, #0]
 811bce0:	1a6d      	subs	r5, r5, r1
 811bce2:	4629      	mov	r1, r5
 811bce4:	4638      	mov	r0, r7
 811bce6:	f7ff ffa7 	bl	811bc38 <sbrk_aligned>
 811bcea:	3001      	adds	r0, #1
 811bcec:	d037      	beq.n	811bd5e <_malloc_r+0xe6>
 811bcee:	6823      	ldr	r3, [r4, #0]
 811bcf0:	442b      	add	r3, r5
 811bcf2:	6023      	str	r3, [r4, #0]
 811bcf4:	f8d8 3000 	ldr.w	r3, [r8]
 811bcf8:	2b00      	cmp	r3, #0
 811bcfa:	d038      	beq.n	811bd6e <_malloc_r+0xf6>
 811bcfc:	685a      	ldr	r2, [r3, #4]
 811bcfe:	42a2      	cmp	r2, r4
 811bd00:	d12b      	bne.n	811bd5a <_malloc_r+0xe2>
 811bd02:	2200      	movs	r2, #0
 811bd04:	605a      	str	r2, [r3, #4]
 811bd06:	e00f      	b.n	811bd28 <_malloc_r+0xb0>
 811bd08:	6822      	ldr	r2, [r4, #0]
 811bd0a:	1b52      	subs	r2, r2, r5
 811bd0c:	d41f      	bmi.n	811bd4e <_malloc_r+0xd6>
 811bd0e:	2a0b      	cmp	r2, #11
 811bd10:	d917      	bls.n	811bd42 <_malloc_r+0xca>
 811bd12:	1961      	adds	r1, r4, r5
 811bd14:	42a3      	cmp	r3, r4
 811bd16:	6025      	str	r5, [r4, #0]
 811bd18:	bf18      	it	ne
 811bd1a:	6059      	strne	r1, [r3, #4]
 811bd1c:	6863      	ldr	r3, [r4, #4]
 811bd1e:	bf08      	it	eq
 811bd20:	f8c8 1000 	streq.w	r1, [r8]
 811bd24:	5162      	str	r2, [r4, r5]
 811bd26:	604b      	str	r3, [r1, #4]
 811bd28:	4638      	mov	r0, r7
 811bd2a:	f104 060b 	add.w	r6, r4, #11
 811bd2e:	f000 fa67 	bl	811c200 <__malloc_unlock>
 811bd32:	f026 0607 	bic.w	r6, r6, #7
 811bd36:	1d23      	adds	r3, r4, #4
 811bd38:	1af2      	subs	r2, r6, r3
 811bd3a:	d0ae      	beq.n	811bc9a <_malloc_r+0x22>
 811bd3c:	1b9b      	subs	r3, r3, r6
 811bd3e:	50a3      	str	r3, [r4, r2]
 811bd40:	e7ab      	b.n	811bc9a <_malloc_r+0x22>
 811bd42:	42a3      	cmp	r3, r4
 811bd44:	6862      	ldr	r2, [r4, #4]
 811bd46:	d1dd      	bne.n	811bd04 <_malloc_r+0x8c>
 811bd48:	f8c8 2000 	str.w	r2, [r8]
 811bd4c:	e7ec      	b.n	811bd28 <_malloc_r+0xb0>
 811bd4e:	4623      	mov	r3, r4
 811bd50:	6864      	ldr	r4, [r4, #4]
 811bd52:	e7ac      	b.n	811bcae <_malloc_r+0x36>
 811bd54:	4634      	mov	r4, r6
 811bd56:	6876      	ldr	r6, [r6, #4]
 811bd58:	e7b4      	b.n	811bcc4 <_malloc_r+0x4c>
 811bd5a:	4613      	mov	r3, r2
 811bd5c:	e7cc      	b.n	811bcf8 <_malloc_r+0x80>
 811bd5e:	230c      	movs	r3, #12
 811bd60:	603b      	str	r3, [r7, #0]
 811bd62:	4638      	mov	r0, r7
 811bd64:	f000 fa4c 	bl	811c200 <__malloc_unlock>
 811bd68:	e797      	b.n	811bc9a <_malloc_r+0x22>
 811bd6a:	6025      	str	r5, [r4, #0]
 811bd6c:	e7dc      	b.n	811bd28 <_malloc_r+0xb0>
 811bd6e:	605b      	str	r3, [r3, #4]
 811bd70:	deff      	udf	#255	; 0xff
 811bd72:	bf00      	nop
 811bd74:	10008fc0 	.word	0x10008fc0

0811bd78 <_printf_common>:
 811bd78:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 811bd7c:	4616      	mov	r6, r2
 811bd7e:	4699      	mov	r9, r3
 811bd80:	688a      	ldr	r2, [r1, #8]
 811bd82:	690b      	ldr	r3, [r1, #16]
 811bd84:	f8dd 8020 	ldr.w	r8, [sp, #32]
 811bd88:	4293      	cmp	r3, r2
 811bd8a:	bfb8      	it	lt
 811bd8c:	4613      	movlt	r3, r2
 811bd8e:	6033      	str	r3, [r6, #0]
 811bd90:	f891 2043 	ldrb.w	r2, [r1, #67]	; 0x43
 811bd94:	4607      	mov	r7, r0
 811bd96:	460c      	mov	r4, r1
 811bd98:	b10a      	cbz	r2, 811bd9e <_printf_common+0x26>
 811bd9a:	3301      	adds	r3, #1
 811bd9c:	6033      	str	r3, [r6, #0]
 811bd9e:	6823      	ldr	r3, [r4, #0]
 811bda0:	0699      	lsls	r1, r3, #26
 811bda2:	bf42      	ittt	mi
 811bda4:	6833      	ldrmi	r3, [r6, #0]
 811bda6:	3302      	addmi	r3, #2
 811bda8:	6033      	strmi	r3, [r6, #0]
 811bdaa:	6825      	ldr	r5, [r4, #0]
 811bdac:	f015 0506 	ands.w	r5, r5, #6
 811bdb0:	d106      	bne.n	811bdc0 <_printf_common+0x48>
 811bdb2:	f104 0a19 	add.w	sl, r4, #25
 811bdb6:	68e3      	ldr	r3, [r4, #12]
 811bdb8:	6832      	ldr	r2, [r6, #0]
 811bdba:	1a9b      	subs	r3, r3, r2
 811bdbc:	42ab      	cmp	r3, r5
 811bdbe:	dc26      	bgt.n	811be0e <_printf_common+0x96>
 811bdc0:	f894 2043 	ldrb.w	r2, [r4, #67]	; 0x43
 811bdc4:	1e13      	subs	r3, r2, #0
 811bdc6:	6822      	ldr	r2, [r4, #0]
 811bdc8:	bf18      	it	ne
 811bdca:	2301      	movne	r3, #1
 811bdcc:	0692      	lsls	r2, r2, #26
 811bdce:	d42b      	bmi.n	811be28 <_printf_common+0xb0>
 811bdd0:	f104 0243 	add.w	r2, r4, #67	; 0x43
 811bdd4:	4649      	mov	r1, r9
 811bdd6:	4638      	mov	r0, r7
 811bdd8:	47c0      	blx	r8
 811bdda:	3001      	adds	r0, #1
 811bddc:	d01e      	beq.n	811be1c <_printf_common+0xa4>
 811bdde:	6823      	ldr	r3, [r4, #0]
 811bde0:	6922      	ldr	r2, [r4, #16]
 811bde2:	f003 0306 	and.w	r3, r3, #6
 811bde6:	2b04      	cmp	r3, #4
 811bde8:	bf02      	ittt	eq
 811bdea:	68e5      	ldreq	r5, [r4, #12]
 811bdec:	6833      	ldreq	r3, [r6, #0]
 811bdee:	1aed      	subeq	r5, r5, r3
 811bdf0:	68a3      	ldr	r3, [r4, #8]
 811bdf2:	bf0c      	ite	eq
 811bdf4:	ea25 75e5 	biceq.w	r5, r5, r5, asr #31
 811bdf8:	2500      	movne	r5, #0
 811bdfa:	4293      	cmp	r3, r2
 811bdfc:	bfc4      	itt	gt
 811bdfe:	1a9b      	subgt	r3, r3, r2
 811be00:	18ed      	addgt	r5, r5, r3
 811be02:	2600      	movs	r6, #0
 811be04:	341a      	adds	r4, #26
 811be06:	42b5      	cmp	r5, r6
 811be08:	d11a      	bne.n	811be40 <_printf_common+0xc8>
 811be0a:	2000      	movs	r0, #0
 811be0c:	e008      	b.n	811be20 <_printf_common+0xa8>
 811be0e:	2301      	movs	r3, #1
 811be10:	4652      	mov	r2, sl
 811be12:	4649      	mov	r1, r9
 811be14:	4638      	mov	r0, r7
 811be16:	47c0      	blx	r8
 811be18:	3001      	adds	r0, #1
 811be1a:	d103      	bne.n	811be24 <_printf_common+0xac>
 811be1c:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 811be20:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 811be24:	3501      	adds	r5, #1
 811be26:	e7c6      	b.n	811bdb6 <_printf_common+0x3e>
 811be28:	18e1      	adds	r1, r4, r3
 811be2a:	1c5a      	adds	r2, r3, #1
 811be2c:	2030      	movs	r0, #48	; 0x30
 811be2e:	f881 0043 	strb.w	r0, [r1, #67]	; 0x43
 811be32:	4422      	add	r2, r4
 811be34:	f894 1045 	ldrb.w	r1, [r4, #69]	; 0x45
 811be38:	f882 1043 	strb.w	r1, [r2, #67]	; 0x43
 811be3c:	3302      	adds	r3, #2
 811be3e:	e7c7      	b.n	811bdd0 <_printf_common+0x58>
 811be40:	2301      	movs	r3, #1
 811be42:	4622      	mov	r2, r4
 811be44:	4649      	mov	r1, r9
 811be46:	4638      	mov	r0, r7
 811be48:	47c0      	blx	r8
 811be4a:	3001      	adds	r0, #1
 811be4c:	d0e6      	beq.n	811be1c <_printf_common+0xa4>
 811be4e:	3601      	adds	r6, #1
 811be50:	e7d9      	b.n	811be06 <_printf_common+0x8e>
	...

0811be54 <_printf_i>:
 811be54:	e92d 47ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, lr}
 811be58:	7e0f      	ldrb	r7, [r1, #24]
 811be5a:	9d0c      	ldr	r5, [sp, #48]	; 0x30
 811be5c:	2f78      	cmp	r7, #120	; 0x78
 811be5e:	4691      	mov	r9, r2
 811be60:	4680      	mov	r8, r0
 811be62:	460c      	mov	r4, r1
 811be64:	469a      	mov	sl, r3
 811be66:	f101 0243 	add.w	r2, r1, #67	; 0x43
 811be6a:	d807      	bhi.n	811be7c <_printf_i+0x28>
 811be6c:	2f62      	cmp	r7, #98	; 0x62
 811be6e:	d80a      	bhi.n	811be86 <_printf_i+0x32>
 811be70:	2f00      	cmp	r7, #0
 811be72:	f000 80d4 	beq.w	811c01e <_printf_i+0x1ca>
 811be76:	2f58      	cmp	r7, #88	; 0x58
 811be78:	f000 80c0 	beq.w	811bffc <_printf_i+0x1a8>
 811be7c:	f104 0542 	add.w	r5, r4, #66	; 0x42
 811be80:	f884 7042 	strb.w	r7, [r4, #66]	; 0x42
 811be84:	e03a      	b.n	811befc <_printf_i+0xa8>
 811be86:	f1a7 0363 	sub.w	r3, r7, #99	; 0x63
 811be8a:	2b15      	cmp	r3, #21
 811be8c:	d8f6      	bhi.n	811be7c <_printf_i+0x28>
 811be8e:	a101      	add	r1, pc, #4	; (adr r1, 811be94 <_printf_i+0x40>)
 811be90:	f851 f023 	ldr.w	pc, [r1, r3, lsl #2]
 811be94:	0811beed 	.word	0x0811beed
 811be98:	0811bf01 	.word	0x0811bf01
 811be9c:	0811be7d 	.word	0x0811be7d
 811bea0:	0811be7d 	.word	0x0811be7d
 811bea4:	0811be7d 	.word	0x0811be7d
 811bea8:	0811be7d 	.word	0x0811be7d
 811beac:	0811bf01 	.word	0x0811bf01
 811beb0:	0811be7d 	.word	0x0811be7d
 811beb4:	0811be7d 	.word	0x0811be7d
 811beb8:	0811be7d 	.word	0x0811be7d
 811bebc:	0811be7d 	.word	0x0811be7d
 811bec0:	0811c005 	.word	0x0811c005
 811bec4:	0811bf2d 	.word	0x0811bf2d
 811bec8:	0811bfbf 	.word	0x0811bfbf
 811becc:	0811be7d 	.word	0x0811be7d
 811bed0:	0811be7d 	.word	0x0811be7d
 811bed4:	0811c027 	.word	0x0811c027
 811bed8:	0811be7d 	.word	0x0811be7d
 811bedc:	0811bf2d 	.word	0x0811bf2d
 811bee0:	0811be7d 	.word	0x0811be7d
 811bee4:	0811be7d 	.word	0x0811be7d
 811bee8:	0811bfc7 	.word	0x0811bfc7
 811beec:	682b      	ldr	r3, [r5, #0]
 811beee:	1d1a      	adds	r2, r3, #4
 811bef0:	681b      	ldr	r3, [r3, #0]
 811bef2:	602a      	str	r2, [r5, #0]
 811bef4:	f104 0542 	add.w	r5, r4, #66	; 0x42
 811bef8:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
 811befc:	2301      	movs	r3, #1
 811befe:	e09f      	b.n	811c040 <_printf_i+0x1ec>
 811bf00:	6820      	ldr	r0, [r4, #0]
 811bf02:	682b      	ldr	r3, [r5, #0]
 811bf04:	0607      	lsls	r7, r0, #24
 811bf06:	f103 0104 	add.w	r1, r3, #4
 811bf0a:	6029      	str	r1, [r5, #0]
 811bf0c:	d501      	bpl.n	811bf12 <_printf_i+0xbe>
 811bf0e:	681e      	ldr	r6, [r3, #0]
 811bf10:	e003      	b.n	811bf1a <_printf_i+0xc6>
 811bf12:	0646      	lsls	r6, r0, #25
 811bf14:	d5fb      	bpl.n	811bf0e <_printf_i+0xba>
 811bf16:	f9b3 6000 	ldrsh.w	r6, [r3]
 811bf1a:	2e00      	cmp	r6, #0
 811bf1c:	da03      	bge.n	811bf26 <_printf_i+0xd2>
 811bf1e:	232d      	movs	r3, #45	; 0x2d
 811bf20:	4276      	negs	r6, r6
 811bf22:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
 811bf26:	485a      	ldr	r0, [pc, #360]	; (811c090 <_printf_i+0x23c>)
 811bf28:	230a      	movs	r3, #10
 811bf2a:	e012      	b.n	811bf52 <_printf_i+0xfe>
 811bf2c:	682b      	ldr	r3, [r5, #0]
 811bf2e:	6820      	ldr	r0, [r4, #0]
 811bf30:	1d19      	adds	r1, r3, #4
 811bf32:	6029      	str	r1, [r5, #0]
 811bf34:	0605      	lsls	r5, r0, #24
 811bf36:	d501      	bpl.n	811bf3c <_printf_i+0xe8>
 811bf38:	681e      	ldr	r6, [r3, #0]
 811bf3a:	e002      	b.n	811bf42 <_printf_i+0xee>
 811bf3c:	0641      	lsls	r1, r0, #25
 811bf3e:	d5fb      	bpl.n	811bf38 <_printf_i+0xe4>
 811bf40:	881e      	ldrh	r6, [r3, #0]
 811bf42:	4853      	ldr	r0, [pc, #332]	; (811c090 <_printf_i+0x23c>)
 811bf44:	2f6f      	cmp	r7, #111	; 0x6f
 811bf46:	bf0c      	ite	eq
 811bf48:	2308      	moveq	r3, #8
 811bf4a:	230a      	movne	r3, #10
 811bf4c:	2100      	movs	r1, #0
 811bf4e:	f884 1043 	strb.w	r1, [r4, #67]	; 0x43
 811bf52:	6865      	ldr	r5, [r4, #4]
 811bf54:	60a5      	str	r5, [r4, #8]
 811bf56:	2d00      	cmp	r5, #0
 811bf58:	bfa2      	ittt	ge
 811bf5a:	6821      	ldrge	r1, [r4, #0]
 811bf5c:	f021 0104 	bicge.w	r1, r1, #4
 811bf60:	6021      	strge	r1, [r4, #0]
 811bf62:	b90e      	cbnz	r6, 811bf68 <_printf_i+0x114>
 811bf64:	2d00      	cmp	r5, #0
 811bf66:	d04b      	beq.n	811c000 <_printf_i+0x1ac>
 811bf68:	4615      	mov	r5, r2
 811bf6a:	fbb6 f1f3 	udiv	r1, r6, r3
 811bf6e:	fb03 6711 	mls	r7, r3, r1, r6
 811bf72:	5dc7      	ldrb	r7, [r0, r7]
 811bf74:	f805 7d01 	strb.w	r7, [r5, #-1]!
 811bf78:	4637      	mov	r7, r6
 811bf7a:	42bb      	cmp	r3, r7
 811bf7c:	460e      	mov	r6, r1
 811bf7e:	d9f4      	bls.n	811bf6a <_printf_i+0x116>
 811bf80:	2b08      	cmp	r3, #8
 811bf82:	d10b      	bne.n	811bf9c <_printf_i+0x148>
 811bf84:	6823      	ldr	r3, [r4, #0]
 811bf86:	07de      	lsls	r6, r3, #31
 811bf88:	d508      	bpl.n	811bf9c <_printf_i+0x148>
 811bf8a:	6923      	ldr	r3, [r4, #16]
 811bf8c:	6861      	ldr	r1, [r4, #4]
 811bf8e:	4299      	cmp	r1, r3
 811bf90:	bfde      	ittt	le
 811bf92:	2330      	movle	r3, #48	; 0x30
 811bf94:	f805 3c01 	strble.w	r3, [r5, #-1]
 811bf98:	f105 35ff 	addle.w	r5, r5, #4294967295	; 0xffffffff
 811bf9c:	1b52      	subs	r2, r2, r5
 811bf9e:	6122      	str	r2, [r4, #16]
 811bfa0:	f8cd a000 	str.w	sl, [sp]
 811bfa4:	464b      	mov	r3, r9
 811bfa6:	aa03      	add	r2, sp, #12
 811bfa8:	4621      	mov	r1, r4
 811bfaa:	4640      	mov	r0, r8
 811bfac:	f7ff fee4 	bl	811bd78 <_printf_common>
 811bfb0:	3001      	adds	r0, #1
 811bfb2:	d14a      	bne.n	811c04a <_printf_i+0x1f6>
 811bfb4:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 811bfb8:	b004      	add	sp, #16
 811bfba:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 811bfbe:	6823      	ldr	r3, [r4, #0]
 811bfc0:	f043 0320 	orr.w	r3, r3, #32
 811bfc4:	6023      	str	r3, [r4, #0]
 811bfc6:	4833      	ldr	r0, [pc, #204]	; (811c094 <_printf_i+0x240>)
 811bfc8:	2778      	movs	r7, #120	; 0x78
 811bfca:	f884 7045 	strb.w	r7, [r4, #69]	; 0x45
 811bfce:	6823      	ldr	r3, [r4, #0]
 811bfd0:	6829      	ldr	r1, [r5, #0]
 811bfd2:	061f      	lsls	r7, r3, #24
 811bfd4:	f851 6b04 	ldr.w	r6, [r1], #4
 811bfd8:	d402      	bmi.n	811bfe0 <_printf_i+0x18c>
 811bfda:	065f      	lsls	r7, r3, #25
 811bfdc:	bf48      	it	mi
 811bfde:	b2b6      	uxthmi	r6, r6
 811bfe0:	07df      	lsls	r7, r3, #31
 811bfe2:	bf48      	it	mi
 811bfe4:	f043 0320 	orrmi.w	r3, r3, #32
 811bfe8:	6029      	str	r1, [r5, #0]
 811bfea:	bf48      	it	mi
 811bfec:	6023      	strmi	r3, [r4, #0]
 811bfee:	b91e      	cbnz	r6, 811bff8 <_printf_i+0x1a4>
 811bff0:	6823      	ldr	r3, [r4, #0]
 811bff2:	f023 0320 	bic.w	r3, r3, #32
 811bff6:	6023      	str	r3, [r4, #0]
 811bff8:	2310      	movs	r3, #16
 811bffa:	e7a7      	b.n	811bf4c <_printf_i+0xf8>
 811bffc:	4824      	ldr	r0, [pc, #144]	; (811c090 <_printf_i+0x23c>)
 811bffe:	e7e4      	b.n	811bfca <_printf_i+0x176>
 811c000:	4615      	mov	r5, r2
 811c002:	e7bd      	b.n	811bf80 <_printf_i+0x12c>
 811c004:	682b      	ldr	r3, [r5, #0]
 811c006:	6826      	ldr	r6, [r4, #0]
 811c008:	6961      	ldr	r1, [r4, #20]
 811c00a:	1d18      	adds	r0, r3, #4
 811c00c:	6028      	str	r0, [r5, #0]
 811c00e:	0635      	lsls	r5, r6, #24
 811c010:	681b      	ldr	r3, [r3, #0]
 811c012:	d501      	bpl.n	811c018 <_printf_i+0x1c4>
 811c014:	6019      	str	r1, [r3, #0]
 811c016:	e002      	b.n	811c01e <_printf_i+0x1ca>
 811c018:	0670      	lsls	r0, r6, #25
 811c01a:	d5fb      	bpl.n	811c014 <_printf_i+0x1c0>
 811c01c:	8019      	strh	r1, [r3, #0]
 811c01e:	2300      	movs	r3, #0
 811c020:	6123      	str	r3, [r4, #16]
 811c022:	4615      	mov	r5, r2
 811c024:	e7bc      	b.n	811bfa0 <_printf_i+0x14c>
 811c026:	682b      	ldr	r3, [r5, #0]
 811c028:	1d1a      	adds	r2, r3, #4
 811c02a:	602a      	str	r2, [r5, #0]
 811c02c:	681d      	ldr	r5, [r3, #0]
 811c02e:	6862      	ldr	r2, [r4, #4]
 811c030:	2100      	movs	r1, #0
 811c032:	4628      	mov	r0, r5
 811c034:	f7e4 f95c 	bl	81002f0 <memchr>
 811c038:	b108      	cbz	r0, 811c03e <_printf_i+0x1ea>
 811c03a:	1b40      	subs	r0, r0, r5
 811c03c:	6060      	str	r0, [r4, #4]
 811c03e:	6863      	ldr	r3, [r4, #4]
 811c040:	6123      	str	r3, [r4, #16]
 811c042:	2300      	movs	r3, #0
 811c044:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
 811c048:	e7aa      	b.n	811bfa0 <_printf_i+0x14c>
 811c04a:	6923      	ldr	r3, [r4, #16]
 811c04c:	462a      	mov	r2, r5
 811c04e:	4649      	mov	r1, r9
 811c050:	4640      	mov	r0, r8
 811c052:	47d0      	blx	sl
 811c054:	3001      	adds	r0, #1
 811c056:	d0ad      	beq.n	811bfb4 <_printf_i+0x160>
 811c058:	6823      	ldr	r3, [r4, #0]
 811c05a:	079b      	lsls	r3, r3, #30
 811c05c:	d413      	bmi.n	811c086 <_printf_i+0x232>
 811c05e:	68e0      	ldr	r0, [r4, #12]
 811c060:	9b03      	ldr	r3, [sp, #12]
 811c062:	4298      	cmp	r0, r3
 811c064:	bfb8      	it	lt
 811c066:	4618      	movlt	r0, r3
 811c068:	e7a6      	b.n	811bfb8 <_printf_i+0x164>
 811c06a:	2301      	movs	r3, #1
 811c06c:	4632      	mov	r2, r6
 811c06e:	4649      	mov	r1, r9
 811c070:	4640      	mov	r0, r8
 811c072:	47d0      	blx	sl
 811c074:	3001      	adds	r0, #1
 811c076:	d09d      	beq.n	811bfb4 <_printf_i+0x160>
 811c078:	3501      	adds	r5, #1
 811c07a:	68e3      	ldr	r3, [r4, #12]
 811c07c:	9903      	ldr	r1, [sp, #12]
 811c07e:	1a5b      	subs	r3, r3, r1
 811c080:	42ab      	cmp	r3, r5
 811c082:	dcf2      	bgt.n	811c06a <_printf_i+0x216>
 811c084:	e7eb      	b.n	811c05e <_printf_i+0x20a>
 811c086:	2500      	movs	r5, #0
 811c088:	f104 0619 	add.w	r6, r4, #25
 811c08c:	e7f5      	b.n	811c07a <_printf_i+0x226>
 811c08e:	bf00      	nop
 811c090:	0811fae0 	.word	0x0811fae0
 811c094:	0811faf1 	.word	0x0811faf1

0811c098 <__sflush_r>:
 811c098:	898a      	ldrh	r2, [r1, #12]
 811c09a:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 811c09e:	4605      	mov	r5, r0
 811c0a0:	0710      	lsls	r0, r2, #28
 811c0a2:	460c      	mov	r4, r1
 811c0a4:	d458      	bmi.n	811c158 <__sflush_r+0xc0>
 811c0a6:	684b      	ldr	r3, [r1, #4]
 811c0a8:	2b00      	cmp	r3, #0
 811c0aa:	dc05      	bgt.n	811c0b8 <__sflush_r+0x20>
 811c0ac:	6c0b      	ldr	r3, [r1, #64]	; 0x40
 811c0ae:	2b00      	cmp	r3, #0
 811c0b0:	dc02      	bgt.n	811c0b8 <__sflush_r+0x20>
 811c0b2:	2000      	movs	r0, #0
 811c0b4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 811c0b8:	6ae6      	ldr	r6, [r4, #44]	; 0x2c
 811c0ba:	2e00      	cmp	r6, #0
 811c0bc:	d0f9      	beq.n	811c0b2 <__sflush_r+0x1a>
 811c0be:	2300      	movs	r3, #0
 811c0c0:	f412 5280 	ands.w	r2, r2, #4096	; 0x1000
 811c0c4:	682f      	ldr	r7, [r5, #0]
 811c0c6:	6a21      	ldr	r1, [r4, #32]
 811c0c8:	602b      	str	r3, [r5, #0]
 811c0ca:	d032      	beq.n	811c132 <__sflush_r+0x9a>
 811c0cc:	6d60      	ldr	r0, [r4, #84]	; 0x54
 811c0ce:	89a3      	ldrh	r3, [r4, #12]
 811c0d0:	075a      	lsls	r2, r3, #29
 811c0d2:	d505      	bpl.n	811c0e0 <__sflush_r+0x48>
 811c0d4:	6863      	ldr	r3, [r4, #4]
 811c0d6:	1ac0      	subs	r0, r0, r3
 811c0d8:	6b63      	ldr	r3, [r4, #52]	; 0x34
 811c0da:	b10b      	cbz	r3, 811c0e0 <__sflush_r+0x48>
 811c0dc:	6c23      	ldr	r3, [r4, #64]	; 0x40
 811c0de:	1ac0      	subs	r0, r0, r3
 811c0e0:	2300      	movs	r3, #0
 811c0e2:	4602      	mov	r2, r0
 811c0e4:	6ae6      	ldr	r6, [r4, #44]	; 0x2c
 811c0e6:	6a21      	ldr	r1, [r4, #32]
 811c0e8:	4628      	mov	r0, r5
 811c0ea:	47b0      	blx	r6
 811c0ec:	1c43      	adds	r3, r0, #1
 811c0ee:	89a3      	ldrh	r3, [r4, #12]
 811c0f0:	d106      	bne.n	811c100 <__sflush_r+0x68>
 811c0f2:	6829      	ldr	r1, [r5, #0]
 811c0f4:	291d      	cmp	r1, #29
 811c0f6:	d82b      	bhi.n	811c150 <__sflush_r+0xb8>
 811c0f8:	4a29      	ldr	r2, [pc, #164]	; (811c1a0 <__sflush_r+0x108>)
 811c0fa:	410a      	asrs	r2, r1
 811c0fc:	07d6      	lsls	r6, r2, #31
 811c0fe:	d427      	bmi.n	811c150 <__sflush_r+0xb8>
 811c100:	2200      	movs	r2, #0
 811c102:	6062      	str	r2, [r4, #4]
 811c104:	04d9      	lsls	r1, r3, #19
 811c106:	6922      	ldr	r2, [r4, #16]
 811c108:	6022      	str	r2, [r4, #0]
 811c10a:	d504      	bpl.n	811c116 <__sflush_r+0x7e>
 811c10c:	1c42      	adds	r2, r0, #1
 811c10e:	d101      	bne.n	811c114 <__sflush_r+0x7c>
 811c110:	682b      	ldr	r3, [r5, #0]
 811c112:	b903      	cbnz	r3, 811c116 <__sflush_r+0x7e>
 811c114:	6560      	str	r0, [r4, #84]	; 0x54
 811c116:	6b61      	ldr	r1, [r4, #52]	; 0x34
 811c118:	602f      	str	r7, [r5, #0]
 811c11a:	2900      	cmp	r1, #0
 811c11c:	d0c9      	beq.n	811c0b2 <__sflush_r+0x1a>
 811c11e:	f104 0344 	add.w	r3, r4, #68	; 0x44
 811c122:	4299      	cmp	r1, r3
 811c124:	d002      	beq.n	811c12c <__sflush_r+0x94>
 811c126:	4628      	mov	r0, r5
 811c128:	f7ff fbee 	bl	811b908 <_free_r>
 811c12c:	2000      	movs	r0, #0
 811c12e:	6360      	str	r0, [r4, #52]	; 0x34
 811c130:	e7c0      	b.n	811c0b4 <__sflush_r+0x1c>
 811c132:	2301      	movs	r3, #1
 811c134:	4628      	mov	r0, r5
 811c136:	47b0      	blx	r6
 811c138:	1c41      	adds	r1, r0, #1
 811c13a:	d1c8      	bne.n	811c0ce <__sflush_r+0x36>
 811c13c:	682b      	ldr	r3, [r5, #0]
 811c13e:	2b00      	cmp	r3, #0
 811c140:	d0c5      	beq.n	811c0ce <__sflush_r+0x36>
 811c142:	2b1d      	cmp	r3, #29
 811c144:	d001      	beq.n	811c14a <__sflush_r+0xb2>
 811c146:	2b16      	cmp	r3, #22
 811c148:	d101      	bne.n	811c14e <__sflush_r+0xb6>
 811c14a:	602f      	str	r7, [r5, #0]
 811c14c:	e7b1      	b.n	811c0b2 <__sflush_r+0x1a>
 811c14e:	89a3      	ldrh	r3, [r4, #12]
 811c150:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 811c154:	81a3      	strh	r3, [r4, #12]
 811c156:	e7ad      	b.n	811c0b4 <__sflush_r+0x1c>
 811c158:	690f      	ldr	r7, [r1, #16]
 811c15a:	2f00      	cmp	r7, #0
 811c15c:	d0a9      	beq.n	811c0b2 <__sflush_r+0x1a>
 811c15e:	0793      	lsls	r3, r2, #30
 811c160:	680e      	ldr	r6, [r1, #0]
 811c162:	bf08      	it	eq
 811c164:	694b      	ldreq	r3, [r1, #20]
 811c166:	600f      	str	r7, [r1, #0]
 811c168:	bf18      	it	ne
 811c16a:	2300      	movne	r3, #0
 811c16c:	eba6 0807 	sub.w	r8, r6, r7
 811c170:	608b      	str	r3, [r1, #8]
 811c172:	f1b8 0f00 	cmp.w	r8, #0
 811c176:	dd9c      	ble.n	811c0b2 <__sflush_r+0x1a>
 811c178:	6a21      	ldr	r1, [r4, #32]
 811c17a:	6aa6      	ldr	r6, [r4, #40]	; 0x28
 811c17c:	4643      	mov	r3, r8
 811c17e:	463a      	mov	r2, r7
 811c180:	4628      	mov	r0, r5
 811c182:	47b0      	blx	r6
 811c184:	2800      	cmp	r0, #0
 811c186:	dc06      	bgt.n	811c196 <__sflush_r+0xfe>
 811c188:	89a3      	ldrh	r3, [r4, #12]
 811c18a:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 811c18e:	81a3      	strh	r3, [r4, #12]
 811c190:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 811c194:	e78e      	b.n	811c0b4 <__sflush_r+0x1c>
 811c196:	4407      	add	r7, r0
 811c198:	eba8 0800 	sub.w	r8, r8, r0
 811c19c:	e7e9      	b.n	811c172 <__sflush_r+0xda>
 811c19e:	bf00      	nop
 811c1a0:	dfbffffe 	.word	0xdfbffffe

0811c1a4 <_fflush_r>:
 811c1a4:	b538      	push	{r3, r4, r5, lr}
 811c1a6:	690b      	ldr	r3, [r1, #16]
 811c1a8:	4605      	mov	r5, r0
 811c1aa:	460c      	mov	r4, r1
 811c1ac:	b913      	cbnz	r3, 811c1b4 <_fflush_r+0x10>
 811c1ae:	2500      	movs	r5, #0
 811c1b0:	4628      	mov	r0, r5
 811c1b2:	bd38      	pop	{r3, r4, r5, pc}
 811c1b4:	b118      	cbz	r0, 811c1be <_fflush_r+0x1a>
 811c1b6:	6a03      	ldr	r3, [r0, #32]
 811c1b8:	b90b      	cbnz	r3, 811c1be <_fflush_r+0x1a>
 811c1ba:	f7ff faeb 	bl	811b794 <__sinit>
 811c1be:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 811c1c2:	2b00      	cmp	r3, #0
 811c1c4:	d0f3      	beq.n	811c1ae <_fflush_r+0xa>
 811c1c6:	6e62      	ldr	r2, [r4, #100]	; 0x64
 811c1c8:	07d0      	lsls	r0, r2, #31
 811c1ca:	d404      	bmi.n	811c1d6 <_fflush_r+0x32>
 811c1cc:	0599      	lsls	r1, r3, #22
 811c1ce:	d402      	bmi.n	811c1d6 <_fflush_r+0x32>
 811c1d0:	6da0      	ldr	r0, [r4, #88]	; 0x58
 811c1d2:	f7ff fb6b 	bl	811b8ac <__retarget_lock_acquire_recursive>
 811c1d6:	4628      	mov	r0, r5
 811c1d8:	4621      	mov	r1, r4
 811c1da:	f7ff ff5d 	bl	811c098 <__sflush_r>
 811c1de:	6e63      	ldr	r3, [r4, #100]	; 0x64
 811c1e0:	07da      	lsls	r2, r3, #31
 811c1e2:	4605      	mov	r5, r0
 811c1e4:	d4e4      	bmi.n	811c1b0 <_fflush_r+0xc>
 811c1e6:	89a3      	ldrh	r3, [r4, #12]
 811c1e8:	059b      	lsls	r3, r3, #22
 811c1ea:	d4e1      	bmi.n	811c1b0 <_fflush_r+0xc>
 811c1ec:	6da0      	ldr	r0, [r4, #88]	; 0x58
 811c1ee:	f7ff fb5e 	bl	811b8ae <__retarget_lock_release_recursive>
 811c1f2:	e7dd      	b.n	811c1b0 <_fflush_r+0xc>

0811c1f4 <__malloc_lock>:
 811c1f4:	4801      	ldr	r0, [pc, #4]	; (811c1fc <__malloc_lock+0x8>)
 811c1f6:	f7ff bb59 	b.w	811b8ac <__retarget_lock_acquire_recursive>
 811c1fa:	bf00      	nop
 811c1fc:	10008fbc 	.word	0x10008fbc

0811c200 <__malloc_unlock>:
 811c200:	4801      	ldr	r0, [pc, #4]	; (811c208 <__malloc_unlock+0x8>)
 811c202:	f7ff bb54 	b.w	811b8ae <__retarget_lock_release_recursive>
 811c206:	bf00      	nop
 811c208:	10008fbc 	.word	0x10008fbc

0811c20c <__sread>:
 811c20c:	b510      	push	{r4, lr}
 811c20e:	460c      	mov	r4, r1
 811c210:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 811c214:	f000 f9c0 	bl	811c598 <_read_r>
 811c218:	2800      	cmp	r0, #0
 811c21a:	bfab      	itete	ge
 811c21c:	6d63      	ldrge	r3, [r4, #84]	; 0x54
 811c21e:	89a3      	ldrhlt	r3, [r4, #12]
 811c220:	181b      	addge	r3, r3, r0
 811c222:	f423 5380 	biclt.w	r3, r3, #4096	; 0x1000
 811c226:	bfac      	ite	ge
 811c228:	6563      	strge	r3, [r4, #84]	; 0x54
 811c22a:	81a3      	strhlt	r3, [r4, #12]
 811c22c:	bd10      	pop	{r4, pc}

0811c22e <__swrite>:
 811c22e:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 811c232:	461f      	mov	r7, r3
 811c234:	898b      	ldrh	r3, [r1, #12]
 811c236:	05db      	lsls	r3, r3, #23
 811c238:	4605      	mov	r5, r0
 811c23a:	460c      	mov	r4, r1
 811c23c:	4616      	mov	r6, r2
 811c23e:	d505      	bpl.n	811c24c <__swrite+0x1e>
 811c240:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 811c244:	2302      	movs	r3, #2
 811c246:	2200      	movs	r2, #0
 811c248:	f000 f994 	bl	811c574 <_lseek_r>
 811c24c:	89a3      	ldrh	r3, [r4, #12]
 811c24e:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
 811c252:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
 811c256:	81a3      	strh	r3, [r4, #12]
 811c258:	4632      	mov	r2, r6
 811c25a:	463b      	mov	r3, r7
 811c25c:	4628      	mov	r0, r5
 811c25e:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 811c262:	f000 b9bb 	b.w	811c5dc <_write_r>

0811c266 <__sseek>:
 811c266:	b510      	push	{r4, lr}
 811c268:	460c      	mov	r4, r1
 811c26a:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 811c26e:	f000 f981 	bl	811c574 <_lseek_r>
 811c272:	1c43      	adds	r3, r0, #1
 811c274:	89a3      	ldrh	r3, [r4, #12]
 811c276:	bf15      	itete	ne
 811c278:	6560      	strne	r0, [r4, #84]	; 0x54
 811c27a:	f423 5380 	biceq.w	r3, r3, #4096	; 0x1000
 811c27e:	f443 5380 	orrne.w	r3, r3, #4096	; 0x1000
 811c282:	81a3      	strheq	r3, [r4, #12]
 811c284:	bf18      	it	ne
 811c286:	81a3      	strhne	r3, [r4, #12]
 811c288:	bd10      	pop	{r4, pc}

0811c28a <__sclose>:
 811c28a:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 811c28e:	f000 b93f 	b.w	811c510 <_close_r>
	...

0811c294 <fiprintf>:
 811c294:	b40e      	push	{r1, r2, r3}
 811c296:	b503      	push	{r0, r1, lr}
 811c298:	4601      	mov	r1, r0
 811c29a:	ab03      	add	r3, sp, #12
 811c29c:	4805      	ldr	r0, [pc, #20]	; (811c2b4 <fiprintf+0x20>)
 811c29e:	f853 2b04 	ldr.w	r2, [r3], #4
 811c2a2:	6800      	ldr	r0, [r0, #0]
 811c2a4:	9301      	str	r3, [sp, #4]
 811c2a6:	f7ff fba5 	bl	811b9f4 <_vfiprintf_r>
 811c2aa:	b002      	add	sp, #8
 811c2ac:	f85d eb04 	ldr.w	lr, [sp], #4
 811c2b0:	b003      	add	sp, #12
 811c2b2:	4770      	bx	lr
 811c2b4:	100001bc 	.word	0x100001bc

0811c2b8 <__swbuf_r>:
 811c2b8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 811c2ba:	460e      	mov	r6, r1
 811c2bc:	4614      	mov	r4, r2
 811c2be:	4605      	mov	r5, r0
 811c2c0:	b118      	cbz	r0, 811c2ca <__swbuf_r+0x12>
 811c2c2:	6a03      	ldr	r3, [r0, #32]
 811c2c4:	b90b      	cbnz	r3, 811c2ca <__swbuf_r+0x12>
 811c2c6:	f7ff fa65 	bl	811b794 <__sinit>
 811c2ca:	69a3      	ldr	r3, [r4, #24]
 811c2cc:	60a3      	str	r3, [r4, #8]
 811c2ce:	89a3      	ldrh	r3, [r4, #12]
 811c2d0:	071a      	lsls	r2, r3, #28
 811c2d2:	d525      	bpl.n	811c320 <__swbuf_r+0x68>
 811c2d4:	6923      	ldr	r3, [r4, #16]
 811c2d6:	b31b      	cbz	r3, 811c320 <__swbuf_r+0x68>
 811c2d8:	6823      	ldr	r3, [r4, #0]
 811c2da:	6922      	ldr	r2, [r4, #16]
 811c2dc:	1a98      	subs	r0, r3, r2
 811c2de:	6963      	ldr	r3, [r4, #20]
 811c2e0:	b2f6      	uxtb	r6, r6
 811c2e2:	4283      	cmp	r3, r0
 811c2e4:	4637      	mov	r7, r6
 811c2e6:	dc04      	bgt.n	811c2f2 <__swbuf_r+0x3a>
 811c2e8:	4621      	mov	r1, r4
 811c2ea:	4628      	mov	r0, r5
 811c2ec:	f7ff ff5a 	bl	811c1a4 <_fflush_r>
 811c2f0:	b9e0      	cbnz	r0, 811c32c <__swbuf_r+0x74>
 811c2f2:	68a3      	ldr	r3, [r4, #8]
 811c2f4:	3b01      	subs	r3, #1
 811c2f6:	60a3      	str	r3, [r4, #8]
 811c2f8:	6823      	ldr	r3, [r4, #0]
 811c2fa:	1c5a      	adds	r2, r3, #1
 811c2fc:	6022      	str	r2, [r4, #0]
 811c2fe:	701e      	strb	r6, [r3, #0]
 811c300:	6962      	ldr	r2, [r4, #20]
 811c302:	1c43      	adds	r3, r0, #1
 811c304:	429a      	cmp	r2, r3
 811c306:	d004      	beq.n	811c312 <__swbuf_r+0x5a>
 811c308:	89a3      	ldrh	r3, [r4, #12]
 811c30a:	07db      	lsls	r3, r3, #31
 811c30c:	d506      	bpl.n	811c31c <__swbuf_r+0x64>
 811c30e:	2e0a      	cmp	r6, #10
 811c310:	d104      	bne.n	811c31c <__swbuf_r+0x64>
 811c312:	4621      	mov	r1, r4
 811c314:	4628      	mov	r0, r5
 811c316:	f7ff ff45 	bl	811c1a4 <_fflush_r>
 811c31a:	b938      	cbnz	r0, 811c32c <__swbuf_r+0x74>
 811c31c:	4638      	mov	r0, r7
 811c31e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 811c320:	4621      	mov	r1, r4
 811c322:	4628      	mov	r0, r5
 811c324:	f000 f806 	bl	811c334 <__swsetup_r>
 811c328:	2800      	cmp	r0, #0
 811c32a:	d0d5      	beq.n	811c2d8 <__swbuf_r+0x20>
 811c32c:	f04f 37ff 	mov.w	r7, #4294967295	; 0xffffffff
 811c330:	e7f4      	b.n	811c31c <__swbuf_r+0x64>
	...

0811c334 <__swsetup_r>:
 811c334:	b538      	push	{r3, r4, r5, lr}
 811c336:	4b2a      	ldr	r3, [pc, #168]	; (811c3e0 <__swsetup_r+0xac>)
 811c338:	4605      	mov	r5, r0
 811c33a:	6818      	ldr	r0, [r3, #0]
 811c33c:	460c      	mov	r4, r1
 811c33e:	b118      	cbz	r0, 811c348 <__swsetup_r+0x14>
 811c340:	6a03      	ldr	r3, [r0, #32]
 811c342:	b90b      	cbnz	r3, 811c348 <__swsetup_r+0x14>
 811c344:	f7ff fa26 	bl	811b794 <__sinit>
 811c348:	89a3      	ldrh	r3, [r4, #12]
 811c34a:	f9b4 200c 	ldrsh.w	r2, [r4, #12]
 811c34e:	0718      	lsls	r0, r3, #28
 811c350:	d422      	bmi.n	811c398 <__swsetup_r+0x64>
 811c352:	06d9      	lsls	r1, r3, #27
 811c354:	d407      	bmi.n	811c366 <__swsetup_r+0x32>
 811c356:	2309      	movs	r3, #9
 811c358:	602b      	str	r3, [r5, #0]
 811c35a:	f042 0340 	orr.w	r3, r2, #64	; 0x40
 811c35e:	81a3      	strh	r3, [r4, #12]
 811c360:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 811c364:	e034      	b.n	811c3d0 <__swsetup_r+0x9c>
 811c366:	0758      	lsls	r0, r3, #29
 811c368:	d512      	bpl.n	811c390 <__swsetup_r+0x5c>
 811c36a:	6b61      	ldr	r1, [r4, #52]	; 0x34
 811c36c:	b141      	cbz	r1, 811c380 <__swsetup_r+0x4c>
 811c36e:	f104 0344 	add.w	r3, r4, #68	; 0x44
 811c372:	4299      	cmp	r1, r3
 811c374:	d002      	beq.n	811c37c <__swsetup_r+0x48>
 811c376:	4628      	mov	r0, r5
 811c378:	f7ff fac6 	bl	811b908 <_free_r>
 811c37c:	2300      	movs	r3, #0
 811c37e:	6363      	str	r3, [r4, #52]	; 0x34
 811c380:	89a3      	ldrh	r3, [r4, #12]
 811c382:	f023 0324 	bic.w	r3, r3, #36	; 0x24
 811c386:	81a3      	strh	r3, [r4, #12]
 811c388:	2300      	movs	r3, #0
 811c38a:	6063      	str	r3, [r4, #4]
 811c38c:	6923      	ldr	r3, [r4, #16]
 811c38e:	6023      	str	r3, [r4, #0]
 811c390:	89a3      	ldrh	r3, [r4, #12]
 811c392:	f043 0308 	orr.w	r3, r3, #8
 811c396:	81a3      	strh	r3, [r4, #12]
 811c398:	6923      	ldr	r3, [r4, #16]
 811c39a:	b94b      	cbnz	r3, 811c3b0 <__swsetup_r+0x7c>
 811c39c:	89a3      	ldrh	r3, [r4, #12]
 811c39e:	f403 7320 	and.w	r3, r3, #640	; 0x280
 811c3a2:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 811c3a6:	d003      	beq.n	811c3b0 <__swsetup_r+0x7c>
 811c3a8:	4621      	mov	r1, r4
 811c3aa:	4628      	mov	r0, r5
 811c3ac:	f000 f840 	bl	811c430 <__smakebuf_r>
 811c3b0:	89a0      	ldrh	r0, [r4, #12]
 811c3b2:	f9b4 200c 	ldrsh.w	r2, [r4, #12]
 811c3b6:	f010 0301 	ands.w	r3, r0, #1
 811c3ba:	d00a      	beq.n	811c3d2 <__swsetup_r+0x9e>
 811c3bc:	2300      	movs	r3, #0
 811c3be:	60a3      	str	r3, [r4, #8]
 811c3c0:	6963      	ldr	r3, [r4, #20]
 811c3c2:	425b      	negs	r3, r3
 811c3c4:	61a3      	str	r3, [r4, #24]
 811c3c6:	6923      	ldr	r3, [r4, #16]
 811c3c8:	b943      	cbnz	r3, 811c3dc <__swsetup_r+0xa8>
 811c3ca:	f010 0080 	ands.w	r0, r0, #128	; 0x80
 811c3ce:	d1c4      	bne.n	811c35a <__swsetup_r+0x26>
 811c3d0:	bd38      	pop	{r3, r4, r5, pc}
 811c3d2:	0781      	lsls	r1, r0, #30
 811c3d4:	bf58      	it	pl
 811c3d6:	6963      	ldrpl	r3, [r4, #20]
 811c3d8:	60a3      	str	r3, [r4, #8]
 811c3da:	e7f4      	b.n	811c3c6 <__swsetup_r+0x92>
 811c3dc:	2000      	movs	r0, #0
 811c3de:	e7f7      	b.n	811c3d0 <__swsetup_r+0x9c>
 811c3e0:	100001bc 	.word	0x100001bc

0811c3e4 <__swhatbuf_r>:
 811c3e4:	b570      	push	{r4, r5, r6, lr}
 811c3e6:	460c      	mov	r4, r1
 811c3e8:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 811c3ec:	2900      	cmp	r1, #0
 811c3ee:	b096      	sub	sp, #88	; 0x58
 811c3f0:	4615      	mov	r5, r2
 811c3f2:	461e      	mov	r6, r3
 811c3f4:	da0d      	bge.n	811c412 <__swhatbuf_r+0x2e>
 811c3f6:	89a3      	ldrh	r3, [r4, #12]
 811c3f8:	f013 0f80 	tst.w	r3, #128	; 0x80
 811c3fc:	f04f 0100 	mov.w	r1, #0
 811c400:	bf0c      	ite	eq
 811c402:	f44f 6380 	moveq.w	r3, #1024	; 0x400
 811c406:	2340      	movne	r3, #64	; 0x40
 811c408:	2000      	movs	r0, #0
 811c40a:	6031      	str	r1, [r6, #0]
 811c40c:	602b      	str	r3, [r5, #0]
 811c40e:	b016      	add	sp, #88	; 0x58
 811c410:	bd70      	pop	{r4, r5, r6, pc}
 811c412:	466a      	mov	r2, sp
 811c414:	f000 f88c 	bl	811c530 <_fstat_r>
 811c418:	2800      	cmp	r0, #0
 811c41a:	dbec      	blt.n	811c3f6 <__swhatbuf_r+0x12>
 811c41c:	9901      	ldr	r1, [sp, #4]
 811c41e:	f401 4170 	and.w	r1, r1, #61440	; 0xf000
 811c422:	f5a1 5300 	sub.w	r3, r1, #8192	; 0x2000
 811c426:	4259      	negs	r1, r3
 811c428:	4159      	adcs	r1, r3
 811c42a:	f44f 6380 	mov.w	r3, #1024	; 0x400
 811c42e:	e7eb      	b.n	811c408 <__swhatbuf_r+0x24>

0811c430 <__smakebuf_r>:
 811c430:	898b      	ldrh	r3, [r1, #12]
 811c432:	b573      	push	{r0, r1, r4, r5, r6, lr}
 811c434:	079d      	lsls	r5, r3, #30
 811c436:	4606      	mov	r6, r0
 811c438:	460c      	mov	r4, r1
 811c43a:	d507      	bpl.n	811c44c <__smakebuf_r+0x1c>
 811c43c:	f104 0347 	add.w	r3, r4, #71	; 0x47
 811c440:	6023      	str	r3, [r4, #0]
 811c442:	6123      	str	r3, [r4, #16]
 811c444:	2301      	movs	r3, #1
 811c446:	6163      	str	r3, [r4, #20]
 811c448:	b002      	add	sp, #8
 811c44a:	bd70      	pop	{r4, r5, r6, pc}
 811c44c:	ab01      	add	r3, sp, #4
 811c44e:	466a      	mov	r2, sp
 811c450:	f7ff ffc8 	bl	811c3e4 <__swhatbuf_r>
 811c454:	9900      	ldr	r1, [sp, #0]
 811c456:	4605      	mov	r5, r0
 811c458:	4630      	mov	r0, r6
 811c45a:	f7ff fc0d 	bl	811bc78 <_malloc_r>
 811c45e:	b948      	cbnz	r0, 811c474 <__smakebuf_r+0x44>
 811c460:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 811c464:	059a      	lsls	r2, r3, #22
 811c466:	d4ef      	bmi.n	811c448 <__smakebuf_r+0x18>
 811c468:	f023 0303 	bic.w	r3, r3, #3
 811c46c:	f043 0302 	orr.w	r3, r3, #2
 811c470:	81a3      	strh	r3, [r4, #12]
 811c472:	e7e3      	b.n	811c43c <__smakebuf_r+0xc>
 811c474:	89a3      	ldrh	r3, [r4, #12]
 811c476:	6020      	str	r0, [r4, #0]
 811c478:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 811c47c:	81a3      	strh	r3, [r4, #12]
 811c47e:	9b00      	ldr	r3, [sp, #0]
 811c480:	6163      	str	r3, [r4, #20]
 811c482:	9b01      	ldr	r3, [sp, #4]
 811c484:	6120      	str	r0, [r4, #16]
 811c486:	b15b      	cbz	r3, 811c4a0 <__smakebuf_r+0x70>
 811c488:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
 811c48c:	4630      	mov	r0, r6
 811c48e:	f000 f861 	bl	811c554 <_isatty_r>
 811c492:	b128      	cbz	r0, 811c4a0 <__smakebuf_r+0x70>
 811c494:	89a3      	ldrh	r3, [r4, #12]
 811c496:	f023 0303 	bic.w	r3, r3, #3
 811c49a:	f043 0301 	orr.w	r3, r3, #1
 811c49e:	81a3      	strh	r3, [r4, #12]
 811c4a0:	89a3      	ldrh	r3, [r4, #12]
 811c4a2:	431d      	orrs	r5, r3
 811c4a4:	81a5      	strh	r5, [r4, #12]
 811c4a6:	e7cf      	b.n	811c448 <__smakebuf_r+0x18>

0811c4a8 <_putc_r>:
 811c4a8:	b570      	push	{r4, r5, r6, lr}
 811c4aa:	460d      	mov	r5, r1
 811c4ac:	4614      	mov	r4, r2
 811c4ae:	4606      	mov	r6, r0
 811c4b0:	b118      	cbz	r0, 811c4ba <_putc_r+0x12>
 811c4b2:	6a03      	ldr	r3, [r0, #32]
 811c4b4:	b90b      	cbnz	r3, 811c4ba <_putc_r+0x12>
 811c4b6:	f7ff f96d 	bl	811b794 <__sinit>
 811c4ba:	6e63      	ldr	r3, [r4, #100]	; 0x64
 811c4bc:	07d8      	lsls	r0, r3, #31
 811c4be:	d405      	bmi.n	811c4cc <_putc_r+0x24>
 811c4c0:	89a3      	ldrh	r3, [r4, #12]
 811c4c2:	0599      	lsls	r1, r3, #22
 811c4c4:	d402      	bmi.n	811c4cc <_putc_r+0x24>
 811c4c6:	6da0      	ldr	r0, [r4, #88]	; 0x58
 811c4c8:	f7ff f9f0 	bl	811b8ac <__retarget_lock_acquire_recursive>
 811c4cc:	68a3      	ldr	r3, [r4, #8]
 811c4ce:	3b01      	subs	r3, #1
 811c4d0:	2b00      	cmp	r3, #0
 811c4d2:	60a3      	str	r3, [r4, #8]
 811c4d4:	da05      	bge.n	811c4e2 <_putc_r+0x3a>
 811c4d6:	69a2      	ldr	r2, [r4, #24]
 811c4d8:	4293      	cmp	r3, r2
 811c4da:	db12      	blt.n	811c502 <_putc_r+0x5a>
 811c4dc:	b2eb      	uxtb	r3, r5
 811c4de:	2b0a      	cmp	r3, #10
 811c4e0:	d00f      	beq.n	811c502 <_putc_r+0x5a>
 811c4e2:	6823      	ldr	r3, [r4, #0]
 811c4e4:	1c5a      	adds	r2, r3, #1
 811c4e6:	6022      	str	r2, [r4, #0]
 811c4e8:	701d      	strb	r5, [r3, #0]
 811c4ea:	b2ed      	uxtb	r5, r5
 811c4ec:	6e63      	ldr	r3, [r4, #100]	; 0x64
 811c4ee:	07da      	lsls	r2, r3, #31
 811c4f0:	d405      	bmi.n	811c4fe <_putc_r+0x56>
 811c4f2:	89a3      	ldrh	r3, [r4, #12]
 811c4f4:	059b      	lsls	r3, r3, #22
 811c4f6:	d402      	bmi.n	811c4fe <_putc_r+0x56>
 811c4f8:	6da0      	ldr	r0, [r4, #88]	; 0x58
 811c4fa:	f7ff f9d8 	bl	811b8ae <__retarget_lock_release_recursive>
 811c4fe:	4628      	mov	r0, r5
 811c500:	bd70      	pop	{r4, r5, r6, pc}
 811c502:	4629      	mov	r1, r5
 811c504:	4622      	mov	r2, r4
 811c506:	4630      	mov	r0, r6
 811c508:	f7ff fed6 	bl	811c2b8 <__swbuf_r>
 811c50c:	4605      	mov	r5, r0
 811c50e:	e7ed      	b.n	811c4ec <_putc_r+0x44>

0811c510 <_close_r>:
 811c510:	b538      	push	{r3, r4, r5, lr}
 811c512:	4d06      	ldr	r5, [pc, #24]	; (811c52c <_close_r+0x1c>)
 811c514:	2300      	movs	r3, #0
 811c516:	4604      	mov	r4, r0
 811c518:	4608      	mov	r0, r1
 811c51a:	602b      	str	r3, [r5, #0]
 811c51c:	f7e4 fc65 	bl	8100dea <_close>
 811c520:	1c43      	adds	r3, r0, #1
 811c522:	d102      	bne.n	811c52a <_close_r+0x1a>
 811c524:	682b      	ldr	r3, [r5, #0]
 811c526:	b103      	cbz	r3, 811c52a <_close_r+0x1a>
 811c528:	6023      	str	r3, [r4, #0]
 811c52a:	bd38      	pop	{r3, r4, r5, pc}
 811c52c:	10008fb8 	.word	0x10008fb8

0811c530 <_fstat_r>:
 811c530:	b538      	push	{r3, r4, r5, lr}
 811c532:	4d07      	ldr	r5, [pc, #28]	; (811c550 <_fstat_r+0x20>)
 811c534:	2300      	movs	r3, #0
 811c536:	4604      	mov	r4, r0
 811c538:	4608      	mov	r0, r1
 811c53a:	4611      	mov	r1, r2
 811c53c:	602b      	str	r3, [r5, #0]
 811c53e:	f7e4 fc60 	bl	8100e02 <_fstat>
 811c542:	1c43      	adds	r3, r0, #1
 811c544:	d102      	bne.n	811c54c <_fstat_r+0x1c>
 811c546:	682b      	ldr	r3, [r5, #0]
 811c548:	b103      	cbz	r3, 811c54c <_fstat_r+0x1c>
 811c54a:	6023      	str	r3, [r4, #0]
 811c54c:	bd38      	pop	{r3, r4, r5, pc}
 811c54e:	bf00      	nop
 811c550:	10008fb8 	.word	0x10008fb8

0811c554 <_isatty_r>:
 811c554:	b538      	push	{r3, r4, r5, lr}
 811c556:	4d06      	ldr	r5, [pc, #24]	; (811c570 <_isatty_r+0x1c>)
 811c558:	2300      	movs	r3, #0
 811c55a:	4604      	mov	r4, r0
 811c55c:	4608      	mov	r0, r1
 811c55e:	602b      	str	r3, [r5, #0]
 811c560:	f7e4 fc5f 	bl	8100e22 <_isatty>
 811c564:	1c43      	adds	r3, r0, #1
 811c566:	d102      	bne.n	811c56e <_isatty_r+0x1a>
 811c568:	682b      	ldr	r3, [r5, #0]
 811c56a:	b103      	cbz	r3, 811c56e <_isatty_r+0x1a>
 811c56c:	6023      	str	r3, [r4, #0]
 811c56e:	bd38      	pop	{r3, r4, r5, pc}
 811c570:	10008fb8 	.word	0x10008fb8

0811c574 <_lseek_r>:
 811c574:	b538      	push	{r3, r4, r5, lr}
 811c576:	4d07      	ldr	r5, [pc, #28]	; (811c594 <_lseek_r+0x20>)
 811c578:	4604      	mov	r4, r0
 811c57a:	4608      	mov	r0, r1
 811c57c:	4611      	mov	r1, r2
 811c57e:	2200      	movs	r2, #0
 811c580:	602a      	str	r2, [r5, #0]
 811c582:	461a      	mov	r2, r3
 811c584:	f7e4 fc58 	bl	8100e38 <_lseek>
 811c588:	1c43      	adds	r3, r0, #1
 811c58a:	d102      	bne.n	811c592 <_lseek_r+0x1e>
 811c58c:	682b      	ldr	r3, [r5, #0]
 811c58e:	b103      	cbz	r3, 811c592 <_lseek_r+0x1e>
 811c590:	6023      	str	r3, [r4, #0]
 811c592:	bd38      	pop	{r3, r4, r5, pc}
 811c594:	10008fb8 	.word	0x10008fb8

0811c598 <_read_r>:
 811c598:	b538      	push	{r3, r4, r5, lr}
 811c59a:	4d07      	ldr	r5, [pc, #28]	; (811c5b8 <_read_r+0x20>)
 811c59c:	4604      	mov	r4, r0
 811c59e:	4608      	mov	r0, r1
 811c5a0:	4611      	mov	r1, r2
 811c5a2:	2200      	movs	r2, #0
 811c5a4:	602a      	str	r2, [r5, #0]
 811c5a6:	461a      	mov	r2, r3
 811c5a8:	f7e4 fbe6 	bl	8100d78 <_read>
 811c5ac:	1c43      	adds	r3, r0, #1
 811c5ae:	d102      	bne.n	811c5b6 <_read_r+0x1e>
 811c5b0:	682b      	ldr	r3, [r5, #0]
 811c5b2:	b103      	cbz	r3, 811c5b6 <_read_r+0x1e>
 811c5b4:	6023      	str	r3, [r4, #0]
 811c5b6:	bd38      	pop	{r3, r4, r5, pc}
 811c5b8:	10008fb8 	.word	0x10008fb8

0811c5bc <_sbrk_r>:
 811c5bc:	b538      	push	{r3, r4, r5, lr}
 811c5be:	4d06      	ldr	r5, [pc, #24]	; (811c5d8 <_sbrk_r+0x1c>)
 811c5c0:	2300      	movs	r3, #0
 811c5c2:	4604      	mov	r4, r0
 811c5c4:	4608      	mov	r0, r1
 811c5c6:	602b      	str	r3, [r5, #0]
 811c5c8:	f7e4 fc44 	bl	8100e54 <_sbrk>
 811c5cc:	1c43      	adds	r3, r0, #1
 811c5ce:	d102      	bne.n	811c5d6 <_sbrk_r+0x1a>
 811c5d0:	682b      	ldr	r3, [r5, #0]
 811c5d2:	b103      	cbz	r3, 811c5d6 <_sbrk_r+0x1a>
 811c5d4:	6023      	str	r3, [r4, #0]
 811c5d6:	bd38      	pop	{r3, r4, r5, pc}
 811c5d8:	10008fb8 	.word	0x10008fb8

0811c5dc <_write_r>:
 811c5dc:	b538      	push	{r3, r4, r5, lr}
 811c5de:	4d07      	ldr	r5, [pc, #28]	; (811c5fc <_write_r+0x20>)
 811c5e0:	4604      	mov	r4, r0
 811c5e2:	4608      	mov	r0, r1
 811c5e4:	4611      	mov	r1, r2
 811c5e6:	2200      	movs	r2, #0
 811c5e8:	602a      	str	r2, [r5, #0]
 811c5ea:	461a      	mov	r2, r3
 811c5ec:	f7e4 fbe1 	bl	8100db2 <_write>
 811c5f0:	1c43      	adds	r3, r0, #1
 811c5f2:	d102      	bne.n	811c5fa <_write_r+0x1e>
 811c5f4:	682b      	ldr	r3, [r5, #0]
 811c5f6:	b103      	cbz	r3, 811c5fa <_write_r+0x1e>
 811c5f8:	6023      	str	r3, [r4, #0]
 811c5fa:	bd38      	pop	{r3, r4, r5, pc}
 811c5fc:	10008fb8 	.word	0x10008fb8

0811c600 <abort>:
 811c600:	b508      	push	{r3, lr}
 811c602:	2006      	movs	r0, #6
 811c604:	f000 f82c 	bl	811c660 <raise>
 811c608:	2001      	movs	r0, #1
 811c60a:	f7e4 fbab 	bl	8100d64 <_exit>

0811c60e <_raise_r>:
 811c60e:	291f      	cmp	r1, #31
 811c610:	b538      	push	{r3, r4, r5, lr}
 811c612:	4604      	mov	r4, r0
 811c614:	460d      	mov	r5, r1
 811c616:	d904      	bls.n	811c622 <_raise_r+0x14>
 811c618:	2316      	movs	r3, #22
 811c61a:	6003      	str	r3, [r0, #0]
 811c61c:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 811c620:	bd38      	pop	{r3, r4, r5, pc}
 811c622:	6bc2      	ldr	r2, [r0, #60]	; 0x3c
 811c624:	b112      	cbz	r2, 811c62c <_raise_r+0x1e>
 811c626:	f852 3021 	ldr.w	r3, [r2, r1, lsl #2]
 811c62a:	b94b      	cbnz	r3, 811c640 <_raise_r+0x32>
 811c62c:	4620      	mov	r0, r4
 811c62e:	f000 f831 	bl	811c694 <_getpid_r>
 811c632:	462a      	mov	r2, r5
 811c634:	4601      	mov	r1, r0
 811c636:	4620      	mov	r0, r4
 811c638:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 811c63c:	f000 b818 	b.w	811c670 <_kill_r>
 811c640:	2b01      	cmp	r3, #1
 811c642:	d00a      	beq.n	811c65a <_raise_r+0x4c>
 811c644:	1c59      	adds	r1, r3, #1
 811c646:	d103      	bne.n	811c650 <_raise_r+0x42>
 811c648:	2316      	movs	r3, #22
 811c64a:	6003      	str	r3, [r0, #0]
 811c64c:	2001      	movs	r0, #1
 811c64e:	e7e7      	b.n	811c620 <_raise_r+0x12>
 811c650:	2400      	movs	r4, #0
 811c652:	f842 4025 	str.w	r4, [r2, r5, lsl #2]
 811c656:	4628      	mov	r0, r5
 811c658:	4798      	blx	r3
 811c65a:	2000      	movs	r0, #0
 811c65c:	e7e0      	b.n	811c620 <_raise_r+0x12>
	...

0811c660 <raise>:
 811c660:	4b02      	ldr	r3, [pc, #8]	; (811c66c <raise+0xc>)
 811c662:	4601      	mov	r1, r0
 811c664:	6818      	ldr	r0, [r3, #0]
 811c666:	f7ff bfd2 	b.w	811c60e <_raise_r>
 811c66a:	bf00      	nop
 811c66c:	100001bc 	.word	0x100001bc

0811c670 <_kill_r>:
 811c670:	b538      	push	{r3, r4, r5, lr}
 811c672:	4d07      	ldr	r5, [pc, #28]	; (811c690 <_kill_r+0x20>)
 811c674:	2300      	movs	r3, #0
 811c676:	4604      	mov	r4, r0
 811c678:	4608      	mov	r0, r1
 811c67a:	4611      	mov	r1, r2
 811c67c:	602b      	str	r3, [r5, #0]
 811c67e:	f7e4 fb5f 	bl	8100d40 <_kill>
 811c682:	1c43      	adds	r3, r0, #1
 811c684:	d102      	bne.n	811c68c <_kill_r+0x1c>
 811c686:	682b      	ldr	r3, [r5, #0]
 811c688:	b103      	cbz	r3, 811c68c <_kill_r+0x1c>
 811c68a:	6023      	str	r3, [r4, #0]
 811c68c:	bd38      	pop	{r3, r4, r5, pc}
 811c68e:	bf00      	nop
 811c690:	10008fb8 	.word	0x10008fb8

0811c694 <_getpid_r>:
 811c694:	f7e4 bb4c 	b.w	8100d30 <_getpid>

0811c698 <_init>:
 811c698:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 811c69a:	bf00      	nop
 811c69c:	bcf8      	pop	{r3, r4, r5, r6, r7}
 811c69e:	bc08      	pop	{r3}
 811c6a0:	469e      	mov	lr, r3
 811c6a2:	4770      	bx	lr

0811c6a4 <_fini>:
 811c6a4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 811c6a6:	bf00      	nop
 811c6a8:	bcf8      	pop	{r3, r4, r5, r6, r7}
 811c6aa:	bc08      	pop	{r3}
 811c6ac:	469e      	mov	lr, r3
 811c6ae:	4770      	bx	lr
